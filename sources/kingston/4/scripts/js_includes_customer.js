/*! RESOURCE: /scripts/js_includes_customer.js */
/*! RESOURCE: ScrumReleaseImportGroupDialog */
var ScrumReleaseImportGroupDialog = Class.create();
ScrumReleaseImportGroupDialog.prototype = {
  initialize: function() {
    this.setUpFacade();
  },
  setUpFacade: function() {
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("task_window");
    this._mstrDlg.setTitle(getMessage("Add Members From Group"));
    this._mstrDlg.setBody(this.getMarkUp(), false, false);
  },
  setUpEvents: function() {
    var self = this,
      dialog = this._mstrDlg;
    var okButton = $("ok");
    if (okButton) {
      okButton.on("click", function() {
        var mapData = {};
        if (self.fillDataMap(mapData)) {
          var processor = new GlideAjax("ScrumAjaxAddReleaseTeamMembersProcessor");
          for (var strKey in mapData) {
            processor.addParam(strKey, mapData[strKey]);
          }
          self.showStatus(getMessage("Adding group users..."));
          processor.getXML(function() {
            self.refresh();
            dialog.destroy();
          });
        } else {
          dialog.destroy();
        }
      });
    }
    var cancelButton = $("cancel");
    if (cancelButton) {
      cancelButton.on("click", function() {
        dialog.destroy();
      });
    }
    var okNGButton = $("okNG");
    if (okNGButton) {
      okNGButton.on("click", function() {
        dialog.destroy();
      });
    }
    var cancelNGButton = $("cancelNG");
    if (cancelNGButton) {
      cancelNGButton.on("click", function() {
        dialog.destroy();
      });
    }
  },
  refresh: function() {
    GlideList2.get("scrum_pp_team.scrum_pp_release_team_member.team").refresh();
  },
  getScrumReleaseTeamSysId: function() {
    return g_form.getUniqueValue() + "";
  },
  getUserChosenGroupSysIds: function() {
    return $F('groupId') + "";
  },
  showStatus: function(strMessage) {
    $("task_controls").update(strMessage);
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getRoleIds: function() {
    var arrRoleNames = ["scrum_user", "scrum_admin", "scrum_release_planner", "scrum_sprint_planner", "scrum_story_creator"];
    var arrRoleIds = [];
    var record = new GlideRecord("sys_user_role");
    record.addQuery("name", "IN", arrRoleNames.join(","));
    record.query();
    while (record.next())
      arrRoleIds.push(record.sys_id + "");
    return arrRoleIds;
  },
  hasScrumRole: function(roleSysId, arrScrumRoleSysIds) {
    for (var index = 0; index < arrScrumRoleSysIds.length; ++index)
      if (arrScrumRoleSysIds[index] == "" + roleSysId)
        return true;
    var record = new GlideRecord("sys_user_role_contains");
    record.addQuery("role", roleSysId);
    record.query();
    while (record.next())
      if (this.hasScrumRole(record.contains, arrScrumRoleSysIds))
        return true;
    return false;
  },
  getGroupIds: function() {
    var arrScrumRoleIds = this.getRoleIds();
    var arrGroupIds = [];
    var record = new GlideRecord("sys_group_has_role");
    record.query();
    while (record.next())
      if (this.hasScrumRole(record.role, arrScrumRoleIds))
        arrGroupIds.push(record.group + "");
    return arrGroupIds;
  },
  getGroupInfo: function() {
    var mapGroupInfo = {};
    var arrRoleIds = this.getRoleIds();
    var arrGroupIds = this.getGroupIds(arrRoleIds);
    var record = new GlideRecord("sys_user_group");
    record.addQuery("sys_id", "IN", arrGroupIds.join(","));
    record.query();
    while (record.next()) {
      var strName = record.name + "";
      var strSysId = record.sys_id + "";
      mapGroupInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    return mapGroupInfo;
  },
  getMarkUp: function() {
    var groupAjax = new GlideAjax('ScrumUserGroupsAjax');
    groupAjax.addParam('sysparm_name', 'getGroupInfo');
    groupAjax.getXML(this.generateMarkUp.bind(this));
  },
  generateMarkUp: function(response) {
    var mapGroupInfo = {};
    var groupData = response.responseXML.getElementsByTagName("group");
    var strName, strSysId;
    for (var i = 0; i < groupData.length; i++) {
      strName = groupData[i].getAttribute("name");
      strSysId = groupData[i].getAttribute("sysid");
      mapGroupInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    var arrGroupNames = [];
    for (var strGroupName in mapGroupInfo) {
      arrGroupNames.push(strGroupName + "");
    }
    arrGroupNames.sort();
    var strMarkUp = "";
    if (arrGroupNames.length > 0) {
      var strTable = "<div class='row'><div class='form-group'><span class='col-sm-12'><select class='form-control' id='groupId'>";
      for (var nSlot = 0; nSlot < arrGroupNames.length; ++nSlot) {
        strName = arrGroupNames[nSlot];
        strSysId = mapGroupInfo[strName].sysid;
        strTable += "<option value='" + strSysId + "'>" + strName + "</option>";
      }
      strTable += "</select></span></div></div>";
      strMarkUp = "<div id='task_controls'>" + strTable +
        "<div style='text-align:right;padding-top:20px;'>" +
        "<button id='cancel' class='btn btn-default' type='button'>" + getMessage("Cancel") + "</button>" +
        "&nbsp;&nbsp;<button id='ok' class='btn btn-primary' type='button'>" + getMessage("OK") + "</button>" +
        "</div></div>";
    } else {
      strMarkUp = "<div id='task_controls'><p>No groups with scrum_user role found</p>" +
        "<div style='text-align: right;padding-top:20px;'>" +
        "<button id='cancelNG' class='btn btn-default' type='button'>" + getMessage("Cancel") + "</button>" +
        "&nbsp;&nbsp;<button id='okNG' class='btn btn-primary' type='button'>" + getMessage("OK") + "</button>" +
        "</div></div>";
    }
    this._mstrDlg.setBody(strMarkUp, false, false);
    this.setUpEvents();
    this.display(true);
  },
  fillDataMap: function(mapData) {
    var strChosenGroupSysId = this.getUserChosenGroupSysIds();
    if (strChosenGroupSysId) {
      mapData.sysparm_name = "createReleaseTeamMembers";
      mapData.sysparm_sys_id = this.getScrumReleaseTeamSysId();
      mapData.sysparm_groups = strChosenGroupSysId;
      return true;
    } else {
      return false;
    }
  }
};
/*! RESOURCE: ITGDN - getMyRequests */
function getMyRequests(order_by, order_dir, start, end, page, limiter, req_state) {
  var gajax = new GlideAjax("itgdnUtils");
  $j.session.set('request_order_by', order_by);
  $j.session.set('request_order_dir', order_dir);
  $j.session.set('request_start', start);
  $j.session.set('request_end', end);
  $j.session.set('request_page', page);
  $j.session.set('request_req_state', req_state);
  gajax.addParam("order_by", order_by);
  gajax.addParam("order_dir", order_dir);
  gajax.addParam("start", start);
  gajax.addParam("end", end);
  gajax.addParam("limiter", limiter);
  gajax.addParam("req_state", req_state);
  gajax.addParam("sysparm_name", "getRequests");
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    var meta = serverResponse.responseXML.getElementsByTagName("meta");
    if (data.length > 0) {
      var sClass = '';
      var sHref = '';
      var orderBy = meta[0].getAttribute("order_by").toString();
      var orderDir = meta[0].getAttribute("order_dir").toString();
      var order_dir_class = orderDir == 'ASC' ? 'ASC' : 'DESC';
      var rowCount = meta[0].getAttribute("rowCount").toString();
      var pageParam = getURLParameter('page');
      if (pageParam == undefined) {
        pageParam = page;
        if (pageParam < 1)
          pageParam = 1;
      }
      var curPage = parseInt(pageParam);
      var prevPage = parseInt(pageParam) - 1;
      var nextPage = parseInt(pageParam) + 1;
      var countPages = Math.ceil((parseInt(rowCount) / limiter) * 1) / 1;
      var count = 1;
      if (getURLParameter('breadcrumb') != 'true') {}
      if ((req_state == 'empty' && $j.session.get('request_req_state') == 'closed') || (req_state == 'closed')) {
        var request_state = '&req_state=closed';
      } else {
        var request_state = '';
      }
      output = '';
      output += "<table class='callsTable' id='data-table' border='0' cellpadding='10' cellspacing='0'><thead><tr>";
      output += "<th scope='col' style='width:16px;'> </th>";
      sClass = orderBy == "opened_at" ? order_dir_class : "";
      sHref = 'request.do?page=' + curPage + '&order_by=opened_at' + request_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_opened_at") + '</a></th>';
      sClass = orderBy == "number" ? order_dir_class : "";
      sHref = 'request.do?page=' + curPage + '&order_by=number' + request_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_number") + '</a></th>';
      sClass = orderBy == "short_description" ? order_dir_class : "";
      sHref = 'request.do?page=' + curPage + '&order_by=short_description' + request_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_short_description") + '</a></th>';
      sClass = orderBy == "category" ? order_dir_class : "";
      sHref = 'request.do?page=' + curPage + '&order_by=category' + request_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_category") + '</a></th>';
      sClass = orderBy == "u_call_state" ? order_dir_class : "";
      sHref = 'request.do?page=' + curPage + '&order_by=incident_state' + request_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_state") + '</a></th>';
      output += '</tr></thead><tbody id="data">';
      for (var i = 0; i < data.length; i++) {
        var evenOrOdd = i % 2 == 0 ? 'even' : 'odd';
        output += '<tr class="' + evenOrOdd + '">';
        output += '<td><img class="clickableImage" title="Toggle description" src="images/list_v2_heir_hide.gifx" onclick="toggleTRVisibility(this)" id="imgFor' + data[i].getAttribute("sys_id").toString() + '"></td>';
        output += '<td class="date" style="width:65px;">' + data[i].getAttribute("opened_at").toString() + '</td>';
        output += '<td class="number" style="width:75px;"><a href="status_detail.do?sys_id=' + data[i].getAttribute("sys_id").toString() + '&sysparm_view=ess' + request_state + '&source=request">' + data[i].getAttribute("number").toString() + '<a/></td>';
        output += '<td class="title" style="width:135px;">' + data[i].getAttribute("short_description").toString() + '</td>';
        output += '<td class="phase" style="width:65px;">' + data[i].getAttribute("category").toString() + '</td>';
        output += '<td class="state" style="width:65px;">' + data[i].getAttribute("state").toString() + '</td>';
        output += '</tr>';
        output += '<tr class="toggleTR" style="display:none;">';
        output += '<td colspan="5"><strong>Description:</strong> ' + data[i].getAttribute("description").toString() + '</td>';
        output += '</tr>';
        count++;
      }
      output += '</tbody></table>';
      if (countPages > 1) {
        output += '<div class="pager">';
        output += '<ul><div class="liWrap">';
        var startCount = 1;
        var endCount = countPages;
        if (countPages > 10) {
          startCount = (curPage - 5) > 0 ? (curPage - 5) : 1;
          endCount = (curPage + 5) <= countPages ? (curPage + 5) : countPages;
        }
        if (curPage > 1) {
          output += '<li class="first"><a href="request.do?page=1&order_by=' + orderBy + '&order_dir=' + orderDir + '">First</a></li>';
          output += '<li class="more"><a href="request.do?page=' + prevPage + '&order_by=' + orderBy + '&order_dir=' + orderDir + '"><<</a></li>';
          if (startCount > 1) {
            output += '<li class=""><a href="request.do?page=1&order_by=' + orderBy + '' + request_state + '&order_dir=' + orderDir + '">1</a></li>';
            output += '<li>...</li>';
          }
        } else {
          output += '<li class="first"><span class="notClickable">First</span></li>';
          output += '<li class="more"><span class="notClickable"><<</span></li>';
        }
        for (var i = startCount; i <= endCount; i++) {
          var activeClass = '';
          if (curPage == i)
            activeClass = 'active';
          output += '<li class="' + activeClass + '"><a href="request.do?page=' + i + '&order_by=' + orderBy + '' + request_state + '&order_dir=' + orderDir + '">' + i + '</a></li>';
        }
        if (countPages >= nextPage) {
          if (endCount < countPages) {
            output += '<li>...</li>';
            output += '<li class=""><a href="request.do?page=' + countPages + '&order_by=' + orderBy + '' + request_state + '&order_dir=' + orderDir + '">' + countPages + '</a></li>';
          }
          output += '<li class="more"><a href="request.do?page=' + nextPage + '&order_by=' + orderBy + '' + request_state + '&order_dir=' + orderDir + '">>></a></li>';
          output += '<li class="last"><a href="request.do?page=' + countPages + '&order_by=' + orderBy + '' + request_state + '&order_dir=' + orderDir + '">Last</a></li>';
        } else {
          output += '<li class="more"><span class="notClickable">>></span></li>';
          output += '<li class="last"><span class="notClickable">Last</span></li>';
        }
        output += '</div></ul>';
        output += '</div>';
      }
      $j("div#wrapper").html(output);
    }
  }
}
/*! RESOURCE: ITGDN - insertNewKnowledgeFeedback */
function insertMyNewKnowledgeFeedback(articleId, rating, useful, comment) {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "insertNewKnowledgeFeedback");
  gajax.addParam("rating", rating);
  gajax.addParam("used", useful);
  gajax.addParam("comment", comment);
  gajax.addParam("article_id", articleId);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    $j.fancybox.close();
    setTimeout("$j('#knowledgeFeedback form')[0].reset();", 500);
  }
}
/*! RESOURCE: docxtemplater.v2.1.5.norm.js */
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f()
  } else if (typeof define === "function" && define.amd) {
    define([], f)
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window
    } else if (typeof global !== "undefined") {
      g = global
    } else if (typeof self !== "undefined") {
      g = self
    } else {
      g = this
    }
    g.Docxgen = f()
  }
})(function() {
  var define, module, exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f
        }
        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e)
        }, l, l.exports, e, t, n, r)
      }
      return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
  })({
    1: [function(require, module, exports) {
      (function(global) {
        var base64 = require('base64-js')
        var ieee754 = require('ieee754')
        var isArray = require('is-array')
        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192
        var rootParent = {}
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ?
          global.TYPED_ARRAY_SUPPORT :
          typedArraySupport()

        function typedArraySupport() {
          function Bar() {}
          try {
            var arr = new Uint8Array(1)
            arr.foo = function() {
              return 42
            }
            arr.constructor = Bar
            return arr.foo() === 42 &&
              arr.constructor === Bar &&
              typeof arr.subarray === 'function' &&
              arr.subarray(1, 1).byteLength === 0
          } catch (e) {
            return false
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ?
            0x7fffffff :
            0x3fffffff
        }

        function Buffer(arg) {
          if (!(this instanceof Buffer)) {
            if (arguments.length > 1) return new Buffer(arg, arguments[1])
            return new Buffer(arg)
          }
          this.length = 0
          this.parent = undefined
          if (typeof arg === 'number') {
            return fromNumber(this, arg)
          }
          if (typeof arg === 'string') {
            return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
          }
          return fromObject(this, arg)
        }

        function fromNumber(that, length) {
          that = allocate(that, length < 0 ? 0 : checked(length) | 0)
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < length; i++) {
              that[i] = 0
            }
          }
          return that
        }

        function fromString(that, string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
          var length = byteLength(string, encoding) | 0
          that = allocate(that, length)
          that.write(string, encoding)
          return that
        }

        function fromObject(that, object) {
          if (Buffer.isBuffer(object)) return fromBuffer(that, object)
          if (isArray(object)) return fromArray(that, object)
          if (object == null) {
            throw new TypeError('must start with number, buffer, array or string')
          }
          if (typeof ArrayBuffer !== 'undefined') {
            if (object.buffer instanceof ArrayBuffer) {
              return fromTypedArray(that, object)
            }
            if (object instanceof ArrayBuffer) {
              return fromArrayBuffer(that, object)
            }
          }
          if (object.length) return fromArrayLike(that, object)
          return fromJsonObject(that, object)
        }

        function fromBuffer(that, buffer) {
          var length = checked(buffer.length) | 0
          that = allocate(that, length)
          buffer.copy(that, 0, 0, length)
          return that
        }

        function fromArray(that, array) {
          var length = checked(array.length) | 0
          that = allocate(that, length)
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromTypedArray(that, array) {
          var length = checked(array.length) | 0
          that = allocate(that, length)
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromArrayBuffer(that, array) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            array.byteLength
            that = Buffer._augment(new Uint8Array(array))
          } else {
            that = fromTypedArray(that, new Uint8Array(array))
          }
          return that
        }

        function fromArrayLike(that, array) {
          var length = checked(array.length) | 0
          that = allocate(that, length)
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromJsonObject(that, object) {
          var array
          var length = 0
          if (object.type === 'Buffer' && isArray(object.data)) {
            array = object.data
            length = checked(array.length) | 0
          }
          that = allocate(that, length)
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype
          Buffer.__proto__ = Uint8Array
        }

        function allocate(that, length) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            that = Buffer._augment(new Uint8Array(length))
            that.__proto__ = Buffer.prototype
          } else {
            that.length = length
            that._isBuffer = true
          }
          var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
          if (fromPool) that.parent = rootParent
          return that
        }

        function checked(length) {
          if (length >= kMaxLength()) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
              'size: 0x' + kMaxLength().toString(16) + ' bytes')
          }
          return length | 0
        }

        function SlowBuffer(subject, encoding) {
          if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
          var buf = new Buffer(subject, encoding)
          delete buf.parent
          return buf
        }
        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer)
        }
        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('Arguments must be Buffers')
          }
          if (a === b) return 0
          var x = a.length
          var y = b.length
          var i = 0
          var len = Math.min(x, y)
          while (i < len) {
            if (a[i] !== b[i]) break
              ++i
          }
          if (i !== len) {
            x = a[i]
            y = b[i]
          }
          if (x < y) return -1
          if (y < x) return 1
          return 0
        }
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true
            default:
              return false
          }
        }
        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
          if (list.length === 0) {
            return new Buffer(0)
          }
          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; i++) {
              length += list[i].length
            }
          }
          var buf = new Buffer(length)
          var pos = 0
          for (i = 0; i < list.length; i++) {
            var item = list[i]
            item.copy(buf, pos)
            pos += item.length
          }
          return buf
        }

        function byteLength(string, encoding) {
          if (typeof string !== 'string') string = '' + string
          var len = string.length
          if (len === 0) return 0
          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case 'ascii':
              case 'binary':
              case 'raw':
              case 'raws':
                return len
              case 'utf8':
              case 'utf-8':
                return utf8ToBytes(string).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2
              case 'hex':
                return len >>> 1
              case 'base64':
                return base64ToBytes(string).length
              default:
                if (loweredCase) return utf8ToBytes(string).length
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength
        Buffer.prototype.length = undefined
        Buffer.prototype.parent = undefined

        function slowToString(encoding, start, end) {
          var loweredCase = false
          start = start | 0
          end = end === undefined || end === Infinity ? this.length : end | 0
          if (!encoding) encoding = 'utf8'
          if (start < 0) start = 0
          if (end > this.length) end = this.length
          if (end <= start) return ''
          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end)
              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end)
              case 'ascii':
                return asciiSlice(this, start, end)
              case 'binary':
                return binarySlice(this, start, end)
              case 'base64':
                return base64Slice(this, start, end)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end)
              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = (encoding + '').toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.prototype.toString = function toString() {
          var length = this.length | 0
          if (length === 0) return ''
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }
        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }
        Buffer.prototype.inspect = function inspect() {
          var str = ''
          var max = exports.INSPECT_MAX_BYTES
          if (this.length > 0) {
            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
            if (this.length > max) str += ' ... '
          }
          return '<Buffer ' + str + '>'
        }
        Buffer.prototype.compare = function compare(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
          if (this === b) return 0
          return Buffer.compare(this, b)
        }
        Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
          if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
          else if (byteOffset < -0x80000000) byteOffset = -0x80000000
          byteOffset >>= 0
          if (this.length === 0) return -1
          if (byteOffset >= this.length) return -1
          if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
          if (typeof val === 'string') {
            if (val.length === 0) return -1
            return String.prototype.indexOf.call(this, val, byteOffset)
          }
          if (Buffer.isBuffer(val)) {
            return arrayIndexOf(this, val, byteOffset)
          }
          if (typeof val === 'number') {
            if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
              return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
            }
            return arrayIndexOf(this, [val], byteOffset)
          }

          function arrayIndexOf(arr, val, byteOffset) {
            var foundIndex = -1
            for (var i = 0; byteOffset + i < arr.length; i++) {
              if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
              } else {
                foundIndex = -1
              }
            }
            return -1
          }
          throw new TypeError('val must be string, number or Buffer')
        }
        Buffer.prototype.get = function get(offset) {
          console.log('.get() is deprecated. Access using array indexes instead.')
          return this.readUInt8(offset)
        }
        Buffer.prototype.set = function set(v, offset) {
          console.log('.set() is deprecated. Access using array indexes instead.')
          return this.writeUInt8(v, offset)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }
          var strLen = string.length
          if (strLen % 2 !== 0) throw new Error('Invalid hex string')
          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; i++) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (isNaN(parsed)) throw new Error('Invalid hex string')
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function binaryWrite(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
          if (offset === undefined) {
            encoding = 'utf8'
            length = this.length
            offset = 0
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset
            length = this.length
            offset = 0
          } else if (isFinite(offset)) {
            offset = offset | 0
            if (isFinite(length)) {
              length = length | 0
              if (encoding === undefined) encoding = 'utf8'
            } else {
              encoding = length
              length = undefined
            }
          } else {
            var swap = encoding
            encoding = offset
            offset = length | 0
            length = swap
          }
          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining
          if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
            throw new RangeError('attempt to write outside buffer bounds')
          }
          if (!encoding) encoding = 'utf8'
          var loweredCase = false
          for (;;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length)
              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length)
              case 'ascii':
                return asciiWrite(this, string, offset, length)
              case 'binary':
                return binaryWrite(this, string, offset, length)
              case 'base64':
                return base64Write(this, string, offset, length)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length)
              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []
          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence = (firstByte > 0xEF) ? 4 :
              (firstByte > 0xDF) ? 3 :
              (firstByte > 0xBF) ? 2 :
              1
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 0xFFFD
              bytesPerSequence = 1
            } else if (codePoint > 0xFFFF) {
              codePoint -= 0x10000
              res.push(codePoint >>> 10 & 0x3FF | 0xD800)
              codePoint = 0xDC00 | codePoint & 0x3FF
            }
            res.push(codePoint)
            i += bytesPerSequence
          }
          return decodeCodePointsArray(res)
        }
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints)
          }
          var res = ''
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i] & 0x7F)
          }
          return ret
        }

        function binarySlice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length
          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len
          var out = ''
          for (var i = start; i < end; i++) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ''
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end
          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }
          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }
          if (end < start) end = start
          var newBuf
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = Buffer._augment(this.subarray(start, end))
          } else {
            var sliceLen = end - start
            newBuf = new Buffer(sliceLen, undefined)
            for (var i = 0; i < sliceLen; i++) {
              newBuf[i] = this[i + start]
            }
          }
          if (newBuf.length) newBuf.parent = this.parent || this
          return newBuf
        }

        function checkOffset(offset, ext, length) {
          if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)
          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          return val
        }
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }
          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }
          return val
        }
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ((this[offset]) |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
        }
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return (this[offset] * 0x1000000) +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
        }
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)
          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80
          if (val >= mul) val -= Math.pow(2, 8 * byteLength)
          return val
        }
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)
          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80
          if (val >= mul) val -= Math.pow(2, 8 * byteLength)
          return val
        }
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return (this[offset])
          return ((0xff - this[offset] + 1) * -1)
        }
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return (this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
        }
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            (this[offset + 3])
        }
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
          if (value > max || value < min) throw new RangeError('value is out of bounds')
          if (offset + ext > buf.length) throw new RangeError('index out of range')
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
          var mul = 1
          var i = 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }
          return offset + byteLength
        }
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset | 0
          byteLength = byteLength | 0
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }
          return offset + byteLength
        }
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
          this[offset] = (value & 0xff)
          return offset + 1
        }

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
              (littleEndian ? i : 1 - i) * 8
          }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        }
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 8)
            this[offset + 1] = (value & 0xff)
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        }

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
            buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
          }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = (value >>> 24)
            this[offset + 2] = (value >>> 16)
            this[offset + 1] = (value >>> 8)
            this[offset] = (value & 0xff)
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        }
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = (value & 0xff)
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        }
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = 0
          var mul = 1
          var sub = value < 0 ? 1 : 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }
          return offset + byteLength
        }
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1)
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = byteLength - 1
          var mul = 1
          var sub = value < 0 ? 1 : 0
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }
          return offset + byteLength
        }
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
          if (value < 0) value = 0xff + value + 1
          this[offset] = (value & 0xff)
          return offset + 1
        }
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        }
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 8)
            this[offset + 1] = (value & 0xff)
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        }
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value & 0xff)
            this[offset + 1] = (value >>> 8)
            this[offset + 2] = (value >>> 16)
            this[offset + 3] = (value >>> 24)
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        }
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset | 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = (value & 0xff)
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (value > max || value < min) throw new RangeError('value is out of bounds')
          if (offset + ext > buf.length) throw new RangeError('index out of range')
          if (offset < 0) throw new RangeError('index out of range')
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert)
        }
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert)
        }
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert)
        }
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0
          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds')
          }
          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
          if (end < 0) throw new RangeError('sourceEnd out of bounds')
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }
          var len = end - start
          var i
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; i--) {
              target[i + targetStart] = this[i + start]
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; i++) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            target._set(this.subarray(start, start + len), targetStart)
          }
          return len
        }
        Buffer.prototype.fill = function fill(value, start, end) {
          if (!value) value = 0
          if (!start) start = 0
          if (!end) end = this.length
          if (end < start) throw new RangeError('end < start')
          if (end === start) return
          if (this.length === 0) return
          if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
          if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
          var i
          if (typeof value === 'number') {
            for (i = start; i < end; i++) {
              this[i] = value
            }
          } else {
            var bytes = utf8ToBytes(value.toString())
            var len = bytes.length
            for (i = start; i < end; i++) {
              this[i] = bytes[i % len]
            }
          }
          return this
        }
        Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
          if (typeof Uint8Array !== 'undefined') {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              return (new Buffer(this)).buffer
            } else {
              var buf = new Uint8Array(this.length)
              for (var i = 0, len = buf.length; i < len; i += 1) {
                buf[i] = this[i]
              }
              return buf.buffer
            }
          } else {
            throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
          }
        }
        var BP = Buffer.prototype
        Buffer._augment = function _augment(arr) {
          arr.constructor = Buffer
          arr._isBuffer = true
          arr._set = arr.set
          arr.get = BP.get
          arr.set = BP.set
          arr.write = BP.write
          arr.toString = BP.toString
          arr.toLocaleString = BP.toString
          arr.toJSON = BP.toJSON
          arr.equals = BP.equals
          arr.compare = BP.compare
          arr.indexOf = BP.indexOf
          arr.copy = BP.copy
          arr.slice = BP.slice
          arr.readUIntLE = BP.readUIntLE
          arr.readUIntBE = BP.readUIntBE
          arr.readUInt8 = BP.readUInt8
          arr.readUInt16LE = BP.readUInt16LE
          arr.readUInt16BE = BP.readUInt16BE
          arr.readUInt32LE = BP.readUInt32LE
          arr.readUInt32BE = BP.readUInt32BE
          arr.readIntLE = BP.readIntLE
          arr.readIntBE = BP.readIntBE
          arr.readInt8 = BP.readInt8
          arr.readInt16LE = BP.readInt16LE
          arr.readInt16BE = BP.readInt16BE
          arr.readInt32LE = BP.readInt32LE
          arr.readInt32BE = BP.readInt32BE
          arr.readFloatLE = BP.readFloatLE
          arr.readFloatBE = BP.readFloatBE
          arr.readDoubleLE = BP.readDoubleLE
          arr.readDoubleBE = BP.readDoubleBE
          arr.writeUInt8 = BP.writeUInt8
          arr.writeUIntLE = BP.writeUIntLE
          arr.writeUIntBE = BP.writeUIntBE
          arr.writeUInt16LE = BP.writeUInt16LE
          arr.writeUInt16BE = BP.writeUInt16BE
          arr.writeUInt32LE = BP.writeUInt32LE
          arr.writeUInt32BE = BP.writeUInt32BE
          arr.writeIntLE = BP.writeIntLE
          arr.writeIntBE = BP.writeIntBE
          arr.writeInt8 = BP.writeInt8
          arr.writeInt16LE = BP.writeInt16LE
          arr.writeInt16BE = BP.writeInt16BE
          arr.writeInt32LE = BP.writeInt32LE
          arr.writeInt32BE = BP.writeInt32BE
          arr.writeFloatLE = BP.writeFloatLE
          arr.writeFloatBE = BP.writeFloatBE
          arr.writeDoubleLE = BP.writeDoubleLE
          arr.writeDoubleBE = BP.writeDoubleBE
          arr.fill = BP.fill
          arr.inspect = BP.inspect
          arr.toArrayBuffer = BP.toArrayBuffer
          return arr
        }
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, '')
          if (str.length < 2) return ''
          while (str.length % 4 !== 0) {
            str = str + '='
          }
          return str
        }

        function stringtrim(str) {
          if (str.trim) return str.trim()
          return str.replace(/^\s+|\s+$/g, '')
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []
          for (var i = 0; i < length; i++) {
            codePoint = string.charCodeAt(i)
            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              if (!leadSurrogate) {
                if (codePoint > 0xDBFF) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                }
                leadSurrogate = codePoint
                continue
              }
              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                leadSurrogate = codePoint
                continue
              }
              codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            }
            leadSurrogate = null
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push(
                codePoint >> 0x6 | 0xC0,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                codePoint >> 0xC | 0xE0,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                codePoint >> 0x12 | 0xF0,
                codePoint >> 0xC & 0x3F | 0x80,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else {
              throw new Error('Invalid code point')
            }
          }
          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 0xFF)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; i++) {
            if ((units -= 2) < 0) break
            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }
          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; i++) {
            if ((i + offset >= dst.length) || (i >= src.length)) break
            dst[i + offset] = src[i]
          }
          return i
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
      "base64-js": 2,
      "ieee754": 3,
      "is-array": 4
    }],
    2: [function(require, module, exports) {
      var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';;
      (function(exports) {
        'use strict';
        var Arr = (typeof Uint8Array !== 'undefined') ?
          Uint8Array :
          Array
        var PLUS = '+'.charCodeAt(0)
        var SLASH = '/'.charCodeAt(0)
        var NUMBER = '0'.charCodeAt(0)
        var LOWER = 'a'.charCodeAt(0)
        var UPPER = 'A'.charCodeAt(0)
        var PLUS_URL_SAFE = '-'.charCodeAt(0)
        var SLASH_URL_SAFE = '_'.charCodeAt(0)

        function decode(elt) {
          var code = elt.charCodeAt(0)
          if (code === PLUS ||
            code === PLUS_URL_SAFE)
            return 62
          if (code === SLASH ||
            code === SLASH_URL_SAFE)
            return 63
          if (code < NUMBER)
            return -1
          if (code < NUMBER + 10)
            return code - NUMBER + 26 + 26
          if (code < UPPER + 26)
            return code - UPPER
          if (code < LOWER + 26)
            return code - LOWER + 26
        }

        function b64ToByteArray(b64) {
          var i, j, l, tmp, placeHolders, arr
          if (b64.length % 4 > 0) {
            throw new Error('Invalid string. Length must be a multiple of 4')
          }
          var len = b64.length
          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
          arr = new Arr(b64.length * 3 / 4 - placeHolders)
          l = placeHolders > 0 ? b64.length - 4 : b64.length
          var L = 0

          function push(v) {
            arr[L++] = v
          }
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
            push((tmp & 0xFF0000) >> 16)
            push((tmp & 0xFF00) >> 8)
            push(tmp & 0xFF)
          }
          if (placeHolders === 2) {
            tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
            push(tmp & 0xFF)
          } else if (placeHolders === 1) {
            tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
            push((tmp >> 8) & 0xFF)
            push(tmp & 0xFF)
          }
          return arr
        }

        function uint8ToBase64(uint8) {
          var i,
            extraBytes = uint8.length % 3,
            output = "",
            temp, length

          function encode(num) {
            return lookup.charAt(num)
          }

          function tripletToBase64(num) {
            return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
          }
          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
            output += tripletToBase64(temp)
          }
          switch (extraBytes) {
            case 1:
              temp = uint8[uint8.length - 1]
              output += encode(temp >> 2)
              output += encode((temp << 4) & 0x3F)
              output += '=='
              break
            case 2:
              temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
              output += encode(temp >> 10)
              output += encode((temp >> 4) & 0x3F)
              output += encode((temp << 2) & 0x3F)
              output += '='
              break
          }
          return output
        }
        exports.toByteArray = b64ToByteArray
        exports.fromByteArray = uint8ToBase64
      }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))
    }, {}],
    3: [function(require, module, exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var nBits = -7
        var i = isLE ? (nBytes - 1) : 0
        var d = isLE ? -1 : 1
        var s = buffer[offset + i]
        i += d
        e = s & ((1 << (-nBits)) - 1)
        s >>= (-nBits)
        nBits += eLen
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & ((1 << (-nBits)) - 1)
        e >>= (-nBits)
        nBits += mLen
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias
        } else if (e === eMax) {
          return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
          m = m + Math.pow(2, mLen)
          e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
      }
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
        var i = isLE ? 0 : (nBytes - 1)
        var d = isLE ? 1 : -1
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
        value = Math.abs(value)
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0
          e = eMax
        } else {
          e = Math.floor(Math.log(value) / Math.LN2)
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--
            c *= 2
          }
          if (e + eBias >= 1) {
            value += rt / c
          } else {
            value += rt * Math.pow(2, 1 - eBias)
          }
          if (value * c >= 2) {
            e++
            c /= 2
          }
          if (e + eBias >= eMax) {
            m = 0
            e = eMax
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen)
            e = e + eBias
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
            e = 0
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
        e = (e << mLen) | m
        eLen += mLen
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128
      }
    }, {}],
    4: [function(require, module, exports) {
      var isArray = Array.isArray;
      var str = Object.prototype.toString;
      module.exports = isArray || function(val) {
        return !!val && '[object Array]' == str.call(val);
      };
    }, {}],
    5: [function(require, module, exports) {
      "use strict";

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var Errors = require("./errors");
      var memoize = require("memoizejs");
      var DocUtils = {};

      function parser(tag) {
        return _defineProperty({}, "get", function get(scope) {
          if (tag === ".") {
            return scope;
          }
          return scope[tag];
        });
      }
      DocUtils.defaults = {
        nullGetter: function nullGetter(tag, props) {
          if (props.tag === "simple") {
            return "undefined";
          }
          if (props.tag === "raw") {
            return "";
          }
          return "";
        },
        parser: memoize(parser),
        intelligentTagging: true,
        fileType: "docx",
        delimiters: {
          start: "{",
          end: "}"
        }
      };
      DocUtils.charMap = {
        "&": "&amp;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;"
      };
      DocUtils.escapeRegExp = function(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
      };
      DocUtils.charMapRegexes = Object.keys(DocUtils.charMap).map(function(endChar) {
        var startChar = DocUtils.charMap[endChar];
        return {
          rstart: new RegExp(DocUtils.escapeRegExp(startChar), "g"),
          rend: new RegExp(DocUtils.escapeRegExp(endChar), "g"),
          start: startChar,
          end: endChar
        };
      });
      DocUtils.wordToUtf8 = function(string) {
        if (typeof string !== "string") {
          string = string.toString();
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rstart, r.end);
        }
        return string;
      };
      DocUtils.utf8ToWord = function(string) {
        if (typeof string !== "string") {
          string = string.toString();
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rend, r.start);
        }
        return string;
      };
      DocUtils.cloneDeep = function(obj) {
        return JSON.parse(JSON.stringify(obj));
      };
      var spaceRegexp = new RegExp(String.fromCharCode(160), "g");
      DocUtils.convertSpaces = function(s) {
        return s.replace(spaceRegexp, " ");
      };
      DocUtils.pregMatchAll = function(regex, content) {
        var matchArray = [];

        function replacer() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          return matchArray.push(pn);
        }
        content.replace(regex, replacer);
        return matchArray;
      };
      DocUtils.sizeOfObject = function(obj) {
        return Object.keys(obj).length;
      };
      DocUtils.encode_utf8 = function(s) {
        return unescape(encodeURIComponent(s));
      };
      DocUtils.decode_utf8 = function(s) {
        try {
          if (s === undefined) {
            return undefined;
          }
          return decodeURIComponent(escape(DocUtils.convert_spaces(s)));
        } catch (e) {
          var err = new Errors.XTError("Could not decode utf8");
          err.properties = {
            toDecode: s,
            baseErr: e
          };
          throw err;
        }
      };
      DocUtils.base64encode = function(b) {
        return btoa(unescape(encodeURIComponent(b)));
      };
      DocUtils.tags = DocUtils.defaults.delimiters;
      DocUtils.defaultParser = DocUtils.defaults.parser;
      DocUtils.convert_spaces = DocUtils.convertSpaces;
      DocUtils.preg_match_all = DocUtils.pregMatchAll;
      module.exports = DocUtils;
    }, {
      "./errors": 6,
      "memoizejs": 39
    }],
    6: [function(require, module, exports) {
      "use strict";

      function XTError(message) {
        this.name = "GenericError";
        this.message = message;
        this.stack = new Error(message).stack;
      }
      XTError.prototype = Error.prototype;

      function XTTemplateError(message) {
        this.name = "TemplateError";
        this.message = message;
        this.stack = new Error(message).stack;
      }
      XTTemplateError.prototype = new XTError();

      function XTScopeParserError(message) {
        this.name = "ScopeParserError";
        this.message = message;
        this.stack = new Error(message).stack;
      }
      XTScopeParserError.prototype = new XTError();

      function XTInternalError(message) {
        this.name = "InternalError";
        this.properties = {
          explanation: "InternalError"
        };
        this.message = message;
        this.stack = new Error(message).stack;
      }
      XTInternalError.prototype = new XTError();
      module.exports = {
        XTError: XTError,
        XTTemplateError: XTTemplateError,
        XTInternalError: XTInternalError,
        XTScopeParserError: XTScopeParserError
      };
    }, {}],
    7: [function(require, module, exports) {
      "use strict";
      var xmlUtil = require("./xmlUtil");
      var SubContent = require("./subContent");
      var PptXFileTypeConfig = {
        textPath: "ppt/slides/slide1.xml",
        tagsXmlArray: ["a:t", "m:t"],
        tagRawXml: "p:sp",
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file) {
            return file.name;
          });
          return slideTemplates.concat(["ppt/presentation.xml"]);
        },
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<a:tc>") {
              return "a:tr";
            }
          }
          return false;
        }
      };
      var DocXFileTypeConfig = {
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/word\/(header|footer)\d+\.xml/).map(function(file) {
            return file.name;
          });
          return slideTemplates.concat(["word/document.xml"]);
        },
        textPath: "word/document.xml",
        tagsXmlArray: ["w:t", "m:t"],
        tagRawXml: "w:p",
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<w:tc>") {
              return "w:tr";
            }
          }
          return false;
        }
      };
      module.exports = {
        docx: DocXFileTypeConfig,
        pptx: PptXFileTypeConfig
      };
    }, {
      "./subContent": 10,
      "./xmlUtil": 14
    }],
    8: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module.exports = function() {
        function ModuleManager() {
          _classCallCheck(this, ModuleManager);
          var instances = {};
          this.getInstance = function(obj) {
            return instances[obj];
          };
          this.setInstance = function(key, value) {
            instances[key] = value;
          };
          this.modules = [];
        }
        _createClass(ModuleManager, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.modules.push(module);
            module.manager = this;
            return this;
          }
        }, {
          key: "sendEvent",
          value: function sendEvent(eventName, data) {
            return this.modules.map(function(m) {
              return m.handleEvent(eventName, data);
            });
          }
        }, {
          key: "get",
          value: function get(value) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              var aux = m.get(value);
              result = aux != null ? aux : result;
            }
            return result;
          }
        }, {
          key: "handle",
          value: function handle(type, data) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              if (result != null) {
                return;
              }
              var aux = m.handle(type, data);
              result = aux != null ? aux : result;
            }
            return result;
          }
        }]);
        return ModuleManager;
      }();
    }, {}],
    9: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Errors = require("./errors");
      var DocUtils = require("./docUtils");
      module.exports = function() {
        function ScopeManager(options) {
          _classCallCheck(this, ScopeManager);
          this.scopePath = options.scopePath;
          this.usedTags = options.usedTags;
          this.scopeList = options.scopeList;
          this.parser = options.parser;
          this.moduleManager = options.moduleManager;
          this.moduleManager.setInstance("scopeManager", this);
        }
        _createClass(ScopeManager, [{
          key: "loopOver",
          value: function loopOver(tag, callback, inverted) {
            inverted = inverted || false;
            var value = this.getValue(tag);
            return this.loopOverValue(value, callback, inverted);
          }
        }, {
          key: "functorIfInverted",
          value: function functorIfInverted(inverted, functor, value) {
            if (inverted) {
              functor(value);
            }
          }
        }, {
          key: "isValueFalsy",
          value: function isValueFalsy(value, type) {
            return value == null || !value || type === "[object Array]" && value.length === 0;
          }
        }, {
          key: "loopOverValue",
          value: function loopOverValue(value, functor, inverted) {
            var type = Object.prototype.toString.call(value);
            var currentValue = this.scopeList[this.num];
            if (this.isValueFalsy(value, type)) {
              return this.functorIfInverted(inverted, functor, currentValue);
            }
            if (type === "[object Array]") {
              for (var i = 0, scope; i < value.length; i++) {
                scope = value[i];
                this.functorIfInverted(!inverted, functor, scope);
              }
              return;
            }
            if (type === "[object Object]") {
              return this.functorIfInverted(!inverted, functor, value);
            }
            if (value === true) {
              return this.functorIfInverted(!inverted, functor, currentValue);
            }
          }
        }, {
          key: "getValue",
          value: function getValue(tag, num) {
            this.num = num == null ? this.scopeList.length - 1 : num;
            var err;
            var parser;
            var result;
            var scope = this.scopeList[this.num];
            try {
              parser = this.parser(tag);
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser compilation failed");
              err.properties = {
                id: "scopeparser_compilation_failed",
                tag: tag,
                explanation: "The scope parser for the tag " + tag + " failed to compile"
              };
              throw err;
            }
            try {
              result = parser.get(scope);
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser execution failed");
              err.properties = {
                id: "scopeparser_execution_failed",
                explanation: "The scope parser for the tag " + tag + " failed to execute",
                scope: scope,
                tag: tag
              };
              throw err;
            }
            if (result == null && this.num > 0) {
              return this.getValue(tag, this.num - 1);
            }
            return result;
          }
        }, {
          key: "getValueFromScope",
          value: function getValueFromScope(tag) {
            var result = this.getValue(tag);
            var value;
            if (result != null) {
              if (typeof result === "string") {
                this.useTag(tag, true);
                value = result;
              } else if (typeof result === "number") {
                value = String(result);
              } else {
                value = result;
              }
            } else {
              this.useTag(tag, false);
              return null;
            }
            return value;
          }
        }, {
          key: "useTag",
          value: function useTag(tag, val) {
            var u;
            if (val) {
              u = this.usedTags.def;
            } else {
              u = this.usedTags.undef;
            }
            var iterable = this.scopePath;
            for (var i = 0, s; i < iterable.length; i++) {
              s = iterable[i];
              if (!(u[s] != null)) {
                u[s] = {};
              }
              u = u[s];
            }
            if (tag !== "") {
              u[tag] = true;
            }
          }
        }, {
          key: "createSubScopeManager",
          value: function createSubScopeManager(scope, tag) {
            var options = DocUtils.cloneDeep({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList
            });
            options.parser = this.parser;
            options.moduleManager = this.moduleManager;
            if (tag != null) {
              options.scopeList = this.scopeList.concat(scope);
              options.scopePath = this.scopePath.concat(tag);
            } else {
              options.scopeList = [];
              options.scopePath = [];
            }
            return new ScopeManager(options);
          }
        }]);
        return ScopeManager;
      }();
    }, {
      "./docUtils": 5,
      "./errors": 6
    }],
    10: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Errors = require("./errors");

      function substr(baseText, start, length) {
        var text = "";
        for (var i = start; i < start + length; i++) {
          text += baseText[i];
        }
        return text;
      }
      module.exports = function() {
        function SubContent(fullText) {
          _classCallCheck(this, SubContent);
          this.fullText = fullText || "";
          this.text = "";
          this.start = 0;
          this.end = 0;
        }
        _createClass(SubContent, [{
          key: "getInnerLoop",
          value: function getInnerLoop(templaterState) {
            this.start = templaterState.calcEndTag(templaterState.loopOpen);
            this.end = templaterState.calcStartTag(templaterState.loopClose);
            return this.refreshText();
          }
        }, {
          key: "getOuterLoop",
          value: function getOuterLoop(templaterState) {
            this.start = templaterState.calcStartTag(templaterState.loopOpen);
            this.end = templaterState.calcEndTag(templaterState.loopClose);
            return this.refreshText();
          }
        }, {
          key: "getInnerTag",
          value: function getInnerTag(templaterState) {
            this.start = templaterState.calcPosition(templaterState.tagStart);
            this.end = templaterState.calcPosition(templaterState.tagEnd) + 1;
            return this.refreshText();
          }
        }, {
          key: "refreshText",
          value: function refreshText() {
            this.text = substr(this.fullText, this.start, this.end - this.start);
            return this;
          }
        }, {
          key: "getErrorProps",
          value: function getErrorProps(xmlTag) {
            return {
              xmlTag: xmlTag,
              text: this.fullText,
              start: this.start,
              previousEnd: this.end
            };
          }
        }, {
          key: "getOuterXml",
          value: function getOuterXml(xmlTag) {
            var endCandidate = this.fullText.indexOf("</" + xmlTag + ">", this.end);
            var err;
            var startCandiate = Math.max(this.fullText.lastIndexOf("<" + xmlTag + ">", this.start), this.fullText.lastIndexOf("<" + xmlTag + " ", this.start));
            if (endCandidate === -1) {
              err = new Errors.XTTemplateError("Can't find endTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err;
            }
            if (startCandiate === -1) {
              err = new Errors.XTTemplateError("Can't find startTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err;
            }
            this.end = endCandidate + ("</" + xmlTag + ">").length;
            this.start = startCandiate;
            return this.refreshText();
          }
        }, {
          key: "replace",
          value: function replace(newText) {
            this.fullText = this.fullText.substr(0, this.start) + newText + this.fullText.substr(this.end);
            this.end = this.start + newText.length;
            return this.refreshText();
          }
        }]);
        return SubContent;
      }();
    }, {
      "./errors": 6
    }],
    11: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var DocUtils = require("./docUtils");
      var Errors = require("./errors");
      var dashInnerRegex = /^-([^\s]+)\s(.+)$/;
      module.exports = function() {
        function TemplaterState(moduleManager, delimiters) {
          _classCallCheck(this, TemplaterState);
          this.moduleManager = moduleManager;
          this.moduleManager.setInstance("templaterState", this);
          this.delimiters = delimiters;
        }
        _createClass(TemplaterState, [{
          key: "moveCharacters",
          value: function moveCharacters(numXmlTag, newTextLength, oldTextLength) {
            var end = this.matches.length;
            for (var k = numXmlTag; k < end; k++) {
              this.charactersAddedCumulative[k] += newTextLength - oldTextLength;
            }
          }
        }, {
          key: "calcStartTag",
          value: function calcStartTag(tag) {
            return this.calcPosition(tag.start);
          }
        }, {
          key: "calcXmlTagPosition",
          value: function calcXmlTagPosition(xmlTagNumber) {
            return this.matches[xmlTagNumber].offset + this.charactersAddedCumulative[xmlTagNumber];
          }
        }, {
          key: "calcEndTag",
          value: function calcEndTag(tag) {
            return this.calcPosition(tag.end) + 1;
          }
        }, {
          key: "calcPosition",
          value: function calcPosition(bracket) {
            return this.calcXmlTagPosition(bracket.numXmlTag) + this.matches[bracket.numXmlTag].array[1].length + bracket.numCharacter + this.charactersAdded[bracket.numXmlTag];
          }
        }, {
          key: "innerContent",
          value: function innerContent(type) {
            return this.matches[this[type].numXmlTag].array[2];
          }
        }, {
          key: "initialize",
          value: function initialize() {
            this.context = "";
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.inTag = false;
            this.inDashLoop = false;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.trail = "";
            this.trailSteps = [];
            this.offset = [];
          }
        }, {
          key: "finalize",
          value: function finalize() {
            var err;
            var xtag;
            if (this.inForLoop === true || this.inDashLoop === true) {
              err = new Errors.XTTemplateError("Unclosed loop");
              xtag = this.loopOpen.raw;
              err.properties = {
                xtag: xtag,
                id: "unclosed_loop",
                context: this.context,
                explanation: "The loop beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err;
            }
            if (this.inTag === true) {
              err = new Errors.XTTemplateError("Unclosed tag");
              xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err;
            }
          }
        }, {
          key: "startTag",
          value: function startTag() {
            if (this.inTag === true) {
              var err = new Errors.XTTemplateError("Unclosed tag");
              var xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err;
            }
            this.currentStep = this.trailSteps[0];
            this.inTag = true;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.tagStart = this.currentStep;
            this.trail = "";
          }
        }, {
          key: "loopType",
          value: function loopType() {
            if (this.inDashLoop) {
              return "dash";
            }
            if (this.inForLoop) {
              return "for";
            }
            if (this.rawXmlTag) {
              return "xml";
            }
            var getFromModule = this.moduleManager.get("loopType");
            if (getFromModule != null) {
              return getFromModule;
            }
            return "simple";
          }
        }, {
          key: "isLoopClosingTag",
          value: function isLoopClosingTag() {
            return this.textInsideTag[0] === "/" && "/" + this.loopOpen.tag === this.textInsideTag || this.textInsideTag === "/";
          }
        }, {
          key: "finishLoop",
          value: function finishLoop() {
            this.context = "";
            this.rawXmlTag = false;
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.loopOpen = null;
            this.loopClose = null;
            this.inDashLoop = false;
            this.inTag = false;
            this.textInsideTag = "";
          }
        }, {
          key: "getLeftValue",
          value: function getLeftValue() {
            return this.innerContent("tagStart").substr(0, this.tagStart.numCharacter + this.offset[this.tagStart.numXmlTag]);
          }
        }, {
          key: "getRightValue",
          value: function getRightValue() {
            return this.innerContent("tagEnd").substr(this.tagEnd.numCharacter + 1 + this.offset[this.tagEnd.numXmlTag]);
          }
        }, {
          key: "getMatchLocation",
          value: function getMatchLocation(num) {
            var match = this.matches[num];
            if (match.first) {
              return "first";
            }
            if (match.last) {
              return "last";
            }
            return "normal";
          }
        }, {
          key: "handleSimpleEndTag",
          value: function handleSimpleEndTag() {
            var baseLoop = this.getCurrentLoop();
            if (this.textInsideTag[0] === "@") {
              this.rawXmlTag = true;
              this.tag = this.textInsideTag.substr(1);
              return;
            }
            if (this.textInsideTag[0] === "#" || this.textInsideTag[0] === "^") {
              this.inForLoop = true;
              baseLoop.tag = this.textInsideTag.substr(1);
              this.loopOpen = baseLoop;
              this.loopIsInverted = this.textInsideTag[0] === "^";
              return;
            }
            if (this.textInsideTag[0] === "-") {
              this.inDashLoop = true;
              baseLoop.tag = this.textInsideTag.replace(dashInnerRegex, "$2");
              baseLoop.element = this.textInsideTag.replace(dashInnerRegex, "$1");
              this.loopOpen = baseLoop;
              return;
            }
          }
        }, {
          key: "getCurrentLoop",
          value: function getCurrentLoop() {
            return {
              start: this.tagStart,
              end: this.tagEnd,
              raw: this.textInsideTag
            };
          }
        }, {
          key: "endTag",
          value: function endTag() {
            if (this.inTag === false) {
              var err = new Errors.XTTemplateError("Unopened tag");
              err.properties = {
                id: "unopened_tag",
                explanation: "Unopened tag near : '" + this.context.substr(this.context.length - 10, 10) + "'",
                context: this.context
              };
              throw err;
            }
            this.inTag = false;
            this.tagEnd = this.currentStep;
            this.textInsideTag = this.textInsideTag.substr(0, this.textInsideTag.length + 1 - this.delimiters.end.length);
            this.textInsideTag = DocUtils.wordToUtf8(this.textInsideTag);
            this.fullTextTag = this.delimiters.start + this.textInsideTag + this.delimiters.end;
            if (this.loopType() === "simple") {
              return this.handleSimpleEndTag();
            }
            if (this.textInsideTag[0] === "/") {
              this.loopClose = this.getCurrentLoop();
            }
          }
        }]);
        return TemplaterState;
      }();
    }, {
      "./docUtils": 5,
      "./errors": 6
    }],
    12: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var memoize = require("memoizejs");

      function handleRecursiveCase(res) {
        function replacerUnshift() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.shift();
          var match = pn.array[0] + pn.array[1];
          pn.array.unshift(match);
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.first = true;
          res.matches.unshift(pn);
          res.charactersAdded.unshift(0);
          return res.charactersAddedCumulative.unshift(0);
        }
        if (res.content.indexOf("<") === -1 && res.content.indexOf(">") === -1) {
          res.content.replace(/^()([^<>]*)$/, replacerUnshift);
        }
        var r = new RegExp("^()([^<]+)</(?:" + res.tagsXmlArrayJoined + ")>");
        res.content.replace(r, replacerUnshift);

        function replacerPush() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.last = true;
          res.matches.push(pn);
          res.charactersAdded.push(0);
          return res.charactersAddedCumulative.push(0);
        }
        r = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^>]+)$");
        res.content.replace(r, replacerPush);
        return res;
      }

      function xmlMatcher(content, tagsXmlArray) {
        var res = {};
        res.content = content;
        res.tagsXmlArray = tagsXmlArray;
        res.tagsXmlArrayJoined = res.tagsXmlArray.join("|");
        var regexp = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^<>]*)</(?:" + res.tagsXmlArrayJoined + ")>", "g");
        res.matches = DocUtils.pregMatchAll(regexp, res.content);
        res.charactersAddedCumulative = res.matches.map(function() {
          return 0;
        });
        res.charactersAdded = res.matches.map(function() {
          return 0;
        });
        return handleRecursiveCase(res);
      }
      var memoized = memoize(xmlMatcher);
      module.exports = function(content, tagsXmlArray) {
        return DocUtils.cloneDeep(memoized(content, tagsXmlArray));
      };
    }, {
      "./docUtils": 5,
      "memoizejs": 39
    }],
    13: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var DocUtils = require("./docUtils");
      var ScopeManager = require("./scopeManager");
      var SubContent = require("./subContent");
      var TemplaterState = require("./templaterState");
      var xmlMatcher = require("./xmlMatcher");
      var ModuleManager = require("./moduleManager");
      var Errors = require("./errors");

      function _getFullText(content, tagsXmlArray) {
        var matcher = xmlMatcher(content, tagsXmlArray);
        var output = matcher.matches.map(function(match) {
          return match.array[2];
        });
        return DocUtils.wordToUtf8(DocUtils.convertSpaces(output.join("")));
      }
      module.exports = function() {
        function XmlTemplater(content, options) {
          _classCallCheck(this, XmlTemplater);
          this.fromJson(options);
          this.templaterState = new TemplaterState(this.moduleManager, this.delimiters);
          this.load(content);
        }
        _createClass(XmlTemplater, [{
          key: "load",
          value: function load(content) {
            this.content = content;
            if (typeof this.content !== "string") {
              var err = new Errors.XTInternalError("Content must be a string");
              err.properties.id = "xmltemplater_content_must_be_string";
              throw err;
            }
            var result = xmlMatcher(this.content, this.fileTypeConfig.tagsXmlArray);
            this.templaterState.matches = result.matches;
            this.templaterState.charactersAddedCumulative = result.charactersAddedCumulative;
            this.templaterState.charactersAdded = result.charactersAdded;
          }
        }, {
          key: "fromJson",
          value: function fromJson(options) {
            var _this = this;
            this.tags = options.tags != null ? options.tags : {};
            this.fileTypeConfig = options.fileTypeConfig;
            this.scopePath = options.scopePath != null ? options.scopePath : [];
            this.scopeList = options.scopeList != null ? options.scopeList : [this.tags];
            this.usedTags = options.usedTags != null ? options.usedTags : {
              def: {},
              undef: {}
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = options[key] != null ? options[key] : defaultValue;
            });
            this.moduleManager = options.moduleManager != null ? options.moduleManager : new ModuleManager();
            this.scopeManager = new ScopeManager({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList,
              parser: this.parser,
              moduleManager: this.moduleManager
            });
          }
        }, {
          key: "toJson",
          value: function toJson() {
            var _this2 = this;
            var obj = {
              fileTypeConfig: this.fileTypeConfig,
              usedTags: this.scopeManager.usedTags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              obj[key] = _this2[key];
            });
            return obj;
          }
        }, {
          key: "getFullText",
          value: function getFullText() {
            return _getFullText(this.content, this.fileTypeConfig.tagsXmlArray);
          }
        }, {
          key: "updateModuleManager",
          value: function updateModuleManager() {
            this.moduleManager.setInstance("xmlTemplater", this);
            this.moduleManager.setInstance("templaterState", this.templaterState);
            this.moduleManager.setInstance("scopeManager", this.scopeManager);
          }
        }, {
          key: "handleModuleManager",
          value: function handleModuleManager(type, data) {
            this.updateModuleManager();
            return this.moduleManager.handle(type, data);
          }
        }, {
          key: "getTrail",
          value: function getTrail(character) {
            this.templaterState.trail += character;
            var length = !this.templaterState.inTag ? this.delimiters.start.length : this.delimiters.end.length;
            return this.templaterState.trail.substr(-length, length);
          }
        }, {
          key: "handleCharacter",
          value: function handleCharacter(character) {
            if (this.templaterState.trail === this.delimiters.start && (this.templaterState.inTag === false || this.sameTags === false)) {
              this.templaterState.startTag();
            } else if (this.templaterState.trail === this.delimiters.end && (this.templaterState.inTag === true || this.sameTags === false)) {
              this.updateModuleManager();
              this.templaterState.endTag();
              this.loopClose();
            } else if (this.templaterState.inTag === true) {
              this.templaterState.textInsideTag += character;
            }
          }
        }, {
          key: "forEachCharacter",
          value: function forEachCharacter(functor) {
            var matches = this.templaterState.matches;
            for (var numXmlTag = 0, match; numXmlTag < matches.length; numXmlTag++) {
              match = matches[numXmlTag];
              var innerText = match.array[2];
              this.templaterState.offset[numXmlTag] = 0;
              if (this.templaterState.trail.length === 0 && !this.templaterState.inTag && innerText.indexOf(this.delimiters.start[0]) === -1 && innerText.indexOf(this.delimiters.end[0]) === -1) {
                continue;
              }
              for (var numCharacter = 0, character; numCharacter < innerText.length; numCharacter++) {
                character = innerText[numCharacter];
                this.templaterState.trail = this.getTrail(character);
                this.templaterState.currentStep = {
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                };
                this.templaterState.trailSteps.push({
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                });
                this.templaterState.trailSteps = this.templaterState.trailSteps.splice(-this.delimiters.start.length, this.delimiters.start.length);
                this.templaterState.context += character;
                functor(character, numXmlTag, numCharacter);
              }
            }
          }
        }, {
          key: "render",
          value: function render() {
            this.sameTags = this.delimiters.start === this.delimiters.end;
            this.templaterState.initialize();
            this.handleModuleManager("xmlRendering");
            this.forEachCharacter(this.handleCharacter.bind(this));
            this.handleModuleManager("xmlRendered");
            this.templaterState.finalize();
            return this;
          }
        }, {
          key: "loopClose",
          value: function loopClose() {
            var loopType = this.templaterState.loopType();
            if (loopType === "simple") {
              this.replaceSimpleTag();
            }
            if (loopType === "xml") {
              this.replaceSimpleTagRawXml();
            }
            if (["dash", "for"].indexOf(loopType) !== -1 && this.templaterState.isLoopClosingTag()) {
              this.replaceLoopTag();
              this.templaterState.finishLoop();
            }
            if (["simple", "dash", "for", "xml"].indexOf(loopType) === -1) {
              this.handleModuleManager("replaceTag", loopType);
            }
          }
        }, {
          key: "replaceSimpleTag",
          value: function replaceSimpleTag() {
            var newValue = this.scopeManager.getValueFromScope(this.templaterState.textInsideTag);
            if (newValue == null) {
              newValue = this.nullGetter(this.templaterState.textInsideTag, {
                tag: "simple"
              });
            }
            this.content = this.replaceTagByValue(DocUtils.utf8ToWord(newValue), this.content);
          }
        }, {
          key: "replaceSimpleTagRawXml",
          value: function replaceSimpleTagRawXml() {
            var outerXml;
            var newText = this.scopeManager.getValueFromScope(this.templaterState.tag);
            if (newText == null) {
              newText = this.nullGetter(this.templaterState.tag, {
                tag: "raw"
              });
            }
            var subContent = new SubContent(this.content);
            subContent.getInnerTag(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(this.fileTypeConfig.tagRawXml);
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "raw_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The raw tag " + error.properties.xtag + " is not valid in this context.";
              }
              throw error;
            }
            var fullText = _getFullText(outerXml.text, this.fileTypeConfig.tagsXmlArray);
            if (this.templaterState.fullTextTag !== fullText) {
              var err = new Errors.XTTemplateError("Raw xml tag should be the only text in paragraph");
              err.properties = {
                id: "raw_xml_tag_should_be_only_text_in_paragraph",
                paragraphContent: fullText,
                fullTag: this.templaterState.fullTextTag,
                xtag: this.templaterState.textInsideTag,
                explanation: "The tag : '" + this.templaterState.fullTextTag + "' should be the the only text in the paragraph (it contains '" + fullText + "')"
              };
              throw err;
            }
            return this.replaceXml(outerXml, newText);
          }
        }, {
          key: "replaceXml",
          value: function replaceXml(subContent, newText) {
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, newText.length, subContent.text.length);
            this.content = subContent.replace(newText).fullText;
            return this.content;
          }
        }, {
          key: "deleteTag",
          value: function deleteTag(xml, tag) {
            this.templaterState.tagStart = tag.start;
            this.templaterState.tagEnd = tag.end;
            this.templaterState.textInsideTag = tag.raw;
            return this.replaceTagByValue("", xml);
          }
        }, {
          key: "deleteOuterTags",
          value: function deleteOuterTags(outerXmlText) {
            return this.deleteTag(this.deleteTag(outerXmlText, this.templaterState.loopOpen), this.templaterState.loopClose);
          }
        }, {
          key: "dashLoop",
          value: function dashLoop(elementDashLoop, sharp) {
            sharp = sharp || false;
            var outerXml;
            var subContent = new SubContent(this.content);
            subContent.getInnerLoop(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(elementDashLoop);
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "dashloop_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The dashLoop tag " + error.properties.xtag + " is not valid in this context.";
              }
              throw error;
            }
            this.templaterState.moveCharacters(0, 0, outerXml.start);
            var outerXmlText = outerXml.text;
            var innerXmlText = this.deleteOuterTags(outerXmlText, sharp);
            this.templaterState.moveCharacters(0, outerXml.start, 0);
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, outerXmlText.length, innerXmlText.length);
            return this.forLoop(outerXml, innerXmlText);
          }
        }, {
          key: "xmlToBeReplaced",
          value: function xmlToBeReplaced(options) {
            var before = "";
            var after = "";
            if (options.noStartTag) {
              return [options.insideValue];
            }
            if (options.spacePreserve && options.tag === "w:t") {
              before = "<" + options.fullTag + " xml:space=\"preserve\">";
            } else {
              before = this.templaterState.matches[options.xmlTagNumber].array[1];
            }
            if (!options.noEndTag) {
              after = "</" + options.tag + ">";
            }
            return [before, options.insideValue, after];
          }
        }, {
          key: "replaceFirstFrom",
          value: function replaceFirstFrom(string, search, replace, from) {
            var rightPart = string.substr(from + search.length);
            var leftPart = string.substr(0, from);
            var middlePart = string.substr(from, search.length);
            if (middlePart !== search) {
              var err = new Errors.XTInternalError("Match not found in content");
              err.properties.id = "xmltemplater_match_not_found_in_content";
              err.properties.search = search;
              err.properties.middlePart = middlePart;
              err.properties.content = string;
              throw err;
            }
            return leftPart + replace + rightPart;
          }
        }, {
          key: "replaceXmlTag",
          value: function replaceXmlTag(content, options) {
            this.templaterState.offset[options.xmlTagNumber] += options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            options.fullTag = this.templaterState.matches[options.xmlTagNumber].array[1].replace(/^<([^>]+)>$/, "$1");
            options.tag = options.fullTag.replace(/([^ ]*).*/, "$1");
            options.spacePreserve = options.spacePreserve != null ? options.spacePreserve : true;
            options.spacePreserve = options.spacePreserve && this.templaterState.matches[options.xmlTagNumber].array[1].indexOf('xml:space="preserve"') === -1;
            options.noStartTag = options.noStartTag != null ? options.noStartTag : false;
            options.noEndTag = options.noEndTag != null ? options.noEndTag : false;
            var replacer = this.xmlToBeReplaced(options);
            if (replacer.length > 1) {
              this.templaterState.matches[options.xmlTagNumber].array[1] = replacer[0];
            }
            this.templaterState.charactersAdded[options.xmlTagNumber] = options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            this.templaterState.matches[options.xmlTagNumber].array[2] = options.insideValue;
            replacer = replacer.join("");
            var startTag = this.templaterState.calcXmlTagPosition(options.xmlTagNumber);
            this.templaterState.moveCharacters(options.xmlTagNumber + 1, replacer.length, this.templaterState.matches[options.xmlTagNumber].array[0].length);
            content = this.replaceFirstFrom(content, this.templaterState.matches[options.xmlTagNumber].array[0], replacer, startTag);
            this.templaterState.matches[options.xmlTagNumber].array[0] = replacer;
            return content;
          }
        }, {
          key: "replaceTagByValue",
          value: function replaceTagByValue(newValue, content) {
            var location = this.templaterState.getMatchLocation(this.templaterState.tagStart.numXmlTag);
            var options = {
              xmlTagNumber: this.templaterState.tagStart.numXmlTag,
              noStartTag: location === "first",
              noEndTag: location === "last"
            };
            if (this.templaterState.tagEnd.numXmlTag === this.templaterState.tagStart.numXmlTag) {
              options.insideValue = this.templaterState.getLeftValue() + newValue + this.templaterState.getRightValue();
              return this.replaceXmlTag(content, options);
            } else if (this.templaterState.tagEnd.numXmlTag > this.templaterState.tagStart.numXmlTag) {
              if (location === "normal") {
                options.insideValue = this.templaterState.getLeftValue() + newValue;
              } else {
                options.insideValue = newValue;
              }
              content = this.replaceXmlTag(content, options);
              options = {
                insideValue: "",
                spacePreserve: false
              };
              var start = this.templaterState.tagStart.numXmlTag + 1;
              var end = this.templaterState.tagEnd.numXmlTag;
              for (var k = start; k < end; k++) {
                options.xmlTagNumber = k;
                content = this.replaceXmlTag(content, options);
              }
              options = {
                insideValue: this.templaterState.getRightValue(),
                spacePreserve: true,
                xmlTagNumber: this.templaterState.tagEnd.numXmlTag,
                noEndTag: this.templaterState.getMatchLocation(this.templaterState.tagEnd.numXmlTag) === "last"
              };
              return this.replaceXmlTag(content, options);
            }
          }
        }, {
          key: "replaceLoopTag",
          value: function replaceLoopTag() {
            if (this.templaterState.loopType() === "dash") {
              return this.dashLoop(this.templaterState.loopOpen.element);
            }
            if (this.intelligentTagging === true) {
              var dashElement = this.fileTypeConfig.calcIntellegentlyDashElement(this.content, this.templaterState);
              if (dashElement !== false) {
                return this.dashLoop(dashElement, true);
              }
            }
            var outerLoop = new SubContent(this.content).getOuterLoop(this.templaterState);
            var innerTemplate = new SubContent(this.content).getInnerLoop(this.templaterState).text;
            return this.forLoop(outerLoop, innerTemplate);
          }
        }, {
          key: "calcSubXmlTemplater",
          value: function calcSubXmlTemplater(innerTagsContent, argOptions) {
            var options = this.toJson();
            options.tags = argOptions.tags;
            options.scopeList = this.scopeList.concat(argOptions.tags);
            options.scopePath = this.scopePath.concat(this.templaterState.loopOpen.tag);
            var subXml = new XmlTemplater(innerTagsContent, options);
            return subXml;
          }
        }, {
          key: "forLoop",
          value: function forLoop(outerTags, subTemplate) {
            var _this3 = this;
            var tag = this.templaterState.loopOpen.tag;
            var newContent = "";
            var loopFn = function loopFn(subTags) {
              newContent += _this3.calcSubXmlTemplater(subTemplate, {
                tags: subTags
              }).render().content;
              return newContent;
            };
            this.scopeManager.loopOver(tag, loopFn, this.templaterState.loopIsInverted);
            this.calcSubXmlTemplater(subTemplate, {
              tags: {}
            }).render();
            return this.replaceXml(outerTags, newContent);
          }
        }]);
        return XmlTemplater;
      }();
    }, {
      "./docUtils": 5,
      "./errors": 6,
      "./moduleManager": 8,
      "./scopeManager": 9,
      "./subContent": 10,
      "./templaterState": 11,
      "./xmlMatcher": 12
    }],
    14: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var XmlUtil = {};

      function addTag(array, tag) {
        return array.concat([{
          tag: "<" + tag.array[1] + ">",
          offset: tag.offset
        }]);
      }

      function lastTagIsOpenTag(array, tag) {
        if (array.length === 0) {
          return false;
        }
        var lastTag = array[array.length - 1];
        var innerLastTag = lastTag.tag.substr(1, lastTag.tag.length - 2);
        var innerCurrentTag = tag.array[1].substr(1);
        return innerLastTag === innerCurrentTag;
      }
      XmlUtil.getListXmlElements = function(text) {
        var tags = DocUtils.pregMatchAll(/<(\/?[^/> ]+)([^>]*)>/g, text);
        var result = [];
        for (var i = 0, tag; i < tags.length; i++) {
          tag = tags[i];
          if (tag.array[1][0] === "/") {
            var justOpened = lastTagIsOpenTag(result, tag);
            if (justOpened) {
              result.pop();
            } else {
              result = addTag(result, tag);
            }
          } else if (tag.array[2][tag.array[2].length - 1] !== "/") {
            result = addTag(result, tag);
          }
        }
        return result;
      };
      module.exports = XmlUtil;
    }, {
      "./docUtils": 5
    }],
    15: [function(require, module, exports) {
      'use strict';
      var DataReader = require('./dataReader');

      function ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0;
          for (var i = 0; i < this.data.length; i++) {
            data[i] = data[i] & 0xFF;
          }
        }
      }
      ArrayReader.prototype = new DataReader();
      ArrayReader.prototype.byteAt = function(i) {
        return this.data[this.zero + i];
      };
      ArrayReader.prototype.lastIndexOfSignature = function(sig) {
        var sig0 = sig.charCodeAt(0),
          sig1 = sig.charCodeAt(1),
          sig2 = sig.charCodeAt(2),
          sig3 = sig.charCodeAt(3);
        for (var i = this.length - 4; i >= 0; --i) {
          if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
          }
        }
        return -1;
      };
      ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return [];
        }
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = ArrayReader;
    }, {
      "./dataReader": 20
    }],
    16: [function(require, module, exports) {
      'use strict';
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      exports.encode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
      };
      exports.decode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        }
        return output;
      };
    }, {}],
    17: [function(require, module, exports) {
      'use strict';

      function CompressedObject() {
        this.compressedSize = 0;
        this.uncompressedSize = 0;
        this.crc32 = 0;
        this.compressionMethod = null;
        this.compressedContent = null;
      }
      CompressedObject.prototype = {
        getContent: function() {
          return null;
        },
        getCompressedContent: function() {
          return null;
        }
      };
      module.exports = CompressedObject;
    }, {}],
    18: [function(require, module, exports) {
      'use strict';
      exports.STORE = {
        magic: "\x00\x00",
        compress: function(content, compressionOptions) {
          return content;
        },
        uncompress: function(content) {
          return content;
        },
        compressInputType: null,
        uncompressInputType: null
      };
      exports.DEFLATE = require('./flate');
    }, {
      "./flate": 23
    }],
    19: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');
      var table = [
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
        0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
        0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
        0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
        0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
        0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
        0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
        0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
        0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
        0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
        0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
        0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
        0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
        0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
        0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
        0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
        0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
        0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
        0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
        0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
        0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
        0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
        0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
        0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
        0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
        0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
        0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
        0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
        0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
        0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
        0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
        0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
        0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
        0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
        0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
        0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
        0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
        0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
        0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
        0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
        0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
        0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
        0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
        0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
        0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
        0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
        0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
        0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
        0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
        0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
        0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
        0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
        0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
        0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
        0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
        0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
        0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
        0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
        0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
        0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
        0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
        0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
      ];
      module.exports = function crc32(input, crc) {
        if (typeof input === "undefined" || !input.length) {
          return 0;
        }
        var isArray = utils.getTypeOf(input) !== "string";
        if (typeof(crc) == "undefined") {
          crc = 0;
        }
        var x = 0;
        var y = 0;
        var b = 0;
        crc = crc ^ (-1);
        for (var i = 0, iTop = input.length; i < iTop; i++) {
          b = isArray ? input[i] : input.charCodeAt(i);
          y = (crc ^ b) & 0xFF;
          x = table[y];
          crc = (crc >>> 8) ^ x;
        }
        return crc ^ (-1);
      };
    }, {
      "./utils": 36
    }],
    20: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');

      function DataReader(data) {
        this.data = null;
        this.length = 0;
        this.index = 0;
        this.zero = 0;
      }
      DataReader.prototype = {
        checkOffset: function(offset) {
          this.checkIndex(this.index + offset);
        },
        checkIndex: function(newIndex) {
          if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
          }
        },
        setIndex: function(newIndex) {
          this.checkIndex(newIndex);
          this.index = newIndex;
        },
        skip: function(n) {
          this.setIndex(this.index + n);
        },
        byteAt: function(i) {},
        readInt: function(size) {
          var result = 0,
            i;
          this.checkOffset(size);
          for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
          }
          this.index += size;
          return result;
        },
        readString: function(size) {
          return utils.transformTo("string", this.readData(size));
        },
        readData: function(size) {},
        lastIndexOfSignature: function(sig) {},
        readDate: function() {
          var dostime = this.readInt(4);
          return new Date(
            ((dostime >> 25) & 0x7f) + 1980,
            ((dostime >> 21) & 0x0f) - 1,
            (dostime >> 16) & 0x1f,
            (dostime >> 11) & 0x1f,
            (dostime >> 5) & 0x3f,
            (dostime & 0x1f) << 1);
        }
      };
      module.exports = DataReader;
    }, {
      "./utils": 36
    }],
    21: [function(require, module, exports) {
      'use strict';
      exports.base64 = false;
      exports.binary = false;
      exports.dir = false;
      exports.createFolders = false;
      exports.date = null;
      exports.compression = null;
      exports.compressionOptions = null;
      exports.comment = null;
      exports.unixPermissions = null;
      exports.dosPermissions = null;
    }, {}],
    22: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');
      exports.string2binary = function(str) {
        return utils.string2binary(str);
      };
      exports.string2Uint8Array = function(str) {
        return utils.transformTo("uint8array", str);
      };
      exports.uint8Array2String = function(array) {
        return utils.transformTo("string", array);
      };
      exports.string2Blob = function(str) {
        var buffer = utils.transformTo("arraybuffer", str);
        return utils.arrayBuffer2Blob(buffer);
      };
      exports.arrayBuffer2Blob = function(buffer) {
        return utils.arrayBuffer2Blob(buffer);
      };
      exports.transformTo = function(outputType, input) {
        return utils.transformTo(outputType, input);
      };
      exports.getTypeOf = function(input) {
        return utils.getTypeOf(input);
      };
      exports.checkSupport = function(type) {
        return utils.checkSupport(type);
      };
      exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
      exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
      exports.pretty = function(str) {
        return utils.pretty(str);
      };
      exports.findCompression = function(compressionMethod) {
        return utils.findCompression(compressionMethod);
      };
      exports.isRegExp = function(object) {
        return utils.isRegExp(object);
      };
    }, {
      "./utils": 36
    }],
    23: [function(require, module, exports) {
      'use strict';
      var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');
      var pako = require("pako");
      exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.magic = "\x08\x00";
      exports.compress = function(input, compressionOptions) {
        return pako.deflateRaw(input, {
          level: compressionOptions.level || -1
        });
      };
      exports.uncompress = function(input) {
        return pako.inflateRaw(input);
      };
    }, {
      "pako": 40
    }],
    24: [function(require, module, exports) {
      'use strict';
      var base64 = require('./base64');

      function JSZip(data, options) {
        if (!(this instanceof JSZip)) return new JSZip(data, options);
        this.files = {};
        this.comment = null;
        this.root = "";
        if (data) {
          this.load(data, options);
        }
        this.clone = function() {
          var newObj = new JSZip();
          for (var i in this) {
            if (typeof this[i] !== "function") {
              newObj[i] = this[i];
            }
          }
          return newObj;
        };
      }
      JSZip.prototype = require('./object');
      JSZip.prototype.load = require('./load');
      JSZip.support = require('./support');
      JSZip.defaults = require('./defaults');
      JSZip.utils = require('./deprecatedPublicUtils');
      JSZip.base64 = {
        encode: function(input) {
          return base64.encode(input);
        },
        decode: function(input) {
          return base64.decode(input);
        }
      };
      JSZip.compressions = require('./compressions');
      module.exports = JSZip;
    }, {
      "./base64": 16,
      "./compressions": 18,
      "./defaults": 21,
      "./deprecatedPublicUtils": 22,
      "./load": 25,
      "./object": 28,
      "./support": 32
    }],
    25: [function(require, module, exports) {
      'use strict';
      var base64 = require('./base64');
      var utf8 = require('./utf8');
      var utils = require('./utils');
      var ZipEntries = require('./zipEntries');
      module.exports = function(data, options) {
        var files, zipEntries, i, input;
        options = utils.extend(options || {}, {
          base64: false,
          checkCRC32: false,
          optimizedBinaryString: false,
          createFolders: false,
          decodeFileName: utf8.utf8decode
        });
        if (options.base64) {
          data = base64.decode(data);
        }
        zipEntries = new ZipEntries(data, options);
        files = zipEntries.files;
        for (i = 0; i < files.length; i++) {
          input = files[i];
          this.file(input.fileNameStr, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
        }
        if (zipEntries.zipComment.length) {
          this.comment = zipEntries.zipComment;
        }
        return this;
      };
    }, {
      "./base64": 16,
      "./utf8": 35,
      "./utils": 36,
      "./zipEntries": 37
    }],
    26: [function(require, module, exports) {
      (function(Buffer) {
        'use strict';
        module.exports = function(data, encoding) {
          return new Buffer(data, encoding);
        };
        module.exports.test = function(b) {
          return Buffer.isBuffer(b);
        };
      }).call(this, require("buffer").Buffer)
    }, {
      "buffer": 1
    }],
    27: [function(require, module, exports) {
      'use strict';
      var Uint8ArrayReader = require('./uint8ArrayReader');

      function NodeBufferReader(data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
      }
      NodeBufferReader.prototype = new Uint8ArrayReader();
      NodeBufferReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = NodeBufferReader;
    }, {
      "./uint8ArrayReader": 33
    }],
    28: [function(require, module, exports) {
      'use strict';
      var support = require('./support');
      var utils = require('./utils');
      var crc32 = require('./crc32');
      var signature = require('./signature');
      var defaults = require('./defaults');
      var base64 = require('./base64');
      var compressions = require('./compressions');
      var CompressedObject = require('./compressedObject');
      var nodeBuffer = require('./nodeBuffer');
      var utf8 = require('./utf8');
      var StringWriter = require('./stringWriter');
      var Uint8ArrayWriter = require('./uint8ArrayWriter');
      var getRawData = function(file) {
        if (file._data instanceof CompressedObject) {
          file._data = file._data.getContent();
          file.options.binary = true;
          file.options.base64 = false;
          if (utils.getTypeOf(file._data) === "uint8array") {
            var copy = file._data;
            file._data = new Uint8Array(copy.length);
            if (copy.length !== 0) {
              file._data.set(copy, 0);
            }
          }
        }
        return file._data;
      };
      var getBinaryData = function(file) {
        var result = getRawData(file),
          type = utils.getTypeOf(result);
        if (type === "string") {
          if (!file.options.binary) {
            if (support.nodebuffer) {
              return nodeBuffer(result, "utf-8");
            }
          }
          return file.asBinary();
        }
        return result;
      };
      var dataToString = function(asUTF8) {
        var result = getRawData(this);
        if (result === null || typeof result === "undefined") {
          return "";
        }
        if (this.options.base64) {
          result = base64.decode(result);
        }
        if (asUTF8 && this.options.binary) {
          result = out.utf8decode(result);
        } else {
          result = utils.transformTo("string", result);
        }
        if (!asUTF8 && !this.options.binary) {
          result = utils.transformTo("string", out.utf8encode(result));
        }
        return result;
      };
      var ZipObject = function(name, data, options) {
        this.name = name;
        this.dir = options.dir;
        this.date = options.date;
        this.comment = options.comment;
        this.unixPermissions = options.unixPermissions;
        this.dosPermissions = options.dosPermissions;
        this._data = data;
        this.options = options;
        this._initialMetadata = {
          dir: options.dir,
          date: options.date
        };
      };
      ZipObject.prototype = {
        asText: function() {
          return dataToString.call(this, true);
        },
        asBinary: function() {
          return dataToString.call(this, false);
        },
        asNodeBuffer: function() {
          var result = getBinaryData(this);
          return utils.transformTo("nodebuffer", result);
        },
        asUint8Array: function() {
          var result = getBinaryData(this);
          return utils.transformTo("uint8array", result);
        },
        asArrayBuffer: function() {
          return this.asUint8Array().buffer;
        }
      };
      var decToHex = function(dec, bytes) {
        var hex = "",
          i;
        for (i = 0; i < bytes; i++) {
          hex += String.fromCharCode(dec & 0xff);
          dec = dec >>> 8;
        }
        return hex;
      };
      var prepareFileAttrs = function(o) {
        o = o || {};
        if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
          o.binary = true;
        }
        o = utils.extend(o, defaults);
        o.date = o.date || new Date();
        if (o.compression !== null) o.compression = o.compression.toUpperCase();
        return o;
      };
      var fileAdd = function(name, data, o) {
        var dataType = utils.getTypeOf(data),
          parent;
        o = prepareFileAttrs(o);
        if (typeof o.unixPermissions === "string") {
          o.unixPermissions = parseInt(o.unixPermissions, 8);
        }
        if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
          o.dir = true;
        }
        if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
          o.dir = true;
        }
        if (o.dir) {
          name = forceTrailingSlash(name);
        }
        if (o.createFolders && (parent = parentFolder(name))) {
          folderAdd.call(this, parent, true);
        }
        if (o.dir || data === null || typeof data === "undefined") {
          o.base64 = false;
          o.binary = false;
          data = null;
          dataType = null;
        } else if (dataType === "string") {
          if (o.binary && !o.base64) {
            if (o.optimizedBinaryString !== true) {
              data = utils.string2binary(data);
            }
          }
        } else {
          o.base64 = false;
          o.binary = true;
          if (!dataType && !(data instanceof CompressedObject)) {
            throw new Error("The data of '" + name + "' is in an unsupported format !");
          }
          if (dataType === "arraybuffer") {
            data = utils.transformTo("uint8array", data);
          }
        }
        var object = new ZipObject(name, data, o);
        this.files[name] = object;
        return object;
      };
      var parentFolder = function(path) {
        if (path.slice(-1) == '/') {
          path = path.substring(0, path.length - 1);
        }
        var lastSlash = path.lastIndexOf('/');
        return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
      };
      var forceTrailingSlash = function(path) {
        if (path.slice(-1) != "/") {
          path += "/";
        }
        return path;
      };
      var folderAdd = function(name, createFolders) {
        createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;
        name = forceTrailingSlash(name);
        if (!this.files[name]) {
          fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
          });
        }
        return this.files[name];
      };
      var generateCompressedObjectFrom = function(file, compression, compressionOptions) {
        var result = new CompressedObject(),
          content;
        if (file._data instanceof CompressedObject) {
          result.uncompressedSize = file._data.uncompressedSize;
          result.crc32 = file._data.crc32;
          if (result.uncompressedSize === 0 || file.dir) {
            compression = compressions['STORE'];
            result.compressedContent = "";
            result.crc32 = 0;
          } else if (file._data.compressionMethod === compression.magic) {
            result.compressedContent = file._data.getCompressedContent();
          } else {
            content = file._data.getContent();
            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
          }
        } else {
          content = getBinaryData(file);
          if (!content || content.length === 0 || file.dir) {
            compression = compressions['STORE'];
            content = "";
          }
          result.uncompressedSize = content.length;
          result.crc32 = crc32(content);
          result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
        }
        result.compressedSize = result.compressedContent.length;
        result.compressionMethod = compression.magic;
        return result;
      };
      var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
        var result = unixPermissions;
        if (!unixPermissions) {
          result = isDir ? 0x41fd : 0x81b4;
        }
        return (result & 0xFFFF) << 16;
      };
      var generateDosExternalFileAttr = function(dosPermissions, isDir) {
        return (dosPermissions || 0) & 0x3F;
      };
      var generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {
        var data = compressedObject.compressedContent,
          useCustomEncoding = encodeFileName !== utf8.utf8encode,
          encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
          utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
          comment = file.comment || "",
          encodedComment = utils.transformTo("string", encodeFileName(comment)),
          utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
          useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
          useUTF8ForComment = utfEncodedComment.length !== comment.length,
          o = file.options,
          dosTime,
          dosDate,
          extraFields = "",
          unicodePathExtraField = "",
          unicodeCommentExtraField = "",
          dir, date;
        if (file._initialMetadata.dir !== file.dir) {
          dir = file.dir;
        } else {
          dir = o.dir;
        }
        if (file._initialMetadata.date !== file.date) {
          date = file.date;
        } else {
          date = o.date;
        }
        var extFileAttr = 0;
        var versionMadeBy = 0;
        if (dir) {
          extFileAttr |= 0x00010;
        }
        if (platform === "UNIX") {
          versionMadeBy = 0x031E;
          extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
        } else {
          versionMadeBy = 0x0014;
          extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
        }
        dosTime = date.getHours();
        dosTime = dosTime << 6;
        dosTime = dosTime | date.getMinutes();
        dosTime = dosTime << 5;
        dosTime = dosTime | date.getSeconds() / 2;
        dosDate = date.getFullYear() - 1980;
        dosDate = dosDate << 4;
        dosDate = dosDate | (date.getMonth() + 1);
        dosDate = dosDate << 5;
        dosDate = dosDate | date.getDate();
        if (useUTF8ForFileName) {
          unicodePathExtraField =
            decToHex(1, 1) +
            decToHex(crc32(encodedFileName), 4) +
            utfEncodedFileName;
          extraFields +=
            "\x75\x70" +
            decToHex(unicodePathExtraField.length, 2) +
            unicodePathExtraField;
        }
        if (useUTF8ForComment) {
          unicodeCommentExtraField =
            decToHex(1, 1) +
            decToHex(this.crc32(encodedComment), 4) +
            utfEncodedComment;
          extraFields +=
            "\x75\x63" +
            decToHex(unicodeCommentExtraField.length, 2) +
            unicodeCommentExtraField;
        }
        var header = "";
        header += "\x0A\x00";
        header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\x00\x08" : "\x00\x00";
        header += compressedObject.compressionMethod;
        header += decToHex(dosTime, 2);
        header += decToHex(dosDate, 2);
        header += decToHex(compressedObject.crc32, 4);
        header += decToHex(compressedObject.compressedSize, 4);
        header += decToHex(compressedObject.uncompressedSize, 4);
        header += decToHex(encodedFileName.length, 2);
        header += decToHex(extraFields.length, 2);
        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
        var dirRecord = signature.CENTRAL_FILE_HEADER +
          decToHex(versionMadeBy, 2) +
          header +
          decToHex(encodedComment.length, 2) +
          "\x00\x00" +
          "\x00\x00" +
          decToHex(extFileAttr, 4) +
          decToHex(offset, 4) +
          encodedFileName +
          extraFields +
          encodedComment;
        return {
          fileRecord: fileRecord,
          dirRecord: dirRecord,
          compressedObject: compressedObject
        };
      };
      var out = {
        load: function(stream, options) {
          throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
        },
        filter: function(search) {
          var result = [],
            filename, relativePath, file, fileClone;
          for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
              continue;
            }
            file = this.files[filename];
            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));
            relativePath = filename.slice(this.root.length, filename.length);
            if (filename.slice(0, this.root.length) === this.root &&
              search(relativePath, fileClone)) {
              result.push(fileClone);
            }
          }
          return result;
        },
        file: function(name, data, o) {
          if (arguments.length === 1) {
            if (utils.isRegExp(name)) {
              var regexp = name;
              return this.filter(function(relativePath, file) {
                return !file.dir && regexp.test(relativePath);
              });
            } else {
              return this.filter(function(relativePath, file) {
                return !file.dir && relativePath === name;
              })[0] || null;
            }
          } else {
            name = this.root + name;
            fileAdd.call(this, name, data, o);
          }
          return this;
        },
        folder: function(arg) {
          if (!arg) {
            return this;
          }
          if (utils.isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
              return file.dir && arg.test(relativePath);
            });
          }
          var name = this.root + arg;
          var newFolder = folderAdd.call(this, name);
          var ret = this.clone();
          ret.root = newFolder.name;
          return ret;
        },
        remove: function(name) {
          name = this.root + name;
          var file = this.files[name];
          if (!file) {
            if (name.slice(-1) != "/") {
              name += "/";
            }
            file = this.files[name];
          }
          if (file && !file.dir) {
            delete this.files[name];
          } else {
            var kids = this.filter(function(relativePath, file) {
              return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
              delete this.files[kids[i].name];
            }
          }
          return this;
        },
        generate: function(options) {
          options = utils.extend(options || {}, {
            base64: true,
            compression: "STORE",
            compressionOptions: null,
            type: "base64",
            platform: "DOS",
            comment: null,
            mimeType: 'application/zip',
            encodeFileName: utf8.utf8encode
          });
          utils.checkSupport(options.type);
          if (
            options.platform === 'darwin' ||
            options.platform === 'freebsd' ||
            options.platform === 'linux' ||
            options.platform === 'sunos'
          ) {
            options.platform = "UNIX";
          }
          if (options.platform === 'win32') {
            options.platform = "DOS";
          }
          var zipData = [],
            localDirLength = 0,
            centralDirLength = 0,
            writer, i,
            encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
          for (var name in this.files) {
            if (!this.files.hasOwnProperty(name)) {
              continue;
            }
            var file = this.files[name];
            var compressionName = file.options.compression || options.compression.toUpperCase();
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !");
            }
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
            centralDirLength += zipPart.dirRecord.length;
            zipData.push(zipPart);
          }
          var dirEnd = "";
          dirEnd = signature.CENTRAL_DIRECTORY_END +
            "\x00\x00" +
            "\x00\x00" +
            decToHex(zipData.length, 2) +
            decToHex(zipData.length, 2) +
            decToHex(centralDirLength, 4) +
            decToHex(localDirLength, 4) +
            decToHex(encodedComment.length, 2) +
            encodedComment;
          var typeName = options.type.toLowerCase();
          if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
          } else {
            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].fileRecord);
            writer.append(zipData[i].compressedObject.compressedContent);
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].dirRecord);
          }
          writer.append(dirEnd);
          var zip = writer.finalize();
          switch (options.type.toLowerCase()) {
            case "uint8array":
            case "arraybuffer":
            case "nodebuffer":
              return utils.transformTo(options.type.toLowerCase(), zip);
            case "blob":
              return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
            case "base64":
              return (options.base64) ? base64.encode(zip) : zip;
            default:
              return zip;
          }
        },
        crc32: function(input, crc) {
          return crc32(input, crc);
        },
        utf8encode: function(string) {
          return utils.transformTo("string", utf8.utf8encode(string));
        },
        utf8decode: function(input) {
          return utf8.utf8decode(input);
        }
      };
      module.exports = out;
    }, {
      "./base64": 16,
      "./compressedObject": 17,
      "./compressions": 18,
      "./crc32": 19,
      "./defaults": 21,
      "./nodeBuffer": 26,
      "./signature": 29,
      "./stringWriter": 31,
      "./support": 32,
      "./uint8ArrayWriter": 34,
      "./utf8": 35,
      "./utils": 36
    }],
    29: [function(require, module, exports) {
      'use strict';
      exports.LOCAL_FILE_HEADER = "PK\x03\x04";
      exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
      exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
      exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
      exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
      exports.DATA_DESCRIPTOR = "PK\x07\x08";
    }, {}],
    30: [function(require, module, exports) {
      'use strict';
      var DataReader = require('./dataReader');
      var utils = require('./utils');

      function StringReader(data, optimizedBinaryString) {
        this.data = data;
        if (!optimizedBinaryString) {
          this.data = utils.string2binary(this.data);
        }
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
      }
      StringReader.prototype = new DataReader();
      StringReader.prototype.byteAt = function(i) {
        return this.data.charCodeAt(this.zero + i);
      };
      StringReader.prototype.lastIndexOfSignature = function(sig) {
        return this.data.lastIndexOf(sig) - this.zero;
      };
      StringReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = StringReader;
    }, {
      "./dataReader": 20,
      "./utils": 36
    }],
    31: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');
      var StringWriter = function() {
        this.data = [];
      };
      StringWriter.prototype = {
        append: function(input) {
          input = utils.transformTo("string", input);
          this.data.push(input);
        },
        finalize: function() {
          return this.data.join("");
        }
      };
      module.exports = StringWriter;
    }, {
      "./utils": 36
    }],
    32: [function(require, module, exports) {
      (function(Buffer) {
        'use strict';
        exports.base64 = true;
        exports.array = true;
        exports.string = true;
        exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
        exports.nodebuffer = typeof Buffer !== "undefined";
        exports.uint8array = typeof Uint8Array !== "undefined";
        if (typeof ArrayBuffer === "undefined") {
          exports.blob = false;
        } else {
          var buffer = new ArrayBuffer(0);
          try {
            exports.blob = new Blob([buffer], {
              type: "application/zip"
            }).size === 0;
          } catch (e) {
            try {
              var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              var builder = new Builder();
              builder.append(buffer);
              exports.blob = builder.getBlob('application/zip').size === 0;
            } catch (e) {
              exports.blob = false;
            }
          }
        }
      }).call(this, require("buffer").Buffer)
    }, {
      "buffer": 1
    }],
    33: [function(require, module, exports) {
      'use strict';
      var ArrayReader = require('./arrayReader');

      function Uint8ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0;
        }
      }
      Uint8ArrayReader.prototype = new ArrayReader();
      Uint8ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return new Uint8Array(0);
        }
        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = Uint8ArrayReader;
    }, {
      "./arrayReader": 15
    }],
    34: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');
      var Uint8ArrayWriter = function(length) {
        this.data = new Uint8Array(length);
        this.index = 0;
      };
      Uint8ArrayWriter.prototype = {
        append: function(input) {
          if (input.length !== 0) {
            input = utils.transformTo("uint8array", input);
            this.data.set(input, this.index);
            this.index += input.length;
          }
        },
        finalize: function() {
          return this.data;
        }
      };
      module.exports = Uint8ArrayWriter;
    }, {
      "./utils": 36
    }],
    35: [function(require, module, exports) {
      'use strict';
      var utils = require('./utils');
      var support = require('./support');
      var nodeBuffer = require('./nodeBuffer');
      var _utf8len = new Array(256);
      for (var i = 0; i < 256; i++) {
        _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
      }
      _utf8len[254] = _utf8len[254] = 1;
      var string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
              c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
              m_pos++;
            }
          }
          buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
        }
        if (support.uint8array) {
          buf = new Uint8Array(buf_len);
        } else {
          buf = new Array(buf_len);
        }
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
              c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
              m_pos++;
            }
          }
          if (c < 0x80) {
            buf[i++] = c;
          } else if (c < 0x800) {
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
          } else if (c < 0x10000) {
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
          } else {
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
          }
        }
        return buf;
      };
      var utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return (pos + _utf8len[buf[pos]] > max) ? pos : max;
      };
      var buf2string = function(buf) {
        var str, i, out, c, c_len;
        var len = buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 0x80) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 0xfffd;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
          while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 0xfffd;
            continue;
          }
          if (c < 0x10000) {
            utf16buf[out++] = c;
          } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
          }
        }
        if (utf16buf.length !== out) {
          if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
          } else {
            utf16buf.length = out;
          }
        }
        return utils.applyFromCharCode(utf16buf);
      };
      exports.utf8encode = function utf8encode(str) {
        if (support.nodebuffer) {
          return nodeBuffer(str, "utf-8");
        }
        return string2buf(str);
      };
      exports.utf8decode = function utf8decode(buf) {
        if (support.nodebuffer) {
          return utils.transformTo("nodebuffer", buf).toString("utf-8");
        }
        buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
        var result = [],
          k = 0,
          len = buf.length,
          chunk = 65536;
        while (k < len) {
          var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
          if (support.uint8array) {
            result.push(buf2string(buf.subarray(k, nextBoundary)));
          } else {
            result.push(buf2string(buf.slice(k, nextBoundary)));
          }
          k = nextBoundary;
        }
        return result.join("");
      };
    }, {
      "./nodeBuffer": 26,
      "./support": 32,
      "./utils": 36
    }],
    36: [function(require, module, exports) {
      'use strict';
      var support = require('./support');
      var compressions = require('./compressions');
      var nodeBuffer = require('./nodeBuffer');
      exports.string2binary = function(str) {
        var result = "";
        for (var i = 0; i < str.length; i++) {
          result += String.fromCharCode(str.charCodeAt(i) & 0xff);
        }
        return result;
      };
      exports.arrayBuffer2Blob = function(buffer, mimeType) {
        exports.checkSupport("blob");
        mimeType = mimeType || 'application/zip';
        try {
          return new Blob([buffer], {
            type: mimeType
          });
        } catch (e) {
          try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            return builder.getBlob(mimeType);
          } catch (e) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };

      function identity(input) {
        return input;
      }

      function stringToArrayLike(str, array) {
        for (var i = 0; i < str.length; ++i) {
          array[i] = str.charCodeAt(i) & 0xFF;
        }
        return array;
      }

      function arrayLikeToString(array) {
        var chunk = 65536;
        var result = [],
          len = array.length,
          type = exports.getTypeOf(array),
          k = 0,
          canUseApply = true;
        try {
          switch (type) {
            case "uint8array":
              String.fromCharCode.apply(null, new Uint8Array(0));
              break;
            case "nodebuffer":
              String.fromCharCode.apply(null, nodeBuffer(0));
              break;
          }
        } catch (e) {
          canUseApply = false;
        }
        if (!canUseApply) {
          var resultStr = "";
          for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
          }
          return resultStr;
        }
        while (k < len && chunk > 1) {
          try {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
        return result.join("");
      }
      exports.applyFromCharCode = arrayLikeToString;

      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i = 0; i < arrayFrom.length; i++) {
          arrayTo[i] = arrayFrom[i];
        }
        return arrayTo;
      }
      var transform = {};
      transform["string"] = {
        "string": identity,
        "array": function(input) {
          return stringToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return transform["string"]["uint8array"](input).buffer;
        },
        "uint8array": function(input) {
          return stringToArrayLike(input, new Uint8Array(input.length));
        },
        "nodebuffer": function(input) {
          return stringToArrayLike(input, nodeBuffer(input.length));
        }
      };
      transform["array"] = {
        "string": arrayLikeToString,
        "array": identity,
        "arraybuffer": function(input) {
          return (new Uint8Array(input)).buffer;
        },
        "uint8array": function(input) {
          return new Uint8Array(input);
        },
        "nodebuffer": function(input) {
          return nodeBuffer(input);
        }
      };
      transform["arraybuffer"] = {
        "string": function(input) {
          return arrayLikeToString(new Uint8Array(input));
        },
        "array": function(input) {
          return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
        },
        "arraybuffer": identity,
        "uint8array": function(input) {
          return new Uint8Array(input);
        },
        "nodebuffer": function(input) {
          return nodeBuffer(new Uint8Array(input));
        }
      };
      transform["uint8array"] = {
        "string": arrayLikeToString,
        "array": function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return input.buffer;
        },
        "uint8array": identity,
        "nodebuffer": function(input) {
          return nodeBuffer(input);
        }
      };
      transform["nodebuffer"] = {
        "string": arrayLikeToString,
        "array": function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return transform["nodebuffer"]["uint8array"](input).buffer;
        },
        "uint8array": function(input) {
          return arrayLikeToArrayLike(input, new Uint8Array(input.length));
        },
        "nodebuffer": identity
      };
      exports.transformTo = function(outputType, input) {
        if (!input) {
          input = "";
        }
        if (!outputType) {
          return input;
        }
        exports.checkSupport(outputType);
        var inputType = exports.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result;
      };
      exports.getTypeOf = function(input) {
        if (typeof input === "string") {
          return "string";
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array";
        }
        if (support.nodebuffer && nodeBuffer.test(input)) {
          return "nodebuffer";
        }
        if (support.uint8array && input instanceof Uint8Array) {
          return "uint8array";
        }
        if (support.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer";
        }
      };
      exports.checkSupport = function(type) {
        var supported = support[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this browser");
        }
      };
      exports.MAX_VALUE_16BITS = 65535;
      exports.MAX_VALUE_32BITS = -1;
      exports.pretty = function(str) {
        var res = '',
          code, i;
        for (i = 0; i < (str || "").length; i++) {
          code = str.charCodeAt(i);
          res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
        }
        return res;
      };
      exports.findCompression = function(compressionMethod) {
        for (var method in compressions) {
          if (!compressions.hasOwnProperty(method)) {
            continue;
          }
          if (compressions[method].magic === compressionMethod) {
            return compressions[method];
          }
        }
        return null;
      };
      exports.isRegExp = function(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]";
      };
      exports.extend = function() {
        var result = {},
          i, attr;
        for (i = 0; i < arguments.length; i++) {
          for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i][attr];
            }
          }
        }
        return result;
      };
    }, {
      "./compressions": 18,
      "./nodeBuffer": 26,
      "./support": 32
    }],
    37: [function(require, module, exports) {
      'use strict';
      var StringReader = require('./stringReader');
      var NodeBufferReader = require('./nodeBufferReader');
      var Uint8ArrayReader = require('./uint8ArrayReader');
      var ArrayReader = require('./arrayReader');
      var utils = require('./utils');
      var sig = require('./signature');
      var ZipEntry = require('./zipEntry');
      var support = require('./support');
      var jszipProto = require('./object');

      function ZipEntries(data, loadOptions) {
        this.files = [];
        this.loadOptions = loadOptions;
        if (data) {
          this.load(data);
        }
      }
      ZipEntries.prototype = {
        checkSignature: function(expectedSignature) {
          var signature = this.reader.readString(4);
          if (signature !== expectedSignature) {
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
          }
        },
        isSignature: function(askedIndex, expectedSignature) {
          var currentIndex = this.reader.index;
          this.reader.setIndex(askedIndex);
          var signature = this.reader.readString(4);
          var result = signature === expectedSignature;
          this.reader.setIndex(currentIndex);
          return result;
        },
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2);
          this.diskWithCentralDirStart = this.reader.readInt(2);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
          this.centralDirRecords = this.reader.readInt(2);
          this.centralDirSize = this.reader.readInt(4);
          this.centralDirOffset = this.reader.readInt(4);
          this.zipCommentLength = this.reader.readInt(2);
          var zipComment = this.reader.readData(this.zipCommentLength);
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          var decodeContent = utils.transformTo(decodeParamType, zipComment);
          this.zipComment = this.loadOptions.decodeFileName(decodeContent);
        },
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8);
          this.versionMadeBy = this.reader.readString(2);
          this.versionNeeded = this.reader.readInt(2);
          this.diskNumber = this.reader.readInt(4);
          this.diskWithCentralDirStart = this.reader.readInt(4);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
          this.centralDirRecords = this.reader.readInt(8);
          this.centralDirSize = this.reader.readInt(8);
          this.centralDirOffset = this.reader.readInt(8);
          this.zip64ExtensibleData = {};
          var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
          while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readString(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            };
          }
        },
        readBlockZip64EndOfCentralLocator: function() {
          this.diskWithZip64CentralDirStart = this.reader.readInt(4);
          this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
          this.disksCount = this.reader.readInt(4);
          if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
          }
        },
        readLocalFiles: function() {
          var i, file;
          for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
          }
        },
        readCentralDir: function() {
          var file;
          this.reader.setIndex(this.centralDirOffset);
          while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
            file = new ZipEntry({
              zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
          }
          if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {}
          }
        },
        readEndOfCentral: function() {
          var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
          if (offset < 0) {
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
            if (isGarbage) {
              throw new Error("Can't find end of central directory : is this a zip file ? " +
                "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
              throw new Error("Corrupted zip : can't find end of central directory");
            }
          }
          this.reader.setIndex(offset);
          var endOfCentralDirOffset = offset;
          this.checkSignature(sig.CENTRAL_DIRECTORY_END);
          this.readBlockEndOfCentral();
          if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
              this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
              }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
          }
          var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
          if (this.zip64) {
            expectedEndOfCentralDirOffset += 20;
            expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
          }
          var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
          if (extraBytes > 0) {
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
              this.reader.zero = extraBytes;
            }
          } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
          }
        },
        prepareReader: function(data) {
          var type = utils.getTypeOf(data);
          utils.checkSupport(type);
          if (type === "string" && !support.uint8array) {
            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
          } else if (type === "nodebuffer") {
            this.reader = new NodeBufferReader(data);
          } else if (support.uint8array) {
            this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));
          } else if (support.array) {
            this.reader = new ArrayReader(utils.transformTo("array", data));
          } else {
            throw new Error("Unexpected error: unsupported type '" + type + "'");
          }
        },
        load: function(data) {
          this.prepareReader(data);
          this.readEndOfCentral();
          this.readCentralDir();
          this.readLocalFiles();
        }
      };
      module.exports = ZipEntries;
    }, {
      "./arrayReader": 15,
      "./nodeBufferReader": 27,
      "./object": 28,
      "./signature": 29,
      "./stringReader": 30,
      "./support": 32,
      "./uint8ArrayReader": 33,
      "./utils": 36,
      "./zipEntry": 38
    }],
    38: [function(require, module, exports) {
      'use strict';
      var StringReader = require('./stringReader');
      var utils = require('./utils');
      var CompressedObject = require('./compressedObject');
      var jszipProto = require('./object');
      var support = require('./support');
      var MADE_BY_DOS = 0x00;
      var MADE_BY_UNIX = 0x03;

      function ZipEntry(options, loadOptions) {
        this.options = options;
        this.loadOptions = loadOptions;
      }
      ZipEntry.prototype = {
        isEncrypted: function() {
          return (this.bitFlag & 0x0001) === 0x0001;
        },
        useUTF8: function() {
          return (this.bitFlag & 0x0800) === 0x0800;
        },
        prepareCompressedContent: function(reader, from, length) {
          return function() {
            var previousIndex = reader.index;
            reader.setIndex(from);
            var compressedFileData = reader.readData(length);
            reader.setIndex(previousIndex);
            return compressedFileData;
          };
        },
        prepareContent: function(reader, from, length, compression, uncompressedSize) {
          return function() {
            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
            var uncompressedFileData = compression.uncompress(compressedFileData);
            if (uncompressedFileData.length !== uncompressedSize) {
              throw new Error("Bug : uncompressed data size mismatch");
            }
            return uncompressedFileData;
          };
        },
        readLocalPart: function(reader) {
          var compression, localExtraFieldsLength;
          reader.skip(22);
          this.fileNameLength = reader.readInt(2);
          localExtraFieldsLength = reader.readInt(2);
          this.fileName = reader.readData(this.fileNameLength);
          reader.skip(localExtraFieldsLength);
          if (this.compressedSize == -1 || this.uncompressedSize == -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
          }
          compression = utils.findCompression(this.compressionMethod);
          if (compression === null) {
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
          }
          this.decompressed = new CompressedObject();
          this.decompressed.compressedSize = this.compressedSize;
          this.decompressed.uncompressedSize = this.uncompressedSize;
          this.decompressed.crc32 = this.crc32;
          this.decompressed.compressionMethod = this.compressionMethod;
          this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
          this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
          if (this.loadOptions.checkCRC32) {
            this.decompressed = utils.transformTo("string", this.decompressed.getContent());
            if (jszipProto.crc32(this.decompressed) !== this.crc32) {
              throw new Error("Corrupted zip : CRC32 mismatch");
            }
          }
        },
        readCentralPart: function(reader) {
          this.versionMadeBy = reader.readInt(2);
          this.versionNeeded = reader.readInt(2);
          this.bitFlag = reader.readInt(2);
          this.compressionMethod = reader.readString(2);
          this.date = reader.readDate();
          this.crc32 = reader.readInt(4);
          this.compressedSize = reader.readInt(4);
          this.uncompressedSize = reader.readInt(4);
          this.fileNameLength = reader.readInt(2);
          this.extraFieldsLength = reader.readInt(2);
          this.fileCommentLength = reader.readInt(2);
          this.diskNumberStart = reader.readInt(2);
          this.internalFileAttributes = reader.readInt(2);
          this.externalFileAttributes = reader.readInt(4);
          this.localHeaderOffset = reader.readInt(4);
          if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
          }
          this.fileName = reader.readData(this.fileNameLength);
          this.readExtraFields(reader);
          this.parseZIP64ExtraField(reader);
          this.fileComment = reader.readData(this.fileCommentLength);
        },
        processAttributes: function() {
          this.unixPermissions = null;
          this.dosPermissions = null;
          var madeBy = this.versionMadeBy >> 8;
          this.dir = this.externalFileAttributes & 0x0010 ? true : false;
          if (madeBy === MADE_BY_DOS) {
            this.dosPermissions = this.externalFileAttributes & 0x3F;
          }
          if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
          }
          if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
          }
        },
        parseZIP64ExtraField: function(reader) {
          if (!this.extraFields[0x0001]) {
            return;
          }
          var extraReader = new StringReader(this.extraFields[0x0001].value);
          if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
          }
          if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
          }
          if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
          }
          if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
          }
        },
        readExtraFields: function(reader) {
          var start = reader.index,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
          this.extraFields = this.extraFields || {};
          while (reader.index < start + this.extraFieldsLength) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readString(extraFieldLength);
            this.extraFields[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            };
          }
        },
        handleUTF8: function() {
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) {
            this.fileNameStr = jszipProto.utf8decode(this.fileName);
            this.fileCommentStr = jszipProto.utf8decode(this.fileComment);
          } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
              this.fileNameStr = upath;
            } else {
              var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }
            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
              this.fileCommentStr = ucomment;
            } else {
              var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
          }
        },
        findExtraFieldUnicodePath: function() {
          var upathField = this.extraFields[0x7075];
          if (upathField) {
            var extraReader = new StringReader(upathField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
              return null;
            }
            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));
          }
          return null;
        },
        findExtraFieldUnicodeComment: function() {
          var ucommentField = this.extraFields[0x6375];
          if (ucommentField) {
            var extraReader = new StringReader(ucommentField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
              return null;
            }
            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
          }
          return null;
        }
      };
      module.exports = ZipEntry;
    }, {
      "./compressedObject": 17,
      "./object": 28,
      "./stringReader": 30,
      "./support": 32,
      "./utils": 36
    }],
    39: [function(require, module, exports) {
      (function(root, factory) {
        if (typeof define === 'function' && define.amd) {
          define([], factory);
        } else if (typeof exports === 'object') {
          module.exports = factory();
        } else {
          root.memoize = factory();
        }
      }(this, function() {
        "use strict";
        var memoize = function(func) {
          var stringifyJson = JSON.stringify,
            cache = {};
          var cachedfun = function() {
            var hash = stringifyJson(arguments);
            return (hash in cache) ? cache[hash] : cache[hash] = func.apply(this, arguments);
          };
          cachedfun.__cache = (function() {
            cache.remove || (cache.remove = function() {
              var hash = stringifyJson(arguments);
              return (delete cache[hash]);
            });
            return cache;
          }).call(this);
          return cachedfun;
        };
        return memoize;
      }));
    }, {}],
    40: [function(require, module, exports) {
      'use strict';
      var assign = require('./lib/utils/common').assign;
      var deflate = require('./lib/deflate');
      var inflate = require('./lib/inflate');
      var constants = require('./lib/zlib/constants');
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module.exports = pako;
    }, {
      "./lib/deflate": 41,
      "./lib/inflate": 42,
      "./lib/utils/common": 43,
      "./lib/zlib/constants": 46
    }],
    41: [function(require, module, exports) {
      'use strict';
      var zlib_deflate = require('./zlib/deflate');
      var utils = require('./utils/common');
      var strings = require('./utils/strings');
      var msg = require('./zlib/messages');
      var ZStream = require('./zlib/zstream');
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;

      function Deflate(options) {
        if (!(this instanceof Deflate)) return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ''
        }, options || {});
        var opt = this.options;
        if (opt.raw && (opt.windowBits > 0)) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = '';
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === 'string') {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
        if (typeof data === 'string') {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
            if (this.options.to === 'string') {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === 'string') {
            this.result = this.chunks.join('');
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };

      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg;
        }
        return deflator.result;
      }

      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }

      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }, {
      "./utils/common": 43,
      "./utils/strings": 44,
      "./zlib/deflate": 48,
      "./zlib/messages": 53,
      "./zlib/zstream": 55
    }],
    42: [function(require, module, exports) {
      'use strict';
      var zlib_inflate = require('./zlib/inflate');
      var utils = require('./utils/common');
      var strings = require('./utils/strings');
      var c = require('./zlib/constants');
      var msg = require('./zlib/messages');
      var ZStream = require('./zlib/zstream');
      var GZheader = require('./zlib/gzheader');
      var toString = Object.prototype.toString;

      function Inflate(options) {
        if (!(this instanceof Inflate)) return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ''
        }, options || {});
        var opt = this.options;
        if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
          !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = '';
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var dict;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
        if (typeof data === 'string') {
          strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            if (typeof dictionary === 'string') {
              dict = strings.string2buf(dictionary);
            } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
              dict = new Uint8Array(dictionary);
            } else {
              dict = dictionary;
            }
            status = zlib_inflate.inflateSetDictionary(this.strm, dict);
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
              if (this.options.to === 'string') {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH;
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK;
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === 'string') {
            this.result = this.chunks.join('');
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };

      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg;
        }
        return inflator.result;
      }

      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate;
    }, {
      "./utils/common": 43,
      "./utils/strings": 44,
      "./zlib/constants": 46,
      "./zlib/gzheader": 49,
      "./zlib/inflate": 51,
      "./zlib/messages": 53,
      "./zlib/zstream": 55
    }],
    43: [function(require, module, exports) {
      'use strict';
      var TYPED_OK = (typeof Uint8Array !== 'undefined') &&
        (typeof Uint16Array !== 'undefined') &&
        (typeof Int32Array !== 'undefined');
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== 'object') {
            throw new TypeError(source + 'must be non-object');
          }
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }, {}],
    44: [function(require, module, exports) {
      'use strict';
      var utils = require('./common');
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (var q = 0; q < 256; q++) {
        _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
      }
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
              c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
              m_pos++;
            }
          }
          buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
              c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
              m_pos++;
            }
          }
          if (c < 0x80) {
            buf[i++] = c;
          } else if (c < 0x800) {
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
          } else if (c < 0x10000) {
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
          } else {
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
          }
        }
        return buf;
      };

      function buf2binstring(buf, len) {
        if (len < 65537) {
          if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = '';
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 0x80) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 0xfffd;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
          while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 0xfffd;
            continue;
          }
          if (c < 0x10000) {
            utf16buf[out++] = c;
          } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return (pos + _utf8len[buf[pos]] > max) ? pos : max;
      };
    }, {
      "./common": 43
    }],
    45: [function(require, module, exports) {
      'use strict';

      function adler32(adler, buf, len, pos) {
        var s1 = (adler & 0xffff) | 0,
          s2 = ((adler >>> 16) & 0xffff) | 0,
          n = 0;
        while (len !== 0) {
          n = len > 2000 ? 2000 : len;
          len -= n;
          do {
            s1 = (s1 + buf[pos++]) | 0;
            s2 = (s2 + s1) | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return (s1 | (s2 << 16)) | 0;
      }
      module.exports = adler32;
    }, {}],
    46: [function(require, module, exports) {
      'use strict';
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
    }, {}],
    47: [function(require, module, exports) {
      'use strict';

      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();

      function crc32(crc, buf, len, pos) {
        var t = crcTable,
          end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
        }
        return (crc ^ (-1));
      }
      module.exports = crc32;
    }, {}],
    48: [function(require, module, exports) {
      'use strict';
      var utils = require('../utils/common');
      var trees = require('./trees');
      var adler32 = require('./adler32');
      var crc32 = require('./crc32');
      var msg = require('./messages');
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
      var PRESET_DICT = 0x20;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 0x03;

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }

      function rank(f) {
        return ((f) << 1) - ((f) > 4 ? 9 : 0);
      }

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }

      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }

      function flush_block_only(s, last) {
        trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }

      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }

      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
      }

      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }

      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
          s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end ||
            _win[match + best_len - 1] !== scan_end1 ||
            _win[match] !== _win[scan] ||
            _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
            scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }

      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = (m >= _w_size ? m - _w_size : 0);
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = (m >= _w_size ? m - _w_size : 0);
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      }

      function deflate_stored(s, flush) {
        var max_block_size = 0xffff;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (;;) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }

      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }

      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match &&
            s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 &&
              (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }

      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (;;) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {} while (prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                prev === _win[++scan] && prev === _win[++scan] &&
                scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }

      function deflate_huff(s, flush) {
        var bflush;
        for (;;) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }

      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];

      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }

      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }

      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
        strm.adler = (s.wrap === 2) ?
          0 :
          1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }

      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }

      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }

      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
          windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
          strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << (memLevel + 6);
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }

      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }

      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state ||
          flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output ||
          (!strm.input && strm.avail_in !== 0) ||
          (s.status === FINISH_STATE && flush !== Z_FINISH)) {
          return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 :
                (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                  4 : 0));
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) +
                (s.gzhead.hcrc ? 2 : 0) +
                (!s.gzhead.extra ? 0 : 4) +
                (!s.gzhead.name ? 0 : 8) +
                (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 0xff);
              put_byte(s, (s.gzhead.time >> 8) & 0xff);
              put_byte(s, (s.gzhead.time >> 16) & 0xff);
              put_byte(s, (s.gzhead.time >> 24) & 0xff);
              put_byte(s, s.level === 9 ? 2 :
                (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                  4 : 0));
              put_byte(s, s.gzhead.os & 0xff);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 0xff);
                put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= (level_flags << 6);
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - (header % 31);
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 0xffff);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 0xff);
              put_byte(s, (strm.adler >> 8) & 0xff);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
          flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 ||
          (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
          var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
            (s.strategy === Z_RLE ? deflate_rle(s, flush) :
              configuration_table[s.level].func(s, flush));
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 0xff);
          put_byte(s, (strm.adler >> 8) & 0xff);
          put_byte(s, (strm.adler >> 16) & 0xff);
          put_byte(s, (strm.adler >> 24) & 0xff);
          put_byte(s, strm.total_in & 0xff);
          put_byte(s, (strm.total_in >> 8) & 0xff);
          put_byte(s, (strm.total_in >> 16) & 0xff);
          put_byte(s, (strm.total_in >> 24) & 0xff);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }

      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE &&
          status !== EXTRA_STATE &&
          status !== NAME_STATE &&
          status !== COMMENT_STATE &&
          status !== HCRC_STATE &&
          status !== BUSY_STATE &&
          status !== FINISH_STATE
        ) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }

      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = 'pako deflate (from Nodeca project)';
    }, {
      "../utils/common": 43,
      "./adler32": 45,
      "./crc32": 47,
      "./messages": 53,
      "./trees": 54
    }],
    49: [function(require, module, exports) {
      'use strict';

      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = '';
        this.comment = '';
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }, {}],
    50: [function(require, module, exports) {
      'use strict';
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = (here >>> 16) & 0xff;
                if (op === 0) {
                  output[_out++] = here & 0xffff;
                } else if (op & 16) {
                  len = here & 0xffff;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & ((1 << op) - 1);
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (;;) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = (here >>> 16) & 0xff;
                      if (op & 16) {
                        dist = here & 0xffff;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & ((1 << op) - 1);
                        if (dist > dmax) {
                          strm.msg = 'invalid distance too far back';
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = 'invalid distance too far back';
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                        continue dodist;
                      } else {
                        strm.msg = 'invalid distance code';
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = 'invalid literal/length code';
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
        strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }, {}],
    51: [function(require, module, exports) {
      'use strict';
      var utils = require('../utils/common');
      var adler32 = require('./adler32');
      var crc32 = require('./crc32');
      var inflate_fast = require('./inffast');
      var inflate_table = require('./inftrees');
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;

      function zswap32(q) {
        return (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
      }

      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }

      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = '';
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }

      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }

      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix, distfix;

      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }

      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }

      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!strm || !strm.state || !strm.output ||
          (!strm.input && strm.avail_in !== 0)) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (;;) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((state.wrap & 2) && hold === 0x8b1f) {
                  state.check = 0;
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) ||
                  (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                  strm.msg = 'incorrect header check';
                  state.mode = BAD;
                  break;
                }
                if ((hold & 0x0f) !== Z_DEFLATED) {
                  strm.msg = 'unknown compression method';
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 0x0f) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = 'invalid window size';
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 0x200 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 0xff) !== Z_DEFLATED) {
                  strm.msg = 'unknown compression method';
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 0xe000) {
                  strm.msg = 'unknown header flags set';
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = ((hold >> 8) & 1);
                }
                if (state.flags & 0x0200) {
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 0x0200) {
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  hbuf[2] = (hold >>> 16) & 0xff;
                  hbuf[3] = (hold >>> 24) & 0xff;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = (hold & 0xff);
                  state.head.os = (hold >> 8);
                }
                if (state.flags & 0x0200) {
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 0x0400) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 0x0200) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = (hold >>> 8) & 0xff;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 0x0400) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        copy,
                        len
                      );
                    }
                    if (state.flags & 0x0200) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 0x0800) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len &&
                      (state.length < 65536)) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 0x0200) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 0x1000) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len &&
                      (state.length < 65536)) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 0x0200) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 0x0200) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 0xffff)) {
                    strm.msg = 'header crc mismatch';
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = ((state.flags >> 9) & 1);
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = (hold & 0x01);
                hold >>>= 1;
                bits -= 1;
                switch ((hold & 0x03)) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = 'invalid block type';
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                  strm.msg = 'invalid stored block lengths';
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 0xffff;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy, put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 0x1f) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 0x1f) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 0x0f) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = 'too many length or distance symbols';
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                  bits: state.lenbits
                };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = 'invalid code lengths set';
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (;;) {
                    here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                    here_bits = here >>> 24;
                    here_op = (here >>> 16) & 0xff;
                    here_val = here & 0xffff;
                    if ((here_bits) <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = 'invalid bit length repeat';
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 0x03);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 0x07);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 0x7f);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = 'invalid bit length repeat';
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = 'invalid code -- missing end-of-block';
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = {
                  bits: state.lenbits
                };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = 'invalid literal/lengths set';
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                  bits: state.distbits
                };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = 'invalid distances set';
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (;;) {
                  here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 0xf0) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (;;) {
                    here = state.lencode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = (here >>> 16) & 0xff;
                    here_val = here & 0xffff;
                    if ((last_bits + here_bits) <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = 'invalid literal/length code';
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & ((1 << state.extra) - 1);
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (;;) {
                  here = state.distcode[hold & ((1 << state.distbits) - 1)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;
                  if ((here_bits) <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 0xf0) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (;;) {
                    here = state.distcode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = (here >>> 16) & 0xff;
                    here_val = here & 0xffff;
                    if ((last_bits + here_bits) <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = 'invalid distance code';
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = (here_op) & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & ((1 << state.extra) - 1);
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = 'invalid distance too far back';
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check =
                      (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = 'incorrect data check';
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 0xffffffff)) {
                    strm.msg = 'incorrect length check';
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
            (state.mode < CHECK || flush !== Z_FINISH))) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check =
            (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) +
          (state.mode === TYPE ? 128 : 0) +
          (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }

      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }

      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }

      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = 'pako inflate (from Nodeca project)';
    }, {
      "../utils/common": 43,
      "./adler32": 45,
      "./crc32": 47,
      "./inffast": 50,
      "./inftrees": 52
    }],
    52: [function(require, module, exports) {
      'use strict';
      var utils = require('../utils/common');
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
      ];
      var lext = [
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
      ];
      var dbase = [
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0
      ];
      var dext = [
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64
      ];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0,
          max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = (1 << 24) | (64 << 16) | 0;
          table[table_index++] = (1 << 24) | (64 << 16) | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if ((type === LENS && used > ENOUGH_LENS) ||
          (type === DISTS && used > ENOUGH_DISTS)) {
          return 1;
        }
        var i = 0;
        for (;;) {
          i++;
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << (len - drop);
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
          } while (fill !== 0);
          incr = 1 << (len - 1);
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if ((type === LENS && used > ENOUGH_LENS) ||
              (type === DISTS && used > ENOUGH_DISTS)) {
              return 1;
            }
            low = huff & mask;
            table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
        }
        opts.bits = root;
        return 0;
      };
    }, {
      "../utils/common": 43
    }],
    53: [function(require, module, exports) {
      'use strict';
      module.exports = {
        2: 'need dictionary',
        1: 'stream end',
        0: '',
        '-1': 'file error',
        '-2': 'stream error',
        '-3': 'data error',
        '-4': 'insufficient memory',
        '-5': 'buffer error',
        '-6': 'incompatible version'
      };
    }, {}],
    54: [function(require, module, exports) {
      'use strict';
      var utils = require('../utils/common');
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);

      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;

      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }

      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }

      function put_short(s, w) {
        s.pending_buf[s.pending++] = (w) & 0xff;
        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
      }

      function send_bits(s, value, length) {
        if (s.bi_valid > (Buf_size - length)) {
          s.bi_buf |= (value << s.bi_valid) & 0xffff;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> (Buf_size - s.bi_valid);
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= (value << s.bi_valid) & 0xffff;
          s.bi_valid += length;
        }
      }

      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
      }

      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }

      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 0xff;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }

      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }

      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }

      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < (1 << extra_lbits[code]); n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < (1 << extra_dbits[code]); n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }

      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }

      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }

      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }

      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return (tree[_n2] < tree[_m2] ||
          (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
      }

      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len &&
            smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      }

      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }

      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = (s.heap_len >> 1); n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }

      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 0xffff;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }

      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }

      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }

      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }

      function detect_data_type(s) {
        var black_mask = 0xf3ffc07f;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 ||
          s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;

      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }

      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }

      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }

      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = (s.opt_len + 3 + 7) >>> 3;
          static_lenb = (s.static_len + 3 + 7) >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      }

      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return (s.last_lit === s.lit_bufsize - 1);
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }, {
      "../utils/common": 43
    }],
    55: [function(require, module, exports) {
      'use strict';

      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = '';
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }, {}],
    "/src/js/docxtemplater.js": [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var DocUtils = require("./docUtils");
      var Docxtemplater = function() {
        function Docxtemplater(content, options) {
          _classCallCheck(this, Docxtemplater);
          this.moduleManager = new Docxtemplater.ModuleManager();
          this.moduleManager.setInstance("gen", this);
          this.setOptions({});
          if (content != null) {
            this.load(content, options);
          }
        }
        _createClass(Docxtemplater, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.moduleManager.attachModule(module);
            return this;
          }
        }, {
          key: "setOptions",
          value: function setOptions(options) {
            var _this = this;
            this.options = options || {};
            Object.keys(DocUtils.defaults).forEach(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = _this.options[key] != null ? _this.options[key] : defaultValue;
            });
            if (this.fileType === "docx" || this.fileType === "pptx") {
              this.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];
              if (this.zip != null) {
                this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
              }
            }
            return this;
          }
        }, {
          key: "load",
          value: function load(content, options) {
            this.moduleManager.sendEvent("loading");
            if (content.file != null) {
              this.zip = content;
            } else {
              this.zip = new Docxtemplater.JSZip(content, options);
            }
            this.moduleManager.sendEvent("loaded");
            this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
            return this;
          }
        }, {
          key: "renderFile",
          value: function renderFile(fileName) {
            this.moduleManager.sendEvent("rendering-file", fileName);
            var currentFile = this.createTemplateClass(fileName);
            this.zip.file(fileName, currentFile.render().content);
            return this.moduleManager.sendEvent("rendered-file", fileName);
          }
        }, {
          key: "render",
          value: function render() {
            this.moduleManager.sendEvent("rendering");
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                this.renderFile(fileName);
              }
            }
            this.moduleManager.sendEvent("rendered");
            return this;
          }
        }, {
          key: "getTags",
          value: function getTags() {
            var usedTags = [];
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                var currentFile = this.createTemplateClass(fileName);
                var usedTemplateV = currentFile.render().usedTags;
                if (DocUtils.sizeOfObject(usedTemplateV)) {
                  usedTags.push({
                    fileName: fileName,
                    vars: usedTemplateV
                  });
                }
              }
            }
            return usedTags;
          }
        }, {
          key: "setData",
          value: function setData(tags) {
            this.tags = tags;
            return this;
          }
        }, {
          key: "getZip",
          value: function getZip() {
            return this.zip;
          }
        }, {
          key: "createTemplateClass",
          value: function createTemplateClass(path) {
            var usedData = this.zip.files[path].asText();
            return this.createTemplateClassFromContent(usedData);
          }
        }, {
          key: "createTemplateClassFromContent",
          value: function createTemplateClassFromContent(content) {
            var _this2 = this;
            var obj = {
              tags: this.tags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).forEach(function(key) {
              obj[key] = _this2[key];
            });
            obj.fileTypeConfig = this.fileTypeConfig;
            return new Docxtemplater.XmlTemplater(content, obj);
          }
        }, {
          key: "getFullText",
          value: function getFullText(path) {
            return this.createTemplateClass(path || this.fileTypeConfig.textPath).getFullText();
          }
        }]);
        return Docxtemplater;
      }();
      Docxtemplater.DocUtils = require("./docUtils");
      Docxtemplater.JSZip = require("jszip");
      Docxtemplater.Errors = require("./errors");
      Docxtemplater.ModuleManager = require("./moduleManager");
      Docxtemplater.XmlTemplater = require("./xmlTemplater");
      Docxtemplater.FileTypeConfig = require("./fileTypeConfig");
      Docxtemplater.XmlMatcher = require("./xmlMatcher");
      Docxtemplater.XmlUtil = require("./xmlUtil");
      Docxtemplater.SubContent = require("./subContent");
      module.exports = Docxtemplater;
    }, {
      "./docUtils": 5,
      "./errors": 6,
      "./fileTypeConfig": 7,
      "./moduleManager": 8,
      "./subContent": 10,
      "./xmlMatcher": 12,
      "./xmlTemplater": 13,
      "./xmlUtil": 14,
      "jszip": 24
    }]
  }, {}, [])("/src/js/docxtemplater.js")
});
/*! RESOURCE: PpmIntGroupSprintCreationHandler */
var PpmIntGroupSprintCreationHandler = Class.create({
  initialize: function(gr) {
    this._gr = gr;
    this._isList = (gr.type + "" == "GlideList2") || (gr.type + "" == "GlideList3");
    this._sysId = this._isList ? this._gr.getChecked() : this._gr.getUniqueValue();
    this._tableName = this._gr.getTableName();
    this._prmErr = [];
  },
  showLoadingDialog: function() {
    this.loadingDialog = new GlideDialogWindow("dialog_loading", true, 300);
    this.loadingDialog.setPreference('table', 'loading');
    this.loadingDialog.render();
  },
  hideLoadingDialog: function() {
    this.loadingDialog && this.loadingDialog.destroy();
  },
  showDialog: function() {
    if (this._tableName == 'm2m_release_group')
      this.getGroupFromReleaseGroup(this._sysId);
    else
      this.getDefaultDataAndShowDialog();
  },
  getDefaultDataAndShowDialog: function() {
    if (!(this._sysId == '')) {
      (new GlideUI()).clearOutputMessages();
      this.showLoadingDialog();
      this._getDefaultData();
    } else {
      var span = document.createElement('span');
      span.setAttribute('data-type', 'system');
      span.setAttribute('data-text', getMessage('Please select a Group'));
      span.setAttribute('data-duration', '4000');
      span.setAttribute('data-attr-type', 'error');
      var notification = {
        xml: span
      };
      GlideUI.get().fire(new GlideUINotification(notification));
    }
  },
  getGroupFromReleaseGroup: function(releaseGroupIds) {
    var ga = new GlideAjax("agile2_AjaxProcessor");
    ga.addParam('sysparm_name', 'getGroupsFromReleaseGroups');
    ga.addParam('sysparm_releasegroups', releaseGroupIds);
    ga.getXML(this._groupCallback.bind(this));
  },
  _groupCallback: function(response) {
    var groups = response.responseXML.getElementsByTagName("group");
    var groupIds = '';
    var id;
    for (var i = 0; i < groups.length; i++) {
      id = groups[i].getAttribute("id");
      if (groupIds == '')
        groupIds = id;
      else
        groupIds = groupIds + ',' + id;
    }
    this._sysId = groupIds;
    this.getDefaultDataAndShowDialog();
  },
  showMainDialog: function() {
    this.hideLoadingDialog();
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("ppm_int_TeamSprintCreationPage");
    var titleMsg = getMessage("Create Sprints");
    this._mstrDlg.setTitle(titleMsg);
    this._mstrDlg.setPreference('sprintCreationHandler', this);
    this._mstrDlg.setPreference('sysparm_nostack', true);
    this._mstrDlg.setPreference('sysparm_start_date', this._defaultStartDate);
    this._mstrDlg.setPreference('sysparm_count', this._defaultCount);
    this._mstrDlg.setPreference('sysparm_duration', this._defultDuration);
    this._mstrDlg.setPreference('sysparm_name', this.defaultName);
    this._mstrDlg.render();
  },
  onSubmit: function() {
    try {
      this.sprintCount = this._getValue('sprint_count');
      this.startDate = this._getValue('start_date');
      this.name = this._getValue('sprint_name');
      this.startAt = this._getValue('sprint_start_count');
      this.duration = this._getValue('sprint_duration');
      if (!this._validate()) {
        return false;
      }
      var ga = new GlideAjax("ppm_int_TeamProcessor");
      ga.addParam('sysparm_name', 'createSprints');
      ga.addParam('sysparm_start_date', this.startDate);
      ga.addParam('sysparm_sysid', this._sysId);
      ga.addParam('sysparm_count', this.sprintCount);
      ga.addParam('sysparm_start_count', this.startAt);
      ga.addParam('sysparm_sprint_name', this.name);
      ga.addParam('sysparm_duration', this.duration);
      this.showLoadingDialog();
      ga.getXML(this.callback.bind(this));
    } catch (err) {
      this._displayErrorDialog();
      console.log(err);
    }
    return false;
  },
  callback: function(response) {
    this.hideLoadingDialog();
    this._mstrDlg.destroy();
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      window.location.reload();
    } else if (resp[0] && resp[0].getAttribute("status") == "hasOverlappingSprints") {
      this._hasOverlappingSprints = true;
      if (this._isList)
        this._gr._refreshAjax();
    } else {
      this._displayErrorDialog();
    }
  },
  _displayErrorDialog: function() {
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._createError = new dialogClass("ppm_int_error_dialog");
    this._createError.setTitle(getMessage("Error while creating Sprints for Team."));
    this._createError.render();
  },
  _validate: function() {
    this._prmErr = [];
    var field = '';
    this._removeAllError('ppm_int_TeamSprintCreationPage');
    if (this.name == 'undefined' || this.name.trim() == "") {
      this._prmErr.push(getMessage("Provide name"));
      field = 'sprint_name';
    } else if (!this.startAt || isNaN(this.startAt)) {
      this._prmErr.push(getMessage("Provide integer value"));
      field = 'sprint_start_count';
    } else if (this.startDate == 'undefined' ||
      this.startDate.trim() == "" ||
      getDateFromFormat(this.startDate, g_user_date_format) == 0) {
      this._prmErr.push(getMessage("Provide valid start date"));
      field = 'start_date';
    } else if (!this.duration || isNaN(this.duration)) {
      this._prmErr.push(getMessage("Provide integer value"));
      field = 'sprint_duration';
    } else if (!this.sprintCount || isNaN(this.sprintCount)) {
      this._prmErr.push(getMessage("Provide integer value"));
      field = 'sprint_count';
    }
    if (this._prmErr.length > 0) {
      setTimeout("var refocus = document.getElementById('" + field + "');refocus.focus();", 0);
      this._showFieldError(field, this._prmErr[0]);
      return false;
    }
    return true;
  },
  _getValue: function(inptNm) {
    return gel(inptNm).value;
  },
  _getDefaultData: function() {
    var ga = new GlideAjax("ppm_int_TeamProcessor");
    ga.addParam('sysparm_name', 'calculateSprintDefaults');
    ga.addParam('sysparm_sysid', this._sysId);
    ga.getXML(this._defaultDataCallback.bind(this));
  },
  _defaultDataCallback: function(response) {
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0]) {
      this._defaultStartDate = resp[0].getAttribute("next_start_date");
      this._defaultCount = resp[0].getAttribute("count");
      this._defultDuration = resp[0].getAttribute("duration");
      this.defaultName = resp[0].getAttribute('name');
    }
    this.showMainDialog();
  },
  _showFieldError: function(groupId, message) {
    var $group = $j('#' + groupId + '_group');
    var $helpBlock = $group.find('.help-block');
    if (!$group.hasClass('has-error'))
      $group.addClass('has-error');
    if ($helpBlock.css('display') != "inline") {
      $helpBlock.text(message);
      $helpBlock.css('display', 'inline');
    }
  },
  _removeAllError: function(dialogName) {
    $j('#' + dialogName + ' .form-group.has-error').each(function() {
      $j(this).removeClass('has-error');
      $j(this).find('.help-block').css('display', 'none');
    });
  },
  type: "PpmIntGroupSprintCreationHandler"
});
/*! RESOURCE: docxtemplater-image-module.v1.0.4.min.js */
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f()
  } else if (typeof define === "function" && define.amd) {
    define([], f)
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window
    } else if (typeof global !== "undefined") {
      g = global
    } else if (typeof self !== "undefined") {
      g = self
    } else {
      g = this
    }
    g.ImageModule = f()
  }
})(function() {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f
        }
        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e)
        }, l, l.exports, e, t, n, r)
      }
      return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
  }({
    1: [function(require, module, exports) {}, {}],
    2: [function(require, module, exports) {
      var util = require("util/");
      var pSlice = Array.prototype.slice;
      var hasOwn = Object.prototype.hasOwnProperty;
      var assert = module.exports = ok;
      assert.AssertionError = function AssertionError(options) {
        this.name = "AssertionError";
        this.actual = options.actual;
        this.expected = options.expected;
        this.operator = options.operator;
        if (options.message) {
          this.message = options.message;
          this.generatedMessage = false
        } else {
          this.message = getMessage(this);
          this.generatedMessage = true
        }
        var stackStartFunction = options.stackStartFunction || fail;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, stackStartFunction)
        } else {
          var err = new Error;
          if (err.stack) {
            var out = err.stack;
            var fn_name = stackStartFunction.name;
            var idx = out.indexOf("\n" + fn_name);
            if (idx >= 0) {
              var next_line = out.indexOf("\n", idx + 1);
              out = out.substring(next_line + 1)
            }
            this.stack = out
          }
        }
      };
      util.inherits(assert.AssertionError, Error);

      function replacer(key, value) {
        if (util.isUndefined(value)) {
          return "" + value
        }
        if (util.isNumber(value) && !isFinite(value)) {
          return value.toString()
        }
        if (util.isFunction(value) || util.isRegExp(value)) {
          return value.toString()
        }
        return value
      }

      function truncate(s, n) {
        if (util.isString(s)) {
          return s.length < n ? s : s.slice(0, n)
        } else {
          return s
        }
      }

      function getMessage(self) {
        return truncate(JSON.stringify(self.actual, replacer), 128) + " " + self.operator + " " + truncate(JSON.stringify(self.expected, replacer), 128)
      }

      function fail(actual, expected, message, operator, stackStartFunction) {
        throw new assert.AssertionError({
          message: message,
          actual: actual,
          expected: expected,
          operator: operator,
          stackStartFunction: stackStartFunction
        })
      }
      assert.fail = fail;

      function ok(value, message) {
        if (!value) fail(value, true, message, "==", assert.ok)
      }
      assert.ok = ok;
      assert.equal = function equal(actual, expected, message) {
        if (actual != expected) fail(actual, expected, message, "==", assert.equal)
      };
      assert.notEqual = function notEqual(actual, expected, message) {
        if (actual == expected) {
          fail(actual, expected, message, "!=", assert.notEqual)
        }
      };
      assert.deepEqual = function deepEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected)) {
          fail(actual, expected, message, "deepEqual", assert.deepEqual)
        }
      };

      function _deepEqual(actual, expected) {
        if (actual === expected) {
          return true
        } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
          if (actual.length != expected.length) return false;
          for (var i = 0; i < actual.length; i++) {
            if (actual[i] !== expected[i]) return false
          }
          return true
        } else if (util.isDate(actual) && util.isDate(expected)) {
          return actual.getTime() === expected.getTime()
        } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
          return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase
        } else if (!util.isObject(actual) && !util.isObject(expected)) {
          return actual == expected
        } else {
          return objEquiv(actual, expected)
        }
      }

      function isArguments(object) {
        return Object.prototype.toString.call(object) == "[object Arguments]"
      }

      function objEquiv(a, b) {
        if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b)) return false;
        if (a.prototype !== b.prototype) return false;
        if (util.isPrimitive(a) || util.isPrimitive(b)) {
          return a === b
        }
        var aIsArgs = isArguments(a),
          bIsArgs = isArguments(b);
        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
        if (aIsArgs) {
          a = pSlice.call(a);
          b = pSlice.call(b);
          return _deepEqual(a, b)
        }
        var ka = objectKeys(a),
          kb = objectKeys(b),
          key, i;
        if (ka.length != kb.length) return false;
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) return false
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!_deepEqual(a[key], b[key])) return false
        }
        return true
      }
      assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (_deepEqual(actual, expected)) {
          fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual)
        }
      };
      assert.strictEqual = function strictEqual(actual, expected, message) {
        if (actual !== expected) {
          fail(actual, expected, message, "===", assert.strictEqual)
        }
      };
      assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (actual === expected) {
          fail(actual, expected, message, "!==", assert.notStrictEqual)
        }
      };

      function expectedException(actual, expected) {
        if (!actual || !expected) {
          return false
        }
        if (Object.prototype.toString.call(expected) == "[object RegExp]") {
          return expected.test(actual)
        } else if (actual instanceof expected) {
          return true
        } else if (expected.call({}, actual) === true) {
          return true
        }
        return false
      }

      function _throws(shouldThrow, block, expected, message) {
        var actual;
        if (util.isString(expected)) {
          message = expected;
          expected = null
        }
        try {
          block()
        } catch (e) {
          actual = e
        }
        message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
        if (shouldThrow && !actual) {
          fail(actual, expected, "Missing expected exception" + message)
        }
        if (!shouldThrow && expectedException(actual, expected)) {
          fail(actual, expected, "Got unwanted exception" + message)
        }
        if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
          throw actual
        }
      }
      assert.throws = function(block, error, message) {
        _throws.apply(this, [true].concat(pSlice.call(arguments)))
      };
      assert.doesNotThrow = function(block, message) {
        _throws.apply(this, [false].concat(pSlice.call(arguments)))
      };
      assert.ifError = function(err) {
        if (err) {
          throw err
        }
      };
      var objectKeys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) {
          if (hasOwn.call(obj, key)) keys.push(key)
        }
        return keys
      }
    }, {
      "util/": 36
    }],
    3: [function(require, module, exports) {
      arguments[4][1][0].apply(exports, arguments)
    }, {
      dup: 1
    }],
    4: [function(require, module, exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object")
          }
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p]
            }
          }
        }
        return obj
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf
        }
        if (buf.subarray) {
          return buf.subarray(0, size)
        }
        buf.length = size;
        return buf
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length
          }
          return result
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks)
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped)
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped)
        }
      };
      exports.setTyped(TYPED_OK)
    }, {}],
    5: [function(require, module, exports) {
      "use strict";

      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0,
          s2 = adler >>> 16 & 65535 | 0,
          n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0
          } while (--n);
          s1 %= 65521;
          s2 %= 65521
        }
        return s1 | s2 << 16 | 0
      }
      module.exports = adler32
    }, {}],
    6: [function(require, module, exports) {
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      }
    }, {}],
    7: [function(require, module, exports) {
      "use strict";

      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1
          }
          table[n] = c
        }
        return table
      }
      var crcTable = makeTable();

      function crc32(crc, buf, len, pos) {
        var t = crcTable,
          end = pos + len;
        crc = crc ^ -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255]
        }
        return crc ^ -1
      }
      module.exports = crc32
    }, {}],
    8: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var trees = require("./trees");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var msg = require("./messages");
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode
      }

      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0)
      }

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }

      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out
        }
        if (len === 0) {
          return
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0
        }
      }

      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm)
      }

      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b
      }

      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255
      }

      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size
        }
        if (len === 0) {
          return 0
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start)
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start)
        }
        strm.next_in += len;
        strm.total_in += len;
        return len
      }

      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue
          }
          scan += 2;
          match++;
          do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len]
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len
        }
        return s.lookahead
      }

      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            more += _w_size
          }
          if (s.strm.avail_in === 0) {
            break
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
      }

      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5
        }
        for (;;) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_NEED_MORE
      }

      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head)
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              } while (--s.match_length !== 0);
              s.strstart++
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false)
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (;;) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_huff(s, flush) {
        var bflush;
        for (;;) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE
              }
              break
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }
      var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func
      };
      var configuration_table;
      configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];

      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0
      }

      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0
      }

      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK
      }

      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state)
        }
        return ret
      }

      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR
        }
        strm.state.gzhead = head;
        return Z_OK
      }

      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR)
        }
        if (windowBits === 8) {
          windowBits = 9
        }
        var s = new DeflateState;
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = s.lit_bufsize >> 1;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm)
      }

      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
      }

      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255)
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0
            } else if (s.level < 6) {
              level_flags = 1
            } else if (s.level === 6) {
              level_flags = 2
            } else {
              level_flags = 3
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535)
            }
            strm.adler = 1
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE
            }
          } else {
            s.status = NAME_STATE
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE
            }
          } else {
            s.status = COMMENT_STATE
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.status = HCRC_STATE
            }
          } else {
            s.status = HCRC_STATE
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm)
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE
            }
          } else {
            s.status = BUSY_STATE
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR)
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR)
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1
            }
            return Z_OK
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s)
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255)
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535)
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END
      }

      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateInfo = "pako deflate (from Nodeca project)"
    }, {
      "../utils/common": 4,
      "./adler32": 5,
      "./crc32": 7,
      "./messages": 12,
      "./trees": 13
    }],
    9: [function(require, module, exports) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8
          }
          here = lcode[hold & lmask];
          dolen: for (;;) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8
              }
              here = dcode[hold & dmask];
              dodist: for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = _out - dist;
                        from_source = output
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++]
                          } while (--op);
                          from = _out - dist;
                          from_source = output
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = _out - dist;
                        from_source = output
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++]
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++]
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top
                }
                break
              }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen
            } else if (op & 32) {
              state.mode = TYPE;
              break top
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top
            }
            break
          }
        } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return
      }
    }, {}],
    10: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var inflate_fast = require("./inffast");
      var inflate_table = require("./inftrees");
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;

      function ZSWAP32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
      }

      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0
      }

      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK
      }

      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm)
      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm)
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR
        }
        state = new InflateState;
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null
        }
        return ret
      }

      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS)
      }
      var virgin = true;
      var lenfix, distfix;

      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8
          }
          while (sym < 256) {
            state.lens[sym++] = 9
          }
          while (sym < 280) {
            state.lens[sym++] = 7
          }
          while (sym < 288) {
            state.lens[sym++] = 8
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });
          virgin = false
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5
      }

      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize)
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0
            }
            if (state.whave < state.wsize) {
              state.whave += dist
            }
          }
        }
        return 0
      }

      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave: for (;;) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.time = hold
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0)
                }
                hold = 0;
                bits = 0
              } else if (state.head) {
                state.head.extra = null
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len)
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len)
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next)
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy
                }
                if (state.length) {
                  break inf_leave
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.name = null
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.comment = null
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              strm.adler = state.check = ZSWAP32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have
                }
                if (copy > left) {
                  copy = left
                }
                if (copy === 0) {
                  break inf_leave
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;;) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break
                  }
                  while (copy--) {
                    state.lens[state.have++] = len
                  }
                }
              }
              if (state.mode === BAD) {
                break
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break
              }
              state.lenbits = 9;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1
                }
                break
              }
              state.back = 0;
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (;;) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy
                } else {
                  from = state.wnext - copy
                }
                if (copy > state.length) {
                  copy = state.length
                }
                from_source = state.window
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length
              }
              if (copy > left) {
                copy = left
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++]
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)
                }
                _out = left;
                if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR
          }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR
        }
        return ret
      }

      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        var state = strm.state;
        if (state.window) {
          state.window = null
        }
        strm.state = null;
        return Z_OK
      }

      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR
        }
        state.head = head;
        head.done = false;
        return Z_OK
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateInfo = "pako inflate (from Nodeca project)"
    }, {
      "../utils/common": 4,
      "./adler32": 5,
      "./crc32": 7,
      "./inffast": 9,
      "./inftrees": 11
    }],
    11: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
      var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
      var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
      var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0,
          max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break
          }
        }
        if (root > max) {
          root = max
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break
          }
        }
        if (root < min) {
          root = min
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len]
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256
        } else {
          base = dbase;
          extra = dext;
          end = -1
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1
        }
        var i = 0;
        for (;;) {
          i++;
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym]
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]]
          } else {
            here_op = 32 + 64;
            here_val = 0
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr
          } else {
            huff = 0
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break
            }
            len = lens[lens_index + work[sym]]
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break
              }
              curr++;
              left <<= 1
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0
        }
        opts.bits = root;
        return 0
      }
    }, {
      "../utils/common": 4
    }],
    12: [function(require, module, exports) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      }
    }, {}],
    13: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length
      };
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      var TreeDesc = function(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc
      };

      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
      }

      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255
      }

      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length
        }
      }

      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2], tree[c * 2 + 1])
      }

      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1
        } while (--len > 0);
        return res >>> 1
      }

      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8
        }
      }

      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base]
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits)
          }
        }
        if (overflow === 0) {
          return
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits
            }
            n--
          }
        }
      }

      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len)
        }
      }

      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5)
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
      }

      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0
      }

      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf)
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf
        }
        s.bi_buf = 0;
        s.bi_valid = 0
      }

      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len)
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len
      }

      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
      }

      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1
        }
        s.heap[k] = v
      }

      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree)
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra)
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra)
              }
            }
          } while (lx < s.last_lit)
        }
        send_code(s, END_BLOCK, ltree)
      }

      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0
          } else {
            tree[n * 2 + 1] = 0
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1]
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n)
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1)
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count)
      }

      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++
            }
            s.bl_tree[REP_3_6 * 2]++
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++
          } else {
            s.bl_tree[REPZ_11_138 * 2]++
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree)
            } while (--count !== 0)
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2)
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3)
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7)
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex
      }

      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3)
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1)
      }

      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT
          }
        }
        return Z_BINARY
      }
      var static_init_done = false;

      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s)
      }

      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true)
      }

      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s)
      }

      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s)
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last)
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree)
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree)
        }
        init_block(s);
        if (last) {
          bi_windup(s)
        }
      }

      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++
        }
        return s.last_lit === s.lit_bufsize - 1
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align
    }, {
      "../utils/common": 4
    }],
    14: [function(require, module, exports) {
      "use strict";

      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0
      }
      module.exports = ZStream
    }, {}],
    15: [function(require, module, exports) {
      (function(process, Buffer) {
        var msg = require("pako/lib/zlib/messages");
        var zstream = require("pako/lib/zlib/zstream");
        var zlib_deflate = require("pako/lib/zlib/deflate.js");
        var zlib_inflate = require("pako/lib/zlib/inflate.js");
        var constants = require("pako/lib/zlib/constants");
        for (var key in constants) {
          exports[key] = constants[key]
        }
        exports.NONE = 0;
        exports.DEFLATE = 1;
        exports.INFLATE = 2;
        exports.GZIP = 3;
        exports.GUNZIP = 4;
        exports.DEFLATERAW = 5;
        exports.INFLATERAW = 6;
        exports.UNZIP = 7;

        function Zlib(mode) {
          if (mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError("Bad argument");
          this.mode = mode;
          this.init_done = false;
          this.write_in_progress = false;
          this.pending_close = false;
          this.windowBits = 0;
          this.level = 0;
          this.memLevel = 0;
          this.strategy = 0;
          this.dictionary = null
        }
        Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
          this.windowBits = windowBits;
          this.level = level;
          this.memLevel = memLevel;
          this.strategy = strategy;
          if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) this.windowBits += 16;
          if (this.mode === exports.UNZIP) this.windowBits += 32;
          if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) this.windowBits = -this.windowBits;
          this.strm = new zstream;
          switch (this.mode) {
            case exports.DEFLATE:
            case exports.GZIP:
            case exports.DEFLATERAW:
              var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
              break;
            case exports.INFLATE:
            case exports.GUNZIP:
            case exports.INFLATERAW:
            case exports.UNZIP:
              var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
              break;
            default:
              throw new Error("Unknown mode " + this.mode)
          }
          if (status !== exports.Z_OK) {
            this._error(status);
            return
          }
          this.write_in_progress = false;
          this.init_done = true
        };
        Zlib.prototype.params = function() {
          throw new Error("deflateParams Not supported")
        };
        Zlib.prototype._writeCheck = function() {
          if (!this.init_done) throw new Error("write before init");
          if (this.mode === exports.NONE) throw new Error("already finalized");
          if (this.write_in_progress) throw new Error("write already in progress");
          if (this.pending_close) throw new Error("close is pending")
        };
        Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
          this._writeCheck();
          this.write_in_progress = true;
          var self = this;
          process.nextTick(function() {
            self.write_in_progress = false;
            var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
            self.callback(res[0], res[1]);
            if (self.pending_close) self.close()
          });
          return this
        };

        function bufferSet(data, offset) {
          for (var i = 0; i < data.length; i++) {
            this[offset + i] = data[i]
          }
        }
        Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
          this._writeCheck();
          return this._write(flush, input, in_off, in_len, out, out_off, out_len)
        };
        Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
          this.write_in_progress = true;
          if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
            throw new Error("Invalid flush value")
          }
          if (input == null) {
            input = new Buffer(0);
            in_len = 0;
            in_off = 0
          }
          if (out._set) out.set = out._set;
          else out.set = bufferSet;
          var strm = this.strm;
          strm.avail_in = in_len;
          strm.input = input;
          strm.next_in = in_off;
          strm.avail_out = out_len;
          strm.output = out;
          strm.next_out = out_off;
          switch (this.mode) {
            case exports.DEFLATE:
            case exports.GZIP:
            case exports.DEFLATERAW:
              var status = zlib_deflate.deflate(strm, flush);
              break;
            case exports.UNZIP:
            case exports.INFLATE:
            case exports.GUNZIP:
            case exports.INFLATERAW:
              var status = zlib_inflate.inflate(strm, flush);
              break;
            default:
              throw new Error("Unknown mode " + this.mode)
          }
          if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
            this._error(status)
          }
          this.write_in_progress = false;
          return [strm.avail_in, strm.avail_out]
        };
        Zlib.prototype.close = function() {
          if (this.write_in_progress) {
            this.pending_close = true;
            return
          }
          this.pending_close = false;
          if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
            zlib_deflate.deflateEnd(this.strm)
          } else {
            zlib_inflate.inflateEnd(this.strm)
          }
          this.mode = exports.NONE
        };
        Zlib.prototype.reset = function() {
          switch (this.mode) {
            case exports.DEFLATE:
            case exports.DEFLATERAW:
              var status = zlib_deflate.deflateReset(this.strm);
              break;
            case exports.INFLATE:
            case exports.INFLATERAW:
              var status = zlib_inflate.inflateReset(this.strm);
              break
          }
          if (status !== exports.Z_OK) {
            this._error(status)
          }
        };
        Zlib.prototype._error = function(status) {
          this.onerror(msg[status] + ": " + this.strm.msg, status);
          this.write_in_progress = false;
          if (this.pending_close) this.close()
        };
        exports.Zlib = Zlib
      }).call(this, require("_process"), require("buffer").Buffer)
    }, {
      _process: 25,
      buffer: 17,
      "pako/lib/zlib/constants": 6,
      "pako/lib/zlib/deflate.js": 8,
      "pako/lib/zlib/inflate.js": 10,
      "pako/lib/zlib/messages": 12,
      "pako/lib/zlib/zstream": 14
    }],
    16: [function(require, module, exports) {
      (function(process, Buffer) {
        var Transform = require("_stream_transform");
        var binding = require("./binding");
        var util = require("util");
        var assert = require("assert").ok;
        binding.Z_MIN_WINDOWBITS = 8;
        binding.Z_MAX_WINDOWBITS = 15;
        binding.Z_DEFAULT_WINDOWBITS = 15;
        binding.Z_MIN_CHUNK = 64;
        binding.Z_MAX_CHUNK = Infinity;
        binding.Z_DEFAULT_CHUNK = 16 * 1024;
        binding.Z_MIN_MEMLEVEL = 1;
        binding.Z_MAX_MEMLEVEL = 9;
        binding.Z_DEFAULT_MEMLEVEL = 8;
        binding.Z_MIN_LEVEL = -1;
        binding.Z_MAX_LEVEL = 9;
        binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
        Object.keys(binding).forEach(function(k) {
          if (k.match(/^Z/)) exports[k] = binding[k]
        });
        exports.codes = {
          Z_OK: binding.Z_OK,
          Z_STREAM_END: binding.Z_STREAM_END,
          Z_NEED_DICT: binding.Z_NEED_DICT,
          Z_ERRNO: binding.Z_ERRNO,
          Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
          Z_DATA_ERROR: binding.Z_DATA_ERROR,
          Z_MEM_ERROR: binding.Z_MEM_ERROR,
          Z_BUF_ERROR: binding.Z_BUF_ERROR,
          Z_VERSION_ERROR: binding.Z_VERSION_ERROR
        };
        Object.keys(exports.codes).forEach(function(k) {
          exports.codes[exports.codes[k]] = k
        });
        exports.Deflate = Deflate;
        exports.Inflate = Inflate;
        exports.Gzip = Gzip;
        exports.Gunzip = Gunzip;
        exports.DeflateRaw = DeflateRaw;
        exports.InflateRaw = InflateRaw;
        exports.Unzip = Unzip;
        exports.createDeflate = function(o) {
          return new Deflate(o)
        };
        exports.createInflate = function(o) {
          return new Inflate(o)
        };
        exports.createDeflateRaw = function(o) {
          return new DeflateRaw(o)
        };
        exports.createInflateRaw = function(o) {
          return new InflateRaw(o)
        };
        exports.createGzip = function(o) {
          return new Gzip(o)
        };
        exports.createGunzip = function(o) {
          return new Gunzip(o)
        };
        exports.createUnzip = function(o) {
          return new Unzip(o)
        };
        exports.deflate = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new Deflate(opts), buffer, callback)
        };
        exports.deflateSync = function(buffer, opts) {
          return zlibBufferSync(new Deflate(opts), buffer)
        };
        exports.gzip = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new Gzip(opts), buffer, callback)
        };
        exports.gzipSync = function(buffer, opts) {
          return zlibBufferSync(new Gzip(opts), buffer)
        };
        exports.deflateRaw = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new DeflateRaw(opts), buffer, callback)
        };
        exports.deflateRawSync = function(buffer, opts) {
          return zlibBufferSync(new DeflateRaw(opts), buffer)
        };
        exports.unzip = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new Unzip(opts), buffer, callback)
        };
        exports.unzipSync = function(buffer, opts) {
          return zlibBufferSync(new Unzip(opts), buffer)
        };
        exports.inflate = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new Inflate(opts), buffer, callback)
        };
        exports.inflateSync = function(buffer, opts) {
          return zlibBufferSync(new Inflate(opts), buffer)
        };
        exports.gunzip = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new Gunzip(opts), buffer, callback)
        };
        exports.gunzipSync = function(buffer, opts) {
          return zlibBufferSync(new Gunzip(opts), buffer)
        };
        exports.inflateRaw = function(buffer, opts, callback) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {}
          }
          return zlibBuffer(new InflateRaw(opts), buffer, callback)
        };
        exports.inflateRawSync = function(buffer, opts) {
          return zlibBufferSync(new InflateRaw(opts), buffer)
        };

        function zlibBuffer(engine, buffer, callback) {
          var buffers = [];
          var nread = 0;
          engine.on("error", onError);
          engine.on("end", onEnd);
          engine.end(buffer);
          flow();

          function flow() {
            var chunk;
            while (null !== (chunk = engine.read())) {
              buffers.push(chunk);
              nread += chunk.length
            }
            engine.once("readable", flow)
          }

          function onError(err) {
            engine.removeListener("end", onEnd);
            engine.removeListener("readable", flow);
            callback(err)
          }

          function onEnd() {
            var buf = Buffer.concat(buffers, nread);
            buffers = [];
            callback(null, buf);
            engine.close()
          }
        }

        function zlibBufferSync(engine, buffer) {
          if (typeof buffer === "string") buffer = new Buffer(buffer);
          if (!Buffer.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
          var flushFlag = binding.Z_FINISH;
          return engine._processChunk(buffer, flushFlag)
        }

        function Deflate(opts) {
          if (!(this instanceof Deflate)) return new Deflate(opts);
          Zlib.call(this, opts, binding.DEFLATE)
        }

        function Inflate(opts) {
          if (!(this instanceof Inflate)) return new Inflate(opts);
          Zlib.call(this, opts, binding.INFLATE)
        }

        function Gzip(opts) {
          if (!(this instanceof Gzip)) return new Gzip(opts);
          Zlib.call(this, opts, binding.GZIP)
        }

        function Gunzip(opts) {
          if (!(this instanceof Gunzip)) return new Gunzip(opts);
          Zlib.call(this, opts, binding.GUNZIP)
        }

        function DeflateRaw(opts) {
          if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
          Zlib.call(this, opts, binding.DEFLATERAW)
        }

        function InflateRaw(opts) {
          if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
          Zlib.call(this, opts, binding.INFLATERAW)
        }

        function Unzip(opts) {
          if (!(this instanceof Unzip)) return new Unzip(opts);
          Zlib.call(this, opts, binding.UNZIP)
        }

        function Zlib(opts, mode) {
          this._opts = opts = opts || {};
          this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
          Transform.call(this, opts);
          if (opts.flush) {
            if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
              throw new Error("Invalid flush flag: " + opts.flush)
            }
          }
          this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
          if (opts.chunkSize) {
            if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
              throw new Error("Invalid chunk size: " + opts.chunkSize)
            }
          }
          if (opts.windowBits) {
            if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
              throw new Error("Invalid windowBits: " + opts.windowBits)
            }
          }
          if (opts.level) {
            if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
              throw new Error("Invalid compression level: " + opts.level)
            }
          }
          if (opts.memLevel) {
            if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
              throw new Error("Invalid memLevel: " + opts.memLevel)
            }
          }
          if (opts.strategy) {
            if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
              throw new Error("Invalid strategy: " + opts.strategy)
            }
          }
          if (opts.dictionary) {
            if (!Buffer.isBuffer(opts.dictionary)) {
              throw new Error("Invalid dictionary: it should be a Buffer instance")
            }
          }
          this._binding = new binding.Zlib(mode);
          var self = this;
          this._hadError = false;
          this._binding.onerror = function(message, errno) {
            self._binding = null;
            self._hadError = true;
            var error = new Error(message);
            error.errno = errno;
            error.code = exports.codes[errno];
            self.emit("error", error)
          };
          var level = exports.Z_DEFAULT_COMPRESSION;
          if (typeof opts.level === "number") level = opts.level;
          var strategy = exports.Z_DEFAULT_STRATEGY;
          if (typeof opts.strategy === "number") strategy = opts.strategy;
          this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
          this._buffer = new Buffer(this._chunkSize);
          this._offset = 0;
          this._closed = false;
          this._level = level;
          this._strategy = strategy;
          this.once("end", this.close)
        }
        util.inherits(Zlib, Transform);
        Zlib.prototype.params = function(level, strategy, callback) {
          if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
            throw new RangeError("Invalid compression level: " + level)
          }
          if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
            throw new TypeError("Invalid strategy: " + strategy)
          }
          if (this._level !== level || this._strategy !== strategy) {
            var self = this;
            this.flush(binding.Z_SYNC_FLUSH, function() {
              self._binding.params(level, strategy);
              if (!self._hadError) {
                self._level = level;
                self._strategy = strategy;
                if (callback) callback()
              }
            })
          } else {
            process.nextTick(callback)
          }
        };
        Zlib.prototype.reset = function() {
          return this._binding.reset()
        };
        Zlib.prototype._flush = function(callback) {
          this._transform(new Buffer(0), "", callback)
        };
        Zlib.prototype.flush = function(kind, callback) {
          var ws = this._writableState;
          if (typeof kind === "function" || kind === void 0 && !callback) {
            callback = kind;
            kind = binding.Z_FULL_FLUSH
          }
          if (ws.ended) {
            if (callback) process.nextTick(callback)
          } else if (ws.ending) {
            if (callback) this.once("end", callback)
          } else if (ws.needDrain) {
            var self = this;
            this.once("drain", function() {
              self.flush(callback)
            })
          } else {
            this._flushFlag = kind;
            this.write(new Buffer(0), "", callback)
          }
        };
        Zlib.prototype.close = function(callback) {
          if (callback) process.nextTick(callback);
          if (this._closed) return;
          this._closed = true;
          this._binding.close();
          var self = this;
          process.nextTick(function() {
            self.emit("close")
          })
        };
        Zlib.prototype._transform = function(chunk, encoding, cb) {
          var flushFlag;
          var ws = this._writableState;
          var ending = ws.ending || ws.ended;
          var last = ending && (!chunk || ws.length === chunk.length);
          if (!chunk === null && !Buffer.isBuffer(chunk)) return cb(new Error("invalid input"));
          if (last) flushFlag = binding.Z_FINISH;
          else {
            flushFlag = this._flushFlag;
            if (chunk.length >= ws.length) {
              this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH
            }
          }
          var self = this;
          this._processChunk(chunk, flushFlag, cb)
        };
        Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
          var availInBefore = chunk && chunk.length;
          var availOutBefore = this._chunkSize - this._offset;
          var inOff = 0;
          var self = this;
          var async = typeof cb === "function";
          if (!async) {
            var buffers = [];
            var nread = 0;
            var error;
            this.on("error", function(er) {
              error = er
            });
            do {
              var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore)
            } while (!this._hadError && callback(res[0], res[1]));
            if (this._hadError) {
              throw error
            }
            var buf = Buffer.concat(buffers, nread);
            this.close();
            return buf
          }
          var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
          req.buffer = chunk;
          req.callback = callback;

          function callback(availInAfter, availOutAfter) {
            if (self._hadError) return;
            var have = availOutBefore - availOutAfter;
            assert(have >= 0, "have should not go down");
            if (have > 0) {
              var out = self._buffer.slice(self._offset, self._offset + have);
              self._offset += have;
              if (async) {
                self.push(out)
              } else {
                buffers.push(out);
                nread += out.length
              }
            }
            if (availOutAfter === 0 || self._offset >= self._chunkSize) {
              availOutBefore = self._chunkSize;
              self._offset = 0;
              self._buffer = new Buffer(self._chunkSize)
            }
            if (availOutAfter === 0) {
              inOff += availInBefore - availInAfter;
              availInBefore = availInAfter;
              if (!async) return true;
              var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
              newReq.callback = callback;
              newReq.buffer = chunk;
              return
            }
            if (!async) return false;
            cb()
          }
        };
        util.inherits(Deflate, Zlib);
        util.inherits(Inflate, Zlib);
        util.inherits(Gzip, Zlib);
        util.inherits(Gunzip, Zlib);
        util.inherits(DeflateRaw, Zlib);
        util.inherits(InflateRaw, Zlib);
        util.inherits(Unzip, Zlib)
      }).call(this, require("_process"), require("buffer").Buffer)
    }, {
      "./binding": 15,
      _process: 25,
      _stream_transform: 33,
      assert: 2,
      buffer: 17,
      util: 36
    }],
    17: [function(require, module, exports) {
      (function(global) {
        var base64 = require("base64-js");
        var ieee754 = require("ieee754");
        var isArray = require("is-array");
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        var rootParent = {};
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

        function typedArraySupport() {
          function Bar() {}
          try {
            var arr = new Uint8Array(1);
            arr.foo = function() {
              return 42
            };
            arr.constructor = Bar;
            return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0
          } catch (e) {
            return false
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function Buffer(arg) {
          if (!(this instanceof Buffer)) {
            if (arguments.length > 1) return new Buffer(arg, arguments[1]);
            return new Buffer(arg)
          }
          this.length = 0;
          this.parent = undefined;
          if (typeof arg === "number") {
            return fromNumber(this, arg)
          }
          if (typeof arg === "string") {
            return fromString(this, arg, arguments.length > 1 ? arguments[1] : "utf8")
          }
          return fromObject(this, arg)
        }

        function fromNumber(that, length) {
          that = allocate(that, length < 0 ? 0 : checked(length) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < length; i++) {
              that[i] = 0
            }
          }
          return that
        }

        function fromString(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
          var length = byteLength(string, encoding) | 0;
          that = allocate(that, length);
          that.write(string, encoding);
          return that
        }

        function fromObject(that, object) {
          if (Buffer.isBuffer(object)) return fromBuffer(that, object);
          if (isArray(object)) return fromArray(that, object);
          if (object == null) {
            throw new TypeError("must start with number, buffer, array or string")
          }
          if (typeof ArrayBuffer !== "undefined") {
            if (object.buffer instanceof ArrayBuffer) {
              return fromTypedArray(that, object)
            }
            if (object instanceof ArrayBuffer) {
              return fromArrayBuffer(that, object)
            }
          }
          if (object.length) return fromArrayLike(that, object);
          return fromJsonObject(that, object)
        }

        function fromBuffer(that, buffer) {
          var length = checked(buffer.length) | 0;
          that = allocate(that, length);
          buffer.copy(that, 0, 0, length);
          return that
        }

        function fromArray(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromTypedArray(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromArrayBuffer(that, array) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            array.byteLength;
            that = Buffer._augment(new Uint8Array(array))
          } else {
            that = fromTypedArray(that, new Uint8Array(array))
          }
          return that
        }

        function fromArrayLike(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromJsonObject(that, object) {
          var array;
          var length = 0;
          if (object.type === "Buffer" && isArray(object.data)) {
            array = object.data;
            length = checked(array.length) | 0
          }
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array
        }

        function allocate(that, length) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            that = Buffer._augment(new Uint8Array(length));
            that.__proto__ = Buffer.prototype
          } else {
            that.length = length;
            that._isBuffer = true
          }
          var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
          if (fromPool) that.parent = rootParent;
          return that
        }

        function checked(length) {
          if (length >= kMaxLength()) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes")
          }
          return length | 0
        }

        function SlowBuffer(subject, encoding) {
          if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);
          var buf = new Buffer(subject, encoding);
          delete buf.parent;
          return buf
        }
        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer)
        };
        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers")
          }
          if (a === b) return 0;
          var x = a.length;
          var y = b.length;
          var i = 0;
          var len = Math.min(x, y);
          while (i < len) {
            if (a[i] !== b[i]) break;
            ++i
          }
          if (i !== len) {
            x = a[i];
            y = b[i]
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) throw new TypeError("list argument must be an Array of Buffers.");
          if (list.length === 0) {
            return new Buffer(0)
          }
          var i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; i++) {
              length += list[i].length
            }
          }
          var buf = new Buffer(length);
          var pos = 0;
          for (i = 0; i < list.length; i++) {
            var item = list[i];
            item.copy(buf, pos);
            pos += item.length
          }
          return buf
        };

        function byteLength(string, encoding) {
          if (typeof string !== "string") string = "" + string;
          var len = string.length;
          if (len === 0) return 0;
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "binary":
              case "raw":
              case "raws":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength;
        Buffer.prototype.length = undefined;
        Buffer.prototype.parent = undefined;

        function slowToString(encoding, start, end) {
          var loweredCase = false;
          start = start | 0;
          end = end === undefined || end === Infinity ? this.length : end | 0;
          if (!encoding) encoding = "utf8";
          if (start < 0) start = 0;
          if (end > this.length) end = this.length;
          if (end <= start) return "";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "binary":
                return binarySlice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true
            }
          }
        }
        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments)
        };
        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer.compare(this, b) === 0
        };
        Buffer.prototype.inspect = function inspect() {
          var str = "";
          var max = exports.INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max) str += " ... "
          }
          return "<Buffer " + str + ">"
        };
        Buffer.prototype.compare = function compare(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return 0;
          return Buffer.compare(this, b)
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
          if (byteOffset > 2147483647) byteOffset = 2147483647;
          else if (byteOffset < -2147483648) byteOffset = -2147483648;
          byteOffset >>= 0;
          if (this.length === 0) return -1;
          if (byteOffset >= this.length) return -1;
          if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
          if (typeof val === "string") {
            if (val.length === 0) return -1;
            return String.prototype.indexOf.call(this, val, byteOffset)
          }
          if (Buffer.isBuffer(val)) {
            return arrayIndexOf(this, val, byteOffset)
          }
          if (typeof val === "number") {
            if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
              return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
            }
            return arrayIndexOf(this, [val], byteOffset)
          }

          function arrayIndexOf(arr, val, byteOffset) {
            var foundIndex = -1;
            for (var i = 0; byteOffset + i < arr.length; i++) {
              if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
              } else {
                foundIndex = -1
              }
            }
            return -1
          }
          throw new TypeError("val must be string, number or Buffer")
        };
        Buffer.prototype.get = function get(offset) {
          console.log(".get() is deprecated. Access using array indexes instead.");
          return this.readUInt8(offset)
        };
        Buffer.prototype.set = function set(v, offset) {
          console.log(".set() is deprecated. Access using array indexes instead.");
          return this.writeUInt8(v, offset)
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining
            }
          }
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new Error("Invalid hex string");
          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; i++) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) throw new Error("Invalid hex string");
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function binaryWrite(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
          if (offset === undefined) {
            encoding = "utf8";
            length = this.length;
            offset = 0
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = "utf8"
            } else {
              encoding = length;
              length = undefined
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length | 0;
            length = swap
          }
          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("attempt to write outside buffer bounds")
          }
          if (!encoding) encoding = "utf8";
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
                return asciiWrite(this, string, offset, length);
              case "binary":
                return binaryWrite(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true
            }
          }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023
            }
            res.push(codePoint);
            i += bytesPerSequence
          }
          return decodeCodePointsArray(res)
        }
        var MAX_ARGUMENTS_LENGTH = 4096;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints)
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH))
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i] & 127)
          }
          return ret
        }

        function binarySlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = "";
          for (var i = start; i < end; i++) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }
          if (end < start) end = start;
          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = Buffer._augment(this.subarray(start, end))
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);
            for (var i = 0; i < sliceLen; i++) {
              newBuf[i] = this[i + start]
            }
          }
          if (newBuf.length) newBuf.parent = this.parent || this;
          return newBuf
        };

        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
          if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length")
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 256)) {
            val += this[offset + i] * mul
          }
          return val
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }
          var val = this[offset + --byteLength];
          var mul = 1;
          while (byteLength > 0 && (mul *= 256)) {
            val += this[offset + --byteLength] * mul
          }
          return val
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset]
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1]
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 256)) {
            val += this[offset + i] * mul
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128)) return this[offset];
          return (255 - this[offset] + 1) * -1
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4)
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4)
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8)
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8)
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError("buffer must be a Buffer instance");
          if (value > max || value < min) throw new RangeError("value is out of bounds");
          if (offset + ext > buf.length) throw new RangeError("index out of range")
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength && (mul *= 256)) {
            this[offset + i] = value / mul & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 255;
          return offset + 1
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 65535 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
          }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 4294967295 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
          }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = 0;
          var mul = 1;
          var sub = value < 0 ? 1 : 0;
          this[offset] = value & 255;
          while (++i < byteLength && (mul *= 256)) {
            this[offset + i] = (value / mul >> 0) - sub & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = byteLength - 1;
          var mul = 1;
          var sub = value < 0 ? 1 : 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = (value / mul >> 0) - sub & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0) value = 4294967295 + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (value > max || value < min) throw new RangeError("value is out of bounds");
          if (offset + ext > buf.length) throw new RangeError("index out of range");
          if (offset < 0) throw new RangeError("index out of range")
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38)
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert)
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert)
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308)
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert)
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert)
        };
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds")
          }
          if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; i--) {
              target[i + targetStart] = this[i + start]
            }
          } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; i++) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            target._set(this.subarray(start, start + len), targetStart)
          }
          return len
        };
        Buffer.prototype.fill = function fill(value, start, end) {
          if (!value) value = 0;
          if (!start) start = 0;
          if (!end) end = this.length;
          if (end < start) throw new RangeError("end < start");
          if (end === start) return;
          if (this.length === 0) return;
          if (start < 0 || start >= this.length) throw new RangeError("start out of bounds");
          if (end < 0 || end > this.length) throw new RangeError("end out of bounds");
          var i;
          if (typeof value === "number") {
            for (i = start; i < end; i++) {
              this[i] = value
            }
          } else {
            var bytes = utf8ToBytes(value.toString());
            var len = bytes.length;
            for (i = start; i < end; i++) {
              this[i] = bytes[i % len]
            }
          }
          return this
        };
        Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
          if (typeof Uint8Array !== "undefined") {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              return new Buffer(this).buffer
            } else {
              var buf = new Uint8Array(this.length);
              for (var i = 0, len = buf.length; i < len; i += 1) {
                buf[i] = this[i]
              }
              return buf.buffer
            }
          } else {
            throw new TypeError("Buffer.toArrayBuffer not supported in this browser")
          }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function _augment(arr) {
          arr.constructor = Buffer;
          arr._isBuffer = true;
          arr._set = arr.set;
          arr.get = BP.get;
          arr.set = BP.set;
          arr.write = BP.write;
          arr.toString = BP.toString;
          arr.toLocaleString = BP.toString;
          arr.toJSON = BP.toJSON;
          arr.equals = BP.equals;
          arr.compare = BP.compare;
          arr.indexOf = BP.indexOf;
          arr.copy = BP.copy;
          arr.slice = BP.slice;
          arr.readUIntLE = BP.readUIntLE;
          arr.readUIntBE = BP.readUIntBE;
          arr.readUInt8 = BP.readUInt8;
          arr.readUInt16LE = BP.readUInt16LE;
          arr.readUInt16BE = BP.readUInt16BE;
          arr.readUInt32LE = BP.readUInt32LE;
          arr.readUInt32BE = BP.readUInt32BE;
          arr.readIntLE = BP.readIntLE;
          arr.readIntBE = BP.readIntBE;
          arr.readInt8 = BP.readInt8;
          arr.readInt16LE = BP.readInt16LE;
          arr.readInt16BE = BP.readInt16BE;
          arr.readInt32LE = BP.readInt32LE;
          arr.readInt32BE = BP.readInt32BE;
          arr.readFloatLE = BP.readFloatLE;
          arr.readFloatBE = BP.readFloatBE;
          arr.readDoubleLE = BP.readDoubleLE;
          arr.readDoubleBE = BP.readDoubleBE;
          arr.writeUInt8 = BP.writeUInt8;
          arr.writeUIntLE = BP.writeUIntLE;
          arr.writeUIntBE = BP.writeUIntBE;
          arr.writeUInt16LE = BP.writeUInt16LE;
          arr.writeUInt16BE = BP.writeUInt16BE;
          arr.writeUInt32LE = BP.writeUInt32LE;
          arr.writeUInt32BE = BP.writeUInt32BE;
          arr.writeIntLE = BP.writeIntLE;
          arr.writeIntBE = BP.writeIntBE;
          arr.writeInt8 = BP.writeInt8;
          arr.writeInt16LE = BP.writeInt16LE;
          arr.writeInt16BE = BP.writeInt16BE;
          arr.writeInt32LE = BP.writeInt32LE;
          arr.writeInt32BE = BP.writeInt32BE;
          arr.writeFloatLE = BP.writeFloatLE;
          arr.writeFloatBE = BP.writeFloatBE;
          arr.writeDoubleLE = BP.writeDoubleLE;
          arr.writeDoubleBE = BP.writeDoubleBE;
          arr.fill = BP.fill;
          arr.inspect = BP.inspect;
          arr.toArrayBuffer = BP.toArrayBuffer;
          return arr
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, "");
          if (str.length < 2) return "";
          while (str.length % 4 !== 0) {
            str = str + "="
          }
          return str
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, "")
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16);
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; i++) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue
                }
                leadSurrogate = codePoint;
                continue
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue
              }
              codePoint = leadSurrogate - 55296 << 10 | codePoint - 56320 | 65536
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189)
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint)
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0) break;
              bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128)
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0) break;
              bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0) break;
              bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
            } else {
              throw new Error("Invalid code point")
            }
          }
          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 255)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi)
          }
          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; i++) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i]
          }
          return i
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
      "base64-js": 18,
      ieee754: 19,
      "is-array": 20
    }],
    18: [function(require, module, exports) {
      var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      (function(exports) {
        "use strict";
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var PLUS = "+".charCodeAt(0);
        var SLASH = "/".charCodeAt(0);
        var NUMBER = "0".charCodeAt(0);
        var LOWER = "a".charCodeAt(0);
        var UPPER = "A".charCodeAt(0);
        var PLUS_URL_SAFE = "-".charCodeAt(0);
        var SLASH_URL_SAFE = "_".charCodeAt(0);

        function decode(elt) {
          var code = elt.charCodeAt(0);
          if (code === PLUS || code === PLUS_URL_SAFE) return 62;
          if (code === SLASH || code === SLASH_URL_SAFE) return 63;
          if (code < NUMBER) return -1;
          if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
          if (code < UPPER + 26) return code - UPPER;
          if (code < LOWER + 26) return code - LOWER + 26
        }

        function b64ToByteArray(b64) {
          var i, j, l, tmp, placeHolders, arr;
          if (b64.length % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4")
          }
          var len = b64.length;
          placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
          arr = new Arr(b64.length * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? b64.length - 4 : b64.length;
          var L = 0;

          function push(v) {
            arr[L++] = v
          }
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
            push((tmp & 16711680) >> 16);
            push((tmp & 65280) >> 8);
            push(tmp & 255)
          }
          if (placeHolders === 2) {
            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
            push(tmp & 255)
          } else if (placeHolders === 1) {
            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
            push(tmp >> 8 & 255);
            push(tmp & 255)
          }
          return arr
        }

        function uint8ToBase64(uint8) {
          var i, extraBytes = uint8.length % 3,
            output = "",
            temp, length;

          function encode(num) {
            return lookup.charAt(num)
          }

          function tripletToBase64(num) {
            return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63)
          }
          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output += tripletToBase64(temp)
          }
          switch (extraBytes) {
            case 1:
              temp = uint8[uint8.length - 1];
              output += encode(temp >> 2);
              output += encode(temp << 4 & 63);
              output += "==";
              break;
            case 2:
              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
              output += encode(temp >> 10);
              output += encode(temp >> 4 & 63);
              output += encode(temp << 2 & 63);
              output += "=";
              break
          }
          return output
        }
        exports.toByteArray = b64ToByteArray;
        exports.fromByteArray = uint8ToBase64
      })(typeof exports === "undefined" ? this.base64js = {} : exports)
    }, {}],
    19: [function(require, module, exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2
          }
          if (e + eBias >= 1) {
            value += rt / c
          } else {
            value += rt * Math.pow(2, 1 - eBias)
          }
          if (value * c >= 2) {
            e++;
            c /= 2
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128
      }
    }, {}],
    20: [function(require, module, exports) {
      var isArray = Array.isArray;
      var str = Object.prototype.toString;
      module.exports = isArray || function(val) {
        return !!val && "[object Array]" == str.call(val)
      }
    }, {}],
    21: [function(require, module, exports) {
      function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined
      }
      module.exports = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._maxListeners = undefined;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this
      };
      EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;
        if (!this._events) this._events = {};
        if (type === "error") {
          if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
            er = arguments[1];
            if (er instanceof Error) {
              throw er
            }
            throw TypeError('Uncaught, unspecified "error" event.')
          }
        }
        handler = this._events[type];
        if (isUndefined(handler)) return false;
        if (isFunction(handler)) {
          switch (arguments.length) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args = Array.prototype.slice.call(arguments, 1);
              handler.apply(this, args)
          }
        } else if (isObject(handler)) {
          args = Array.prototype.slice.call(arguments, 1);
          listeners = handler.slice();
          len = listeners.length;
          for (i = 0; i < len; i++) listeners[i].apply(this, args)
        }
        return true
      };
      EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events) this._events = {};
        if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type]) this._events[type] = listener;
        else if (isObject(this._events[type])) this._events[type].push(listener);
        else this._events[type] = [this._events[type], listener];
        if (isObject(this._events[type]) && !this._events[type].warned) {
          if (!isUndefined(this._maxListeners)) {
            m = this._maxListeners
          } else {
            m = EventEmitter.defaultMaxListeners
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
            if (typeof console.trace === "function") {
              console.trace()
            }
          }
        }
        return this
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        var fired = false;

        function g() {
          this.removeListener(type, g);
          if (!fired) {
            fired = true;
            listener.apply(this, arguments)
          }
        }
        g.listener = listener;
        this.on(type, g);
        return this
      };
      EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
          delete this._events[type];
          if (this._events.removeListener) this.emit("removeListener", type, listener)
        } else if (isObject(list)) {
          for (i = length; i-- > 0;) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              position = i;
              break
            }
          }
          if (position < 0) return this;
          if (list.length === 1) {
            list.length = 0;
            delete this._events[type]
          } else {
            list.splice(position, 1)
          }
          if (this._events.removeListener) this.emit("removeListener", type, listener)
        }
        return this
      };
      EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        if (!this._events) return this;
        if (!this._events.removeListener) {
          if (arguments.length === 0) this._events = {};
          else if (this._events[type]) delete this._events[type];
          return this
        }
        if (arguments.length === 0) {
          for (key in this._events) {
            if (key === "removeListener") continue;
            this.removeAllListeners(key)
          }
          this.removeAllListeners("removeListener");
          this._events = {};
          return this
        }
        listeners = this._events[type];
        if (isFunction(listeners)) {
          this.removeListener(type, listeners)
        } else if (listeners) {
          while (listeners.length) this.removeListener(type, listeners[listeners.length - 1])
        }
        delete this._events[type];
        return this
      };
      EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type]) ret = [];
        else if (isFunction(this._events[type])) ret = [this._events[type]];
        else ret = this._events[type].slice();
        return ret
      };
      EventEmitter.prototype.listenerCount = function(type) {
        if (this._events) {
          var evlistener = this._events[type];
          if (isFunction(evlistener)) return 1;
          else if (evlistener) return evlistener.length
        }
        return 0
      };
      EventEmitter.listenerCount = function(emitter, type) {
        return emitter.listenerCount(type)
      };

      function isFunction(arg) {
        return typeof arg === "function"
      }

      function isNumber(arg) {
        return typeof arg === "number"
      }

      function isObject(arg) {
        return typeof arg === "object" && arg !== null
      }

      function isUndefined(arg) {
        return arg === void 0
      }
    }, {}],
    22: [function(require, module, exports) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          })
        }
      } else {
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor;
          ctor.prototype.constructor = ctor
        }
      }
    }, {}],
    23: [function(require, module, exports) {
      module.exports = function(obj) {
        return !!(obj != null && (obj._isBuffer || obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj)))
      }
    }, {}],
    24: [function(require, module, exports) {
      module.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == "[object Array]"
      }
    }, {}],
    25: [function(require, module, exports) {
      var process = module.exports = {};
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue)
        } else {
          queueIndex = -1
        }
        if (queue.length) {
          drainQueue()
        }
      }

      function drainQueue() {
        if (draining) {
          return
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run()
            }
          }
          queueIndex = -1;
          len = queue.length
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout)
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i]
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          setTimeout(drainQueue, 0)
        }
      };

      function Item(fun, array) {
        this.fun = fun;
        this.array = array
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array)
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};

      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.binding = function(name) {
        throw new Error("process.binding is not supported")
      };
      process.cwd = function() {
        return "/"
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported")
      };
      process.umask = function() {
        return 0
      }
    }, {}],
    26: [function(require, module, exports) {
      "use strict";
      var objectKeys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys
      };
      module.exports = Duplex;
      var processNextTick = require("process-nextick-args");
      var util = require("core-util-is");
      util.inherits = require("inherits");
      var Readable = require("./_stream_readable");
      var Writable = require("./_stream_writable");
      util.inherits(Duplex, Readable);
      var keys = objectKeys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
      }

      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once("end", onend)
      }

      function onend() {
        if (this.allowHalfOpen || this._writableState.ended) return;
        processNextTick(onEndNT, this)
      }

      function onEndNT(self) {
        self.end()
      }

      function forEach(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i)
        }
      }
    }, {
      "./_stream_readable": 27,
      "./_stream_writable": 29,
      "core-util-is": 30,
      inherits: 22,
      "process-nextick-args": 31
    }],
    27: [function(require, module, exports) {
      (function(process) {
        "use strict";
        module.exports = Readable;
        var processNextTick = require("process-nextick-args");
        var isArray = require("isarray");
        var Buffer = require("buffer").Buffer;
        Readable.ReadableState = ReadableState;
        var EE = require("events");
        var EElistenerCount = function(emitter, type) {
          return emitter.listeners(type).length
        };
        var Stream;
        (function() {
          try {
            Stream = require("st" + "ream")
          } catch (_) {} finally {
            if (!Stream) Stream = require("events").EventEmitter
          }
        })();
        var Buffer = require("buffer").Buffer;
        var util = require("core-util-is");
        util.inherits = require("inherits");
        var debugUtil = require("util");
        var debug;
        if (debugUtil && debugUtil.debuglog) {
          debug = debugUtil.debuglog("stream")
        } else {
          debug = function() {}
        }
        var StringDecoder;
        util.inherits(Readable, Stream);

        function ReadableState(options, stream) {
          var Duplex = require("./_stream_duplex");
          options = options || {};
          this.objectMode = !!options.objectMode;
          if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
          var hwm = options.highWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
          this.highWaterMark = ~~this.highWaterMark;
          this.buffer = [];
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false;
          this.sync = true;
          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.ranOut = false;
          this.awaitDrain = 0;
          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;
          if (options.encoding) {
            if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding
          }
        }

        function Readable(options) {
          var Duplex = require("./_stream_duplex");
          if (!(this instanceof Readable)) return new Readable(options);
          this._readableState = new ReadableState(options, this);
          this.readable = true;
          if (options && typeof options.read === "function") this._read = options.read;
          Stream.call(this)
        }
        Readable.prototype.push = function(chunk, encoding) {
          var state = this._readableState;
          if (!state.objectMode && typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = new Buffer(chunk, encoding);
              encoding = ""
            }
          }
          return readableAddChunk(this, state, chunk, encoding, false)
        };
        Readable.prototype.unshift = function(chunk) {
          var state = this._readableState;
          return readableAddChunk(this, state, chunk, "", true)
        };
        Readable.prototype.isPaused = function() {
          return this._readableState.flowing === false
        };

        function readableAddChunk(stream, state, chunk, encoding, addToFront) {
          var er = chunkInvalid(state, chunk);
          if (er) {
            stream.emit("error", er)
          } else if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state)
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (state.ended && !addToFront) {
              var e = new Error("stream.push() after EOF");
              stream.emit("error", e)
            } else if (state.endEmitted && addToFront) {
              var e = new Error("stream.unshift() after end event");
              stream.emit("error", e)
            } else {
              if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
              if (!addToFront) state.reading = false;
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0)
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk);
                else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream)
              }
              maybeReadMore(stream, state)
            }
          } else if (!addToFront) {
            state.reading = false
          }
          return needMoreData(state)
        }

        function needMoreData(state) {
          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0)
        }
        Readable.prototype.setEncoding = function(enc) {
          if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
          this._readableState.decoder = new StringDecoder(enc);
          this._readableState.encoding = enc;
          return this
        };
        var MAX_HWM = 8388608;

        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM
          } else {
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++
          }
          return n
        }

        function howMuchToRead(n, state) {
          if (state.length === 0 && state.ended) return 0;
          if (state.objectMode) return n === 0 ? 0 : 1;
          if (n === null || isNaN(n)) {
            if (state.flowing && state.buffer.length) return state.buffer[0].length;
            else return state.length
          }
          if (n <= 0) return 0;
          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
          if (n > state.length) {
            if (!state.ended) {
              state.needReadable = true;
              return 0
            } else {
              return state.length
            }
          }
          return n
        }
        Readable.prototype.read = function(n) {
          debug("read", n);
          var state = this._readableState;
          var nOrig = n;
          if (typeof n !== "number" || n > 0) state.emittedReadable = false;
          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
            debug("read: emitReadable", state.length, state.ended);
            if (state.length === 0 && state.ended) endReadable(this);
            else emitReadable(this);
            return null
          }
          n = howMuchToRead(n, state);
          if (n === 0 && state.ended) {
            if (state.length === 0) endReadable(this);
            return null
          }
          var doRead = state.needReadable;
          debug("need readable", doRead);
          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug("length less than watermark", doRead)
          }
          if (state.ended || state.reading) {
            doRead = false;
            debug("reading or ended", doRead)
          }
          if (doRead) {
            debug("do read");
            state.reading = true;
            state.sync = true;
            if (state.length === 0) state.needReadable = true;
            this._read(state.highWaterMark);
            state.sync = false
          }
          if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
          var ret;
          if (n > 0) ret = fromList(n, state);
          else ret = null;
          if (ret === null) {
            state.needReadable = true;
            n = 0
          }
          state.length -= n;
          if (state.length === 0 && !state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
          if (ret !== null) this.emit("data", ret);
          return ret
        };

        function chunkInvalid(state, chunk) {
          var er = null;
          if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== undefined && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk")
          }
          return er
        }

        function onEofChunk(stream, state) {
          if (state.ended) return;
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length
            }
          }
          state.ended = true;
          emitReadable(stream)
        }

        function emitReadable(stream) {
          var state = stream._readableState;
          state.needReadable = false;
          if (!state.emittedReadable) {
            debug("emitReadable", state.flowing);
            state.emittedReadable = true;
            if (state.sync) processNextTick(emitReadable_, stream);
            else emitReadable_(stream)
          }
        }

        function emitReadable_(stream) {
          debug("emit readable");
          stream.emit("readable");
          flow(stream)
        }

        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            processNextTick(maybeReadMore_, stream, state)
          }
        }

        function maybeReadMore_(stream, state) {
          var len = state.length;
          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
            debug("maybeReadMore read 0");
            stream.read(0);
            if (len === state.length) break;
            else len = state.length
          }
          state.readingMore = false
        }
        Readable.prototype._read = function(n) {
          this.emit("error", new Error("not implemented"))
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
          var src = this;
          var state = this._readableState;
          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [state.pipes, dest];
              break;
            default:
              state.pipes.push(dest);
              break
          }
          state.pipesCount += 1;
          debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : cleanup;
          if (state.endEmitted) processNextTick(endFn);
          else src.once("end", endFn);
          dest.on("unpipe", onunpipe);

          function onunpipe(readable) {
            debug("onunpipe");
            if (readable === src) {
              cleanup()
            }
          }

          function onend() {
            debug("onend");
            dest.end()
          }
          var ondrain = pipeOnDrain(src);
          dest.on("drain", ondrain);

          function cleanup() {
            debug("cleanup");
            dest.removeListener("close", onclose);
            dest.removeListener("finish", onfinish);
            dest.removeListener("drain", ondrain);
            dest.removeListener("error", onerror);
            dest.removeListener("unpipe", onunpipe);
            src.removeListener("end", onend);
            src.removeListener("end", cleanup);
            src.removeListener("data", ondata);
            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain()
          }
          src.on("data", ondata);

          function ondata(chunk) {
            debug("ondata");
            var ret = dest.write(chunk);
            if (false === ret) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              src.pause()
            }
          }

          function onerror(er) {
            debug("onerror", er);
            unpipe();
            dest.removeListener("error", onerror);
            if (EElistenerCount(dest, "error") === 0) dest.emit("error", er)
          }
          if (!dest._events || !dest._events.error) dest.on("error", onerror);
          else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);
          else dest._events.error = [onerror, dest._events.error];

          function onclose() {
            dest.removeListener("finish", onfinish);
            unpipe()
          }
          dest.once("close", onclose);

          function onfinish() {
            debug("onfinish");
            dest.removeListener("close", onclose);
            unpipe()
          }
          dest.once("finish", onfinish);

          function unpipe() {
            debug("unpipe");
            src.unpipe(dest)
          }
          dest.emit("pipe", src);
          if (!state.flowing) {
            debug("pipe resume");
            src.resume()
          }
          return dest
        };

        function pipeOnDrain(src) {
          return function() {
            var state = src._readableState;
            debug("pipeOnDrain", state.awaitDrain);
            if (state.awaitDrain) state.awaitDrain--;
            if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
              state.flowing = true;
              flow(src)
            }
          }
        }
        Readable.prototype.unpipe = function(dest) {
          var state = this._readableState;
          if (state.pipesCount === 0) return this;
          if (state.pipesCount === 1) {
            if (dest && dest !== state.pipes) return this;
            if (!dest) dest = state.pipes;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest) dest.emit("unpipe", this);
            return this
          }
          if (!dest) {
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            for (var i = 0; i < len; i++) dests[i].emit("unpipe", this);
            return this
          }
          var i = indexOf(state.pipes, dest);
          if (i === -1) return this;
          state.pipes.splice(i, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1) state.pipes = state.pipes[0];
          dest.emit("unpipe", this);
          return this
        };
        Readable.prototype.on = function(ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);
          if (ev === "data" && false !== this._readableState.flowing) {
            this.resume()
          }
          if (ev === "readable" && this.readable) {
            var state = this._readableState;
            if (!state.readableListening) {
              state.readableListening = true;
              state.emittedReadable = false;
              state.needReadable = true;
              if (!state.reading) {
                processNextTick(nReadingNextTick, this)
              } else if (state.length) {
                emitReadable(this, state)
              }
            }
          }
          return res
        };
        Readable.prototype.addListener = Readable.prototype.on;

        function nReadingNextTick(self) {
          debug("readable nexttick read 0");
          self.read(0)
        }
        Readable.prototype.resume = function() {
          var state = this._readableState;
          if (!state.flowing) {
            debug("resume");
            state.flowing = true;
            resume(this, state)
          }
          return this
        };

        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            processNextTick(resume_, stream, state)
          }
        }

        function resume_(stream, state) {
          if (!state.reading) {
            debug("resume read 0");
            stream.read(0)
          }
          state.resumeScheduled = false;
          stream.emit("resume");
          flow(stream);
          if (state.flowing && !state.reading) stream.read(0)
        }
        Readable.prototype.pause = function() {
          debug("call pause flowing=%j", this._readableState.flowing);
          if (false !== this._readableState.flowing) {
            debug("pause");
            this._readableState.flowing = false;
            this.emit("pause")
          }
          return this
        };

        function flow(stream) {
          var state = stream._readableState;
          debug("flow", state.flowing);
          if (state.flowing) {
            do {
              var chunk = stream.read()
            } while (null !== chunk && state.flowing)
          }
        }
        Readable.prototype.wrap = function(stream) {
          var state = this._readableState;
          var paused = false;
          var self = this;
          stream.on("end", function() {
            debug("wrapped end");
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) self.push(chunk)
            }
            self.push(null)
          });
          stream.on("data", function(chunk) {
            debug("wrapped data");
            if (state.decoder) chunk = state.decoder.write(chunk);
            if (state.objectMode && (chunk === null || chunk === undefined)) return;
            else if (!state.objectMode && (!chunk || !chunk.length)) return;
            var ret = self.push(chunk);
            if (!ret) {
              paused = true;
              stream.pause()
            }
          });
          for (var i in stream) {
            if (this[i] === undefined && typeof stream[i] === "function") {
              this[i] = function(method) {
                return function() {
                  return stream[method].apply(stream, arguments)
                }
              }(i)
            }
          }
          var events = ["error", "close", "destroy", "pause", "resume"];
          forEach(events, function(ev) {
            stream.on(ev, self.emit.bind(self, ev))
          });
          self._read = function(n) {
            debug("wrapped _read", n);
            if (paused) {
              paused = false;
              stream.resume()
            }
          };
          return self
        };
        Readable._fromList = fromList;

        function fromList(n, state) {
          var list = state.buffer;
          var length = state.length;
          var stringMode = !!state.decoder;
          var objectMode = !!state.objectMode;
          var ret;
          if (list.length === 0) return null;
          if (length === 0) ret = null;
          else if (objectMode) ret = list.shift();
          else if (!n || n >= length) {
            if (stringMode) ret = list.join("");
            else ret = Buffer.concat(list, length);
            list.length = 0
          } else {
            if (n < list[0].length) {
              var buf = list[0];
              ret = buf.slice(0, n);
              list[0] = buf.slice(n)
            } else if (n === list[0].length) {
              ret = list.shift()
            } else {
              if (stringMode) ret = "";
              else ret = new Buffer(n);
              var c = 0;
              for (var i = 0, l = list.length; i < l && c < n; i++) {
                var buf = list[0];
                var cpy = Math.min(n - c, buf.length);
                if (stringMode) ret += buf.slice(0, cpy);
                else buf.copy(ret, c, 0, cpy);
                if (cpy < buf.length) list[0] = buf.slice(cpy);
                else list.shift();
                c += cpy
              }
            }
          }
          return ret
        }

        function endReadable(stream) {
          var state = stream._readableState;
          if (state.length > 0) throw new Error("endReadable called on non-empty stream");
          if (!state.endEmitted) {
            state.ended = true;
            processNextTick(endReadableNT, state, stream)
          }
        }

        function endReadableNT(state, stream) {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end")
          }
        }

        function forEach(xs, f) {
          for (var i = 0, l = xs.length; i < l; i++) {
            f(xs[i], i)
          }
        }

        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) return i
          }
          return -1
        }
      }).call(this, require("_process"))
    }, {
      "./_stream_duplex": 26,
      _process: 25,
      buffer: 17,
      "core-util-is": 30,
      events: 21,
      inherits: 22,
      isarray: 24,
      "process-nextick-args": 31,
      "string_decoder/": 34,
      util: 3
    }],
    28: [function(require, module, exports) {
      "use strict";
      module.exports = Transform;
      var Duplex = require("./_stream_duplex");
      var util = require("core-util-is");
      util.inherits = require("inherits");
      util.inherits(Transform, Duplex);

      function TransformState(stream) {
        this.afterTransform = function(er, data) {
          return afterTransform(stream, er, data)
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null
      }

      function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) return stream.emit("error", new Error("no writecb in Transform class"));
        ts.writechunk = null;
        ts.writecb = null;
        if (data !== null && data !== undefined) stream.push(data);
        if (cb) cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark)
        }
      }

      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function") this._flush(function(er) {
            done(stream, er)
          });
          else done(stream)
        })
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding)
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("not implemented")
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark)
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
        } else {
          ts.needTransform = true
        }
      };

      function done(stream, er) {
        if (er) return stream.emit("error", er);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length) throw new Error("calling transform done when ws.length != 0");
        if (ts.transforming) throw new Error("calling transform done when still transforming");
        return stream.push(null)
      }
    }, {
      "./_stream_duplex": 26,
      "core-util-is": 30,
      inherits: 22
    }],
    29: [function(require, module, exports) {
      "use strict";
      module.exports = Writable;
      var processNextTick = require("process-nextick-args");
      var Buffer = require("buffer").Buffer;
      Writable.WritableState = WritableState;
      var util = require("core-util-is");
      util.inherits = require("inherits");
      var internalUtil = {
        deprecate: require("util-deprecate")
      };
      var Stream;
      (function() {
        try {
          Stream = require("st" + "ream")
        } catch (_) {} finally {
          if (!Stream) Stream = require("events").EventEmitter
        }
      })();
      var Buffer = require("buffer").Buffer;
      util.inherits(Writable, Stream);

      function nop() {}

      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null
      }

      function WritableState(options, stream) {
        var Duplex = require("./_stream_duplex");
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er)
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false
      }
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next
        }
        return out
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.")
          })
        } catch (_) {}
      })();

      function Writable(options) {
        var Duplex = require("./_stream_duplex");
        if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev
        }
        Stream.call(this)
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe. Not readable."))
      };

      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        processNextTick(cb, er)
      }

      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== undefined && !state.objectMode) {
          var er = new TypeError("Invalid non-string/buffer chunk");
          stream.emit("error", er);
          processNextTick(cb, er);
          valid = false
        }
        return valid
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null
        }
        if (Buffer.isBuffer(chunk)) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ended) writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb)
        }
        return ret
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state)
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding
      };

      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = new Buffer(chunk, encoding)
        }
        return chunk
      }

      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer.isBuffer(chunk)) encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest
          } else {
            state.bufferedRequest = state.lastBufferedRequest
          }
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb)
        }
        return ret
      }

      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev) stream._writev(chunk, state.onwrite);
        else stream._write(chunk, encoding, state.onwrite);
        state.sync = false
      }

      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) processNextTick(cb, er);
        else cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er)
      }

      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0
      }

      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er) onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state)
          }
          if (sync) {
            processNextTick(afterWrite, stream, state, finished, cb)
          } else {
            afterWrite(stream, state, finished, cb)
          }
        }
      }

      function afterWrite(stream, state, finished, cb) {
        if (!finished) onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state)
      }

      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain")
        }
      }

      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var buffer = [];
          var cbs = [];
          while (entry) {
            cbs.push(entry.callback);
            buffer.push(entry);
            entry = entry.next
          }
          state.pendingcb++;
          state.lastBufferedRequest = null;
          doWrite(stream, state, true, state.length, buffer, "", function(err) {
            for (var i = 0; i < cbs.length; i++) {
              state.pendingcb--;
              cbs[i](err)
            }
          })
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break
            }
          }
          if (entry === null) state.lastBufferedRequest = null
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"))
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null
        }
        if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork()
        }
        if (!state.ending && !state.finished) endWritable(this, state, cb)
      };

      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing
      }

      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit("prefinish")
        }
      }

      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit("finish")
          } else {
            prefinish(stream, state)
          }
        }
        return need
      }

      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished) processNextTick(cb);
          else stream.once("finish", cb)
        }
        state.ended = true
      }
    }, {
      "./_stream_duplex": 26,
      buffer: 17,
      "core-util-is": 30,
      events: 21,
      inherits: 22,
      "process-nextick-args": 31,
      "util-deprecate": 32
    }],
    30: [function(require, module, exports) {
      (function(Buffer) {
        function isArray(ar) {
          return Array.isArray(ar)
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
          return typeof arg === "boolean"
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
          return arg === null
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
          return arg == null
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
          return typeof arg === "number"
        }
        exports.isNumber = isNumber;

        function isString(arg) {
          return typeof arg === "string"
        }
        exports.isString = isString;

        function isSymbol(arg) {
          return typeof arg === "symbol"
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
          return arg === void 0
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
          return isObject(re) && objectToString(re) === "[object RegExp]"
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
          return typeof arg === "object" && arg !== null
        }
        exports.isObject = isObject;

        function isDate(d) {
          return isObject(d) && objectToString(d) === "[object Date]"
        }
        exports.isDate = isDate;

        function isError(e) {
          return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error)
        }
        exports.isError = isError;

        function isFunction(arg) {
          return typeof arg === "function"
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined"
        }
        exports.isPrimitive = isPrimitive;

        function isBuffer(arg) {
          return Buffer.isBuffer(arg)
        }
        exports.isBuffer = isBuffer;

        function objectToString(o) {
          return Object.prototype.toString.call(o)
        }
      }).call(this, {
        isBuffer: require("../../../../insert-module-globals/node_modules/is-buffer/index.js")
      })
    }, {
      "../../../../insert-module-globals/node_modules/is-buffer/index.js": 23
    }],
    31: [function(require, module, exports) {
      (function(process) {
        "use strict";
        module.exports = nextTick;

        function nextTick(fn) {
          var args = new Array(arguments.length - 1);
          var i = 0;
          while (i < args.length) {
            args[i++] = arguments[i]
          }
          process.nextTick(function afterTick() {
            fn.apply(null, args)
          })
        }
      }).call(this, require("_process"))
    }, {
      _process: 25
    }],
    32: [function(require, module, exports) {
      (function(global) {
        module.exports = deprecate;

        function deprecate(fn, msg) {
          if (config("noDeprecation")) {
            return fn
          }
          var warned = false;

          function deprecated() {
            if (!warned) {
              if (config("throwDeprecation")) {
                throw new Error(msg)
              } else if (config("traceDeprecation")) {
                console.trace(msg)
              } else {
                console.warn(msg)
              }
              warned = true
            }
            return fn.apply(this, arguments)
          }
          return deprecated
        }

        function config(name) {
          try {
            if (!global.localStorage) return false
          } catch (_) {
            return false
          }
          var val = global.localStorage[name];
          if (null == val) return false;
          return String(val).toLowerCase() === "true"
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    33: [function(require, module, exports) {
      module.exports = require("./lib/_stream_transform.js")
    }, {
      "./lib/_stream_transform.js": 28
    }],
    34: [function(require, module, exports) {
      var Buffer = require("buffer").Buffer;
      var isBufferEncoding = Buffer.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false
        }
      };

      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding)
        }
      }
      var StringDecoder = exports.StringDecoder = function(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return
        }
        this.charBuffer = new Buffer(6);
        this.charReceived = 0;
        this.charLength = 0
      };
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return ""
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr
          }
          break
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end)
        }
        return charStr
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break
          }
        }
        this.charReceived = i
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length) res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc)
        }
        return res
      };

      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding)
      }

      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0
      }

      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0
      }
    }, {
      buffer: 17
    }],
    35: [function(require, module, exports) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function"
      }
    }, {}],
    36: [function(require, module, exports) {
      (function(process, global) {
        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
          if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]))
            }
            return objects.join(" ")
          }
          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function(x) {
            if (x === "%%") return "%";
            if (i >= len) return x;
            switch (x) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++])
                } catch (_) {
                  return "[Circular]"
                }
              default:
                return x
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
              str += " " + x
            } else {
              str += " " + inspect(x)
            }
          }
          return str
        };
        exports.deprecate = function(fn, msg) {
          if (isUndefined(global.process)) {
            return function() {
              return exports.deprecate(fn, msg).apply(this, arguments)
            }
          }
          if (process.noDeprecation === true) {
            return fn
          }
          var warned = false;

          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) {
                throw new Error(msg)
              } else if (process.traceDeprecation) {
                console.trace(msg)
              } else {
                console.error(msg)
              }
              warned = true
            }
            return fn.apply(this, arguments)
          }
          return deprecated
        };
        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
          if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
          set = set.toUpperCase();
          if (!debugs[set]) {
            if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
              var pid = process.pid;
              debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error("%s %d: %s", set, pid, msg)
              }
            } else {
              debugs[set] = function() {}
            }
          }
          return debugs[set]
        };

        function inspect(obj, opts) {
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          if (arguments.length >= 3) ctx.depth = arguments[2];
          if (arguments.length >= 4) ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            ctx.showHidden = opts
          } else if (opts) {
            exports._extend(ctx, opts)
          }
          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
          if (isUndefined(ctx.depth)) ctx.depth = 2;
          if (isUndefined(ctx.colors)) ctx.colors = false;
          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
          if (ctx.colors) ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth)
        }
        exports.inspect = inspect;
        inspect.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        };
        inspect.styles = {
          special: "cyan",
          number: "yellow",
          "boolean": "yellow",
          undefined: "grey",
          "null": "bold",
          string: "green",
          date: "magenta",
          regexp: "red"
        };

        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];
          if (style) {
            return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m"
          } else {
            return str
          }
        }

        function stylizeNoColor(str, styleType) {
          return str
        }

        function arrayToHash(array) {
          var hash = {};
          array.forEach(function(val, idx) {
            hash[val] = true
          });
          return hash
        }

        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes)
            }
            return ret
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive
          }
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);
          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value)
          }
          if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
            return formatError(value)
          }
          if (keys.length === 0) {
            if (isFunction(value)) {
              var name = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name + "]", "special")
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), "date")
            }
            if (isError(value)) {
              return formatError(value)
            }
          }
          var base = "",
            array = false,
            braces = ["{", "}"];
          if (isArray(value)) {
            array = true;
            braces = ["[", "]"]
          }
          if (isFunction(value)) {
            var n = value.name ? ": " + value.name : "";
            base = " [Function" + n + "]"
          }
          if (isRegExp(value)) {
            base = " " + RegExp.prototype.toString.call(value)
          }
          if (isDate(value)) {
            base = " " + Date.prototype.toUTCString.call(value)
          }
          if (isError(value)) {
            base = " " + formatError(value)
          }
          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1]
          }
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
            } else {
              return ctx.stylize("[Object]", "special")
            }
          }
          ctx.seen.push(value);
          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
          } else {
            output = keys.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
            })
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base, braces)
        }

        function formatPrimitive(ctx, value) {
          if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
          if (isString(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string")
          }
          if (isNumber(value)) return ctx.stylize("" + value, "number");
          if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
          if (isNull(value)) return ctx.stylize("null", "null")
        }

        function formatError(value) {
          return "[" + Error.prototype.toString.call(value) + "]"
        }

        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true))
            } else {
              output.push("")
            }
          }
          keys.forEach(function(key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true))
            }
          });
          return output
        }

        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || {
            value: value[key]
          };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize("[Getter/Setter]", "special")
            } else {
              str = ctx.stylize("[Getter]", "special")
            }
          } else {
            if (desc.set) {
              str = ctx.stylize("[Setter]", "special")
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name = "[" + key + "]"
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null)
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1)
              }
              if (str.indexOf("\n") > -1) {
                if (array) {
                  str = str.split("\n").map(function(line) {
                    return "  " + line
                  }).join("\n").substr(2)
                } else {
                  str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line
                  }).join("\n")
                }
              }
            } else {
              str = ctx.stylize("[Circular]", "special")
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str
            }
            name = JSON.stringify("" + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, "name")
            } else {
              name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, "string")
            }
          }
          return name + ": " + str
        }

        function reduceToSingleString(output, base, braces) {
          var numLinesEst = 0;
          var length = output.reduce(function(prev, cur) {
            numLinesEst++;
            if (cur.indexOf("\n") >= 0) numLinesEst++;
            return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1
          }, 0);
          if (length > 60) {
            return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1]
          }
          return braces[0] + base + " " + output.join(", ") + " " + braces[1]
        }

        function isArray(ar) {
          return Array.isArray(ar)
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
          return typeof arg === "boolean"
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
          return arg === null
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
          return arg == null
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
          return typeof arg === "number"
        }
        exports.isNumber = isNumber;

        function isString(arg) {
          return typeof arg === "string"
        }
        exports.isString = isString;

        function isSymbol(arg) {
          return typeof arg === "symbol"
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
          return arg === void 0
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
          return isObject(re) && objectToString(re) === "[object RegExp]"
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
          return typeof arg === "object" && arg !== null
        }
        exports.isObject = isObject;

        function isDate(d) {
          return isObject(d) && objectToString(d) === "[object Date]"
        }
        exports.isDate = isDate;

        function isError(e) {
          return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error)
        }
        exports.isError = isError;

        function isFunction(arg) {
          return typeof arg === "function"
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined"
        }
        exports.isPrimitive = isPrimitive;
        exports.isBuffer = require("./support/isBuffer");

        function objectToString(o) {
          return Object.prototype.toString.call(o)
        }

        function pad(n) {
          return n < 10 ? "0" + n.toString(10) : n.toString(10)
        }
        var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        function timestamp() {
          var d = new Date;
          var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
          return [d.getDate(), months[d.getMonth()], time].join(" ")
        }
        exports.log = function() {
          console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments))
        };
        exports.inherits = require("inherits");
        exports._extend = function(origin, add) {
          if (!add || !isObject(add)) return origin;
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]]
          }
          return origin
        };

        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop)
        }
      }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
      "./support/isBuffer": 35,
      _process: 25,
      inherits: 22
    }],
    37: [function(require, module, exports) {
      "use strict";
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      module.exports.encode = function(input) {
        var output = "";
        var chr1 = void 0,
          chr2 = void 0,
          chr3 = void 0,
          enc1 = void 0,
          enc2 = void 0,
          enc3 = void 0,
          enc4 = void 0;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64
          } else if (isNaN(chr3)) {
            enc4 = 64
          }
          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)
        }
        return output
      }
    }, {}],
    38: [function(require, module, exports) {
      "use strict";
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj
      };
      var DOMParser = require("xmldom").DOMParser;
      var XMLSerializer = require("xmldom").XMLSerializer;
      var DocUtils = {};
      DocUtils.xml2Str = function(xmlNode) {
        var a = new XMLSerializer;
        return a.serializeToString(xmlNode)
      };
      DocUtils.str2xml = function(str, errorHandler) {
        var parser = new DOMParser({
          errorHandler: errorHandler
        });
        return parser.parseFromString(str, "text/xml")
      };
      DocUtils.maxArray = function(a) {
        return Math.max.apply(null, a)
      };
      DocUtils.decodeUtf8 = function(s) {
        try {
          if (s === undefined) {
            return undefined
          }
          return decodeURIComponent(escape(DocUtils.convertSpaces(s)))
        } catch (e) {
          var err = new Error("End");
          err.properties.data = s;
          err.properties.explanation = "Could not decode string to UFT8";
          throw err
        }
      };
      DocUtils.encodeUtf8 = function(s) {
        return unescape(encodeURIComponent(s))
      };
      DocUtils.convertSpaces = function(s) {
        return s.replace(new RegExp(String.fromCharCode(160), "g"), " ")
      };
      DocUtils.pregMatchAll = function(regex, content) {
        if ((typeof regex === "undefined" ? "undefined" : _typeof(regex)) !== "object") {
          regex = new RegExp(regex, "g")
        }
        var matchArray = [];
        var replacer = function replacer() {
          var pn = Array.prototype.slice.call(arguments);
          pn.pop();
          var offset = pn.pop();
          pn.offset = offset;
          return matchArray.push(pn)
        };
        content.replace(regex, replacer);
        return matchArray
      };
      module.exports = DocUtils
    }, {
      xmldom: 97
    }],
    39: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var XmlTemplater = require("docxtemplater").XmlTemplater;
      var QrCode = require("qrcode-reader");
      module.exports = function() {
        function DocxQrCode(imageData, xmlTemplater, imgName, num, getDataFromString) {
          _classCallCheck(this, DocxQrCode);
          this.xmlTemplater = xmlTemplater;
          this.imgName = imgName || "";
          this.num = num;
          this.getDataFromString = getDataFromString;
          this.callbacked = false;
          this.data = imageData;
          if (this.data === undefined) {
            throw new Error("data of qrcode can't be undefined")
          }
          this.ready = false;
          this.result = null
        }
        _createClass(DocxQrCode, [{
          key: "decode",
          value: function decode(callback) {
            this.callback = callback;
            var self = this;
            this.qr = new QrCode;
            this.qr.callback = function() {
              self.ready = true;
              self.result = this.result;
              var testdoc = new XmlTemplater(this.result, {
                fileTypeConfig: self.xmlTemplater.fileTypeConfig,
                tags: self.xmlTemplater.tags,
                Tags: self.xmlTemplater.Tags,
                parser: self.xmlTemplater.parser
              });
              testdoc.render();
              self.result = testdoc.content;
              return self.searchImage()
            };
            return this.qr.decode({
              width: this.data.width,
              height: this.data.height
            }, this.data.decoded)
          }
        }, {
          key: "searchImage",
          value: function searchImage() {
            var _this = this;
            var cb = function cb(_err, data) {
              _this.data = data || _this.data.data;
              return _this.callback(_this, _this.imgName, _this.num)
            };
            if (!(this.result != null)) {
              return cb()
            }
            return this.getDataFromString(this.result, cb)
          }
        }]);
        return DocxQrCode
      }()
    }, {
      docxtemplater: 46,
      "qrcode-reader": 96
    }],
    40: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var imageExtensions = ["gif", "jpeg", "jpg", "emf", "png"];
      var imageListRegex = /[^.]+\.([^.]+)/;
      module.exports = function() {
        function ImgManager(zip, fileName) {
          _classCallCheck(this, ImgManager);
          this.zip = zip;
          this.fileName = fileName;
          this.endFileName = this.fileName.replace(/^.*?([a-z0-9]+)\.xml$/, "$1")
        }
        _createClass(ImgManager, [{
          key: "getImageList",
          value: function getImageList() {
            var imageList = [];
            Object.keys(this.zip.files).forEach(function(path) {
              var extension = path.replace(imageListRegex, "$1");
              if (imageExtensions.indexOf(extension) >= 0) {
                imageList.push({
                  path: path,
                  files: this.zip.files[path]
                })
              }
            });
            return imageList
          }
        }, {
          key: "setImage",
          value: function setImage(fileName, data, options) {
            options = options || {};
            this.zip.remove(fileName);
            return this.zip.file(fileName, data, options)
          }
        }, {
          key: "hasImage",
          value: function hasImage(fileName) {
            return this.zip.files[fileName] != null
          }
        }, {
          key: "loadImageRels",
          value: function loadImageRels() {
            var file = this.zip.files["word/_rels/" + this.endFileName + ".xml.rels"] || this.zip.files["word/_rels/document.xml.rels"];
            if (file == null) {
              return
            }
            var content = DocUtils.decodeUtf8(file.asText());
            this.xmlDoc = DocUtils.str2xml(content);
            var RidArray = [0];
            var iterable = this.xmlDoc.getElementsByTagName("Relationship");
            for (var i = 0, tag; i < iterable.length; i++) {
              tag = iterable[i];
              var id = tag.getAttribute("Id");
              if (/^rId[0-9]+$/.test(id)) {
                RidArray.push(parseInt(id.substr(3), 10))
              }
            }
            this.maxRid = DocUtils.maxArray(RidArray);
            this.imageRels = [];
            return this
          }
        }, {
          key: "addExtensionRels",
          value: function addExtensionRels(contentType, extension) {
            var content = this.zip.files["[Content_Types].xml"].asText();
            var xmlDoc = DocUtils.str2xml(content);
            var addTag = true;
            var defaultTags = xmlDoc.getElementsByTagName("Default");
            for (var i = 0, tag; i < defaultTags.length; i++) {
              tag = defaultTags[i];
              if (tag.getAttribute("Extension") === extension) {
                addTag = false
              }
            }
            if (addTag) {
              var types = xmlDoc.getElementsByTagName("Types")[0];
              var newTag = xmlDoc.createElement("Default");
              newTag.namespaceURI = null;
              newTag.setAttribute("ContentType", contentType);
              newTag.setAttribute("Extension", extension);
              types.appendChild(newTag);
              return this.setImage("[Content_Types].xml", DocUtils.encodeUtf8(DocUtils.xml2Str(xmlDoc)))
            }
          }
        }, {
          key: "addImageRels",
          value: function addImageRels(imageName, imageData, i) {
            if (i == null) {
              i = 0
            }
            var realImageName = i === 0 ? imageName : imageName + ("(" + i + ")");
            if (this.zip.files["word/media/" + realImageName] != null) {
              return this.addImageRels(imageName, imageData, i + 1)
            }
            this.maxRid++;
            var file = {
              name: "word/media/" + realImageName,
              data: imageData,
              options: {
                base64: true,
                binary: true,
                compression: null,
                date: new Date,
                dir: false
              }
            };
            this.zip.file(file.name, file.data, file.options);
            var extension = realImageName.replace(/[^.]+\.([^.]+)/, "$1");
            this.addExtensionRels("image/" + extension, extension);
            var relationships = this.xmlDoc.getElementsByTagName("Relationships")[0];
            var newTag = this.xmlDoc.createElement("Relationship");
            newTag.namespaceURI = null;
            newTag.setAttribute("Id", "rId" + this.maxRid);
            newTag.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");
            newTag.setAttribute("Target", "media/" + realImageName);
            relationships.appendChild(newTag);
            this.setImage("word/_rels/" + this.endFileName + ".xml.rels", DocUtils.encodeUtf8(DocUtils.xml2Str(this.xmlDoc)));
            return this.maxRid
          }
        }, {
          key: "getImageName",
          value: function getImageName(id) {
            id = id || 0;
            var nameCandidate = "Copie_" + id + ".png";
            var fullPath = this.getFullPath(nameCandidate);
            if (this.hasImage(fullPath)) {
              return this.getImageName(id + 1)
            }
            return nameCandidate
          }
        }, {
          key: "getFullPath",
          value: function getFullPath(imgName) {
            return "word/media/" + imgName
          }
        }, {
          key: "getImageByRid",
          value: function getImageByRid(rId) {
            var relationships = this.xmlDoc.getElementsByTagName("Relationship");
            for (var i = 0, relationship; i < relationships.length; i++) {
              relationship = relationships[i];
              var cRId = relationship.getAttribute("Id");
              if (rId === cRId) {
                var path = relationship.getAttribute("Target");
                if (path.substr(0, 6) === "media/") {
                  return this.zip.files["word/" + path]
                }
                throw new Error("Rid is not an image")
              }
            }
            throw new Error("No Media with this Rid found")
          }
        }]);
        return ImgManager
      }()
    }, {
      "./docUtils": 38
    }],
    41: [function(require, module, exports) {
      (function(Buffer) {
        "use strict";
        var _createClass = function() {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor
          }
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
          }
        }
        var DocUtils = require("./docUtils");
        var DocxQrCode = require("./docxQrCode");
        var PNG = require("png-js");
        var base64encode = require("./base64").encode;
        module.exports = function() {
          function ImgReplacer(xmlTemplater, imgManager) {
            _classCallCheck(this, ImgReplacer);
            this.xmlTemplater = xmlTemplater;
            this.imgManager = imgManager;
            this.imageSetter = this.imageSetter.bind(this);
            this.imgMatches = [];
            this.xmlTemplater.numQrCode = 0
          }
          _createClass(ImgReplacer, [{
            key: "findImages",
            value: function findImages() {
              this.imgMatches = DocUtils.pregMatchAll(/<w:drawing[^>]*>.*?<a:blip.r:embed.*?<\/w:drawing>/g, this.xmlTemplater.content);
              return this
            }
          }, {
            key: "replaceImages",
            value: function replaceImages() {
              this.qr = [];
              this.xmlTemplater.numQrCode += this.imgMatches.length;
              var iterable = this.imgMatches;
              for (var imgNum = 0, match; imgNum < iterable.length; imgNum++) {
                match = iterable[imgNum];
                this.replaceImage(match, imgNum)
              }
              return this
            }
          }, {
            key: "imageSetter",
            value: function imageSetter(docxqrCode) {
              if (docxqrCode.callbacked === true) {
                return
              }
              docxqrCode.callbacked = true;
              docxqrCode.xmlTemplater.numQrCode--;
              this.imgManager.setImage("word/media/" + docxqrCode.imgName, docxqrCode.data, {
                binary: true
              });
              return this.popQrQueue(this.imgManager.fileName + "-" + docxqrCode.num, false)
            }
          }, {
            key: "getXmlImg",
            value: function getXmlImg(match) {
              var baseDocument = '<?xml version="1.0" ?>\n		<w:document\n		mc:Ignorable="w14 wp14"\n		xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"\n			xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"\n			xmlns:o="urn:schemas-microsoft-com:office:office"\n		xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"\n			xmlns:v="urn:schemas-microsoft-com:vml"\n		xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"\n			xmlns:w10="urn:schemas-microsoft-com:office:word"\n		xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"\n			xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"\n			xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"\n			xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"\n			xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas"\n			xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup"\n			xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk"\n			xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape">' + match[0] + "</w:document>\n			";
              var f = function f(e) {
                if (e === "fatalError") {
                  throw new Error("fatalError")
                }
              };
              return DocUtils.str2xml(baseDocument, f)
            }
          }, {
            key: "replaceImage",
            value: function replaceImage(match, imgNum) {
              var num = parseInt(Math.random() * 1e4, 10);
              var xmlImg = void 0;
              try {
                xmlImg = this.getXmlImg(match)
              } catch (e) {
                return
              }
              var tagrId = xmlImg.getElementsByTagName("a:blip")[0];
              if (tagrId == null) {
                throw new Error("tagRiD undefined !")
              }
              var rId = tagrId.getAttribute("r:embed");
              var tag = xmlImg.getElementsByTagName("wp:docPr")[0];
              if (tag == null) {
                throw new Error("tag undefined")
              }
              if (tag.getAttribute("name").substr(0, 6) === "Copie_") {
                return
              }
              var imgName = this.imgManager.getImageName();
              this.pushQrQueue(this.imgManager.fileName + "-" + num, true);
              var newId = this.imgManager.addImageRels(imgName, "");
              this.xmlTemplater.imageId++;
              var oldFile = this.imgManager.getImageByRid(rId);
              this.imgManager.setImage(this.imgManager.getFullPath(imgName), oldFile.data, {
                binary: true
              });
              tag.setAttribute("name", "" + imgName);
              tagrId.setAttribute("r:embed", "rId" + newId);
              var imageTag = xmlImg.getElementsByTagName("w:drawing")[0];
              if (imageTag == null) {
                throw new Error("imageTag undefined")
              }
              var replacement = DocUtils.xml2Str(imageTag);
              this.xmlTemplater.content = this.xmlTemplater.content.replace(match[0], replacement);
              return this.decodeImage(oldFile, imgName, num, imgNum)
            }
          }, {
            key: "decodeImage",
            value: function decodeImage(oldFile, imgName, num, imgNum) {
              var _this = this;
              var mockedQrCode = {
                xmlTemplater: this.xmlTemplater,
                imgName: imgName,
                data: oldFile.asBinary(),
                num: num
              };
              if (!/\.png$/.test(oldFile.name)) {
                return this.imageSetter(mockedQrCode)
              }
              return function(imgName) {
                var base64 = base64encode(oldFile.asBinary());
                var binaryData = new Buffer(base64, "base64");
                var png = new PNG(binaryData);
                var finished = function finished(a) {
                  png.decoded = a;
                  try {
                    _this.qr[imgNum] = new DocxQrCode(png, _this.xmlTemplater, imgName, num, _this.getDataFromString);
                    return _this.qr[imgNum].decode(_this.imageSetter)
                  } catch (e) {
                    return _this.imageSetter(mockedQrCode)
                  }
                };
                return png.decode(finished)
              }(imgName)
            }
          }]);
          return ImgReplacer
        }()
      }).call(this, require("buffer").Buffer)
    }, {
      "./base64": 37,
      "./docUtils": 38,
      "./docxQrCode": 39,
      buffer: 17,
      "png-js": 95
    }],
    42: [function(require, module, exports) {
      "use strict";

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          })
        } else {
          obj[key] = value
        }
        return obj
      }
      var Errors = require("./errors");
      var memoize = require("memoizejs");
      var DocUtils = {};

      function parser(tag) {
        return _defineProperty({}, "get", function get(scope) {
          if (tag === ".") {
            return scope
          }
          return scope[tag]
        })
      }
      DocUtils.defaults = {
        nullGetter: function nullGetter(tag, props) {
          if (props.tag === "simple") {
            return "undefined"
          }
          if (props.tag === "raw") {
            return ""
          }
          return ""
        },
        parser: memoize(parser),
        intelligentTagging: true,
        fileType: "docx",
        delimiters: {
          start: "{",
          end: "}"
        }
      };
      DocUtils.charMap = {
        "&": "&amp;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;"
      };
      DocUtils.escapeRegExp = function(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
      };
      DocUtils.charMapRegexes = Object.keys(DocUtils.charMap).map(function(endChar) {
        var startChar = DocUtils.charMap[endChar];
        return {
          rstart: new RegExp(DocUtils.escapeRegExp(startChar), "g"),
          rend: new RegExp(DocUtils.escapeRegExp(endChar), "g"),
          start: startChar,
          end: endChar
        }
      });
      DocUtils.wordToUtf8 = function(string) {
        if (typeof string !== "string") {
          string = string.toString()
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rstart, r.end)
        }
        return string
      };
      DocUtils.utf8ToWord = function(string) {
        if (typeof string !== "string") {
          string = string.toString()
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rend, r.start)
        }
        return string
      };
      DocUtils.cloneDeep = function(obj) {
        return JSON.parse(JSON.stringify(obj))
      };
      var spaceRegexp = new RegExp(String.fromCharCode(160), "g");
      DocUtils.convertSpaces = function(s) {
        return s.replace(spaceRegexp, " ")
      };
      DocUtils.pregMatchAll = function(regex, content) {
        var matchArray = [];

        function replacer() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          return matchArray.push(pn)
        }
        content.replace(regex, replacer);
        return matchArray
      };
      DocUtils.sizeOfObject = function(obj) {
        return Object.keys(obj).length
      };
      DocUtils.encode_utf8 = function(s) {
        return unescape(encodeURIComponent(s))
      };
      DocUtils.decode_utf8 = function(s) {
        try {
          if (s === undefined) {
            return undefined
          }
          return decodeURIComponent(escape(DocUtils.convert_spaces(s)))
        } catch (e) {
          var err = new Errors.XTError("Could not decode utf8");
          err.properties = {
            toDecode: s,
            baseErr: e
          };
          throw err
        }
      };
      DocUtils.base64encode = function(b) {
        return btoa(unescape(encodeURIComponent(b)))
      };
      DocUtils.tags = DocUtils.defaults.delimiters;
      DocUtils.defaultParser = DocUtils.defaults.parser;
      DocUtils.convert_spaces = DocUtils.convertSpaces;
      DocUtils.preg_match_all = DocUtils.pregMatchAll;
      module.exports = DocUtils
    }, {
      "./errors": 44,
      memoizejs: 94
    }],
    43: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var Docxtemplater = function() {
        function Docxtemplater(content, options) {
          _classCallCheck(this, Docxtemplater);
          this.moduleManager = new Docxtemplater.ModuleManager;
          this.moduleManager.setInstance("gen", this);
          this.setOptions({});
          if (content != null) {
            this.load(content, options)
          }
        }
        _createClass(Docxtemplater, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.moduleManager.attachModule(module);
            return this
          }
        }, {
          key: "setOptions",
          value: function setOptions(options) {
            var _this = this;
            this.options = options || {};
            Object.keys(DocUtils.defaults).forEach(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = _this.options[key] != null ? _this.options[key] : defaultValue
            });
            if (this.fileType === "docx" || this.fileType === "pptx") {
              this.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];
              if (this.zip != null) {
                this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip)
              }
            }
            return this
          }
        }, {
          key: "load",
          value: function load(content, options) {
            this.moduleManager.sendEvent("loading");
            if (content.file != null) {
              this.zip = content
            } else {
              this.zip = new Docxtemplater.JSZip(content, options)
            }
            this.moduleManager.sendEvent("loaded");
            this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
            return this
          }
        }, {
          key: "renderFile",
          value: function renderFile(fileName) {
            this.moduleManager.sendEvent("rendering-file", fileName);
            var currentFile = this.createTemplateClass(fileName);
            this.zip.file(fileName, currentFile.render().content);
            return this.moduleManager.sendEvent("rendered-file", fileName)
          }
        }, {
          key: "render",
          value: function render() {
            this.moduleManager.sendEvent("rendering");
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                this.renderFile(fileName)
              }
            }
            this.moduleManager.sendEvent("rendered");
            return this
          }
        }, {
          key: "getTags",
          value: function getTags() {
            var usedTags = [];
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                var currentFile = this.createTemplateClass(fileName);
                var usedTemplateV = currentFile.render().usedTags;
                if (DocUtils.sizeOfObject(usedTemplateV)) {
                  usedTags.push({
                    fileName: fileName,
                    vars: usedTemplateV
                  })
                }
              }
            }
            return usedTags
          }
        }, {
          key: "setData",
          value: function setData(tags) {
            this.tags = tags;
            return this
          }
        }, {
          key: "getZip",
          value: function getZip() {
            return this.zip
          }
        }, {
          key: "createTemplateClass",
          value: function createTemplateClass(path) {
            var usedData = this.zip.files[path].asText();
            return this.createTemplateClassFromContent(usedData)
          }
        }, {
          key: "createTemplateClassFromContent",
          value: function createTemplateClassFromContent(content) {
            var _this2 = this;
            var obj = {
              tags: this.tags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).forEach(function(key) {
              obj[key] = _this2[key]
            });
            obj.fileTypeConfig = this.fileTypeConfig;
            return new Docxtemplater.XmlTemplater(content, obj)
          }
        }, {
          key: "getFullText",
          value: function getFullText(path) {
            return this.createTemplateClass(path || this.fileTypeConfig.textPath).getFullText()
          }
        }]);
        return Docxtemplater
      }();
      Docxtemplater.DocUtils = require("./docUtils");
      Docxtemplater.JSZip = require("jszip");
      Docxtemplater.Errors = require("./errors");
      Docxtemplater.ModuleManager = require("./moduleManager");
      Docxtemplater.XmlTemplater = require("./xmlTemplater");
      Docxtemplater.FileTypeConfig = require("./fileTypeConfig");
      Docxtemplater.XmlMatcher = require("./xmlMatcher");
      Docxtemplater.XmlUtil = require("./xmlUtil");
      Docxtemplater.SubContent = require("./subContent");
      module.exports = Docxtemplater
    }, {
      "./docUtils": 42,
      "./errors": 44,
      "./fileTypeConfig": 45,
      "./moduleManager": 47,
      "./subContent": 49,
      "./xmlMatcher": 51,
      "./xmlTemplater": 52,
      "./xmlUtil": 53,
      jszip: 63
    }],
    44: [function(require, module, exports) {
      "use strict";

      function XTError(message) {
        this.name = "GenericError";
        this.message = message;
        this.stack = (new Error).stack
      }
      XTError.prototype = new Error;

      function XTTemplateError(message) {
        this.name = "TemplateError";
        this.message = message;
        this.stack = (new Error).stack
      }
      XTTemplateError.prototype = new XTError;

      function XTScopeParserError(message) {
        this.name = "ScopeParserError";
        this.message = message;
        this.stack = (new Error).stack
      }
      XTScopeParserError.prototype = new XTError;

      function XTInternalError(message) {
        this.name = "InternalError";
        this.properties = {
          explanation: "InternalError"
        };
        this.message = message;
        this.stack = (new Error).stack
      }
      XTInternalError.prototype = new XTError;
      module.exports = {
        XTError: XTError,
        XTTemplateError: XTTemplateError,
        XTInternalError: XTInternalError,
        XTScopeParserError: XTScopeParserError
      }
    }, {}],
    45: [function(require, module, exports) {
      "use strict";
      var xmlUtil = require("./xmlUtil");
      var SubContent = require("./subContent");
      var PptXFileTypeConfig = {
        textPath: "ppt/slides/slide1.xml",
        tagsXmlArray: ["a:t", "m:t"],
        tagRawXml: "p:sp",
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file) {
            return file.name
          });
          return slideTemplates.concat(["ppt/presentation.xml"])
        },
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<a:tc>") {
              return "a:tr"
            }
          }
          return false
        }
      };
      var DocXFileTypeConfig = {
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/word\/(header|footer)\d+\.xml/).map(function(file) {
            return file.name
          });
          return slideTemplates.concat(["word/document.xml"])
        },
        textPath: "word/document.xml",
        tagsXmlArray: ["w:t", "m:t"],
        tagRawXml: "w:p",
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<w:tc>") {
              return "w:tr"
            }
          }
          return false
        }
      };
      module.exports = {
        docx: DocXFileTypeConfig,
        pptx: PptXFileTypeConfig
      }
    }, {
      "./subContent": 49,
      "./xmlUtil": 53
    }],
    46: [function(require, module, exports) {
      "use strict";
      module.exports = require("./docxtemplater")
    }, {
      "./docxtemplater": 43
    }],
    47: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      module.exports = function() {
        function ModuleManager() {
          _classCallCheck(this, ModuleManager);
          var instances = {};
          this.getInstance = function(obj) {
            return instances[obj]
          };
          this.setInstance = function(key, value) {
            instances[key] = value
          };
          this.modules = []
        }
        _createClass(ModuleManager, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.modules.push(module);
            module.manager = this;
            return this
          }
        }, {
          key: "sendEvent",
          value: function sendEvent(eventName, data) {
            return this.modules.map(function(m) {
              return m.handleEvent(eventName, data)
            })
          }
        }, {
          key: "get",
          value: function get(value) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              var aux = m.get(value);
              result = aux != null ? aux : result
            }
            return result
          }
        }, {
          key: "handle",
          value: function handle(type, data) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              if (result != null) {
                return
              }
              var aux = m.handle(type, data);
              result = aux != null ? aux : result
            }
            return result
          }
        }]);
        return ModuleManager
      }()
    }, {}],
    48: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var Errors = require("./errors");
      var DocUtils = require("./docUtils");
      module.exports = function() {
        function ScopeManager(options) {
          _classCallCheck(this, ScopeManager);
          this.scopePath = options.scopePath;
          this.usedTags = options.usedTags;
          this.scopeList = options.scopeList;
          this.parser = options.parser;
          this.moduleManager = options.moduleManager;
          this.moduleManager.setInstance("scopeManager", this)
        }
        _createClass(ScopeManager, [{
          key: "loopOver",
          value: function loopOver(tag, callback, inverted) {
            inverted = inverted || false;
            var value = this.getValue(tag);
            return this.loopOverValue(value, callback, inverted)
          }
        }, {
          key: "functorIfInverted",
          value: function functorIfInverted(inverted, functor, value) {
            if (inverted) {
              functor(value)
            }
          }
        }, {
          key: "isValueFalsy",
          value: function isValueFalsy(value, type) {
            return value == null || !value || type === "[object Array]" && value.length === 0
          }
        }, {
          key: "loopOverValue",
          value: function loopOverValue(value, functor, inverted) {
            var type = Object.prototype.toString.call(value);
            var currentValue = this.scopeList[this.num];
            if (this.isValueFalsy(value, type)) {
              return this.functorIfInverted(inverted, functor, currentValue)
            }
            if (type === "[object Array]") {
              for (var i = 0, scope; i < value.length; i++) {
                scope = value[i];
                this.functorIfInverted(!inverted, functor, scope)
              }
              return
            }
            if (type === "[object Object]") {
              return this.functorIfInverted(!inverted, functor, value)
            }
            if (value === true) {
              return this.functorIfInverted(!inverted, functor, currentValue)
            }
          }
        }, {
          key: "getValue",
          value: function getValue(tag, num) {
            this.num = num == null ? this.scopeList.length - 1 : num;
            var err;
            var parser;
            var result;
            var scope = this.scopeList[this.num];
            try {
              parser = this.parser(tag)
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser compilation failed");
              err.properties = {
                id: "scopeparser_compilation_failed",
                tag: tag,
                explanation: "The scope parser for the tag " + tag + " failed to compile"
              };
              throw err
            }
            try {
              result = parser.get(scope)
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser execution failed");
              err.properties = {
                id: "scopeparser_execution_failed",
                explanation: "The scope parser for the tag " + tag + " failed to execute",
                scope: scope,
                tag: tag
              };
              throw err
            }
            if (result == null && this.num > 0) {
              return this.getValue(tag, this.num - 1)
            }
            return result
          }
        }, {
          key: "getValueFromScope",
          value: function getValueFromScope(tag) {
            var result = this.getValue(tag);
            var value;
            if (result != null) {
              if (typeof result === "string") {
                this.useTag(tag, true);
                value = result
              } else if (typeof result === "number") {
                value = String(result)
              } else {
                value = result
              }
            } else {
              this.useTag(tag, false);
              return null
            }
            return value
          }
        }, {
          key: "useTag",
          value: function useTag(tag, val) {
            var u;
            if (val) {
              u = this.usedTags.def
            } else {
              u = this.usedTags.undef
            }
            var iterable = this.scopePath;
            for (var i = 0, s; i < iterable.length; i++) {
              s = iterable[i];
              if (!(u[s] != null)) {
                u[s] = {}
              }
              u = u[s]
            }
            if (tag !== "") {
              u[tag] = true
            }
          }
        }, {
          key: "createSubScopeManager",
          value: function createSubScopeManager(scope, tag) {
            var options = DocUtils.cloneDeep({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList
            });
            options.parser = this.parser;
            options.moduleManager = this.moduleManager;
            if (tag != null) {
              options.scopeList = this.scopeList.concat(scope);
              options.scopePath = this.scopePath.concat(tag)
            } else {
              options.scopeList = [];
              options.scopePath = []
            }
            return new ScopeManager(options)
          }
        }]);
        return ScopeManager
      }()
    }, {
      "./docUtils": 42,
      "./errors": 44
    }],
    49: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var Errors = require("./errors");

      function substr(baseText, start, length) {
        var text = "";
        for (var i = start; i < start + length; i++) {
          text += baseText[i]
        }
        return text
      }
      module.exports = function() {
        function SubContent(fullText) {
          _classCallCheck(this, SubContent);
          this.fullText = fullText || "";
          this.text = "";
          this.start = 0;
          this.end = 0
        }
        _createClass(SubContent, [{
          key: "getInnerLoop",
          value: function getInnerLoop(templaterState) {
            this.start = templaterState.calcEndTag(templaterState.loopOpen);
            this.end = templaterState.calcStartTag(templaterState.loopClose);
            return this.refreshText()
          }
        }, {
          key: "getOuterLoop",
          value: function getOuterLoop(templaterState) {
            this.start = templaterState.calcStartTag(templaterState.loopOpen);
            this.end = templaterState.calcEndTag(templaterState.loopClose);
            return this.refreshText()
          }
        }, {
          key: "getInnerTag",
          value: function getInnerTag(templaterState) {
            this.start = templaterState.calcPosition(templaterState.tagStart);
            this.end = templaterState.calcPosition(templaterState.tagEnd) + 1;
            return this.refreshText()
          }
        }, {
          key: "refreshText",
          value: function refreshText() {
            this.text = substr(this.fullText, this.start, this.end - this.start);
            return this
          }
        }, {
          key: "getErrorProps",
          value: function getErrorProps(xmlTag) {
            return {
              xmlTag: xmlTag,
              text: this.fullText,
              start: this.start,
              previousEnd: this.end
            }
          }
        }, {
          key: "getOuterXml",
          value: function getOuterXml(xmlTag) {
            var endCandidate = this.fullText.indexOf("</" + xmlTag + ">", this.end);
            var err;
            var startCandiate = Math.max(this.fullText.lastIndexOf("<" + xmlTag + ">", this.start), this.fullText.lastIndexOf("<" + xmlTag + " ", this.start));
            if (endCandidate === -1) {
              err = new Errors.XTTemplateError("Can't find endTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err
            }
            if (startCandiate === -1) {
              err = new Errors.XTTemplateError("Can't find startTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err
            }
            this.end = endCandidate + ("</" + xmlTag + ">").length;
            this.start = startCandiate;
            return this.refreshText()
          }
        }, {
          key: "replace",
          value: function replace(newText) {
            this.fullText = this.fullText.substr(0, this.start) + newText + this.fullText.substr(this.end);
            this.end = this.start + newText.length;
            return this.refreshText()
          }
        }]);
        return SubContent
      }()
    }, {
      "./errors": 44
    }],
    50: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var Errors = require("./errors");
      var dashInnerRegex = /^-([^\s]+)\s(.+)$/;
      module.exports = function() {
        function TemplaterState(moduleManager, delimiters) {
          _classCallCheck(this, TemplaterState);
          this.moduleManager = moduleManager;
          this.moduleManager.setInstance("templaterState", this);
          this.delimiters = delimiters
        }
        _createClass(TemplaterState, [{
          key: "moveCharacters",
          value: function moveCharacters(numXmlTag, newTextLength, oldTextLength) {
            var end = this.matches.length;
            for (var k = numXmlTag; k < end; k++) {
              this.charactersAddedCumulative[k] += newTextLength - oldTextLength
            }
          }
        }, {
          key: "calcStartTag",
          value: function calcStartTag(tag) {
            return this.calcPosition(tag.start)
          }
        }, {
          key: "calcXmlTagPosition",
          value: function calcXmlTagPosition(xmlTagNumber) {
            return this.matches[xmlTagNumber].offset + this.charactersAddedCumulative[xmlTagNumber]
          }
        }, {
          key: "calcEndTag",
          value: function calcEndTag(tag) {
            return this.calcPosition(tag.end) + 1
          }
        }, {
          key: "calcPosition",
          value: function calcPosition(bracket) {
            return this.calcXmlTagPosition(bracket.numXmlTag) + this.matches[bracket.numXmlTag].array[1].length + bracket.numCharacter + this.charactersAdded[bracket.numXmlTag]
          }
        }, {
          key: "innerContent",
          value: function innerContent(type) {
            return this.matches[this[type].numXmlTag].array[2]
          }
        }, {
          key: "initialize",
          value: function initialize() {
            this.context = "";
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.inTag = false;
            this.inDashLoop = false;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.trail = "";
            this.trailSteps = [];
            this.offset = []
          }
        }, {
          key: "finalize",
          value: function finalize() {
            var err;
            var xtag;
            if (this.inForLoop === true || this.inDashLoop === true) {
              err = new Errors.XTTemplateError("Unclosed loop");
              xtag = this.loopOpen.raw;
              err.properties = {
                xtag: xtag,
                id: "unclosed_loop",
                context: this.context,
                explanation: "The loop beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
            if (this.inTag === true) {
              err = new Errors.XTTemplateError("Unclosed tag");
              xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
          }
        }, {
          key: "startTag",
          value: function startTag() {
            if (this.inTag === true) {
              var err = new Errors.XTTemplateError("Unclosed tag");
              var xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
            this.currentStep = this.trailSteps[0];
            this.inTag = true;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.tagStart = this.currentStep;
            this.trail = ""
          }
        }, {
          key: "loopType",
          value: function loopType() {
            if (this.inDashLoop) {
              return "dash"
            }
            if (this.inForLoop) {
              return "for"
            }
            if (this.rawXmlTag) {
              return "xml"
            }
            var getFromModule = this.moduleManager.get("loopType");
            if (getFromModule != null) {
              return getFromModule
            }
            return "simple"
          }
        }, {
          key: "isLoopClosingTag",
          value: function isLoopClosingTag() {
            return this.textInsideTag[0] === "/" && "/" + this.loopOpen.tag === this.textInsideTag || this.textInsideTag === "/"
          }
        }, {
          key: "finishLoop",
          value: function finishLoop() {
            this.context = "";
            this.rawXmlTag = false;
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.loopOpen = null;
            this.loopClose = null;
            this.inDashLoop = false;
            this.inTag = false;
            this.textInsideTag = ""
          }
        }, {
          key: "getLeftValue",
          value: function getLeftValue() {
            return this.innerContent("tagStart").substr(0, this.tagStart.numCharacter + this.offset[this.tagStart.numXmlTag])
          }
        }, {
          key: "getRightValue",
          value: function getRightValue() {
            return this.innerContent("tagEnd").substr(this.tagEnd.numCharacter + 1 + this.offset[this.tagEnd.numXmlTag])
          }
        }, {
          key: "getMatchLocation",
          value: function getMatchLocation(num) {
            var match = this.matches[num];
            if (match.first) {
              return "first"
            }
            if (match.last) {
              return "last"
            }
            return "normal"
          }
        }, {
          key: "handleSimpleEndTag",
          value: function handleSimpleEndTag() {
            var baseLoop = this.getCurrentLoop();
            if (this.textInsideTag[0] === "@") {
              this.rawXmlTag = true;
              this.tag = this.textInsideTag.substr(1);
              return
            }
            if (this.textInsideTag[0] === "#" || this.textInsideTag[0] === "^") {
              this.inForLoop = true;
              baseLoop.tag = this.textInsideTag.substr(1);
              this.loopOpen = baseLoop;
              this.loopIsInverted = this.textInsideTag[0] === "^";
              return
            }
            if (this.textInsideTag[0] === "-") {
              this.inDashLoop = true;
              baseLoop.tag = this.textInsideTag.replace(dashInnerRegex, "$2");
              baseLoop.element = this.textInsideTag.replace(dashInnerRegex, "$1");
              this.loopOpen = baseLoop;
              return
            }
          }
        }, {
          key: "getCurrentLoop",
          value: function getCurrentLoop() {
            return {
              start: this.tagStart,
              end: this.tagEnd,
              raw: this.textInsideTag
            }
          }
        }, {
          key: "endTag",
          value: function endTag() {
            if (this.inTag === false) {
              var err = new Errors.XTTemplateError("Unopened tag");
              err.properties = {
                id: "unopened_tag",
                explanation: "Unopened tag near : '" + this.context.substr(this.context.length - 10, 10) + "'",
                context: this.context
              };
              throw err
            }
            this.inTag = false;
            this.tagEnd = this.currentStep;
            this.textInsideTag = this.textInsideTag.substr(0, this.textInsideTag.length + 1 - this.delimiters.end.length);
            this.textInsideTag = DocUtils.wordToUtf8(this.textInsideTag);
            this.fullTextTag = this.delimiters.start + this.textInsideTag + this.delimiters.end;
            if (this.loopType() === "simple") {
              return this.handleSimpleEndTag()
            }
            if (this.textInsideTag[0] === "/") {
              this.loopClose = this.getCurrentLoop()
            }
          }
        }]);
        return TemplaterState
      }()
    }, {
      "./docUtils": 42,
      "./errors": 44
    }],
    51: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var memoize = require("memoizejs");

      function handleRecursiveCase(res) {
        function replacerUnshift() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.shift();
          var match = pn.array[0] + pn.array[1];
          pn.array.unshift(match);
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.first = true;
          res.matches.unshift(pn);
          res.charactersAdded.unshift(0);
          return res.charactersAddedCumulative.unshift(0)
        }
        if (res.content.indexOf("<") === -1 && res.content.indexOf(">") === -1) {
          res.content.replace(/^()([^<>]*)$/, replacerUnshift)
        }
        var r = new RegExp("^()([^<]+)</(?:" + res.tagsXmlArrayJoined + ")>");
        res.content.replace(r, replacerUnshift);

        function replacerPush() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.last = true;
          res.matches.push(pn);
          res.charactersAdded.push(0);
          return res.charactersAddedCumulative.push(0)
        }
        r = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^>]+)$");
        res.content.replace(r, replacerPush);
        return res
      }

      function xmlMatcher(content, tagsXmlArray) {
        var res = {};
        res.content = content;
        res.tagsXmlArray = tagsXmlArray;
        res.tagsXmlArrayJoined = res.tagsXmlArray.join("|");
        var regexp = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^<>]*)</(?:" + res.tagsXmlArrayJoined + ")>", "g");
        res.matches = DocUtils.pregMatchAll(regexp, res.content);
        res.charactersAddedCumulative = res.matches.map(function() {
          return 0
        });
        res.charactersAdded = res.matches.map(function() {
          return 0
        });
        return handleRecursiveCase(res)
      }
      var memoized = memoize(xmlMatcher);
      module.exports = function(content, tagsXmlArray) {
        return DocUtils.cloneDeep(memoized(content, tagsXmlArray))
      }
    }, {
      "./docUtils": 42,
      memoizejs: 94
    }],
    52: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var ScopeManager = require("./scopeManager");
      var SubContent = require("./subContent");
      var TemplaterState = require("./templaterState");
      var xmlMatcher = require("./xmlMatcher");
      var ModuleManager = require("./moduleManager");
      var Errors = require("./errors");

      function _getFullText(content, tagsXmlArray) {
        var matcher = xmlMatcher(content, tagsXmlArray);
        var output = matcher.matches.map(function(match) {
          return match.array[2]
        });
        return DocUtils.wordToUtf8(DocUtils.convertSpaces(output.join("")))
      }
      module.exports = function() {
        function XmlTemplater(content, options) {
          _classCallCheck(this, XmlTemplater);
          this.fromJson(options);
          this.templaterState = new TemplaterState(this.moduleManager, this.delimiters);
          this.load(content)
        }
        _createClass(XmlTemplater, [{
          key: "load",
          value: function load(content) {
            this.content = content;
            if (typeof this.content !== "string") {
              var err = new Errors.XTInternalError("Content must be a string");
              err.properties.id = "xmltemplater_content_must_be_string";
              throw err
            }
            var result = xmlMatcher(this.content, this.fileTypeConfig.tagsXmlArray);
            this.templaterState.matches = result.matches;
            this.templaterState.charactersAddedCumulative = result.charactersAddedCumulative;
            this.templaterState.charactersAdded = result.charactersAdded
          }
        }, {
          key: "fromJson",
          value: function fromJson(options) {
            var _this = this;
            this.tags = options.tags != null ? options.tags : {};
            this.fileTypeConfig = options.fileTypeConfig;
            this.scopePath = options.scopePath != null ? options.scopePath : [];
            this.scopeList = options.scopeList != null ? options.scopeList : [this.tags];
            this.usedTags = options.usedTags != null ? options.usedTags : {
              def: {},
              undef: {}
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = options[key] != null ? options[key] : defaultValue
            });
            this.moduleManager = options.moduleManager != null ? options.moduleManager : new ModuleManager;
            this.scopeManager = new ScopeManager({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList,
              parser: this.parser,
              moduleManager: this.moduleManager
            })
          }
        }, {
          key: "toJson",
          value: function toJson() {
            var _this2 = this;
            var obj = {
              fileTypeConfig: this.fileTypeConfig,
              usedTags: this.scopeManager.usedTags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              obj[key] = _this2[key]
            });
            return obj
          }
        }, {
          key: "getFullText",
          value: function getFullText() {
            return _getFullText(this.content, this.fileTypeConfig.tagsXmlArray)
          }
        }, {
          key: "updateModuleManager",
          value: function updateModuleManager() {
            this.moduleManager.setInstance("xmlTemplater", this);
            this.moduleManager.setInstance("templaterState", this.templaterState);
            this.moduleManager.setInstance("scopeManager", this.scopeManager)
          }
        }, {
          key: "handleModuleManager",
          value: function handleModuleManager(type, data) {
            this.updateModuleManager();
            return this.moduleManager.handle(type, data)
          }
        }, {
          key: "getTrail",
          value: function getTrail(character) {
            this.templaterState.trail += character;
            var length = !this.templaterState.inTag ? this.delimiters.start.length : this.delimiters.end.length;
            return this.templaterState.trail.substr(-length, length)
          }
        }, {
          key: "handleCharacter",
          value: function handleCharacter(character) {
            if (this.templaterState.trail === this.delimiters.start && (this.templaterState.inTag === false || this.sameTags === false)) {
              this.templaterState.startTag()
            } else if (this.templaterState.trail === this.delimiters.end && (this.templaterState.inTag === true || this.sameTags === false)) {
              this.updateModuleManager();
              this.templaterState.endTag();
              this.loopClose()
            } else if (this.templaterState.inTag === true) {
              this.templaterState.textInsideTag += character
            }
          }
        }, {
          key: "forEachCharacter",
          value: function forEachCharacter(functor) {
            var matches = this.templaterState.matches;
            for (var numXmlTag = 0, match; numXmlTag < matches.length; numXmlTag++) {
              match = matches[numXmlTag];
              var innerText = match.array[2];
              this.templaterState.offset[numXmlTag] = 0;
              if (this.templaterState.trail.length === 0 && !this.templaterState.inTag && innerText.indexOf(this.delimiters.start[0]) === -1 && innerText.indexOf(this.delimiters.end[0]) === -1) {
                continue
              }
              for (var numCharacter = 0, character; numCharacter < innerText.length; numCharacter++) {
                character = innerText[numCharacter];
                this.templaterState.trail = this.getTrail(character);
                this.templaterState.currentStep = {
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                };
                this.templaterState.trailSteps.push({
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                });
                this.templaterState.trailSteps = this.templaterState.trailSteps.splice(-this.delimiters.start.length, this.delimiters.start.length);
                this.templaterState.context += character;
                functor(character, numXmlTag, numCharacter)
              }
            }
          }
        }, {
          key: "render",
          value: function render() {
            this.sameTags = this.delimiters.start === this.delimiters.end;
            this.templaterState.initialize();
            this.handleModuleManager("xmlRendering");
            this.forEachCharacter(this.handleCharacter.bind(this));
            this.handleModuleManager("xmlRendered");
            this.templaterState.finalize();
            return this
          }
        }, {
          key: "loopClose",
          value: function loopClose() {
            var loopType = this.templaterState.loopType();
            if (loopType === "simple") {
              this.replaceSimpleTag()
            }
            if (loopType === "xml") {
              this.replaceSimpleTagRawXml()
            }
            if (["dash", "for"].indexOf(loopType) !== -1 && this.templaterState.isLoopClosingTag()) {
              this.replaceLoopTag();
              this.templaterState.finishLoop()
            }
            if (["simple", "dash", "for", "xml"].indexOf(loopType) === -1) {
              this.handleModuleManager("replaceTag", loopType)
            }
          }
        }, {
          key: "replaceSimpleTag",
          value: function replaceSimpleTag() {
            var newValue = this.scopeManager.getValueFromScope(this.templaterState.textInsideTag);
            if (newValue == null) {
              newValue = this.nullGetter(this.templaterState.textInsideTag, {
                tag: "simple"
              })
            }
            this.content = this.replaceTagByValue(DocUtils.utf8ToWord(newValue), this.content)
          }
        }, {
          key: "replaceSimpleTagRawXml",
          value: function replaceSimpleTagRawXml() {
            var outerXml;
            var newText = this.scopeManager.getValueFromScope(this.templaterState.tag);
            if (newText == null) {
              newText = this.nullGetter(this.templaterState.tag, {
                tag: "raw"
              })
            }
            var subContent = new SubContent(this.content);
            subContent.getInnerTag(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(this.fileTypeConfig.tagRawXml)
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "raw_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The raw tag " + error.properties.xtag + " is not valid in this context."
              }
              throw error
            }
            var fullText = _getFullText(outerXml.text, this.fileTypeConfig.tagsXmlArray);
            if (this.templaterState.fullTextTag !== fullText) {
              var err = new Errors.XTTemplateError("Raw xml tag should be the only text in paragraph");
              err.properties = {
                id: "raw_xml_tag_should_be_only_text_in_paragraph",
                paragraphContent: fullText,
                fullTag: this.templaterState.fullTextTag,
                xtag: this.templaterState.textInsideTag,
                explanation: "The tag : '" + this.templaterState.fullTextTag + "' should be the the only text in the paragraph (it contains '" + fullText + "')"
              };
              throw err
            }
            return this.replaceXml(outerXml, newText)
          }
        }, {
          key: "replaceXml",
          value: function replaceXml(subContent, newText) {
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, newText.length, subContent.text.length);
            this.content = subContent.replace(newText).fullText;
            return this.content
          }
        }, {
          key: "deleteTag",
          value: function deleteTag(xml, tag) {
            this.templaterState.tagStart = tag.start;
            this.templaterState.tagEnd = tag.end;
            this.templaterState.textInsideTag = tag.raw;
            return this.replaceTagByValue("", xml)
          }
        }, {
          key: "deleteOuterTags",
          value: function deleteOuterTags(outerXmlText) {
            return this.deleteTag(this.deleteTag(outerXmlText, this.templaterState.loopOpen), this.templaterState.loopClose)
          }
        }, {
          key: "dashLoop",
          value: function dashLoop(elementDashLoop, sharp) {
            sharp = sharp || false;
            var outerXml;
            var subContent = new SubContent(this.content);
            subContent.getInnerLoop(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(elementDashLoop)
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "dashloop_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The dashLoop tag " + error.properties.xtag + " is not valid in this context."
              }
              throw error
            }
            this.templaterState.moveCharacters(0, 0, outerXml.start);
            var outerXmlText = outerXml.text;
            var innerXmlText = this.deleteOuterTags(outerXmlText, sharp);
            this.templaterState.moveCharacters(0, outerXml.start, 0);
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, outerXmlText.length, innerXmlText.length);
            return this.forLoop(outerXml, innerXmlText)
          }
        }, {
          key: "xmlToBeReplaced",
          value: function xmlToBeReplaced(options) {
            var before = "";
            var after = "";
            if (options.noStartTag) {
              return [options.insideValue]
            }
            if (options.spacePreserve && options.tag === "w:t") {
              before = "<" + options.fullTag + ' xml:space="preserve">'
            } else {
              before = this.templaterState.matches[options.xmlTagNumber].array[1]
            }
            if (!options.noEndTag) {
              after = "</" + options.tag + ">"
            }
            return [before, options.insideValue, after]
          }
        }, {
          key: "replaceFirstFrom",
          value: function replaceFirstFrom(string, search, replace, from) {
            var rightPart = string.substr(from + search.length);
            var leftPart = string.substr(0, from);
            var middlePart = string.substr(from, search.length);
            if (middlePart !== search) {
              var err = new Errors.XTInternalError("Match not found in content");
              err.properties.id = "xmltemplater_match_not_found_in_content";
              err.properties.search = search;
              err.properties.middlePart = middlePart;
              err.properties.content = string;
              throw err
            }
            return leftPart + replace + rightPart
          }
        }, {
          key: "replaceXmlTag",
          value: function replaceXmlTag(content, options) {
            this.templaterState.offset[options.xmlTagNumber] += options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            options.fullTag = this.templaterState.matches[options.xmlTagNumber].array[1].replace(/^<([^>]+)>$/, "$1");
            options.tag = options.fullTag.replace(/([^ ]*).*/, "$1");
            options.spacePreserve = options.spacePreserve != null ? options.spacePreserve : true;
            options.spacePreserve = options.spacePreserve && this.templaterState.matches[options.xmlTagNumber].array[1].indexOf('xml:space="preserve"') === -1;
            options.noStartTag = options.noStartTag != null ? options.noStartTag : false;
            options.noEndTag = options.noEndTag != null ? options.noEndTag : false;
            var replacer = this.xmlToBeReplaced(options);
            if (replacer.length > 1) {
              this.templaterState.matches[options.xmlTagNumber].array[1] = replacer[0]
            }
            this.templaterState.charactersAdded[options.xmlTagNumber] = options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            this.templaterState.matches[options.xmlTagNumber].array[2] = options.insideValue;
            replacer = replacer.join("");
            var startTag = this.templaterState.calcXmlTagPosition(options.xmlTagNumber);
            this.templaterState.moveCharacters(options.xmlTagNumber + 1, replacer.length, this.templaterState.matches[options.xmlTagNumber].array[0].length);
            content = this.replaceFirstFrom(content, this.templaterState.matches[options.xmlTagNumber].array[0], replacer, startTag);
            this.templaterState.matches[options.xmlTagNumber].array[0] = replacer;
            return content
          }
        }, {
          key: "replaceTagByValue",
          value: function replaceTagByValue(newValue, content) {
            var location = this.templaterState.getMatchLocation(this.templaterState.tagStart.numXmlTag);
            var options = {
              xmlTagNumber: this.templaterState.tagStart.numXmlTag,
              noStartTag: location === "first",
              noEndTag: location === "last"
            };
            if (this.templaterState.tagEnd.numXmlTag === this.templaterState.tagStart.numXmlTag) {
              options.insideValue = this.templaterState.getLeftValue() + newValue + this.templaterState.getRightValue();
              return this.replaceXmlTag(content, options)
            } else if (this.templaterState.tagEnd.numXmlTag > this.templaterState.tagStart.numXmlTag) {
              if (location === "normal") {
                options.insideValue = this.templaterState.getLeftValue() + newValue
              } else {
                options.insideValue = newValue
              }
              content = this.replaceXmlTag(content, options);
              options = {
                insideValue: "",
                spacePreserve: false
              };
              var start = this.templaterState.tagStart.numXmlTag + 1;
              var end = this.templaterState.tagEnd.numXmlTag;
              for (var k = start; k < end; k++) {
                options.xmlTagNumber = k;
                content = this.replaceXmlTag(content, options)
              }
              options = {
                insideValue: this.templaterState.getRightValue(),
                spacePreserve: true,
                xmlTagNumber: this.templaterState.tagEnd.numXmlTag,
                noEndTag: this.templaterState.getMatchLocation(this.templaterState.tagEnd.numXmlTag) === "last"
              };
              return this.replaceXmlTag(content, options)
            }
          }
        }, {
          key: "replaceLoopTag",
          value: function replaceLoopTag() {
            if (this.templaterState.loopType() === "dash") {
              return this.dashLoop(this.templaterState.loopOpen.element)
            }
            if (this.intelligentTagging === true) {
              var dashElement = this.fileTypeConfig.calcIntellegentlyDashElement(this.content, this.templaterState);
              if (dashElement !== false) {
                return this.dashLoop(dashElement, true)
              }
            }
            var outerLoop = new SubContent(this.content).getOuterLoop(this.templaterState);
            var innerTemplate = new SubContent(this.content).getInnerLoop(this.templaterState).text;
            return this.forLoop(outerLoop, innerTemplate)
          }
        }, {
          key: "calcSubXmlTemplater",
          value: function calcSubXmlTemplater(innerTagsContent, argOptions) {
            var options = this.toJson();
            options.tags = argOptions.tags;
            options.scopeList = this.scopeList.concat(argOptions.tags);
            options.scopePath = this.scopePath.concat(this.templaterState.loopOpen.tag);
            var subXml = new XmlTemplater(innerTagsContent, options);
            return subXml
          }
        }, {
          key: "forLoop",
          value: function forLoop(outerTags, subTemplate) {
            var _this3 = this;
            var tag = this.templaterState.loopOpen.tag;
            var newContent = "";
            var loopFn = function loopFn(subTags) {
              newContent += _this3.calcSubXmlTemplater(subTemplate, {
                tags: subTags
              }).render().content;
              return newContent
            };
            this.scopeManager.loopOver(tag, loopFn, this.templaterState.loopIsInverted);
            this.calcSubXmlTemplater(subTemplate, {
              tags: {}
            }).render();
            return this.replaceXml(outerTags, newContent)
          }
        }]);
        return XmlTemplater
      }()
    }, {
      "./docUtils": 42,
      "./errors": 44,
      "./moduleManager": 47,
      "./scopeManager": 48,
      "./subContent": 49,
      "./templaterState": 50,
      "./xmlMatcher": 51
    }],
    53: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var XmlUtil = {};

      function addTag(array, tag) {
        return array.concat([{
          tag: "<" + tag.array[1] + ">",
          offset: tag.offset
        }])
      }

      function lastTagIsOpenTag(array, tag) {
        if (array.length === 0) {
          return false
        }
        var lastTag = array[array.length - 1];
        var innerLastTag = lastTag.tag.substr(1, lastTag.tag.length - 2);
        var innerCurrentTag = tag.array[1].substr(1);
        return innerLastTag === innerCurrentTag
      }
      XmlUtil.getListXmlElements = function(text) {
        var tags = DocUtils.pregMatchAll(/<(\/?[^\/> ]+)([^>]*)>/g, text);
        var result = [];
        for (var i = 0, tag; i < tags.length; i++) {
          tag = tags[i];
          if (tag.array[1][0] === "/") {
            var justOpened = lastTagIsOpenTag(result, tag);
            if (justOpened) {
              result.pop()
            } else {
              result = addTag(result, tag)
            }
          } else if (tag.array[2][tag.array[2].length - 1] !== "/") {
            result = addTag(result, tag)
          }
        }
        return result
      };
      module.exports = XmlUtil
    }, {
      "./docUtils": 42
    }],
    54: [function(require, module, exports) {
      "use strict";
      var DataReader = require("./dataReader");

      function ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0;
          for (var i = 0; i < this.data.length; i++) {
            data[i] = data[i] & 255
          }
        }
      }
      ArrayReader.prototype = new DataReader;
      ArrayReader.prototype.byteAt = function(i) {
        return this.data[this.zero + i]
      };
      ArrayReader.prototype.lastIndexOfSignature = function(sig) {
        var sig0 = sig.charCodeAt(0),
          sig1 = sig.charCodeAt(1),
          sig2 = sig.charCodeAt(2),
          sig3 = sig.charCodeAt(3);
        for (var i = this.length - 4; i >= 0; --i) {
          if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero
          }
        }
        return -1
      };
      ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return []
        }
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = ArrayReader
    }, {
      "./dataReader": 59
    }],
    55: [function(require, module, exports) {
      "use strict";
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      exports.encode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64
          } else if (isNaN(chr3)) {
            enc4 = 64
          }
          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)
        }
        return output
      };
      exports.decode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2)
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3)
          }
        }
        return output
      }
    }, {}],
    56: [function(require, module, exports) {
      "use strict";

      function CompressedObject() {
        this.compressedSize = 0;
        this.uncompressedSize = 0;
        this.crc32 = 0;
        this.compressionMethod = null;
        this.compressedContent = null
      }
      CompressedObject.prototype = {
        getContent: function() {
          return null
        },
        getCompressedContent: function() {
          return null
        }
      };
      module.exports = CompressedObject
    }, {}],
    57: [function(require, module, exports) {
      "use strict";
      exports.STORE = {
        magic: "\x00\x00",
        compress: function(content, compressionOptions) {
          return content
        },
        uncompress: function(content) {
          return content
        },
        compressInputType: null,
        uncompressInputType: null
      };
      exports.DEFLATE = require("./flate")
    }, {
      "./flate": 62
    }],
    58: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
      module.exports = function crc32(input, crc) {
        if (typeof input === "undefined" || !input.length) {
          return 0
        }
        var isArray = utils.getTypeOf(input) !== "string";
        if (typeof crc == "undefined") {
          crc = 0
        }
        var x = 0;
        var y = 0;
        var b = 0;
        crc = crc ^ -1;
        for (var i = 0, iTop = input.length; i < iTop; i++) {
          b = isArray ? input[i] : input.charCodeAt(i);
          y = (crc ^ b) & 255;
          x = table[y];
          crc = crc >>> 8 ^ x
        }
        return crc ^ -1
      }
    }, {
      "./utils": 75
    }],
    59: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");

      function DataReader(data) {
        this.data = null;
        this.length = 0;
        this.index = 0;
        this.zero = 0
      }
      DataReader.prototype = {
        checkOffset: function(offset) {
          this.checkIndex(this.index + offset)
        },
        checkIndex: function(newIndex) {
          if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?")
          }
        },
        setIndex: function(newIndex) {
          this.checkIndex(newIndex);
          this.index = newIndex
        },
        skip: function(n) {
          this.setIndex(this.index + n)
        },
        byteAt: function(i) {},
        readInt: function(size) {
          var result = 0,
            i;
          this.checkOffset(size);
          for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i)
          }
          this.index += size;
          return result
        },
        readString: function(size) {
          return utils.transformTo("string", this.readData(size))
        },
        readData: function(size) {},
        lastIndexOfSignature: function(sig) {},
        readDate: function() {
          var dostime = this.readInt(4);
          return new Date((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1)
        }
      };
      module.exports = DataReader
    }, {
      "./utils": 75
    }],
    60: [function(require, module, exports) {
      "use strict";
      exports.base64 = false;
      exports.binary = false;
      exports.dir = false;
      exports.createFolders = false;
      exports.date = null;
      exports.compression = null;
      exports.compressionOptions = null;
      exports.comment = null;
      exports.unixPermissions = null;
      exports.dosPermissions = null
    }, {}],
    61: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      exports.string2binary = function(str) {
        return utils.string2binary(str)
      };
      exports.string2Uint8Array = function(str) {
        return utils.transformTo("uint8array", str)
      };
      exports.uint8Array2String = function(array) {
        return utils.transformTo("string", array)
      };
      exports.string2Blob = function(str) {
        var buffer = utils.transformTo("arraybuffer", str);
        return utils.arrayBuffer2Blob(buffer)
      };
      exports.arrayBuffer2Blob = function(buffer) {
        return utils.arrayBuffer2Blob(buffer)
      };
      exports.transformTo = function(outputType, input) {
        return utils.transformTo(outputType, input)
      };
      exports.getTypeOf = function(input) {
        return utils.getTypeOf(input)
      };
      exports.checkSupport = function(type) {
        return utils.checkSupport(type)
      };
      exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
      exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
      exports.pretty = function(str) {
        return utils.pretty(str)
      };
      exports.findCompression = function(compressionMethod) {
        return utils.findCompression(compressionMethod)
      };
      exports.isRegExp = function(object) {
        return utils.isRegExp(object)
      }
    }, {
      "./utils": 75
    }],
    62: [function(require, module, exports) {
      "use strict";
      var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
      var pako = require("pako");
      exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.magic = "\b\x00";
      exports.compress = function(input, compressionOptions) {
        return pako.deflateRaw(input, {
          level: compressionOptions.level || -1
        })
      };
      exports.uncompress = function(input) {
        return pako.inflateRaw(input)
      }
    }, {
      pako: 78
    }],
    63: [function(require, module, exports) {
      "use strict";
      var base64 = require("./base64");

      function JSZip(data, options) {
        if (!(this instanceof JSZip)) return new JSZip(data, options);
        this.files = {};
        this.comment = null;
        this.root = "";
        if (data) {
          this.load(data, options)
        }
        this.clone = function() {
          var newObj = new JSZip;
          for (var i in this) {
            if (typeof this[i] !== "function") {
              newObj[i] = this[i]
            }
          }
          return newObj
        }
      }
      JSZip.prototype = require("./object");
      JSZip.prototype.load = require("./load");
      JSZip.support = require("./support");
      JSZip.defaults = require("./defaults");
      JSZip.utils = require("./deprecatedPublicUtils");
      JSZip.base64 = {
        encode: function(input) {
          return base64.encode(input)
        },
        decode: function(input) {
          return base64.decode(input)
        }
      };
      JSZip.compressions = require("./compressions");
      module.exports = JSZip
    }, {
      "./base64": 55,
      "./compressions": 57,
      "./defaults": 60,
      "./deprecatedPublicUtils": 61,
      "./load": 64,
      "./object": 67,
      "./support": 71
    }],
    64: [function(require, module, exports) {
      "use strict";
      var base64 = require("./base64");
      var utf8 = require("./utf8");
      var utils = require("./utils");
      var ZipEntries = require("./zipEntries");
      module.exports = function(data, options) {
        var files, zipEntries, i, input;
        options = utils.extend(options || {}, {
          base64: false,
          checkCRC32: false,
          optimizedBinaryString: false,
          createFolders: false,
          decodeFileName: utf8.utf8decode
        });
        if (options.base64) {
          data = base64.decode(data)
        }
        zipEntries = new ZipEntries(data, options);
        files = zipEntries.files;
        for (i = 0; i < files.length; i++) {
          input = files[i];
          this.file(input.fileNameStr, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          })
        }
        if (zipEntries.zipComment.length) {
          this.comment = zipEntries.zipComment
        }
        return this
      }
    }, {
      "./base64": 55,
      "./utf8": 74,
      "./utils": 75,
      "./zipEntries": 76
    }],
    65: [function(require, module, exports) {
      (function(Buffer) {
        "use strict";
        module.exports = function(data, encoding) {
          return new Buffer(data, encoding)
        };
        module.exports.test = function(b) {
          return Buffer.isBuffer(b)
        }
      }).call(this, require("buffer").Buffer)
    }, {
      buffer: 17
    }],
    66: [function(require, module, exports) {
      "use strict";
      var Uint8ArrayReader = require("./uint8ArrayReader");

      function NodeBufferReader(data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0
      }
      NodeBufferReader.prototype = new Uint8ArrayReader;
      NodeBufferReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = NodeBufferReader
    }, {
      "./uint8ArrayReader": 72
    }],
    67: [function(require, module, exports) {
      "use strict";
      var support = require("./support");
      var utils = require("./utils");
      var crc32 = require("./crc32");
      var signature = require("./signature");
      var defaults = require("./defaults");
      var base64 = require("./base64");
      var compressions = require("./compressions");
      var CompressedObject = require("./compressedObject");
      var nodeBuffer = require("./nodeBuffer");
      var utf8 = require("./utf8");
      var StringWriter = require("./stringWriter");
      var Uint8ArrayWriter = require("./uint8ArrayWriter");
      var getRawData = function(file) {
        if (file._data instanceof CompressedObject) {
          file._data = file._data.getContent();
          file.options.binary = true;
          file.options.base64 = false;
          if (utils.getTypeOf(file._data) === "uint8array") {
            var copy = file._data;
            file._data = new Uint8Array(copy.length);
            if (copy.length !== 0) {
              file._data.set(copy, 0)
            }
          }
        }
        return file._data
      };
      var getBinaryData = function(file) {
        var result = getRawData(file),
          type = utils.getTypeOf(result);
        if (type === "string") {
          if (!file.options.binary) {
            if (support.nodebuffer) {
              return nodeBuffer(result, "utf-8")
            }
          }
          return file.asBinary()
        }
        return result
      };
      var dataToString = function(asUTF8) {
        var result = getRawData(this);
        if (result === null || typeof result === "undefined") {
          return ""
        }
        if (this.options.base64) {
          result = base64.decode(result)
        }
        if (asUTF8 && this.options.binary) {
          result = out.utf8decode(result)
        } else {
          result = utils.transformTo("string", result)
        }
        if (!asUTF8 && !this.options.binary) {
          result = utils.transformTo("string", out.utf8encode(result))
        }
        return result
      };
      var ZipObject = function(name, data, options) {
        this.name = name;
        this.dir = options.dir;
        this.date = options.date;
        this.comment = options.comment;
        this.unixPermissions = options.unixPermissions;
        this.dosPermissions = options.dosPermissions;
        this._data = data;
        this.options = options;
        this._initialMetadata = {
          dir: options.dir,
          date: options.date
        }
      };
      ZipObject.prototype = {
        asText: function() {
          return dataToString.call(this, true)
        },
        asBinary: function() {
          return dataToString.call(this, false)
        },
        asNodeBuffer: function() {
          var result = getBinaryData(this);
          return utils.transformTo("nodebuffer", result)
        },
        asUint8Array: function() {
          var result = getBinaryData(this);
          return utils.transformTo("uint8array", result)
        },
        asArrayBuffer: function() {
          return this.asUint8Array().buffer
        }
      };
      var decToHex = function(dec, bytes) {
        var hex = "",
          i;
        for (i = 0; i < bytes; i++) {
          hex += String.fromCharCode(dec & 255);
          dec = dec >>> 8
        }
        return hex
      };
      var prepareFileAttrs = function(o) {
        o = o || {};
        if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
          o.binary = true
        }
        o = utils.extend(o, defaults);
        o.date = o.date || new Date;
        if (o.compression !== null) o.compression = o.compression.toUpperCase();
        return o
      };
      var fileAdd = function(name, data, o) {
        var dataType = utils.getTypeOf(data),
          parent;
        o = prepareFileAttrs(o);
        if (typeof o.unixPermissions === "string") {
          o.unixPermissions = parseInt(o.unixPermissions, 8)
        }
        if (o.unixPermissions && o.unixPermissions & 16384) {
          o.dir = true
        }
        if (o.dosPermissions && o.dosPermissions & 16) {
          o.dir = true
        }
        if (o.dir) {
          name = forceTrailingSlash(name)
        }
        if (o.createFolders && (parent = parentFolder(name))) {
          folderAdd.call(this, parent, true)
        }
        if (o.dir || data === null || typeof data === "undefined") {
          o.base64 = false;
          o.binary = false;
          data = null;
          dataType = null
        } else if (dataType === "string") {
          if (o.binary && !o.base64) {
            if (o.optimizedBinaryString !== true) {
              data = utils.string2binary(data)
            }
          }
        } else {
          o.base64 = false;
          o.binary = true;
          if (!dataType && !(data instanceof CompressedObject)) {
            throw new Error("The data of '" + name + "' is in an unsupported format !")
          }
          if (dataType === "arraybuffer") {
            data = utils.transformTo("uint8array", data)
          }
        }
        var object = new ZipObject(name, data, o);
        this.files[name] = object;
        return object
      };
      var parentFolder = function(path) {
        if (path.slice(-1) == "/") {
          path = path.substring(0, path.length - 1)
        }
        var lastSlash = path.lastIndexOf("/");
        return lastSlash > 0 ? path.substring(0, lastSlash) : ""
      };
      var forceTrailingSlash = function(path) {
        if (path.slice(-1) != "/") {
          path += "/"
        }
        return path
      };
      var folderAdd = function(name, createFolders) {
        createFolders = typeof createFolders !== "undefined" ? createFolders : false;
        name = forceTrailingSlash(name);
        if (!this.files[name]) {
          fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
          })
        }
        return this.files[name]
      };
      var generateCompressedObjectFrom = function(file, compression, compressionOptions) {
        var result = new CompressedObject,
          content;
        if (file._data instanceof CompressedObject) {
          result.uncompressedSize = file._data.uncompressedSize;
          result.crc32 = file._data.crc32;
          if (result.uncompressedSize === 0 || file.dir) {
            compression = compressions["STORE"];
            result.compressedContent = "";
            result.crc32 = 0
          } else if (file._data.compressionMethod === compression.magic) {
            result.compressedContent = file._data.getCompressedContent()
          } else {
            content = file._data.getContent();
            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions)
          }
        } else {
          content = getBinaryData(file);
          if (!content || content.length === 0 || file.dir) {
            compression = compressions["STORE"];
            content = ""
          }
          result.uncompressedSize = content.length;
          result.crc32 = crc32(content);
          result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions)
        }
        result.compressedSize = result.compressedContent.length;
        result.compressionMethod = compression.magic;
        return result
      };
      var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
        var result = unixPermissions;
        if (!unixPermissions) {
          result = isDir ? 16893 : 33204
        }
        return (result & 65535) << 16
      };
      var generateDosExternalFileAttr = function(dosPermissions, isDir) {
        return (dosPermissions || 0) & 63
      };
      var generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {
        var data = compressedObject.compressedContent,
          useCustomEncoding = encodeFileName !== utf8.utf8encode,
          encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
          utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
          comment = file.comment || "",
          encodedComment = utils.transformTo("string", encodeFileName(comment)),
          utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
          useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
          useUTF8ForComment = utfEncodedComment.length !== comment.length,
          o = file.options,
          dosTime, dosDate, extraFields = "",
          unicodePathExtraField = "",
          unicodeCommentExtraField = "",
          dir, date;
        if (file._initialMetadata.dir !== file.dir) {
          dir = file.dir
        } else {
          dir = o.dir
        }
        if (file._initialMetadata.date !== file.date) {
          date = file.date
        } else {
          date = o.date
        }
        var extFileAttr = 0;
        var versionMadeBy = 0;
        if (dir) {
          extFileAttr |= 16
        }
        if (platform === "UNIX") {
          versionMadeBy = 798;
          extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir)
        } else {
          versionMadeBy = 20;
          extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir)
        }
        dosTime = date.getHours();
        dosTime = dosTime << 6;
        dosTime = dosTime | date.getMinutes();
        dosTime = dosTime << 5;
        dosTime = dosTime | date.getSeconds() / 2;
        dosDate = date.getFullYear() - 1980;
        dosDate = dosDate << 4;
        dosDate = dosDate | date.getMonth() + 1;
        dosDate = dosDate << 5;
        dosDate = dosDate | date.getDate();
        if (useUTF8ForFileName) {
          unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
          extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField
        }
        if (useUTF8ForComment) {
          unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(encodedComment), 4) + utfEncodedComment;
          extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField
        }
        var header = "";
        header += "\n\x00";
        header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\x00\b" : "\x00\x00";
        header += compressedObject.compressionMethod;
        header += decToHex(dosTime, 2);
        header += decToHex(dosDate, 2);
        header += decToHex(compressedObject.crc32, 4);
        header += decToHex(compressedObject.compressedSize, 4);
        header += decToHex(compressedObject.uncompressedSize, 4);
        header += decToHex(encodedFileName.length, 2);
        header += decToHex(extraFields.length, 2);
        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
        var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
        return {
          fileRecord: fileRecord,
          dirRecord: dirRecord,
          compressedObject: compressedObject
        }
      };
      var out = {
        load: function(stream, options) {
          throw new Error("Load method is not defined. Is the file jszip-load.js included ?")
        },
        filter: function(search) {
          var result = [],
            filename, relativePath, file, fileClone;
          for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
              continue
            }
            file = this.files[filename];
            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));
            relativePath = filename.slice(this.root.length, filename.length);
            if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone)) {
              result.push(fileClone)
            }
          }
          return result
        },
        file: function(name, data, o) {
          if (arguments.length === 1) {
            if (utils.isRegExp(name)) {
              var regexp = name;
              return this.filter(function(relativePath, file) {
                return !file.dir && regexp.test(relativePath)
              })
            } else {
              return this.filter(function(relativePath, file) {
                return !file.dir && relativePath === name
              })[0] || null
            }
          } else {
            name = this.root + name;
            fileAdd.call(this, name, data, o)
          }
          return this
        },
        folder: function(arg) {
          if (!arg) {
            return this
          }
          if (utils.isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
              return file.dir && arg.test(relativePath)
            })
          }
          var name = this.root + arg;
          var newFolder = folderAdd.call(this, name);
          var ret = this.clone();
          ret.root = newFolder.name;
          return ret
        },
        remove: function(name) {
          name = this.root + name;
          var file = this.files[name];
          if (!file) {
            if (name.slice(-1) != "/") {
              name += "/"
            }
            file = this.files[name]
          }
          if (file && !file.dir) {
            delete this.files[name]
          } else {
            var kids = this.filter(function(relativePath, file) {
              return file.name.slice(0, name.length) === name
            });
            for (var i = 0; i < kids.length; i++) {
              delete this.files[kids[i].name]
            }
          }
          return this
        },
        generate: function(options) {
          options = utils.extend(options || {}, {
            base64: true,
            compression: "STORE",
            compressionOptions: null,
            type: "base64",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          utils.checkSupport(options.type);
          if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
            options.platform = "UNIX"
          }
          if (options.platform === "win32") {
            options.platform = "DOS"
          }
          var zipData = [],
            localDirLength = 0,
            centralDirLength = 0,
            writer, i, encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
          for (var name in this.files) {
            if (!this.files.hasOwnProperty(name)) {
              continue
            }
            var file = this.files[name];
            var compressionName = file.options.compression || options.compression.toUpperCase();
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !")
            }
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
            centralDirLength += zipPart.dirRecord.length;
            zipData.push(zipPart)
          }
          var dirEnd = "";
          dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
          var typeName = options.type.toLowerCase();
          if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length)
          } else {
            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length)
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].fileRecord);
            writer.append(zipData[i].compressedObject.compressedContent)
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].dirRecord)
          }
          writer.append(dirEnd);
          var zip = writer.finalize();
          switch (options.type.toLowerCase()) {
            case "uint8array":
            case "arraybuffer":
            case "nodebuffer":
              return utils.transformTo(options.type.toLowerCase(), zip);
            case "blob":
              return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
            case "base64":
              return options.base64 ? base64.encode(zip) : zip;
            default:
              return zip
          }
        },
        crc32: function(input, crc) {
          return crc32(input, crc)
        },
        utf8encode: function(string) {
          return utils.transformTo("string", utf8.utf8encode(string))
        },
        utf8decode: function(input) {
          return utf8.utf8decode(input)
        }
      };
      module.exports = out
    }, {
      "./base64": 55,
      "./compressedObject": 56,
      "./compressions": 57,
      "./crc32": 58,
      "./defaults": 60,
      "./nodeBuffer": 65,
      "./signature": 68,
      "./stringWriter": 70,
      "./support": 71,
      "./uint8ArrayWriter": 73,
      "./utf8": 74,
      "./utils": 75
    }],
    68: [function(require, module, exports) {
      "use strict";
      exports.LOCAL_FILE_HEADER = "PK";
      exports.CENTRAL_FILE_HEADER = "PK";
      exports.CENTRAL_DIRECTORY_END = "PK";
      exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK";
      exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
      exports.DATA_DESCRIPTOR = "PK\b"
    }, {}],
    69: [function(require, module, exports) {
      "use strict";
      var DataReader = require("./dataReader");
      var utils = require("./utils");

      function StringReader(data, optimizedBinaryString) {
        this.data = data;
        if (!optimizedBinaryString) {
          this.data = utils.string2binary(this.data)
        }
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0
      }
      StringReader.prototype = new DataReader;
      StringReader.prototype.byteAt = function(i) {
        return this.data.charCodeAt(this.zero + i)
      };
      StringReader.prototype.lastIndexOfSignature = function(sig) {
        return this.data.lastIndexOf(sig) - this.zero
      };
      StringReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = StringReader
    }, {
      "./dataReader": 59,
      "./utils": 75
    }],
    70: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var StringWriter = function() {
        this.data = []
      };
      StringWriter.prototype = {
        append: function(input) {
          input = utils.transformTo("string", input);
          this.data.push(input)
        },
        finalize: function() {
          return this.data.join("")
        }
      };
      module.exports = StringWriter
    }, {
      "./utils": 75
    }],
    71: [function(require, module, exports) {
      (function(Buffer) {
        "use strict";
        exports.base64 = true;
        exports.array = true;
        exports.string = true;
        exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
        exports.nodebuffer = typeof Buffer !== "undefined";
        exports.uint8array = typeof Uint8Array !== "undefined";
        if (typeof ArrayBuffer === "undefined") {
          exports.blob = false
        } else {
          var buffer = new ArrayBuffer(0);
          try {
            exports.blob = new Blob([buffer], {
              type: "application/zip"
            }).size === 0
          } catch (e) {
            try {
              var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              var builder = new Builder;
              builder.append(buffer);
              exports.blob = builder.getBlob("application/zip").size === 0
            } catch (e) {
              exports.blob = false
            }
          }
        }
      }).call(this, require("buffer").Buffer)
    }, {
      buffer: 17
    }],
    72: [function(require, module, exports) {
      "use strict";
      var ArrayReader = require("./arrayReader");

      function Uint8ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0
        }
      }
      Uint8ArrayReader.prototype = new ArrayReader;
      Uint8ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return new Uint8Array(0)
        }
        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = Uint8ArrayReader
    }, {
      "./arrayReader": 54
    }],
    73: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var Uint8ArrayWriter = function(length) {
        this.data = new Uint8Array(length);
        this.index = 0
      };
      Uint8ArrayWriter.prototype = {
        append: function(input) {
          if (input.length !== 0) {
            input = utils.transformTo("uint8array", input);
            this.data.set(input, this.index);
            this.index += input.length
          }
        },
        finalize: function() {
          return this.data
        }
      };
      module.exports = Uint8ArrayWriter
    }, {
      "./utils": 75
    }],
    74: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var support = require("./support");
      var nodeBuffer = require("./nodeBuffer");
      var _utf8len = new Array(256);
      for (var i = 0; i < 256; i++) {
        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1
      }
      _utf8len[254] = _utf8len[254] = 1;
      var string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
        }
        if (support.uint8array) {
          buf = new Uint8Array(buf_len)
        } else {
          buf = new Array(buf_len)
        }
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          if (c < 128) {
            buf[i++] = c
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          }
        }
        return buf
      };
      var utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--
        }
        if (pos < 0) {
          return max
        }
        if (pos === 0) {
          return max
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max
      };
      var buf2string = function(buf) {
        var str, i, out, c, c_len;
        var len = buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue
          }
          if (c < 65536) {
            utf16buf[out++] = c
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023
          }
        }
        if (utf16buf.length !== out) {
          if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out)
          } else {
            utf16buf.length = out
          }
        }
        return utils.applyFromCharCode(utf16buf)
      };
      exports.utf8encode = function utf8encode(str) {
        if (support.nodebuffer) {
          return nodeBuffer(str, "utf-8")
        }
        return string2buf(str)
      };
      exports.utf8decode = function utf8decode(buf) {
        if (support.nodebuffer) {
          return utils.transformTo("nodebuffer", buf).toString("utf-8")
        }
        buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
        var result = [],
          k = 0,
          len = buf.length,
          chunk = 65536;
        while (k < len) {
          var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
          if (support.uint8array) {
            result.push(buf2string(buf.subarray(k, nextBoundary)))
          } else {
            result.push(buf2string(buf.slice(k, nextBoundary)))
          }
          k = nextBoundary
        }
        return result.join("")
      }
    }, {
      "./nodeBuffer": 65,
      "./support": 71,
      "./utils": 75
    }],
    75: [function(require, module, exports) {
      "use strict";
      var support = require("./support");
      var compressions = require("./compressions");
      var nodeBuffer = require("./nodeBuffer");
      exports.string2binary = function(str) {
        var result = "";
        for (var i = 0; i < str.length; i++) {
          result += String.fromCharCode(str.charCodeAt(i) & 255)
        }
        return result
      };
      exports.arrayBuffer2Blob = function(buffer, mimeType) {
        exports.checkSupport("blob");
        mimeType = mimeType || "application/zip";
        try {
          return new Blob([buffer], {
            type: mimeType
          })
        } catch (e) {
          try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder;
            builder.append(buffer);
            return builder.getBlob(mimeType)
          } catch (e) {
            throw new Error("Bug : can't construct the Blob.")
          }
        }
      };

      function identity(input) {
        return input
      }

      function stringToArrayLike(str, array) {
        for (var i = 0; i < str.length; ++i) {
          array[i] = str.charCodeAt(i) & 255
        }
        return array
      }

      function arrayLikeToString(array) {
        var chunk = 65536;
        var result = [],
          len = array.length,
          type = exports.getTypeOf(array),
          k = 0,
          canUseApply = true;
        try {
          switch (type) {
            case "uint8array":
              String.fromCharCode.apply(null, new Uint8Array(0));
              break;
            case "nodebuffer":
              String.fromCharCode.apply(null, nodeBuffer(0));
              break
          }
        } catch (e) {
          canUseApply = false
        }
        if (!canUseApply) {
          var resultStr = "";
          for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i])
          }
          return resultStr
        }
        while (k < len && chunk > 1) {
          try {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))))
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))))
            }
            k += chunk
          } catch (e) {
            chunk = Math.floor(chunk / 2)
          }
        }
        return result.join("")
      }
      exports.applyFromCharCode = arrayLikeToString;

      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i = 0; i < arrayFrom.length; i++) {
          arrayTo[i] = arrayFrom[i]
        }
        return arrayTo
      }
      var transform = {};
      transform["string"] = {
        string: identity,
        array: function(input) {
          return stringToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return transform["string"]["uint8array"](input).buffer
        },
        uint8array: function(input) {
          return stringToArrayLike(input, new Uint8Array(input.length))
        },
        nodebuffer: function(input) {
          return stringToArrayLike(input, nodeBuffer(input.length))
        }
      };
      transform["array"] = {
        string: arrayLikeToString,
        array: identity,
        arraybuffer: function(input) {
          return new Uint8Array(input).buffer
        },
        uint8array: function(input) {
          return new Uint8Array(input)
        },
        nodebuffer: function(input) {
          return nodeBuffer(input)
        }
      };
      transform["arraybuffer"] = {
        string: function(input) {
          return arrayLikeToString(new Uint8Array(input))
        },
        array: function(input) {
          return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
        },
        arraybuffer: identity,
        uint8array: function(input) {
          return new Uint8Array(input)
        },
        nodebuffer: function(input) {
          return nodeBuffer(new Uint8Array(input))
        }
      };
      transform["uint8array"] = {
        string: arrayLikeToString,
        array: function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return input.buffer
        },
        uint8array: identity,
        nodebuffer: function(input) {
          return nodeBuffer(input)
        }
      };
      transform["nodebuffer"] = {
        string: arrayLikeToString,
        array: function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return transform["nodebuffer"]["uint8array"](input).buffer
        },
        uint8array: function(input) {
          return arrayLikeToArrayLike(input, new Uint8Array(input.length))
        },
        nodebuffer: identity
      };
      exports.transformTo = function(outputType, input) {
        if (!input) {
          input = ""
        }
        if (!outputType) {
          return input
        }
        exports.checkSupport(outputType);
        var inputType = exports.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result
      };
      exports.getTypeOf = function(input) {
        if (typeof input === "string") {
          return "string"
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array"
        }
        if (support.nodebuffer && nodeBuffer.test(input)) {
          return "nodebuffer"
        }
        if (support.uint8array && input instanceof Uint8Array) {
          return "uint8array"
        }
        if (support.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer"
        }
      };
      exports.checkSupport = function(type) {
        var supported = support[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this browser")
        }
      };
      exports.MAX_VALUE_16BITS = 65535;
      exports.MAX_VALUE_32BITS = -1;
      exports.pretty = function(str) {
        var res = "",
          code, i;
        for (i = 0; i < (str || "").length; i++) {
          code = str.charCodeAt(i);
          res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase()
        }
        return res
      };
      exports.findCompression = function(compressionMethod) {
        for (var method in compressions) {
          if (!compressions.hasOwnProperty(method)) {
            continue
          }
          if (compressions[method].magic === compressionMethod) {
            return compressions[method]
          }
        }
        return null
      };
      exports.isRegExp = function(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]"
      };
      exports.extend = function() {
        var result = {},
          i, attr;
        for (i = 0; i < arguments.length; i++) {
          for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i][attr]
            }
          }
        }
        return result
      }
    }, {
      "./compressions": 57,
      "./nodeBuffer": 65,
      "./support": 71
    }],
    76: [function(require, module, exports) {
      "use strict";
      var StringReader = require("./stringReader");
      var NodeBufferReader = require("./nodeBufferReader");
      var Uint8ArrayReader = require("./uint8ArrayReader");
      var ArrayReader = require("./arrayReader");
      var utils = require("./utils");
      var sig = require("./signature");
      var ZipEntry = require("./zipEntry");
      var support = require("./support");
      var jszipProto = require("./object");

      function ZipEntries(data, loadOptions) {
        this.files = [];
        this.loadOptions = loadOptions;
        if (data) {
          this.load(data)
        }
      }
      ZipEntries.prototype = {
        checkSignature: function(expectedSignature) {
          var signature = this.reader.readString(4);
          if (signature !== expectedSignature) {
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")")
          }
        },
        isSignature: function(askedIndex, expectedSignature) {
          var currentIndex = this.reader.index;
          this.reader.setIndex(askedIndex);
          var signature = this.reader.readString(4);
          var result = signature === expectedSignature;
          this.reader.setIndex(currentIndex);
          return result
        },
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2);
          this.diskWithCentralDirStart = this.reader.readInt(2);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
          this.centralDirRecords = this.reader.readInt(2);
          this.centralDirSize = this.reader.readInt(4);
          this.centralDirOffset = this.reader.readInt(4);
          this.zipCommentLength = this.reader.readInt(2);
          var zipComment = this.reader.readData(this.zipCommentLength);
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          var decodeContent = utils.transformTo(decodeParamType, zipComment);
          this.zipComment = this.loadOptions.decodeFileName(decodeContent)
        },
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8);
          this.versionMadeBy = this.reader.readString(2);
          this.versionNeeded = this.reader.readInt(2);
          this.diskNumber = this.reader.readInt(4);
          this.diskWithCentralDirStart = this.reader.readInt(4);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
          this.centralDirRecords = this.reader.readInt(8);
          this.centralDirSize = this.reader.readInt(8);
          this.centralDirOffset = this.reader.readInt(8);
          this.zip64ExtensibleData = {};
          var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId, extraFieldLength, extraFieldValue;
          while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readString(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            }
          }
        },
        readBlockZip64EndOfCentralLocator: function() {
          this.diskWithZip64CentralDirStart = this.reader.readInt(4);
          this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
          this.disksCount = this.reader.readInt(4);
          if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported")
          }
        },
        readLocalFiles: function() {
          var i, file;
          for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes()
          }
        },
        readCentralDir: function() {
          var file;
          this.reader.setIndex(this.centralDirOffset);
          while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
            file = new ZipEntry({
              zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file)
          }
          if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
            } else {}
          }
        },
        readEndOfCentral: function() {
          var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
          if (offset < 0) {
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
            if (isGarbage) {
              throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html")
            } else {
              throw new Error("Corrupted zip : can't find end of central directory")
            }
          }
          this.reader.setIndex(offset);
          var endOfCentralDirOffset = offset;
          this.checkSignature(sig.CENTRAL_DIRECTORY_END);
          this.readBlockEndOfCentral();
          if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
              this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory")
              }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral()
          }
          var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
          if (this.zip64) {
            expectedEndOfCentralDirOffset += 20;
            expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize
          }
          var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
          if (extraBytes > 0) {
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
              this.reader.zero = extraBytes
            }
          } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.")
          }
        },
        prepareReader: function(data) {
          var type = utils.getTypeOf(data);
          utils.checkSupport(type);
          if (type === "string" && !support.uint8array) {
            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString)
          } else if (type === "nodebuffer") {
            this.reader = new NodeBufferReader(data)
          } else if (support.uint8array) {
            this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data))
          } else if (support.array) {
            this.reader = new ArrayReader(utils.transformTo("array", data))
          } else {
            throw new Error("Unexpected error: unsupported type '" + type + "'")
          }
        },
        load: function(data) {
          this.prepareReader(data);
          this.readEndOfCentral();
          this.readCentralDir();
          this.readLocalFiles()
        }
      };
      module.exports = ZipEntries
    }, {
      "./arrayReader": 54,
      "./nodeBufferReader": 66,
      "./object": 67,
      "./signature": 68,
      "./stringReader": 69,
      "./support": 71,
      "./uint8ArrayReader": 72,
      "./utils": 75,
      "./zipEntry": 77
    }],
    77: [function(require, module, exports) {
      "use strict";
      var StringReader = require("./stringReader");
      var utils = require("./utils");
      var CompressedObject = require("./compressedObject");
      var jszipProto = require("./object");
      var support = require("./support");
      var MADE_BY_DOS = 0;
      var MADE_BY_UNIX = 3;

      function ZipEntry(options, loadOptions) {
        this.options = options;
        this.loadOptions = loadOptions
      }
      ZipEntry.prototype = {
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1
        },
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048
        },
        prepareCompressedContent: function(reader, from, length) {
          return function() {
            var previousIndex = reader.index;
            reader.setIndex(from);
            var compressedFileData = reader.readData(length);
            reader.setIndex(previousIndex);
            return compressedFileData
          }
        },
        prepareContent: function(reader, from, length, compression, uncompressedSize) {
          return function() {
            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
            var uncompressedFileData = compression.uncompress(compressedFileData);
            if (uncompressedFileData.length !== uncompressedSize) {
              throw new Error("Bug : uncompressed data size mismatch")
            }
            return uncompressedFileData
          }
        },
        readLocalPart: function(reader) {
          var compression, localExtraFieldsLength;
          reader.skip(22);
          this.fileNameLength = reader.readInt(2);
          localExtraFieldsLength = reader.readInt(2);
          this.fileName = reader.readData(this.fileNameLength);
          reader.skip(localExtraFieldsLength);
          if (this.compressedSize == -1 || this.uncompressedSize == -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)")
          }
          compression = utils.findCompression(this.compressionMethod);
          if (compression === null) {
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")")
          }
          this.decompressed = new CompressedObject;
          this.decompressed.compressedSize = this.compressedSize;
          this.decompressed.uncompressedSize = this.uncompressedSize;
          this.decompressed.crc32 = this.crc32;
          this.decompressed.compressionMethod = this.compressionMethod;
          this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
          this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
          if (this.loadOptions.checkCRC32) {
            this.decompressed = utils.transformTo("string", this.decompressed.getContent());
            if (jszipProto.crc32(this.decompressed) !== this.crc32) {
              throw new Error("Corrupted zip : CRC32 mismatch")
            }
          }
        },
        readCentralPart: function(reader) {
          this.versionMadeBy = reader.readInt(2);
          this.versionNeeded = reader.readInt(2);
          this.bitFlag = reader.readInt(2);
          this.compressionMethod = reader.readString(2);
          this.date = reader.readDate();
          this.crc32 = reader.readInt(4);
          this.compressedSize = reader.readInt(4);
          this.uncompressedSize = reader.readInt(4);
          this.fileNameLength = reader.readInt(2);
          this.extraFieldsLength = reader.readInt(2);
          this.fileCommentLength = reader.readInt(2);
          this.diskNumberStart = reader.readInt(2);
          this.internalFileAttributes = reader.readInt(2);
          this.externalFileAttributes = reader.readInt(4);
          this.localHeaderOffset = reader.readInt(4);
          if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported")
          }
          this.fileName = reader.readData(this.fileNameLength);
          this.readExtraFields(reader);
          this.parseZIP64ExtraField(reader);
          this.fileComment = reader.readData(this.fileCommentLength)
        },
        processAttributes: function() {
          this.unixPermissions = null;
          this.dosPermissions = null;
          var madeBy = this.versionMadeBy >> 8;
          this.dir = this.externalFileAttributes & 16 ? true : false;
          if (madeBy === MADE_BY_DOS) {
            this.dosPermissions = this.externalFileAttributes & 63
          }
          if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 65535
          }
          if (!this.dir && this.fileNameStr.slice(-1) === "/") {
            this.dir = true
          }
        },
        parseZIP64ExtraField: function(reader) {
          if (!this.extraFields[1]) {
            return
          }
          var extraReader = new StringReader(this.extraFields[1].value);
          if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8)
          }
          if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8)
          }
          if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8)
          }
          if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4)
          }
        },
        readExtraFields: function(reader) {
          var start = reader.index,
            extraFieldId, extraFieldLength, extraFieldValue;
          this.extraFields = this.extraFields || {};
          while (reader.index < start + this.extraFieldsLength) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readString(extraFieldLength);
            this.extraFields[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            }
          }
        },
        handleUTF8: function() {
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) {
            this.fileNameStr = jszipProto.utf8decode(this.fileName);
            this.fileCommentStr = jszipProto.utf8decode(this.fileComment)
          } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
              this.fileNameStr = upath
            } else {
              var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray)
            }
            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
              this.fileCommentStr = ucomment
            } else {
              var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray)
            }
          }
        },
        findExtraFieldUnicodePath: function() {
          var upathField = this.extraFields[28789];
          if (upathField) {
            var extraReader = new StringReader(upathField.value);
            if (extraReader.readInt(1) !== 1) {
              return null
            }
            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
              return null
            }
            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))
          }
          return null
        },
        findExtraFieldUnicodeComment: function() {
          var ucommentField = this.extraFields[25461];
          if (ucommentField) {
            var extraReader = new StringReader(ucommentField.value);
            if (extraReader.readInt(1) !== 1) {
              return null
            }
            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
              return null
            }
            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))
          }
          return null
        }
      };
      module.exports = ZipEntry
    }, {
      "./compressedObject": 56,
      "./object": 67,
      "./stringReader": 69,
      "./support": 71,
      "./utils": 75
    }],
    78: [function(require, module, exports) {
      "use strict";
      var assign = require("./lib/utils/common").assign;
      var deflate = require("./lib/deflate");
      var inflate = require("./lib/inflate");
      var constants = require("./lib/zlib/constants");
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module.exports = pako
    }, {
      "./lib/deflate": 79,
      "./lib/inflate": 80,
      "./lib/utils/common": 81,
      "./lib/zlib/constants": 84
    }],
    79: [function(require, module, exports) {
      "use strict";
      var zlib_deflate = require("./zlib/deflate");
      var utils = require("./utils/common");
      var strings = require("./utils/strings");
      var msg = require("./zlib/messages");
      var ZStream = require("./zlib/zstream");
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;

      function Deflate(options) {
        if (!(this instanceof Deflate)) return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream;
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status])
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header)
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary)
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary)
          } else {
            dict = opt.dictionary
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status])
          }
          this._dict_set = true
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data)
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data)
        } else {
          strm.input = data
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)))
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out))
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true
        }
        return true
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk)
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("")
          } else {
            this.result = utils.flattenChunks(this.chunks)
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg
      };

      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg
        }
        return deflator.result
      }

      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options)
      }

      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options)
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip
    }, {
      "./utils/common": 81,
      "./utils/strings": 82,
      "./zlib/deflate": 86,
      "./zlib/messages": 91,
      "./zlib/zstream": 93
    }],
    80: [function(require, module, exports) {
      "use strict";
      var zlib_inflate = require("./zlib/inflate");
      var utils = require("./utils/common");
      var strings = require("./utils/strings");
      var c = require("./zlib/constants");
      var msg = require("./zlib/messages");
      var ZStream = require("./zlib/zstream");
      var GZheader = require("./zlib/gzheader");
      var toString = Object.prototype.toString;

      function Inflate(options) {
        if (!(this instanceof Inflate)) return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream;
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== c.Z_OK) {
          throw new Error(msg[status])
        }
        this.header = new GZheader;
        zlib_inflate.inflateGetHeader(this.strm, this.header)
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var dict;
        var allowBufError = false;
        if (this.ended) {
          return false
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data)
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data)
        } else {
          strm.input = data
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            if (typeof dictionary === "string") {
              dict = strings.string2buf(dictionary)
            } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(dictionary)
            } else {
              dict = dictionary
            }
            status = zlib_inflate.inflateSetDictionary(this.strm, dict)
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0)
                }
                this.onData(utf8str)
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out))
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true
        }
        return true
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk)
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("")
          } else {
            this.result = utils.flattenChunks(this.chunks)
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg
      };

      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg
        }
        return inflator.result
      }

      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options)
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate
    }, {
      "./utils/common": 81,
      "./utils/strings": 82,
      "./zlib/constants": 84,
      "./zlib/gzheader": 87,
      "./zlib/inflate": 89,
      "./zlib/messages": 91,
      "./zlib/zstream": 93
    }],
    81: [function(require, module, exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object")
          }
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p]
            }
          }
        }
        return obj
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf
        }
        if (buf.subarray) {
          return buf.subarray(0, size)
        }
        buf.length = size;
        return buf
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length
          }
          return result
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks)
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped)
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped)
        }
      };
      exports.setTyped(TYPED_OK)
    }, {}],
    82: [function(require, module, exports) {
      "use strict";
      var utils = require("./common");
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0])
      } catch (__) {
        STR_APPLY_OK = false
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1))
      } catch (__) {
        STR_APPLY_UIA_OK = false
      }
      var _utf8len = new utils.Buf8(256);
      for (var q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1
      }
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          if (c < 128) {
            buf[i++] = c
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          }
        }
        return buf
      };

      function buf2binstring(buf, len) {
        if (len < 65537) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len))
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i])
        }
        return result
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length)
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i)
        }
        return buf
      };
      exports.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue
          }
          if (c < 65536) {
            utf16buf[out++] = c
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023
          }
        }
        return buf2binstring(utf16buf, out)
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--
        }
        if (pos < 0) {
          return max
        }
        if (pos === 0) {
          return max
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max
      }
    }, {
      "./common": 81
    }],
    83: [function(require, module, exports) {
      arguments[4][5][0].apply(exports, arguments)
    }, {
      dup: 5
    }],
    84: [function(require, module, exports) {
      "use strict";
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      }
    }, {}],
    85: [function(require, module, exports) {
      "use strict";

      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1
          }
          table[n] = c
        }
        return table
      }
      var crcTable = makeTable();

      function crc32(crc, buf, len, pos) {
        var t = crcTable,
          end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255]
        }
        return crc ^ -1
      }
      module.exports = crc32
    }, {}],
    86: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var trees = require("./trees");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var msg = require("./messages");
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode
      }

      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0)
      }

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }

      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out
        }
        if (len === 0) {
          return
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0
        }
      }

      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm)
      }

      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b
      }

      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255
      }

      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size
        }
        if (len === 0) {
          return 0
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start)
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start)
        }
        strm.next_in += len;
        strm.total_in += len;
        return len
      }

      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue
          }
          scan += 2;
          match++;
          do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len]
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len
        }
        return s.lookahead
      }

      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            more += _w_size
          }
          if (s.strm.avail_in === 0) {
            break
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
      }

      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5
        }
        for (;;) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_NEED_MORE
      }

      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head)
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              } while (--s.match_length !== 0);
              s.strstart++
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false)
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (;;) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_huff(s, flush) {
        var bflush;
        for (;;) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE
              }
              break
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func
      }
      var configuration_table;
      configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];

      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0
      }

      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0
      }

      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK
      }

      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state)
        }
        return ret
      }

      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR
        }
        strm.state.gzhead = head;
        return Z_OK
      }

      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR)
        }
        if (windowBits === 8) {
          windowBits = 9
        }
        var s = new DeflateState;
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm)
      }

      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
      }

      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255)
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0
            } else if (s.level < 6) {
              level_flags = 1
            } else if (s.level === 6) {
              level_flags = 2
            } else {
              level_flags = 3
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535)
            }
            strm.adler = 1
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE
            }
          } else {
            s.status = NAME_STATE
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE
            }
          } else {
            s.status = COMMENT_STATE
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.status = HCRC_STATE
            }
          } else {
            s.status = HCRC_STATE
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm)
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE
            }
          } else {
            s.status = BUSY_STATE
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR)
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR)
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1
            }
            return Z_OK
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s)
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255)
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535)
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END
      }

      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
      }

      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0)
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s)
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)"
    }, {
      "../utils/common": 81,
      "./adler32": 83,
      "./crc32": 85,
      "./messages": 91,
      "./trees": 92
    }],
    87: [function(require, module, exports) {
      "use strict";

      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false
      }
      module.exports = GZheader
    }, {}],
    88: [function(require, module, exports) {
      arguments[4][9][0].apply(exports, arguments)
    }, {
      dup: 9
    }],
    89: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var inflate_fast = require("./inffast");
      var inflate_table = require("./inftrees");
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;

      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
      }

      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0
      }

      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK
      }

      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm)
      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm)
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR
        }
        state = new InflateState;
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null
        }
        return ret
      }

      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS)
      }
      var virgin = true;
      var lenfix, distfix;

      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8
          }
          while (sym < 256) {
            state.lens[sym++] = 9
          }
          while (sym < 280) {
            state.lens[sym++] = 7
          }
          while (sym < 288) {
            state.lens[sym++] = 8
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });
          virgin = false
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5
      }

      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize)
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0
            }
            if (state.whave < state.wsize) {
              state.whave += dist
            }
          }
        }
        return 0
      }

      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave: for (;;) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.time = hold
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0)
                }
                hold = 0;
                bits = 0
              } else if (state.head) {
                state.head.extra = null
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len)
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len)
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next)
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy
                }
                if (state.length) {
                  break inf_leave
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.name = null
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.comment = null
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have
                }
                if (copy > left) {
                  copy = left
                }
                if (copy === 0) {
                  break inf_leave
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;;) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break
                  }
                  while (copy--) {
                    state.lens[state.have++] = len
                  }
                }
              }
              if (state.mode === BAD) {
                break
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break
              }
              state.lenbits = 9;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1
                }
                break
              }
              state.back = 0;
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (;;) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy
                } else {
                  from = state.wnext - copy
                }
                if (copy > state.length) {
                  copy = state.length
                }
                from_source = state.window
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length
              }
              if (copy > left) {
                copy = left
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++]
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR
          }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR
        }
        return ret
      }

      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        var state = strm.state;
        if (state.window) {
          state.window = null
        }
        strm.state = null;
        return Z_OK
      }

      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR
        }
        state.head = head;
        head.done = false;
        return Z_OK
      }

      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR
        }
        state.havedict = 1;
        return Z_OK
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)"
    }, {
      "../utils/common": 81,
      "./adler32": 83,
      "./crc32": 85,
      "./inffast": 88,
      "./inftrees": 90
    }],
    90: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
      var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
      var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
      var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0,
          max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break
          }
        }
        if (root > max) {
          root = max
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break
          }
        }
        if (root < min) {
          root = min
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len]
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256
        } else {
          base = dbase;
          extra = dext;
          end = -1
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1
        }
        var i = 0;
        for (;;) {
          i++;
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym]
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]]
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr
          } else {
            huff = 0
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break
            }
            len = lens[lens_index + work[sym]]
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break
              }
              curr++;
              left <<= 1
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0
        }
        opts.bits = root;
        return 0
      }
    }, {
      "../utils/common": 81
    }],
    91: [function(require, module, exports) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      }
    }, {}],
    92: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);

      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;

      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc
      }

      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
      }

      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255
      }

      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length
        }
      }

      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2], tree[c * 2 + 1])
      }

      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1
        } while (--len > 0);
        return res >>> 1
      }

      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8
        }
      }

      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base]
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits)
          }
        }
        if (overflow === 0) {
          return
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits
            }
            n--
          }
        }
      }

      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len)
        }
      }

      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5)
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
      }

      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0
      }

      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf)
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf
        }
        s.bi_buf = 0;
        s.bi_valid = 0
      }

      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len)
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len
      }

      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
      }

      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1
        }
        s.heap[k] = v
      }

      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree)
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra)
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra)
              }
            }
          } while (lx < s.last_lit)
        }
        send_code(s, END_BLOCK, ltree)
      }

      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0
          } else {
            tree[n * 2 + 1] = 0
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1]
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n)
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1)
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count)
      }

      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++
            }
            s.bl_tree[REP_3_6 * 2]++
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++
          } else {
            s.bl_tree[REPZ_11_138 * 2]++
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree)
            } while (--count !== 0)
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2)
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3)
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7)
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex
      }

      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3)
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1)
      }

      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT
          }
        }
        return Z_BINARY
      }
      var static_init_done = false;

      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s)
      }

      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true)
      }

      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s)
      }

      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s)
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last)
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree)
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree)
        }
        init_block(s);
        if (last) {
          bi_windup(s)
        }
      }

      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++
        }
        return s.last_lit === s.lit_bufsize - 1
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align
    }, {
      "../utils/common": 81
    }],
    93: [function(require, module, exports) {
      arguments[4][14][0].apply(exports, arguments)
    }, {
      dup: 14
    }],
    94: [function(require, module, exports) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory)
        } else if (typeof exports === "object") {
          module.exports = factory()
        } else {
          root.memoize = factory()
        }
      })(this, function() {
        "use strict";
        var memoize = function(func) {
          var stringifyJson = JSON.stringify,
            cache = {};
          var cachedfun = function() {
            var hash = stringifyJson(arguments);
            return hash in cache ? cache[hash] : cache[hash] = func.apply(this, arguments)
          };
          cachedfun.__cache = function() {
            cache.remove || (cache.remove = function() {
              var hash = stringifyJson(arguments);
              return delete cache[hash]
            });
            return cache
          }.call(this);
          return cachedfun
        };
        return memoize
      })
    }, {}],
    95: [function(require, module, exports) {
      (function(Buffer) {
        (function() {
          var PNG, fs, zlib;
          fs = require("fs");
          zlib = require("zlib");
          module.exports = PNG = function() {
            PNG.decode = function(path, fn) {
              return fs.readFile(path, function(err, file) {
                var png;
                png = new PNG(file);
                return png.decode(function(pixels) {
                  return fn(pixels)
                })
              })
            };
            PNG.load = function(path) {
              var file;
              file = fs.readFileSync(path);
              return new PNG(file)
            };

            function PNG(data) {
              var chunkSize, colors, i, index, key, section, short, text, _i, _j, _ref;
              this.data = data;
              this.pos = 8;
              this.palette = [];
              this.imgData = [];
              this.transparency = {};
              this.text = {};
              while (true) {
                chunkSize = this.readUInt32();
                section = function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 4; i = ++_i) {
                    _results.push(String.fromCharCode(this.data[this.pos++]))
                  }
                  return _results
                }.call(this).join("");
                switch (section) {
                  case "IHDR":
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod = this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;
                  case "PLTE":
                    this.palette = this.read(chunkSize);
                    break;
                  case "IDAT":
                    for (i = _i = 0; _i < chunkSize; i = _i += 1) {
                      this.imgData.push(this.data[this.pos++])
                    }
                    break;
                  case "tRNS":
                    this.transparency = {};
                    switch (this.colorType) {
                      case 3:
                        this.transparency.indexed = this.read(chunkSize);
                        short = 255 - this.transparency.indexed.length;
                        if (short > 0) {
                          for (i = _j = 0; 0 <= short ? _j < short : _j > short; i = 0 <= short ? ++_j : --_j) {
                            this.transparency.indexed.push(255)
                          }
                        }
                        break;
                      case 0:
                        this.transparency.grayscale = this.read(chunkSize)[0];
                        break;
                      case 2:
                        this.transparency.rgb = this.read(chunkSize)
                    }
                    break;
                  case "tEXt":
                    text = this.read(chunkSize);
                    index = text.indexOf(0);
                    key = String.fromCharCode.apply(String, text.slice(0, index));
                    this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                    break;
                  case "IEND":
                    this.colors = function() {
                      switch (this.colorType) {
                        case 0:
                        case 3:
                        case 4:
                          return 1;
                        case 2:
                        case 6:
                          return 3
                      }
                    }.call(this);
                    this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
                    colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * colors;
                    this.colorSpace = function() {
                      switch (this.colors) {
                        case 1:
                          return "DeviceGray";
                        case 3:
                          return "DeviceRGB"
                      }
                    }.call(this);
                    this.imgData = new Buffer(this.imgData);
                    return;
                  default:
                    this.pos += chunkSize
                }
                this.pos += 4;
                if (this.pos > this.data.length) {
                  throw new Error("Incomplete or corrupt PNG file")
                }
              }
              return
            }
            PNG.prototype.read = function(bytes) {
              var i, _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                _results.push(this.data[this.pos++])
              }
              return _results
            };
            PNG.prototype.readUInt32 = function() {
              var b1, b2, b3, b4;
              b1 = this.data[this.pos++] << 24;
              b2 = this.data[this.pos++] << 16;
              b3 = this.data[this.pos++] << 8;
              b4 = this.data[this.pos++];
              return b1 | b2 | b3 | b4
            };
            PNG.prototype.readUInt16 = function() {
              var b1, b2;
              b1 = this.data[this.pos++] << 8;
              b2 = this.data[this.pos++];
              return b1 | b2
            };
            PNG.prototype.decodePixels = function(fn) {
              var _this = this;
              return zlib.inflate(this.imgData, function(err, data) {
                var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
                if (err) {
                  throw err
                }
                pixelBytes = _this.pixelBitlength / 8;
                scanlineLength = pixelBytes * _this.width;
                pixels = new Buffer(scanlineLength * _this.height);
                length = data.length;
                row = 0;
                pos = 0;
                c = 0;
                while (pos < length) {
                  switch (data[pos++]) {
                    case 0:
                      for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                        pixels[c++] = data[pos++]
                      }
                      break;
                    case 1:
                      for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                        byte = data[pos++];
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        pixels[c++] = (byte + left) % 256
                      }
                      break;
                    case 2:
                      for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                        byte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (upper + byte) % 256
                      }
                      break;
                    case 3:
                      for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                        byte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256
                      }
                      break;
                    case 4:
                      for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                        byte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        if (row === 0) {
                          upper = upperLeft = 0
                        } else {
                          upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                          upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes]
                        }
                        p = left + upper - upperLeft;
                        pa = Math.abs(p - left);
                        pb = Math.abs(p - upper);
                        pc = Math.abs(p - upperLeft);
                        if (pa <= pb && pa <= pc) {
                          paeth = left
                        } else if (pb <= pc) {
                          paeth = upper
                        } else {
                          paeth = upperLeft
                        }
                        pixels[c++] = (byte + paeth) % 256
                      }
                      break;
                    default:
                      throw new Error("Invalid filter algorithm: " + data[pos - 1])
                  }
                  row++
                }
                return fn(pixels)
              })
            };
            PNG.prototype.decodePalette = function() {
              var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
              palette = this.palette;
              transparency = this.transparency.indexed || [];
              ret = new Buffer(transparency.length + palette.length);
              pos = 0;
              length = palette.length;
              c = 0;
              for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                ret[pos++] = palette[i];
                ret[pos++] = palette[i + 1];
                ret[pos++] = palette[i + 2];
                ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255
              }
              return ret
            };
            PNG.prototype.copyToImageData = function(imageData, pixels) {
              var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
              colors = this.colors;
              palette = null;
              alpha = this.hasAlphaChannel;
              if (this.palette.length) {
                palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
                colors = 4;
                alpha = true
              }
              data = (imageData != null ? imageData.data : void 0) || imageData;
              length = data.length;
              input = palette || pixels;
              i = j = 0;
              if (colors === 1) {
                while (i < length) {
                  k = palette ? pixels[i / 4] * 4 : j;
                  v = input[k++];
                  data[i++] = v;
                  data[i++] = v;
                  data[i++] = v;
                  data[i++] = alpha ? input[k++] : 255;
                  j = k
                }
              } else {
                while (i < length) {
                  k = palette ? pixels[i / 4] * 4 : j;
                  data[i++] = input[k++];
                  data[i++] = input[k++];
                  data[i++] = input[k++];
                  data[i++] = alpha ? input[k++] : 255;
                  j = k
                }
              }
            };
            PNG.prototype.decode = function(fn) {
              var ret, _this = this;
              ret = new Buffer(this.width * this.height * 4);
              return this.decodePixels(function(pixels) {
                _this.copyToImageData(ret, pixels);
                return fn(ret)
              })
            };
            return PNG
          }()
        }).call(this)
      }).call(this, require("buffer").Buffer)
    }, {
      buffer: 17,
      fs: 1,
      zlib: 16
    }],
    96: [function(require, module, exports) {
      var GridSampler = {};
      GridSampler.checkAndNudgePoints = function(image, points) {
        var width = image.width;
        var height = image.height;
        var nudged = true;
        for (var offset = 0; offset < points.length && nudged; offset += 2) {
          var x = Math.floor(points[offset]);
          var y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw "Error.checkAndNudgePoints "
          }
          nudged = false;
          if (x == -1) {
            points[offset] = 0;
            nudged = true
          } else if (x == width) {
            points[offset] = width - 1;
            nudged = true
          }
          if (y == -1) {
            points[offset + 1] = 0;
            nudged = true
          } else if (y == height) {
            points[offset + 1] = height - 1;
            nudged = true
          }
        }
        nudged = true;
        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
          var x = Math.floor(points[offset]);
          var y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw "Error.checkAndNudgePoints "
          }
          nudged = false;
          if (x == -1) {
            points[offset] = 0;
            nudged = true
          } else if (x == width) {
            points[offset] = width - 1;
            nudged = true
          }
          if (y == -1) {
            points[offset + 1] = 0;
            nudged = true
          } else if (y == height) {
            points[offset + 1] = height - 1;
            nudged = true
          }
        }
      };
      GridSampler.sampleGrid3 = function(image, dimension, transform) {
        var bits = new BitMatrix(dimension);
        var points = new Array(dimension << 1);
        for (var y = 0; y < dimension; y++) {
          var max = points.length;
          var iValue = y + .5;
          for (var x = 0; x < max; x += 2) {
            points[x] = (x >> 1) + .5;
            points[x + 1] = iValue
          }
          transform.transformPoints1(points);
          GridSampler.checkAndNudgePoints(image, points);
          try {
            for (var x = 0; x < max; x += 2) {
              var xpoint = Math.floor(points[x]) * 4 + Math.floor(points[x + 1]) * image.width * 4;
              var bit = image.data[Math.floor(points[x]) + image.width * Math.floor(points[x + 1])];
              if (bit) bits.set_Renamed(x >> 1, y)
            }
          } catch (aioobe) {
            throw "Error.checkAndNudgePoints"
          }
        }
        return bits
      };

      function ECB(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
        Object.defineProperty(this, "Count", {
          get: function() {
            return this.count
          }
        });
        Object.defineProperty(this, "DataCodewords", {
          get: function() {
            return this.dataCodewords
          }
        })
      }

      function ECBlocks(ecCodewordsPerBlock, ecBlocks1, ecBlocks2) {
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        if (ecBlocks2) this.ecBlocks = new Array(ecBlocks1, ecBlocks2);
        else this.ecBlocks = new Array(ecBlocks1);
        Object.defineProperty(this, "ECCodewordsPerBlock", {
          get: function() {
            return this.ecCodewordsPerBlock
          }
        });
        Object.defineProperty(this, "TotalECCodewords", {
          get: function() {
            return this.ecCodewordsPerBlock * this.NumBlocks
          }
        });
        Object.defineProperty(this, "NumBlocks", {
          get: function() {
            var total = 0;
            for (var i = 0; i < this.ecBlocks.length; i++) {
              total += this.ecBlocks[i].length
            }
            return total
          }
        });
        this.getECBlocks = function() {
          return this.ecBlocks
        }
      }

      function Version(versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4) {
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);
        var total = 0;
        var ecCodewords = ecBlocks1.ECCodewordsPerBlock;
        var ecbArray = ecBlocks1.getECBlocks();
        for (var i = 0; i < ecbArray.length; i++) {
          var ecBlock = ecbArray[i];
          total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords)
        }
        this.totalCodewords = total;
        Object.defineProperty(this, "VersionNumber", {
          get: function() {
            return this.versionNumber
          }
        });
        Object.defineProperty(this, "AlignmentPatternCenters", {
          get: function() {
            return this.alignmentPatternCenters
          }
        });
        Object.defineProperty(this, "TotalCodewords", {
          get: function() {
            return this.totalCodewords
          }
        });
        Object.defineProperty(this, "DimensionForVersion", {
          get: function() {
            return 17 + 4 * this.versionNumber
          }
        });
        this.buildFunctionPattern = function() {
          var dimension = this.DimensionForVersion;
          var bitMatrix = new BitMatrix(dimension);
          bitMatrix.setRegion(0, 0, 9, 9);
          bitMatrix.setRegion(dimension - 8, 0, 8, 9);
          bitMatrix.setRegion(0, dimension - 8, 9, 8);
          var max = this.alignmentPatternCenters.length;
          for (var x = 0; x < max; x++) {
            var i = this.alignmentPatternCenters[x] - 2;
            for (var y = 0; y < max; y++) {
              if (x == 0 && (y == 0 || y == max - 1) || x == max - 1 && y == 0) {
                continue
              }
              bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5)
            }
          }
          bitMatrix.setRegion(6, 9, 1, dimension - 17);
          bitMatrix.setRegion(9, 6, dimension - 17, 1);
          if (this.versionNumber > 6) {
            bitMatrix.setRegion(dimension - 11, 0, 3, 6);
            bitMatrix.setRegion(0, dimension - 11, 6, 3)
          }
          return bitMatrix
        };
        this.getECBlocksForLevel = function(ecLevel) {
          return this.ecBlocks[ecLevel.ordinal()]
        }
      }
      Version.VERSION_DECODE_INFO = new Array(31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154, 84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568, 133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017);
      Version.VERSIONS = buildVersions();
      Version.getVersionForNumber = function(versionNumber) {
        if (versionNumber < 1 || versionNumber > 40) {
          throw "ArgumentException"
        }
        return Version.VERSIONS[versionNumber - 1]
      };
      Version.getProvisionalVersionForDimension = function(dimension) {
        if (dimension % 4 != 1) {
          throw "Error getProvisionalVersionForDimension"
        }
        try {
          return Version.getVersionForNumber(dimension - 17 >> 2)
        } catch (iae) {
          throw "Error getVersionForNumber"
        }
      };
      Version.decodeVersionInformation = function(versionBits) {
        var bestDifference = 4294967295;
        var bestVersion = 0;
        for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
          var targetVersion = Version.VERSION_DECODE_INFO[i];
          if (targetVersion == versionBits) {
            return this.getVersionForNumber(i + 7)
          }
          var bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
          if (bitsDifference < bestDifference) {
            bestVersion = i + 7;
            bestDifference = bitsDifference
          }
        }
        if (bestDifference <= 3) {
          return this.getVersionForNumber(bestVersion)
        }
        return null
      };

      function buildVersions() {
        return new Array(new Version(1, new Array, new ECBlocks(7, new ECB(1, 19)), new ECBlocks(10, new ECB(1, 16)), new ECBlocks(13, new ECB(1, 13)), new ECBlocks(17, new ECB(1, 9))), new Version(2, new Array(6, 18), new ECBlocks(10, new ECB(1, 34)), new ECBlocks(16, new ECB(1, 28)), new ECBlocks(22, new ECB(1, 22)), new ECBlocks(28, new ECB(1, 16))), new Version(3, new Array(6, 22), new ECBlocks(15, new ECB(1, 55)), new ECBlocks(26, new ECB(1, 44)), new ECBlocks(18, new ECB(2, 17)), new ECBlocks(22, new ECB(2, 13))), new Version(4, new Array(6, 26), new ECBlocks(20, new ECB(1, 80)), new ECBlocks(18, new ECB(2, 32)), new ECBlocks(26, new ECB(2, 24)), new ECBlocks(16, new ECB(4, 9))), new Version(5, new Array(6, 30), new ECBlocks(26, new ECB(1, 108)), new ECBlocks(24, new ECB(2, 43)), new ECBlocks(18, new ECB(2, 15), new ECB(2, 16)), new ECBlocks(22, new ECB(2, 11), new ECB(2, 12))), new Version(6, new Array(6, 34), new ECBlocks(18, new ECB(2, 68)), new ECBlocks(16, new ECB(4, 27)), new ECBlocks(24, new ECB(4, 19)), new ECBlocks(28, new ECB(4, 15))), new Version(7, new Array(6, 22, 38), new ECBlocks(20, new ECB(2, 78)), new ECBlocks(18, new ECB(4, 31)), new ECBlocks(18, new ECB(2, 14), new ECB(4, 15)), new ECBlocks(26, new ECB(4, 13), new ECB(1, 14))), new Version(8, new Array(6, 24, 42), new ECBlocks(24, new ECB(2, 97)), new ECBlocks(22, new ECB(2, 38), new ECB(2, 39)), new ECBlocks(22, new ECB(4, 18), new ECB(2, 19)), new ECBlocks(26, new ECB(4, 14), new ECB(2, 15))), new Version(9, new Array(6, 26, 46), new ECBlocks(30, new ECB(2, 116)), new ECBlocks(22, new ECB(3, 36), new ECB(2, 37)), new ECBlocks(20, new ECB(4, 16), new ECB(4, 17)), new ECBlocks(24, new ECB(4, 12), new ECB(4, 13))), new Version(10, new Array(6, 28, 50), new ECBlocks(18, new ECB(2, 68), new ECB(2, 69)), new ECBlocks(26, new ECB(4, 43), new ECB(1, 44)), new ECBlocks(24, new ECB(6, 19), new ECB(2, 20)), new ECBlocks(28, new ECB(6, 15), new ECB(2, 16))), new Version(11, new Array(6, 30, 54), new ECBlocks(20, new ECB(4, 81)), new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))), new Version(12, new Array(6, 32, 58), new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))), new Version(13, new Array(6, 34, 62), new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))), new Version(14, new Array(6, 26, 46, 66), new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))), new Version(15, new Array(6, 26, 48, 70), new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))), new Version(16, new Array(6, 26, 50, 74), new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))), new Version(17, new Array(6, 30, 54, 78), new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))), new Version(18, new Array(6, 30, 56, 82), new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))), new Version(19, new Array(6, 30, 58, 86), new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21), new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))), new Version(20, new Array(6, 34, 62, 90), new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))), new Version(21, new Array(6, 28, 50, 72, 94), new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))), new Version(22, new Array(6, 26, 50, 74, 98), new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))), new Version(23, new Array(6, 30, 54, 74, 102), new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))), new Version(24, new Array(6, 28, 54, 80, 106), new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))), new Version(25, new Array(6, 32, 58, 84, 110), new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))), new Version(26, new Array(6, 30, 58, 86, 114), new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))), new Version(27, new Array(6, 34, 62, 90, 118), new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15), new ECB(28, 16))), new Version(28, new Array(6, 26, 50, 74, 98, 122), new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))), new Version(29, new Array(6, 30, 54, 78, 102, 126), new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))), new Version(30, new Array(6, 26, 52, 78, 104, 130), new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))), new Version(31, new Array(6, 30, 56, 82, 108, 134), new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))), new Version(32, new Array(6, 34, 60, 86, 112, 138), new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))), new Version(33, new Array(6, 30, 58, 86, 114, 142), new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))), new Version(34, new Array(6, 34, 62, 90, 118, 146), new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))), new Version(35, new Array(6, 30, 54, 78, 102, 126, 150), new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))), new Version(36, new Array(6, 24, 50, 76, 102, 128, 154), new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))), new Version(37, new Array(6, 28, 54, 80, 106, 132, 158), new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))), new Version(38, new Array(6, 32, 58, 84, 110, 136, 162), new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))), new Version(39, new Array(6, 26, 54, 82, 110, 138, 166), new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))), new Version(40, new Array(6, 30, 58, 86, 114, 142, 170), new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16))));
      }

      function PerspectiveTransform(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
        this.a11 = a11;
        this.a12 = a12;
        this.a13 = a13;
        this.a21 = a21;
        this.a22 = a22;
        this.a23 = a23;
        this.a31 = a31;
        this.a32 = a32;
        this.a33 = a33;
        this.transformPoints1 = function(points) {
          var max = points.length;
          var a11 = this.a11;
          var a12 = this.a12;
          var a13 = this.a13;
          var a21 = this.a21;
          var a22 = this.a22;
          var a23 = this.a23;
          var a31 = this.a31;
          var a32 = this.a32;
          var a33 = this.a33;
          for (var i = 0; i < max; i += 2) {
            var x = points[i];
            var y = points[i + 1];
            var denominator = a13 * x + a23 * y + a33;
            points[i] = (a11 * x + a21 * y + a31) / denominator;
            points[i + 1] = (a12 * x + a22 * y + a32) / denominator
          }
        };
        this.transformPoints2 = function(xValues, yValues) {
          var n = xValues.length;
          for (var i = 0; i < n; i++) {
            var x = xValues[i];
            var y = yValues[i];
            var denominator = this.a13 * x + this.a23 * y + this.a33;
            xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
            yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator
          }
        };
        this.buildAdjoint = function() {
          return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21)
        };
        this.times = function(other) {
          return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33)
        }
      }
      PerspectiveTransform.quadrilateralToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
        var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS)
      };
      PerspectiveTransform.squareToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3) {
        dy2 = y3 - y2;
        dy3 = y0 - y1 + y2 - y3;
        if (dy2 == 0 && dy3 == 0) {
          return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1)
        } else {
          dx1 = x1 - x2;
          dx2 = x3 - x2;
          dx3 = x0 - x1 + x2 - x3;
          dy1 = y1 - y2;
          denominator = dx1 * dy2 - dx2 * dy1;
          a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
          a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
          return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1)
        }
      };
      PerspectiveTransform.quadrilateralToSquare = function(x0, y0, x1, y1, x2, y2, x3, y3) {
        return this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint()
      };

      function DetectorResult(bits, points) {
        this.bits = bits;
        this.points = points
      }

      function Detector(image) {
        this.image = image;
        this.resultPointCallback = null;
        this.sizeOfBlackWhiteBlackRun = function(fromX, fromY, toX, toY) {
          var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
          if (steep) {
            var temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp
          }
          var dx = Math.abs(toX - fromX);
          var dy = Math.abs(toY - fromY);
          var error = -dx >> 1;
          var ystep = fromY < toY ? 1 : -1;
          var xstep = fromX < toX ? 1 : -1;
          var state = 0;
          for (var x = fromX, y = fromY; x != toX; x += xstep) {
            var realX = steep ? y : x;
            var realY = steep ? x : y;
            if (state == 1) {
              if (this.image.data[realX + realY * image.width]) {
                state++
              }
            } else {
              if (!this.image.data[realX + realY * image.width]) {
                state++
              }
            }
            if (state == 3) {
              var diffX = x - fromX;
              var diffY = y - fromY;
              return Math.sqrt(diffX * diffX + diffY * diffY)
            }
            error += dy;
            if (error > 0) {
              if (y == toY) {
                break
              }
              y += ystep;
              error -= dx
            }
          }
          var diffX2 = toX - fromX;
          var diffY2 = toY - fromY;
          return Math.sqrt(diffX2 * diffX2 + diffY2 * diffY2)
        };
        this.sizeOfBlackWhiteBlackRunBothWays = function(fromX, fromY, toX, toY) {
          var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
          var scale = 1;
          var otherToX = fromX - (toX - fromX);
          if (otherToX < 0) {
            scale = fromX / (fromX - otherToX);
            otherToX = 0
          } else if (otherToX >= image.width) {
            scale = (image.width - 1 - fromX) / (otherToX - fromX);
            otherToX = image.width - 1
          }
          var otherToY = Math.floor(fromY - (toY - fromY) * scale);
          scale = 1;
          if (otherToY < 0) {
            scale = fromY / (fromY - otherToY);
            otherToY = 0
          } else if (otherToY >= image.height) {
            scale = (image.height - 1 - fromY) / (otherToY - fromY);
            otherToY = image.height - 1
          }
          otherToX = Math.floor(fromX + (otherToX - fromX) * scale);
          result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
          return result - 1
        };
        this.calculateModuleSizeOneWay = function(pattern, otherPattern) {
          var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.X), Math.floor(pattern.Y), Math.floor(otherPattern.X), Math.floor(otherPattern.Y));
          var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor(pattern.X), Math.floor(pattern.Y));
          if (isNaN(moduleSizeEst1)) {
            return moduleSizeEst2 / 7
          }
          if (isNaN(moduleSizeEst2)) {
            return moduleSizeEst1 / 7
          }
          return (moduleSizeEst1 + moduleSizeEst2) / 14
        };
        this.calculateModuleSize = function(topLeft, topRight, bottomLeft) {
          return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2
        };
        this.distance = function(pattern1, pattern2) {
          xDiff = pattern1.X - pattern2.X;
          yDiff = pattern1.Y - pattern2.Y;
          return Math.sqrt(xDiff * xDiff + yDiff * yDiff)
        };
        this.computeDimension = function(topLeft, topRight, bottomLeft, moduleSize) {
          var tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);
          var tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);
          var dimension = (tltrCentersDimension + tlblCentersDimension >> 1) + 7;
          switch (dimension & 3) {
            case 0:
              dimension++;
              break;
            case 2:
              dimension--;
              break;
            case 3:
              throw "Error"
          }
          return dimension
        };
        this.findAlignmentInRegion = function(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
          var allowance = Math.floor(allowanceFactor * overallEstModuleSize);
          var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
          var alignmentAreaRightX = Math.min(image.width - 1, estAlignmentX + allowance);
          if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
            throw "Error"
          }
          var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
          var alignmentAreaBottomY = Math.min(image.height - 1, estAlignmentY + allowance);
          var alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
          return alignmentFinder.find()
        };
        this.createTransform = function(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
          var dimMinusThree = dimension - 3.5;
          var bottomRightX;
          var bottomRightY;
          var sourceBottomRightX;
          var sourceBottomRightY;
          if (alignmentPattern != null) {
            bottomRightX = alignmentPattern.X;
            bottomRightY = alignmentPattern.Y;
            sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3
          } else {
            bottomRightX = topRight.X - topLeft.X + bottomLeft.X;
            bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;
            sourceBottomRightX = sourceBottomRightY = dimMinusThree
          }
          var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);
          return transform
        };
        this.sampleGrid = function(image, transform, dimension) {
          var sampler = GridSampler;
          return sampler.sampleGrid3(image, dimension, transform)
        };
        this.processFinderPatternInfo = function(info) {
          var topLeft = info.TopLeft;
          var topRight = info.TopRight;
          var bottomLeft = info.BottomLeft;
          var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
          if (moduleSize < 1) {
            throw "Error"
          }
          var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
          var provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
          var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;
          var alignmentPattern = null;
          if (provisionalVersion.AlignmentPatternCenters.length > 0) {
            var bottomRightX = topRight.X - topLeft.X + bottomLeft.X;
            var bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;
            var correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
            var estAlignmentX = Math.floor(topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));
            var estAlignmentY = Math.floor(topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y));
            for (var i = 4; i <= 16; i <<= 1) {
              alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
              break
            }
          }
          var transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
          var bits = this.sampleGrid(this.image, transform, dimension);
          var points;
          if (alignmentPattern == null) {
            points = new Array(bottomLeft, topLeft, topRight)
          } else {
            points = new Array(bottomLeft, topLeft, topRight, alignmentPattern)
          }
          return new DetectorResult(bits, points)
        };
        this.detect = function() {
          var info = (new FinderPatternFinder).findFinderPattern(this.image);
          return this.processFinderPatternInfo(info)
        }
      }
      var FORMAT_INFO_MASK_QR = 21522;
      var FORMAT_INFO_DECODE_LOOKUP = new Array(new Array(21522, 0), new Array(20773, 1), new Array(24188, 2), new Array(23371, 3), new Array(17913, 4), new Array(16590, 5), new Array(20375, 6), new Array(19104, 7), new Array(30660, 8), new Array(29427, 9), new Array(32170, 10), new Array(30877, 11), new Array(26159, 12), new Array(25368, 13), new Array(27713, 14), new Array(26998, 15), new Array(5769, 16), new Array(5054, 17), new Array(7399, 18), new Array(6608, 19), new Array(1890, 20), new Array(597, 21), new Array(3340, 22), new Array(2107, 23), new Array(13663, 24), new Array(12392, 25), new Array(16177, 26), new Array(14854, 27), new Array(9396, 28), new Array(8579, 29), new Array(11994, 30), new Array(11245, 31));
      var BITS_SET_IN_HALF_BYTE = new Array(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);

      function FormatInformation(formatInfo) {
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
        this.dataMask = formatInfo & 7;
        Object.defineProperty(this, "ErrorCorrectionLevel", {
          get: function() {
            return this.errorCorrectionLevel
          }
        });
        Object.defineProperty(this, "DataMask", {
          get: function() {
            return this.dataMask
          }
        });
        this.GetHashCode = function() {
          return this.errorCorrectionLevel.ordinal() << 3 | dataMask
        };
        this.Equals = function(o) {
          var other = o;
          return this.errorCorrectionLevel == other.errorCorrectionLevel && this.dataMask == other.dataMask
        }
      }
      FormatInformation.numBitsDiffering = function(a, b) {
        a ^= b;
        return BITS_SET_IN_HALF_BYTE[a & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 4) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 8) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 12) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 16) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 20) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 24) & 15] + BITS_SET_IN_HALF_BYTE[URShift(a, 28) & 15]
      };
      FormatInformation.decodeFormatInformation = function(maskedFormatInfo) {
        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo);
        if (formatInfo != null) {
          return formatInfo
        }
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR)
      };
      FormatInformation.doDecodeFormatInformation = function(maskedFormatInfo) {
        var bestDifference = 4294967295;
        var bestFormatInfo = 0;
        for (var i = 0; i < FORMAT_INFO_DECODE_LOOKUP.length; i++) {
          var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
          var targetInfo = decodeInfo[0];
          if (targetInfo == maskedFormatInfo) {
            return new FormatInformation(decodeInfo[1])
          }
          var bitsDifference = this.numBitsDiffering(maskedFormatInfo, targetInfo);
          if (bitsDifference < bestDifference) {
            bestFormatInfo = decodeInfo[1];
            bestDifference = bitsDifference
          }
        }
        if (bestDifference <= 3) {
          return new FormatInformation(bestFormatInfo)
        }
        return null
      };

      function ErrorCorrectionLevel(ordinal, bits, name) {
        this.ordinal_Renamed_Field = ordinal;
        this.bits = bits;
        this.name = name;
        Object.defineProperty(this, "Bits", {
          get: function() {
            return this.bits
          }
        });
        Object.defineProperty(this, "Name", {
          get: function() {
            return this.name
          }
        });
        this.ordinal = function() {
          return this.ordinal_Renamed_Field
        }
      }
      ErrorCorrectionLevel.forBits = function(bits) {
        if (bits < 0 || bits >= FOR_BITS.length) {
          throw "ArgumentException"
        }
        return FOR_BITS[bits]
      };
      var FOR_BITS = new Array(new ErrorCorrectionLevel(1, 0, "M"), new ErrorCorrectionLevel(0, 1, "L"), new ErrorCorrectionLevel(3, 2, "H"), new ErrorCorrectionLevel(2, 3, "Q"));

      function BitMatrix(width, height) {
        if (!height) height = width;
        if (width < 1 || height < 1) {
          throw "Both dimensions must be greater than 0"
        }
        this.width = width;
        this.height = height;
        var rowSize = width >> 5;
        if ((width & 31) != 0) {
          rowSize++
        }
        this.rowSize = rowSize;
        this.bits = new Array(rowSize * height);
        for (var i = 0; i < this.bits.length; i++) this.bits[i] = 0;
        Object.defineProperty(this, "Width", {
          get: function() {
            return this.width
          }
        });
        Object.defineProperty(this, "Height", {
          get: function() {
            return this.height
          }
        });
        Object.defineProperty(this, "Dimension", {
          get: function() {
            if (this.width != this.height) {
              throw "Can't call getDimension() on a non-square matrix"
            }
            return this.width
          }
        });
        this.get_Renamed = function(x, y) {
          var offset = y * this.rowSize + (x >> 5);
          return (URShift(this.bits[offset], x & 31) & 1) != 0
        };
        this.set_Renamed = function(x, y) {
          var offset = y * this.rowSize + (x >> 5);
          this.bits[offset] |= 1 << (x & 31)
        };
        this.flip = function(x, y) {
          var offset = y * this.rowSize + (x >> 5);
          this.bits[offset] ^= 1 << (x & 31)
        };
        this.clear = function() {
          var max = this.bits.length;
          for (var i = 0; i < max; i++) {
            this.bits[i] = 0
          }
        };
        this.setRegion = function(left, top, width, height) {
          if (top < 0 || left < 0) {
            throw "Left and top must be nonnegative"
          }
          if (height < 1 || width < 1) {
            throw "Height and width must be at least 1"
          }
          var right = left + width;
          var bottom = top + height;
          if (bottom > this.height || right > this.width) {
            throw "The region must fit inside the matrix"
          }
          for (var y = top; y < bottom; y++) {
            var offset = y * this.rowSize;
            for (var x = left; x < right; x++) {
              this.bits[offset + (x >> 5)] |= 1 << (x & 31)
            }
          }
        }
      }

      function DataBlock(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
        Object.defineProperty(this, "NumDataCodewords", {
          get: function() {
            return this.numDataCodewords
          }
        });
        Object.defineProperty(this, "Codewords", {
          get: function() {
            return this.codewords
          }
        })
      }
      DataBlock.getDataBlocks = function(rawCodewords, version, ecLevel) {
        if (rawCodewords.length != version.TotalCodewords) {
          throw "ArgumentException"
        }
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var totalBlocks = 0;
        var ecBlockArray = ecBlocks.getECBlocks();
        for (var i = 0; i < ecBlockArray.length; i++) {
          totalBlocks += ecBlockArray[i].Count
        }
        var result = new Array(totalBlocks);
        var numResultBlocks = 0;
        for (var j = 0; j < ecBlockArray.length; j++) {
          var ecBlock = ecBlockArray[j];
          for (var i = 0; i < ecBlock.Count; i++) {
            var numDataCodewords = ecBlock.DataCodewords;
            var numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;
            result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords))
          }
        }
        var shorterBlocksTotalCodewords = result[0].codewords.length;
        var longerBlocksStartAt = result.length - 1;
        while (longerBlocksStartAt >= 0) {
          var numCodewords = result[longerBlocksStartAt].codewords.length;
          if (numCodewords == shorterBlocksTotalCodewords) {
            break
          }
          longerBlocksStartAt--
        }
        longerBlocksStartAt++;
        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ECCodewordsPerBlock;
        var rawCodewordsOffset = 0;
        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++]
          }
        }
        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
          result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++]
        }
        var max = result[0].codewords.length;
        for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            var iOffset = j < longerBlocksStartAt ? i : i + 1;
            result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++]
          }
        }
        return result
      };

      function BitMatrixParser(bitMatrix) {
        var dimension = bitMatrix.Dimension;
        if (dimension < 21 || (dimension & 3) != 1) {
          throw "Error BitMatrixParser"
        }
        this.bitMatrix = bitMatrix;
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.copyBit = function(i, j, versionBits) {
          return this.bitMatrix.get_Renamed(i, j) ? versionBits << 1 | 1 : versionBits << 1
        };
        this.readFormatInformation = function() {
          if (this.parsedFormatInfo != null) {
            return this.parsedFormatInfo
          }
          var formatInfoBits = 0;
          for (var i = 0; i < 6; i++) {
            formatInfoBits = this.copyBit(i, 8, formatInfoBits)
          }
          formatInfoBits = this.copyBit(7, 8, formatInfoBits);
          formatInfoBits = this.copyBit(8, 8, formatInfoBits);
          formatInfoBits = this.copyBit(8, 7, formatInfoBits);
          for (var j = 5; j >= 0; j--) {
            formatInfoBits = this.copyBit(8, j, formatInfoBits)
          }
          this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
          if (this.parsedFormatInfo != null) {
            return this.parsedFormatInfo
          }
          var dimension = this.bitMatrix.Dimension;
          formatInfoBits = 0;
          var iMin = dimension - 8;
          for (var i = dimension - 1; i >= iMin; i--) {
            formatInfoBits = this.copyBit(i, 8, formatInfoBits)
          }
          for (var j = dimension - 7; j < dimension; j++) {
            formatInfoBits = this.copyBit(8, j, formatInfoBits)
          }
          this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
          if (this.parsedFormatInfo != null) {
            return this.parsedFormatInfo
          }
          throw "Error readFormatInformation"
        };
        this.readVersion = function() {
          if (this.parsedVersion != null) {
            return this.parsedVersion
          }
          var dimension = this.bitMatrix.Dimension;
          var provisionalVersion = dimension - 17 >> 2;
          if (provisionalVersion <= 6) {
            return Version.getVersionForNumber(provisionalVersion)
          }
          var versionBits = 0;
          var ijMin = dimension - 11;
          for (var j = 5; j >= 0; j--) {
            for (var i = dimension - 9; i >= ijMin; i--) {
              versionBits = this.copyBit(i, j, versionBits)
            }
          }
          this.parsedVersion = Version.decodeVersionInformation(versionBits);
          if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {
            return this.parsedVersion
          }
          versionBits = 0;
          for (var i = 5; i >= 0; i--) {
            for (var j = dimension - 9; j >= ijMin; j--) {
              versionBits = this.copyBit(i, j, versionBits)
            }
          }
          this.parsedVersion = Version.decodeVersionInformation(versionBits);
          if (this.parsedVersion != null && this.parsedVersion.DimensionForVersion == dimension) {
            return this.parsedVersion
          }
          throw "Error readVersion"
        };
        this.readCodewords = function() {
          var formatInfo = this.readFormatInformation();
          var version = this.readVersion();
          var dataMask = DataMask.forReference(formatInfo.DataMask);
          var dimension = this.bitMatrix.Dimension;
          dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
          var functionPattern = version.buildFunctionPattern();
          var readingUp = true;
          var result = new Array(version.TotalCodewords);
          var resultOffset = 0;
          var currentByte = 0;
          var bitsRead = 0;
          for (var j = dimension - 1; j > 0; j -= 2) {
            if (j == 6) {
              j--
            }
            for (var count = 0; count < dimension; count++) {
              var i = readingUp ? dimension - 1 - count : count;
              for (var col = 0; col < 2; col++) {
                if (!functionPattern.get_Renamed(j - col, i)) {
                  bitsRead++;
                  currentByte <<= 1;
                  if (this.bitMatrix.get_Renamed(j - col, i)) {
                    currentByte |= 1
                  }
                  if (bitsRead == 8) {
                    result[resultOffset++] = currentByte;
                    bitsRead = 0;
                    currentByte = 0
                  }
                }
              }
            }
            readingUp ^= true
          }
          if (resultOffset != version.TotalCodewords) {
            throw "Error readCodewords"
          }
          return result
        }
      }
      var DataMask = {};
      DataMask.forReference = function(reference) {
        if (reference < 0 || reference > 7) {
          throw "System.ArgumentException"
        }
        return DataMask.DATA_MASKS[reference]
      };

      function DataMask000() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return (i + j & 1) == 0
        }
      }

      function DataMask001() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return (i & 1) == 0
        }
      }

      function DataMask010() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return j % 3 == 0
        }
      }

      function DataMask011() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return (i + j) % 3 == 0
        }
      }

      function DataMask100() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return (URShift(i, 1) + j / 3 & 1) == 0
        }
      }

      function DataMask101() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          var temp = i * j;
          return (temp & 1) + temp % 3 == 0
        }
      }

      function DataMask110() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          var temp = i * j;
          return ((temp & 1) + temp % 3 & 1) == 0
        }
      }

      function DataMask111() {
        this.unmaskBitMatrix = function(bits, dimension) {
          for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
              if (this.isMasked(i, j)) {
                bits.flip(j, i)
              }
            }
          }
        };
        this.isMasked = function(i, j) {
          return ((i + j & 1) + i * j % 3 & 1) == 0
        }
      }
      DataMask.DATA_MASKS = new Array(new DataMask000, new DataMask001, new DataMask010, new DataMask011, new DataMask100, new DataMask101, new DataMask110, new DataMask111);

      function ReedSolomonDecoder(field) {
        this.field = field;
        this.decode = function(received, twoS) {
          var poly = new GF256Poly(this.field, received);
          var syndromeCoefficients = new Array(twoS);
          for (var i = 0; i < syndromeCoefficients.length; i++) syndromeCoefficients[i] = 0;
          var dataMatrix = false;
          var noError = true;
          for (var i = 0; i < twoS; i++) {
            var eval = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));
            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;
            if (eval != 0) {
              noError = false
            }
          }
          if (noError) {
            return
          }
          var syndrome = new GF256Poly(this.field, syndromeCoefficients);
          var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);
          var sigma = sigmaOmega[0];
          var omega = sigmaOmega[1];
          var errorLocations = this.findErrorLocations(sigma);
          var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);
          for (var i = 0; i < errorLocations.length; i++) {
            var position = received.length - 1 - this.field.log(errorLocations[i]);
            if (position < 0) {
              throw "ReedSolomonException Bad error location"
            }
            received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i])
          }
        };
        this.runEuclideanAlgorithm = function(a, b, R) {
          if (a.Degree < b.Degree) {
            var temp = a;
            a = b;
            b = temp
          }
          var rLast = a;
          var r = b;
          var sLast = this.field.One;
          var s = this.field.Zero;
          var tLast = this.field.Zero;
          var t = this.field.One;
          while (r.Degree >= Math.floor(R / 2)) {
            var rLastLast = rLast;
            var sLastLast = sLast;
            var tLastLast = tLast;
            rLast = r;
            sLast = s;
            tLast = t;
            if (rLast.Zero) {
              throw "r_{i-1} was zero"
            }
            r = rLastLast;
            var q = this.field.Zero;
            var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);
            var dltInverse = this.field.inverse(denominatorLeadingTerm);
            while (r.Degree >= rLast.Degree && !r.Zero) {
              var degreeDiff = r.Degree - rLast.Degree;
              var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);
              q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));
              r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale))
            }
            s = q.multiply1(sLast).addOrSubtract(sLastLast);
            t = q.multiply1(tLast).addOrSubtract(tLastLast)
          }
          var sigmaTildeAtZero = t.getCoefficient(0);
          if (sigmaTildeAtZero == 0) {
            throw "ReedSolomonException sigmaTilde(0) was zero"
          }
          var inverse = this.field.inverse(sigmaTildeAtZero);
          var sigma = t.multiply2(inverse);
          var omega = r.multiply2(inverse);
          return new Array(sigma, omega)
        };
        this.findErrorLocations = function(errorLocator) {
          var numErrors = errorLocator.Degree;
          if (numErrors == 1) {
            return new Array(errorLocator.getCoefficient(1))
          }
          var result = new Array(numErrors);
          var e = 0;
          for (var i = 1; i < 256 && e < numErrors; i++) {
            if (errorLocator.evaluateAt(i) == 0) {
              result[e] = this.field.inverse(i);
              e++
            }
          }
          if (e != numErrors) {
            throw "Error locator degree does not match number of roots"
          }
          return result
        };
        this.findErrorMagnitudes = function(errorEvaluator, errorLocations, dataMatrix) {
          var s = errorLocations.length;
          var result = new Array(s);
          for (var i = 0; i < s; i++) {
            var xiInverse = this.field.inverse(errorLocations[i]);
            var denominator = 1;
            for (var j = 0; j < s; j++) {
              if (i != j) {
                denominator = this.field.multiply(denominator, GF256.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)))
              }
            }
            result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator));
            if (dataMatrix) {
              result[i] = this.field.multiply(result[i], xiInverse)
            }
          }
          return result
        }
      }

      function GF256Poly(field, coefficients) {
        if (coefficients == null || coefficients.length == 0) {
          throw "System.ArgumentException"
        }
        this.field = field;
        var coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] == 0) {
          var firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] == 0) {
            firstNonZero++
          }
          if (firstNonZero == coefficientsLength) {
            this.coefficients = field.Zero.coefficients
          } else {
            this.coefficients = new Array(coefficientsLength - firstNonZero);
            for (var i = 0; i < this.coefficients.length; i++) this.coefficients[i] = 0;
            for (var ci = 0; ci < this.coefficients.length; ci++) this.coefficients[ci] = coefficients[firstNonZero + ci]
          }
        } else {
          this.coefficients = coefficients
        }
        Object.defineProperty(this, "Zero", {
          get: function() {
            return this.coefficients[0] == 0
          }
        });
        Object.defineProperty(this, "Degree", {
          get: function() {
            return this.coefficients.length - 1
          }
        });
        Object.defineProperty(this, "Coefficients", {
          get: function() {
            return this.coefficients
          }
        });
        this.getCoefficient = function(degree) {
          return this.coefficients[this.coefficients.length - 1 - degree]
        };
        this.evaluateAt = function(a) {
          if (a == 0) {
            return this.getCoefficient(0)
          }
          var size = this.coefficients.length;
          if (a == 1) {
            var result = 0;
            for (var i = 0; i < size; i++) {
              result = GF256.addOrSubtract(result, this.coefficients[i])
            }
            return result
          }
          var result2 = this.coefficients[0];
          for (var i = 1; i < size; i++) {
            result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i])
          }
          return result2
        };
        this.addOrSubtract = function(other) {
          if (this.field != other.field) {
            throw "GF256Polys do not have same GF256 field"
          }
          if (this.Zero) {
            return other
          }
          if (other.Zero) {
            return this
          }
          var smallerCoefficients = this.coefficients;
          var largerCoefficients = other.coefficients;
          if (smallerCoefficients.length > largerCoefficients.length) {
            var temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp
          }
          var sumDiff = new Array(largerCoefficients.length);
          var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
          for (var ci = 0; ci < lengthDiff; ci++) sumDiff[ci] = largerCoefficients[ci];
          for (var i = lengthDiff; i < largerCoefficients.length; i++) {
            sumDiff[i] = GF256.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i])
          }
          return new GF256Poly(field, sumDiff)
        };
        this.multiply1 = function(other) {
          if (this.field != other.field) {
            throw "GF256Polys do not have same GF256 field"
          }
          if (this.Zero || other.Zero) {
            return this.field.Zero
          }
          var aCoefficients = this.coefficients;
          var aLength = aCoefficients.length;
          var bCoefficients = other.coefficients;
          var bLength = bCoefficients.length;
          var product = new Array(aLength + bLength - 1);
          for (var i = 0; i < aLength; i++) {
            var aCoeff = aCoefficients[i];
            for (var j = 0; j < bLength; j++) {
              product[i + j] = GF256.addOrSubtract(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]))
            }
          }
          return new GF256Poly(this.field, product)
        };
        this.multiply2 = function(scalar) {
          if (scalar == 0) {
            return this.field.Zero
          }
          if (scalar == 1) {
            return this
          }
          var size = this.coefficients.length;
          var product = new Array(size);
          for (var i = 0; i < size; i++) {
            product[i] = this.field.multiply(this.coefficients[i], scalar)
          }
          return new GF256Poly(this.field, product)
        };
        this.multiplyByMonomial = function(degree, coefficient) {
          if (degree < 0) {
            throw "System.ArgumentException"
          }
          if (coefficient == 0) {
            return this.field.Zero
          }
          var size = this.coefficients.length;
          var product = new Array(size + degree);
          for (var i = 0; i < product.length; i++) product[i] = 0;
          for (var i = 0; i < size; i++) {
            product[i] = this.field.multiply(this.coefficients[i], coefficient)
          }
          return new GF256Poly(this.field, product)
        };
        this.divide = function(other) {
          if (this.field != other.field) {
            throw "GF256Polys do not have same GF256 field"
          }
          if (other.Zero) {
            throw "Divide by 0"
          }
          var quotient = this.field.Zero;
          var remainder = this;
          var denominatorLeadingTerm = other.getCoefficient(other.Degree);
          var inverseDenominatorLeadingTerm = this.field.inverse(denominatorLeadingTerm);
          while (remainder.Degree >= other.Degree && !remainder.Zero) {
            var degreeDifference = remainder.Degree - other.Degree;
            var scale = this.field.multiply(remainder.getCoefficient(remainder.Degree), inverseDenominatorLeadingTerm);
            var term = other.multiplyByMonomial(degreeDifference, scale);
            var iterationQuotient = this.field.buildMonomial(degreeDifference, scale);
            quotient = quotient.addOrSubtract(iterationQuotient);
            remainder = remainder.addOrSubtract(term)
          }
          return new Array(quotient, remainder)
        }
      }

      function GF256(primitive) {
        this.expTable = new Array(256);
        this.logTable = new Array(256);
        var x = 1;
        for (var i = 0; i < 256; i++) {
          this.expTable[i] = x;
          x <<= 1;
          if (x >= 256) {
            x ^= primitive
          }
        }
        for (var i = 0; i < 255; i++) {
          this.logTable[this.expTable[i]] = i
        }
        var at0 = new Array(1);
        at0[0] = 0;
        this.zero = new GF256Poly(this, new Array(at0));
        var at1 = new Array(1);
        at1[0] = 1;
        this.one = new GF256Poly(this, new Array(at1));
        Object.defineProperty(this, "Zero", {
          get: function() {
            return this.zero
          }
        });
        Object.defineProperty(this, "One", {
          get: function() {
            return this.one
          }
        });
        this.buildMonomial = function(degree, coefficient) {
          if (degree < 0) {
            throw "System.ArgumentException"
          }
          if (coefficient == 0) {
            return zero
          }
          var coefficients = new Array(degree + 1);
          for (var i = 0; i < coefficients.length; i++) coefficients[i] = 0;
          coefficients[0] = coefficient;
          return new GF256Poly(this, coefficients)
        };
        this.exp = function(a) {
          return this.expTable[a]
        };
        this.log = function(a) {
          if (a == 0) {
            throw "System.ArgumentException"
          }
          return this.logTable[a]
        };
        this.inverse = function(a) {
          if (a == 0) {
            throw "System.ArithmeticException"
          }
          return this.expTable[255 - this.logTable[a]]
        };
        this.multiply = function(a, b) {
          if (a == 0 || b == 0) {
            return 0
          }
          if (a == 1) {
            return b
          }
          if (b == 1) {
            return a
          }
          return this.expTable[(this.logTable[a] + this.logTable[b]) % 255]
        }
      }
      GF256.QR_CODE_FIELD = new GF256(285);
      GF256.DATA_MATRIX_FIELD = new GF256(301);
      GF256.addOrSubtract = function(a, b) {
        return a ^ b
      };
      var Decoder = {};
      Decoder.rsDecoder = new ReedSolomonDecoder(GF256.QR_CODE_FIELD);
      Decoder.correctErrors = function(codewordBytes, numDataCodewords) {
        var numCodewords = codewordBytes.length;
        var codewordsInts = new Array(numCodewords);
        for (var i = 0; i < numCodewords; i++) {
          codewordsInts[i] = codewordBytes[i] & 255
        }
        var numECCodewords = codewordBytes.length - numDataCodewords;
        try {
          Decoder.rsDecoder.decode(codewordsInts, numECCodewords)
        } catch (rse) {
          throw rse
        }
        for (var i = 0; i < numDataCodewords; i++) {
          codewordBytes[i] = codewordsInts[i]
        }
      };
      Decoder.decode = function(bits) {
        var parser = new BitMatrixParser(bits);
        var version = parser.readVersion();
        var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;
        var codewords = parser.readCodewords();
        var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);
        var totalBytes = 0;
        for (var i = 0; i < dataBlocks.length; i++) {
          totalBytes += dataBlocks[i].NumDataCodewords
        }
        var resultBytes = new Array(totalBytes);
        var resultOffset = 0;
        for (var j = 0; j < dataBlocks.length; j++) {
          var dataBlock = dataBlocks[j];
          var codewordBytes = dataBlock.Codewords;
          var numDataCodewords = dataBlock.NumDataCodewords;
          Decoder.correctErrors(codewordBytes, numDataCodewords);
          for (var i = 0; i < numDataCodewords; i++) {
            resultBytes[resultOffset++] = codewordBytes[i]
          }
        }
        var reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);
        return reader
      };
      var qrcode = {};
      qrcode.sizeOfDataLengthInfo = [
        [10, 9, 8, 8],
        [12, 11, 16, 10],
        [14, 13, 16, 12]
      ];
      QrCode = function() {
        this.imagedata = null;
        this.width = 0;
        this.height = 0;
        this.qrCodeSymbol = null;
        this.debug = false;
        this.callback = null;
        this.decode = function(src, data) {
          var decode = function() {
            try {
              this.error = undefined;
              this.result = this.process(this.imagedata)
            } catch (e) {
              this.error = e;
              this.result = undefined
            }
            if (this.callback != null) {
              this.callback(this.result, this.error)
            }
            return this.result
          }.bind(this);
          if (src == undefined) {
            var canvas_qr = document.getElementById("qr-canvas");
            var context = canvas_qr.getContext("2d");
            this.width = canvas_qr.width;
            this.height = canvas_qr.height;
            this.imagedata = context.getImageData(0, 0, this.width, this.height);
            decode()
          } else if (src.width != undefined) {
            this.width = src.width;
            this.height = src.height;
            this.imagedata = {
              data: data || src.data
            };
            this.imagedata.width = src.width;
            this.imagedata.height = src.height;
            decode()
          } else {
            var image = new Image;
            var _this = this;
            image.onload = function() {
              var canvas_qr = document.createElement("canvas");
              var context = canvas_qr.getContext("2d");
              var canvas_out = document.getElementById("out-canvas");
              if (canvas_out != null) {
                var outctx = canvas_out.getContext("2d");
                outctx.clearRect(0, 0, 320, 240);
                outctx.drawImage(image, 0, 0, 320, 240)
              }
              canvas_qr.width = image.width;
              canvas_qr.height = image.height;
              context.drawImage(image, 0, 0);
              this.width = image.width;
              this.height = image.height;
              try {
                this.imagedata = context.getImageData(0, 0, image.width, image.height)
              } catch (e) {
                this.result = "Cross domain image reading not supported in your browser! Save it to your computer then drag and drop the file!";
                if (this.callback != null) return this.callback(this.result)
              }
              decode()
            }.bind(this);
            image.src = src
          }
        };
        this.decode_utf8 = function(s) {
          return decodeURIComponent(escape(s))
        };
        this.process = function(imageData) {
          var start = (new Date).getTime();
          var image = this.grayScaleToBitmap(this.grayscale(imageData));
          var detector = new Detector(image);
          var qRCodeMatrix = detector.detect();
          var reader = Decoder.decode(qRCodeMatrix.bits);
          var data = reader.DataByte;
          var str = "";
          for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) str += String.fromCharCode(data[i][j])
          }
          var end = (new Date).getTime();
          var time = end - start;
          if (this.debug) {
            console.log("QR Code processing time (ms): " + time)
          }
          return this.decode_utf8(str)
        };
        this.getPixel = function(imageData, x, y) {
          if (imageData.width < x) {
            throw "point error"
          }
          if (imageData.height < y) {
            throw "point error"
          }
          var point = x * 4 + y * imageData.width * 4;
          return (imageData.data[point] * 33 + imageData.data[point + 1] * 34 + imageData.data[point + 2] * 33) / 100
        };
        this.binarize = function(th) {
          var ret = new Array(this.width * this.height);
          for (var y = 0; y < this.height; y++) {
            for (var x = 0; x < this.width; x++) {
              var gray = this.getPixel(x, y);
              ret[x + y * this.width] = gray <= th ? true : false
            }
          }
          return ret
        };
        this.getMiddleBrightnessPerArea = function(imageData) {
          var numSqrtArea = 4;
          var areaWidth = Math.floor(imageData.width / numSqrtArea);
          var areaHeight = Math.floor(imageData.height / numSqrtArea);
          var minmax = new Array(numSqrtArea);
          for (var i = 0; i < numSqrtArea; i++) {
            minmax[i] = new Array(numSqrtArea);
            for (var i2 = 0; i2 < numSqrtArea; i2++) {
              minmax[i][i2] = new Array(0, 0)
            }
          }
          for (var ay = 0; ay < numSqrtArea; ay++) {
            for (var ax = 0; ax < numSqrtArea; ax++) {
              minmax[ax][ay][0] = 255;
              for (var dy = 0; dy < areaHeight; dy++) {
                for (var dx = 0; dx < areaWidth; dx++) {
                  var target = imageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * imageData.width];
                  if (target < minmax[ax][ay][0]) minmax[ax][ay][0] = target;
                  if (target > minmax[ax][ay][1]) minmax[ax][ay][1] = target
                }
              }
            }
          }
          var middle = new Array(numSqrtArea);
          for (var i3 = 0; i3 < numSqrtArea; i3++) {
            middle[i3] = new Array(numSqrtArea)
          }
          for (var ay = 0; ay < numSqrtArea; ay++) {
            for (var ax = 0; ax < numSqrtArea; ax++) {
              middle[ax][ay] = Math.floor((minmax[ax][ay][0] + minmax[ax][ay][1]) / 2)
            }
          }
          return middle
        };
        this.grayScaleToBitmap = function(grayScaleImageData) {
          var middle = this.getMiddleBrightnessPerArea(grayScaleImageData);
          var sqrtNumArea = middle.length;
          var areaWidth = Math.floor(grayScaleImageData.width / sqrtNumArea);
          var areaHeight = Math.floor(grayScaleImageData.height / sqrtNumArea);
          for (var ay = 0; ay < sqrtNumArea; ay++) {
            for (var ax = 0; ax < sqrtNumArea; ax++) {
              for (var dy = 0; dy < areaHeight; dy++) {
                for (var dx = 0; dx < areaWidth; dx++) {
                  grayScaleImageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * grayScaleImageData.width] = grayScaleImageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * grayScaleImageData.width] < middle[ax][ay] ? true : false
                }
              }
            }
          }
          return grayScaleImageData
        };
        this.grayscale = function(imageData) {
          var ret = new Array(imageData.width * imageData.height);
          for (var y = 0; y < imageData.height; y++) {
            for (var x = 0; x < imageData.width; x++) {
              var gray = this.getPixel(imageData, x, y);
              ret[x + y * imageData.width] = gray
            }
          }
          return {
            height: imageData.height,
            width: imageData.width,
            data: ret
          }
        }
      };

      function URShift(number, bits) {
        if (number >= 0) return number >> bits;
        else return (number >> bits) + (2 << ~bits)
      }
      var MIN_SKIP = 3;
      var MAX_MODULES = 57;
      var INTEGER_MATH_SHIFT = 8;
      var CENTER_QUORUM = 2;
      qrcode.orderBestPatterns = function(patterns) {
        function distance(pattern1, pattern2) {
          xDiff = pattern1.X - pattern2.X;
          yDiff = pattern1.Y - pattern2.Y;
          return Math.sqrt(xDiff * xDiff + yDiff * yDiff)
        }

        function crossProductZ(pointA, pointB, pointC) {
          var bX = pointB.x;
          var bY = pointB.y;
          return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX)
        }
        var zeroOneDistance = distance(patterns[0], patterns[1]);
        var oneTwoDistance = distance(patterns[1], patterns[2]);
        var zeroTwoDistance = distance(patterns[0], patterns[2]);
        var pointA, pointB, pointC;
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
          pointB = patterns[0];
          pointA = patterns[1];
          pointC = patterns[2]
        } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
          pointB = patterns[1];
          pointA = patterns[0];
          pointC = patterns[2]
        } else {
          pointB = patterns[2];
          pointA = patterns[0];
          pointC = patterns[1]
        }
        if (crossProductZ(pointA, pointB, pointC) < 0) {
          var temp = pointA;
          pointA = pointC;
          pointC = temp
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC
      };

      function FinderPattern(posX, posY, estimatedModuleSize) {
        this.x = posX;
        this.y = posY;
        this.count = 1;
        this.estimatedModuleSize = estimatedModuleSize;
        Object.defineProperty(this, "EstimatedModuleSize", {
          get: function() {
            return this.estimatedModuleSize
          }
        });
        Object.defineProperty(this, "Count", {
          get: function() {
            return this.count
          }
        });
        Object.defineProperty(this, "X", {
          get: function() {
            return this.x
          }
        });
        Object.defineProperty(this, "Y", {
          get: function() {
            return this.y
          }
        });
        this.incrementCount = function() {
          this.count++
        };
        this.aboutEquals = function(moduleSize, i, j) {
          if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {
            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1 || moduleSizeDiff / this.estimatedModuleSize <= 1
          }
          return false
        }
      }

      function FinderPatternInfo(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
        Object.defineProperty(this, "BottomLeft", {
          get: function() {
            return this.bottomLeft
          }
        });
        Object.defineProperty(this, "TopLeft", {
          get: function() {
            return this.topLeft
          }
        });
        Object.defineProperty(this, "TopRight", {
          get: function() {
            return this.topRight
          }
        })
      }

      function FinderPatternFinder() {
        this.image = null;
        this.possibleCenters = [];
        this.hasSkipped = false;
        this.crossCheckStateCount = new Array(0, 0, 0, 0, 0);
        this.resultPointCallback = null;
        Object.defineProperty(this, "CrossCheckStateCount", {
          get: function() {
            this.crossCheckStateCount[0] = 0;
            this.crossCheckStateCount[1] = 0;
            this.crossCheckStateCount[2] = 0;
            this.crossCheckStateCount[3] = 0;
            this.crossCheckStateCount[4] = 0;
            return this.crossCheckStateCount
          }
        });
        this.foundPatternCross = function(stateCount) {
          var totalModuleSize = 0;
          for (var i = 0; i < 5; i++) {
            var count = stateCount[i];
            if (count == 0) {
              return false
            }
            totalModuleSize += count
          }
          if (totalModuleSize < 7) {
            return false
          }
          var moduleSize = Math.floor((totalModuleSize << INTEGER_MATH_SHIFT) / 7);
          var maxVariance = Math.floor(moduleSize / 2);
          return Math.abs(moduleSize - (stateCount[0] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << INTEGER_MATH_SHIFT)) < maxVariance
        };
        this.centerFromEnd = function(stateCount, end) {
          return end - stateCount[4] - stateCount[3] - stateCount[2] / 2
        };
        this.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
          var image = this.image;
          var maxI = image.height;
          var stateCount = this.CrossCheckStateCount;
          var i = startI;
          while (i >= 0 && image.data[centerJ + i * image.width]) {
            stateCount[2]++;
            i--
          }
          if (i < 0) {
            return NaN
          }
          while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--
          }
          if (i < 0 || stateCount[1] > maxCount) {
            return NaN
          }
          while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--
          }
          if (stateCount[0] > maxCount) {
            return NaN
          }
          i = startI + 1;
          while (i < maxI && image.data[centerJ + i * image.width]) {
            stateCount[2]++;
            i++
          }
          if (i == maxI) {
            return NaN
          }
          while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[3] < maxCount) {
            stateCount[3]++;
            i++
          }
          if (i == maxI || stateCount[3] >= maxCount) {
            return NaN
          }
          while (i < maxI && image.data[centerJ + i * image.width] && stateCount[4] < maxCount) {
            stateCount[4]++;
            i++
          }
          if (stateCount[4] >= maxCount) {
            return NaN
          }
          var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN
          }
          return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN
        };
        this.crossCheckHorizontal = function(startJ, centerI, maxCount, originalStateCountTotal) {
          var image = this.image;
          var maxJ = image.width;
          var stateCount = this.CrossCheckStateCount;
          var j = startJ;
          while (j >= 0 && image.data[j + centerI * image.width]) {
            stateCount[2]++;
            j--
          }
          if (j < 0) {
            return NaN
          }
          while (j >= 0 && !image.data[j + centerI * image.width] && stateCount[1] <= maxCount) {
            stateCount[1]++;
            j--
          }
          if (j < 0 || stateCount[1] > maxCount) {
            return NaN
          }
          while (j >= 0 && image.data[j + centerI * image.width] && stateCount[0] <= maxCount) {
            stateCount[0]++;
            j--
          }
          if (stateCount[0] > maxCount) {
            return NaN
          }
          j = startJ + 1;
          while (j < maxJ && image.data[j + centerI * image.width]) {
            stateCount[2]++;
            j++
          }
          if (j == maxJ) {
            return NaN
          }
          while (j < maxJ && !image.data[j + centerI * image.width] && stateCount[3] < maxCount) {
            stateCount[3]++;
            j++
          }
          if (j == maxJ || stateCount[3] >= maxCount) {
            return NaN
          }
          while (j < maxJ && image.data[j + centerI * image.width] && stateCount[4] < maxCount) {
            stateCount[4]++;
            j++
          }
          if (stateCount[4] >= maxCount) {
            return NaN
          }
          var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
            return NaN
          }
          return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, j) : NaN
        };
        this.handlePossibleCenter = function(stateCount, i, j) {
          var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          var centerJ = this.centerFromEnd(stateCount, j);
          var centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal);
          if (!isNaN(centerI)) {
            centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);
            if (!isNaN(centerJ)) {
              var estimatedModuleSize = stateCountTotal / 7;
              var found = false;
              var max = this.possibleCenters.length;
              for (var index = 0; index < max; index++) {
                var center = this.possibleCenters[index];
                if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                  center.incrementCount();
                  found = true;
                  break
                }
              }
              if (!found) {
                var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);
                this.possibleCenters.push(point);
                if (this.resultPointCallback != null) {
                  this.resultPointCallback.foundPossibleResultPoint(point)
                }
              }
              return true
            }
          }
          return false
        };
        this.selectBestPatterns = function() {
          var startSize = this.possibleCenters.length;
          if (startSize < 3) {
            throw "Couldn't find enough finder patterns:" + startSize + " patterns found"
          }
          if (startSize > 3) {
            var totalModuleSize = 0;
            var square = 0;
            for (var i = 0; i < startSize; i++) {
              var centerValue = this.possibleCenters[i].EstimatedModuleSize;
              totalModuleSize += centerValue;
              square += centerValue * centerValue
            }
            var average = totalModuleSize / startSize;
            this.possibleCenters.sort(function(center1, center2) {
              var dA = Math.abs(center2.EstimatedModuleSize - average);
              var dB = Math.abs(center1.EstimatedModuleSize - average);
              if (dA < dB) {
                return -1
              } else if (dA == dB) {
                return 0
              } else {
                return 1
              }
            });
            var stdDev = Math.sqrt(square / startSize - average * average);
            var limit = Math.max(.2 * average, stdDev);
            for (var i = 0; i < this.possibleCenters.length && this.possibleCenters.length > 3; i++) {
              var pattern = this.possibleCenters[i];
              if (Math.abs(pattern.EstimatedModuleSize - average) > limit) {
                this.possibleCenters.splice(i, 1);
                i--
              }
            }
          }
          if (this.possibleCenters.length > 3) {
            this.possibleCenters.sort(function(a, b) {
              if (a.count > b.count) {
                return -1
              }
              if (a.count < b.count) {
                return 1
              }
              return 0
            })
          }
          return new Array(this.possibleCenters[0], this.possibleCenters[1], this.possibleCenters[2])
        };
        this.findRowSkip = function() {
          var max = this.possibleCenters.length;
          if (max <= 1) {
            return 0
          }
          var firstConfirmedCenter = null;
          for (var i = 0; i < max; i++) {
            var center = this.possibleCenters[i];
            if (center.Count >= CENTER_QUORUM) {
              if (firstConfirmedCenter == null) {
                firstConfirmedCenter = center
              } else {
                this.hasSkipped = true;
                return Math.floor((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2)
              }
            }
          }
          return 0
        };
        this.haveMultiplyConfirmedCenters = function() {
          var confirmedCount = 0;
          var totalModuleSize = 0;
          var max = this.possibleCenters.length;
          for (var i = 0; i < max; i++) {
            var pattern = this.possibleCenters[i];
            if (pattern.Count >= CENTER_QUORUM) {
              confirmedCount++;
              totalModuleSize += pattern.EstimatedModuleSize
            }
          }
          if (confirmedCount < 3) {
            return false
          }
          var average = totalModuleSize / max;
          var totalDeviation = 0;
          for (var i = 0; i < max; i++) {
            pattern = this.possibleCenters[i];
            totalDeviation += Math.abs(pattern.EstimatedModuleSize - average)
          }
          return totalDeviation <= .05 * totalModuleSize
        };
        this.findFinderPattern = function(image) {
          var tryHarder = false;
          this.image = image;
          var maxI = image.height;
          var maxJ = image.width;
          var iSkip = Math.floor(3 * maxI / (4 * MAX_MODULES));
          if (iSkip < MIN_SKIP || tryHarder) {
            iSkip = MIN_SKIP
          }
          var done = false;
          var stateCount = new Array(5);
          for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            var currentState = 0;
            for (var j = 0; j < maxJ; j++) {
              if (image.data[j + i * image.width]) {
                if ((currentState & 1) == 1) {
                  currentState++
                }
                stateCount[currentState]++
              } else {
                if ((currentState & 1) == 0) {
                  if (currentState == 4) {
                    if (this.foundPatternCross(stateCount)) {
                      var confirmed = this.handlePossibleCenter(stateCount, i, j);
                      if (confirmed) {
                        iSkip = 2;
                        if (this.hasSkipped) {
                          done = this.haveMultiplyConfirmedCenters()
                        } else {
                          var rowSkip = this.findRowSkip();
                          if (rowSkip > stateCount[2]) {
                            i += rowSkip - stateCount[2] - iSkip;
                            j = maxJ - 1
                          }
                        }
                      } else {
                        do {
                          j++
                        } while (j < maxJ && !image.data[j + i * image.width]);
                        j--
                      }
                      currentState = 0;
                      stateCount[0] = 0;
                      stateCount[1] = 0;
                      stateCount[2] = 0;
                      stateCount[3] = 0;
                      stateCount[4] = 0
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3
                    }
                  } else {
                    stateCount[++currentState]++
                  }
                } else {
                  stateCount[currentState]++
                }
              }
            }
            if (this.foundPatternCross(stateCount)) {
              var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
              if (confirmed) {
                iSkip = stateCount[0];
                if (this.hasSkipped) {
                  done = haveMultiplyConfirmedCenters()
                }
              }
            }
          }
          var patternInfo = this.selectBestPatterns();
          qrcode.orderBestPatterns(patternInfo);
          return new FinderPatternInfo(patternInfo)
        }
      }

      function AlignmentPattern(posX, posY, estimatedModuleSize) {
        this.x = posX;
        this.y = posY;
        this.count = 1;
        this.estimatedModuleSize = estimatedModuleSize;
        Object.defineProperty(this, "EstimatedModuleSize", {
          get: function() {
            return this.estimatedModuleSize
          }
        });
        Object.defineProperty(this, "Count", {
          get: function() {
            return this.count
          }
        });
        Object.defineProperty(this, "X", {
          get: function() {
            return Math.floor(this.x)
          }
        });
        Object.defineProperty(this, "Y", {
          get: function() {
            return Math.floor(this.y)
          }
        });
        this.incrementCount = function() {
          this.count++
        };
        this.aboutEquals = function(moduleSize, i, j) {
          if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {
            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1 || moduleSizeDiff / this.estimatedModuleSize <= 1
          }
          return false
        }
      }

      function AlignmentPatternFinder(image, startX, startY, width, height, moduleSize, resultPointCallback) {
        this.image = image;
        this.possibleCenters = new Array;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.crossCheckStateCount = new Array(0, 0, 0);
        this.resultPointCallback = resultPointCallback;
        this.centerFromEnd = function(stateCount, end) {
          return end - stateCount[2] - stateCount[1] / 2
        };
        this.foundPatternCross = function(stateCount) {
          var moduleSize = this.moduleSize;
          var maxVariance = moduleSize / 2;
          for (var i = 0; i < 3; i++) {
            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
              return false
            }
          }
          return true
        };
        this.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
          var image = this.image;
          var maxI = image.height;
          var stateCount = this.crossCheckStateCount;
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          var i = startI;
          while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--
          }
          if (i < 0 || stateCount[1] > maxCount) {
            return NaN
          }
          while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--
          }
          if (stateCount[0] > maxCount) {
            return NaN
          }
          i = startI + 1;
          while (i < maxI && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i++
          }
          if (i == maxI || stateCount[1] > maxCount) {
            return NaN
          }
          while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[2] <= maxCount) {
            stateCount[2]++;
            i++
          }
          if (stateCount[2] > maxCount) {
            return NaN
          }
          var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN
          }
          return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN
        };
        this.handlePossibleCenter = function(stateCount, i, j) {
          var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
          var centerJ = this.centerFromEnd(stateCount, j);
          var centerI = this.crossCheckVertical(i, Math.floor(centerJ), 2 * stateCount[1], stateCountTotal);
          if (!isNaN(centerI)) {
            var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
            var max = this.possibleCenters.length;
            for (var index = 0; index < max; index++) {
              var center = this.possibleCenters[index];
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                return new AlignmentPattern(centerJ, centerI, estimatedModuleSize)
              }
            }
            var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
            this.possibleCenters.push(point);
            if (this.resultPointCallback != null) {
              this.resultPointCallback.foundPossibleResultPoint(point)
            }
          }
          return null
        };
        this.find = function() {
          var startX = this.startX;
          var height = this.height;
          var maxJ = startX + width;
          var middleI = startY + (height >> 1);
          var stateCount = new Array(0, 0, 0);
          for (var iGen = 0; iGen < height; iGen++) {
            var i = middleI + ((iGen & 1) == 0 ? iGen + 1 >> 1 : -(iGen + 1 >> 1));
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            var j = startX;
            while (j < maxJ && !image.data[j + image.width * i]) {
              j++
            }
            var currentState = 0;
            while (j < maxJ) {
              if (image.data[j + i * image.width]) {
                if (currentState == 1) {
                  stateCount[currentState]++
                } else {
                  if (currentState == 2) {
                    if (this.foundPatternCross(stateCount)) {
                      var confirmed = this.handlePossibleCenter(stateCount, i, j);
                      if (confirmed != null) {
                        return confirmed
                      }
                    }
                    stateCount[0] = stateCount[2];
                    stateCount[1] = 1;
                    stateCount[2] = 0;
                    currentState = 1
                  } else {
                    stateCount[++currentState]++
                  }
                }
              } else {
                if (currentState == 1) {
                  currentState++
                }
                stateCount[currentState]++
              }
              j++
            }
            if (this.foundPatternCross(stateCount)) {
              var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
              if (confirmed != null) {
                return confirmed
              }
            }
          }
          if (!(this.possibleCenters.length == 0)) {
            return this.possibleCenters[0]
          }
          throw "Couldn't find enough alignment patterns"
        }
      }

      function QRCodeDataBlockReader(blocks, version, numErrorCorrectionCode) {
        this.blockPointer = 0;
        this.bitPointer = 7;
        this.dataLength = 0;
        this.blocks = blocks;
        this.numErrorCorrectionCode = numErrorCorrectionCode;
        if (version <= 9) this.dataLengthMode = 0;
        else if (version >= 10 && version <= 26) this.dataLengthMode = 1;
        else if (version >= 27 && version <= 40) this.dataLengthMode = 2;
        this.getNextBits = function(numBits) {
          var bits = 0;
          if (numBits < this.bitPointer + 1) {
            var mask = 0;
            for (var i = 0; i < numBits; i++) {
              mask += 1 << i
            }
            mask <<= this.bitPointer - numBits + 1;
            bits = (this.blocks[this.blockPointer] & mask) >> this.bitPointer - numBits + 1;
            this.bitPointer -= numBits;
            return bits
          } else if (numBits < this.bitPointer + 1 + 8) {
            var mask1 = 0;
            for (var i = 0; i < this.bitPointer + 1; i++) {
              mask1 += 1 << i
            }
            bits = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);
            this.blockPointer++;
            bits += this.blocks[this.blockPointer] >> 8 - (numBits - (this.bitPointer + 1));
            this.bitPointer = this.bitPointer - numBits % 8;
            if (this.bitPointer < 0) {
              this.bitPointer = 8 + this.bitPointer
            }
            return bits
          } else if (numBits < this.bitPointer + 1 + 16) {
            var mask1 = 0;
            var mask3 = 0;
            for (var i = 0; i < this.bitPointer + 1; i++) {
              mask1 += 1 << i
            }
            var bitsFirstBlock = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);
            this.blockPointer++;
            var bitsSecondBlock = this.blocks[this.blockPointer] << numBits - (this.bitPointer + 1 + 8);
            this.blockPointer++;
            for (var i = 0; i < numBits - (this.bitPointer + 1 + 8); i++) {
              mask3 += 1 << i
            }
            mask3 <<= 8 - (numBits - (this.bitPointer + 1 + 8));
            var bitsThirdBlock = (this.blocks[this.blockPointer] & mask3) >> 8 - (numBits - (this.bitPointer + 1 + 8));
            bits = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock;
            this.bitPointer = this.bitPointer - (numBits - 8) % 8;
            if (this.bitPointer < 0) {
              this.bitPointer = 8 + this.bitPointer
            }
            return bits
          } else {
            return 0
          }
        };
        this.NextMode = function() {
          if (this.blockPointer > this.blocks.length - this.numErrorCorrectionCode - 2) return 0;
          else return this.getNextBits(4)
        };
        this.getDataLength = function(modeIndicator) {
          var index = 0;
          while (true) {
            if (modeIndicator >> index == 1) break;
            index++
          }
          return this.getNextBits(qrcode.sizeOfDataLengthInfo[this.dataLengthMode][index])
        };
        this.getRomanAndFigureString = function(dataLength) {
          var length = dataLength;
          var intData = 0;
          var strData = "";
          var tableRomanAndFigure = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":");
          do {
            if (length > 1) {
              intData = this.getNextBits(11);
              var firstLetter = Math.floor(intData / 45);
              var secondLetter = intData % 45;
              strData += tableRomanAndFigure[firstLetter];
              strData += tableRomanAndFigure[secondLetter];
              length -= 2
            } else if (length == 1) {
              intData = this.getNextBits(6);
              strData += tableRomanAndFigure[intData];
              length -= 1
            }
          } while (length > 0);
          return strData
        };
        this.getFigureString = function(dataLength) {
          var length = dataLength;
          var intData = 0;
          var strData = "";
          do {
            if (length >= 3) {
              intData = this.getNextBits(10);
              if (intData < 100) strData += "0";
              if (intData < 10) strData += "0";
              length -= 3
            } else if (length == 2) {
              intData = this.getNextBits(7);
              if (intData < 10) strData += "0";
              length -= 2
            } else if (length == 1) {
              intData = this.getNextBits(4);
              length -= 1
            }
            strData += intData
          } while (length > 0);
          return strData
        };
        this.get8bitByteArray = function(dataLength) {
          var length = dataLength;
          var intData = 0;
          var output = new Array;
          do {
            intData = this.getNextBits(8);
            output.push(intData);
            length--
          } while (length > 0);
          return output
        };
        this.getKanjiString = function(dataLength) {
          var length = dataLength;
          var intData = 0;
          var unicodeString = "";
          do {
            intData = getNextBits(13);
            var lowerByte = intData % 192;
            var higherByte = intData / 192;
            var tempWord = (higherByte << 8) + lowerByte;
            var shiftjisWord = 0;
            if (tempWord + 33088 <= 40956) {
              shiftjisWord = tempWord + 33088
            } else {
              shiftjisWord = tempWord + 49472
            }
            unicodeString += String.fromCharCode(shiftjisWord);
            length--
          } while (length > 0);
          return unicodeString
        };
        Object.defineProperty(this, "DataByte", {
          get: function() {
            var output = new Array;
            var MODE_NUMBER = 1;
            var MODE_ROMAN_AND_NUMBER = 2;
            var MODE_8BIT_BYTE = 4;
            var MODE_KANJI = 8;
            do {
              var mode = this.NextMode();
              if (mode == 0) {
                if (output.length > 0) break;
                else throw "Empty data block"
              }
              if (mode != MODE_NUMBER && mode != MODE_ROMAN_AND_NUMBER && mode != MODE_8BIT_BYTE && mode != MODE_KANJI) {
                throw "Invalid mode: " + mode + " in (block:" + this.blockPointer + " bit:" + this.bitPointer + ")"
              }
              dataLength = this.getDataLength(mode);
              if (dataLength < 1) throw "Invalid data length: " + dataLength;
              switch (mode) {
                case MODE_NUMBER:
                  var temp_str = this.getFigureString(dataLength);
                  var ta = new Array(temp_str.length);
                  for (var j = 0; j < temp_str.length; j++) ta[j] = temp_str.charCodeAt(j);
                  output.push(ta);
                  break;
                case MODE_ROMAN_AND_NUMBER:
                  var temp_str = this.getRomanAndFigureString(dataLength);
                  var ta = new Array(temp_str.length);
                  for (var j = 0; j < temp_str.length; j++) ta[j] = temp_str.charCodeAt(j);
                  output.push(ta);
                  break;
                case MODE_8BIT_BYTE:
                  var temp_sbyteArray3 = this.get8bitByteArray(dataLength);
                  output.push(temp_sbyteArray3);
                  break;
                case MODE_KANJI:
                  var temp_str = this.getKanjiString(dataLength);
                  output.push(temp_str);
                  break
              }
            } while (true);
            return output
          }
        })
      }
      module.exports = QrCode
    }, {}],
    97: [function(require, module, exports) {
      function DOMParser(options) {
        this.options = options || {
          locator: {}
        }
      }
      DOMParser.prototype.parseFromString = function(source, mimeType) {
        var options = this.options;
        var sax = new XMLReader;
        var domBuilder = options.domBuilder || new DOMHandler;
        var errorHandler = options.errorHandler;
        var locator = options.locator;
        var defaultNSMap = options.xmlns || {};
        var entityMap = {
          lt: "<",
          gt: ">",
          amp: "&",
          quot: '"',
          apos: "'"
        };
        if (locator) {
          domBuilder.setDocumentLocator(locator)
        }
        sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
        sax.domBuilder = options.domBuilder || domBuilder;
        if (/\/x?html?$/.test(mimeType)) {
          entityMap.nbsp = " ";
          entityMap.copy = "";
          defaultNSMap[""] = "http://www.w3.org/1999/xhtml"
        }
        defaultNSMap.xml = defaultNSMap.xml || "http://www.w3.org/XML/1998/namespace";
        if (source) {
          sax.parse(source, defaultNSMap, entityMap)
        } else {
          sax.errorHandler.error("invalid document source")
        }
        return domBuilder.document
      };

      function buildErrorHandler(errorImpl, domBuilder, locator) {
        if (!errorImpl) {
          if (domBuilder instanceof DOMHandler) {
            return domBuilder
          }
          errorImpl = domBuilder
        }
        var errorHandler = {};
        var isCallback = errorImpl instanceof Function;
        locator = locator || {};

        function build(key) {
          var fn = errorImpl[key];
          if (!fn && isCallback) {
            fn = errorImpl.length == 2 ? function(msg) {
              errorImpl(key, msg)
            } : errorImpl
          }
          errorHandler[key] = fn && function(msg) {
            fn("[xmldom " + key + "]	" + msg + _locator(locator))
          } || function() {}
        }
        build("warning");
        build("error");
        build("fatalError");
        return errorHandler
      }

      function DOMHandler() {
        this.cdata = false
      }

      function position(locator, node) {
        node.lineNumber = locator.lineNumber;
        node.columnNumber = locator.columnNumber
      }
      DOMHandler.prototype = {
        startDocument: function() {
          this.document = (new DOMImplementation).createDocument(null, null, null);
          if (this.locator) {
            this.document.documentURI = this.locator.systemId
          }
        },
        startElement: function(namespaceURI, localName, qName, attrs) {
          var doc = this.document;
          var el = doc.createElementNS(namespaceURI, qName || localName);
          var len = attrs.length;
          appendElement(this, el);
          this.currentElement = el;
          this.locator && position(this.locator, el);
          for (var i = 0; i < len; i++) {
            var namespaceURI = attrs.getURI(i);
            var value = attrs.getValue(i);
            var qName = attrs.getQName(i);
            var attr = doc.createAttributeNS(namespaceURI, qName);
            if (attr.getOffset) {
              position(attr.getOffset(1), attr)
            }
            attr.value = attr.nodeValue = value;
            el.setAttributeNode(attr)
          }
        },
        endElement: function(namespaceURI, localName, qName) {
          var current = this.currentElement;
          var tagName = current.tagName;
          this.currentElement = current.parentNode
        },
        startPrefixMapping: function(prefix, uri) {},
        endPrefixMapping: function(prefix) {},
        processingInstruction: function(target, data) {
          var ins = this.document.createProcessingInstruction(target, data);
          this.locator && position(this.locator, ins);
          appendElement(this, ins)
        },
        ignorableWhitespace: function(ch, start, length) {},
        characters: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          if (this.currentElement && chars) {
            if (this.cdata) {
              var charNode = this.document.createCDATASection(chars);
              this.currentElement.appendChild(charNode)
            } else {
              var charNode = this.document.createTextNode(chars);
              this.currentElement.appendChild(charNode)
            }
            this.locator && position(this.locator, charNode)
          }
        },
        skippedEntity: function(name) {},
        endDocument: function() {
          this.document.normalize()
        },
        setDocumentLocator: function(locator) {
          if (this.locator = locator) {
            locator.lineNumber = 0
          }
        },
        comment: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          var comm = this.document.createComment(chars);
          this.locator && position(this.locator, comm);
          appendElement(this, comm)
        },
        startCDATA: function() {
          this.cdata = true
        },
        endCDATA: function() {
          this.cdata = false
        },
        startDTD: function(name, publicId, systemId) {
          var impl = this.document.implementation;
          if (impl && impl.createDocumentType) {
            var dt = impl.createDocumentType(name, publicId, systemId);
            this.locator && position(this.locator, dt);
            appendElement(this, dt)
          }
        },
        warning: function(error) {
          console.warn("[xmldom warning]	" + error, _locator(this.locator))
        },
        error: function(error) {
          console.error("[xmldom error]	" + error, _locator(this.locator))
        },
        fatalError: function(error) {
          console.error("[xmldom fatalError]	" + error, _locator(this.locator));
          throw error
        }
      };

      function _locator(l) {
        if (l) {
          return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]"
        }
      }

      function _toString(chars, start, length) {
        if (typeof chars == "string") {
          return chars.substr(start, length)
        } else {
          if (chars.length >= start + length || start) {
            return new java.lang.String(chars, start, length) + ""
          }
          return chars
        }
      }
      "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
        DOMHandler.prototype[key] = function() {
          return null
        }
      });

      function appendElement(hander, node) {
        if (!hander.currentElement) {
          hander.document.appendChild(node)
        } else {
          hander.currentElement.appendChild(node)
        }
      }
      if (typeof require == "function") {
        var XMLReader = require("./sax").XMLReader;
        var DOMImplementation = exports.DOMImplementation = require("./dom").DOMImplementation;
        exports.XMLSerializer = require("./dom").XMLSerializer;
        exports.DOMParser = DOMParser
      }
    }, {
      "./dom": 98,
      "./sax": 99
    }],
    98: [function(require, module, exports) {
      function copy(src, dest) {
        for (var p in src) {
          dest[p] = src[p]
        }
      }

      function _extends(Class, Super) {
        var pt = Class.prototype;
        if (Object.create) {
          var ppt = Object.create(Super.prototype);
          pt.__proto__ = ppt
        }
        if (!(pt instanceof Super)) {
          function t() {}
          t.prototype = Super.prototype;
          t = new t;
          copy(pt, t);
          Class.prototype = pt = t
        }
        if (pt.constructor != Class) {
          if (typeof Class != "function") {
            console.error("unknow Class:" + Class)
          }
          pt.constructor = Class
        }
      }
      var htmlns = "http://www.w3.org/1999/xhtml";
      var NodeType = {};
      var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
      var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
      var TEXT_NODE = NodeType.TEXT_NODE = 3;
      var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
      var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
      var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
      var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
      var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
      var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
      var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
      var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
      var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
      var ExceptionCode = {};
      var ExceptionMessage = {};
      var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
      var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
      var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
      var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
      var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
      var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
      var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
      var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
      var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
      var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
      var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
      var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
      var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
      var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
      var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);

      function DOMException(code, message) {
        if (message instanceof Error) {
          var error = message
        } else {
          error = this;
          Error.call(this, ExceptionMessage[code]);
          this.message = ExceptionMessage[code];
          if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException)
        }
        error.code = code;
        if (message) this.message = this.message + ": " + message;
        return error
      }
      DOMException.prototype = Error.prototype;
      copy(ExceptionCode, DOMException);

      function NodeList() {}
      NodeList.prototype = {
        length: 0,
        item: function(index) {
          return this[index] || null
        },
        toString: function() {
          for (var buf = [], i = 0; i < this.length; i++) {
            serializeToString(this[i], buf)
          }
          return buf.join("")
        }
      };

      function LiveNodeList(node, refresh) {
        this._node = node;
        this._refresh = refresh;
        _updateLiveList(this)
      }

      function _updateLiveList(list) {
        var inc = list._node._inc || list._node.ownerDocument._inc;
        if (list._inc != inc) {
          var ls = list._refresh(list._node);
          __set__(list, "length", ls.length);
          copy(ls, list);
          list._inc = inc
        }
      }
      LiveNodeList.prototype.item = function(i) {
        _updateLiveList(this);
        return this[i]
      };
      _extends(LiveNodeList, NodeList);

      function NamedNodeMap() {}

      function _findNodeIndex(list, node) {
        var i = list.length;
        while (i--) {
          if (list[i] === node) {
            return i
          }
        }
      }

      function _addNamedNode(el, list, newAttr, oldAttr) {
        if (oldAttr) {
          list[_findNodeIndex(list, oldAttr)] = newAttr
        } else {
          list[list.length++] = newAttr
        }
        if (el) {
          newAttr.ownerElement = el;
          var doc = el.ownerDocument;
          if (doc) {
            oldAttr && _onRemoveAttribute(doc, el, oldAttr);
            _onAddAttribute(doc, el, newAttr)
          }
        }
      }

      function _removeNamedNode(el, list, attr) {
        var i = _findNodeIndex(list, attr);
        if (i >= 0) {
          var lastIndex = list.length - 1;
          while (i < lastIndex) {
            list[i] = list[++i]
          }
          list.length = lastIndex;
          if (el) {
            var doc = el.ownerDocument;
            if (doc) {
              _onRemoveAttribute(doc, el, attr);
              attr.ownerElement = null
            }
          }
        } else {
          throw DOMException(NOT_FOUND_ERR, new Error)
        }
      }
      NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(key) {
          var i = this.length;
          while (i--) {
            var attr = this[i];
            if (attr.nodeName == key) {
              return attr
            }
          }
        },
        setNamedItem: function(attr) {
          var el = attr.ownerElement;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR)
          }
          var oldAttr = this.getNamedItem(attr.nodeName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr
        },
        setNamedItemNS: function(attr) {
          var el = attr.ownerElement,
            oldAttr;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR)
          }
          oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        removeNamedItem: function(key) {
          var attr = this.getNamedItem(key);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr
        },
        removeNamedItemNS: function(namespaceURI, localName) {
          var attr = this.getNamedItemNS(namespaceURI, localName);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr
        },
        getNamedItemNS: function(namespaceURI, localName) {
          var i = this.length;
          while (i--) {
            var node = this[i];
            if (node.localName == localName && node.namespaceURI == namespaceURI) {
              return node
            }
          }
          return null
        }
      };

      function DOMImplementation(features) {
        this._features = {};
        if (features) {
          for (var feature in features) {
            this._features = features[feature]
          }
        }
      }
      DOMImplementation.prototype = {
        hasFeature: function(feature, version) {
          var versions = this._features[feature.toLowerCase()];
          if (versions && (!version || version in versions)) {
            return true
          } else {
            return false
          }
        },
        createDocument: function(namespaceURI, qualifiedName, doctype) {
          var doc = new Document;
          doc.implementation = this;
          doc.childNodes = new NodeList;
          doc.doctype = doctype;
          if (doctype) {
            doc.appendChild(doctype)
          }
          if (qualifiedName) {
            var root = doc.createElementNS(namespaceURI, qualifiedName);
            doc.appendChild(root)
          }
          return doc
        },
        createDocumentType: function(qualifiedName, publicId, systemId) {
          var node = new DocumentType;
          node.name = qualifiedName;
          node.nodeName = qualifiedName;
          node.publicId = publicId;
          node.systemId = systemId;
          return node
        }
      };

      function Node() {}
      Node.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        insertBefore: function(newChild, refChild) {
          return _insertBefore(this, newChild, refChild)
        },
        replaceChild: function(newChild, oldChild) {
          this.insertBefore(newChild, oldChild);
          if (oldChild) {
            this.removeChild(oldChild)
          }
        },
        removeChild: function(oldChild) {
          return _removeChild(this, oldChild)
        },
        appendChild: function(newChild) {
          return this.insertBefore(newChild, null)
        },
        hasChildNodes: function() {
          return this.firstChild != null
        },
        cloneNode: function(deep) {
          return cloneNode(this.ownerDocument || this, this, deep)
        },
        normalize: function() {
          var child = this.firstChild;
          while (child) {
            var next = child.nextSibling;
            if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
              this.removeChild(next);
              child.appendData(next.data)
            } else {
              child.normalize();
              child = next
            }
          }
        },
        isSupported: function(feature, version) {
          return this.ownerDocument.implementation.hasFeature(feature, version)
        },
        hasAttributes: function() {
          return this.attributes.length > 0
        },
        lookupPrefix: function(namespaceURI) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              for (var n in map) {
                if (map[n] == namespaceURI) {
                  return n
                }
              }
            }
            el = el.nodeType == 2 ? el.ownerDocument : el.parentNode
          }
          return null
        },
        lookupNamespaceURI: function(prefix) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              if (prefix in map) {
                return map[prefix]
              }
            }
            el = el.nodeType == 2 ? el.ownerDocument : el.parentNode
          }
          return null
        },
        isDefaultNamespace: function(namespaceURI) {
          var prefix = this.lookupPrefix(namespaceURI);
          return prefix == null
        }
      };

      function _xmlEncoder(c) {
        return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";"
      }
      copy(NodeType, Node);
      copy(NodeType, Node.prototype);

      function _visitNode(node, callback) {
        if (callback(node)) {
          return true
        }
        if (node = node.firstChild) {
          do {
            if (_visitNode(node, callback)) {
              return true
            }
          } while (node = node.nextSibling)
        }
      }

      function Document() {}

      function _onAddAttribute(doc, el, newAttr) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns == "http://www.w3.org/2000/xmlns/") {
          el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value
        }
      }

      function _onRemoveAttribute(doc, el, newAttr, remove) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns == "http://www.w3.org/2000/xmlns/") {
          delete el._nsMap[newAttr.prefix ? newAttr.localName : ""]
        }
      }

      function _onUpdateChild(doc, el, newChild) {
        if (doc && doc._inc) {
          doc._inc++;
          var cs = el.childNodes;
          if (newChild) {
            cs[cs.length++] = newChild
          } else {
            var child = el.firstChild;
            var i = 0;
            while (child) {
              cs[i++] = child;
              child = child.nextSibling
            }
            cs.length = i
          }
        }
      }

      function _removeChild(parentNode, child) {
        var previous = child.previousSibling;
        var next = child.nextSibling;
        if (previous) {
          previous.nextSibling = next
        } else {
          parentNode.firstChild = next
        }
        if (next) {
          next.previousSibling = previous
        } else {
          parentNode.lastChild = previous
        }
        _onUpdateChild(parentNode.ownerDocument, parentNode);
        return child
      }

      function _insertBefore(parentNode, newChild, nextChild) {
        var cp = newChild.parentNode;
        if (cp) {
          cp.removeChild(newChild)
        }
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var newFirst = newChild.firstChild;
          if (newFirst == null) {
            return newChild
          }
          var newLast = newChild.lastChild
        } else {
          newFirst = newLast = newChild
        }
        var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
        newFirst.previousSibling = pre;
        newLast.nextSibling = nextChild;
        if (pre) {
          pre.nextSibling = newFirst
        } else {
          parentNode.firstChild = newFirst
        }
        if (nextChild == null) {
          parentNode.lastChild = newLast
        } else {
          nextChild.previousSibling = newLast
        }
        do {
          newFirst.parentNode = parentNode
        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
        _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          newChild.firstChild = newChild.lastChild = null
        }
        return newChild
      }

      function _appendSingleChild(parentNode, newChild) {
        var cp = newChild.parentNode;
        if (cp) {
          var pre = parentNode.lastChild;
          cp.removeChild(newChild);
          var pre = parentNode.lastChild
        }
        var pre = parentNode.lastChild;
        newChild.parentNode = parentNode;
        newChild.previousSibling = pre;
        newChild.nextSibling = null;
        if (pre) {
          pre.nextSibling = newChild
        } else {
          parentNode.firstChild = newChild
        }
        parentNode.lastChild = newChild;
        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
        return newChild
      }
      Document.prototype = {
        nodeName: "#document",
        nodeType: DOCUMENT_NODE,
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(newChild, refChild) {
          if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
              var next = child.nextSibling;
              this.insertBefore(child, refChild);
              child = next
            }
            return newChild
          }
          if (this.documentElement == null && newChild.nodeType == 1) {
            this.documentElement = newChild
          }
          return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild
        },
        removeChild: function(oldChild) {
          if (this.documentElement == oldChild) {
            this.documentElement = null
          }
          return _removeChild(this, oldChild)
        },
        importNode: function(importedNode, deep) {
          return importNode(this, importedNode, deep)
        },
        getElementById: function(id) {
          var rtv = null;
          _visitNode(this.documentElement, function(node) {
            if (node.nodeType == 1) {
              if (node.getAttribute("id") == id) {
                rtv = node;
                return true
              }
            }
          });
          return rtv
        },
        createElement: function(tagName) {
          var node = new Element;
          node.ownerDocument = this;
          node.nodeName = tagName;
          node.tagName = tagName;
          node.childNodes = new NodeList;
          var attrs = node.attributes = new NamedNodeMap;
          attrs._ownerElement = node;
          return node
        },
        createDocumentFragment: function() {
          var node = new DocumentFragment;
          node.ownerDocument = this;
          node.childNodes = new NodeList;
          return node
        },
        createTextNode: function(data) {
          var node = new Text;
          node.ownerDocument = this;
          node.appendData(data);
          return node
        },
        createComment: function(data) {
          var node = new Comment;
          node.ownerDocument = this;
          node.appendData(data);
          return node
        },
        createCDATASection: function(data) {
          var node = new CDATASection;
          node.ownerDocument = this;
          node.appendData(data);
          return node
        },
        createProcessingInstruction: function(target, data) {
          var node = new ProcessingInstruction;
          node.ownerDocument = this;
          node.tagName = node.target = target;
          node.nodeValue = node.data = data;
          return node
        },
        createAttribute: function(name) {
          var node = new Attr;
          node.ownerDocument = this;
          node.name = name;
          node.nodeName = name;
          node.localName = name;
          node.specified = true;
          return node
        },
        createEntityReference: function(name) {
          var node = new EntityReference;
          node.ownerDocument = this;
          node.nodeName = name;
          return node
        },
        createElementNS: function(namespaceURI, qualifiedName) {
          var node = new Element;
          var pl = qualifiedName.split(":");
          var attrs = node.attributes = new NamedNodeMap;
          node.childNodes = new NodeList;
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.tagName = qualifiedName;
          node.namespaceURI = namespaceURI;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1]
          } else {
            node.localName = qualifiedName
          }
          attrs._ownerElement = node;
          return node
        },
        createAttributeNS: function(namespaceURI, qualifiedName) {
          var node = new Attr;
          var pl = qualifiedName.split(":");
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.name = qualifiedName;
          node.namespaceURI = namespaceURI;
          node.specified = true;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1]
          } else {
            node.localName = qualifiedName
          }
          return node
        }
      };
      _extends(Document, Node);

      function Element() {
        this._nsMap = {}
      }
      Element.prototype = {
        nodeType: ELEMENT_NODE,
        hasAttribute: function(name) {
          return this.getAttributeNode(name) != null
        },
        getAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          return attr && attr.value || ""
        },
        getAttributeNode: function(name) {
          return this.attributes.getNamedItem(name)
        },
        setAttribute: function(name, value) {
          var attr = this.ownerDocument.createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr)
        },
        removeAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          attr && this.removeAttributeNode(attr)
        },
        appendChild: function(newChild) {
          if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
            return this.insertBefore(newChild, null)
          } else {
            return _appendSingleChild(this, newChild)
          }
        },
        setAttributeNode: function(newAttr) {
          return this.attributes.setNamedItem(newAttr)
        },
        setAttributeNodeNS: function(newAttr) {
          return this.attributes.setNamedItemNS(newAttr)
        },
        removeAttributeNode: function(oldAttr) {
          return this.attributes.removeNamedItem(oldAttr.nodeName)
        },
        removeAttributeNS: function(namespaceURI, localName) {
          var old = this.getAttributeNodeNS(namespaceURI, localName);
          old && this.removeAttributeNode(old)
        },
        hasAttributeNS: function(namespaceURI, localName) {
          return this.getAttributeNodeNS(namespaceURI, localName) != null
        },
        getAttributeNS: function(namespaceURI, localName) {
          var attr = this.getAttributeNodeNS(namespaceURI, localName);
          return attr && attr.value || ""
        },
        setAttributeNS: function(namespaceURI, qualifiedName, value) {
          var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr)
        },
        getAttributeNodeNS: function(namespaceURI, localName) {
          return this.attributes.getNamedItemNS(namespaceURI, localName)
        },
        getElementsByTagName: function(tagName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                ls.push(node)
              }
            });
            return ls
          })
        },
        getElementsByTagNameNS: function(namespaceURI, localName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                ls.push(node)
              }
            });
            return ls
          })
        }
      };
      Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
      Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
      _extends(Element, Node);

      function Attr() {}
      Attr.prototype.nodeType = ATTRIBUTE_NODE;
      _extends(Attr, Node);

      function CharacterData() {}
      CharacterData.prototype = {
        data: "",
        substringData: function(offset, count) {
          return this.data.substring(offset, offset + count)
        },
        appendData: function(text) {
          text = this.data + text;
          this.nodeValue = this.data = text;
          this.length = text.length
        },
        insertData: function(offset, text) {
          this.replaceData(offset, 0, text)
        },
        appendChild: function(newChild) {
          throw new Error(ExceptionMessage[3]);
          return Node.prototype.appendChild.apply(this, arguments)
        },
        deleteData: function(offset, count) {
          this.replaceData(offset, count, "")
        },
        replaceData: function(offset, count, text) {
          var start = this.data.substring(0, offset);
          var end = this.data.substring(offset + count);
          text = start + text + end;
          this.nodeValue = this.data = text;
          this.length = text.length
        }
      };
      _extends(CharacterData, Node);

      function Text() {}
      Text.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE,
        splitText: function(offset) {
          var text = this.data;
          var newText = text.substring(offset);
          text = text.substring(0, offset);
          this.data = this.nodeValue = text;
          this.length = text.length;
          var newNode = this.ownerDocument.createTextNode(newText);
          if (this.parentNode) {
            this.parentNode.insertBefore(newNode, this.nextSibling)
          }
          return newNode
        }
      };
      _extends(Text, CharacterData);

      function Comment() {}
      Comment.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
      };
      _extends(Comment, CharacterData);

      function CDATASection() {}
      CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
      };
      _extends(CDATASection, CharacterData);

      function DocumentType() {}
      DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
      _extends(DocumentType, Node);

      function Notation() {}
      Notation.prototype.nodeType = NOTATION_NODE;
      _extends(Notation, Node);

      function Entity() {}
      Entity.prototype.nodeType = ENTITY_NODE;
      _extends(Entity, Node);

      function EntityReference() {}
      EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
      _extends(EntityReference, Node);

      function DocumentFragment() {}
      DocumentFragment.prototype.nodeName = "#document-fragment";
      DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
      _extends(DocumentFragment, Node);

      function ProcessingInstruction() {}
      ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
      _extends(ProcessingInstruction, Node);

      function XMLSerializer() {}
      XMLSerializer.prototype.serializeToString = function(node, attributeSorter) {
        return node.toString(attributeSorter)
      };
      Node.prototype.toString = function(attributeSorter) {
        var buf = [];
        serializeToString(this, buf, attributeSorter);
        return buf.join("")
      };

      function serializeToString(node, buf, attributeSorter, isHTML) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var len = attrs.length;
            var child = node.firstChild;
            var nodeName = node.tagName;
            isHTML = htmlns === node.namespaceURI || isHTML;
            buf.push("<", nodeName);
            if (attributeSorter) {
              buf.sort.apply(attrs, attributeSorter)
            }
            for (var i = 0; i < len; i++) {
              serializeToString(attrs.item(i), buf, attributeSorter, isHTML)
            }
            if (child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)) {
              buf.push(">");
              if (isHTML && /^script$/i.test(nodeName)) {
                if (child) {
                  buf.push(child.data)
                }
              } else {
                while (child) {
                  serializeToString(child, buf, attributeSorter, isHTML);
                  child = child.nextSibling
                }
              }
              buf.push("</", nodeName, ">")
            } else {
              buf.push("/>")
            }
            return;
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var child = node.firstChild;
            while (child) {
              serializeToString(child, buf, attributeSorter, isHTML);
              child = child.nextSibling
            }
            return;
          case ATTRIBUTE_NODE:
            return buf.push(" ", node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
          case TEXT_NODE:
            return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));
          case CDATA_SECTION_NODE:
            return buf.push("<![CDATA[", node.data, "]]>");
          case COMMENT_NODE:
            return buf.push("<!--", node.data, "-->");
          case DOCUMENT_TYPE_NODE:
            var pubid = node.publicId;
            var sysid = node.systemId;
            buf.push("<!DOCTYPE ", node.name);
            if (pubid) {
              buf.push(' PUBLIC "', pubid);
              if (sysid && sysid != ".") {
                buf.push('" "', sysid)
              }
              buf.push('">')
            } else if (sysid && sysid != ".") {
              buf.push(' SYSTEM "', sysid, '">')
            } else {
              var sub = node.internalSubset;
              if (sub) {
                buf.push(" [", sub, "]")
              }
              buf.push(">")
            }
            return;
          case PROCESSING_INSTRUCTION_NODE:
            return buf.push("<?", node.target, " ", node.data, "?>");
          case ENTITY_REFERENCE_NODE:
            return buf.push("&", node.nodeName, ";");
          default:
            buf.push("??", node.nodeName)
        }
      }

      function importNode(doc, node, deep) {
        var node2;
        switch (node.nodeType) {
          case ELEMENT_NODE:
            node2 = node.cloneNode(false);
            node2.ownerDocument = doc;
          case DOCUMENT_FRAGMENT_NODE:
            break;
          case ATTRIBUTE_NODE:
            deep = true;
            break
        }
        if (!node2) {
          node2 = node.cloneNode(false)
        }
        node2.ownerDocument = doc;
        node2.parentNode = null;
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(importNode(doc, child, deep));
            child = child.nextSibling
          }
        }
        return node2
      }

      function cloneNode(doc, node, deep) {
        var node2 = new node.constructor;
        for (var n in node) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v
            }
          }
        }
        if (node.childNodes) {
          node2.childNodes = new NodeList
        }
        node2.ownerDocument = doc;
        switch (node2.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var attrs2 = node2.attributes = new NamedNodeMap;
            var len = attrs.length;
            attrs2._ownerElement = node2;
            for (var i = 0; i < len; i++) {
              node2.setAttributeNode(cloneNode(doc, attrs.item(i), true))
            }
            break;
          case ATTRIBUTE_NODE:
            deep = true
        }
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(cloneNode(doc, child, deep));
            child = child.nextSibling
          }
        }
        return node2
      }

      function __set__(object, key, value) {
        object[key] = value
      }
      try {
        if (Object.defineProperty) {
          Object.defineProperty(LiveNodeList.prototype, "length", {
            get: function() {
              _updateLiveList(this);
              return this.$$length
            }
          });
          Object.defineProperty(Node.prototype, "textContent", {
            get: function() {
              return getTextContent(this)
            },
            set: function(data) {
              switch (this.nodeType) {
                case 1:
                case 11:
                  while (this.firstChild) {
                    this.removeChild(this.firstChild)
                  }
                  if (data || String(data)) {
                    this.appendChild(this.ownerDocument.createTextNode(data))
                  }
                  break;
                default:
                  this.data = data;
                  this.value = value;
                  this.nodeValue = data
              }
            }
          });

          function getTextContent(node) {
            switch (node.nodeType) {
              case 1:
              case 11:
                var buf = [];
                node = node.firstChild;
                while (node) {
                  if (node.nodeType !== 7 && node.nodeType !== 8) {
                    buf.push(getTextContent(node))
                  }
                  node = node.nextSibling
                }
                return buf.join("");
              default:
                return node.nodeValue
            }
          }
          __set__ = function(object, key, value) {
            object["$$" + key] = value
          }
        }
      } catch (e) {}
      if (typeof require == "function") {
        exports.DOMImplementation = DOMImplementation;
        exports.XMLSerializer = XMLSerializer
      }
    }, {}],
    99: [function(require, module, exports) {
      var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "-\\u203F-]");
      var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
      var S_TAG = 0;
      var S_ATTR = 1;
      var S_ATTR_S = 2;
      var S_EQ = 3;
      var S_V = 4;
      var S_E = 5;
      var S_S = 6;
      var S_C = 7;

      function XMLReader() {}
      XMLReader.prototype = {
        parse: function(source, defaultNSMap, entityMap) {
          var domBuilder = this.domBuilder;
          domBuilder.startDocument();
          _copy(defaultNSMap, defaultNSMap = {});
          parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
          domBuilder.endDocument()
        }
      };

      function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
        function fixedFromCharCode(code) {
          if (code > 65535) {
            code -= 65536;
            var surrogate1 = 55296 + (code >> 10),
              surrogate2 = 56320 + (code & 1023);
            return String.fromCharCode(surrogate1, surrogate2)
          } else {
            return String.fromCharCode(code)
          }
        }

        function entityReplacer(a) {
          var k = a.slice(1, -1);
          if (k in entityMap) {
            return entityMap[k]
          } else if (k.charAt(0) === "#") {
            return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")))
          } else {
            errorHandler.error("entity not found:" + a);
            return a
          }
        }

        function appendText(end) {
          if (end > start) {
            var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
            locator && position(start);
            domBuilder.characters(xt, 0, end - start);
            start = end
          }
        }

        function position(p, m) {
          while (p >= lineEnd && (m = linePattern.exec(source))) {
            lineStart = m.index;
            lineEnd = lineStart + m[0].length;
            locator.lineNumber++
          }
          locator.columnNumber = p - lineStart + 1
        }
        var lineStart = 0;
        var lineEnd = 0;
        var linePattern = /.+(?:\r\n?|\n)|.*$/g;
        var locator = domBuilder.locator;
        var parseStack = [{
          currentNSMap: defaultNSMapCopy
        }];
        var closeMap = {};
        var start = 0;
        while (true) {
          try {
            var tagStart = source.indexOf("<", start);
            if (tagStart < 0) {
              if (!source.substr(start).match(/^\s*$/)) {
                var doc = domBuilder.document;
                var text = doc.createTextNode(source.substr(start));
                doc.appendChild(text);
                domBuilder.currentElement = text
              }
              return
            }
            if (tagStart > start) {
              appendText(tagStart)
            }
            switch (source.charAt(tagStart + 1)) {
              case "/":
                var end = source.indexOf(">", tagStart + 3);
                var tagName = source.substring(tagStart + 2, end);
                var config = parseStack.pop();
                var localNSMap = config.localNSMap;
                if (config.tagName != tagName) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName)
                }
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    domBuilder.endPrefixMapping(prefix)
                  }
                }
                end++;
                break;
              case "?":
                locator && position(tagStart);
                end = parseInstruction(source, tagStart, domBuilder);
                break;
              case "!":
                locator && position(tagStart);
                end = parseDCC(source, tagStart, domBuilder, errorHandler);
                break;
              default:
                locator && position(tagStart);
                var el = new ElementAttributes;
                var end = parseElementStartPart(source, tagStart, el, entityReplacer, errorHandler);
                var len = el.length;
                if (locator) {
                  if (len) {
                    for (var i = 0; i < len; i++) {
                      var a = el[i];
                      position(a.offset);
                      a.offset = copyLocator(locator, {})
                    }
                  }
                  position(end)
                }
                if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                  el.closed = true;
                  if (!entityMap.nbsp) {
                    errorHandler.warning("unclosed xml attribute")
                  }
                }
                appendElement(el, domBuilder, parseStack);
                if (el.uri === "http://www.w3.org/1999/xhtml" && !el.closed) {
                  end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder)
                } else {
                  end++
                }
            }
          } catch (e) {
            errorHandler.error("element parse error: " + e);
            end = -1
          }
          if (end > start) {
            start = end
          } else {
            appendText(Math.max(tagStart, start) + 1)
          }
        }
      }

      function copyLocator(f, t) {
        t.lineNumber = f.lineNumber;
        t.columnNumber = f.columnNumber;
        return t
      }

      function parseElementStartPart(source, start, el, entityReplacer, errorHandler) {
        var attrName;
        var value;
        var p = ++start;
        var s = S_TAG;
        while (true) {
          var c = source.charAt(p);
          switch (c) {
            case "=":
              if (s === S_ATTR) {
                attrName = source.slice(start, p);
                s = S_EQ
              } else if (s === S_ATTR_S) {
                s = S_EQ
              } else {
                throw new Error("attribute equal must after attrName")
              }
              break;
            case "'":
            case '"':
              if (s === S_EQ) {
                start = p + 1;
                p = source.indexOf(c, start);
                if (p > 0) {
                  value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                  el.add(attrName, value, start - 1);
                  s = S_E
                } else {
                  throw new Error("attribute value no end '" + c + "' match")
                }
              } else if (s == S_V) {
                value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                el.add(attrName, value, start);
                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                start = p + 1;
                s = S_E
              } else {
                throw new Error('attribute value must after "="')
              }
              break;
            case "/":
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                case S_E:
                case S_S:
                case S_C:
                  s = S_C;
                  el.closed = true;
                case S_V:
                case S_ATTR:
                case S_ATTR_S:
                  break;
                default:
                  throw new Error("attribute invalid close char('/')")
              }
              break;
            case "":
              errorHandler.error("unexpected end of input");
            case ">":
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                case S_E:
                case S_S:
                case S_C:
                  break;
                case S_V:
                case S_ATTR:
                  value = source.slice(start, p);
                  if (value.slice(-1) === "/") {
                    el.closed = true;
                    value = value.slice(0, -1)
                  }
                case S_ATTR_S:
                  if (s === S_ATTR_S) {
                    value = attrName
                  }
                  if (s == S_V) {
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    el.add(attrName, value.replace(/&#?\w+;/g, entityReplacer), start)
                  } else {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                    el.add(value, value, start)
                  }
                  break;
                case S_EQ:
                  throw new Error("attribute value missed!!")
              }
              return p;
            case "":
              c = " ";
            default:
              if (c <= " ") {
                switch (s) {
                  case S_TAG:
                    el.setTagName(source.slice(start, p));
                    s = S_S;
                    break;
                  case S_ATTR:
                    attrName = source.slice(start, p);
                    s = S_ATTR_S;
                    break;
                  case S_V:
                    var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    el.add(attrName, value, start);
                  case S_E:
                    s = S_S;
                    break
                }
              } else {
                switch (s) {
                  case S_ATTR_S:
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead!!');
                    el.add(attrName, attrName, start);
                    start = p;
                    s = S_ATTR;
                    break;
                  case S_E:
                    errorHandler.warning('attribute space is required"' + attrName + '"!!');
                  case S_S:
                    s = S_ATTR;
                    start = p;
                    break;
                  case S_EQ:
                    s = S_V;
                    start = p;
                    break;
                  case S_C:
                    throw new Error("elements closed character '/' and '>' must be connected to")
                }
              }
          }
          p++
        }
      }

      function appendElement(el, domBuilder, parseStack) {
        var tagName = el.tagName;
        var localNSMap = null;
        var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
        var i = el.length;
        while (i--) {
          var a = el[i];
          var qName = a.qName;
          var value = a.value;
          var nsp = qName.indexOf(":");
          if (nsp > 0) {
            var prefix = a.prefix = qName.slice(0, nsp);
            var localName = qName.slice(nsp + 1);
            var nsPrefix = prefix === "xmlns" && localName
          } else {
            localName = qName;
            prefix = null;
            nsPrefix = qName === "xmlns" && ""
          }
          a.localName = localName;
          if (nsPrefix !== false) {
            if (localNSMap == null) {
              localNSMap = {};
              _copy(currentNSMap, currentNSMap = {})
            }
            currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            a.uri = "http://www.w3.org/2000/xmlns/";
            domBuilder.startPrefixMapping(nsPrefix, value)
          }
        }
        var i = el.length;
        while (i--) {
          a = el[i];
          var prefix = a.prefix;
          if (prefix) {
            if (prefix === "xml") {
              a.uri = "http://www.w3.org/XML/1998/namespace"
            }
            if (prefix !== "xmlns") {
              a.uri = currentNSMap[prefix]
            }
          }
        }
        var nsp = tagName.indexOf(":");
        if (nsp > 0) {
          prefix = el.prefix = tagName.slice(0, nsp);
          localName = el.localName = tagName.slice(nsp + 1)
        } else {
          prefix = null;
          localName = el.localName = tagName
        }
        var ns = el.uri = currentNSMap[prefix || ""];
        domBuilder.startElement(ns, localName, tagName, el);
        if (el.closed) {
          domBuilder.endElement(ns, localName, tagName);
          if (localNSMap) {
            for (prefix in localNSMap) {
              domBuilder.endPrefixMapping(prefix)
            }
          }
        } else {
          el.currentNSMap = currentNSMap;
          el.localNSMap = localNSMap;
          parseStack.push(el)
        }
      }

      function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
        if (/^(?:script|textarea)$/i.test(tagName)) {
          var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
          var text = source.substring(elStartEnd + 1, elEndStart);
          if (/[&<]/.test(text)) {
            if (/^script$/i.test(tagName)) {
              domBuilder.characters(text, 0, text.length);
              return elEndStart
            }
            text = text.replace(/&#?\w+;/g, entityReplacer);
            domBuilder.characters(text, 0, text.length);
            return elEndStart
          }
        }
        return elStartEnd + 1
      }

      function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
        var pos = closeMap[tagName];
        if (pos == null) {
          pos = closeMap[tagName] = source.lastIndexOf("</" + tagName + ">")
        }
        return pos < elStartEnd
      }

      function _copy(source, target) {
        for (var n in source) {
          target[n] = source[n]
        }
      }

      function parseDCC(source, start, domBuilder, errorHandler) {
        var next = source.charAt(start + 2);
        switch (next) {
          case "-":
            if (source.charAt(start + 3) === "-") {
              var end = source.indexOf("-->", start + 4);
              if (end > start) {
                domBuilder.comment(source, start + 4, end - start - 4);
                return end + 3
              } else {
                errorHandler.error("Unclosed comment");
                return -1
              }
            } else {
              return -1
            }
          default:
            if (source.substr(start + 3, 6) == "CDATA[") {
              var end = source.indexOf("]]>", start + 9);
              domBuilder.startCDATA();
              domBuilder.characters(source, start + 9, end - start - 9);
              domBuilder.endCDATA();
              return end + 3
            }
            var matchs = split(source, start);
            var len = matchs.length;
            if (len > 1 && /!doctype/i.test(matchs[0][0])) {
              var name = matchs[1][0];
              var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0];
              var sysid = len > 4 && matchs[4][0];
              var lastMatch = matchs[len - 1];
              domBuilder.startDTD(name, pubid && pubid.replace(/^(['"])(.*?)\1$/, "$2"), sysid && sysid.replace(/^(['"])(.*?)\1$/, "$2"));
              domBuilder.endDTD();
              return lastMatch.index + lastMatch[0].length
            }
        }
        return -1
      }

      function parseInstruction(source, start, domBuilder) {
        var end = source.indexOf("?>", start);
        if (end) {
          var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
          if (match) {
            var len = match[0].length;
            domBuilder.processingInstruction(match[1], match[2]);
            return end + 2
          } else {
            return -1
          }
        }
        return -1
      }

      function ElementAttributes(source) {}
      ElementAttributes.prototype = {
        setTagName: function(tagName) {
          if (!tagNamePattern.test(tagName)) {
            throw new Error("invalid tagName:" + tagName)
          }
          this.tagName = tagName
        },
        add: function(qName, value, offset) {
          if (!tagNamePattern.test(qName)) {
            throw new Error("invalid attribute:" + qName)
          }
          this[this.length++] = {
            qName: qName,
            value: value,
            offset: offset
          }
        },
        length: 0,
        getLocalName: function(i) {
          return this[i].localName
        },
        getOffset: function(i) {
          return this[i].offset
        },
        getQName: function(i) {
          return this[i].qName
        },
        getURI: function(i) {
          return this[i].uri
        },
        getValue: function(i) {
          return this[i].value
        }
      };

      function _set_proto_(thiz, parent) {
        thiz.__proto__ = parent;
        return thiz
      }
      if (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {
        _set_proto_ = function(thiz, parent) {
          function p() {}
          p.prototype = parent;
          p = new p;
          for (parent in thiz) {
            p[parent] = thiz[parent]
          }
          return p
        }
      }

      function split(source, start) {
        var match;
        var buf = [];
        var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        reg.lastIndex = start;
        reg.exec(source);
        while (match = reg.exec(source)) {
          buf.push(match);
          if (match[1]) return buf
        }
      }
      if (typeof require == "function") {
        exports.XMLReader = XMLReader
      }
    }, {}],
    "/src/js/index.js": [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var isNaN = function isNaN(number) {
        return !(number === number)
      };
      var SubContent = require("docxtemplater").SubContent;
      var ImgManager = require("./imgManager");
      var ImgReplacer = require("./imgReplacer");
      var ImageModule = function() {
        function ImageModule(options) {
          _classCallCheck(this, ImageModule);
          this.options = options || {};
          if (this.options.centered == null) {
            this.options.centered = false
          }
          if (this.options.getImage == null) {
            throw new Error("You should pass getImage")
          }
          if (this.options.getSize == null) {
            throw new Error("You should pass getSize")
          }
          this.qrQueue = [];
          this.imageNumber = 1
        }
        _createClass(ImageModule, [{
          key: "handleEvent",
          value: function handleEvent(event, eventData) {
            if (event === "rendering-file") {
              this.renderingFileName = eventData;
              var gen = this.manager.getInstance("gen");
              this.imgManager = new ImgManager(gen.zip, this.renderingFileName);
              this.imgManager.loadImageRels()
            }
            if (event === "rendered") {
              if (this.qrQueue.length === 0) {
                return this.finished()
              }
            }
          }
        }, {
          key: "get",
          value: function get(data) {
            if (data === "loopType") {
              var templaterState = this.manager.getInstance("templaterState");
              if (templaterState.textInsideTag[0] === "%") {
                return "image"
              }
            }
            return null
          }
        }, {
          key: "getNextImageName",
          value: function getNextImageName() {
            var name = "image_generated_" + this.imageNumber + ".png";
            this.imageNumber++;
            return name
          }
        }, {
          key: "replaceBy",
          value: function replaceBy(text, outsideElement) {
            var xmlTemplater = this.manager.getInstance("xmlTemplater");
            var templaterState = this.manager.getInstance("templaterState");
            var subContent = new SubContent(xmlTemplater.content);
            subContent = subContent.getInnerTag(templaterState);
            subContent = subContent.getOuterXml(outsideElement);
            return xmlTemplater.replaceXml(subContent, text)
          }
        }, {
          key: "convertPixelsToEmus",
          value: function convertPixelsToEmus(pixel) {
            return Math.round(pixel * 9525)
          }
        }, {
          key: "replaceTag",
          value: function replaceTag() {
            var scopeManager = this.manager.getInstance("scopeManager");
            var templaterState = this.manager.getInstance("templaterState");
            var xmlTemplater = this.manager.getInstance("xmlTemplater");
            var tagXml = xmlTemplater.fileTypeConfig.tagsXmlArray[0];
            var tagXmlParagraph = tagXml.substr(0, 1) + ":p";
            var tag = templaterState.textInsideTag.substr(1);
            var tagValue = scopeManager.getValue(tag);
            var startEnd = "<" + tagXml + "></" + tagXml + ">";
            var outsideElement = this.options.centered ? tagXmlParagraph : tagXml;
            if (tagValue == null) {
              return this.replaceBy(startEnd, tagXml)
            }
            var imgBuffer = void 0;
            try {
              imgBuffer = this.options.getImage(tagValue, tag)
            } catch (e) {
              return this.replaceBy(startEnd, tagXml)
            }
            var imageRels = this.imgManager.loadImageRels();
            if (!imageRels) {
              return
            }
            var rId = imageRels.addImageRels(this.getNextImageName(), imgBuffer);
            var sizePixel = this.options.getSize(imgBuffer, tagValue, tag);
            var size = [this.convertPixelsToEmus(sizePixel[0]), this.convertPixelsToEmus(sizePixel[1])];
            var newText = this.options.centered ? this.getImageXmlCentered(rId, size) : this.getImageXml(rId, size);
            return this.replaceBy(newText, outsideElement)
          }
        }, {
          key: "replaceQr",
          value: function replaceQr() {
            var _this = this;
            var xmlTemplater = this.manager.getInstance("xmlTemplater");
            var imR = new ImgReplacer(xmlTemplater, this.imgManager);
            imR.getDataFromString = function(result, cb) {
              if (_this.options.getImageAsync != null) {
                return _this.options.getImageAsync(result, cb)
              }
              return cb(null, _this.options.getImage(result))
            };
            imR.pushQrQueue = function(num) {
              return _this.qrQueue.push(num)
            };
            imR.popQrQueue = function(num) {
              var found = _this.qrQueue.indexOf(num);
              if (found !== -1) {
                _this.qrQueue.splice(found, 1)
              } else {
                _this.on("error", new Error("qrqueue " + num + " is not in qrqueue"))
              }
              if (_this.qrQueue.length === 0) {
                return _this.finished()
              }
            };
            var num = parseInt(Math.random() * 1e4, 10);
            imR.pushQrQueue("rendered-" + num);
            try {
              imR.findImages().replaceImages()
            } catch (e) {
              this.on("error", e)
            }
            var f = function f() {
              return imR.popQrQueue("rendered-" + num)
            };
            return setTimeout(f, 1)
          }
        }, {
          key: "finished",
          value: function finished() {}
        }, {
          key: "on",
          value: function on(event, data) {
            if (event === "error") {
              throw data
            }
          }
        }, {
          key: "handle",
          value: function handle(type, data) {
            if (type === "replaceTag" && data === "image") {
              this.replaceTag()
            }
            if (type === "xmlRendered" && this.options.qrCode) {
              this.replaceQr()
            }
            return null
          }
        }, {
          key: "getImageXml",
          value: function getImageXml(rId, size) {
            if (isNaN(rId)) {
              throw new Error("rId is NaN, aborting")
            }
            return '<w:drawing>\n  <wp:inline distT="0" distB="0" distL="0" distR="0">\n    <wp:extent cx="' + size[0] + '" cy="' + size[1] + '"/>\n    <wp:effectExtent l="0" t="0" r="0" b="0"/>\n    <wp:docPr id="2" name="Image 2" descr="image"/>\n    <wp:cNvGraphicFramePr>\n      <a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/>\n    </wp:cNvGraphicFramePr>\n    <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n      <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n        <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n          <pic:nvPicPr>\n            <pic:cNvPr id="0" name="Picture 1" descr="image"/>\n            <pic:cNvPicPr>\n              <a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n            </pic:cNvPicPr>\n          </pic:nvPicPr>\n          <pic:blipFill>\n            <a:blip r:embed="rId' + rId + '">\n              <a:extLst>\n                <a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n                  <a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n                </a:ext>\n              </a:extLst>\n            </a:blip>\n            <a:srcRect/>\n            <a:stretch>\n              <a:fillRect/>\n            </a:stretch>\n          </pic:blipFill>\n          <pic:spPr bwMode="auto">\n            <a:xfrm>\n              <a:off x="0" y="0"/>\n              <a:ext cx="' + size[0] + '" cy="' + size[1] + '"/>\n            </a:xfrm>\n            <a:prstGeom prst="rect">\n              <a:avLst/>\n            </a:prstGeom>\n            <a:noFill/>\n            <a:ln>\n              <a:noFill/>\n            </a:ln>\n          </pic:spPr>\n        </pic:pic>\n      </a:graphicData>\n    </a:graphic>\n  </wp:inline>\n</w:drawing>\n		'
          }
        }, {
          key: "getImageXmlCentered",
          value: function getImageXmlCentered(rId, size) {
            if (isNaN(rId)) {
              throw new Error("rId is NaN, aborting")
            }
            return '		<w:p>\n		  <w:pPr>\n			<w:jc w:val="center"/>\n		  </w:pPr>\n		  <w:r>\n			<w:rPr/>\n			<w:drawing>\n			  <wp:inline distT="0" distB="0" distL="0" distR="0">\n				<wp:extent cx="' + size[0] + '" cy="' + size[1] + '"/>\n				<wp:docPr id="0" name="Picture" descr=""/>\n				<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n				  <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n					<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n					  <pic:nvPicPr>\n						<pic:cNvPr id="0" name="Picture" descr=""/>\n						<pic:cNvPicPr>\n						  <a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n						</pic:cNvPicPr>\n					  </pic:nvPicPr>\n					  <pic:blipFill>\n						<a:blip r:embed="rId' + rId + '"/>\n						<a:stretch>\n						  <a:fillRect/>\n						</a:stretch>\n					  </pic:blipFill>\n					  <pic:spPr bwMode="auto">\n						<a:xfrm>\n						  <a:off x="0" y="0"/>\n						  <a:ext cx="' + size[0] + '" cy="' + size[1] + '"/>\n						</a:xfrm>\n						<a:prstGeom prst="rect">\n						  <a:avLst/>\n						</a:prstGeom>\n						<a:noFill/>\n						<a:ln w="9525">\n						  <a:noFill/>\n						  <a:miter lim="800000"/>\n						  <a:headEnd/>\n						  <a:tailEnd/>\n						</a:ln>\n					  </pic:spPr>\n					</pic:pic>\n				  </a:graphicData>\n				</a:graphic>\n			  </wp:inline>\n			</w:drawing>\n		  </w:r>\n		</w:p>\n		'
          }
        }]);
        return ImageModule
      }();
      module.exports = ImageModule
    }, {
      "./imgManager": 40,
      "./imgReplacer": 41,
      docxtemplater: 46
    }]
  }, {}, [])("/src/js/index.js")
});
/*! RESOURCE: Validate Client Script Functions */
function validateFunctionDeclaration(fieldName, functionName) {
  var code = g_form.getValue(fieldName);
  if (code == "")
    return true;
  code = removeCommentsFromClientScript(code);
  var patternString = "function(\\s+)" + functionName + "((\\s+)|\\(|\\[\r\n])";
  var validatePattern = new RegExp(patternString);
  if (!validatePattern.test(code)) {
    var msg = new GwtMessage().getMessage('Missing function declaration for') + ' ' + functionName;
    g_form.showErrorBox(fieldName, msg);
    return false;
  }
  return true;
}

function validateNoServerObjectsInClientScript(fieldName) {
  var code = g_form.getValue(fieldName);
  if (code == "")
    return true;
  code = removeCommentsFromClientScript(code);
  var doubleQuotePattern = /"[^"\r\n]*"/g;
  code = code.replace(doubleQuotePattern, "");
  var singleQuotePattern = /'[^'\r\n]*'/g;
  code = code.replace(singleQuotePattern, "");
  var rc = true;
  var gsPattern = /(\s|\W)gs\./;
  if (gsPattern.test(code)) {
    var msg = new GwtMessage().getMessage('The object "gs" should not be used in client scripts.');
    g_form.showErrorBox(fieldName, msg);
    rc = false;
  }
  var currentPattern = /(\s|\W)current\./;
  if (currentPattern.test(code)) {
    var msg = new GwtMessage().getMessage('The object "current" should not be used in client scripts.');
    g_form.showErrorBox(fieldName, msg);
    rc = false;
  }
  return rc;
}

function validateUIScriptIIFEPattern(fieldName, scopeName, scriptName) {
  var code = g_form.getValue(fieldName);
  var rc = true;
  if ("global" == scopeName)
    return rc;
  code = removeCommentsFromClientScript(code);
  code = removeSpacesFromClientScript(code);
  code = removeNewlinesFromClientScript(code);
  var requiredStart = "var" + scopeName + "=" + scopeName + "||{};" + scopeName + "." + scriptName + "=(function(){\"usestrict\";";
  var requiredEnd = "})();";
  if (!code.startsWith(requiredStart)) {
    var msg = new GwtMessage().getMessage("Missing closure assignment.");
    g_form.showErrorBox(fieldName, msg);
    rc = false;
  }
  if (!code.endsWith(requiredEnd)) {
    var msg = new GwtMessage().getMessage("Missing immediately-invoked function declaration end.");
    g_form.showErrorBox(fieldName, msg);
    rc = false;
  }
  return rc;
}

function validateNotCallingFunction(fieldName, functionName) {
  var code = g_form.getValue(fieldName);
  var rc = true;
  var reg = new RegExp(functionName, "g");
  var matches;
  code = removeCommentsFromClientScript(code);
  if (code == '')
    return rc;
  matches = code.match(reg);
  rc = (matches && (matches.length == 1));
  if (!rc) {
    var msg = "Do not explicitly call the " + functionName + " function in your business rule. It will be called automatically at execution time.";
    msg = new GwtMessage().getMessage(msg);
    g_form.showErrorBox(fieldName, msg);
  }
  return rc;
}

function removeCommentsFromClientScript(code) {
  var pattern1 = /\/\*(.|[\r\n])*?\*\//g;
  code = code.replace(pattern1, "");
  var pattern2 = /\/\/.*/g;
  code = code.replace(pattern2, "");
  return code;
}

function removeSpacesFromClientScript(code) {
  var pattern = /\s*/g;
  return code.replace(pattern, "");
}

function removeNewlinesFromClientScript(code) {
  var pattern = /[\r\n]*/g;
  return code.replace(pattern, "");
}
/*! RESOURCE: ProjectTaskUtil */
var ProjectTaskUtil = Class.create();
ProjectTaskUtil.prototype = {
  initialize: function() {},
  type: 'ProjectTaskUtil'
};
ProjectTaskUtil.decodeOnLoadActualDatesState = function(response) {
  var result = (response.responseXML.getElementsByTagName('result'))[0];
  var status = result.getAttribute('status');
  var workStartReadOnly = true;
  var workEndReadOnly = true;
  if (status == 'success') {
    var state = result.getAttribute('state');
    if (state == 'closed') {
      workStartReadOnly = false;
      workEndReadOnly = false;
    } else if (state == 'started')
      workStartReadOnly = false;
  }
  return {
    workStartReadOnly: workStartReadOnly,
    workEndReadOnly: workEndReadOnly
  };
};
ProjectTaskUtil.decodeOnChangeActualDatesState = function(response) {
  var result = (response.responseXML.getElementsByTagName('result'))[0];
  var state = JSON.parse(result.getAttribute('state'));
  return {
    workStartState: ProjectTaskUtil._decodeActualStartDateState(state.work_start_state),
    workEndState: ProjectTaskUtil._decodeActualEndDateState(state.work_end_state)
  };
};
ProjectTaskUtil._decodeActualStartDateState = function(result) {
  var workStartState = {
    date: '',
    readOnly: true
  };
  var status = result.work_start_status;
  if (status == 'success') {
    var state = result.work_start_state;
    if (state == 'already_started' || state == 'about_to_start') {
      workStartState.readOnly = false;
      workStartState.date = result.work_start;
    }
  }
  return workStartState;
};
ProjectTaskUtil._decodeActualEndDateState = function(result) {
  var workEndState = {
    date: '',
    readOnly: true
  };
  var status = result.work_end_status;
  if (status == 'success') {
    var state = result.work_end_state;
    if (state == 'already_closed' || state == 'about_to_close') {
      workEndState.readOnly = false;
      workEndState.date = result.work_end;
    }
  }
  return workEndState;
};
/*! RESOURCE: cv_editor_scripts */
bindToggleIcon = function() {
  $("button.toggle-icon").bind("click", function() {
    $(this).find("span.glyphicon").toggleClass("glyphicon-resize-small").toggleClass("glyphicon-resize-full");
  });
};
/*! RESOURCE: ScrumTaskDialog */
var ScrumTaskDialog = Class.create(GlideDialogWindow, {
  initialize: function() {
    if (typeof g_list != "undefined")
      this.list = g_list;
    else
      this.list = null;
    this.storyID = typeof rowSysId == 'undefined' ? (gel('sys_uniqueValue') ? gel('sys_uniqueValue').value : "") : rowSysId;
    this.setUpFacade();
    this.setUpEvents();
    this.display(true);
    this.checkOKButton();
    this.setWidth(155);
    this.focusFirstSelectElement();
  },
  toggleOKButton: function(visible) {
    $("ok").style.display = (visible ? "inline" : "none");
  },
  setUpFacade: function() {
    GlideDialogWindow.prototype.initialize.call(this, "task_window", false);
    this.setTitle(getMessage("Add Scrum Tasks"));
    var mapCount = this.getTypeCounts();
    this.setBody(this.getMarkUp(mapCount), false, false);
  },
  checkOKButton: function() {
    var visible = false;
    var thisDialog = this;
    this.container.select("select").each(function(elem) {
      if (elem.value + "" != "0")
        visible = true;
      if (!elem.onChangeAdded) {
        elem.onChangeAdded = true;
        elem.on("change", function() {
          thisDialog.checkOKButton();
        });
      }
    });
    this.toggleOKButton(visible);
  },
  focusFirstSelectElement: function() {
    this.container.select("select")[0].focus();
  },
  getTypeCounts: function() {
    var mapLabel = this.getLabels("rm_scrum_task", "type");
    var mapCount = {};
    for (var strKey in mapLabel) {
      mapCount[strKey] = getPreference("com.snc.sdlc.scrum.pp.tasks." + strKey, 0);
    }
    return mapCount;
  },
  setUpEvents: function() {
    var dialog = this;
    $("ok").on("click", function() {
      var mapTaskData = {};
      if (dialog.fillDataMap(mapTaskData)) {
        var taskProducer = new GlideAjax("ScrumAjaxTaskProducer");
        for (var strKey in mapTaskData) {
          taskProducer.addParam("sysparm_" + strKey, mapTaskData[strKey]);
        }
        dialog.showStatus("Adding tasks...");
        taskProducer.getXML(function() {
          dialog.refresh();
          dialog._onCloseClicked();
        });
      } else {
        dialog._onCloseClicked();
      }
    });
    $("cancel").on("click", function() {
      dialog._onCloseClicked();
    });
  },
  refresh: function() {
    if (this.list)
      this.list.refresh();
    else
      this.reloadList("rm_story.rm_scrum_task.story");
  },
  getSysID: function() {
    return this.storyID;
  },
  fillDataMap: function(mapTaskData) {
    var bTasksRequired = false;
    mapTaskData.name = "createTasks";
    mapTaskData.sys_id = this.getSysID();
    var mapDetails = this.getLabels("rm_scrum_task", "type");
    var arrTaskTypes = [];
    for (var key in mapDetails) {
      arrTaskTypes.push(key);
    }
    for (var nSlot = 0; nSlot < arrTaskTypes.length; ++nSlot) {
      var strTaskType = arrTaskTypes[nSlot];
      var strTaskData = $(strTaskType).getValue();
      mapTaskData[strTaskType] = strTaskData;
      setPreference("com.snc.sdlc.scrum.pp.tasks." + strTaskType, strTaskData);
      if (strTaskData != "0") {
        bTasksRequired = true;
      }
    }
    return bTasksRequired;
  },
  getMarkUp: function(mapCounts) {
    function getSelectMarkUp(strFieldId, nValue) {
      var strMarkUp = "<select id='" + strFieldId + "'>";
      for (var nSlot = 0; nSlot <= 10; nSlot++) {
        if (nValue != 0 && nValue == nSlot) {
          strMarkUp += "<option value='" + nSlot + "' + " + "selected='selected'" + ">" + nSlot + "</choice>";
        } else {
          strMarkUp += "<option value='" + nSlot + "'>" + nSlot + "</choice>";
        }
      }
      strMarkUp += "</select>";
      return strMarkUp;
    }

    function buildRow(strMessage, strLabel, nValue) {
      return "<tr><td><label for='" + strLabel + "'>" + strMessage + "</label></td><td>" + getSelectMarkUp(strLabel, nValue) + "</td></tr>";
    }

    function buildTable(mapDetails, mapCounts) {
      var arrDetails = [];
      for (var strKey in mapDetails) {
        arrDetails.push(strKey + "");
      }
      arrDetails.sort();
      var strBuf = "<table>";
      for (var index = 0; index < arrDetails.length; ++index) {
        var strTitleCase = arrDetails[index].charAt(0).toString().toUpperCase() + arrDetails[index].substring(1);
        var nCount = mapCounts[arrDetails[index]];
        strBuf += buildRow(strTitleCase, arrDetails[index], nCount);
      }
      strBuf += "</table>";
      return strBuf;
    }
    var mapLabels = this.getLabels("rm_scrum_task", "type");
    return "<div id='task_controls'>" + buildTable(mapLabels, mapCounts) +
      "<button id='ok' type='button'>" + getMessage('OK') + "</button>" +
      "<button id='cancel' type='button'>" + getMessage('Cancel') + "</button></div>";
  },
  reloadForm: function() {
    document.location.href = document.location.href;
  },
  reloadList: function(strListName) {
    GlideList2.get(strListName).refresh();
  },
  showStatus: function(strMessage) {
    $("task_controls").update("Loading...");
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getLabels: function(strTable, strAttribute) {
    var taskProducer = new GlideAjax("ScrumAjaxTaskProducer");
    taskProducer.addParam("sysparm_name", "getLabels");
    taskProducer.addParam("sysparm_table", strTable);
    taskProducer.addParam("sysparm_attribute", strAttribute);
    var result = taskProducer.getXMLWait();
    return this._parseResponse(result);
  },
  _parseResponse: function(resultXML) {
    var jsonStr = resultXML.documentElement.getAttribute("answer");
    var map = (isMSIE7 || isMSIE8) ? eval("(" + jsonStr + ")") : JSON.parse(jsonStr);
    return map;
  }
});
/*! RESOURCE: Display PO number and Description */
function setTitle() {
  try {
    var num = g_form.getValue("number");
    var sd = g_form.getValue("description");
  } catch (e) {}
  if (num && sd) {
    top.document.title = num + ' - ' + sd;
  } else {
    top.document.title = 'ServiceNow - IT Service Management Suite';
  }
}
addLoadEvent(setTitle);
/*! RESOURCE: tm_AssignDefect */
var tm_AssignDefect = Class.create({
  initialize: function(gr) {
    this._gr = gr;
    this._isList = (gr.type + "" == "GlideList2");
    this._sysId = this._gr.getUniqueValue();
    this._tableName = this._gr.getTableName();
    this._redirect = false;
    this._testCaseInstance = 'tm_test_case_instance';
    this._prmErr = [];
    if (this._tableName == 'tm_test_instance') {
      this._sysId = this._gr.getValue('tm_test_case_instance');
    }
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("tm_ref_choose_dialog");
    var titleMsg = getMessage("Assign Defect to Test Case");
    this._mstrDlg.setTitle(titleMsg);
    this._mstrDlg.setPreference("sysparam_reference_table", "rm_defect");
    this._mstrDlg.setPreference("sysparam_query", "");
    this._mstrDlg.setPreference("sysparam_field_label", getMessage("Defect"));
    this._mstrDlg.setPreference("handler", this);
  },
  showLoadingDialog: function() {
    this.loadingDialog = new GlideDialogWindow("dialog_loading", true, 300);
    this.loadingDialog.setPreference('table', 'loading');
    this.loadingDialog.render();
  },
  hideLoadingDialog: function() {
    this.loadingDialog && this.loadingDialog.destroy();
  },
  showDialog: function() {
    this._mstrDlg.render();
  },
  onSubmit: function() {
    this.defectId = this._getValue('rm_defect_ref');
    this.defectLabel = this._getDisplayValue('rm_defect_ref');
    if (!this._validate()) {
      var e = gel("sys_display.rm_defect_ref");
      if (e)
        e.focus();
      return false;
    }
    this._mstrDlg.destroy();
    if (this.defectId) {
      var ga = new GlideAjax("tm_AjaxProcessor");
      ga.addParam('sysparm_name', 'mapDefectToTestCase');
      ga.addParam('sysparm_sysId', this._sysId);
      ga.addParam('sysparm_defect', this.defectId);
      ga.addParam('sysparm_tn', this._testCaseInstance);
      this.showLoadingDialog();
      ga.getXML(this.callback.bind(this));
    }
    return false;
  },
  callback: function(response) {
    this.hideLoadingDialog();
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      if (this._tableName == this._testCaseInstance) {
        var list = GlideList2.get(g_form.getTableName() + '.REL:5da20971872121003706db5eb2e3ec0b');
        if (list)
          list.setFilterAndRefresh('');
      } else {
        this._displayInfoMessage(resp[0]);
      }
    } else {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._createError = new dialogClass("tm_error_dialog");
      this._createError.setTitle(getMessage("Error while assigning defect."));
      this._createError.render();
    }
  },
  _validate: function() {
    this._prmErr = [];
    this._removeAllError('tm_ref_choose_dialog');
    if (this._getValue('rm_defect_ref') == 'undefined' || this._getValue('rm_defect_ref').trim() == "") {
      this._prmErr.push(getMessage("Select the defect."));
      this._showFieldError('ref_test_suite_field', getMessage(this._prmErr[0]));
      return false;
    }
    return this._checkForDuplicateEntry();
  },
  _getValue: function(inptNm) {
    return gel(inptNm).value;
  },
  _getDisplayValue: function(inputNm) {
    return gel('display_hidden.' + inputNm).value;
  },
  _displayInfoMessage: function(result) {
    var infoMessage = result.textContent;
    this._gr.addInfoMessage(infoMessage);
  },
  _checkForDuplicateEntry: function() {
    this.defectId = this._getValue('rm_defect_ref');
    this._testCaseInstance;
    var ga = new GlideAjax("tm_AjaxProcessor");
    ga.addParam('sysparm_name', 'hasAssociation');
    ga.addParam('sysparm_testcaseinstance', this._sysId);
    ga.addParam('sysparm_defect', this._getValue('rm_defect_ref'));
    this.showLoadingDialog();
    var responseXML = ga.getXMLWait();
    return this._parseResponse(responseXML);
  },
  _parseResponse: function(responseXML) {
    this.hideLoadingDialog();
    var resp = responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      var isDuplicate = responseXML.documentElement.getAttribute("answer");
      this._removeAllError('tm_ref_choose_dialog');
      if (isDuplicate == 'true') {
        this._showFieldError('ref_test_suite_field', getMessage('Already assigned'));
        return false;
      }
    }
    return true;
  },
  _removeAllError: function(dialogName) {
    $$('#' + dialogName + ' .form-group.has-error').each(function(item) {
      $(item).removeClassName('has-error');
      $(item).down('.help-block').setStyle({
        'display': 'none'
      });
    });
  },
  _showFieldError: function(groupId, message) {
    var $group = $(groupId);
    var $helpBlock = $group.down('.help-block');
    if (!$group.hasClassName('has-error'))
      $group.addClassName('has-error');
    if ($helpBlock.getStyle('display') != 'inline-block') {
      $helpBlock.update(message);
      $helpBlock.setStyle({
        'display': 'inline-block'
      });
    }
  },
  type: "tm_AssignDefect"
});
/*! RESOURCE: ScrumMoveToProjectHandler */
var ScrumMoveToProjectHandler = Class.create({
  initialize: function(g_list) {
    this.g_list = g_list;
  },
  showDialog: function() {
    if (this.g_list.getChecked() == '') {
      var span = document.createElement('span');
      span.setAttribute('data-type', 'system');
      span.setAttribute('data-text', getMessage('Please select a Story'));
      span.setAttribute('data-duration', '4000');
      span.setAttribute('data-attr-type', 'error');
      var notification = {
        xml: span
      };
      GlideUI.get().fire(new GlideUINotification(notification));
    } else {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this.dlg = new dialogClass("scrum_move_to_project_dialog");
      var titleMsg = getMessage("Assign to project");
      this.dlg.setTitle(titleMsg);
      this.dlg.setPreference('handler', this);
      this.dlg.setPreference('sysparam_reference_table', 'pm_project');
      this.dlg.setPreference('sysparam_query', 'active=true');
      this.dlg.setPreference('sysparam_field_label', getMessage('Project'));
      this.dlg.render();
    }
  },
  onSubmit: function() {
    if (!this.valid()) {
      return false;
    }
    var projectType = this.getValue('project_type_radiobutton');
    var ga;
    var dialogClass;
    if (projectType != 'new') {
      var projectId = this.getValue('pm_project_ref');
      var phaseId = this.getValue('pm_project_phase');
      this.dlg.destroy();
      dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this.wtDlg = new dialogClass('scrum_please_wait');
      this.wtDlg.render();
      ga = new GlideAjax("agile2_AjaxProcessor");
      ga.addParam('sysparm_name', 'addStoriesToProject');
      ga.addParam('sysparm_project', projectId);
      ga.addParam('sysparm_phase', phaseId);
      ga.addParam('sysparm_stories', this.g_list.getChecked());
      ga.getXML(this.callback.bind(this));
      return false;
    } else {
      var projectName = this.getValue('new_project_field');
      var projectStartDate = this.getValue('new_project_start_date');
      this.dlg.destroy();
      dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this.wtDlg = new dialogClass('scrum_please_wait');
      this.wtDlg.render();
      ga = new GlideAjax("agile2_AjaxProcessor");
      ga.addParam('sysparm_name', 'createProjectForStories');
      ga.addParam('sysparm_project', projectName);
      ga.addParam('sysparm_startDate', projectStartDate);
      ga.addParam('sysparm_stories', this.g_list.getChecked());
      ga.getXML(this.callback.bind(this));
      return false;
    }
  },
  onCancel: function() {
    this.dlg.destroy();
    return false;
  },
  getValue: function(fieldId) {
    if (fieldId == 'project_type_radiobutton')
      return $j("input[name='project_type_radiobutton']:checked").val();
    return gel(fieldId).value;
  },
  callback: function(response) {
    this.wtDlg.destroy();
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      var projectId = resp[0].getAttribute("projectId");
      if (projectId) {
        var url = "pm_project.do?sys_id=" + projectId;
        window.location = url;
      } else
        window.location.reload();
    }
  },
  valid: function() {
    var projectType = this.getValue('project_type_radiobutton');
    var errMsg;
    this._hideAllFieldErrors();
    if (projectType != 'new') {
      if (typeof this.getValue('pm_project_ref') == 'undefined' || this.getValue('pm_project_ref').trim() == '') {
        errMsg = getMessage("Select a project");
        this._showFieldError('ref_project_field', errMsg, 'sys_display.pm_project_ref');
        return false;
      } else if (this._isVisible('ref_project_phase') && (typeof this.getValue('pm_project_phase') == 'undefined' || this.getValue('pm_project_phase').trim() == '')) {
        errMsg = getMessage("Select a phase");
        this._showFieldError('ref_project_phase', errMsg, 'ref_project_phase');
        return false;
      } else
        return true;
    } else {
      if (typeof this.getValue('new_project_field') == 'undefined' || this.getValue('new_project_field').trim() == '') {
        errMsg = getMessage("Enter the project name");
        this._showFieldError('ref_new_project_field', errMsg, 'new_project_field');
        return false;
      } else if (typeof this.getValue('new_project_start_date') == 'undefined' || this.getValue('new_project_start_date').trim() == '') {
        errMsg = getMessage("Enter the project start date");
        this._showFieldError('ref_new_project_start_date', errMsg, 'new_project_start_date');
        return false;
      } else
        return true;
    }
  },
  _showFieldError: function(groupId, message, focusField) {
    var $group = $j('#' + groupId);
    var $helpBlock = $group.find('.help-block');
    if (!$group.hasClass('has-error'))
      $group.addClass('has-error');
    if ($helpBlock.css('display') != "inline") {
      $helpBlock.text(message);
      $helpBlock.css('display', 'inline');
    } else
      $helpBlock.css('display', 'none');
    if (focusField) {
      var elem = gel(focusField);
      elem.focus();
    }
  },
  _hideAllFieldErrors: function() {
    var fields = ['ref_project_field', 'ref_new_project_field', 'ref_new_project_start_date'];
    var $group;
    var $helpBlock;
    fields.forEach(function(field) {
      $group = $j('#' + field);
      $helpBlock = $group.find('.help-block');
      $helpBlock.css('display', 'none');
    });
  },
  _isVisible: function(field) {
    return $j('#' + field).is(":visible");
  },
  type: "ScrumMoveToProjectHandler"
});
/*! RESOURCE: ITGDN - getMyProfile */
function getMyProfile() {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "getProfile");
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    if (data.length > 0) {
      var output = "<div id='myProfile'>";
      for (var i = 0; i < 1; i++) {
        var first_name = data[i].getAttribute("first_name").toString();
        var middle_name = data[i].getAttribute("middle_name").toString();
        var last_name = data[i].getAttribute("last_name").toString();
        var email = data[i].getAttribute("email").toString();
        var mobile_phone = data[i].getAttribute("mobile_phone").toString();
        var phone = data[i].getAttribute("phone").toString();
        var location = data[i].getAttribute("location").toString();
        var job = data[i].getAttribute("job").toString();
        output += '<div id="profilePersonal"><h2>My personal data</h2></div>';
        output += '<div id="profileData">';
        output += '<span class="profileFirstColumn">Name: </span><span class="profileSecondColumn">' + first_name + ' ' + middle_name + ' ' + last_name + '</span><br />';
        output += '<span class="profileFirstColumn">Job Title: </span><span class="profileSecondColumn">' + job + '</span><br />';
        output += '<span class="profileFirstColumn">Email: </span><span class="profileSecondColumn">' + email + '</span><br />';
        output += '<span class="profileFirstColumn">Business phone: </span><span class="profileSecondColumn">' + phone + '</span><br />';
        output += '<span class="profileFirstColumn">Mobile phone: </span><span class="profileSecondColumn">' + mobile_phone + '</span>';
        output += '</div>';
      }
      output += "</div";
      $j("div#wrapper").html(output);
    } else {
      $j("div#wrapper").html('No data found.');
    }
  }
}
/*! RESOURCE: ITGDN - getMyKnowledgeBaseList */
function getMyKnowledgeBaseList(wrapper, type, limit) {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "getKnowledgeBase");
  gajax.addParam("knowledge_type", type);
  gajax.addParam("limit", limit);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    if (data.length > 0) {
      var count = 1;
      var output = "<table class='callsTable' id='data-table' border='0' cellpadding='10' cellspacing='0'>";
      output += "<tbody id='data'>";
      for (var i = 0; i < data.length; i++) {
        var evenOrOdd = 'odd';
        if (i % 2 == 0) {
          evenOrOdd = 'even';
        }
        output += '<tr>';
        output += '<td>';
        var newsDate = '';
        if (type == 'News') {
          newsDate = '<div class="knowledge_date_list">' + data[i].getAttribute("knowledge_date").toString() + '</div>';
        }
        output += '<a href="/support/knowledge_detail.do?sys_id=' + data[i].getAttribute("knowledge_sys_id").toString() + '&type=' + type + '">' + newsDate + '' + data[i].getAttribute("knowledge_name").toString() + '</a>';
        output += '</td>';
        output += '</tr>';
        count++;
      }
      $j("div#" + wrapper + "").html(output);
    } else {
      $j("div#" + wrapper + "").html('No records found.');
    }
  }
}
/*! RESOURCE: ITGDN - getMyKnowledgeBaseHome */
function getMyKnowledgeBaseHome(wrapper, type, limit) {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "getKnowledgeBase");
  gajax.addParam("wrapper", wrapper);
  gajax.addParam("knowledge_type", type);
  gajax.addParam("limit", limit);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    if (data.length > 0) {
      var count = 1;
      output = '';
      for (var i = 0; i < data.length; i++) {
        var evenOrOdd = 'odd';
        if (i % 2 == 0) {
          evenOrOdd = 'even';
        }
        output += '<div class="announcementRow ' + evenOrOdd + '">';
        var stringLegthLimit = 65;
        if (type == 'News') {
          stringLegthLimit = 45;
          var knowledge_dt = data[i].getAttribute("knowledge_date");
          output += '<div class="knowledge_date">' + knowledge_dt.toString() + '</div>';
        }
        var shortDesc = data[i].getAttribute("knowledge_name");
        var dots = '';
        if (shortDesc.length > stringLegthLimit) {
          dots = '...';
        }
        output += '<a href="/support/knowledge_detail.do?sys_id=' + data[i].getAttribute("knowledge_sys_id").toString() + '&type=' + type + '">' + shortDesc.substr(0, stringLegthLimit) + '' + dots;
        output += '</a>';
        output += '</div>';
        count++;
      }
      $j("div#" + wrapper + "").html(output);
    } else {
      $j("div#announcementsWrapper").html('No data found.');
    }
  }
}
/*! RESOURCE: docxtemplater.v2.1.5.min.js */
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f()
  } else if (typeof define === "function" && define.amd) {
    define([], f)
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window
    } else if (typeof global !== "undefined") {
      g = global
    } else if (typeof self !== "undefined") {
      g = self
    } else {
      g = this
    }
    g.Docxgen = f()
  }
})(function() {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f
        }
        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e)
        }, l, l.exports, e, t, n, r)
      }
      return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s
  }({
    1: [function(require, module, exports) {
      (function(global) {
        var base64 = require("base64-js");
        var ieee754 = require("ieee754");
        var isArray = require("is-array");
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        var rootParent = {};
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

        function typedArraySupport() {
          function Bar() {}
          try {
            var arr = new Uint8Array(1);
            arr.foo = function() {
              return 42
            };
            arr.constructor = Bar;
            return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0
          } catch (e) {
            return false
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function Buffer(arg) {
          if (!(this instanceof Buffer)) {
            if (arguments.length > 1) return new Buffer(arg, arguments[1]);
            return new Buffer(arg)
          }
          this.length = 0;
          this.parent = undefined;
          if (typeof arg === "number") {
            return fromNumber(this, arg)
          }
          if (typeof arg === "string") {
            return fromString(this, arg, arguments.length > 1 ? arguments[1] : "utf8")
          }
          return fromObject(this, arg)
        }

        function fromNumber(that, length) {
          that = allocate(that, length < 0 ? 0 : checked(length) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < length; i++) {
              that[i] = 0
            }
          }
          return that
        }

        function fromString(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
          var length = byteLength(string, encoding) | 0;
          that = allocate(that, length);
          that.write(string, encoding);
          return that
        }

        function fromObject(that, object) {
          if (Buffer.isBuffer(object)) return fromBuffer(that, object);
          if (isArray(object)) return fromArray(that, object);
          if (object == null) {
            throw new TypeError("must start with number, buffer, array or string")
          }
          if (typeof ArrayBuffer !== "undefined") {
            if (object.buffer instanceof ArrayBuffer) {
              return fromTypedArray(that, object)
            }
            if (object instanceof ArrayBuffer) {
              return fromArrayBuffer(that, object)
            }
          }
          if (object.length) return fromArrayLike(that, object);
          return fromJsonObject(that, object)
        }

        function fromBuffer(that, buffer) {
          var length = checked(buffer.length) | 0;
          that = allocate(that, length);
          buffer.copy(that, 0, 0, length);
          return that
        }

        function fromArray(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromTypedArray(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromArrayBuffer(that, array) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            array.byteLength;
            that = Buffer._augment(new Uint8Array(array))
          } else {
            that = fromTypedArray(that, new Uint8Array(array))
          }
          return that
        }

        function fromArrayLike(that, array) {
          var length = checked(array.length) | 0;
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }

        function fromJsonObject(that, object) {
          var array;
          var length = 0;
          if (object.type === "Buffer" && isArray(object.data)) {
            array = object.data;
            length = checked(array.length) | 0
          }
          that = allocate(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255
          }
          return that
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array
        }

        function allocate(that, length) {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            that = Buffer._augment(new Uint8Array(length));
            that.__proto__ = Buffer.prototype
          } else {
            that.length = length;
            that._isBuffer = true
          }
          var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
          if (fromPool) that.parent = rootParent;
          return that
        }

        function checked(length) {
          if (length >= kMaxLength()) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes")
          }
          return length | 0
        }

        function SlowBuffer(subject, encoding) {
          if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);
          var buf = new Buffer(subject, encoding);
          delete buf.parent;
          return buf
        }
        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer)
        };
        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers")
          }
          if (a === b) return 0;
          var x = a.length;
          var y = b.length;
          var i = 0;
          var len = Math.min(x, y);
          while (i < len) {
            if (a[i] !== b[i]) break;
            ++i
          }
          if (i !== len) {
            x = a[i];
            y = b[i]
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) throw new TypeError("list argument must be an Array of Buffers.");
          if (list.length === 0) {
            return new Buffer(0)
          }
          var i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; i++) {
              length += list[i].length
            }
          }
          var buf = new Buffer(length);
          var pos = 0;
          for (i = 0; i < list.length; i++) {
            var item = list[i];
            item.copy(buf, pos);
            pos += item.length
          }
          return buf
        };

        function byteLength(string, encoding) {
          if (typeof string !== "string") string = "" + string;
          var len = string.length;
          if (len === 0) return 0;
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "binary":
              case "raw":
              case "raws":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength;
        Buffer.prototype.length = undefined;
        Buffer.prototype.parent = undefined;

        function slowToString(encoding, start, end) {
          var loweredCase = false;
          start = start | 0;
          end = end === undefined || end === Infinity ? this.length : end | 0;
          if (!encoding) encoding = "utf8";
          if (start < 0) start = 0;
          if (end > this.length) end = this.length;
          if (end <= start) return "";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "binary":
                return binarySlice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true
            }
          }
        }
        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments)
        };
        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer.compare(this, b) === 0
        };
        Buffer.prototype.inspect = function inspect() {
          var str = "";
          var max = exports.INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max) str += " ... "
          }
          return "<Buffer " + str + ">"
        };
        Buffer.prototype.compare = function compare(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
          if (this === b) return 0;
          return Buffer.compare(this, b)
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
          if (byteOffset > 2147483647) byteOffset = 2147483647;
          else if (byteOffset < -2147483648) byteOffset = -2147483648;
          byteOffset >>= 0;
          if (this.length === 0) return -1;
          if (byteOffset >= this.length) return -1;
          if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
          if (typeof val === "string") {
            if (val.length === 0) return -1;
            return String.prototype.indexOf.call(this, val, byteOffset)
          }
          if (Buffer.isBuffer(val)) {
            return arrayIndexOf(this, val, byteOffset)
          }
          if (typeof val === "number") {
            if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
              return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
            }
            return arrayIndexOf(this, [val], byteOffset)
          }

          function arrayIndexOf(arr, val, byteOffset) {
            var foundIndex = -1;
            for (var i = 0; byteOffset + i < arr.length; i++) {
              if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
              } else {
                foundIndex = -1
              }
            }
            return -1
          }
          throw new TypeError("val must be string, number or Buffer")
        };
        Buffer.prototype.get = function get(offset) {
          console.log(".get() is deprecated. Access using array indexes instead.");
          return this.readUInt8(offset)
        };
        Buffer.prototype.set = function set(v, offset) {
          console.log(".set() is deprecated. Access using array indexes instead.");
          return this.writeUInt8(v, offset)
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining
            }
          }
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new Error("Invalid hex string");
          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; i++) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) throw new Error("Invalid hex string");
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function binaryWrite(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
          if (offset === undefined) {
            encoding = "utf8";
            length = this.length;
            offset = 0
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = "utf8"
            } else {
              encoding = length;
              length = undefined
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length | 0;
            length = swap
          }
          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("attempt to write outside buffer bounds")
          }
          if (!encoding) encoding = "utf8";
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
                return asciiWrite(this, string, offset, length);
              case "binary":
                return binaryWrite(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true
            }
          }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023
            }
            res.push(codePoint);
            i += bytesPerSequence
          }
          return decodeCodePointsArray(res)
        }
        var MAX_ARGUMENTS_LENGTH = 4096;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints)
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH))
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i] & 127)
          }
          return ret
        }

        function binarySlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = "";
          for (var i = start; i < end; i++) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
          }
          return res
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }
          if (end < start) end = start;
          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = Buffer._augment(this.subarray(start, end))
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);
            for (var i = 0; i < sliceLen; i++) {
              newBuf[i] = this[i + start]
            }
          }
          if (newBuf.length) newBuf.parent = this.parent || this;
          return newBuf
        };

        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
          if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length")
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 256)) {
            val += this[offset + i] * mul
          }
          return val
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }
          var val = this[offset + --byteLength];
          var mul = 1;
          while (byteLength > 0 && (mul *= 256)) {
            val += this[offset + --byteLength] * mul
          }
          return val
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset]
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1]
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 256)) {
            val += this[offset + i] * mul
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul
          }
          mul *= 128;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128)) return this[offset];
          return (255 - this[offset] + 1) * -1
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4)
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4)
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8)
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8)
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError("buffer must be a Buffer instance");
          if (value > max || value < min) throw new RangeError("value is out of bounds");
          if (offset + ext > buf.length) throw new RangeError("index out of range")
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength && (mul *= 256)) {
            this[offset + i] = value / mul & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 255;
          return offset + 1
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 65535 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
          }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 4294967295 + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
          }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = 0;
          var mul = 1;
          var sub = value < 0 ? 1 : 0;
          this[offset] = value & 255;
          while (++i < byteLength && (mul *= 256)) {
            this[offset + i] = (value / mul >> 0) - sub & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }
          var i = byteLength - 1;
          var mul = 1;
          var sub = value < 0 ? 1 : 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = (value / mul >> 0) - sub & 255
          }
          return offset + byteLength
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8
          } else {
            objectWriteUInt16(this, value, offset, true)
          }
          return offset + 2
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255
          } else {
            objectWriteUInt16(this, value, offset, false)
          }
          return offset + 2
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24
          } else {
            objectWriteUInt32(this, value, offset, true)
          }
          return offset + 4
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0) value = 4294967295 + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255
          } else {
            objectWriteUInt32(this, value, offset, false)
          }
          return offset + 4
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (value > max || value < min) throw new RangeError("value is out of bounds");
          if (offset + ext > buf.length) throw new RangeError("index out of range");
          if (offset < 0) throw new RangeError("index out of range")
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38)
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert)
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert)
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308)
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert)
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert)
        };
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds")
          }
          if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            for (i = len - 1; i >= 0; i--) {
              target[i + targetStart] = this[i + start]
            }
          } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (i = 0; i < len; i++) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            target._set(this.subarray(start, start + len), targetStart)
          }
          return len
        };
        Buffer.prototype.fill = function fill(value, start, end) {
          if (!value) value = 0;
          if (!start) start = 0;
          if (!end) end = this.length;
          if (end < start) throw new RangeError("end < start");
          if (end === start) return;
          if (this.length === 0) return;
          if (start < 0 || start >= this.length) throw new RangeError("start out of bounds");
          if (end < 0 || end > this.length) throw new RangeError("end out of bounds");
          var i;
          if (typeof value === "number") {
            for (i = start; i < end; i++) {
              this[i] = value
            }
          } else {
            var bytes = utf8ToBytes(value.toString());
            var len = bytes.length;
            for (i = start; i < end; i++) {
              this[i] = bytes[i % len]
            }
          }
          return this
        };
        Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
          if (typeof Uint8Array !== "undefined") {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              return new Buffer(this).buffer
            } else {
              var buf = new Uint8Array(this.length);
              for (var i = 0, len = buf.length; i < len; i += 1) {
                buf[i] = this[i]
              }
              return buf.buffer
            }
          } else {
            throw new TypeError("Buffer.toArrayBuffer not supported in this browser")
          }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function _augment(arr) {
          arr.constructor = Buffer;
          arr._isBuffer = true;
          arr._set = arr.set;
          arr.get = BP.get;
          arr.set = BP.set;
          arr.write = BP.write;
          arr.toString = BP.toString;
          arr.toLocaleString = BP.toString;
          arr.toJSON = BP.toJSON;
          arr.equals = BP.equals;
          arr.compare = BP.compare;
          arr.indexOf = BP.indexOf;
          arr.copy = BP.copy;
          arr.slice = BP.slice;
          arr.readUIntLE = BP.readUIntLE;
          arr.readUIntBE = BP.readUIntBE;
          arr.readUInt8 = BP.readUInt8;
          arr.readUInt16LE = BP.readUInt16LE;
          arr.readUInt16BE = BP.readUInt16BE;
          arr.readUInt32LE = BP.readUInt32LE;
          arr.readUInt32BE = BP.readUInt32BE;
          arr.readIntLE = BP.readIntLE;
          arr.readIntBE = BP.readIntBE;
          arr.readInt8 = BP.readInt8;
          arr.readInt16LE = BP.readInt16LE;
          arr.readInt16BE = BP.readInt16BE;
          arr.readInt32LE = BP.readInt32LE;
          arr.readInt32BE = BP.readInt32BE;
          arr.readFloatLE = BP.readFloatLE;
          arr.readFloatBE = BP.readFloatBE;
          arr.readDoubleLE = BP.readDoubleLE;
          arr.readDoubleBE = BP.readDoubleBE;
          arr.writeUInt8 = BP.writeUInt8;
          arr.writeUIntLE = BP.writeUIntLE;
          arr.writeUIntBE = BP.writeUIntBE;
          arr.writeUInt16LE = BP.writeUInt16LE;
          arr.writeUInt16BE = BP.writeUInt16BE;
          arr.writeUInt32LE = BP.writeUInt32LE;
          arr.writeUInt32BE = BP.writeUInt32BE;
          arr.writeIntLE = BP.writeIntLE;
          arr.writeIntBE = BP.writeIntBE;
          arr.writeInt8 = BP.writeInt8;
          arr.writeInt16LE = BP.writeInt16LE;
          arr.writeInt16BE = BP.writeInt16BE;
          arr.writeInt32LE = BP.writeInt32LE;
          arr.writeInt32BE = BP.writeInt32BE;
          arr.writeFloatLE = BP.writeFloatLE;
          arr.writeFloatBE = BP.writeFloatBE;
          arr.writeDoubleLE = BP.writeDoubleLE;
          arr.writeDoubleBE = BP.writeDoubleBE;
          arr.fill = BP.fill;
          arr.inspect = BP.inspect;
          arr.toArrayBuffer = BP.toArrayBuffer;
          return arr
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          str = stringtrim(str).replace(INVALID_BASE64_RE, "");
          if (str.length < 2) return "";
          while (str.length % 4 !== 0) {
            str = str + "="
          }
          return str
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, "")
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16);
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; i++) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  continue
                }
                leadSurrogate = codePoint;
                continue
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue
              }
              codePoint = leadSurrogate - 55296 << 10 | codePoint - 56320 | 65536
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189)
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint)
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0) break;
              bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128)
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0) break;
              bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0) break;
              bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128)
            } else {
              throw new Error("Invalid code point")
            }
          }
          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 255)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; i++) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi)
          }
          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; i++) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i]
          }
          return i
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
      "base64-js": 2,
      ieee754: 3,
      "is-array": 4
    }],
    2: [function(require, module, exports) {
      var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      (function(exports) {
        "use strict";
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var PLUS = "+".charCodeAt(0);
        var SLASH = "/".charCodeAt(0);
        var NUMBER = "0".charCodeAt(0);
        var LOWER = "a".charCodeAt(0);
        var UPPER = "A".charCodeAt(0);
        var PLUS_URL_SAFE = "-".charCodeAt(0);
        var SLASH_URL_SAFE = "_".charCodeAt(0);

        function decode(elt) {
          var code = elt.charCodeAt(0);
          if (code === PLUS || code === PLUS_URL_SAFE) return 62;
          if (code === SLASH || code === SLASH_URL_SAFE) return 63;
          if (code < NUMBER) return -1;
          if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
          if (code < UPPER + 26) return code - UPPER;
          if (code < LOWER + 26) return code - LOWER + 26
        }

        function b64ToByteArray(b64) {
          var i, j, l, tmp, placeHolders, arr;
          if (b64.length % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4")
          }
          var len = b64.length;
          placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
          arr = new Arr(b64.length * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? b64.length - 4 : b64.length;
          var L = 0;

          function push(v) {
            arr[L++] = v
          }
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
            push((tmp & 16711680) >> 16);
            push((tmp & 65280) >> 8);
            push(tmp & 255)
          }
          if (placeHolders === 2) {
            tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
            push(tmp & 255)
          } else if (placeHolders === 1) {
            tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
            push(tmp >> 8 & 255);
            push(tmp & 255)
          }
          return arr
        }

        function uint8ToBase64(uint8) {
          var i, extraBytes = uint8.length % 3,
            output = "",
            temp, length;

          function encode(num) {
            return lookup.charAt(num)
          }

          function tripletToBase64(num) {
            return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
          }
          for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
            temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output += tripletToBase64(temp)
          }
          switch (extraBytes) {
            case 1:
              temp = uint8[uint8.length - 1];
              output += encode(temp >> 2);
              output += encode(temp << 4 & 63);
              output += "==";
              break;
            case 2:
              temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
              output += encode(temp >> 10);
              output += encode(temp >> 4 & 63);
              output += encode(temp << 2 & 63);
              output += "=";
              break
          }
          return output
        }
        exports.toByteArray = b64ToByteArray;
        exports.fromByteArray = uint8ToBase64
      })(typeof exports === "undefined" ? this.base64js = {} : exports)
    }, {}],
    3: [function(require, module, exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2
          }
          if (e + eBias >= 1) {
            value += rt / c
          } else {
            value += rt * Math.pow(2, 1 - eBias)
          }
          if (value * c >= 2) {
            e++;
            c /= 2
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128
      }
    }, {}],
    4: [function(require, module, exports) {
      var isArray = Array.isArray;
      var str = Object.prototype.toString;
      module.exports = isArray || function(val) {
        return !!val && "[object Array]" == str.call(val)
      }
    }, {}],
    5: [function(require, module, exports) {
      "use strict";

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          })
        } else {
          obj[key] = value
        }
        return obj
      }
      var Errors = require("./errors");
      var memoize = require("memoizejs");
      var DocUtils = {};

      function parser(tag) {
        return _defineProperty({}, "get", function get(scope) {
          if (tag === ".") {
            return scope
          }
          return scope[tag]
        })
      }
      DocUtils.defaults = {
        nullGetter: function nullGetter(tag, props) {
          if (props.tag === "simple") {
            return "undefined"
          }
          if (props.tag === "raw") {
            return ""
          }
          return ""
        },
        parser: memoize(parser),
        intelligentTagging: true,
        fileType: "docx",
        delimiters: {
          start: "{",
          end: "}"
        }
      };
      DocUtils.charMap = {
        "&": "&amp;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;"
      };
      DocUtils.escapeRegExp = function(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
      };
      DocUtils.charMapRegexes = Object.keys(DocUtils.charMap).map(function(endChar) {
        var startChar = DocUtils.charMap[endChar];
        return {
          rstart: new RegExp(DocUtils.escapeRegExp(startChar), "g"),
          rend: new RegExp(DocUtils.escapeRegExp(endChar), "g"),
          start: startChar,
          end: endChar
        }
      });
      DocUtils.wordToUtf8 = function(string) {
        if (typeof string !== "string") {
          string = string.toString()
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rstart, r.end)
        }
        return string
      };
      DocUtils.utf8ToWord = function(string) {
        if (typeof string !== "string") {
          string = string.toString()
        }
        var r;
        for (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {
          r = DocUtils.charMapRegexes[i];
          string = string.replace(r.rend, r.start)
        }
        return string
      };
      DocUtils.cloneDeep = function(obj) {
        return JSON.parse(JSON.stringify(obj))
      };
      var spaceRegexp = new RegExp(String.fromCharCode(160), "g");
      DocUtils.convertSpaces = function(s) {
        return s.replace(spaceRegexp, " ")
      };
      DocUtils.pregMatchAll = function(regex, content) {
        var matchArray = [];

        function replacer() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          return matchArray.push(pn)
        }
        content.replace(regex, replacer);
        return matchArray
      };
      DocUtils.sizeOfObject = function(obj) {
        return Object.keys(obj).length
      };
      DocUtils.encode_utf8 = function(s) {
        return unescape(encodeURIComponent(s))
      };
      DocUtils.decode_utf8 = function(s) {
        try {
          if (s === undefined) {
            return undefined
          }
          return decodeURIComponent(escape(DocUtils.convert_spaces(s)))
        } catch (e) {
          var err = new Errors.XTError("Could not decode utf8");
          err.properties = {
            toDecode: s,
            baseErr: e
          };
          throw err
        }
      };
      DocUtils.base64encode = function(b) {
        return btoa(unescape(encodeURIComponent(b)))
      };
      DocUtils.tags = DocUtils.defaults.delimiters;
      DocUtils.defaultParser = DocUtils.defaults.parser;
      DocUtils.convert_spaces = DocUtils.convertSpaces;
      DocUtils.preg_match_all = DocUtils.pregMatchAll;
      module.exports = DocUtils
    }, {
      "./errors": 6,
      memoizejs: 39
    }],
    6: [function(require, module, exports) {
      "use strict";

      function XTError(message) {
        this.name = "GenericError";
        this.message = message;
        this.stack = new Error(message).stack
      }
      XTError.prototype = Error.prototype;

      function XTTemplateError(message) {
        this.name = "TemplateError";
        this.message = message;
        this.stack = new Error(message).stack
      }
      XTTemplateError.prototype = new XTError;

      function XTScopeParserError(message) {
        this.name = "ScopeParserError";
        this.message = message;
        this.stack = new Error(message).stack
      }
      XTScopeParserError.prototype = new XTError;

      function XTInternalError(message) {
        this.name = "InternalError";
        this.properties = {
          explanation: "InternalError"
        };
        this.message = message;
        this.stack = new Error(message).stack
      }
      XTInternalError.prototype = new XTError;
      module.exports = {
        XTError: XTError,
        XTTemplateError: XTTemplateError,
        XTInternalError: XTInternalError,
        XTScopeParserError: XTScopeParserError
      }
    }, {}],
    7: [function(require, module, exports) {
      "use strict";
      var xmlUtil = require("./xmlUtil");
      var SubContent = require("./subContent");
      var PptXFileTypeConfig = {
        textPath: "ppt/slides/slide1.xml",
        tagsXmlArray: ["a:t", "m:t"],
        tagRawXml: "p:sp",
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file) {
            return file.name
          });
          return slideTemplates.concat(["ppt/presentation.xml"])
        },
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<a:tc>") {
              return "a:tr"
            }
          }
          return false
        }
      };
      var DocXFileTypeConfig = {
        getTemplatedFiles: function getTemplatedFiles(zip) {
          var slideTemplates = zip.file(/word\/(header|footer)\d+\.xml/).map(function(file) {
            return file.name
          });
          return slideTemplates.concat(["word/document.xml"])
        },
        textPath: "word/document.xml",
        tagsXmlArray: ["w:t", "m:t"],
        tagRawXml: "w:p",
        calcIntellegentlyDashElement: function calcIntellegentlyDashElement(content, templaterState) {
          var outer = new SubContent(content).getOuterLoop(templaterState);
          var scopeContent = xmlUtil.getListXmlElements(content.substr(outer.start, outer.end - outer.start));
          for (var i = 0, t; i < scopeContent.length; i++) {
            t = scopeContent[i];
            if (t.tag === "<w:tc>") {
              return "w:tr"
            }
          }
          return false
        }
      };
      module.exports = {
        docx: DocXFileTypeConfig,
        pptx: PptXFileTypeConfig
      }
    }, {
      "./subContent": 10,
      "./xmlUtil": 14
    }],
    8: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      module.exports = function() {
        function ModuleManager() {
          _classCallCheck(this, ModuleManager);
          var instances = {};
          this.getInstance = function(obj) {
            return instances[obj]
          };
          this.setInstance = function(key, value) {
            instances[key] = value
          };
          this.modules = []
        }
        _createClass(ModuleManager, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.modules.push(module);
            module.manager = this;
            return this
          }
        }, {
          key: "sendEvent",
          value: function sendEvent(eventName, data) {
            return this.modules.map(function(m) {
              return m.handleEvent(eventName, data)
            })
          }
        }, {
          key: "get",
          value: function get(value) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              var aux = m.get(value);
              result = aux != null ? aux : result
            }
            return result
          }
        }, {
          key: "handle",
          value: function handle(type, data) {
            var result = null;
            var iterable = this.modules;
            for (var i = 0, m; i < iterable.length; i++) {
              m = iterable[i];
              if (result != null) {
                return
              }
              var aux = m.handle(type, data);
              result = aux != null ? aux : result
            }
            return result
          }
        }]);
        return ModuleManager
      }()
    }, {}],
    9: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var Errors = require("./errors");
      var DocUtils = require("./docUtils");
      module.exports = function() {
        function ScopeManager(options) {
          _classCallCheck(this, ScopeManager);
          this.scopePath = options.scopePath;
          this.usedTags = options.usedTags;
          this.scopeList = options.scopeList;
          this.parser = options.parser;
          this.moduleManager = options.moduleManager;
          this.moduleManager.setInstance("scopeManager", this)
        }
        _createClass(ScopeManager, [{
          key: "loopOver",
          value: function loopOver(tag, callback, inverted) {
            inverted = inverted || false;
            var value = this.getValue(tag);
            return this.loopOverValue(value, callback, inverted)
          }
        }, {
          key: "functorIfInverted",
          value: function functorIfInverted(inverted, functor, value) {
            if (inverted) {
              functor(value)
            }
          }
        }, {
          key: "isValueFalsy",
          value: function isValueFalsy(value, type) {
            return value == null || !value || type === "[object Array]" && value.length === 0
          }
        }, {
          key: "loopOverValue",
          value: function loopOverValue(value, functor, inverted) {
            var type = Object.prototype.toString.call(value);
            var currentValue = this.scopeList[this.num];
            if (this.isValueFalsy(value, type)) {
              return this.functorIfInverted(inverted, functor, currentValue)
            }
            if (type === "[object Array]") {
              for (var i = 0, scope; i < value.length; i++) {
                scope = value[i];
                this.functorIfInverted(!inverted, functor, scope)
              }
              return
            }
            if (type === "[object Object]") {
              return this.functorIfInverted(!inverted, functor, value)
            }
            if (value === true) {
              return this.functorIfInverted(!inverted, functor, currentValue)
            }
          }
        }, {
          key: "getValue",
          value: function getValue(tag, num) {
            this.num = num == null ? this.scopeList.length - 1 : num;
            var err;
            var parser;
            var result;
            var scope = this.scopeList[this.num];
            try {
              parser = this.parser(tag)
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser compilation failed");
              err.properties = {
                id: "scopeparser_compilation_failed",
                tag: tag,
                explanation: "The scope parser for the tag " + tag + " failed to compile"
              };
              throw err
            }
            try {
              result = parser.get(scope)
            } catch (error) {
              err = new Errors.XTScopeParserError("Scope parser execution failed");
              err.properties = {
                id: "scopeparser_execution_failed",
                explanation: "The scope parser for the tag " + tag + " failed to execute",
                scope: scope,
                tag: tag
              };
              throw err
            }
            if (result == null && this.num > 0) {
              return this.getValue(tag, this.num - 1)
            }
            return result
          }
        }, {
          key: "getValueFromScope",
          value: function getValueFromScope(tag) {
            var result = this.getValue(tag);
            var value;
            if (result != null) {
              if (typeof result === "string") {
                this.useTag(tag, true);
                value = result
              } else if (typeof result === "number") {
                value = String(result)
              } else {
                value = result
              }
            } else {
              this.useTag(tag, false);
              return null
            }
            return value
          }
        }, {
          key: "useTag",
          value: function useTag(tag, val) {
            var u;
            if (val) {
              u = this.usedTags.def
            } else {
              u = this.usedTags.undef
            }
            var iterable = this.scopePath;
            for (var i = 0, s; i < iterable.length; i++) {
              s = iterable[i];
              if (!(u[s] != null)) {
                u[s] = {}
              }
              u = u[s]
            }
            if (tag !== "") {
              u[tag] = true
            }
          }
        }, {
          key: "createSubScopeManager",
          value: function createSubScopeManager(scope, tag) {
            var options = DocUtils.cloneDeep({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList
            });
            options.parser = this.parser;
            options.moduleManager = this.moduleManager;
            if (tag != null) {
              options.scopeList = this.scopeList.concat(scope);
              options.scopePath = this.scopePath.concat(tag)
            } else {
              options.scopeList = [];
              options.scopePath = []
            }
            return new ScopeManager(options)
          }
        }]);
        return ScopeManager
      }()
    }, {
      "./docUtils": 5,
      "./errors": 6
    }],
    10: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var Errors = require("./errors");

      function substr(baseText, start, length) {
        var text = "";
        for (var i = start; i < start + length; i++) {
          text += baseText[i]
        }
        return text
      }
      module.exports = function() {
        function SubContent(fullText) {
          _classCallCheck(this, SubContent);
          this.fullText = fullText || "";
          this.text = "";
          this.start = 0;
          this.end = 0
        }
        _createClass(SubContent, [{
          key: "getInnerLoop",
          value: function getInnerLoop(templaterState) {
            this.start = templaterState.calcEndTag(templaterState.loopOpen);
            this.end = templaterState.calcStartTag(templaterState.loopClose);
            return this.refreshText()
          }
        }, {
          key: "getOuterLoop",
          value: function getOuterLoop(templaterState) {
            this.start = templaterState.calcStartTag(templaterState.loopOpen);
            this.end = templaterState.calcEndTag(templaterState.loopClose);
            return this.refreshText()
          }
        }, {
          key: "getInnerTag",
          value: function getInnerTag(templaterState) {
            this.start = templaterState.calcPosition(templaterState.tagStart);
            this.end = templaterState.calcPosition(templaterState.tagEnd) + 1;
            return this.refreshText()
          }
        }, {
          key: "refreshText",
          value: function refreshText() {
            this.text = substr(this.fullText, this.start, this.end - this.start);
            return this
          }
        }, {
          key: "getErrorProps",
          value: function getErrorProps(xmlTag) {
            return {
              xmlTag: xmlTag,
              text: this.fullText,
              start: this.start,
              previousEnd: this.end
            }
          }
        }, {
          key: "getOuterXml",
          value: function getOuterXml(xmlTag) {
            var endCandidate = this.fullText.indexOf("</" + xmlTag + ">", this.end);
            var err;
            var startCandiate = Math.max(this.fullText.lastIndexOf("<" + xmlTag + ">", this.start), this.fullText.lastIndexOf("<" + xmlTag + " ", this.start));
            if (endCandidate === -1) {
              err = new Errors.XTTemplateError("Can't find endTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err
            }
            if (startCandiate === -1) {
              err = new Errors.XTTemplateError("Can't find startTag");
              err.properties = this.getErrorProps(xmlTag);
              throw err
            }
            this.end = endCandidate + ("</" + xmlTag + ">").length;
            this.start = startCandiate;
            return this.refreshText()
          }
        }, {
          key: "replace",
          value: function replace(newText) {
            this.fullText = this.fullText.substr(0, this.start) + newText + this.fullText.substr(this.end);
            this.end = this.start + newText.length;
            return this.refreshText()
          }
        }]);
        return SubContent
      }()
    }, {
      "./errors": 6
    }],
    11: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var Errors = require("./errors");
      var dashInnerRegex = /^-([^\s]+)\s(.+)$/;
      module.exports = function() {
        function TemplaterState(moduleManager, delimiters) {
          _classCallCheck(this, TemplaterState);
          this.moduleManager = moduleManager;
          this.moduleManager.setInstance("templaterState", this);
          this.delimiters = delimiters
        }
        _createClass(TemplaterState, [{
          key: "moveCharacters",
          value: function moveCharacters(numXmlTag, newTextLength, oldTextLength) {
            var end = this.matches.length;
            for (var k = numXmlTag; k < end; k++) {
              this.charactersAddedCumulative[k] += newTextLength - oldTextLength
            }
          }
        }, {
          key: "calcStartTag",
          value: function calcStartTag(tag) {
            return this.calcPosition(tag.start)
          }
        }, {
          key: "calcXmlTagPosition",
          value: function calcXmlTagPosition(xmlTagNumber) {
            return this.matches[xmlTagNumber].offset + this.charactersAddedCumulative[xmlTagNumber]
          }
        }, {
          key: "calcEndTag",
          value: function calcEndTag(tag) {
            return this.calcPosition(tag.end) + 1
          }
        }, {
          key: "calcPosition",
          value: function calcPosition(bracket) {
            return this.calcXmlTagPosition(bracket.numXmlTag) + this.matches[bracket.numXmlTag].array[1].length + bracket.numCharacter + this.charactersAdded[bracket.numXmlTag]
          }
        }, {
          key: "innerContent",
          value: function innerContent(type) {
            return this.matches[this[type].numXmlTag].array[2]
          }
        }, {
          key: "initialize",
          value: function initialize() {
            this.context = "";
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.inTag = false;
            this.inDashLoop = false;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.trail = "";
            this.trailSteps = [];
            this.offset = []
          }
        }, {
          key: "finalize",
          value: function finalize() {
            var err;
            var xtag;
            if (this.inForLoop === true || this.inDashLoop === true) {
              err = new Errors.XTTemplateError("Unclosed loop");
              xtag = this.loopOpen.raw;
              err.properties = {
                xtag: xtag,
                id: "unclosed_loop",
                context: this.context,
                explanation: "The loop beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
            if (this.inTag === true) {
              err = new Errors.XTTemplateError("Unclosed tag");
              xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
          }
        }, {
          key: "startTag",
          value: function startTag() {
            if (this.inTag === true) {
              var err = new Errors.XTTemplateError("Unclosed tag");
              var xtag = this.textInsideTag;
              err.properties = {
                xtag: xtag.split(" ")[0],
                id: "unclosed_tag",
                context: this.context,
                explanation: "The tag beginning with '" + xtag.substr(0, 10) + "' is unclosed"
              };
              throw err
            }
            this.currentStep = this.trailSteps[0];
            this.inTag = true;
            this.rawXmlTag = false;
            this.textInsideTag = "";
            this.tagStart = this.currentStep;
            this.trail = ""
          }
        }, {
          key: "loopType",
          value: function loopType() {
            if (this.inDashLoop) {
              return "dash"
            }
            if (this.inForLoop) {
              return "for"
            }
            if (this.rawXmlTag) {
              return "xml"
            }
            var getFromModule = this.moduleManager.get("loopType");
            if (getFromModule != null) {
              return getFromModule
            }
            return "simple"
          }
        }, {
          key: "isLoopClosingTag",
          value: function isLoopClosingTag() {
            return this.textInsideTag[0] === "/" && "/" + this.loopOpen.tag === this.textInsideTag || this.textInsideTag === "/"
          }
        }, {
          key: "finishLoop",
          value: function finishLoop() {
            this.context = "";
            this.rawXmlTag = false;
            this.inForLoop = false;
            this.loopIsInverted = false;
            this.loopOpen = null;
            this.loopClose = null;
            this.inDashLoop = false;
            this.inTag = false;
            this.textInsideTag = ""
          }
        }, {
          key: "getLeftValue",
          value: function getLeftValue() {
            return this.innerContent("tagStart").substr(0, this.tagStart.numCharacter + this.offset[this.tagStart.numXmlTag])
          }
        }, {
          key: "getRightValue",
          value: function getRightValue() {
            return this.innerContent("tagEnd").substr(this.tagEnd.numCharacter + 1 + this.offset[this.tagEnd.numXmlTag])
          }
        }, {
          key: "getMatchLocation",
          value: function getMatchLocation(num) {
            var match = this.matches[num];
            if (match.first) {
              return "first"
            }
            if (match.last) {
              return "last"
            }
            return "normal"
          }
        }, {
          key: "handleSimpleEndTag",
          value: function handleSimpleEndTag() {
            var baseLoop = this.getCurrentLoop();
            if (this.textInsideTag[0] === "@") {
              this.rawXmlTag = true;
              this.tag = this.textInsideTag.substr(1);
              return
            }
            if (this.textInsideTag[0] === "#" || this.textInsideTag[0] === "^") {
              this.inForLoop = true;
              baseLoop.tag = this.textInsideTag.substr(1);
              this.loopOpen = baseLoop;
              this.loopIsInverted = this.textInsideTag[0] === "^";
              return
            }
            if (this.textInsideTag[0] === "-") {
              this.inDashLoop = true;
              baseLoop.tag = this.textInsideTag.replace(dashInnerRegex, "$2");
              baseLoop.element = this.textInsideTag.replace(dashInnerRegex, "$1");
              this.loopOpen = baseLoop;
              return
            }
          }
        }, {
          key: "getCurrentLoop",
          value: function getCurrentLoop() {
            return {
              start: this.tagStart,
              end: this.tagEnd,
              raw: this.textInsideTag
            }
          }
        }, {
          key: "endTag",
          value: function endTag() {
            if (this.inTag === false) {
              var err = new Errors.XTTemplateError("Unopened tag");
              err.properties = {
                id: "unopened_tag",
                explanation: "Unopened tag near : '" + this.context.substr(this.context.length - 10, 10) + "'",
                context: this.context
              };
              throw err
            }
            this.inTag = false;
            this.tagEnd = this.currentStep;
            this.textInsideTag = this.textInsideTag.substr(0, this.textInsideTag.length + 1 - this.delimiters.end.length);
            this.textInsideTag = DocUtils.wordToUtf8(this.textInsideTag);
            this.fullTextTag = this.delimiters.start + this.textInsideTag + this.delimiters.end;
            if (this.loopType() === "simple") {
              return this.handleSimpleEndTag()
            }
            if (this.textInsideTag[0] === "/") {
              this.loopClose = this.getCurrentLoop()
            }
          }
        }]);
        return TemplaterState
      }()
    }, {
      "./docUtils": 5,
      "./errors": 6
    }],
    12: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var memoize = require("memoizejs");

      function handleRecursiveCase(res) {
        function replacerUnshift() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.shift();
          var match = pn.array[0] + pn.array[1];
          pn.array.unshift(match);
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.first = true;
          res.matches.unshift(pn);
          res.charactersAdded.unshift(0);
          return res.charactersAddedCumulative.unshift(0)
        }
        if (res.content.indexOf("<") === -1 && res.content.indexOf(">") === -1) {
          res.content.replace(/^()([^<>]*)$/, replacerUnshift)
        }
        var r = new RegExp("^()([^<]+)</(?:" + res.tagsXmlArrayJoined + ")>");
        res.content.replace(r, replacerUnshift);

        function replacerPush() {
          var pn = {
            array: Array.prototype.slice.call(arguments)
          };
          pn.array.pop();
          var offset = pn.array.pop();
          pn.offset = offset;
          pn.last = true;
          res.matches.push(pn);
          res.charactersAdded.push(0);
          return res.charactersAddedCumulative.push(0)
        }
        r = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^>]+)$");
        res.content.replace(r, replacerPush);
        return res
      }

      function xmlMatcher(content, tagsXmlArray) {
        var res = {};
        res.content = content;
        res.tagsXmlArray = tagsXmlArray;
        res.tagsXmlArrayJoined = res.tagsXmlArray.join("|");
        var regexp = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^<>]*)</(?:" + res.tagsXmlArrayJoined + ")>", "g");
        res.matches = DocUtils.pregMatchAll(regexp, res.content);
        res.charactersAddedCumulative = res.matches.map(function() {
          return 0
        });
        res.charactersAdded = res.matches.map(function() {
          return 0
        });
        return handleRecursiveCase(res)
      }
      var memoized = memoize(xmlMatcher);
      module.exports = function(content, tagsXmlArray) {
        return DocUtils.cloneDeep(memoized(content, tagsXmlArray))
      }
    }, {
      "./docUtils": 5,
      memoizejs: 39
    }],
    13: [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var ScopeManager = require("./scopeManager");
      var SubContent = require("./subContent");
      var TemplaterState = require("./templaterState");
      var xmlMatcher = require("./xmlMatcher");
      var ModuleManager = require("./moduleManager");
      var Errors = require("./errors");

      function _getFullText(content, tagsXmlArray) {
        var matcher = xmlMatcher(content, tagsXmlArray);
        var output = matcher.matches.map(function(match) {
          return match.array[2]
        });
        return DocUtils.wordToUtf8(DocUtils.convertSpaces(output.join("")))
      }
      module.exports = function() {
        function XmlTemplater(content, options) {
          _classCallCheck(this, XmlTemplater);
          this.fromJson(options);
          this.templaterState = new TemplaterState(this.moduleManager, this.delimiters);
          this.load(content)
        }
        _createClass(XmlTemplater, [{
          key: "load",
          value: function load(content) {
            this.content = content;
            if (typeof this.content !== "string") {
              var err = new Errors.XTInternalError("Content must be a string");
              err.properties.id = "xmltemplater_content_must_be_string";
              throw err
            }
            var result = xmlMatcher(this.content, this.fileTypeConfig.tagsXmlArray);
            this.templaterState.matches = result.matches;
            this.templaterState.charactersAddedCumulative = result.charactersAddedCumulative;
            this.templaterState.charactersAdded = result.charactersAdded
          }
        }, {
          key: "fromJson",
          value: function fromJson(options) {
            var _this = this;
            this.tags = options.tags != null ? options.tags : {};
            this.fileTypeConfig = options.fileTypeConfig;
            this.scopePath = options.scopePath != null ? options.scopePath : [];
            this.scopeList = options.scopeList != null ? options.scopeList : [this.tags];
            this.usedTags = options.usedTags != null ? options.usedTags : {
              def: {},
              undef: {}
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = options[key] != null ? options[key] : defaultValue
            });
            this.moduleManager = options.moduleManager != null ? options.moduleManager : new ModuleManager;
            this.scopeManager = new ScopeManager({
              scopePath: this.scopePath,
              usedTags: this.usedTags,
              scopeList: this.scopeList,
              parser: this.parser,
              moduleManager: this.moduleManager
            })
          }
        }, {
          key: "toJson",
          value: function toJson() {
            var _this2 = this;
            var obj = {
              fileTypeConfig: this.fileTypeConfig,
              usedTags: this.scopeManager.usedTags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).map(function(key) {
              obj[key] = _this2[key]
            });
            return obj
          }
        }, {
          key: "getFullText",
          value: function getFullText() {
            return _getFullText(this.content, this.fileTypeConfig.tagsXmlArray)
          }
        }, {
          key: "updateModuleManager",
          value: function updateModuleManager() {
            this.moduleManager.setInstance("xmlTemplater", this);
            this.moduleManager.setInstance("templaterState", this.templaterState);
            this.moduleManager.setInstance("scopeManager", this.scopeManager)
          }
        }, {
          key: "handleModuleManager",
          value: function handleModuleManager(type, data) {
            this.updateModuleManager();
            return this.moduleManager.handle(type, data)
          }
        }, {
          key: "getTrail",
          value: function getTrail(character) {
            this.templaterState.trail += character;
            var length = !this.templaterState.inTag ? this.delimiters.start.length : this.delimiters.end.length;
            return this.templaterState.trail.substr(-length, length)
          }
        }, {
          key: "handleCharacter",
          value: function handleCharacter(character) {
            if (this.templaterState.trail === this.delimiters.start && (this.templaterState.inTag === false || this.sameTags === false)) {
              this.templaterState.startTag()
            } else if (this.templaterState.trail === this.delimiters.end && (this.templaterState.inTag === true || this.sameTags === false)) {
              this.updateModuleManager();
              this.templaterState.endTag();
              this.loopClose()
            } else if (this.templaterState.inTag === true) {
              this.templaterState.textInsideTag += character
            }
          }
        }, {
          key: "forEachCharacter",
          value: function forEachCharacter(functor) {
            var matches = this.templaterState.matches;
            for (var numXmlTag = 0, match; numXmlTag < matches.length; numXmlTag++) {
              match = matches[numXmlTag];
              var innerText = match.array[2];
              this.templaterState.offset[numXmlTag] = 0;
              if (this.templaterState.trail.length === 0 && !this.templaterState.inTag && innerText.indexOf(this.delimiters.start[0]) === -1 && innerText.indexOf(this.delimiters.end[0]) === -1) {
                continue
              }
              for (var numCharacter = 0, character; numCharacter < innerText.length; numCharacter++) {
                character = innerText[numCharacter];
                this.templaterState.trail = this.getTrail(character);
                this.templaterState.currentStep = {
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                };
                this.templaterState.trailSteps.push({
                  numXmlTag: numXmlTag,
                  numCharacter: numCharacter
                });
                this.templaterState.trailSteps = this.templaterState.trailSteps.splice(-this.delimiters.start.length, this.delimiters.start.length);
                this.templaterState.context += character;
                functor(character, numXmlTag, numCharacter)
              }
            }
          }
        }, {
          key: "render",
          value: function render() {
            this.sameTags = this.delimiters.start === this.delimiters.end;
            this.templaterState.initialize();
            this.handleModuleManager("xmlRendering");
            this.forEachCharacter(this.handleCharacter.bind(this));
            this.handleModuleManager("xmlRendered");
            this.templaterState.finalize();
            return this
          }
        }, {
          key: "loopClose",
          value: function loopClose() {
            var loopType = this.templaterState.loopType();
            if (loopType === "simple") {
              this.replaceSimpleTag()
            }
            if (loopType === "xml") {
              this.replaceSimpleTagRawXml()
            }
            if (["dash", "for"].indexOf(loopType) !== -1 && this.templaterState.isLoopClosingTag()) {
              this.replaceLoopTag();
              this.templaterState.finishLoop()
            }
            if (["simple", "dash", "for", "xml"].indexOf(loopType) === -1) {
              this.handleModuleManager("replaceTag", loopType)
            }
          }
        }, {
          key: "replaceSimpleTag",
          value: function replaceSimpleTag() {
            var newValue = this.scopeManager.getValueFromScope(this.templaterState.textInsideTag);
            if (newValue == null) {
              newValue = this.nullGetter(this.templaterState.textInsideTag, {
                tag: "simple"
              })
            }
            this.content = this.replaceTagByValue(DocUtils.utf8ToWord(newValue), this.content)
          }
        }, {
          key: "replaceSimpleTagRawXml",
          value: function replaceSimpleTagRawXml() {
            var outerXml;
            var newText = this.scopeManager.getValueFromScope(this.templaterState.tag);
            if (newText == null) {
              newText = this.nullGetter(this.templaterState.tag, {
                tag: "raw"
              })
            }
            var subContent = new SubContent(this.content);
            subContent.getInnerTag(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(this.fileTypeConfig.tagRawXml)
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "raw_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The raw tag " + error.properties.xtag + " is not valid in this context."
              }
              throw error
            }
            var fullText = _getFullText(outerXml.text, this.fileTypeConfig.tagsXmlArray);
            if (this.templaterState.fullTextTag !== fullText) {
              var err = new Errors.XTTemplateError("Raw xml tag should be the only text in paragraph");
              err.properties = {
                id: "raw_xml_tag_should_be_only_text_in_paragraph",
                paragraphContent: fullText,
                fullTag: this.templaterState.fullTextTag,
                xtag: this.templaterState.textInsideTag,
                explanation: "The tag : '" + this.templaterState.fullTextTag + "' should be the the only text in the paragraph (it contains '" + fullText + "')"
              };
              throw err
            }
            return this.replaceXml(outerXml, newText)
          }
        }, {
          key: "replaceXml",
          value: function replaceXml(subContent, newText) {
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, newText.length, subContent.text.length);
            this.content = subContent.replace(newText).fullText;
            return this.content
          }
        }, {
          key: "deleteTag",
          value: function deleteTag(xml, tag) {
            this.templaterState.tagStart = tag.start;
            this.templaterState.tagEnd = tag.end;
            this.templaterState.textInsideTag = tag.raw;
            return this.replaceTagByValue("", xml)
          }
        }, {
          key: "deleteOuterTags",
          value: function deleteOuterTags(outerXmlText) {
            return this.deleteTag(this.deleteTag(outerXmlText, this.templaterState.loopOpen), this.templaterState.loopClose)
          }
        }, {
          key: "dashLoop",
          value: function dashLoop(elementDashLoop, sharp) {
            sharp = sharp || false;
            var outerXml;
            var subContent = new SubContent(this.content);
            subContent.getInnerLoop(this.templaterState);
            try {
              outerXml = subContent.getOuterXml(elementDashLoop)
            } catch (error) {
              if (error instanceof Errors.XTTemplateError) {
                error.properties.id = "dashloop_tag_outerxml_invalid";
                error.properties.xtag = this.templaterState.textInsideTag;
                error.properties.explanation = "The dashLoop tag " + error.properties.xtag + " is not valid in this context."
              }
              throw error
            }
            this.templaterState.moveCharacters(0, 0, outerXml.start);
            var outerXmlText = outerXml.text;
            var innerXmlText = this.deleteOuterTags(outerXmlText, sharp);
            this.templaterState.moveCharacters(0, outerXml.start, 0);
            this.templaterState.moveCharacters(this.templaterState.tagStart.numXmlTag, outerXmlText.length, innerXmlText.length);
            return this.forLoop(outerXml, innerXmlText)
          }
        }, {
          key: "xmlToBeReplaced",
          value: function xmlToBeReplaced(options) {
            var before = "";
            var after = "";
            if (options.noStartTag) {
              return [options.insideValue]
            }
            if (options.spacePreserve && options.tag === "w:t") {
              before = "<" + options.fullTag + ' xml:space="preserve">'
            } else {
              before = this.templaterState.matches[options.xmlTagNumber].array[1]
            }
            if (!options.noEndTag) {
              after = "</" + options.tag + ">"
            }
            return [before, options.insideValue, after]
          }
        }, {
          key: "replaceFirstFrom",
          value: function replaceFirstFrom(string, search, replace, from) {
            var rightPart = string.substr(from + search.length);
            var leftPart = string.substr(0, from);
            var middlePart = string.substr(from, search.length);
            if (middlePart !== search) {
              var err = new Errors.XTInternalError("Match not found in content");
              err.properties.id = "xmltemplater_match_not_found_in_content";
              err.properties.search = search;
              err.properties.middlePart = middlePart;
              err.properties.content = string;
              throw err
            }
            return leftPart + replace + rightPart
          }
        }, {
          key: "replaceXmlTag",
          value: function replaceXmlTag(content, options) {
            this.templaterState.offset[options.xmlTagNumber] += options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            options.fullTag = this.templaterState.matches[options.xmlTagNumber].array[1].replace(/^<([^>]+)>$/, "$1");
            options.tag = options.fullTag.replace(/([^ ]*).*/, "$1");
            options.spacePreserve = options.spacePreserve != null ? options.spacePreserve : true;
            options.spacePreserve = options.spacePreserve && this.templaterState.matches[options.xmlTagNumber].array[1].indexOf('xml:space="preserve"') === -1;
            options.noStartTag = options.noStartTag != null ? options.noStartTag : false;
            options.noEndTag = options.noEndTag != null ? options.noEndTag : false;
            var replacer = this.xmlToBeReplaced(options);
            if (replacer.length > 1) {
              this.templaterState.matches[options.xmlTagNumber].array[1] = replacer[0]
            }
            this.templaterState.charactersAdded[options.xmlTagNumber] = options.insideValue.length - this.templaterState.matches[options.xmlTagNumber].array[2].length;
            this.templaterState.matches[options.xmlTagNumber].array[2] = options.insideValue;
            replacer = replacer.join("");
            var startTag = this.templaterState.calcXmlTagPosition(options.xmlTagNumber);
            this.templaterState.moveCharacters(options.xmlTagNumber + 1, replacer.length, this.templaterState.matches[options.xmlTagNumber].array[0].length);
            content = this.replaceFirstFrom(content, this.templaterState.matches[options.xmlTagNumber].array[0], replacer, startTag);
            this.templaterState.matches[options.xmlTagNumber].array[0] = replacer;
            return content
          }
        }, {
          key: "replaceTagByValue",
          value: function replaceTagByValue(newValue, content) {
            var location = this.templaterState.getMatchLocation(this.templaterState.tagStart.numXmlTag);
            var options = {
              xmlTagNumber: this.templaterState.tagStart.numXmlTag,
              noStartTag: location === "first",
              noEndTag: location === "last"
            };
            if (this.templaterState.tagEnd.numXmlTag === this.templaterState.tagStart.numXmlTag) {
              options.insideValue = this.templaterState.getLeftValue() + newValue + this.templaterState.getRightValue();
              return this.replaceXmlTag(content, options)
            } else if (this.templaterState.tagEnd.numXmlTag > this.templaterState.tagStart.numXmlTag) {
              if (location === "normal") {
                options.insideValue = this.templaterState.getLeftValue() + newValue
              } else {
                options.insideValue = newValue
              }
              content = this.replaceXmlTag(content, options);
              options = {
                insideValue: "",
                spacePreserve: false
              };
              var start = this.templaterState.tagStart.numXmlTag + 1;
              var end = this.templaterState.tagEnd.numXmlTag;
              for (var k = start; k < end; k++) {
                options.xmlTagNumber = k;
                content = this.replaceXmlTag(content, options)
              }
              options = {
                insideValue: this.templaterState.getRightValue(),
                spacePreserve: true,
                xmlTagNumber: this.templaterState.tagEnd.numXmlTag,
                noEndTag: this.templaterState.getMatchLocation(this.templaterState.tagEnd.numXmlTag) === "last"
              };
              return this.replaceXmlTag(content, options)
            }
          }
        }, {
          key: "replaceLoopTag",
          value: function replaceLoopTag() {
            if (this.templaterState.loopType() === "dash") {
              return this.dashLoop(this.templaterState.loopOpen.element)
            }
            if (this.intelligentTagging === true) {
              var dashElement = this.fileTypeConfig.calcIntellegentlyDashElement(this.content, this.templaterState);
              if (dashElement !== false) {
                return this.dashLoop(dashElement, true)
              }
            }
            var outerLoop = new SubContent(this.content).getOuterLoop(this.templaterState);
            var innerTemplate = new SubContent(this.content).getInnerLoop(this.templaterState).text;
            return this.forLoop(outerLoop, innerTemplate)
          }
        }, {
          key: "calcSubXmlTemplater",
          value: function calcSubXmlTemplater(innerTagsContent, argOptions) {
            var options = this.toJson();
            options.tags = argOptions.tags;
            options.scopeList = this.scopeList.concat(argOptions.tags);
            options.scopePath = this.scopePath.concat(this.templaterState.loopOpen.tag);
            var subXml = new XmlTemplater(innerTagsContent, options);
            return subXml
          }
        }, {
          key: "forLoop",
          value: function forLoop(outerTags, subTemplate) {
            var _this3 = this;
            var tag = this.templaterState.loopOpen.tag;
            var newContent = "";
            var loopFn = function loopFn(subTags) {
              newContent += _this3.calcSubXmlTemplater(subTemplate, {
                tags: subTags
              }).render().content;
              return newContent
            };
            this.scopeManager.loopOver(tag, loopFn, this.templaterState.loopIsInverted);
            this.calcSubXmlTemplater(subTemplate, {
              tags: {}
            }).render();
            return this.replaceXml(outerTags, newContent)
          }
        }]);
        return XmlTemplater
      }()
    }, {
      "./docUtils": 5,
      "./errors": 6,
      "./moduleManager": 8,
      "./scopeManager": 9,
      "./subContent": 10,
      "./templaterState": 11,
      "./xmlMatcher": 12
    }],
    14: [function(require, module, exports) {
      "use strict";
      var DocUtils = require("./docUtils");
      var XmlUtil = {};

      function addTag(array, tag) {
        return array.concat([{
          tag: "<" + tag.array[1] + ">",
          offset: tag.offset
        }])
      }

      function lastTagIsOpenTag(array, tag) {
        if (array.length === 0) {
          return false
        }
        var lastTag = array[array.length - 1];
        var innerLastTag = lastTag.tag.substr(1, lastTag.tag.length - 2);
        var innerCurrentTag = tag.array[1].substr(1);
        return innerLastTag === innerCurrentTag
      }
      XmlUtil.getListXmlElements = function(text) {
        var tags = DocUtils.pregMatchAll(/<(\/?[^\/> ]+)([^>]*)>/g, text);
        var result = [];
        for (var i = 0, tag; i < tags.length; i++) {
          tag = tags[i];
          if (tag.array[1][0] === "/") {
            var justOpened = lastTagIsOpenTag(result, tag);
            if (justOpened) {
              result.pop()
            } else {
              result = addTag(result, tag)
            }
          } else if (tag.array[2][tag.array[2].length - 1] !== "/") {
            result = addTag(result, tag)
          }
        }
        return result
      };
      module.exports = XmlUtil
    }, {
      "./docUtils": 5
    }],
    15: [function(require, module, exports) {
      "use strict";
      var DataReader = require("./dataReader");

      function ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0;
          for (var i = 0; i < this.data.length; i++) {
            data[i] = data[i] & 255
          }
        }
      }
      ArrayReader.prototype = new DataReader;
      ArrayReader.prototype.byteAt = function(i) {
        return this.data[this.zero + i]
      };
      ArrayReader.prototype.lastIndexOfSignature = function(sig) {
        var sig0 = sig.charCodeAt(0),
          sig1 = sig.charCodeAt(1),
          sig2 = sig.charCodeAt(2),
          sig3 = sig.charCodeAt(3);
        for (var i = this.length - 4; i >= 0; --i) {
          if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero
          }
        }
        return -1
      };
      ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return []
        }
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = ArrayReader
    }, {
      "./dataReader": 20
    }],
    16: [function(require, module, exports) {
      "use strict";
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      exports.encode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64
          } else if (isNaN(chr3)) {
            enc4 = 64
          }
          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)
        }
        return output
      };
      exports.decode = function(input, utf8) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2)
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3)
          }
        }
        return output
      }
    }, {}],
    17: [function(require, module, exports) {
      "use strict";

      function CompressedObject() {
        this.compressedSize = 0;
        this.uncompressedSize = 0;
        this.crc32 = 0;
        this.compressionMethod = null;
        this.compressedContent = null
      }
      CompressedObject.prototype = {
        getContent: function() {
          return null
        },
        getCompressedContent: function() {
          return null
        }
      };
      module.exports = CompressedObject
    }, {}],
    18: [function(require, module, exports) {
      "use strict";
      exports.STORE = {
        magic: "\x00\x00",
        compress: function(content, compressionOptions) {
          return content
        },
        uncompress: function(content) {
          return content
        },
        compressInputType: null,
        uncompressInputType: null
      };
      exports.DEFLATE = require("./flate")
    }, {
      "./flate": 23
    }],
    19: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
      module.exports = function crc32(input, crc) {
        if (typeof input === "undefined" || !input.length) {
          return 0
        }
        var isArray = utils.getTypeOf(input) !== "string";
        if (typeof crc == "undefined") {
          crc = 0
        }
        var x = 0;
        var y = 0;
        var b = 0;
        crc = crc ^ -1;
        for (var i = 0, iTop = input.length; i < iTop; i++) {
          b = isArray ? input[i] : input.charCodeAt(i);
          y = (crc ^ b) & 255;
          x = table[y];
          crc = crc >>> 8 ^ x
        }
        return crc ^ -1
      }
    }, {
      "./utils": 36
    }],
    20: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");

      function DataReader(data) {
        this.data = null;
        this.length = 0;
        this.index = 0;
        this.zero = 0
      }
      DataReader.prototype = {
        checkOffset: function(offset) {
          this.checkIndex(this.index + offset)
        },
        checkIndex: function(newIndex) {
          if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?")
          }
        },
        setIndex: function(newIndex) {
          this.checkIndex(newIndex);
          this.index = newIndex
        },
        skip: function(n) {
          this.setIndex(this.index + n)
        },
        byteAt: function(i) {},
        readInt: function(size) {
          var result = 0,
            i;
          this.checkOffset(size);
          for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i)
          }
          this.index += size;
          return result
        },
        readString: function(size) {
          return utils.transformTo("string", this.readData(size))
        },
        readData: function(size) {},
        lastIndexOfSignature: function(sig) {},
        readDate: function() {
          var dostime = this.readInt(4);
          return new Date((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1)
        }
      };
      module.exports = DataReader
    }, {
      "./utils": 36
    }],
    21: [function(require, module, exports) {
      "use strict";
      exports.base64 = false;
      exports.binary = false;
      exports.dir = false;
      exports.createFolders = false;
      exports.date = null;
      exports.compression = null;
      exports.compressionOptions = null;
      exports.comment = null;
      exports.unixPermissions = null;
      exports.dosPermissions = null
    }, {}],
    22: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      exports.string2binary = function(str) {
        return utils.string2binary(str)
      };
      exports.string2Uint8Array = function(str) {
        return utils.transformTo("uint8array", str)
      };
      exports.uint8Array2String = function(array) {
        return utils.transformTo("string", array)
      };
      exports.string2Blob = function(str) {
        var buffer = utils.transformTo("arraybuffer", str);
        return utils.arrayBuffer2Blob(buffer)
      };
      exports.arrayBuffer2Blob = function(buffer) {
        return utils.arrayBuffer2Blob(buffer)
      };
      exports.transformTo = function(outputType, input) {
        return utils.transformTo(outputType, input)
      };
      exports.getTypeOf = function(input) {
        return utils.getTypeOf(input)
      };
      exports.checkSupport = function(type) {
        return utils.checkSupport(type)
      };
      exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
      exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
      exports.pretty = function(str) {
        return utils.pretty(str)
      };
      exports.findCompression = function(compressionMethod) {
        return utils.findCompression(compressionMethod)
      };
      exports.isRegExp = function(object) {
        return utils.isRegExp(object)
      }
    }, {
      "./utils": 36
    }],
    23: [function(require, module, exports) {
      "use strict";
      var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
      var pako = require("pako");
      exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.magic = "\b\x00";
      exports.compress = function(input, compressionOptions) {
        return pako.deflateRaw(input, {
          level: compressionOptions.level || -1
        })
      };
      exports.uncompress = function(input) {
        return pako.inflateRaw(input)
      }
    }, {
      pako: 40
    }],
    24: [function(require, module, exports) {
      "use strict";
      var base64 = require("./base64");

      function JSZip(data, options) {
        if (!(this instanceof JSZip)) return new JSZip(data, options);
        this.files = {};
        this.comment = null;
        this.root = "";
        if (data) {
          this.load(data, options)
        }
        this.clone = function() {
          var newObj = new JSZip;
          for (var i in this) {
            if (typeof this[i] !== "function") {
              newObj[i] = this[i]
            }
          }
          return newObj
        }
      }
      JSZip.prototype = require("./object");
      JSZip.prototype.load = require("./load");
      JSZip.support = require("./support");
      JSZip.defaults = require("./defaults");
      JSZip.utils = require("./deprecatedPublicUtils");
      JSZip.base64 = {
        encode: function(input) {
          return base64.encode(input)
        },
        decode: function(input) {
          return base64.decode(input)
        }
      };
      JSZip.compressions = require("./compressions");
      module.exports = JSZip
    }, {
      "./base64": 16,
      "./compressions": 18,
      "./defaults": 21,
      "./deprecatedPublicUtils": 22,
      "./load": 25,
      "./object": 28,
      "./support": 32
    }],
    25: [function(require, module, exports) {
      "use strict";
      var base64 = require("./base64");
      var utf8 = require("./utf8");
      var utils = require("./utils");
      var ZipEntries = require("./zipEntries");
      module.exports = function(data, options) {
        var files, zipEntries, i, input;
        options = utils.extend(options || {}, {
          base64: false,
          checkCRC32: false,
          optimizedBinaryString: false,
          createFolders: false,
          decodeFileName: utf8.utf8decode
        });
        if (options.base64) {
          data = base64.decode(data)
        }
        zipEntries = new ZipEntries(data, options);
        files = zipEntries.files;
        for (i = 0; i < files.length; i++) {
          input = files[i];
          this.file(input.fileNameStr, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          })
        }
        if (zipEntries.zipComment.length) {
          this.comment = zipEntries.zipComment
        }
        return this
      }
    }, {
      "./base64": 16,
      "./utf8": 35,
      "./utils": 36,
      "./zipEntries": 37
    }],
    26: [function(require, module, exports) {
      (function(Buffer) {
        "use strict";
        module.exports = function(data, encoding) {
          return new Buffer(data, encoding)
        };
        module.exports.test = function(b) {
          return Buffer.isBuffer(b)
        }
      }).call(this, require("buffer").Buffer)
    }, {
      buffer: 1
    }],
    27: [function(require, module, exports) {
      "use strict";
      var Uint8ArrayReader = require("./uint8ArrayReader");

      function NodeBufferReader(data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0
      }
      NodeBufferReader.prototype = new Uint8ArrayReader;
      NodeBufferReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = NodeBufferReader
    }, {
      "./uint8ArrayReader": 33
    }],
    28: [function(require, module, exports) {
      "use strict";
      var support = require("./support");
      var utils = require("./utils");
      var crc32 = require("./crc32");
      var signature = require("./signature");
      var defaults = require("./defaults");
      var base64 = require("./base64");
      var compressions = require("./compressions");
      var CompressedObject = require("./compressedObject");
      var nodeBuffer = require("./nodeBuffer");
      var utf8 = require("./utf8");
      var StringWriter = require("./stringWriter");
      var Uint8ArrayWriter = require("./uint8ArrayWriter");
      var getRawData = function(file) {
        if (file._data instanceof CompressedObject) {
          file._data = file._data.getContent();
          file.options.binary = true;
          file.options.base64 = false;
          if (utils.getTypeOf(file._data) === "uint8array") {
            var copy = file._data;
            file._data = new Uint8Array(copy.length);
            if (copy.length !== 0) {
              file._data.set(copy, 0)
            }
          }
        }
        return file._data
      };
      var getBinaryData = function(file) {
        var result = getRawData(file),
          type = utils.getTypeOf(result);
        if (type === "string") {
          if (!file.options.binary) {
            if (support.nodebuffer) {
              return nodeBuffer(result, "utf-8")
            }
          }
          return file.asBinary()
        }
        return result
      };
      var dataToString = function(asUTF8) {
        var result = getRawData(this);
        if (result === null || typeof result === "undefined") {
          return ""
        }
        if (this.options.base64) {
          result = base64.decode(result)
        }
        if (asUTF8 && this.options.binary) {
          result = out.utf8decode(result)
        } else {
          result = utils.transformTo("string", result)
        }
        if (!asUTF8 && !this.options.binary) {
          result = utils.transformTo("string", out.utf8encode(result))
        }
        return result
      };
      var ZipObject = function(name, data, options) {
        this.name = name;
        this.dir = options.dir;
        this.date = options.date;
        this.comment = options.comment;
        this.unixPermissions = options.unixPermissions;
        this.dosPermissions = options.dosPermissions;
        this._data = data;
        this.options = options;
        this._initialMetadata = {
          dir: options.dir,
          date: options.date
        }
      };
      ZipObject.prototype = {
        asText: function() {
          return dataToString.call(this, true)
        },
        asBinary: function() {
          return dataToString.call(this, false)
        },
        asNodeBuffer: function() {
          var result = getBinaryData(this);
          return utils.transformTo("nodebuffer", result)
        },
        asUint8Array: function() {
          var result = getBinaryData(this);
          return utils.transformTo("uint8array", result)
        },
        asArrayBuffer: function() {
          return this.asUint8Array().buffer
        }
      };
      var decToHex = function(dec, bytes) {
        var hex = "",
          i;
        for (i = 0; i < bytes; i++) {
          hex += String.fromCharCode(dec & 255);
          dec = dec >>> 8
        }
        return hex
      };
      var prepareFileAttrs = function(o) {
        o = o || {};
        if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
          o.binary = true
        }
        o = utils.extend(o, defaults);
        o.date = o.date || new Date;
        if (o.compression !== null) o.compression = o.compression.toUpperCase();
        return o
      };
      var fileAdd = function(name, data, o) {
        var dataType = utils.getTypeOf(data),
          parent;
        o = prepareFileAttrs(o);
        if (typeof o.unixPermissions === "string") {
          o.unixPermissions = parseInt(o.unixPermissions, 8)
        }
        if (o.unixPermissions && o.unixPermissions & 16384) {
          o.dir = true
        }
        if (o.dosPermissions && o.dosPermissions & 16) {
          o.dir = true
        }
        if (o.dir) {
          name = forceTrailingSlash(name)
        }
        if (o.createFolders && (parent = parentFolder(name))) {
          folderAdd.call(this, parent, true)
        }
        if (o.dir || data === null || typeof data === "undefined") {
          o.base64 = false;
          o.binary = false;
          data = null;
          dataType = null
        } else if (dataType === "string") {
          if (o.binary && !o.base64) {
            if (o.optimizedBinaryString !== true) {
              data = utils.string2binary(data)
            }
          }
        } else {
          o.base64 = false;
          o.binary = true;
          if (!dataType && !(data instanceof CompressedObject)) {
            throw new Error("The data of '" + name + "' is in an unsupported format !")
          }
          if (dataType === "arraybuffer") {
            data = utils.transformTo("uint8array", data)
          }
        }
        var object = new ZipObject(name, data, o);
        this.files[name] = object;
        return object
      };
      var parentFolder = function(path) {
        if (path.slice(-1) == "/") {
          path = path.substring(0, path.length - 1)
        }
        var lastSlash = path.lastIndexOf("/");
        return lastSlash > 0 ? path.substring(0, lastSlash) : ""
      };
      var forceTrailingSlash = function(path) {
        if (path.slice(-1) != "/") {
          path += "/"
        }
        return path
      };
      var folderAdd = function(name, createFolders) {
        createFolders = typeof createFolders !== "undefined" ? createFolders : false;
        name = forceTrailingSlash(name);
        if (!this.files[name]) {
          fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
          })
        }
        return this.files[name]
      };
      var generateCompressedObjectFrom = function(file, compression, compressionOptions) {
        var result = new CompressedObject,
          content;
        if (file._data instanceof CompressedObject) {
          result.uncompressedSize = file._data.uncompressedSize;
          result.crc32 = file._data.crc32;
          if (result.uncompressedSize === 0 || file.dir) {
            compression = compressions["STORE"];
            result.compressedContent = "";
            result.crc32 = 0
          } else if (file._data.compressionMethod === compression.magic) {
            result.compressedContent = file._data.getCompressedContent()
          } else {
            content = file._data.getContent();
            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions)
          }
        } else {
          content = getBinaryData(file);
          if (!content || content.length === 0 || file.dir) {
            compression = compressions["STORE"];
            content = ""
          }
          result.uncompressedSize = content.length;
          result.crc32 = crc32(content);
          result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions)
        }
        result.compressedSize = result.compressedContent.length;
        result.compressionMethod = compression.magic;
        return result
      };
      var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
        var result = unixPermissions;
        if (!unixPermissions) {
          result = isDir ? 16893 : 33204
        }
        return (result & 65535) << 16
      };
      var generateDosExternalFileAttr = function(dosPermissions, isDir) {
        return (dosPermissions || 0) & 63
      };
      var generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {
        var data = compressedObject.compressedContent,
          useCustomEncoding = encodeFileName !== utf8.utf8encode,
          encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
          utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
          comment = file.comment || "",
          encodedComment = utils.transformTo("string", encodeFileName(comment)),
          utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
          useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
          useUTF8ForComment = utfEncodedComment.length !== comment.length,
          o = file.options,
          dosTime, dosDate, extraFields = "",
          unicodePathExtraField = "",
          unicodeCommentExtraField = "",
          dir, date;
        if (file._initialMetadata.dir !== file.dir) {
          dir = file.dir
        } else {
          dir = o.dir
        }
        if (file._initialMetadata.date !== file.date) {
          date = file.date
        } else {
          date = o.date
        }
        var extFileAttr = 0;
        var versionMadeBy = 0;
        if (dir) {
          extFileAttr |= 16
        }
        if (platform === "UNIX") {
          versionMadeBy = 798;
          extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir)
        } else {
          versionMadeBy = 20;
          extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir)
        }
        dosTime = date.getHours();
        dosTime = dosTime << 6;
        dosTime = dosTime | date.getMinutes();
        dosTime = dosTime << 5;
        dosTime = dosTime | date.getSeconds() / 2;
        dosDate = date.getFullYear() - 1980;
        dosDate = dosDate << 4;
        dosDate = dosDate | date.getMonth() + 1;
        dosDate = dosDate << 5;
        dosDate = dosDate | date.getDate();
        if (useUTF8ForFileName) {
          unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
          extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField
        }
        if (useUTF8ForComment) {
          unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(encodedComment), 4) + utfEncodedComment;
          extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField
        }
        var header = "";
        header += "\n\x00";
        header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\x00\b" : "\x00\x00";
        header += compressedObject.compressionMethod;
        header += decToHex(dosTime, 2);
        header += decToHex(dosDate, 2);
        header += decToHex(compressedObject.crc32, 4);
        header += decToHex(compressedObject.compressedSize, 4);
        header += decToHex(compressedObject.uncompressedSize, 4);
        header += decToHex(encodedFileName.length, 2);
        header += decToHex(extraFields.length, 2);
        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
        var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\x00\x00" + "\x00\x00" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
        return {
          fileRecord: fileRecord,
          dirRecord: dirRecord,
          compressedObject: compressedObject
        }
      };
      var out = {
        load: function(stream, options) {
          throw new Error("Load method is not defined. Is the file jszip-load.js included ?")
        },
        filter: function(search) {
          var result = [],
            filename, relativePath, file, fileClone;
          for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
              continue
            }
            file = this.files[filename];
            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));
            relativePath = filename.slice(this.root.length, filename.length);
            if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone)) {
              result.push(fileClone)
            }
          }
          return result
        },
        file: function(name, data, o) {
          if (arguments.length === 1) {
            if (utils.isRegExp(name)) {
              var regexp = name;
              return this.filter(function(relativePath, file) {
                return !file.dir && regexp.test(relativePath)
              })
            } else {
              return this.filter(function(relativePath, file) {
                return !file.dir && relativePath === name
              })[0] || null
            }
          } else {
            name = this.root + name;
            fileAdd.call(this, name, data, o)
          }
          return this
        },
        folder: function(arg) {
          if (!arg) {
            return this
          }
          if (utils.isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
              return file.dir && arg.test(relativePath)
            })
          }
          var name = this.root + arg;
          var newFolder = folderAdd.call(this, name);
          var ret = this.clone();
          ret.root = newFolder.name;
          return ret
        },
        remove: function(name) {
          name = this.root + name;
          var file = this.files[name];
          if (!file) {
            if (name.slice(-1) != "/") {
              name += "/"
            }
            file = this.files[name]
          }
          if (file && !file.dir) {
            delete this.files[name]
          } else {
            var kids = this.filter(function(relativePath, file) {
              return file.name.slice(0, name.length) === name
            });
            for (var i = 0; i < kids.length; i++) {
              delete this.files[kids[i].name]
            }
          }
          return this
        },
        generate: function(options) {
          options = utils.extend(options || {}, {
            base64: true,
            compression: "STORE",
            compressionOptions: null,
            type: "base64",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          utils.checkSupport(options.type);
          if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
            options.platform = "UNIX"
          }
          if (options.platform === "win32") {
            options.platform = "DOS"
          }
          var zipData = [],
            localDirLength = 0,
            centralDirLength = 0,
            writer, i, encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
          for (var name in this.files) {
            if (!this.files.hasOwnProperty(name)) {
              continue
            }
            var file = this.files[name];
            var compressionName = file.options.compression || options.compression.toUpperCase();
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !")
            }
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
            centralDirLength += zipPart.dirRecord.length;
            zipData.push(zipPart)
          }
          var dirEnd = "";
          dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
          var typeName = options.type.toLowerCase();
          if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length)
          } else {
            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length)
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].fileRecord);
            writer.append(zipData[i].compressedObject.compressedContent)
          }
          for (i = 0; i < zipData.length; i++) {
            writer.append(zipData[i].dirRecord)
          }
          writer.append(dirEnd);
          var zip = writer.finalize();
          switch (options.type.toLowerCase()) {
            case "uint8array":
            case "arraybuffer":
            case "nodebuffer":
              return utils.transformTo(options.type.toLowerCase(), zip);
            case "blob":
              return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
            case "base64":
              return options.base64 ? base64.encode(zip) : zip;
            default:
              return zip
          }
        },
        crc32: function(input, crc) {
          return crc32(input, crc)
        },
        utf8encode: function(string) {
          return utils.transformTo("string", utf8.utf8encode(string))
        },
        utf8decode: function(input) {
          return utf8.utf8decode(input)
        }
      };
      module.exports = out
    }, {
      "./base64": 16,
      "./compressedObject": 17,
      "./compressions": 18,
      "./crc32": 19,
      "./defaults": 21,
      "./nodeBuffer": 26,
      "./signature": 29,
      "./stringWriter": 31,
      "./support": 32,
      "./uint8ArrayWriter": 34,
      "./utf8": 35,
      "./utils": 36
    }],
    29: [function(require, module, exports) {
      "use strict";
      exports.LOCAL_FILE_HEADER = "PK";
      exports.CENTRAL_FILE_HEADER = "PK";
      exports.CENTRAL_DIRECTORY_END = "PK";
      exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK";
      exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
      exports.DATA_DESCRIPTOR = "PK\b"
    }, {}],
    30: [function(require, module, exports) {
      "use strict";
      var DataReader = require("./dataReader");
      var utils = require("./utils");

      function StringReader(data, optimizedBinaryString) {
        this.data = data;
        if (!optimizedBinaryString) {
          this.data = utils.string2binary(this.data)
        }
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0
      }
      StringReader.prototype = new DataReader;
      StringReader.prototype.byteAt = function(i) {
        return this.data.charCodeAt(this.zero + i)
      };
      StringReader.prototype.lastIndexOfSignature = function(sig) {
        return this.data.lastIndexOf(sig) - this.zero
      };
      StringReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = StringReader
    }, {
      "./dataReader": 20,
      "./utils": 36
    }],
    31: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var StringWriter = function() {
        this.data = []
      };
      StringWriter.prototype = {
        append: function(input) {
          input = utils.transformTo("string", input);
          this.data.push(input)
        },
        finalize: function() {
          return this.data.join("")
        }
      };
      module.exports = StringWriter
    }, {
      "./utils": 36
    }],
    32: [function(require, module, exports) {
      (function(Buffer) {
        "use strict";
        exports.base64 = true;
        exports.array = true;
        exports.string = true;
        exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
        exports.nodebuffer = typeof Buffer !== "undefined";
        exports.uint8array = typeof Uint8Array !== "undefined";
        if (typeof ArrayBuffer === "undefined") {
          exports.blob = false
        } else {
          var buffer = new ArrayBuffer(0);
          try {
            exports.blob = new Blob([buffer], {
              type: "application/zip"
            }).size === 0
          } catch (e) {
            try {
              var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              var builder = new Builder;
              builder.append(buffer);
              exports.blob = builder.getBlob("application/zip").size === 0
            } catch (e) {
              exports.blob = false
            }
          }
        }
      }).call(this, require("buffer").Buffer)
    }, {
      buffer: 1
    }],
    33: [function(require, module, exports) {
      "use strict";
      var ArrayReader = require("./arrayReader");

      function Uint8ArrayReader(data) {
        if (data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
          this.zero = 0
        }
      }
      Uint8ArrayReader.prototype = new ArrayReader;
      Uint8ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return new Uint8Array(0)
        }
        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result
      };
      module.exports = Uint8ArrayReader
    }, {
      "./arrayReader": 15
    }],
    34: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var Uint8ArrayWriter = function(length) {
        this.data = new Uint8Array(length);
        this.index = 0
      };
      Uint8ArrayWriter.prototype = {
        append: function(input) {
          if (input.length !== 0) {
            input = utils.transformTo("uint8array", input);
            this.data.set(input, this.index);
            this.index += input.length
          }
        },
        finalize: function() {
          return this.data
        }
      };
      module.exports = Uint8ArrayWriter
    }, {
      "./utils": 36
    }],
    35: [function(require, module, exports) {
      "use strict";
      var utils = require("./utils");
      var support = require("./support");
      var nodeBuffer = require("./nodeBuffer");
      var _utf8len = new Array(256);
      for (var i = 0; i < 256; i++) {
        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1
      }
      _utf8len[254] = _utf8len[254] = 1;
      var string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
        }
        if (support.uint8array) {
          buf = new Uint8Array(buf_len)
        } else {
          buf = new Array(buf_len)
        }
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          if (c < 128) {
            buf[i++] = c
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          }
        }
        return buf
      };
      var utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--
        }
        if (pos < 0) {
          return max
        }
        if (pos === 0) {
          return max
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max
      };
      var buf2string = function(buf) {
        var str, i, out, c, c_len;
        var len = buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue
          }
          if (c < 65536) {
            utf16buf[out++] = c
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023
          }
        }
        if (utf16buf.length !== out) {
          if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out)
          } else {
            utf16buf.length = out
          }
        }
        return utils.applyFromCharCode(utf16buf)
      };
      exports.utf8encode = function utf8encode(str) {
        if (support.nodebuffer) {
          return nodeBuffer(str, "utf-8")
        }
        return string2buf(str)
      };
      exports.utf8decode = function utf8decode(buf) {
        if (support.nodebuffer) {
          return utils.transformTo("nodebuffer", buf).toString("utf-8")
        }
        buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
        var result = [],
          k = 0,
          len = buf.length,
          chunk = 65536;
        while (k < len) {
          var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
          if (support.uint8array) {
            result.push(buf2string(buf.subarray(k, nextBoundary)))
          } else {
            result.push(buf2string(buf.slice(k, nextBoundary)))
          }
          k = nextBoundary
        }
        return result.join("")
      }
    }, {
      "./nodeBuffer": 26,
      "./support": 32,
      "./utils": 36
    }],
    36: [function(require, module, exports) {
      "use strict";
      var support = require("./support");
      var compressions = require("./compressions");
      var nodeBuffer = require("./nodeBuffer");
      exports.string2binary = function(str) {
        var result = "";
        for (var i = 0; i < str.length; i++) {
          result += String.fromCharCode(str.charCodeAt(i) & 255)
        }
        return result
      };
      exports.arrayBuffer2Blob = function(buffer, mimeType) {
        exports.checkSupport("blob");
        mimeType = mimeType || "application/zip";
        try {
          return new Blob([buffer], {
            type: mimeType
          })
        } catch (e) {
          try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder;
            builder.append(buffer);
            return builder.getBlob(mimeType)
          } catch (e) {
            throw new Error("Bug : can't construct the Blob.")
          }
        }
      };

      function identity(input) {
        return input
      }

      function stringToArrayLike(str, array) {
        for (var i = 0; i < str.length; ++i) {
          array[i] = str.charCodeAt(i) & 255
        }
        return array
      }

      function arrayLikeToString(array) {
        var chunk = 65536;
        var result = [],
          len = array.length,
          type = exports.getTypeOf(array),
          k = 0,
          canUseApply = true;
        try {
          switch (type) {
            case "uint8array":
              String.fromCharCode.apply(null, new Uint8Array(0));
              break;
            case "nodebuffer":
              String.fromCharCode.apply(null, nodeBuffer(0));
              break
          }
        } catch (e) {
          canUseApply = false
        }
        if (!canUseApply) {
          var resultStr = "";
          for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i])
          }
          return resultStr
        }
        while (k < len && chunk > 1) {
          try {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))))
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))))
            }
            k += chunk
          } catch (e) {
            chunk = Math.floor(chunk / 2)
          }
        }
        return result.join("")
      }
      exports.applyFromCharCode = arrayLikeToString;

      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i = 0; i < arrayFrom.length; i++) {
          arrayTo[i] = arrayFrom[i]
        }
        return arrayTo
      }
      var transform = {};
      transform["string"] = {
        string: identity,
        array: function(input) {
          return stringToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return transform["string"]["uint8array"](input).buffer
        },
        uint8array: function(input) {
          return stringToArrayLike(input, new Uint8Array(input.length))
        },
        nodebuffer: function(input) {
          return stringToArrayLike(input, nodeBuffer(input.length))
        }
      };
      transform["array"] = {
        string: arrayLikeToString,
        array: identity,
        arraybuffer: function(input) {
          return new Uint8Array(input).buffer
        },
        uint8array: function(input) {
          return new Uint8Array(input)
        },
        nodebuffer: function(input) {
          return nodeBuffer(input)
        }
      };
      transform["arraybuffer"] = {
        string: function(input) {
          return arrayLikeToString(new Uint8Array(input))
        },
        array: function(input) {
          return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
        },
        arraybuffer: identity,
        uint8array: function(input) {
          return new Uint8Array(input)
        },
        nodebuffer: function(input) {
          return nodeBuffer(new Uint8Array(input))
        }
      };
      transform["uint8array"] = {
        string: arrayLikeToString,
        array: function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return input.buffer
        },
        uint8array: identity,
        nodebuffer: function(input) {
          return nodeBuffer(input)
        }
      };
      transform["nodebuffer"] = {
        string: arrayLikeToString,
        array: function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length))
        },
        arraybuffer: function(input) {
          return transform["nodebuffer"]["uint8array"](input).buffer
        },
        uint8array: function(input) {
          return arrayLikeToArrayLike(input, new Uint8Array(input.length))
        },
        nodebuffer: identity
      };
      exports.transformTo = function(outputType, input) {
        if (!input) {
          input = ""
        }
        if (!outputType) {
          return input
        }
        exports.checkSupport(outputType);
        var inputType = exports.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result
      };
      exports.getTypeOf = function(input) {
        if (typeof input === "string") {
          return "string"
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array"
        }
        if (support.nodebuffer && nodeBuffer.test(input)) {
          return "nodebuffer"
        }
        if (support.uint8array && input instanceof Uint8Array) {
          return "uint8array"
        }
        if (support.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer"
        }
      };
      exports.checkSupport = function(type) {
        var supported = support[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this browser")
        }
      };
      exports.MAX_VALUE_16BITS = 65535;
      exports.MAX_VALUE_32BITS = -1;
      exports.pretty = function(str) {
        var res = "",
          code, i;
        for (i = 0; i < (str || "").length; i++) {
          code = str.charCodeAt(i);
          res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase()
        }
        return res
      };
      exports.findCompression = function(compressionMethod) {
        for (var method in compressions) {
          if (!compressions.hasOwnProperty(method)) {
            continue
          }
          if (compressions[method].magic === compressionMethod) {
            return compressions[method]
          }
        }
        return null
      };
      exports.isRegExp = function(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]"
      };
      exports.extend = function() {
        var result = {},
          i, attr;
        for (i = 0; i < arguments.length; i++) {
          for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i][attr]
            }
          }
        }
        return result
      }
    }, {
      "./compressions": 18,
      "./nodeBuffer": 26,
      "./support": 32
    }],
    37: [function(require, module, exports) {
      "use strict";
      var StringReader = require("./stringReader");
      var NodeBufferReader = require("./nodeBufferReader");
      var Uint8ArrayReader = require("./uint8ArrayReader");
      var ArrayReader = require("./arrayReader");
      var utils = require("./utils");
      var sig = require("./signature");
      var ZipEntry = require("./zipEntry");
      var support = require("./support");
      var jszipProto = require("./object");

      function ZipEntries(data, loadOptions) {
        this.files = [];
        this.loadOptions = loadOptions;
        if (data) {
          this.load(data)
        }
      }
      ZipEntries.prototype = {
        checkSignature: function(expectedSignature) {
          var signature = this.reader.readString(4);
          if (signature !== expectedSignature) {
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")")
          }
        },
        isSignature: function(askedIndex, expectedSignature) {
          var currentIndex = this.reader.index;
          this.reader.setIndex(askedIndex);
          var signature = this.reader.readString(4);
          var result = signature === expectedSignature;
          this.reader.setIndex(currentIndex);
          return result
        },
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2);
          this.diskWithCentralDirStart = this.reader.readInt(2);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
          this.centralDirRecords = this.reader.readInt(2);
          this.centralDirSize = this.reader.readInt(4);
          this.centralDirOffset = this.reader.readInt(4);
          this.zipCommentLength = this.reader.readInt(2);
          var zipComment = this.reader.readData(this.zipCommentLength);
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          var decodeContent = utils.transformTo(decodeParamType, zipComment);
          this.zipComment = this.loadOptions.decodeFileName(decodeContent)
        },
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8);
          this.versionMadeBy = this.reader.readString(2);
          this.versionNeeded = this.reader.readInt(2);
          this.diskNumber = this.reader.readInt(4);
          this.diskWithCentralDirStart = this.reader.readInt(4);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
          this.centralDirRecords = this.reader.readInt(8);
          this.centralDirSize = this.reader.readInt(8);
          this.centralDirOffset = this.reader.readInt(8);
          this.zip64ExtensibleData = {};
          var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId, extraFieldLength, extraFieldValue;
          while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readString(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            }
          }
        },
        readBlockZip64EndOfCentralLocator: function() {
          this.diskWithZip64CentralDirStart = this.reader.readInt(4);
          this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
          this.disksCount = this.reader.readInt(4);
          if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported")
          }
        },
        readLocalFiles: function() {
          var i, file;
          for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes()
          }
        },
        readCentralDir: function() {
          var file;
          this.reader.setIndex(this.centralDirOffset);
          while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
            file = new ZipEntry({
              zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file)
          }
          if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
            } else {}
          }
        },
        readEndOfCentral: function() {
          var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
          if (offset < 0) {
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
            if (isGarbage) {
              throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html")
            } else {
              throw new Error("Corrupted zip : can't find end of central directory")
            }
          }
          this.reader.setIndex(offset);
          var endOfCentralDirOffset = offset;
          this.checkSignature(sig.CENTRAL_DIRECTORY_END);
          this.readBlockEndOfCentral();
          if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator")
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
              this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory")
              }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral()
          }
          var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
          if (this.zip64) {
            expectedEndOfCentralDirOffset += 20;
            expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize
          }
          var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
          if (extraBytes > 0) {
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
              this.reader.zero = extraBytes
            }
          } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.")
          }
        },
        prepareReader: function(data) {
          var type = utils.getTypeOf(data);
          utils.checkSupport(type);
          if (type === "string" && !support.uint8array) {
            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString)
          } else if (type === "nodebuffer") {
            this.reader = new NodeBufferReader(data)
          } else if (support.uint8array) {
            this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data))
          } else if (support.array) {
            this.reader = new ArrayReader(utils.transformTo("array", data))
          } else {
            throw new Error("Unexpected error: unsupported type '" + type + "'")
          }
        },
        load: function(data) {
          this.prepareReader(data);
          this.readEndOfCentral();
          this.readCentralDir();
          this.readLocalFiles()
        }
      };
      module.exports = ZipEntries
    }, {
      "./arrayReader": 15,
      "./nodeBufferReader": 27,
      "./object": 28,
      "./signature": 29,
      "./stringReader": 30,
      "./support": 32,
      "./uint8ArrayReader": 33,
      "./utils": 36,
      "./zipEntry": 38
    }],
    38: [function(require, module, exports) {
      "use strict";
      var StringReader = require("./stringReader");
      var utils = require("./utils");
      var CompressedObject = require("./compressedObject");
      var jszipProto = require("./object");
      var support = require("./support");
      var MADE_BY_DOS = 0;
      var MADE_BY_UNIX = 3;

      function ZipEntry(options, loadOptions) {
        this.options = options;
        this.loadOptions = loadOptions
      }
      ZipEntry.prototype = {
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1
        },
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048
        },
        prepareCompressedContent: function(reader, from, length) {
          return function() {
            var previousIndex = reader.index;
            reader.setIndex(from);
            var compressedFileData = reader.readData(length);
            reader.setIndex(previousIndex);
            return compressedFileData
          }
        },
        prepareContent: function(reader, from, length, compression, uncompressedSize) {
          return function() {
            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
            var uncompressedFileData = compression.uncompress(compressedFileData);
            if (uncompressedFileData.length !== uncompressedSize) {
              throw new Error("Bug : uncompressed data size mismatch")
            }
            return uncompressedFileData
          }
        },
        readLocalPart: function(reader) {
          var compression, localExtraFieldsLength;
          reader.skip(22);
          this.fileNameLength = reader.readInt(2);
          localExtraFieldsLength = reader.readInt(2);
          this.fileName = reader.readData(this.fileNameLength);
          reader.skip(localExtraFieldsLength);
          if (this.compressedSize == -1 || this.uncompressedSize == -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)")
          }
          compression = utils.findCompression(this.compressionMethod);
          if (compression === null) {
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")")
          }
          this.decompressed = new CompressedObject;
          this.decompressed.compressedSize = this.compressedSize;
          this.decompressed.uncompressedSize = this.uncompressedSize;
          this.decompressed.crc32 = this.crc32;
          this.decompressed.compressionMethod = this.compressionMethod;
          this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
          this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
          if (this.loadOptions.checkCRC32) {
            this.decompressed = utils.transformTo("string", this.decompressed.getContent());
            if (jszipProto.crc32(this.decompressed) !== this.crc32) {
              throw new Error("Corrupted zip : CRC32 mismatch")
            }
          }
        },
        readCentralPart: function(reader) {
          this.versionMadeBy = reader.readInt(2);
          this.versionNeeded = reader.readInt(2);
          this.bitFlag = reader.readInt(2);
          this.compressionMethod = reader.readString(2);
          this.date = reader.readDate();
          this.crc32 = reader.readInt(4);
          this.compressedSize = reader.readInt(4);
          this.uncompressedSize = reader.readInt(4);
          this.fileNameLength = reader.readInt(2);
          this.extraFieldsLength = reader.readInt(2);
          this.fileCommentLength = reader.readInt(2);
          this.diskNumberStart = reader.readInt(2);
          this.internalFileAttributes = reader.readInt(2);
          this.externalFileAttributes = reader.readInt(4);
          this.localHeaderOffset = reader.readInt(4);
          if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported")
          }
          this.fileName = reader.readData(this.fileNameLength);
          this.readExtraFields(reader);
          this.parseZIP64ExtraField(reader);
          this.fileComment = reader.readData(this.fileCommentLength)
        },
        processAttributes: function() {
          this.unixPermissions = null;
          this.dosPermissions = null;
          var madeBy = this.versionMadeBy >> 8;
          this.dir = this.externalFileAttributes & 16 ? true : false;
          if (madeBy === MADE_BY_DOS) {
            this.dosPermissions = this.externalFileAttributes & 63
          }
          if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 65535
          }
          if (!this.dir && this.fileNameStr.slice(-1) === "/") {
            this.dir = true
          }
        },
        parseZIP64ExtraField: function(reader) {
          if (!this.extraFields[1]) {
            return
          }
          var extraReader = new StringReader(this.extraFields[1].value);
          if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8)
          }
          if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8)
          }
          if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8)
          }
          if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4)
          }
        },
        readExtraFields: function(reader) {
          var start = reader.index,
            extraFieldId, extraFieldLength, extraFieldValue;
          this.extraFields = this.extraFields || {};
          while (reader.index < start + this.extraFieldsLength) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readString(extraFieldLength);
            this.extraFields[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            }
          }
        },
        handleUTF8: function() {
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) {
            this.fileNameStr = jszipProto.utf8decode(this.fileName);
            this.fileCommentStr = jszipProto.utf8decode(this.fileComment)
          } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
              this.fileNameStr = upath
            } else {
              var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray)
            }
            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
              this.fileCommentStr = ucomment
            } else {
              var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray)
            }
          }
        },
        findExtraFieldUnicodePath: function() {
          var upathField = this.extraFields[28789];
          if (upathField) {
            var extraReader = new StringReader(upathField.value);
            if (extraReader.readInt(1) !== 1) {
              return null
            }
            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
              return null
            }
            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))
          }
          return null
        },
        findExtraFieldUnicodeComment: function() {
          var ucommentField = this.extraFields[25461];
          if (ucommentField) {
            var extraReader = new StringReader(ucommentField.value);
            if (extraReader.readInt(1) !== 1) {
              return null
            }
            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
              return null
            }
            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))
          }
          return null
        }
      };
      module.exports = ZipEntry
    }, {
      "./compressedObject": 17,
      "./object": 28,
      "./stringReader": 30,
      "./support": 32,
      "./utils": 36
    }],
    39: [function(require, module, exports) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory)
        } else if (typeof exports === "object") {
          module.exports = factory()
        } else {
          root.memoize = factory()
        }
      })(this, function() {
        "use strict";
        var memoize = function(func) {
          var stringifyJson = JSON.stringify,
            cache = {};
          var cachedfun = function() {
            var hash = stringifyJson(arguments);
            return hash in cache ? cache[hash] : cache[hash] = func.apply(this, arguments)
          };
          cachedfun.__cache = function() {
            cache.remove || (cache.remove = function() {
              var hash = stringifyJson(arguments);
              return delete cache[hash]
            });
            return cache
          }.call(this);
          return cachedfun
        };
        return memoize
      })
    }, {}],
    40: [function(require, module, exports) {
      "use strict";
      var assign = require("./lib/utils/common").assign;
      var deflate = require("./lib/deflate");
      var inflate = require("./lib/inflate");
      var constants = require("./lib/zlib/constants");
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module.exports = pako
    }, {
      "./lib/deflate": 41,
      "./lib/inflate": 42,
      "./lib/utils/common": 43,
      "./lib/zlib/constants": 46
    }],
    41: [function(require, module, exports) {
      "use strict";
      var zlib_deflate = require("./zlib/deflate");
      var utils = require("./utils/common");
      var strings = require("./utils/strings");
      var msg = require("./zlib/messages");
      var ZStream = require("./zlib/zstream");
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;

      function Deflate(options) {
        if (!(this instanceof Deflate)) return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream;
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status])
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header)
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary)
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary)
          } else {
            dict = opt.dictionary
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status])
          }
          this._dict_set = true
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data)
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data)
        } else {
          strm.input = data
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)))
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out))
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true
        }
        return true
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk)
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("")
          } else {
            this.result = utils.flattenChunks(this.chunks)
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg
      };

      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg
        }
        return deflator.result
      }

      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options)
      }

      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options)
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip
    }, {
      "./utils/common": 43,
      "./utils/strings": 44,
      "./zlib/deflate": 48,
      "./zlib/messages": 53,
      "./zlib/zstream": 55
    }],
    42: [function(require, module, exports) {
      "use strict";
      var zlib_inflate = require("./zlib/inflate");
      var utils = require("./utils/common");
      var strings = require("./utils/strings");
      var c = require("./zlib/constants");
      var msg = require("./zlib/messages");
      var ZStream = require("./zlib/zstream");
      var GZheader = require("./zlib/gzheader");
      var toString = Object.prototype.toString;

      function Inflate(options) {
        if (!(this instanceof Inflate)) return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream;
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== c.Z_OK) {
          throw new Error(msg[status])
        }
        this.header = new GZheader;
        zlib_inflate.inflateGetHeader(this.strm, this.header)
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var dict;
        var allowBufError = false;
        if (this.ended) {
          return false
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data)
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data)
        } else {
          strm.input = data
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            if (typeof dictionary === "string") {
              dict = strings.string2buf(dictionary)
            } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(dictionary)
            } else {
              dict = dictionary
            }
            status = zlib_inflate.inflateSetDictionary(this.strm, dict)
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0)
                }
                this.onData(utf8str)
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out))
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true
        }
        return true
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk)
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("")
          } else {
            this.result = utils.flattenChunks(this.chunks)
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg
      };

      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg
        }
        return inflator.result
      }

      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options)
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate
    }, {
      "./utils/common": 43,
      "./utils/strings": 44,
      "./zlib/constants": 46,
      "./zlib/gzheader": 49,
      "./zlib/inflate": 51,
      "./zlib/messages": 53,
      "./zlib/zstream": 55
    }],
    43: [function(require, module, exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object")
          }
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p]
            }
          }
        }
        return obj
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf
        }
        if (buf.subarray) {
          return buf.subarray(0, size)
        }
        buf.length = size;
        return buf
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length
          }
          return result
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i]
          }
        },
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks)
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped)
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped)
        }
      };
      exports.setTyped(TYPED_OK)
    }, {}],
    44: [function(require, module, exports) {
      "use strict";
      var utils = require("./common");
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0])
      } catch (__) {
        STR_APPLY_OK = false
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1))
      } catch (__) {
        STR_APPLY_UIA_OK = false
      }
      var _utf8len = new utils.Buf8(256);
      for (var q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1
      }
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length,
          buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++
            }
          }
          if (c < 128) {
            buf[i++] = c
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63
          }
        }
        return buf
      };

      function buf2binstring(buf, len) {
        if (len < 65537) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len))
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i])
        }
        return result
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length)
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i)
        }
        return buf
      };
      exports.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len;) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue
          }
          if (c < 65536) {
            utf16buf[out++] = c
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023
          }
        }
        return buf2binstring(utf16buf, out)
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--
        }
        if (pos < 0) {
          return max
        }
        if (pos === 0) {
          return max
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max
      }
    }, {
      "./common": 43
    }],
    45: [function(require, module, exports) {
      "use strict";

      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0,
          s2 = adler >>> 16 & 65535 | 0,
          n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0
          } while (--n);
          s1 %= 65521;
          s2 %= 65521
        }
        return s1 | s2 << 16 | 0
      }
      module.exports = adler32
    }, {}],
    46: [function(require, module, exports) {
      "use strict";
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      }
    }, {}],
    47: [function(require, module, exports) {
      "use strict";

      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1
          }
          table[n] = c
        }
        return table
      }
      var crcTable = makeTable();

      function crc32(crc, buf, len, pos) {
        var t = crcTable,
          end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255]
        }
        return crc ^ -1
      }
      module.exports = crc32
    }, {}],
    48: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var trees = require("./trees");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var msg = require("./messages");
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode
      }

      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0)
      }

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }

      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out
        }
        if (len === 0) {
          return
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0
        }
      }

      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm)
      }

      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b
      }

      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255
      }

      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size
        }
        if (len === 0) {
          return 0
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start)
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start)
        }
        strm.next_in += len;
        strm.total_in += len;
        return len
      }

      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue
          }
          scan += 2;
          match++;
          do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len]
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len
        }
        return s.lookahead
      }

      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0
            } while (--n);
            more += _w_size
          }
          if (s.strm.avail_in === 0) {
            break
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
      }

      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5
        }
        for (;;) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_NEED_MORE
      }

      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head)
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              } while (--s.match_length !== 0);
              s.strstart++
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (;;) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false)
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (;;) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE
            }
            if (s.lookahead === 0) {
              break
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function deflate_huff(s, flush) {
        var bflush;
        for (;;) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE
              }
              break
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED
          }
          return BS_FINISH_DONE
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE
          }
        }
        return BS_BLOCK_DONE
      }

      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func
      }
      var configuration_table;
      configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];

      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0
      }

      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0
      }

      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK
      }

      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state)
        }
        return ret
      }

      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR
        }
        strm.state.gzhead = head;
        return Z_OK
      }

      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR)
        }
        if (windowBits === 8) {
          windowBits = 9
        }
        var s = new DeflateState;
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm)
      }

      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
      }

      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255)
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0
            } else if (s.level < 6) {
              level_flags = 1
            } else if (s.level === 6) {
              level_flags = 2
            } else {
              level_flags = 3
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535)
            }
            strm.adler = 1
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE
            }
          } else {
            s.status = NAME_STATE
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE
            }
          } else {
            s.status = COMMENT_STATE
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255
              } else {
                val = 0
              }
              put_byte(s, val)
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
            }
            if (val === 0) {
              s.status = HCRC_STATE
            }
          } else {
            s.status = HCRC_STATE
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm)
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE
            }
          } else {
            s.status = BUSY_STATE
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR)
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR)
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1
            }
            return Z_OK
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s)
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255)
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535)
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END
      }

      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR)
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
      }

      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0)
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s)
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)"
    }, {
      "../utils/common": 43,
      "./adler32": 45,
      "./crc32": 47,
      "./messages": 53,
      "./trees": 54
    }],
    49: [function(require, module, exports) {
      "use strict";

      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false
      }
      module.exports = GZheader
    }, {}],
    50: [function(require, module, exports) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8
          }
          here = lcode[hold & lmask];
          dolen: for (;;) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8
              }
              here = dcode[hold & dmask];
              dodist: for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = _out - dist;
                        from_source = output
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++]
                          } while (--op);
                          from = _out - dist;
                          from_source = output
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++]
                        } while (--op);
                        from = _out - dist;
                        from_source = output
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++]
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++]
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top
                }
                break
              }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen
            } else if (op & 32) {
              state.mode = TYPE;
              break top
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top
            }
            break
          }
        } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return
      }
    }, {}],
    51: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var adler32 = require("./adler32");
      var crc32 = require("./crc32");
      var inflate_fast = require("./inffast");
      var inflate_table = require("./inftrees");
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;

      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
      }

      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0
      }

      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK
      }

      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm)
      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm)
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR
        }
        state = new InflateState;
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null
        }
        return ret
      }

      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS)
      }
      var virgin = true;
      var lenfix, distfix;

      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8
          }
          while (sym < 256) {
            state.lens[sym++] = 9
          }
          while (sym < 280) {
            state.lens[sym++] = 7
          }
          while (sym < 288) {
            state.lens[sym++] = 8
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });
          virgin = false
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5
      }

      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize)
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0
            }
            if (state.whave < state.wsize) {
              state.whave += dist
            }
          }
        }
        return 0
      }

      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave: for (;;) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.time = hold
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0)
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0)
                }
                hold = 0;
                bits = 0
              } else if (state.head) {
                state.head.extra = null
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len)
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len)
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next)
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy
                }
                if (state.length) {
                  break inf_leave
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.name = null
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len)
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next)
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave
                }
              } else if (state.head) {
                state.head.comment = null
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have
                }
                if (copy > left) {
                  copy = left
                }
                if (copy === 0) {
                  break inf_leave
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;;) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break
                  }
                  while (copy--) {
                    state.lens[state.have++] = len
                  }
                }
              }
              if (state.mode === BAD) {
                break
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break
              }
              state.lenbits = 9;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1
                }
                break
              }
              state.back = 0;
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (;;) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break
                }
                if (have === 0) {
                  break inf_leave
                }
                have--;
                hold += input[next++] << bits;
                bits += 8
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break
                  }
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy
                } else {
                  from = state.wnext - copy
                }
                if (copy > state.length) {
                  copy = state.length
                }
                from_source = state.window
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length
              }
              if (copy > left) {
                copy = left
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++]
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break
                }
                hold = 0;
                bits = 0
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR
          }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR
        }
        return ret
      }

      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        var state = strm.state;
        if (state.window) {
          state.window = null
        }
        strm.state = null;
        return Z_OK
      }

      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR
        }
        state.head = head;
        head.done = false;
        return Z_OK
      }

      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR
        }
        state.havedict = 1;
        return Z_OK
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)"
    }, {
      "../utils/common": 43,
      "./adler32": 45,
      "./crc32": 47,
      "./inffast": 50,
      "./inftrees": 52
    }],
    52: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
      var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
      var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
      var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0,
          max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break
          }
        }
        if (root > max) {
          root = max
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break
          }
        }
        if (root < min) {
          root = min
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len]
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256
        } else {
          base = dbase;
          extra = dext;
          end = -1
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1
        }
        var i = 0;
        for (;;) {
          i++;
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym]
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]]
          } else {
            here_op = 32 + 64;
            here_val = 0
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr
          } else {
            huff = 0
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break
            }
            len = lens[lens_index + work[sym]]
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break
              }
              curr++;
              left <<= 1
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0
        }
        opts.bits = root;
        return 0
      }
    }, {
      "../utils/common": 43
    }],
    53: [function(require, module, exports) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      }
    }, {}],
    54: [function(require, module, exports) {
      "use strict";
      var utils = require("../utils/common");
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;

      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);

      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;

      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc
      }

      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
      }

      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255
      }

      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length
        }
      }

      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2], tree[c * 2 + 1])
      }

      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1
        } while (--len > 0);
        return res >>> 1
      }

      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8
        }
      }

      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base]
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits)
          }
        }
        if (overflow === 0) {
          return
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits
            }
            n--
          }
        }
      }

      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len)
        }
      }

      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5)
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
      }

      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0
      }

      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf)
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf
        }
        s.bi_buf = 0;
        s.bi_valid = 0
      }

      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len)
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len
      }

      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
      }

      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1
        }
        s.heap[k] = v
      }

      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree)
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra)
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra)
              }
            }
          } while (lx < s.last_lit)
        }
        send_code(s, END_BLOCK, ltree)
      }

      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0
          } else {
            tree[n * 2 + 1] = 0
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1]
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n)
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1)
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count)
      }

      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++
            }
            s.bl_tree[REP_3_6 * 2]++
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++
          } else {
            s.bl_tree[REPZ_11_138 * 2]++
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree)
            } while (--count !== 0)
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2)
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3)
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7)
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3
          } else {
            max_count = 7;
            min_count = 4
          }
        }
      }

      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex
      }

      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3)
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1)
      }

      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT
          }
        }
        return Z_BINARY
      }
      var static_init_done = false;

      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s)
      }

      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true)
      }

      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s)
      }

      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s)
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last)
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree)
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree)
        }
        init_block(s);
        if (last) {
          bi_windup(s)
        }
      }

      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++
        }
        return s.last_lit === s.lit_bufsize - 1
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align
    }, {
      "../utils/common": 43
    }],
    55: [function(require, module, exports) {
      "use strict";

      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0
      }
      module.exports = ZStream
    }, {}],
    "/src/js/docxtemplater.js": [function(require, module, exports) {
      "use strict";
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor
        }
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function")
        }
      }
      var DocUtils = require("./docUtils");
      var Docxtemplater = function() {
        function Docxtemplater(content, options) {
          _classCallCheck(this, Docxtemplater);
          this.moduleManager = new Docxtemplater.ModuleManager;
          this.moduleManager.setInstance("gen", this);
          this.setOptions({});
          if (content != null) {
            this.load(content, options)
          }
        }
        _createClass(Docxtemplater, [{
          key: "attachModule",
          value: function attachModule(module) {
            this.moduleManager.attachModule(module);
            return this
          }
        }, {
          key: "setOptions",
          value: function setOptions(options) {
            var _this = this;
            this.options = options || {};
            Object.keys(DocUtils.defaults).forEach(function(key) {
              var defaultValue = DocUtils.defaults[key];
              _this[key] = _this.options[key] != null ? _this.options[key] : defaultValue
            });
            if (this.fileType === "docx" || this.fileType === "pptx") {
              this.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];
              if (this.zip != null) {
                this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip)
              }
            }
            return this
          }
        }, {
          key: "load",
          value: function load(content, options) {
            this.moduleManager.sendEvent("loading");
            if (content.file != null) {
              this.zip = content
            } else {
              this.zip = new Docxtemplater.JSZip(content, options)
            }
            this.moduleManager.sendEvent("loaded");
            this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
            return this
          }
        }, {
          key: "renderFile",
          value: function renderFile(fileName) {
            this.moduleManager.sendEvent("rendering-file", fileName);
            var currentFile = this.createTemplateClass(fileName);
            this.zip.file(fileName, currentFile.render().content);
            return this.moduleManager.sendEvent("rendered-file", fileName)
          }
        }, {
          key: "render",
          value: function render() {
            this.moduleManager.sendEvent("rendering");
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                this.renderFile(fileName)
              }
            }
            this.moduleManager.sendEvent("rendered");
            return this
          }
        }, {
          key: "getTags",
          value: function getTags() {
            var usedTags = [];
            var iterable = this.templatedFiles;
            for (var i = 0, fileName; i < iterable.length; i++) {
              fileName = iterable[i];
              if (this.zip.files[fileName] != null) {
                var currentFile = this.createTemplateClass(fileName);
                var usedTemplateV = currentFile.render().usedTags;
                if (DocUtils.sizeOfObject(usedTemplateV)) {
                  usedTags.push({
                    fileName: fileName,
                    vars: usedTemplateV
                  })
                }
              }
            }
            return usedTags
          }
        }, {
          key: "setData",
          value: function setData(tags) {
            this.tags = tags;
            return this
          }
        }, {
          key: "getZip",
          value: function getZip() {
            return this.zip
          }
        }, {
          key: "createTemplateClass",
          value: function createTemplateClass(path) {
            var usedData = this.zip.files[path].asText();
            return this.createTemplateClassFromContent(usedData)
          }
        }, {
          key: "createTemplateClassFromContent",
          value: function createTemplateClassFromContent(content) {
            var _this2 = this;
            var obj = {
              tags: this.tags,
              moduleManager: this.moduleManager
            };
            Object.keys(DocUtils.defaults).forEach(function(key) {
              obj[key] = _this2[key]
            });
            obj.fileTypeConfig = this.fileTypeConfig;
            return new Docxtemplater.XmlTemplater(content, obj)
          }
        }, {
          key: "getFullText",
          value: function getFullText(path) {
            return this.createTemplateClass(path || this.fileTypeConfig.textPath).getFullText()
          }
        }]);
        return Docxtemplater
      }();
      Docxtemplater.DocUtils = require("./docUtils");
      Docxtemplater.JSZip = require("jszip");
      Docxtemplater.Errors = require("./errors");
      Docxtemplater.ModuleManager = require("./moduleManager");
      Docxtemplater.XmlTemplater = require("./xmlTemplater");
      Docxtemplater.FileTypeConfig = require("./fileTypeConfig");
      Docxtemplater.XmlMatcher = require("./xmlMatcher");
      Docxtemplater.XmlUtil = require("./xmlUtil");
      Docxtemplater.SubContent = require("./subContent");
      module.exports = Docxtemplater
    }, {
      "./docUtils": 5,
      "./errors": 6,
      "./fileTypeConfig": 7,
      "./moduleManager": 8,
      "./subContent": 10,
      "./xmlMatcher": 12,
      "./xmlTemplater": 13,
      "./xmlUtil": 14,
      jszip: 24
    }]
  }, {}, [])("/src/js/docxtemplater.js")
});
/*! RESOURCE: redirect_itgdn */
Event.observe(window, 'load', function() {
  var currentUrl = window.location.toString();
  var currentUrlHref = window.location.href.toString();
  var currentUrlTopHref = window.top.location.href.toString();
  var res = currentUrl.split("/");
  var g_user = ((g_user == null) ? getActiveUser() : g_user.userName);
  var userName = g_user.userName;
  if (g_user.hasRole('admin') || g_user.hasRole('lsmc_tm_employee')) {} else {
    if ((userName.toString() != 'guest' && !g_user.hasRoles()) || g_user.hasRole('Customer License Counter Viewer')) {
      if (currentUrlHref.indexOf('pa_dashboard') < 0) {
        if (currentUrlHref.indexOf('expert_shell') != -1 && currentUrlTopHref.indexOf('expert_shell') == -1) {
          window.top.location.href = currentUrlHref;
        } else if (currentUrlTopHref.indexOf('expert_shell') != -1) {} else if (res[3] != "itgdn") {
          if (res[3] == 'login_cpw.do') {} else {
            window.location = '/itgdn';
            redirectToItgdn();
          }
        }
      }
    } else {}
  }
});

function redirectToItgdn() {
  var dialog = new GlideDialogWindow('redirect_itgdn');
  dialog.setTitle('You will be redirected to the portal page.');
  dialog.setSize(500, 400);
  dialog.removeCloseDecoration();
  dialog.render();
  var d = $('grayBackground');
  d.style.opacity = "1";
  d.style.filter = "alpha(opacity = 100)";
  Event.observe(window, 'resize', function() {
    var dims = document.viewport.getDimensions();
    d.style.width = dims.width + 'px';
    d.style.height = dims.height + 'px';
  });
}
/*! RESOURCE: tm_AddToTestPlanHandler */
var tm_AddToTestPlanHandler = Class.create({
  initialize: function(gr) {
    this._gr = gr;
    this._isList = (gr.type + "" == "GlideList2");
    this._tableName = this._gr.getTableName();
    this._prmErr = [];
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("tm_ref_choose_dialog");
    var titleMsg = '';
    if (this._gr.getTableName() == 'tm_test_case') {
      titleMsg = getMessage("Add Case(s) to Test Plan");
    } else if (this._gr.getTableName() == 'tm_test_suite') {
      titleMsg = getMessage("Add Suite(s) to Test Plan");
    }
    this._mstrDlg.setTitle(titleMsg);
    this._mstrDlg.setPreference("sysparam_field_label", getMessage("Test Plan"));
    this._mstrDlg.setPreference("sysparam_reference_table", "tm_test_plan");
    this._mstrDlg.setPreference("sysparam_query", "active=true");
    this._mstrDlg.setPreference("handler", this);
  },
  showDialog: function() {
    this._mstrDlg.render();
  },
  onSubmit: function() {
    var testPlanId = this._getValue('tm_test_plan_ref');
    if (!this._validate()) {
      return false;
    }
    this._mstrDlg.destroy();
    if (testPlanId) {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._plsWtDlg = new dialogClass("tm_wait_dialog");
      this._plsWtDlg.setTitle(getMessage("Working.  Please wait."));
      this._plsWtDlg.render();
      var ga = new GlideAjax("tm_AjaxProcessor");
      ga.addParam('sysparm_name', 'addToTestPlan');
      ga.addParam('sysparm_sys_id', this._isList ? this._gr.getChecked() : this._gr.getUniqueValue());
      ga.addParam('sysparm_tm_test_plan', testPlanId);
      ga.addParam('sysparm_tn', this._tableName);
      ga.getXML(this.callback.bind(this));
    }
    return false;
  },
  callback: function(response) {
    this._plsWtDlg.destroy();
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      return false;
    } else {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._createError = new dialogClass("tm_error_dialog");
      this._createError.setTitle(getMessage("Error while adding Test Cases from selected Test Suite."));
      this._createError.render();
    }
  },
  _refreshRelatedList: function() {
    this._gForm.setFilterAndRefresh('');
  },
  _validate: function() {
    var valid = true;
    this._prmErr = [];
    if (!this._isList)
      this._removeAllError('tm_ref_choose_dialog');
    if (this._getValue('tm_test_plan_ref') == 'undefined' || this._getValue('tm_test_plan_ref').trim() == "") {
      this._prmErr.push(getMessage("Select Test Plan"));
      if (!this._isList)
        this._showFieldError('ref_test_suite_field', this._prmErr[0]);
      valid = false;
    }
    return valid;
  },
  _removeAllError: function(dialogName) {
    $$('#' + dialogName + ' .form-group.has-error').each(function(item) {
      $(item).removeClassName('has-error');
      $(item).down('.help-block').setStyle({
        'display': 'none'
      });
    });
  },
  _showFieldError: function(groupId, message) {
    var $group = $(groupId);
    var $helpBlock = $group.down('.help-block');
    if (!$group.hasClassName('has-error'))
      $group.addClassName('has-error');
    if ($helpBlock.getStyle('display') != 'inline-block') {
      $helpBlock.update(message);
      $helpBlock.setStyle({
        'display': 'inline-block'
      });
    }
  },
  _getValue: function(inptNm) {
    return gel(inptNm).value;
  },
  type: "tm_AddToTestPlanHandler"
});
/*! RESOURCE: NavFilterExtension */
function navFilterExtension(val, msg) {
  if (!gs.hasRole('admin')) {
    getNavWindow().GwtNavFilter.filter(val);
    return true;
  } else {
    return false;
  }
}
/*! RESOURCE: AddScrumTask */
var AddScrumTask = Class.create();
AddScrumTask.prototype = {
  initialize: function() {
    this.list = (typeof g_list != "undefined") ? g_list : null;
    this.storyID = typeof rowSysId == 'undefined' ? (gel('sys_uniqueValue') ? gel('sys_uniqueValue').value : "") : rowSysId;
    this.setUpFacade();
    this.setUpEvents();
    this.display(true);
    this.checkOKButton();
    this.focusFirstSelectElement();
  },
  toggleOKButton: function(visible) {
    $("ok").style.display = (visible ? "inline" : "none");
  },
  setUpFacade: function() {
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this.dialog = new dialogClass("task_window");
    this.dialog.setTitle(getMessage("Add Scrum Tasks"));
    var mapCount = this.getTypeCounts();
    this.dialog.setBody(this.getMarkUp(mapCount), false, false);
  },
  checkOKButton: function() {
    var visible = false;
    var self = this;
    $('task_window').select("select").each(function(elem) {
      if (elem.value + "" != "0") visible = true;
      if (!elem.onChangeAdded) {
        elem.onChangeAdded = true;
        elem.on("change", function() {
          self.checkOKButton();
        });
      }
    });
    this.toggleOKButton(visible);
  },
  focusFirstSelectElement: function() {
    $('task_window').select("select")[0].focus();
  },
  getTypeCounts: function() {
    var mapLabel = this.getLabels("rm_scrum_task", "type");
    var mapCount = {};
    for (var strKey in mapLabel) {
      mapCount[strKey] = getPreference("com.snc.sdlc.scrum.pp.tasks." + strKey, 0);
    }
    return mapCount;
  },
  setUpEvents: function() {
    var self = this,
      dialog = this.dialog;
    $("ok").on("click", function() {
      var mapTaskData = {};
      if (self.fillDataMap(mapTaskData)) {
        var taskProducer = new GlideAjax("ScrumAjaxTaskProducer");
        for (var strKey in mapTaskData) {
          taskProducer.addParam("sysparm_" + encodeURIComponent(strKey), mapTaskData[strKey]);
        }
        self.showStatus("Adding tasks...");
        taskProducer.getXML(function() {
          self.refresh();
          dialog.destroy();
        });
      } else {
        dialog.destroy();
      }
    });
    $("cancel").on("click", function() {
      dialog.destroy();
    });
  },
  refresh: function() {
    if (this.list) this.list.refresh();
    else this.reloadList("rm_story.rm_scrum_task.story");
  },
  getSysID: function() {
    return this.storyID;
  },
  fillDataMap: function(mapTaskData) {
    var bTasksRequired = false;
    mapTaskData.name = "createTasks";
    mapTaskData.sys_id = this.getSysID();
    var mapDetails = this.getLabels("rm_scrum_task", "type");
    var arrTaskTypes = [];
    for (var key in mapDetails) {
      arrTaskTypes.push(key);
    }
    for (var nSlot = 0; nSlot < arrTaskTypes.length; ++nSlot) {
      var strTaskType = arrTaskTypes[nSlot];
      var strTaskData = $(strTaskType).getValue();
      mapTaskData[strTaskType] = strTaskData;
      setPreference("com.snc.sdlc.scrum.pp.tasks." + strTaskType, strTaskData);
      if (strTaskData != "0") {
        bTasksRequired = true;
      }
    }
    return bTasksRequired;
  },
  getMarkUp: function(mapCounts) {
    function getSelectMarkUp(strFieldId, nValue) {
      var strMarkUp = '<select class="form-control select2" id="' + strFieldId + '" name="' + strFieldId + '">';
      for (var nSlot = 0; nSlot <= 10; nSlot++) {
        if (nValue != 0 && nValue == nSlot) {
          strMarkUp += '<option value="' + nSlot + '" selected="selected">' + nSlot + '</option>';
        } else {
          strMarkUp += '<option value="' + nSlot + '">' + nSlot + '</option>';
        }
      }
      strMarkUp += "</select>";
      return strMarkUp;
    }

    function buildRow(strMessage, nValue) {
      var row = '';
      row += '<div class="row" style="padding-top:10px;">';
      row += '<div class="form-group">';
      row += '<label class="control-label col-sm-3" for="' + strMessage + '" style="white-space:nowrap;">';
      row += strMessage;
      row += '</label>';
      row += '<span class="col-sm-9">';
      row += getSelectMarkUp(strMessage, nValue);
      row += '</span>';
      row += '</div>';
      row += '</div>';
      return row;
    }

    function buildTable(mapDetails, mapCounts) {
      var arrDetails = [];
      for (var strKey in mapDetails) {
        arrDetails.push(strKey + "");
      }
      arrDetails.sort();
      var strBuf = '';
      for (var index = 0; index < arrDetails.length; ++index) {
        var nCount = mapCounts[arrDetails[index]];
        strBuf += buildRow(arrDetails[index], nCount);
      }
      strBuf += '';
      return strBuf;
    }
    var mapLabels = this.getLabels("rm_scrum_task", "type");
    return buildTable(mapLabels, mapCounts) + "<div id='task_controls' style='text-align:right;padding-top:20px;'>" +
      "<button id='cancel' type='button' class='btn btn-default'>" + getMessage('Cancel') + "</button>" +
      "&nbsp;&nbsp;<button id='ok' type='button' class='btn btn-primary'>" + getMessage('OK') + "</button></div>";
  },
  reloadForm: function() {
    document.location.href = document.location.href;
  },
  reloadList: function(strListName) {
    var list = GlideList2.get(strListName);
    if (list)
      list.refresh();
  },
  showStatus: function(strMessage) {
    $("task_controls").update("Loading...");
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getLabels: function(strTable, strAttribute) {
    var taskProducer = new GlideAjax("ScrumAjaxTaskProducer");
    taskProducer.addParam("sysparm_name", "getLabels");
    taskProducer.addParam("sysparm_table", strTable);
    taskProducer.addParam("sysparm_attribute", strAttribute);
    var result = taskProducer.getXMLWait();
    return this._parseResponse(result);
  },
  _parseResponse: function(resultXML) {
    var jsonStr = resultXML.documentElement.getAttribute("answer");
    var map = JSON.parse(jsonStr);
    return map;
  }
};
/*! RESOURCE: Mirror42 */
var Mirror42 = {
  show: function(token, url, height, width) {
    if (!height) {
      height = "600px";
    }
    if (!width) {
      width = "100%";
    }
    if (/^\d+$/.test(height + '')) {
      height = height + 'px';
    }
    if (/^\d+$/.test(width + '')) {
      width = width + 'px';
    }
    token = token.split('#');
    url = url.replace(/^\s+/g, '');
    if (url.indexOf('http') !== 0) {
      if (url.indexOf('/') !== 0) {
        url = '/' + url;
      }
      url = token[0] + url;
    }
    url = url + (url.indexOf('?') === -1 ? "?" : "&");
    url = url + "apptoken=" + encodeURIComponent(token[1]);
    url = url + "&h=" + encodeURIComponent(height);
    var m42 = document.getElementById('mirror42');
    m42.innerHTML = '<iframe class="content_embedded" frameborder="0" src="' + url + '" style="height:' + height + ';width:' + width + ';" frameborder="0" scrolling="no"></iframe>';
  }
};
/*! RESOURCE: UI Action Context Menu */
function showUIActionContext(event) {
  if (!g_user.hasRole("ui_action_admin"))
    return;
  var element = Event.element(event);
  if (element.tagName.toLowerCase() == "span")
    element = element.parentNode;
  var id = element.getAttribute("gsft_id");
  var mcm = new GwtContextMenu('context_menu_action_' + id);
  mcm.clear();
  mcm.addURL(getMessage('Edit UI Action'), "sys_ui_action.do?sys_id=" + id, "gsft_main");
  contextShow(event, mcm.getID(), 500, 0, 0);
  Event.stop(event);
}
addLoadEvent(function() {
  document.on('contextmenu', '.action_context', function(evt, element) {
    showUIActionContext(evt);
  });
});
/*! RESOURCE: ITGDN - getMyCalls */
function getMyCalls(order_by, order_dir, start, end, page, limiter, inc_state) {
  var gajax = new GlideAjax("itgdnUtils");
  $j.session.set('call_order_by', order_by);
  $j.session.set('call_order_dir', order_dir);
  $j.session.set('call_start', start);
  $j.session.set('call_end', end);
  $j.session.set('call_page', page);
  $j.session.set('call_inc_state', inc_state);
  gajax.addParam("sysparm_name", "getCalls");
  gajax.addParam("order_by", order_by);
  gajax.addParam("order_dir", order_dir);
  gajax.addParam("start", start);
  gajax.addParam("end", end);
  gajax.addParam("limiter", limiter);
  gajax.addParam("inc_state", inc_state);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    var meta = serverResponse.responseXML.getElementsByTagName("meta");
    if (data.length > 0) {
      var sClass = '';
      var sHref = '';
      var orderBy = meta[0].getAttribute("order_by").toString();
      var orderDir = meta[0].getAttribute("order_dir").toString();
      var order_dir_class = orderDir == 'ASC' ? 'ASC' : 'DESC';
      var rowCount = meta[0].getAttribute("rowCount").toString();
      var pageParam = getURLParameter('page');
      if (pageParam == undefined) {
        pageParam = page;
        if (pageParam < 1)
          pageParam = 1;
      }
      var curPage = parseInt(pageParam);
      var prevPage = parseInt(pageParam) - 1;
      var nextPage = parseInt(pageParam) + 1;
      var countPages = Math.ceil((parseInt(rowCount) / limiter) * 1) / 1;
      var count = 1;
      if (getURLParameter('breadcrumb') != 'true') {}
      if ((inc_state == 'empty' && $j.session.get('call_inc_state') == 'closed') || (inc_state == 'closed')) {
        var incident_state = '&inc_state=closed';
      } else {
        var incident_state = '';
      }
      output = '';
      output += "<table class='callsTable' id='data-table' border='0' cellpadding='10' cellspacing='0'><thead><tr>";
      output += "<th scope='col' style='width:16px;'> </th>";
      sClass = orderBy == "opened_at" ? order_dir_class : "";
      sHref = 'status.do?page=' + curPage + '&order_by=opened_at' + incident_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_opened_at") + '</a></th>';
      sClass = orderBy == "number" ? order_dir_class : "";
      sHref = 'status.do?page=' + curPage + '&order_by=number' + incident_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_number") + '</a></th>';
      sClass = orderBy == "short_description" ? order_dir_class : "";
      sHref = 'status.do?page=' + curPage + '&order_by=short_description' + incident_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_short_description") + '</a></th>';
      sClass = orderBy == "category" ? order_dir_class : "";
      sHref = 'status.do?page=' + curPage + '&order_by=category' + incident_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_category") + '</a></th>';
      sClass = orderBy == "u_call_state" ? order_dir_class : "";
      sHref = 'status.do?page=' + curPage + '&order_by=incident_state' + incident_state + '&order_dir=' + (orderDir == "ASC" ? "DESC" : "ASC");
      output += '<th class="' + sClass + '"><a href="' + sHref + '">' + getMessage("cms_state") + '</a></th>';
      output += '</tr></thead><tbody id="data">';
      for (var i = 0; i < data.length; i++) {
        var evenOrOdd = i % 2 == 0 ? 'even' : 'odd';
        output += '<tr class="' + evenOrOdd + '">';
        output += '<td><img class="clickableImage" title="Toggle description" src="images/list_v2_heir_hide.gifx" onclick="toggleTRVisibility(this)" id="imgFor' + data[i].getAttribute("sys_id").toString() + '"></td>';
        output += '<td class="date" style="width:65px;">' + data[i].getAttribute("opened_at").toString() + '</td>';
        output += '<td class="number" style="width:75px;"><a href="status_detail.do?sys_id=' + data[i].getAttribute("sys_id").toString() + '&sysparm_view=ess' + incident_state + '">' + data[i].getAttribute("number").toString() + '<a/></td>';
        output += '<td class="title" style="width:135px;">' + data[i].getAttribute("short_description").toString() + '</td>';
        output += '<td class="phase" style="width:65px;">' + data[i].getAttribute("category").toString() + '</td>';
        output += '<td class="state" style="width:65px;">' + data[i].getAttribute("state").toString() + '</td>';
        output += '</tr>';
        output += '<tr class="toggleTR" style="display:none;">';
        output += '<td colspan="5"><strong>Description:</strong> ' + data[i].getAttribute("description").toString() + '</td>';
        output += '</tr>';
        count++;
      }
      output += '</tbody></table>';
      if (countPages > 1) {
        output += '<div class="pager">';
        output += '<ul><div class="liWrap">';
        var startCount = 1;
        var endCount = countPages;
        if (countPages > 10) {
          startCount = (curPage - 5) > 0 ? (curPage - 5) : 1;
          endCount = (curPage + 5) <= countPages ? (curPage + 5) : countPages;
        }
        if (curPage > 1) {
          output += '<li class="first"><a href="status.do?page=1&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">First</a></li>';
          output += '<li class="more"><a href="status.do?page=' + prevPage + '&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '"><<</a></li>';
          if (startCount > 1) {
            output += '<li class=""><a href="status.do?page=1&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">1</a></li>';
            output += '<li>...</li>';
          }
        } else {
          output += '<li class="first"><span class="notClickable">First</span></li>';
          output += '<li class="more"><span class="notClickable"><<</span></li>';
        }
        for (var i = startCount; i <= endCount; i++) {
          var activeClass = '';
          if (curPage == i)
            activeClass = 'active';
          output += '<li class="' + activeClass + '"><a href="status.do?page=' + i + '&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">' + i + '</a></li>';
        }
        if (countPages >= nextPage) {
          if (endCount < countPages) {
            output += '<li>...</li>';
            output += '<li class=""><a href="status.do?page=' + countPages + '&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">' + countPages + '</a></li>';
          }
          output += '<li class="more"><a href="status.do?page=' + nextPage + '&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">>></a></li>';
          output += '<li class="last"><a href="status.do?page=' + countPages + '&order_by=' + orderBy + '' + incident_state + '&order_dir=' + orderDir + '">Last</a></li>';
        } else {
          output += '<li class="more"><span class="notClickable">>></span></li>';
          output += '<li class="last"><span class="notClickable">Last</span></li>';
        }
        output += '</div></ul>';
        output += '</div>';
      }
      $j("div#wrapper").html(output);
    }
  }
}

function toggleTRVisibility(current) {
  var trToToggle = $j(current).parent().parent().next('tr');
  var oldImg = 'images/list_v2_heir_hide.gifx';
  var newImg = 'images/list_th_down.gifx';
  if ($j(trToToggle).is(':visible')) {
    $j(current).attr('src', oldImg);
  } else {
    $j(current).attr('src', newImg);
  }
  trToToggle.toggle();
}
/*! RESOURCE: AddMembersFromGroup */
var AddMembersFromGroup = Class.create(GlideDialogWindow, {
  initialize: function() {
    this.setUpFacade();
  },
  setUpFacade: function() {
    GlideDialogWindow.prototype.initialize.call(this, "task_window", false);
    this.setTitle(getMessage("Add Members From Group"));
    this.setBody(this.getMarkUp(), false, false);
  },
  setUpEvents: function() {
    var dialog = this;
    var okButton = $("ok");
    if (okButton) {
      okButton.on("click", function() {
        var mapData = {};
        if (dialog.fillDataMap(mapData)) {
          var processor = new GlideAjax("ScrumAjaxAddReleaseTeamMembersProcessor");
          for (var strKey in mapData) {
            processor.addParam(strKey, mapData[strKey]);
          }
          dialog.showStatus(getMessage("Adding group users..."));
          processor.getXML(function() {
            dialog.refresh();
            dialog._onCloseClicked();
          });
        } else {
          dialog._onCloseClicked();
        }
      });
    }
    var cancelButton = $("cancel");
    if (cancelButton) {
      cancelButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
    var okNGButton = $("okNG");
    if (okNGButton) {
      okNGButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
    var cancelNGButton = $("cancelNG");
    if (cancelNGButton) {
      cancelNGButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
  },
  refresh: function() {
    GlideList2.get("scrum_pp_team.scrum_pp_release_team_member.team").refresh();
  },
  getScrumReleaseTeamSysId: function() {
    return g_form.getUniqueValue() + "";
  },
  getUserChosenGroupSysIds: function() {
    return $F('groupId') + "";
  },
  showStatus: function(strMessage) {
    $("task_controls").update(strMessage);
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getRoleIds: function() {
    var arrRoleNames = ["scrum_user", "scrum_admin", "scrum_release_planner", "scrum_sprint_planner", "scrum_story_creator"];
    var arrRoleIds = [];
    var record = new GlideRecord("sys_user_role");
    record.addQuery("name", "IN", arrRoleNames.join(","));
    record.query();
    while (record.next())
      arrRoleIds.push(record.sys_id + "");
    return arrRoleIds;
  },
  hasScrumRole: function(roleSysId, arrScrumRoleSysIds) {
    for (var index = 0; index < arrScrumRoleSysIds.length; ++index)
      if (arrScrumRoleSysIds[index] == "" + roleSysId)
        return true;
    var record = new GlideRecord("sys_user_role_contains");
    record.addQuery("role", roleSysId);
    record.query();
    while (record.next())
      if (this.hasScrumRole(record.contains, arrScrumRoleSysIds))
        return true;
    return false;
  },
  getGroupIds: function() {
    var arrScrumRoleIds = this.getRoleIds();
    var arrGroupIds = [];
    var record = new GlideRecord("sys_group_has_role");
    record.query();
    while (record.next())
      if (this.hasScrumRole(record.role, arrScrumRoleIds))
        arrGroupIds.push(record.group + "");
    return arrGroupIds;
  },
  getGroupInfo: function() {
    var mapGroupInfo = {};
    var arrRoleIds = this.getRoleIds();
    var arrGroupIds = this.getGroupIds(arrRoleIds);
    var record = new GlideRecord("sys_user_group");
    record.addQuery("sys_id", "IN", arrGroupIds.join(","));
    record.query();
    while (record.next()) {
      var strName = record.name + "";
      var strSysId = record.sys_id + "";
      mapGroupInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    return mapGroupInfo;
  },
  getMarkUp: function() {
    var groupAjax = new GlideAjax('ScrumUserGroupsAjax');
    groupAjax.addParam('sysparm_name', 'getGroupInfo');
    groupAjax.getXML(this.generateMarkUp.bind(this));
  },
  generateMarkUp: function(response) {
    var mapGroupInfo = {};
    var groupData = response.responseXML.getElementsByTagName("group");
    var strName, strSysId;
    for (var i = 0; i < groupData.length; i++) {
      strName = groupData[i].getAttribute("name");
      strSysId = groupData[i].getAttribute("sysid");
      mapGroupInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    var arrGroupNames = [];
    for (var strGroupName in mapGroupInfo) {
      arrGroupNames.push(strGroupName + "");
    }
    arrGroupNames.sort();
    var strMarkUp = "";
    if (arrGroupNames.length > 0) {
      var strTable = "<table><tr><td><label for='groupId'><select id='groupId'>";
      for (var nSlot = 0; nSlot < arrGroupNames.length; ++nSlot) {
        strName = arrGroupNames[nSlot];
        strSysId = mapGroupInfo[strName].sysid;
        strTable += "<option value='" + strSysId + "'>" + strName + "</option>";
      }
      strTable += "</select></label></td></tr></table>";
      strMarkUp = "<div id='task_controls'>" + strTable +
        "<div style='text-align: right;'>" +
        "<button id='ok' type='button'>" + getMessage("OK") + "</button>" +
        "<button id='cancel' type='button'>" + getMessage("Cancel") + "</button></div></div>";
    } else {
      strMarkUp = "<div id='task_controls'><p>No groups with scrum_user role found</p>" +
        "<div style='text-align: right;'>" +
        "<button id='okNG' type='button'>" + getMessage("OK") + "</button>" +
        "<button id='cancelNG' type='button'>" + getMessage("Cancel") +
        "</button></div></div>";
    }
    this.setBody(strMarkUp, false, false);
    this.setUpEvents();
    this.display(true);
    this.setWidth(180);
  },
  fillDataMap: function(mapData) {
    var strChosenGroupSysId = this.getUserChosenGroupSysIds();
    if (strChosenGroupSysId) {
      mapData.sysparm_name = "createReleaseTeamMembers";
      mapData.sysparm_sys_id = this.getScrumReleaseTeamSysId();
      mapData.sysparm_groups = strChosenGroupSysId;
      return true;
    } else {
      return false;
    }
  }
});
/*! RESOURCE: ValidateStartEndDates */
function validateStartEndDate(startDateField, endDateField, processErrorMsg) {
  var startDate = g_form.getValue(startDateField);
  var endDate = g_form.getValue(endDateField);
  var format = g_user_date_format;
  if (startDate === "" || endDate === "")
    return true;
  var startDateFormat = getDateFromFormat(startDate, format);
  var endDateFormat = getDateFromFormat(endDate, format);
  if (startDateFormat < endDateFormat)
    return true;
  if (startDateFormat === 0 || endDateFormat === 0) {
    processErrorMsg(new GwtMessage().getMessage("{0} is invalid", g_form.getLabelOf(startDate === 0 ? startDateField : endDateField)));
    return false;
  }
  if (startDateFormat > endDateFormat) {
    processErrorMsg(new GwtMessage().getMessage("{0} must be after {1}", g_form.getLabelOf(endDateField), g_form.getLabelOf(startDateField)));
    return false;
  }
  return true;
}
/*! RESOURCE: AddTeamMembers */
var AddTeamMembers = Class.create(GlideDialogWindow, {
  initialize: function() {
    this.setUpFacade();
  },
  setUpFacade: function() {
    GlideDialogWindow.prototype.initialize.call(this, "task_window", false);
    this.setTitle(getMessage("Add Team Members"));
    this.setBody(this.getMarkUp(), false, false);
  },
  setUpEvents: function() {
    var dialog = this;
    var okButton = $("ok");
    if (okButton) {
      okButton.on("click", function() {
        var mapData = {};
        if (dialog.fillDataMap(mapData)) {
          var processor = new GlideAjax("ScrumAjaxAddReleaseTeamMembers2Processor");
          for (var strKey in mapData) {
            processor.addParam(strKey, mapData[strKey]);
          }
          dialog.showStatus(getMessage("Adding team members..."));
          processor.getXML(function() {
            dialog.refresh();
            dialog._onCloseClicked();
          });
        } else {
          dialog._onCloseClicked();
        }
      });
    }
    var cancelButton = $("cancel");
    if (cancelButton) {
      cancelButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
    var okNGButton = $("okNG");
    if (okNGButton) {
      okNGButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
    var cancelNGButton = $("cancelNG");
    if (cancelNGButton) {
      cancelNGButton.on("click", function() {
        dialog._onCloseClicked();
      });
    }
    var teamCombo = $("teamId");
    if (teamCombo) {
      teamCombo.on("change", function() {
        dialog.updateMembers();
      });
    }
  },
  updateMembers: function() {
    var arrMemberInfo = [];
    var teamCombo = $("teamId");
    if (teamCombo) {
      var strTeamSysId = teamCombo.value;
      var recTeamMember = new GlideRecord("scrum_pp_release_team_member");
      recTeamMember.addQuery("team", strTeamSysId);
      recTeamMember.query();
      while (recTeamMember.next()) {
        var recSysUser = new GlideRecord("sys_user");
        recSysUser.addQuery("sys_id", recTeamMember.name);
        recSysUser.query();
        var strName = recSysUser.next() ? recSysUser.name : "";
        var strPoints = recTeamMember.default_sprint_points + "";
        arrMemberInfo.push({
          name: strName,
          points: strPoints
        });
      }
    }
    if (arrMemberInfo.length > 0) {
      var strHtml = "<tr><th style='text-align: left; white-space: nowrap'>" +
        "Member</th><th style='text-align: left; white-space: nowrap'>Sprint Points</th><tr>";
      for (var nSlot = 0; nSlot < arrMemberInfo.length; ++nSlot) {
        var strMemberName = arrMemberInfo[nSlot].name + "";
        var strMemberPoints = arrMemberInfo[nSlot].points + "";
        strHtml += "<tr><td  style='text-align: left; white-space: nowrap'>" + strMemberName +
          "</td><td style='text-align: left; white-space: nowrap'>" + strMemberPoints + "</td></tr>";
      }
      $("memberId").update(strHtml);
    } else {
      $("memberId").update("<tr><td style='font-weight: bold'>" + getMessage("No team members") + "</td></tr>");
    }
  },
  refresh: function() {
    GlideList2.get("scrum_pp_team.scrum_pp_release_team_member.team").refresh();
  },
  getScrumReleaseTeamSysId: function() {
    return g_form.getUniqueValue() + "";
  },
  getUserChosenTeamSysIds: function() {
    return $F('teamId') + "";
  },
  showStatus: function(strMessage) {
    $("task_controls").update(strMessage);
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getMarkUp: function() {
    var groupAjax = new GlideAjax('ScrumUserGroupsAjax');
    groupAjax.addParam('sysparm_name', 'getTeamInfo');
    groupAjax.addParam('sysparm_scrum_team_sysid', this.getScrumReleaseTeamSysId());
    groupAjax.getXML(this.generateMarkUp.bind(this));
  },
  generateMarkUp: function(response) {
    var mapTeamInfo = {};
    var teamData = response.responseXML.getElementsByTagName("team");
    var strName, strSysId;
    for (var i = 0; i < teamData.length; i++) {
      strName = teamData[i].getAttribute("name");
      strSysId = teamData[i].getAttribute("sysid");
      mapTeamInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    var arrTeamNames = [];
    for (var strTeamName in mapTeamInfo) {
      arrTeamNames.push(strTeamName + "");
    }
    arrTeamNames.sort();
    var strMarkUp = "";
    if (arrTeamNames.length > 0) {
      var strTable = "<table><tr><td><label for='teamId'>" + getMessage("Team") + "</label>&nbsp;<select id='teamId'>";
      for (var nSlot = 0; nSlot < arrTeamNames.length; ++nSlot) {
        strName = arrTeamNames[nSlot];
        strSysId = mapTeamInfo[strName].sysid;
        strTable += "<option value='" + strSysId + "'>" + strName + "</option>";
      }
      strTable += "</select></label></td></tr></table>";
      var strTable2 = "<table style='width: 100%;'><tr><td style='width: 50%;'></td><td><table id='memberId'></table></td><td style='width: 50%;'></td></tr></table>";
      strMarkUp = "<div id='task_controls' style='overflow: auto;>" + strTable + strTable2 +
        "</div><table style='width: 100%'><tr><td style='white-space: nowrap; text-align: right;'><button id='ok' type='button'>" + getMessage("OK") + "</button>" +
        "<button id='cancel' type='button'>" + getMessage("Cancel") + "</button></td></tr></table>";
    } else {
      strMarkUp = "<div id='task_controls'><p>No release teams found</p>" +
        "<table style='width: 100%'><tr><td style='white-space: nowrap; text-align: right;'><button id='okNG' type='button'>" + getMessage("OK") + "</button>" +
        "<button id='cancelNG' type='button'>" + getMessage("Cancel") + "</button></td></tr></table></div>";
    }
    this.setBody(strMarkUp, false, false);
    this.setUpEvents();
    this.display(true);
    this.setWidth(280);
  },
  fillDataMap: function(mapData) {
    var strChosenTeamSysId = this.getUserChosenTeamSysIds();
    if (strChosenTeamSysId) {
      mapData.sysparm_name = "createReleaseTeamMembers";
      mapData.sysparm_sys_id = this.getScrumReleaseTeamSysId();
      mapData.sysparm_teams = strChosenTeamSysId;
      return true;
    } else {
      return false;
    }
  }
});
/*! RESOURCE: jquery.min */
(function(E, B) {
  function ka(a, b, d) {
    if (d === B && a.nodeType === 1) {
      d = a.getAttribute("data-" + b);
      if (typeof d === "string") {
        try {
          d = d === "true" ? true : d === "false" ? false : d === "null" ? null : !c.isNaN(d) ? parseFloat(d) : Ja.test(d) ? c.parseJSON(d) : d
        } catch (e) {}
        c.data(a, b, d)
      } else d = B
    }
    return d
  }

  function U() {
    return false
  }

  function ca() {
    return true
  }

  function la(a, b, d) {
    d[0].type = a;
    return c.event.handle.apply(b, d)
  }

  function Ka(a) {
    var b, d, e, f, h, l, k, o, x, r, A, C = [];
    f = [];
    h = c.data(this, this.nodeType ? "events" : "__events__");
    if (typeof h === "function") h =
      h.events;
    if (!(a.liveFired === this || !h || !h.live || a.button && a.type === "click")) {
      if (a.namespace) A = RegExp("(^|\\.)" + a.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
      a.liveFired = this;
      var J = h.live.slice(0);
      for (k = 0; k < J.length; k++) {
        h = J[k];
        h.origType.replace(X, "") === a.type ? f.push(h.selector) : J.splice(k--, 1)
      }
      f = c(a.target).closest(f, a.currentTarget);
      o = 0;
      for (x = f.length; o < x; o++) {
        r = f[o];
        for (k = 0; k < J.length; k++) {
          h = J[k];
          if (r.selector === h.selector && (!A || A.test(h.namespace))) {
            l = r.elem;
            e = null;
            if (h.preType === "mouseenter" ||
              h.preType === "mouseleave") {
              a.type = h.preType;
              e = c(a.relatedTarget).closest(h.selector)[0]
            }
            if (!e || e !== l) C.push({
              elem: l,
              handleObj: h,
              level: r.level
            })
          }
        }
      }
      o = 0;
      for (x = C.length; o < x; o++) {
        f = C[o];
        if (d && f.level > d) break;
        a.currentTarget = f.elem;
        a.data = f.handleObj.data;
        a.handleObj = f.handleObj;
        A = f.handleObj.origHandler.apply(f.elem, arguments);
        if (A === false || a.isPropagationStopped()) {
          d = f.level;
          if (A === false) b = false;
          if (a.isImmediatePropagationStopped()) break
        }
      }
      return b
    }
  }

  function Y(a, b) {
    return (a && a !== "*" ? a + "." : "") + b.replace(La,
      "`").replace(Ma, "&")
  }

  function ma(a, b, d) {
    if (c.isFunction(b)) return c.grep(a, function(f, h) {
      return !!b.call(f, h, f) === d
    });
    else if (b.nodeType) return c.grep(a, function(f) {
      return f === b === d
    });
    else if (typeof b === "string") {
      var e = c.grep(a, function(f) {
        return f.nodeType === 1
      });
      if (Na.test(b)) return c.filter(b, e, !d);
      else b = c.filter(b, e)
    }
    return c.grep(a, function(f) {
      return c.inArray(f, b) >= 0 === d
    })
  }

  function na(a, b) {
    var d = 0;
    b.each(function() {
      if (this.nodeName === (a[d] && a[d].nodeName)) {
        var e = c.data(a[d++]),
          f = c.data(this,
            e);
        if (e = e && e.events) {
          delete f.handle;
          f.events = {};
          for (var h in e)
            for (var l in e[h]) c.event.add(this, h, e[h][l], e[h][l].data)
        }
      }
    })
  }

  function Oa(a, b) {
    b.src ? c.ajax({
      url: b.src,
      async: false,
      dataType: "script"
    }) : c.globalEval(b.text || b.textContent || b.innerHTML || "");
    b.parentNode && b.parentNode.removeChild(b)
  }

  function oa(a, b, d) {
    var e = b === "width" ? a.offsetWidth : a.offsetHeight;
    if (d === "border") return e;
    c.each(b === "width" ? Pa : Qa, function() {
      d || (e -= parseFloat(c.css(a, "padding" + this)) || 0);
      if (d === "margin") e += parseFloat(c.css(a,
        "margin" + this)) || 0;
      else e -= parseFloat(c.css(a, "border" + this + "Width")) || 0
    });
    return e
  }

  function da(a, b, d, e) {
    if (c.isArray(b) && b.length) c.each(b, function(f, h) {
      d || Ra.test(a) ? e(a, h) : da(a + "[" + (typeof h === "object" || c.isArray(h) ? f : "") + "]", h, d, e)
    });
    else if (!d && b != null && typeof b === "object") c.isEmptyObject(b) ? e(a, "") : c.each(b, function(f, h) {
      da(a + "[" + f + "]", h, d, e)
    });
    else e(a, b)
  }

  function S(a, b) {
    var d = {};
    c.each(pa.concat.apply([], pa.slice(0, b)), function() {
      d[this] = a
    });
    return d
  }

  function qa(a) {
    if (!ea[a]) {
      var b = c("<" +
          a + ">").appendTo("body"),
        d = b.css("display");
      b.remove();
      if (d === "none" || d === "") d = "block";
      ea[a] = d
    }
    return ea[a]
  }

  function fa(a) {
    return c.isWindow(a) ? a : a.nodeType === 9 ? a.defaultView || a.parentWindow : false
  }
  var t = E.document,
    c = function() {
      function a() {
        if (!b.isReady) {
          try {
            t.documentElement.doScroll("left")
          } catch (j) {
            setTimeout(a, 1);
            return
          }
          b.ready()
        }
      }
      var b = function(j, s) {
          return new b.fn.init(j, s)
        },
        d = E.jQuery,
        e = E.$,
        f, h = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,
        l = /\S/,
        k = /^\s+/,
        o = /\s+$/,
        x = /\W/,
        r = /\d/,
        A = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
        C = /^[\],:{}\s]*$/,
        J = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
        w = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        I = /(?:^|:|,)(?:\s*\[)+/g,
        L = /(webkit)[ \/]([\w.]+)/,
        g = /(opera)(?:.*version)?[ \/]([\w.]+)/,
        i = /(msie) ([\w.]+)/,
        n = /(mozilla)(?:.*? rv:([\w.]+))?/,
        m = navigator.userAgent,
        p = false,
        q = [],
        u, y = Object.prototype.toString,
        F = Object.prototype.hasOwnProperty,
        M = Array.prototype.push,
        N = Array.prototype.slice,
        O = String.prototype.trim,
        D = Array.prototype.indexOf,
        R = {};
      b.fn = b.prototype = {
        init: function(j,
          s) {
          var v, z, H;
          if (!j) return this;
          if (j.nodeType) {
            this.context = this[0] = j;
            this.length = 1;
            return this
          }
          if (j === "body" && !s && t.body) {
            this.context = t;
            this[0] = t.body;
            this.selector = "body";
            this.length = 1;
            return this
          }
          if (typeof j === "string")
            if ((v = h.exec(j)) && (v[1] || !s))
              if (v[1]) {
                H = s ? s.ownerDocument || s : t;
                if (z = A.exec(j))
                  if (b.isPlainObject(s)) {
                    j = [t.createElement(z[1])];
                    b.fn.attr.call(j, s, true)
                  } else j = [H.createElement(z[1])];
                else {
                  z = b.buildFragment([v[1]], [H]);
                  j = (z.cacheable ? z.fragment.cloneNode(true) : z.fragment).childNodes
                }
                return b.merge(this,
                  j)
              } else {
                if ((z = t.getElementById(v[2])) && z.parentNode) {
                  if (z.id !== v[2]) return f.find(j);
                  this.length = 1;
                  this[0] = z
                }
                this.context = t;
                this.selector = j;
                return this
              }
          else if (!s && !x.test(j)) {
            this.selector = j;
            this.context = t;
            j = t.getElementsByTagName(j);
            return b.merge(this, j)
          } else return !s || s.jquery ? (s || f).find(j) : b(s).find(j);
          else if (b.isFunction(j)) return f.ready(j);
          if (j.selector !== B) {
            this.selector = j.selector;
            this.context = j.context
          }
          return b.makeArray(j, this)
        },
        selector: "",
        jquery: "1.4.4",
        length: 0,
        size: function() {
          return this.length
        },
        toArray: function() {
          return N.call(this, 0)
        },
        get: function(j) {
          return j == null ? this.toArray() : j < 0 ? this.slice(j)[0] : this[j]
        },
        pushStack: function(j, s, v) {
          var z = b();
          b.isArray(j) ? M.apply(z, j) : b.merge(z, j);
          z.prevObject = this;
          z.context = this.context;
          if (s === "find") z.selector = this.selector + (this.selector ? " " : "") + v;
          else if (s) z.selector = this.selector + "." + s + "(" + v + ")";
          return z
        },
        each: function(j, s) {
          return b.each(this, j, s)
        },
        ready: function(j) {
          b.bindReady();
          if (b.isReady) j.call(t, b);
          else q && q.push(j);
          return this
        },
        eq: function(j) {
          return j ===
            -1 ? this.slice(j) : this.slice(j, +j + 1)
        },
        first: function() {
          return this.eq(0)
        },
        last: function() {
          return this.eq(-1)
        },
        slice: function() {
          return this.pushStack(N.apply(this, arguments), "slice", N.call(arguments).join(","))
        },
        map: function(j) {
          return this.pushStack(b.map(this, function(s, v) {
            return j.call(s, v, s)
          }))
        },
        end: function() {
          return this.prevObject || b(null)
        },
        push: M,
        sort: [].sort,
        splice: [].splice
      };
      b.fn.init.prototype = b.fn;
      b.extend = b.fn.extend = function() {
        var j, s, v, z, H, G = arguments[0] || {},
          K = 1,
          Q = arguments.length,
          ga = false;
        if (typeof G === "boolean") {
          ga = G;
          G = arguments[1] || {};
          K = 2
        }
        if (typeof G !== "object" && !b.isFunction(G)) G = {};
        if (Q === K) {
          G = this;
          --K
        }
        for (; K < Q; K++)
          if ((j = arguments[K]) != null)
            for (s in j) {
              v = G[s];
              z = j[s];
              if (G !== z)
                if (ga && z && (b.isPlainObject(z) || (H = b.isArray(z)))) {
                  if (H) {
                    H = false;
                    v = v && b.isArray(v) ? v : []
                  } else v = v && b.isPlainObject(v) ? v : {};
                  G[s] = b.extend(ga, v, z)
                } else if (z !== B) G[s] = z
            }
        return G
      };
      b.extend({
        noConflict: function(j) {
          E.$ = e;
          if (j) E.jQuery = d;
          return b
        },
        isReady: false,
        readyWait: 1,
        ready: function(j) {
          j === true && b.readyWait--;
          if (!b.readyWait || j !== true && !b.isReady) {
            if (!t.body) return setTimeout(b.ready, 1);
            b.isReady = true;
            if (!(j !== true && --b.readyWait > 0))
              if (q) {
                var s = 0,
                  v = q;
                for (q = null; j = v[s++];) j.call(t, b);
                b.fn.trigger && b(t).trigger("ready").unbind("ready")
              }
          }
        },
        bindReady: function() {
          if (!p) {
            p = true;
            if (t.readyState === "complete") return setTimeout(b.ready, 1);
            if (t.addEventListener) {
              t.addEventListener("DOMContentLoaded", u, false);
              E.addEventListener("load", b.ready, false)
            } else if (t.attachEvent) {
              t.attachEvent("onreadystatechange", u);
              E.attachEvent("onload",
                b.ready);
              var j = false;
              try {
                j = E.frameElement == null
              } catch (s) {}
              t.documentElement.doScroll && j && a()
            }
          }
        },
        isFunction: function(j) {
          return b.type(j) === "function"
        },
        isArray: Array.isArray || function(j) {
          return b.type(j) === "array"
        },
        isWindow: function(j) {
          return j && typeof j === "object" && "setInterval" in j
        },
        isNaN: function(j) {
          return j == null || !r.test(j) || isNaN(j)
        },
        type: function(j) {
          return j == null ? String(j) : R[y.call(j)] || "object"
        },
        isPlainObject: function(j) {
          if (!j || b.type(j) !== "object" || j.nodeType || b.isWindow(j)) return false;
          if (j.constructor &&
            !F.call(j, "constructor") && !F.call(j.constructor.prototype, "isPrototypeOf")) return false;
          for (var s in j);
          return s === B || F.call(j, s)
        },
        isEmptyObject: function(j) {
          for (var s in j) return false;
          return true
        },
        error: function(j) {
          throw j;
        },
        parseJSON: function(j) {
          if (typeof j !== "string" || !j) return null;
          j = b.trim(j);
          if (C.test(j.replace(J, "@").replace(w, "]").replace(I, ""))) return E.JSON && E.JSON.parse ? E.JSON.parse(j) : (new Function("return " + j))();
          else b.error("Invalid JSON: " + j)
        },
        noop: function() {},
        globalEval: function(j) {
          if (j &&
            l.test(j)) {
            var s = t.getElementsByTagName("head")[0] || t.documentElement,
              v = t.createElement("script");
            v.type = "text/javascript";
            if (b.support.scriptEval) v.appendChild(t.createTextNode(j));
            else v.text = j;
            s.insertBefore(v, s.firstChild);
            s.removeChild(v)
          }
        },
        nodeName: function(j, s) {
          return j.nodeName && j.nodeName.toUpperCase() === s.toUpperCase()
        },
        each: function(j, s, v) {
          var z, H = 0,
            G = j.length,
            K = G === B || b.isFunction(j);
          if (v)
            if (K)
              for (z in j) {
                if (s.apply(j[z], v) === false) break
              } else
                for (; H < G;) {
                  if (s.apply(j[H++], v) === false) break
                } else if (K)
                  for (z in j) {
                    if (s.call(j[z],
                        z, j[z]) === false) break
                  } else
                    for (v = j[0]; H < G && s.call(v, H, v) !== false; v = j[++H]);
          return j
        },
        trim: O ? function(j) {
          return j == null ? "" : O.call(j)
        } : function(j) {
          return j == null ? "" : j.toString().replace(k, "").replace(o, "")
        },
        makeArray: function(j, s) {
          var v = s || [];
          if (j != null) {
            var z = b.type(j);
            j.length == null || z === "string" || z === "function" || z === "regexp" || b.isWindow(j) ? M.call(v, j) : b.merge(v, j)
          }
          return v
        },
        inArray: function(j, s) {
          if (s.indexOf) return s.indexOf(j);
          for (var v = 0, z = s.length; v < z; v++)
            if (s[v] === j) return v;
          return -1
        },
        merge: function(j,
          s) {
          var v = j.length,
            z = 0;
          if (typeof s.length === "number")
            for (var H = s.length; z < H; z++) j[v++] = s[z];
          else
            for (; s[z] !== B;) j[v++] = s[z++];
          j.length = v;
          return j
        },
        grep: function(j, s, v) {
          var z = [],
            H;
          v = !!v;
          for (var G = 0, K = j.length; G < K; G++) {
            H = !!s(j[G], G);
            v !== H && z.push(j[G])
          }
          return z
        },
        map: function(j, s, v) {
          for (var z = [], H, G = 0, K = j.length; G < K; G++) {
            H = s(j[G], G, v);
            if (H != null) z[z.length] = H
          }
          return z.concat.apply([], z)
        },
        guid: 1,
        proxy: function(j, s, v) {
          if (arguments.length === 2)
            if (typeof s === "string") {
              v = j;
              j = v[s];
              s = B
            } else if (s && !b.isFunction(s)) {
            v =
              s;
            s = B
          }
          if (!s && j) s = function() {
            return j.apply(v || this, arguments)
          };
          if (j) s.guid = j.guid = j.guid || s.guid || b.guid++;
          return s
        },
        access: function(j, s, v, z, H, G) {
          var K = j.length;
          if (typeof s === "object") {
            for (var Q in s) b.access(j, Q, s[Q], z, H, v);
            return j
          }
          if (v !== B) {
            z = !G && z && b.isFunction(v);
            for (Q = 0; Q < K; Q++) H(j[Q], s, z ? v.call(j[Q], Q, H(j[Q], s)) : v, G);
            return j
          }
          return K ? H(j[0], s) : B
        },
        now: function() {
          return (new Date).getTime()
        },
        uaMatch: function(j) {
          j = j.toLowerCase();
          j = L.exec(j) || g.exec(j) || i.exec(j) || j.indexOf("compatible") < 0 && n.exec(j) || [];
          return {
            browser: j[1] || "",
            version: j[2] || "0"
          }
        },
        browser: {}
      });
      b.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(j, s) {
        R["[object " + s + "]"] = s.toLowerCase()
      });
      m = b.uaMatch(m);
      if (m.browser) {
        b.browser[m.browser] = true;
        b.browser.version = m.version
      }
      if (b.browser.webkit) b.browser.safari = true;
      if (D) b.inArray = function(j, s) {
        return D.call(s, j)
      };
      if (!/\s/.test("\u00a0")) {
        k = /^[\s\xA0]+/;
        o = /[\s\xA0]+$/
      }
      f = b(t);
      if (t.addEventListener) u = function() {
        t.removeEventListener("DOMContentLoaded", u,
          false);
        b.ready()
      };
      else if (t.attachEvent) u = function() {
        if (t.readyState === "complete") {
          t.detachEvent("onreadystatechange", u);
          b.ready()
        }
      };
      return E.jQuery = E.$ = b
    }();
  (function() {
    c.support = {};
    var a = t.documentElement,
      b = t.createElement("script"),
      d = t.createElement("div"),
      e = "script" + c.now();
    d.style.display = "none";
    d.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
    var f = d.getElementsByTagName("*"),
      h = d.getElementsByTagName("a")[0],
      l = t.createElement("select"),
      k = l.appendChild(t.createElement("option"));
    if (!(!f || !f.length || !h)) {
      c.support = {
        leadingWhitespace: d.firstChild.nodeType === 3,
        tbody: !d.getElementsByTagName("tbody").length,
        htmlSerialize: !!d.getElementsByTagName("link").length,
        style: /red/.test(h.getAttribute("style")),
        hrefNormalized: h.getAttribute("href") === "/a",
        opacity: /^0.55$/.test(h.style.opacity),
        cssFloat: !!h.style.cssFloat,
        checkOn: d.getElementsByTagName("input")[0].value === "on",
        optSelected: k.selected,
        deleteExpando: true,
        optDisabled: false,
        checkClone: false,
        scriptEval: false,
        noCloneEvent: true,
        boxModel: null,
        inlineBlockNeedsLayout: false,
        shrinkWrapBlocks: false,
        reliableHiddenOffsets: true
      };
      l.disabled = true;
      c.support.optDisabled = !k.disabled;
      b.type = "text/javascript";
      try {
        b.appendChild(t.createTextNode("window." + e + "=1;"))
      } catch (o) {}
      a.insertBefore(b, a.firstChild);
      if (E[e]) {
        c.support.scriptEval = true;
        delete E[e]
      }
      try {
        delete b.test
      } catch (x) {
        c.support.deleteExpando = false
      }
      a.removeChild(b);
      if (d.attachEvent && d.fireEvent) {
        d.attachEvent("onclick", function r() {
          c.support.noCloneEvent =
            false;
          d.detachEvent("onclick", r)
        });
        d.cloneNode(true).fireEvent("onclick")
      }
      d = t.createElement("div");
      d.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";
      a = t.createDocumentFragment();
      a.appendChild(d.firstChild);
      c.support.checkClone = a.cloneNode(true).cloneNode(true).lastChild.checked;
      c(function() {
        var r = t.createElement("div");
        r.style.width = r.style.paddingLeft = "1px";
        t.body.appendChild(r);
        c.boxModel = c.support.boxModel = r.offsetWidth === 2;
        if ("zoom" in r.style) {
          r.style.display = "inline";
          r.style.zoom =
            1;
          c.support.inlineBlockNeedsLayout = r.offsetWidth === 2;
          r.style.display = "";
          r.innerHTML = "<div style='width:4px;'></div>";
          c.support.shrinkWrapBlocks = r.offsetWidth !== 2
        }
        r.innerHTML = "<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";
        var A = r.getElementsByTagName("td");
        c.support.reliableHiddenOffsets = A[0].offsetHeight === 0;
        A[0].style.display = "";
        A[1].style.display = "none";
        c.support.reliableHiddenOffsets = c.support.reliableHiddenOffsets && A[0].offsetHeight === 0;
        r.innerHTML = "";
        t.body.removeChild(r).style.display =
          "none"
      });
      a = function(r) {
        var A = t.createElement("div");
        r = "on" + r;
        var C = r in A;
        if (!C) {
          A.setAttribute(r, "return;");
          C = typeof A[r] === "function"
        }
        return C
      };
      c.support.submitBubbles = a("submit");
      c.support.changeBubbles = a("change");
      a = b = d = f = h = null
    }
  })();
  var ra = {},
    Ja = /^(?:\{.*\}|\[.*\])$/;
  c.extend({
    cache: {},
    uuid: 0,
    expando: "jQuery" + c.now(),
    noData: {
      embed: true,
      object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
      applet: true
    },
    data: function(a, b, d) {
      if (c.acceptData(a)) {
        a = a == E ? ra : a;
        var e = a.nodeType,
          f = e ? a[c.expando] : null,
          h =
          c.cache;
        if (!(e && !f && typeof b === "string" && d === B)) {
          if (e) f || (a[c.expando] = f = ++c.uuid);
          else h = a;
          if (typeof b === "object")
            if (e) h[f] = c.extend(h[f], b);
            else c.extend(h, b);
          else if (e && !h[f]) h[f] = {};
          a = e ? h[f] : h;
          if (d !== B) a[b] = d;
          return typeof b === "string" ? a[b] : a
        }
      }
    },
    removeData: function(a, b) {
      if (c.acceptData(a)) {
        a = a == E ? ra : a;
        var d = a.nodeType,
          e = d ? a[c.expando] : a,
          f = c.cache,
          h = d ? f[e] : e;
        if (b) {
          if (h) {
            delete h[b];
            d && c.isEmptyObject(h) && c.removeData(a)
          }
        } else if (d && c.support.deleteExpando) delete a[c.expando];
        else if (a.removeAttribute) a.removeAttribute(c.expando);
        else if (d) delete f[e];
        else
          for (var l in a) delete a[l]
      }
    },
    acceptData: function(a) {
      if (a.nodeName) {
        var b = c.noData[a.nodeName.toLowerCase()];
        if (b) return !(b === true || a.getAttribute("classid") !== b)
      }
      return true
    }
  });
  c.fn.extend({
    data: function(a, b) {
      var d = null;
      if (typeof a === "undefined") {
        if (this.length) {
          var e = this[0].attributes,
            f;
          d = c.data(this[0]);
          for (var h = 0, l = e.length; h < l; h++) {
            f = e[h].name;
            if (f.indexOf("data-") === 0) {
              f = f.substr(5);
              ka(this[0], f, d[f])
            }
          }
        }
        return d
      } else if (typeof a === "object") return this.each(function() {
        c.data(this,
          a)
      });
      var k = a.split(".");
      k[1] = k[1] ? "." + k[1] : "";
      if (b === B) {
        d = this.triggerHandler("getData" + k[1] + "!", [k[0]]);
        if (d === B && this.length) {
          d = c.data(this[0], a);
          d = ka(this[0], a, d)
        }
        return d === B && k[1] ? this.data(k[0]) : d
      } else return this.each(function() {
        var o = c(this),
          x = [k[0], b];
        o.triggerHandler("setData" + k[1] + "!", x);
        c.data(this, a, b);
        o.triggerHandler("changeData" + k[1] + "!", x)
      })
    },
    removeData: function(a) {
      return this.each(function() {
        c.removeData(this, a)
      })
    }
  });
  c.extend({
    queue: function(a, b, d) {
      if (a) {
        b = (b || "fx") + "queue";
        var e =
          c.data(a, b);
        if (!d) return e || [];
        if (!e || c.isArray(d)) e = c.data(a, b, c.makeArray(d));
        else e.push(d);
        return e
      }
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var d = c.queue(a, b),
        e = d.shift();
      if (e === "inprogress") e = d.shift();
      if (e) {
        b === "fx" && d.unshift("inprogress");
        e.call(a, function() {
          c.dequeue(a, b)
        })
      }
    }
  });
  c.fn.extend({
    queue: function(a, b) {
      if (typeof a !== "string") {
        b = a;
        a = "fx"
      }
      if (b === B) return c.queue(this[0], a);
      return this.each(function() {
        var d = c.queue(this, a, b);
        a === "fx" && d[0] !== "inprogress" && c.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        c.dequeue(this,
          a)
      })
    },
    delay: function(a, b) {
      a = c.fx ? c.fx.speeds[a] || a : a;
      b = b || "fx";
      return this.queue(b, function() {
        var d = this;
        setTimeout(function() {
          c.dequeue(d, b)
        }, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    }
  });
  var sa = /[\n\t]/g,
    ha = /\s+/,
    Sa = /\r/g,
    Ta = /^(?:href|src|style)$/,
    Ua = /^(?:button|input)$/i,
    Va = /^(?:button|input|object|select|textarea)$/i,
    Wa = /^a(?:rea)?$/i,
    ta = /^(?:radio|checkbox)$/i;
  c.props = {
    "for": "htmlFor",
    "class": "className",
    readonly: "readOnly",
    maxlength: "maxLength",
    cellspacing: "cellSpacing",
    rowspan: "rowSpan",
    colspan: "colSpan",
    tabindex: "tabIndex",
    usemap: "useMap",
    frameborder: "frameBorder"
  };
  c.fn.extend({
    attr: function(a, b) {
      return c.access(this, a, b, true, c.attr)
    },
    removeAttr: function(a) {
      return this.each(function() {
        c.attr(this, a, "");
        this.nodeType === 1 && this.removeAttribute(a)
      })
    },
    addClass: function(a) {
      if (c.isFunction(a)) return this.each(function(x) {
        var r = c(this);
        r.addClass(a.call(this, x, r.attr("class")))
      });
      if (a && typeof a === "string")
        for (var b = (a || "").split(ha), d = 0, e = this.length; d < e; d++) {
          var f = this[d];
          if (f.nodeType ===
            1)
            if (f.className) {
              for (var h = " " + f.className + " ", l = f.className, k = 0, o = b.length; k < o; k++)
                if (h.indexOf(" " + b[k] + " ") < 0) l += " " + b[k];
              f.className = c.trim(l)
            } else f.className = a
        }
      return this
    },
    removeClass: function(a) {
      if (c.isFunction(a)) return this.each(function(o) {
        var x = c(this);
        x.removeClass(a.call(this, o, x.attr("class")))
      });
      if (a && typeof a === "string" || a === B)
        for (var b = (a || "").split(ha), d = 0, e = this.length; d < e; d++) {
          var f = this[d];
          if (f.nodeType === 1 && f.className)
            if (a) {
              for (var h = (" " + f.className + " ").replace(sa, " "),
                  l = 0, k = b.length; l < k; l++) h = h.replace(" " + b[l] + " ", " ");
              f.className = c.trim(h)
            } else f.className = ""
        }
      return this
    },
    toggleClass: function(a, b) {
      var d = typeof a,
        e = typeof b === "boolean";
      if (c.isFunction(a)) return this.each(function(f) {
        var h = c(this);
        h.toggleClass(a.call(this, f, h.attr("class"), b), b)
      });
      return this.each(function() {
        if (d === "string")
          for (var f, h = 0, l = c(this), k = b, o = a.split(ha); f = o[h++];) {
            k = e ? k : !l.hasClass(f);
            l[k ? "addClass" : "removeClass"](f)
          } else if (d === "undefined" || d === "boolean") {
            this.className && c.data(this,
              "__className__", this.className);
            this.className = this.className || a === false ? "" : c.data(this, "__className__") || ""
          }
      })
    },
    hasClass: function(a) {
      a = " " + a + " ";
      for (var b = 0, d = this.length; b < d; b++)
        if ((" " + this[b].className + " ").replace(sa, " ").indexOf(a) > -1) return true;
      return false
    },
    val: function(a) {
      if (!arguments.length) {
        var b = this[0];
        if (b) {
          if (c.nodeName(b, "option")) {
            var d = b.attributes.value;
            return !d || d.specified ? b.value : b.text
          }
          if (c.nodeName(b, "select")) {
            var e = b.selectedIndex;
            d = [];
            var f = b.options;
            b = b.type === "select-one";
            if (e < 0) return null;
            var h = b ? e : 0;
            for (e = b ? e + 1 : f.length; h < e; h++) {
              var l = f[h];
              if (l.selected && (c.support.optDisabled ? !l.disabled : l.getAttribute("disabled") === null) && (!l.parentNode.disabled || !c.nodeName(l.parentNode, "optgroup"))) {
                a = c(l).val();
                if (b) return a;
                d.push(a)
              }
            }
            return d
          }
          if (ta.test(b.type) && !c.support.checkOn) return b.getAttribute("value") === null ? "on" : b.value;
          return (b.value || "").replace(Sa, "")
        }
        return B
      }
      var k = c.isFunction(a);
      return this.each(function(o) {
        var x = c(this),
          r = a;
        if (this.nodeType === 1) {
          if (k) r =
            a.call(this, o, x.val());
          if (r == null) r = "";
          else if (typeof r === "number") r += "";
          else if (c.isArray(r)) r = c.map(r, function(C) {
            return C == null ? "" : C + ""
          });
          if (c.isArray(r) && ta.test(this.type)) this.checked = c.inArray(x.val(), r) >= 0;
          else if (c.nodeName(this, "select")) {
            var A = c.makeArray(r);
            c("option", this).each(function() {
              this.selected = c.inArray(c(this).val(), A) >= 0
            });
            if (!A.length) this.selectedIndex = -1
          } else this.value = r
        }
      })
    }
  });
  c.extend({
    attrFn: {
      val: true,
      css: true,
      html: true,
      text: true,
      data: true,
      width: true,
      height: true,
      offset: true
    },
    attr: function(a, b, d, e) {
      if (!a || a.nodeType === 3 || a.nodeType === 8) return B;
      if (e && b in c.attrFn) return c(a)[b](d);
      e = a.nodeType !== 1 || !c.isXMLDoc(a);
      var f = d !== B;
      b = e && c.props[b] || b;
      var h = Ta.test(b);
      if ((b in a || a[b] !== B) && e && !h) {
        if (f) {
          b === "type" && Ua.test(a.nodeName) && a.parentNode && c.error("type property can't be changed");
          if (d === null) a.nodeType === 1 && a.removeAttribute(b);
          else a[b] = d
        }
        if (c.nodeName(a, "form") && a.getAttributeNode(b)) return a.getAttributeNode(b).nodeValue;
        if (b === "tabIndex") return (b = a.getAttributeNode("tabIndex")) &&
          b.specified ? b.value : Va.test(a.nodeName) || Wa.test(a.nodeName) && a.href ? 0 : B;
        return a[b]
      }
      if (!c.support.style && e && b === "style") {
        if (f) a.style.cssText = "" + d;
        return a.style.cssText
      }
      f && a.setAttribute(b, "" + d);
      if (!a.attributes[b] && a.hasAttribute && !a.hasAttribute(b)) return B;
      a = !c.support.hrefNormalized && e && h ? a.getAttribute(b, 2) : a.getAttribute(b);
      return a === null ? B : a
    }
  });
  var X = /\.(.*)$/,
    ia = /^(?:textarea|input|select)$/i,
    La = /\./g,
    Ma = / /g,
    Xa = /[^\w\s.|`]/g,
    Ya = function(a) {
      return a.replace(Xa, "\\$&")
    },
    ua = {
      focusin: 0,
      focusout: 0
    };
  c.event = {
    add: function(a, b, d, e) {
      if (!(a.nodeType === 3 || a.nodeType === 8)) {
        if (c.isWindow(a) && a !== E && !a.frameElement) a = E;
        if (d === false) d = U;
        else if (!d) return;
        var f, h;
        if (d.handler) {
          f = d;
          d = f.handler
        }
        if (!d.guid) d.guid = c.guid++;
        if (h = c.data(a)) {
          var l = a.nodeType ? "events" : "__events__",
            k = h[l],
            o = h.handle;
          if (typeof k === "function") {
            o = k.handle;
            k = k.events
          } else if (!k) {
            a.nodeType || (h[l] = h = function() {});
            h.events = k = {}
          }
          if (!o) h.handle = o = function() {
            return typeof c !== "undefined" && !c.event.triggered ? c.event.handle.apply(o.elem,
              arguments) : B
          };
          o.elem = a;
          b = b.split(" ");
          for (var x = 0, r; l = b[x++];) {
            h = f ? c.extend({}, f) : {
              handler: d,
              data: e
            };
            if (l.indexOf(".") > -1) {
              r = l.split(".");
              l = r.shift();
              h.namespace = r.slice(0).sort().join(".")
            } else {
              r = [];
              h.namespace = ""
            }
            h.type = l;
            if (!h.guid) h.guid = d.guid;
            var A = k[l],
              C = c.event.special[l] || {};
            if (!A) {
              A = k[l] = [];
              if (!C.setup || C.setup.call(a, e, r, o) === false)
                if (a.addEventListener) a.addEventListener(l, o, false);
                else a.attachEvent && a.attachEvent("on" + l, o)
            }
            if (C.add) {
              C.add.call(a, h);
              if (!h.handler.guid) h.handler.guid =
                d.guid
            }
            A.push(h);
            c.event.global[l] = true
          }
          a = null
        }
      }
    },
    global: {},
    remove: function(a, b, d, e) {
      if (!(a.nodeType === 3 || a.nodeType === 8)) {
        if (d === false) d = U;
        var f, h, l = 0,
          k, o, x, r, A, C, J = a.nodeType ? "events" : "__events__",
          w = c.data(a),
          I = w && w[J];
        if (w && I) {
          if (typeof I === "function") {
            w = I;
            I = I.events
          }
          if (b && b.type) {
            d = b.handler;
            b = b.type
          }
          if (!b || typeof b === "string" && b.charAt(0) === ".") {
            b = b || "";
            for (f in I) c.event.remove(a, f + b)
          } else {
            for (b = b.split(" "); f = b[l++];) {
              r = f;
              k = f.indexOf(".") < 0;
              o = [];
              if (!k) {
                o = f.split(".");
                f = o.shift();
                x = RegExp("(^|\\.)" +
                  c.map(o.slice(0).sort(), Ya).join("\\.(?:.*\\.)?") + "(\\.|$)")
              }
              if (A = I[f])
                if (d) {
                  r = c.event.special[f] || {};
                  for (h = e || 0; h < A.length; h++) {
                    C = A[h];
                    if (d.guid === C.guid) {
                      if (k || x.test(C.namespace)) {
                        e == null && A.splice(h--, 1);
                        r.remove && r.remove.call(a, C)
                      }
                      if (e != null) break
                    }
                  }
                  if (A.length === 0 || e != null && A.length === 1) {
                    if (!r.teardown || r.teardown.call(a, o) === false) c.removeEvent(a, f, w.handle);
                    delete I[f]
                  }
                } else
                  for (h = 0; h < A.length; h++) {
                    C = A[h];
                    if (k || x.test(C.namespace)) {
                      c.event.remove(a, r, C.handler, h);
                      A.splice(h--, 1)
                    }
                  }
            }
            if (c.isEmptyObject(I)) {
              if (b =
                w.handle) b.elem = null;
              delete w.events;
              delete w.handle;
              if (typeof w === "function") c.removeData(a, J);
              else c.isEmptyObject(w) && c.removeData(a)
            }
          }
        }
      }
    },
    trigger: function(a, b, d, e) {
      var f = a.type || a;
      if (!e) {
        a = typeof a === "object" ? a[c.expando] ? a : c.extend(c.Event(f), a) : c.Event(f);
        if (f.indexOf("!") >= 0) {
          a.type = f = f.slice(0, -1);
          a.exclusive = true
        }
        if (!d) {
          a.stopPropagation();
          c.event.global[f] && c.each(c.cache, function() {
            this.events && this.events[f] && c.event.trigger(a, b, this.handle.elem)
          })
        }
        if (!d || d.nodeType === 3 || d.nodeType ===
          8) return B;
        a.result = B;
        a.target = d;
        b = c.makeArray(b);
        b.unshift(a)
      }
      a.currentTarget = d;
      (e = d.nodeType ? c.data(d, "handle") : (c.data(d, "__events__") || {}).handle) && e.apply(d, b);
      e = d.parentNode || d.ownerDocument;
      try {
        if (!(d && d.nodeName && c.noData[d.nodeName.toLowerCase()]))
          if (d["on" + f] && d["on" + f].apply(d, b) === false) {
            a.result = false;
            a.preventDefault()
          }
      } catch (h) {}
      if (!a.isPropagationStopped() && e) c.event.trigger(a, b, e, true);
      else if (!a.isDefaultPrevented()) {
        var l;
        e = a.target;
        var k = f.replace(X, ""),
          o = c.nodeName(e, "a") && k ===
          "click",
          x = c.event.special[k] || {};
        if ((!x._default || x._default.call(d, a) === false) && !o && !(e && e.nodeName && c.noData[e.nodeName.toLowerCase()])) {
          try {
            if (e[k]) {
              if (l = e["on" + k]) e["on" + k] = null;
              c.event.triggered = true;
              e[k]()
            }
          } catch (r) {}
          if (l) e["on" + k] = l;
          c.event.triggered = false
        }
      }
    },
    handle: function(a) {
      var b, d, e, f;
      d = [];
      var h = c.makeArray(arguments);
      a = h[0] = c.event.fix(a || E.event);
      a.currentTarget = this;
      b = a.type.indexOf(".") < 0 && !a.exclusive;
      if (!b) {
        e = a.type.split(".");
        a.type = e.shift();
        d = e.slice(0).sort();
        e = RegExp("(^|\\.)" +
          d.join("\\.(?:.*\\.)?") + "(\\.|$)")
      }
      a.namespace = a.namespace || d.join(".");
      f = c.data(this, this.nodeType ? "events" : "__events__");
      if (typeof f === "function") f = f.events;
      d = (f || {})[a.type];
      if (f && d) {
        d = d.slice(0);
        f = 0;
        for (var l = d.length; f < l; f++) {
          var k = d[f];
          if (b || e.test(k.namespace)) {
            a.handler = k.handler;
            a.data = k.data;
            a.handleObj = k;
            k = k.handler.apply(this, h);
            if (k !== B) {
              a.result = k;
              if (k === false) {
                a.preventDefault();
                a.stopPropagation()
              }
            }
            if (a.isImmediatePropagationStopped()) break
          }
        }
      }
      return a.result
    },
    props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
    fix: function(a) {
      if (a[c.expando]) return a;
      var b = a;
      a = c.Event(b);
      for (var d = this.props.length, e; d;) {
        e = this.props[--d];
        a[e] = b[e]
      }
      if (!a.target) a.target = a.srcElement || t;
      if (a.target.nodeType === 3) a.target = a.target.parentNode;
      if (!a.relatedTarget && a.fromElement) a.relatedTarget = a.fromElement === a.target ? a.toElement : a.fromElement;
      if (a.pageX == null && a.clientX != null) {
        b = t.documentElement;
        d = t.body;
        a.pageX = a.clientX + (b && b.scrollLeft || d && d.scrollLeft || 0) - (b && b.clientLeft || d && d.clientLeft || 0);
        a.pageY = a.clientY + (b && b.scrollTop ||
          d && d.scrollTop || 0) - (b && b.clientTop || d && d.clientTop || 0)
      }
      if (a.which == null && (a.charCode != null || a.keyCode != null)) a.which = a.charCode != null ? a.charCode : a.keyCode;
      if (!a.metaKey && a.ctrlKey) a.metaKey = a.ctrlKey;
      if (!a.which && a.button !== B) a.which = a.button & 1 ? 1 : a.button & 2 ? 3 : a.button & 4 ? 2 : 0;
      return a
    },
    guid: 1E8,
    proxy: c.proxy,
    special: {
      ready: {
        setup: c.bindReady,
        teardown: c.noop
      },
      live: {
        add: function(a) {
          c.event.add(this, Y(a.origType, a.selector), c.extend({}, a, {
            handler: Ka,
            guid: a.handler.guid
          }))
        },
        remove: function(a) {
          c.event.remove(this,
            Y(a.origType, a.selector), a)
        }
      },
      beforeunload: {
        setup: function(a, b, d) {
          if (c.isWindow(this)) this.onbeforeunload = d
        },
        teardown: function(a, b) {
          if (this.onbeforeunload === b) this.onbeforeunload = null
        }
      }
    }
  };
  c.removeEvent = t.removeEventListener ? function(a, b, d) {
    a.removeEventListener && a.removeEventListener(b, d, false)
  } : function(a, b, d) {
    a.detachEvent && a.detachEvent("on" + b, d)
  };
  c.Event = function(a) {
    if (!this.preventDefault) return new c.Event(a);
    if (a && a.type) {
      this.originalEvent = a;
      this.type = a.type
    } else this.type = a;
    this.timeStamp =
      c.now();
    this[c.expando] = true
  };
  c.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = ca;
      var a = this.originalEvent;
      if (a)
        if (a.preventDefault) a.preventDefault();
        else a.returnValue = false
    },
    stopPropagation: function() {
      this.isPropagationStopped = ca;
      var a = this.originalEvent;
      if (a) {
        a.stopPropagation && a.stopPropagation();
        a.cancelBubble = true
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = ca;
      this.stopPropagation()
    },
    isDefaultPrevented: U,
    isPropagationStopped: U,
    isImmediatePropagationStopped: U
  };
  var va = function(a) {
      var b = a.relatedTarget;
      try {
        for (; b && b !== this;) b = b.parentNode;
        if (b !== this) {
          a.type = a.data;
          c.event.handle.apply(this, arguments)
        }
      } catch (d) {}
    },
    wa = function(a) {
      a.type = a.data;
      c.event.handle.apply(this, arguments)
    };
  c.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function(a, b) {
    c.event.special[a] = {
      setup: function(d) {
        c.event.add(this, b, d && d.selector ? wa : va, a)
      },
      teardown: function(d) {
        c.event.remove(this, b, d && d.selector ? wa : va)
      }
    }
  });
  if (!c.support.submitBubbles) c.event.special.submit = {
    setup: function() {
      if (this.nodeName.toLowerCase() !==
        "form") {
        c.event.add(this, "click.specialSubmit", function(a) {
          var b = a.target,
            d = b.type;
          if ((d === "submit" || d === "image") && c(b).closest("form").length) {
            a.liveFired = B;
            return la("submit", this, arguments)
          }
        });
        c.event.add(this, "keypress.specialSubmit", function(a) {
          var b = a.target,
            d = b.type;
          if ((d === "text" || d === "password") && c(b).closest("form").length && a.keyCode === 13) {
            a.liveFired = B;
            return la("submit", this, arguments)
          }
        })
      } else return false
    },
    teardown: function() {
      c.event.remove(this, ".specialSubmit")
    }
  };
  if (!c.support.changeBubbles) {
    var V,
      xa = function(a) {
        var b = a.type,
          d = a.value;
        if (b === "radio" || b === "checkbox") d = a.checked;
        else if (b === "select-multiple") d = a.selectedIndex > -1 ? c.map(a.options, function(e) {
          return e.selected
        }).join("-") : "";
        else if (a.nodeName.toLowerCase() === "select") d = a.selectedIndex;
        return d
      },
      Z = function(a, b) {
        var d = a.target,
          e, f;
        if (!(!ia.test(d.nodeName) || d.readOnly)) {
          e = c.data(d, "_change_data");
          f = xa(d);
          if (a.type !== "focusout" || d.type !== "radio") c.data(d, "_change_data", f);
          if (!(e === B || f === e))
            if (e != null || f) {
              a.type = "change";
              a.liveFired =
                B;
              return c.event.trigger(a, b, d)
            }
        }
      };
    c.event.special.change = {
      filters: {
        focusout: Z,
        beforedeactivate: Z,
        click: function(a) {
          var b = a.target,
            d = b.type;
          if (d === "radio" || d === "checkbox" || b.nodeName.toLowerCase() === "select") return Z.call(this, a)
        },
        keydown: function(a) {
          var b = a.target,
            d = b.type;
          if (a.keyCode === 13 && b.nodeName.toLowerCase() !== "textarea" || a.keyCode === 32 && (d === "checkbox" || d === "radio") || d === "select-multiple") return Z.call(this, a)
        },
        beforeactivate: function(a) {
          a = a.target;
          c.data(a, "_change_data", xa(a))
        }
      },
      setup: function() {
        if (this.type ===
          "file") return false;
        for (var a in V) c.event.add(this, a + ".specialChange", V[a]);
        return ia.test(this.nodeName)
      },
      teardown: function() {
        c.event.remove(this, ".specialChange");
        return ia.test(this.nodeName)
      }
    };
    V = c.event.special.change.filters;
    V.focus = V.beforeactivate
  }
  t.addEventListener && c.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    function d(e) {
      e = c.event.fix(e);
      e.type = b;
      return c.event.trigger(e, null, e.target)
    }
    c.event.special[b] = {
      setup: function() {
        ua[b]++ === 0 && t.addEventListener(a, d, true)
      },
      teardown: function() {
        --ua[b] ===
          0 && t.removeEventListener(a, d, true)
      }
    }
  });
  c.each(["bind", "one"], function(a, b) {
    c.fn[b] = function(d, e, f) {
      if (typeof d === "object") {
        for (var h in d) this[b](h, e, d[h], f);
        return this
      }
      if (c.isFunction(e) || e === false) {
        f = e;
        e = B
      }
      var l = b === "one" ? c.proxy(f, function(o) {
        c(this).unbind(o, l);
        return f.apply(this, arguments)
      }) : f;
      if (d === "unload" && b !== "one") this.one(d, e, f);
      else {
        h = 0;
        for (var k = this.length; h < k; h++) c.event.add(this[h], d, l, e)
      }
      return this
    }
  });
  c.fn.extend({
    unbind: function(a, b) {
      if (typeof a === "object" && !a.preventDefault)
        for (var d in a) this.unbind(d,
          a[d]);
      else {
        d = 0;
        for (var e = this.length; d < e; d++) c.event.remove(this[d], a, b)
      }
      return this
    },
    delegate: function(a, b, d, e) {
      return this.live(b, d, e, a)
    },
    undelegate: function(a, b, d) {
      return arguments.length === 0 ? this.unbind("live") : this.die(b, null, d, a)
    },
    trigger: function(a, b) {
      return this.each(function() {
        c.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      if (this[0]) {
        var d = c.Event(a);
        d.preventDefault();
        d.stopPropagation();
        c.event.trigger(d, b, this[0]);
        return d.result
      }
    },
    toggle: function(a) {
      for (var b = arguments, d =
          1; d < b.length;) c.proxy(a, b[d++]);
      return this.click(c.proxy(a, function(e) {
        var f = (c.data(this, "lastToggle" + a.guid) || 0) % d;
        c.data(this, "lastToggle" + a.guid, f + 1);
        e.preventDefault();
        return b[f].apply(this, arguments) || false
      }))
    },
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    }
  });
  var ya = {
    focus: "focusin",
    blur: "focusout",
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  c.each(["live", "die"], function(a, b) {
    c.fn[b] = function(d, e, f, h) {
      var l, k = 0,
        o, x, r = h || this.selector;
      h = h ? this : c(this.context);
      if (typeof d ===
        "object" && !d.preventDefault) {
        for (l in d) h[b](l, e, d[l], r);
        return this
      }
      if (c.isFunction(e)) {
        f = e;
        e = B
      }
      for (d = (d || "").split(" ");
        (l = d[k++]) != null;) {
        o = X.exec(l);
        x = "";
        if (o) {
          x = o[0];
          l = l.replace(X, "")
        }
        if (l === "hover") d.push("mouseenter" + x, "mouseleave" + x);
        else {
          o = l;
          if (l === "focus" || l === "blur") {
            d.push(ya[l] + x);
            l += x
          } else l = (ya[l] || l) + x;
          if (b === "live") {
            x = 0;
            for (var A = h.length; x < A; x++) c.event.add(h[x], "live." + Y(l, r), {
              data: e,
              selector: r,
              handler: f,
              origType: l,
              origHandler: f,
              preType: o
            })
          } else h.unbind("live." + Y(l, r), f)
        }
      }
      return this
    }
  });
  c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "), function(a, b) {
    c.fn[b] = function(d, e) {
      if (e == null) {
        e = d;
        d = null
      }
      return arguments.length > 0 ? this.bind(b, d, e) : this.trigger(b)
    };
    if (c.attrFn) c.attrFn[b] = true
  });
  E.attachEvent && !E.addEventListener && c(E).bind("unload", function() {
    for (var a in c.cache)
      if (c.cache[a].handle) try {
        c.event.remove(c.cache[a].handle.elem)
      } catch (b) {}
  });
  (function() {
    function a(g, i, n, m, p, q) {
      p = 0;
      for (var u = m.length; p < u; p++) {
        var y = m[p];
        if (y) {
          var F = false;
          for (y = y[g]; y;) {
            if (y.sizcache === n) {
              F = m[y.sizset];
              break
            }
            if (y.nodeType === 1 && !q) {
              y.sizcache = n;
              y.sizset = p
            }
            if (y.nodeName.toLowerCase() === i) {
              F = y;
              break
            }
            y = y[g]
          }
          m[p] = F
        }
      }
    }

    function b(g, i, n, m, p, q) {
      p = 0;
      for (var u = m.length; p < u; p++) {
        var y = m[p];
        if (y) {
          var F = false;
          for (y = y[g]; y;) {
            if (y.sizcache === n) {
              F = m[y.sizset];
              break
            }
            if (y.nodeType === 1) {
              if (!q) {
                y.sizcache = n;
                y.sizset = p
              }
              if (typeof i !== "string") {
                if (y === i) {
                  F = true;
                  break
                }
              } else if (k.filter(i, [y]).length > 0) {
                F = y;
                break
              }
            }
            y = y[g]
          }
          m[p] = F
        }
      }
    }
    var d = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
      e = 0,
      f = Object.prototype.toString,
      h = false,
      l = true;
    [0, 0].sort(function() {
      l = false;
      return 0
    });
    var k = function(g, i, n, m) {
      n = n || [];
      var p = i = i || t;
      if (i.nodeType !== 1 && i.nodeType !== 9) return [];
      if (!g || typeof g !== "string") return n;
      var q, u, y, F, M, N = true,
        O = k.isXML(i),
        D = [],
        R = g;
      do {
        d.exec("");
        if (q = d.exec(R)) {
          R = q[3];
          D.push(q[1]);
          if (q[2]) {
            F = q[3];
            break
          }
        }
      } while (q);
      if (D.length > 1 && x.exec(g))
        if (D.length === 2 && o.relative[D[0]]) u = L(D[0] + D[1], i);
        else
          for (u = o.relative[D[0]] ? [i] : k(D.shift(), i); D.length;) {
            g = D.shift();
            if (o.relative[g]) g += D.shift();
            u = L(g, u)
          } else {
            if (!m && D.length > 1 && i.nodeType === 9 && !O && o.match.ID.test(D[0]) && !o.match.ID.test(D[D.length - 1])) {
              q = k.find(D.shift(), i, O);
              i = q.expr ? k.filter(q.expr, q.set)[0] : q.set[0]
            }
            if (i) {
              q = m ? {
                expr: D.pop(),
                set: C(m)
              } : k.find(D.pop(), D.length === 1 && (D[0] === "~" || D[0] === "+") && i.parentNode ? i.parentNode : i, O);
              u = q.expr ? k.filter(q.expr,
                q.set) : q.set;
              if (D.length > 0) y = C(u);
              else N = false;
              for (; D.length;) {
                q = M = D.pop();
                if (o.relative[M]) q = D.pop();
                else M = "";
                if (q == null) q = i;
                o.relative[M](y, q, O)
              }
            } else y = []
          }
      y || (y = u);
      y || k.error(M || g);
      if (f.call(y) === "[object Array]")
        if (N)
          if (i && i.nodeType === 1)
            for (g = 0; y[g] != null; g++) {
              if (y[g] && (y[g] === true || y[g].nodeType === 1 && k.contains(i, y[g]))) n.push(u[g])
            } else
              for (g = 0; y[g] != null; g++) y[g] && y[g].nodeType === 1 && n.push(u[g]);
          else n.push.apply(n, y);
      else C(y, n);
      if (F) {
        k(F, p, n, m);
        k.uniqueSort(n)
      }
      return n
    };
    k.uniqueSort = function(g) {
      if (w) {
        h =
          l;
        g.sort(w);
        if (h)
          for (var i = 1; i < g.length; i++) g[i] === g[i - 1] && g.splice(i--, 1)
      }
      return g
    };
    k.matches = function(g, i) {
      return k(g, null, null, i)
    };
    k.matchesSelector = function(g, i) {
      return k(i, null, null, [g]).length > 0
    };
    k.find = function(g, i, n) {
      var m;
      if (!g) return [];
      for (var p = 0, q = o.order.length; p < q; p++) {
        var u, y = o.order[p];
        if (u = o.leftMatch[y].exec(g)) {
          var F = u[1];
          u.splice(1, 1);
          if (F.substr(F.length - 1) !== "\\") {
            u[1] = (u[1] || "").replace(/\\/g, "");
            m = o.find[y](u, i, n);
            if (m != null) {
              g = g.replace(o.match[y], "");
              break
            }
          }
        }
      }
      m || (m = i.getElementsByTagName("*"));
      return {
        set: m,
        expr: g
      }
    };
    k.filter = function(g, i, n, m) {
      for (var p, q, u = g, y = [], F = i, M = i && i[0] && k.isXML(i[0]); g && i.length;) {
        for (var N in o.filter)
          if ((p = o.leftMatch[N].exec(g)) != null && p[2]) {
            var O, D, R = o.filter[N];
            D = p[1];
            q = false;
            p.splice(1, 1);
            if (D.substr(D.length - 1) !== "\\") {
              if (F === y) y = [];
              if (o.preFilter[N])
                if (p = o.preFilter[N](p, F, n, y, m, M)) {
                  if (p === true) continue
                } else q = O = true;
              if (p)
                for (var j = 0;
                  (D = F[j]) != null; j++)
                  if (D) {
                    O = R(D, p, j, F);
                    var s = m ^ !!O;
                    if (n && O != null)
                      if (s) q = true;
                      else F[j] = false;
                    else if (s) {
                      y.push(D);
                      q = true
                    }
                  }
              if (O !==
                B) {
                n || (F = y);
                g = g.replace(o.match[N], "");
                if (!q) return [];
                break
              }
            }
          }
        if (g === u)
          if (q == null) k.error(g);
          else break;
        u = g
      }
      return F
    };
    k.error = function(g) {
      throw "Syntax error, unrecognized expression: " + g;
    };
    var o = k.selectors = {
        order: ["ID", "NAME", "TAG"],
        match: {
          ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
          CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
          NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
          ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
          TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
          CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
          POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
          PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
        },
        leftMatch: {},
        attrMap: {
          "class": "className",
          "for": "htmlFor"
        },
        attrHandle: {
          href: function(g) {
            return g.getAttribute("href")
          }
        },
        relative: {
          "+": function(g, i) {
            var n = typeof i === "string",
              m = n && !/\W/.test(i);
            n = n && !m;
            if (m) i = i.toLowerCase();
            m = 0;
            for (var p = g.length, q; m < p; m++)
              if (q = g[m]) {
                for (;
                  (q = q.previousSibling) && q.nodeType !== 1;);
                g[m] = n || q && q.nodeName.toLowerCase() ===
                  i ? q || false : q === i
              }
            n && k.filter(i, g, true)
          },
          ">": function(g, i) {
            var n, m = typeof i === "string",
              p = 0,
              q = g.length;
            if (m && !/\W/.test(i))
              for (i = i.toLowerCase(); p < q; p++) {
                if (n = g[p]) {
                  n = n.parentNode;
                  g[p] = n.nodeName.toLowerCase() === i ? n : false
                }
              } else {
                for (; p < q; p++)
                  if (n = g[p]) g[p] = m ? n.parentNode : n.parentNode === i;
                m && k.filter(i, g, true)
              }
          },
          "": function(g, i, n) {
            var m, p = e++,
              q = b;
            if (typeof i === "string" && !/\W/.test(i)) {
              m = i = i.toLowerCase();
              q = a
            }
            q("parentNode", i, p, g, m, n)
          },
          "~": function(g, i, n) {
            var m, p = e++,
              q = b;
            if (typeof i === "string" && !/\W/.test(i)) {
              m =
                i = i.toLowerCase();
              q = a
            }
            q("previousSibling", i, p, g, m, n)
          }
        },
        find: {
          ID: function(g, i, n) {
            if (typeof i.getElementById !== "undefined" && !n) return (g = i.getElementById(g[1])) && g.parentNode ? [g] : []
          },
          NAME: function(g, i) {
            if (typeof i.getElementsByName !== "undefined") {
              for (var n = [], m = i.getElementsByName(g[1]), p = 0, q = m.length; p < q; p++) m[p].getAttribute("name") === g[1] && n.push(m[p]);
              return n.length === 0 ? null : n
            }
          },
          TAG: function(g, i) {
            return i.getElementsByTagName(g[1])
          }
        },
        preFilter: {
          CLASS: function(g, i, n, m, p, q) {
            g = " " + g[1].replace(/\\/g,
              "") + " ";
            if (q) return g;
            q = 0;
            for (var u;
              (u = i[q]) != null; q++)
              if (u)
                if (p ^ (u.className && (" " + u.className + " ").replace(/[\t\n]/g, " ").indexOf(g) >= 0)) n || m.push(u);
                else if (n) i[q] = false;
            return false
          },
          ID: function(g) {
            return g[1].replace(/\\/g, "")
          },
          TAG: function(g) {
            return g[1].toLowerCase()
          },
          CHILD: function(g) {
            if (g[1] === "nth") {
              var i = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2] === "even" && "2n" || g[2] === "odd" && "2n+1" || !/\D/.test(g[2]) && "0n+" + g[2] || g[2]);
              g[2] = i[1] + (i[2] || 1) - 0;
              g[3] = i[3] - 0
            }
            g[0] = e++;
            return g
          },
          ATTR: function(g, i, n,
            m, p, q) {
            i = g[1].replace(/\\/g, "");
            if (!q && o.attrMap[i]) g[1] = o.attrMap[i];
            if (g[2] === "~=") g[4] = " " + g[4] + " ";
            return g
          },
          PSEUDO: function(g, i, n, m, p) {
            if (g[1] === "not")
              if ((d.exec(g[3]) || "").length > 1 || /^\w/.test(g[3])) g[3] = k(g[3], null, null, i);
              else {
                g = k.filter(g[3], i, n, true ^ p);
                n || m.push.apply(m, g);
                return false
              }
            else if (o.match.POS.test(g[0]) || o.match.CHILD.test(g[0])) return true;
            return g
          },
          POS: function(g) {
            g.unshift(true);
            return g
          }
        },
        filters: {
          enabled: function(g) {
            return g.disabled === false && g.type !== "hidden"
          },
          disabled: function(g) {
            return g.disabled ===
              true
          },
          checked: function(g) {
            return g.checked === true
          },
          selected: function(g) {
            return g.selected === true
          },
          parent: function(g) {
            return !!g.firstChild
          },
          empty: function(g) {
            return !g.firstChild
          },
          has: function(g, i, n) {
            return !!k(n[3], g).length
          },
          header: function(g) {
            return /h\d/i.test(g.nodeName)
          },
          text: function(g) {
            return "text" === g.type
          },
          radio: function(g) {
            return "radio" === g.type
          },
          checkbox: function(g) {
            return "checkbox" === g.type
          },
          file: function(g) {
            return "file" === g.type
          },
          password: function(g) {
            return "password" === g.type
          },
          submit: function(g) {
            return "submit" ===
              g.type
          },
          image: function(g) {
            return "image" === g.type
          },
          reset: function(g) {
            return "reset" === g.type
          },
          button: function(g) {
            return "button" === g.type || g.nodeName.toLowerCase() === "button"
          },
          input: function(g) {
            return /input|select|textarea|button/i.test(g.nodeName)
          }
        },
        setFilters: {
          first: function(g, i) {
            return i === 0
          },
          last: function(g, i, n, m) {
            return i === m.length - 1
          },
          even: function(g, i) {
            return i % 2 === 0
          },
          odd: function(g, i) {
            return i % 2 === 1
          },
          lt: function(g, i, n) {
            return i < n[3] - 0
          },
          gt: function(g, i, n) {
            return i > n[3] - 0
          },
          nth: function(g, i, n) {
            return n[3] -
              0 === i
          },
          eq: function(g, i, n) {
            return n[3] - 0 === i
          }
        },
        filter: {
          PSEUDO: function(g, i, n, m) {
            var p = i[1],
              q = o.filters[p];
            if (q) return q(g, n, i, m);
            else if (p === "contains") return (g.textContent || g.innerText || k.getText([g]) || "").indexOf(i[3]) >= 0;
            else if (p === "not") {
              i = i[3];
              n = 0;
              for (m = i.length; n < m; n++)
                if (i[n] === g) return false;
              return true
            } else k.error("Syntax error, unrecognized expression: " + p)
          },
          CHILD: function(g, i) {
            var n = i[1],
              m = g;
            switch (n) {
              case "only":
              case "first":
                for (; m = m.previousSibling;)
                  if (m.nodeType === 1) return false;
                if (n ===
                  "first") return true;
                m = g;
              case "last":
                for (; m = m.nextSibling;)
                  if (m.nodeType === 1) return false;
                return true;
              case "nth":
                n = i[2];
                var p = i[3];
                if (n === 1 && p === 0) return true;
                var q = i[0],
                  u = g.parentNode;
                if (u && (u.sizcache !== q || !g.nodeIndex)) {
                  var y = 0;
                  for (m = u.firstChild; m; m = m.nextSibling)
                    if (m.nodeType === 1) m.nodeIndex = ++y;
                  u.sizcache = q
                }
                m = g.nodeIndex - p;
                return n === 0 ? m === 0 : m % n === 0 && m / n >= 0
            }
          },
          ID: function(g, i) {
            return g.nodeType === 1 && g.getAttribute("id") === i
          },
          TAG: function(g, i) {
            return i === "*" && g.nodeType === 1 || g.nodeName.toLowerCase() ===
              i
          },
          CLASS: function(g, i) {
            return (" " + (g.className || g.getAttribute("class")) + " ").indexOf(i) > -1
          },
          ATTR: function(g, i) {
            var n = i[1];
            n = o.attrHandle[n] ? o.attrHandle[n](g) : g[n] != null ? g[n] : g.getAttribute(n);
            var m = n + "",
              p = i[2],
              q = i[4];
            return n == null ? p === "!=" : p === "=" ? m === q : p === "*=" ? m.indexOf(q) >= 0 : p === "~=" ? (" " + m + " ").indexOf(q) >= 0 : !q ? m && n !== false : p === "!=" ? m !== q : p === "^=" ? m.indexOf(q) === 0 : p === "$=" ? m.substr(m.length - q.length) === q : p === "|=" ? m === q || m.substr(0, q.length + 1) === q + "-" : false
          },
          POS: function(g, i, n, m) {
            var p = o.setFilters[i[2]];
            if (p) return p(g, n, i, m)
          }
        }
      },
      x = o.match.POS,
      r = function(g, i) {
        return "\\" + (i - 0 + 1)
      },
      A;
    for (A in o.match) {
      o.match[A] = RegExp(o.match[A].source + /(?![^\[]*\])(?![^\(]*\))/.source);
      o.leftMatch[A] = RegExp(/(^(?:.|\r|\n)*?)/.source + o.match[A].source.replace(/\\(\d+)/g, r))
    }
    var C = function(g, i) {
      g = Array.prototype.slice.call(g, 0);
      if (i) {
        i.push.apply(i, g);
        return i
      }
      return g
    };
    try {
      Array.prototype.slice.call(t.documentElement.childNodes, 0)
    } catch (J) {
      C = function(g, i) {
        var n = 0,
          m = i || [];
        if (f.call(g) === "[object Array]") Array.prototype.push.apply(m,
          g);
        else if (typeof g.length === "number")
          for (var p = g.length; n < p; n++) m.push(g[n]);
        else
          for (; g[n]; n++) m.push(g[n]);
        return m
      }
    }
    var w, I;
    if (t.documentElement.compareDocumentPosition) w = function(g, i) {
      if (g === i) {
        h = true;
        return 0
      }
      if (!g.compareDocumentPosition || !i.compareDocumentPosition) return g.compareDocumentPosition ? -1 : 1;
      return g.compareDocumentPosition(i) & 4 ? -1 : 1
    };
    else {
      w = function(g, i) {
        var n, m, p = [],
          q = [];
        n = g.parentNode;
        m = i.parentNode;
        var u = n;
        if (g === i) {
          h = true;
          return 0
        } else if (n === m) return I(g, i);
        else if (n) {
          if (!m) return 1
        } else return -1;
        for (; u;) {
          p.unshift(u);
          u = u.parentNode
        }
        for (u = m; u;) {
          q.unshift(u);
          u = u.parentNode
        }
        n = p.length;
        m = q.length;
        for (u = 0; u < n && u < m; u++)
          if (p[u] !== q[u]) return I(p[u], q[u]);
        return u === n ? I(g, q[u], -1) : I(p[u], i, 1)
      };
      I = function(g, i, n) {
        if (g === i) return n;
        for (g = g.nextSibling; g;) {
          if (g === i) return -1;
          g = g.nextSibling
        }
        return 1
      }
    }
    k.getText = function(g) {
      for (var i = "", n, m = 0; g[m]; m++) {
        n = g[m];
        if (n.nodeType === 3 || n.nodeType === 4) i += n.nodeValue;
        else if (n.nodeType !== 8) i += k.getText(n.childNodes)
      }
      return i
    };
    (function() {
      var g = t.createElement("div"),
        i = "script" + (new Date).getTime(),
        n = t.documentElement;
      g.innerHTML = "<a name='" + i + "'/>";
      n.insertBefore(g, n.firstChild);
      if (t.getElementById(i)) {
        o.find.ID = function(m, p, q) {
          if (typeof p.getElementById !== "undefined" && !q) return (p = p.getElementById(m[1])) ? p.id === m[1] || typeof p.getAttributeNode !== "undefined" && p.getAttributeNode("id").nodeValue === m[1] ? [p] : B : []
        };
        o.filter.ID = function(m, p) {
          var q = typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id");
          return m.nodeType === 1 && q && q.nodeValue === p
        }
      }
      n.removeChild(g);
      n = g = null
    })();
    (function() {
      var g = t.createElement("div");
      g.appendChild(t.createComment(""));
      if (g.getElementsByTagName("*").length > 0) o.find.TAG = function(i, n) {
        var m = n.getElementsByTagName(i[1]);
        if (i[1] === "*") {
          for (var p = [], q = 0; m[q]; q++) m[q].nodeType === 1 && p.push(m[q]);
          m = p
        }
        return m
      };
      g.innerHTML = "<a href='#'></a>";
      if (g.firstChild && typeof g.firstChild.getAttribute !== "undefined" && g.firstChild.getAttribute("href") !== "#") o.attrHandle.href = function(i) {
        return i.getAttribute("href", 2)
      };
      g = null
    })();
    t.querySelectorAll &&
      function() {
        var g = k,
          i = t.createElement("div");
        i.innerHTML = "<p class='TEST'></p>";
        if (!(i.querySelectorAll && i.querySelectorAll(".TEST").length === 0)) {
          k = function(m, p, q, u) {
            p = p || t;
            m = m.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
            if (!u && !k.isXML(p))
              if (p.nodeType === 9) try {
                return C(p.querySelectorAll(m), q)
              } catch (y) {} else if (p.nodeType === 1 && p.nodeName.toLowerCase() !== "object") {
                var F = p.getAttribute("id"),
                  M = F || "__sizzle__";
                F || p.setAttribute("id", M);
                try {
                  return C(p.querySelectorAll("#" + M + " " + m), q)
                } catch (N) {} finally {
                  F ||
                    p.removeAttribute("id")
                }
              }
            return g(m, p, q, u)
          };
          for (var n in g) k[n] = g[n];
          i = null
        }
      }();
    (function() {
      var g = t.documentElement,
        i = g.matchesSelector || g.mozMatchesSelector || g.webkitMatchesSelector || g.msMatchesSelector,
        n = false;
      try {
        i.call(t.documentElement, "[test!='']:sizzle")
      } catch (m) {
        n = true
      }
      if (i) k.matchesSelector = function(p, q) {
        q = q.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
        if (!k.isXML(p)) try {
          if (n || !o.match.PSEUDO.test(q) && !/!=/.test(q)) return i.call(p, q)
        } catch (u) {}
        return k(q, null, null, [p]).length > 0
      }
    })();
    (function() {
      var g =
        t.createElement("div");
      g.innerHTML = "<div class='test e'></div><div class='test'></div>";
      if (!(!g.getElementsByClassName || g.getElementsByClassName("e").length === 0)) {
        g.lastChild.className = "e";
        if (g.getElementsByClassName("e").length !== 1) {
          o.order.splice(1, 0, "CLASS");
          o.find.CLASS = function(i, n, m) {
            if (typeof n.getElementsByClassName !== "undefined" && !m) return n.getElementsByClassName(i[1])
          };
          g = null
        }
      }
    })();
    k.contains = t.documentElement.contains ? function(g, i) {
        return g !== i && (g.contains ? g.contains(i) : true)
      } : t.documentElement.compareDocumentPosition ?
      function(g, i) {
        return !!(g.compareDocumentPosition(i) & 16)
      } : function() {
        return false
      };
    k.isXML = function(g) {
      return (g = (g ? g.ownerDocument || g : 0).documentElement) ? g.nodeName !== "HTML" : false
    };
    var L = function(g, i) {
      for (var n, m = [], p = "", q = i.nodeType ? [i] : i; n = o.match.PSEUDO.exec(g);) {
        p += n[0];
        g = g.replace(o.match.PSEUDO, "")
      }
      g = o.relative[g] ? g + "*" : g;
      n = 0;
      for (var u = q.length; n < u; n++) k(g, q[n], m);
      return k.filter(p, m)
    };
    c.find = k;
    c.expr = k.selectors;
    c.expr[":"] = c.expr.filters;
    c.unique = k.uniqueSort;
    c.text = k.getText;
    c.isXMLDoc = k.isXML;
    c.contains = k.contains
  })();
  var Za = /Until$/,
    $a = /^(?:parents|prevUntil|prevAll)/,
    ab = /,/,
    Na = /^.[^:#\[\.,]*$/,
    bb = Array.prototype.slice,
    cb = c.expr.match.POS;
  c.fn.extend({
    find: function(a) {
      for (var b = this.pushStack("", "find", a), d = 0, e = 0, f = this.length; e < f; e++) {
        d = b.length;
        c.find(a, this[e], b);
        if (e > 0)
          for (var h = d; h < b.length; h++)
            for (var l = 0; l < d; l++)
              if (b[l] === b[h]) {
                b.splice(h--, 1);
                break
              }
      }
      return b
    },
    has: function(a) {
      var b = c(a);
      return this.filter(function() {
        for (var d = 0, e = b.length; d < e; d++)
          if (c.contains(this, b[d])) return true
      })
    },
    not: function(a) {
      return this.pushStack(ma(this, a, false), "not", a)
    },
    filter: function(a) {
      return this.pushStack(ma(this, a, true), "filter", a)
    },
    is: function(a) {
      return !!a && c.filter(a, this).length > 0
    },
    closest: function(a, b) {
      var d = [],
        e, f, h = this[0];
      if (c.isArray(a)) {
        var l, k = {},
          o = 1;
        if (h && a.length) {
          e = 0;
          for (f = a.length; e < f; e++) {
            l = a[e];
            k[l] || (k[l] = c.expr.match.POS.test(l) ? c(l, b || this.context) : l)
          }
          for (; h && h.ownerDocument && h !== b;) {
            for (l in k) {
              e = k[l];
              if (e.jquery ? e.index(h) > -1 : c(h).is(e)) d.push({
                selector: l,
                elem: h,
                level: o
              })
            }
            h =
              h.parentNode;
            o++
          }
        }
        return d
      }
      l = cb.test(a) ? c(a, b || this.context) : null;
      e = 0;
      for (f = this.length; e < f; e++)
        for (h = this[e]; h;)
          if (l ? l.index(h) > -1 : c.find.matchesSelector(h, a)) {
            d.push(h);
            break
          } else {
            h = h.parentNode;
            if (!h || !h.ownerDocument || h === b) break
          }
      d = d.length > 1 ? c.unique(d) : d;
      return this.pushStack(d, "closest", a)
    },
    index: function(a) {
      if (!a || typeof a === "string") return c.inArray(this[0], a ? c(a) : this.parent().children());
      return c.inArray(a.jquery ? a[0] : a, this)
    },
    add: function(a, b) {
      var d = typeof a === "string" ? c(a, b || this.context) :
        c.makeArray(a),
        e = c.merge(this.get(), d);
      return this.pushStack(!d[0] || !d[0].parentNode || d[0].parentNode.nodeType === 11 || !e[0] || !e[0].parentNode || e[0].parentNode.nodeType === 11 ? e : c.unique(e))
    },
    andSelf: function() {
      return this.add(this.prevObject)
    }
  });
  c.each({
    parent: function(a) {
      return (a = a.parentNode) && a.nodeType !== 11 ? a : null
    },
    parents: function(a) {
      return c.dir(a, "parentNode")
    },
    parentsUntil: function(a, b, d) {
      return c.dir(a, "parentNode", d)
    },
    next: function(a) {
      return c.nth(a, 2, "nextSibling")
    },
    prev: function(a) {
      return c.nth(a,
        2, "previousSibling")
    },
    nextAll: function(a) {
      return c.dir(a, "nextSibling")
    },
    prevAll: function(a) {
      return c.dir(a, "previousSibling")
    },
    nextUntil: function(a, b, d) {
      return c.dir(a, "nextSibling", d)
    },
    prevUntil: function(a, b, d) {
      return c.dir(a, "previousSibling", d)
    },
    siblings: function(a) {
      return c.sibling(a.parentNode.firstChild, a)
    },
    children: function(a) {
      return c.sibling(a.firstChild)
    },
    contents: function(a) {
      return c.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : c.makeArray(a.childNodes)
    }
  }, function(a,
    b) {
    c.fn[a] = function(d, e) {
      var f = c.map(this, b, d);
      Za.test(a) || (e = d);
      if (e && typeof e === "string") f = c.filter(e, f);
      f = this.length > 1 ? c.unique(f) : f;
      if ((this.length > 1 || ab.test(e)) && $a.test(a)) f = f.reverse();
      return this.pushStack(f, a, bb.call(arguments).join(","))
    }
  });
  c.extend({
    filter: function(a, b, d) {
      if (d) a = ":not(" + a + ")";
      return b.length === 1 ? c.find.matchesSelector(b[0], a) ? [b[0]] : [] : c.find.matches(a, b)
    },
    dir: function(a, b, d) {
      var e = [];
      for (a = a[b]; a && a.nodeType !== 9 && (d === B || a.nodeType !== 1 || !c(a).is(d));) {
        a.nodeType === 1 &&
          e.push(a);
        a = a[b]
      }
      return e
    },
    nth: function(a, b, d) {
      b = b || 1;
      for (var e = 0; a; a = a[d])
        if (a.nodeType === 1 && ++e === b) break;
      return a
    },
    sibling: function(a, b) {
      for (var d = []; a; a = a.nextSibling) a.nodeType === 1 && a !== b && d.push(a);
      return d
    }
  });
  var za = / jQuery\d+="(?:\d+|null)"/g,
    $ = /^\s+/,
    Aa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    Ba = /<([\w:]+)/,
    db = /<tbody/i,
    eb = /<|&#?\w+;/,
    Ca = /<(?:script|object|embed|option|style)/i,
    Da = /checked\s*(?:[^=]|=\s*.checked.)/i,
    fb = /\=([^="'>\s]+\/)>/g,
    P = {
      option: [1,
        "<select multiple='multiple'>", "</select>"
      ],
      legend: [1, "<fieldset>", "</fieldset>"],
      thead: [1, "<table>", "</table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      area: [1, "<map>", "</map>"],
      _default: [0, "", ""]
    };
  P.optgroup = P.option;
  P.tbody = P.tfoot = P.colgroup = P.caption = P.thead;
  P.th = P.td;
  if (!c.support.htmlSerialize) P._default = [1, "div<div>", "</div>"];
  c.fn.extend({
    text: function(a) {
      if (c.isFunction(a)) return this.each(function(b) {
        var d =
          c(this);
        d.text(a.call(this, b, d.text()))
      });
      if (typeof a !== "object" && a !== B) return this.empty().append((this[0] && this[0].ownerDocument || t).createTextNode(a));
      return c.text(this)
    },
    wrapAll: function(a) {
      if (c.isFunction(a)) return this.each(function(d) {
        c(this).wrapAll(a.call(this, d))
      });
      if (this[0]) {
        var b = c(a, this[0].ownerDocument).eq(0).clone(true);
        this[0].parentNode && b.insertBefore(this[0]);
        b.map(function() {
          for (var d = this; d.firstChild && d.firstChild.nodeType === 1;) d = d.firstChild;
          return d
        }).append(this)
      }
      return this
    },
    wrapInner: function(a) {
      if (c.isFunction(a)) return this.each(function(b) {
        c(this).wrapInner(a.call(this, b))
      });
      return this.each(function() {
        var b = c(this),
          d = b.contents();
        d.length ? d.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      return this.each(function() {
        c(this).wrapAll(a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        c.nodeName(this, "body") || c(this).replaceWith(this.childNodes)
      }).end()
    },
    append: function() {
      return this.domManip(arguments, true, function(a) {
        this.nodeType === 1 && this.appendChild(a)
      })
    },
    prepend: function() {
      return this.domManip(arguments, true, function(a) {
        this.nodeType === 1 && this.insertBefore(a, this.firstChild)
      })
    },
    before: function() {
      if (this[0] && this[0].parentNode) return this.domManip(arguments, false, function(b) {
        this.parentNode.insertBefore(b, this)
      });
      else if (arguments.length) {
        var a = c(arguments[0]);
        a.push.apply(a, this.toArray());
        return this.pushStack(a, "before", arguments)
      }
    },
    after: function() {
      if (this[0] && this[0].parentNode) return this.domManip(arguments, false, function(b) {
        this.parentNode.insertBefore(b,
          this.nextSibling)
      });
      else if (arguments.length) {
        var a = this.pushStack(this, "after", arguments);
        a.push.apply(a, c(arguments[0]).toArray());
        return a
      }
    },
    remove: function(a, b) {
      for (var d = 0, e;
        (e = this[d]) != null; d++)
        if (!a || c.filter(a, [e]).length) {
          if (!b && e.nodeType === 1) {
            c.cleanData(e.getElementsByTagName("*"));
            c.cleanData([e])
          }
          e.parentNode && e.parentNode.removeChild(e)
        }
      return this
    },
    empty: function() {
      for (var a = 0, b;
        (b = this[a]) != null; a++)
        for (b.nodeType === 1 && c.cleanData(b.getElementsByTagName("*")); b.firstChild;) b.removeChild(b.firstChild);
      return this
    },
    clone: function(a) {
      var b = this.map(function() {
        if (!c.support.noCloneEvent && !c.isXMLDoc(this)) {
          var d = this.outerHTML,
            e = this.ownerDocument;
          if (!d) {
            d = e.createElement("div");
            d.appendChild(this.cloneNode(true));
            d = d.innerHTML
          }
          return c.clean([d.replace(za, "").replace(fb, '="$1">').replace($, "")], e)[0]
        } else return this.cloneNode(true)
      });
      if (a === true) {
        na(this, b);
        na(this.find("*"), b.find("*"))
      }
      return b
    },
    html: function(a) {
      if (a === B) return this[0] && this[0].nodeType === 1 ? this[0].innerHTML.replace(za, "") : null;
      else if (typeof a === "string" && !Ca.test(a) && (c.support.leadingWhitespace || !$.test(a)) && !P[(Ba.exec(a) || ["", ""])[1].toLowerCase()]) {
        a = a.replace(Aa, "<$1></$2>");
        try {
          for (var b = 0, d = this.length; b < d; b++)
            if (this[b].nodeType === 1) {
              c.cleanData(this[b].getElementsByTagName("*"));
              this[b].innerHTML = a
            }
        } catch (e) {
          this.empty().append(a)
        }
      } else c.isFunction(a) ? this.each(function(f) {
        var h = c(this);
        h.html(a.call(this, f, h.html()))
      }) : this.empty().append(a);
      return this
    },
    replaceWith: function(a) {
      if (this[0] && this[0].parentNode) {
        if (c.isFunction(a)) return this.each(function(b) {
          var d =
            c(this),
            e = d.html();
          d.replaceWith(a.call(this, b, e))
        });
        if (typeof a !== "string") a = c(a).detach();
        return this.each(function() {
          var b = this.nextSibling,
            d = this.parentNode;
          c(this).remove();
          b ? c(b).before(a) : c(d).append(a)
        })
      } else return this.pushStack(c(c.isFunction(a) ? a() : a), "replaceWith", a)
    },
    detach: function(a) {
      return this.remove(a, true)
    },
    domManip: function(a, b, d) {
      var e, f, h, l = a[0],
        k = [];
      if (!c.support.checkClone && arguments.length === 3 && typeof l === "string" && Da.test(l)) return this.each(function() {
        c(this).domManip(a,
          b, d, true)
      });
      if (c.isFunction(l)) return this.each(function(x) {
        var r = c(this);
        a[0] = l.call(this, x, b ? r.html() : B);
        r.domManip(a, b, d)
      });
      if (this[0]) {
        e = l && l.parentNode;
        e = c.support.parentNode && e && e.nodeType === 11 && e.childNodes.length === this.length ? {
          fragment: e
        } : c.buildFragment(a, this, k);
        h = e.fragment;
        if (f = h.childNodes.length === 1 ? h = h.firstChild : h.firstChild) {
          b = b && c.nodeName(f, "tr");
          f = 0;
          for (var o = this.length; f < o; f++) d.call(b ? c.nodeName(this[f], "table") ? this[f].getElementsByTagName("tbody")[0] || this[f].appendChild(this[f].ownerDocument.createElement("tbody")) :
            this[f] : this[f], f > 0 || e.cacheable || this.length > 1 ? h.cloneNode(true) : h)
        }
        k.length && c.each(k, Oa)
      }
      return this
    }
  });
  c.buildFragment = function(a, b, d) {
    var e, f, h;
    b = b && b[0] ? b[0].ownerDocument || b[0] : t;
    if (a.length === 1 && typeof a[0] === "string" && a[0].length < 512 && b === t && !Ca.test(a[0]) && (c.support.checkClone || !Da.test(a[0]))) {
      f = true;
      if (h = c.fragments[a[0]])
        if (h !== 1) e = h
    }
    if (!e) {
      e = b.createDocumentFragment();
      c.clean(a, b, e, d)
    }
    if (f) c.fragments[a[0]] = h ? e : 1;
    return {
      fragment: e,
      cacheable: f
    }
  };
  c.fragments = {};
  c.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    c.fn[a] = function(d) {
      var e = [];
      d = c(d);
      var f = this.length === 1 && this[0].parentNode;
      if (f && f.nodeType === 11 && f.childNodes.length === 1 && d.length === 1) {
        d[b](this[0]);
        return this
      } else {
        f = 0;
        for (var h = d.length; f < h; f++) {
          var l = (f > 0 ? this.clone(true) : this).get();
          c(d[f])[b](l);
          e = e.concat(l)
        }
        return this.pushStack(e, a, d.selector)
      }
    }
  });
  c.extend({
    clean: function(a, b, d, e) {
      b = b || t;
      if (typeof b.createElement === "undefined") b = b.ownerDocument ||
        b[0] && b[0].ownerDocument || t;
      for (var f = [], h = 0, l;
        (l = a[h]) != null; h++) {
        if (typeof l === "number") l += "";
        if (l) {
          if (typeof l === "string" && !eb.test(l)) l = b.createTextNode(l);
          else if (typeof l === "string") {
            l = l.replace(Aa, "<$1></$2>");
            var k = (Ba.exec(l) || ["", ""])[1].toLowerCase(),
              o = P[k] || P._default,
              x = o[0],
              r = b.createElement("div");
            for (r.innerHTML = o[1] + l + o[2]; x--;) r = r.lastChild;
            if (!c.support.tbody) {
              x = db.test(l);
              k = k === "table" && !x ? r.firstChild && r.firstChild.childNodes : o[1] === "<table>" && !x ? r.childNodes : [];
              for (o = k.length -
                1; o >= 0; --o) c.nodeName(k[o], "tbody") && !k[o].childNodes.length && k[o].parentNode.removeChild(k[o])
            }!c.support.leadingWhitespace && $.test(l) && r.insertBefore(b.createTextNode($.exec(l)[0]), r.firstChild);
            l = r.childNodes
          }
          if (l.nodeType) f.push(l);
          else f = c.merge(f, l)
        }
      }
      if (d)
        for (h = 0; f[h]; h++)
          if (e && c.nodeName(f[h], "script") && (!f[h].type || f[h].type.toLowerCase() === "text/javascript")) e.push(f[h].parentNode ? f[h].parentNode.removeChild(f[h]) : f[h]);
          else {
            f[h].nodeType === 1 && f.splice.apply(f, [h + 1, 0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
            d.appendChild(f[h])
          }
      return f
    },
    cleanData: function(a) {
      for (var b, d, e = c.cache, f = c.event.special, h = c.support.deleteExpando, l = 0, k;
        (k = a[l]) != null; l++)
        if (!(k.nodeName && c.noData[k.nodeName.toLowerCase()]))
          if (d = k[c.expando]) {
            if ((b = e[d]) && b.events)
              for (var o in b.events) f[o] ? c.event.remove(k, o) : c.removeEvent(k, o, b.handle);
            if (h) delete k[c.expando];
            else k.removeAttribute && k.removeAttribute(c.expando);
            delete e[d]
          }
    }
  });
  var Ea = /alpha\([^)]*\)/i,
    gb = /opacity=([^)]*)/,
    hb = /-([a-z])/ig,
    ib = /([A-Z])/g,
    Fa = /^-?\d+(?:px)?$/i,
    jb = /^-?\d/,
    kb = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Pa = ["Left", "Right"],
    Qa = ["Top", "Bottom"],
    W, Ga, aa, lb = function(a, b) {
      return b.toUpperCase()
    };
  c.fn.css = function(a, b) {
    if (arguments.length === 2 && b === B) return this;
    return c.access(this, a, b, true, function(d, e, f) {
      return f !== B ? c.style(d, e, f) : c.css(d, e)
    })
  };
  c.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var d = W(a, "opacity", "opacity");
            return d === "" ? "1" : d
          } else return a.style.opacity
        }
      }
    },
    cssNumber: {
      zIndex: true,
      fontWeight: true,
      opacity: true,
      zoom: true,
      lineHeight: true
    },
    cssProps: {
      "float": c.support.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function(a, b, d, e) {
      if (!(!a || a.nodeType === 3 || a.nodeType === 8 || !a.style)) {
        var f, h = c.camelCase(b),
          l = a.style,
          k = c.cssHooks[h];
        b = c.cssProps[h] || h;
        if (d !== B) {
          if (!(typeof d === "number" && isNaN(d) || d == null)) {
            if (typeof d === "number" && !c.cssNumber[h]) d += "px";
            if (!k || !("set" in k) || (d = k.set(a, d)) !== B) try {
              l[b] = d
            } catch (o) {}
          }
        } else {
          if (k && "get" in k && (f = k.get(a, false, e)) !== B) return f;
          return l[b]
        }
      }
    },
    css: function(a, b, d) {
      var e, f = c.camelCase(b),
        h = c.cssHooks[f];
      b = c.cssProps[f] || f;
      if (h && "get" in h && (e = h.get(a, true, d)) !== B) return e;
      else if (W) return W(a, b, f)
    },
    swap: function(a, b, d) {
      var e = {},
        f;
      for (f in b) {
        e[f] = a.style[f];
        a.style[f] = b[f]
      }
      d.call(a);
      for (f in b) a.style[f] = e[f]
    },
    camelCase: function(a) {
      return a.replace(hb, lb)
    }
  });
  c.curCSS = c.css;
  c.each(["height", "width"], function(a, b) {
    c.cssHooks[b] = {
      get: function(d, e, f) {
        var h;
        if (e) {
          if (d.offsetWidth !== 0) h = oa(d, b, f);
          else c.swap(d, kb, function() {
            h = oa(d, b, f)
          });
          if (h <= 0) {
            h = W(d, b, b);
            if (h === "0px" && aa) h = aa(d, b, b);
            if (h != null) return h === "" || h === "auto" ? "0px" : h
          }
          if (h < 0 || h == null) {
            h = d.style[b];
            return h === "" || h === "auto" ? "0px" : h
          }
          return typeof h === "string" ? h : h + "px"
        }
      },
      set: function(d, e) {
        if (Fa.test(e)) {
          e = parseFloat(e);
          if (e >= 0) return e + "px"
        } else return e
      }
    }
  });
  if (!c.support.opacity) c.cssHooks.opacity = {
    get: function(a, b) {
      return gb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 + "" : b ? "1" : ""
    },
    set: function(a, b) {
      var d = a.style;
      d.zoom = 1;
      var e = c.isNaN(b) ? "" : "alpha(opacity=" + b * 100 + ")",
        f =
        d.filter || "";
      d.filter = Ea.test(f) ? f.replace(Ea, e) : d.filter + " " + e
    }
  };
  if (t.defaultView && t.defaultView.getComputedStyle) Ga = function(a, b, d) {
    var e;
    d = d.replace(ib, "-$1").toLowerCase();
    if (!(b = a.ownerDocument.defaultView)) return B;
    if (b = b.getComputedStyle(a, null)) {
      e = b.getPropertyValue(d);
      if (e === "" && !c.contains(a.ownerDocument.documentElement, a)) e = c.style(a, d)
    }
    return e
  };
  if (t.documentElement.currentStyle) aa = function(a, b) {
    var d, e, f = a.currentStyle && a.currentStyle[b],
      h = a.style;
    if (!Fa.test(f) && jb.test(f)) {
      d = h.left;
      e = a.runtimeStyle.left;
      a.runtimeStyle.left = a.currentStyle.left;
      h.left = b === "fontSize" ? "1em" : f || 0;
      f = h.pixelLeft + "px";
      h.left = d;
      a.runtimeStyle.left = e
    }
    return f === "" ? "auto" : f
  };
  W = Ga || aa;
  if (c.expr && c.expr.filters) {
    c.expr.filters.hidden = function(a) {
      var b = a.offsetHeight;
      return a.offsetWidth === 0 && b === 0 || !c.support.reliableHiddenOffsets && (a.style.display || c.css(a, "display")) === "none"
    };
    c.expr.filters.visible = function(a) {
      return !c.expr.filters.hidden(a)
    }
  }
  var mb = c.now(),
    nb = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    ob = /^(?:select|textarea)/i,
    pb = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    qb = /^(?:GET|HEAD)$/,
    Ra = /\[\]$/,
    T = /\=\?(&|$)/,
    ja = /\?/,
    rb = /([?&])_=[^&]*/,
    sb = /^(\w+:)?\/\/([^\/?#]+)/,
    tb = /%20/g,
    ub = /#.*$/,
    Ha = c.fn.load;
  c.fn.extend({
    load: function(a, b, d) {
      if (typeof a !== "string" && Ha) return Ha.apply(this, arguments);
      else if (!this.length) return this;
      var e = a.indexOf(" ");
      if (e >= 0) {
        var f = a.slice(e, a.length);
        a = a.slice(0, e)
      }
      e = "GET";
      if (b)
        if (c.isFunction(b)) {
          d = b;
          b = null
        } else if (typeof b ===
        "object") {
        b = c.param(b, c.ajaxSettings.traditional);
        e = "POST"
      }
      var h = this;
      c.ajax({
        url: a,
        type: e,
        dataType: "html",
        data: b,
        complete: function(l, k) {
          if (k === "success" || k === "notmodified") h.html(f ? c("<div>").append(l.responseText.replace(nb, "")).find(f) : l.responseText);
          d && h.each(d, [l.responseText, k, l])
        }
      });
      return this
    },
    serialize: function() {
      return c.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        return this.elements ? c.makeArray(this.elements) : this
      }).filter(function() {
        return this.name &&
          !this.disabled && (this.checked || ob.test(this.nodeName) || pb.test(this.type))
      }).map(function(a, b) {
        var d = c(this).val();
        return d == null ? null : c.isArray(d) ? c.map(d, function(e) {
          return {
            name: b.name,
            value: e
          }
        }) : {
          name: b.name,
          value: d
        }
      }).get()
    }
  });
  c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(a, b) {
    c.fn[b] = function(d) {
      return this.bind(b, d)
    }
  });
  c.extend({
    get: function(a, b, d, e) {
      if (c.isFunction(b)) {
        e = e || d;
        d = b;
        b = null
      }
      return c.ajax({
        type: "GET",
        url: a,
        data: b,
        success: d,
        dataType: e
      })
    },
    getScript: function(a, b) {
      return c.get(a, null, b, "script")
    },
    getJSON: function(a, b, d) {
      return c.get(a, b, d, "json")
    },
    post: function(a, b, d, e) {
      if (c.isFunction(b)) {
        e = e || d;
        d = b;
        b = {}
      }
      return c.ajax({
        type: "POST",
        url: a,
        data: b,
        success: d,
        dataType: e
      })
    },
    ajaxSetup: function(a) {
      c.extend(c.ajaxSettings, a)
    },
    ajaxSettings: {
      url: location.href,
      global: true,
      type: "GET",
      contentType: "application/x-www-form-urlencoded",
      processData: true,
      async: true,
      xhr: function() {
        return new E.XMLHttpRequest
      },
      accepts: {
        xml: "application/xml, text/xml",
        html: "text/html",
        script: "text/javascript, application/javascript",
        json: "application/json, text/javascript",
        text: "text/plain",
        _default: "*/*"
      }
    },
    ajax: function(a) {
      var b = c.extend(true, {}, c.ajaxSettings, a),
        d, e, f, h = b.type.toUpperCase(),
        l = qb.test(h);
      b.url = b.url.replace(ub, "");
      b.context = a && a.context != null ? a.context : b;
      if (b.data && b.processData && typeof b.data !== "string") b.data = c.param(b.data, b.traditional);
      if (b.dataType === "jsonp") {
        if (h === "GET") T.test(b.url) || (b.url += (ja.test(b.url) ? "&" : "?") + (b.jsonp || "callback") + "=?");
        else if (!b.data ||
          !T.test(b.data)) b.data = (b.data ? b.data + "&" : "") + (b.jsonp || "callback") + "=?";
        b.dataType = "json"
      }
      if (b.dataType === "json" && (b.data && T.test(b.data) || T.test(b.url))) {
        d = b.jsonpCallback || "jsonp" + mb++;
        if (b.data) b.data = (b.data + "").replace(T, "=" + d + "$1");
        b.url = b.url.replace(T, "=" + d + "$1");
        b.dataType = "script";
        var k = E[d];
        E[d] = function(m) {
          if (c.isFunction(k)) k(m);
          else {
            E[d] = B;
            try {
              delete E[d]
            } catch (p) {}
          }
          f = m;
          c.handleSuccess(b, w, e, f);
          c.handleComplete(b, w, e, f);
          r && r.removeChild(A)
        }
      }
      if (b.dataType === "script" && b.cache === null) b.cache =
        false;
      if (b.cache === false && l) {
        var o = c.now(),
          x = b.url.replace(rb, "$1_=" + o);
        b.url = x + (x === b.url ? (ja.test(b.url) ? "&" : "?") + "_=" + o : "")
      }
      if (b.data && l) b.url += (ja.test(b.url) ? "&" : "?") + b.data;
      b.global && c.active++ === 0 && c.event.trigger("ajaxStart");
      o = (o = sb.exec(b.url)) && (o[1] && o[1].toLowerCase() !== location.protocol || o[2].toLowerCase() !== location.host);
      if (b.dataType === "script" && h === "GET" && o) {
        var r = t.getElementsByTagName("head")[0] || t.documentElement,
          A = t.createElement("script");
        if (b.scriptCharset) A.charset = b.scriptCharset;
        A.src = b.url;
        if (!d) {
          var C = false;
          A.onload = A.onreadystatechange = function() {
            if (!C && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
              C = true;
              c.handleSuccess(b, w, e, f);
              c.handleComplete(b, w, e, f);
              A.onload = A.onreadystatechange = null;
              r && A.parentNode && r.removeChild(A)
            }
          }
        }
        r.insertBefore(A, r.firstChild);
        return B
      }
      var J = false,
        w = b.xhr();
      if (w) {
        b.username ? w.open(h, b.url, b.async, b.username, b.password) : w.open(h, b.url, b.async);
        try {
          if (b.data != null && !l || a && a.contentType) w.setRequestHeader("Content-Type",
            b.contentType);
          if (b.ifModified) {
            c.lastModified[b.url] && w.setRequestHeader("If-Modified-Since", c.lastModified[b.url]);
            c.etag[b.url] && w.setRequestHeader("If-None-Match", c.etag[b.url])
          }
          o || w.setRequestHeader("X-Requested-With", "XMLHttpRequest");
          w.setRequestHeader("Accept", b.dataType && b.accepts[b.dataType] ? b.accepts[b.dataType] + ", */*; q=0.01" : b.accepts._default)
        } catch (I) {}
        if (b.beforeSend && b.beforeSend.call(b.context, w, b) === false) {
          b.global && c.active-- === 1 && c.event.trigger("ajaxStop");
          w.abort();
          return false
        }
        b.global &&
          c.triggerGlobal(b, "ajaxSend", [w, b]);
        var L = w.onreadystatechange = function(m) {
          if (!w || w.readyState === 0 || m === "abort") {
            J || c.handleComplete(b, w, e, f);
            J = true;
            if (w) w.onreadystatechange = c.noop
          } else if (!J && w && (w.readyState === 4 || m === "timeout")) {
            J = true;
            w.onreadystatechange = c.noop;
            e = m === "timeout" ? "timeout" : !c.httpSuccess(w) ? "error" : b.ifModified && c.httpNotModified(w, b.url) ? "notmodified" : "success";
            var p;
            if (e === "success") try {
              f = c.httpData(w, b.dataType, b)
            } catch (q) {
              e = "parsererror";
              p = q
            }
            if (e === "success" || e === "notmodified") d ||
              c.handleSuccess(b, w, e, f);
            else c.handleError(b, w, e, p);
            d || c.handleComplete(b, w, e, f);
            m === "timeout" && w.abort();
            if (b.async) w = null
          }
        };
        try {
          var g = w.abort;
          w.abort = function() {
            w && Function.prototype.call.call(g, w);
            L("abort")
          }
        } catch (i) {}
        b.async && b.timeout > 0 && setTimeout(function() {
          w && !J && L("timeout")
        }, b.timeout);
        try {
          w.send(l || b.data == null ? null : b.data)
        } catch (n) {
          c.handleError(b, w, null, n);
          c.handleComplete(b, w, e, f)
        }
        b.async || L();
        return w
      }
    },
    param: function(a, b) {
      var d = [],
        e = function(h, l) {
          l = c.isFunction(l) ? l() : l;
          d[d.length] =
            encodeURIComponent(h) + "=" + encodeURIComponent(l)
        };
      if (b === B) b = c.ajaxSettings.traditional;
      if (c.isArray(a) || a.jquery) c.each(a, function() {
        e(this.name, this.value)
      });
      else
        for (var f in a) da(f, a[f], b, e);
      return d.join("&").replace(tb, "+")
    }
  });
  c.extend({
    active: 0,
    lastModified: {},
    etag: {},
    handleError: function(a, b, d, e) {
      a.error && a.error.call(a.context, b, d, e);
      a.global && c.triggerGlobal(a, "ajaxError", [b, a, e])
    },
    handleSuccess: function(a, b, d, e) {
      a.success && a.success.call(a.context, e, d, b);
      a.global && c.triggerGlobal(a, "ajaxSuccess", [b, a])
    },
    handleComplete: function(a, b, d) {
      a.complete && a.complete.call(a.context, b, d);
      a.global && c.triggerGlobal(a, "ajaxComplete", [b, a]);
      a.global && c.active-- === 1 && c.event.trigger("ajaxStop")
    },
    triggerGlobal: function(a, b, d) {
      (a.context && a.context.url == null ? c(a.context) : c.event).trigger(b, d)
    },
    httpSuccess: function(a) {
      try {
        return !a.status && location.protocol === "file:" || a.status >= 200 && a.status < 300 || a.status === 304 || a.status === 1223
      } catch (b) {}
      return false
    },
    httpNotModified: function(a, b) {
      var d = a.getResponseHeader("Last-Modified"),
        e = a.getResponseHeader("Etag");
      if (d) c.lastModified[b] = d;
      if (e) c.etag[b] = e;
      return a.status === 304
    },
    httpData: function(a, b, d) {
      var e = a.getResponseHeader("content-type") || "",
        f = b === "xml" || !b && e.indexOf("xml") >= 0;
      a = f ? a.responseXML : a.responseText;
      f && a.documentElement.nodeName === "parsererror" && c.error("parsererror");
      if (d && d.dataFilter) a = d.dataFilter(a, b);
      if (typeof a === "string")
        if (b === "json" || !b && e.indexOf("json") >= 0) a = c.parseJSON(a);
        else if (b === "script" || !b && e.indexOf("javascript") >= 0) c.globalEval(a);
      return a
    }
  });
  if (E.ActiveXObject) c.ajaxSettings.xhr = function() {
    if (E.location.protocol !== "file:") try {
      return new E.XMLHttpRequest
    } catch (a) {}
    try {
      return new E.ActiveXObject("Microsoft.XMLHTTP")
    } catch (b) {}
  };
  c.support.ajax = !!c.ajaxSettings.xhr();
  var ea = {},
    vb = /^(?:toggle|show|hide)$/,
    wb = /^([+\-]=)?([\d+.\-]+)(.*)$/,
    ba, pa = [
      ["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
      ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
      ["opacity"]
    ];
  c.fn.extend({
    show: function(a, b, d) {
      if (a || a === 0) return this.animate(S("show",
        3), a, b, d);
      else {
        d = 0;
        for (var e = this.length; d < e; d++) {
          a = this[d];
          b = a.style.display;
          if (!c.data(a, "olddisplay") && b === "none") b = a.style.display = "";
          b === "" && c.css(a, "display") === "none" && c.data(a, "olddisplay", qa(a.nodeName))
        }
        for (d = 0; d < e; d++) {
          a = this[d];
          b = a.style.display;
          if (b === "" || b === "none") a.style.display = c.data(a, "olddisplay") || ""
        }
        return this
      }
    },
    hide: function(a, b, d) {
      if (a || a === 0) return this.animate(S("hide", 3), a, b, d);
      else {
        a = 0;
        for (b = this.length; a < b; a++) {
          d = c.css(this[a], "display");
          d !== "none" && c.data(this[a], "olddisplay",
            d)
        }
        for (a = 0; a < b; a++) this[a].style.display = "none";
        return this
      }
    },
    _toggle: c.fn.toggle,
    toggle: function(a, b, d) {
      var e = typeof a === "boolean";
      if (c.isFunction(a) && c.isFunction(b)) this._toggle.apply(this, arguments);
      else a == null || e ? this.each(function() {
        var f = e ? a : c(this).is(":hidden");
        c(this)[f ? "show" : "hide"]()
      }) : this.animate(S("toggle", 3), a, b, d);
      return this
    },
    fadeTo: function(a, b, d, e) {
      return this.filter(":hidden").css("opacity", 0).show().end().animate({
        opacity: b
      }, a, d, e)
    },
    animate: function(a, b, d, e) {
      var f = c.speed(b,
        d, e);
      if (c.isEmptyObject(a)) return this.each(f.complete);
      return this[f.queue === false ? "each" : "queue"](function() {
        var h = c.extend({}, f),
          l, k = this.nodeType === 1,
          o = k && c(this).is(":hidden"),
          x = this;
        for (l in a) {
          var r = c.camelCase(l);
          if (l !== r) {
            a[r] = a[l];
            delete a[l];
            l = r
          }
          if (a[l] === "hide" && o || a[l] === "show" && !o) return h.complete.call(this);
          if (k && (l === "height" || l === "width")) {
            h.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];
            if (c.css(this, "display") === "inline" && c.css(this, "float") === "none")
              if (c.support.inlineBlockNeedsLayout)
                if (qa(this.nodeName) ===
                  "inline") this.style.display = "inline-block";
                else {
                  this.style.display = "inline";
                  this.style.zoom = 1
                }
            else this.style.display = "inline-block"
          }
          if (c.isArray(a[l])) {
            (h.specialEasing = h.specialEasing || {})[l] = a[l][1];
            a[l] = a[l][0]
          }
        }
        if (h.overflow != null) this.style.overflow = "hidden";
        h.curAnim = c.extend({}, a);
        c.each(a, function(A, C) {
          var J = new c.fx(x, h, A);
          if (vb.test(C)) J[C === "toggle" ? o ? "show" : "hide" : C](a);
          else {
            var w = wb.exec(C),
              I = J.cur() || 0;
            if (w) {
              var L = parseFloat(w[2]),
                g = w[3] || "px";
              if (g !== "px") {
                c.style(x, A, (L || 1) + g);
                I = (L ||
                  1) / J.cur() * I;
                c.style(x, A, I + g)
              }
              if (w[1]) L = (w[1] === "-=" ? -1 : 1) * L + I;
              J.custom(I, L, g)
            } else J.custom(I, C, "")
          }
        });
        return true
      })
    },
    stop: function(a, b) {
      var d = c.timers;
      a && this.queue([]);
      this.each(function() {
        for (var e = d.length - 1; e >= 0; e--)
          if (d[e].elem === this) {
            b && d[e](true);
            d.splice(e, 1)
          }
      });
      b || this.dequeue();
      return this
    }
  });
  c.each({
    slideDown: S("show", 1),
    slideUp: S("hide", 1),
    slideToggle: S("toggle", 1),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function(a, b) {
    c.fn[a] = function(d, e, f) {
      return this.animate(b,
        d, e, f)
    }
  });
  c.extend({
    speed: function(a, b, d) {
      var e = a && typeof a === "object" ? c.extend({}, a) : {
        complete: d || !d && b || c.isFunction(a) && a,
        duration: a,
        easing: d && b || b && !c.isFunction(b) && b
      };
      e.duration = c.fx.off ? 0 : typeof e.duration === "number" ? e.duration : e.duration in c.fx.speeds ? c.fx.speeds[e.duration] : c.fx.speeds._default;
      e.old = e.complete;
      e.complete = function() {
        e.queue !== false && c(this).dequeue();
        c.isFunction(e.old) && e.old.call(this)
      };
      return e
    },
    easing: {
      linear: function(a, b, d, e) {
        return d + e * a
      },
      swing: function(a, b, d, e) {
        return (-Math.cos(a *
          Math.PI) / 2 + 0.5) * e + d
      }
    },
    timers: [],
    fx: function(a, b, d) {
      this.options = b;
      this.elem = a;
      this.prop = d;
      if (!b.orig) b.orig = {}
    }
  });
  c.fx.prototype = {
    update: function() {
      this.options.step && this.options.step.call(this.elem, this.now, this);
      (c.fx.step[this.prop] || c.fx.step._default)(this)
    },
    cur: function() {
      if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) return this.elem[this.prop];
      var a = parseFloat(c.css(this.elem, this.prop));
      return a && a > -1E4 ? a : 0
    },
    custom: function(a, b, d) {
      function e(l) {
        return f.step(l)
      }
      var f = this,
        h = c.fx;
      this.startTime = c.now();
      this.start = a;
      this.end = b;
      this.unit = d || this.unit || "px";
      this.now = this.start;
      this.pos = this.state = 0;
      e.elem = this.elem;
      if (e() && c.timers.push(e) && !ba) ba = setInterval(h.tick, h.interval)
    },
    show: function() {
      this.options.orig[this.prop] = c.style(this.elem, this.prop);
      this.options.show = true;
      this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
      c(this.elem).show()
    },
    hide: function() {
      this.options.orig[this.prop] = c.style(this.elem, this.prop);
      this.options.hide = true;
      this.custom(this.cur(), 0)
    },
    step: function(a) {
      var b = c.now(),
        d = true;
      if (a || b >= this.options.duration + this.startTime) {
        this.now = this.end;
        this.pos = this.state = 1;
        this.update();
        this.options.curAnim[this.prop] = true;
        for (var e in this.options.curAnim)
          if (this.options.curAnim[e] !== true) d = false;
        if (d) {
          if (this.options.overflow != null && !c.support.shrinkWrapBlocks) {
            var f = this.elem,
              h = this.options;
            c.each(["", "X", "Y"], function(k, o) {
              f.style["overflow" + o] = h.overflow[k]
            })
          }
          this.options.hide && c(this.elem).hide();
          if (this.options.hide ||
            this.options.show)
            for (var l in this.options.curAnim) c.style(this.elem, l, this.options.orig[l]);
          this.options.complete.call(this.elem)
        }
        return false
      } else {
        a = b - this.startTime;
        this.state = a / this.options.duration;
        b = this.options.easing || (c.easing.swing ? "swing" : "linear");
        this.pos = c.easing[this.options.specialEasing && this.options.specialEasing[this.prop] || b](this.state, a, 0, 1, this.options.duration);
        this.now = this.start + (this.end - this.start) * this.pos;
        this.update()
      }
      return true
    }
  };
  c.extend(c.fx, {
    tick: function() {
      for (var a =
          c.timers, b = 0; b < a.length; b++) a[b]() || a.splice(b--, 1);
      a.length || c.fx.stop()
    },
    interval: 13,
    stop: function() {
      clearInterval(ba);
      ba = null
    },
    speeds: {
      slow: 600,
      fast: 200,
      _default: 400
    },
    step: {
      opacity: function(a) {
        c.style(a.elem, "opacity", a.now)
      },
      _default: function(a) {
        if (a.elem.style && a.elem.style[a.prop] != null) a.elem.style[a.prop] = (a.prop === "width" || a.prop === "height" ? Math.max(0, a.now) : a.now) + a.unit;
        else a.elem[a.prop] = a.now
      }
    }
  });
  if (c.expr && c.expr.filters) c.expr.filters.animated = function(a) {
    return c.grep(c.timers, function(b) {
      return a ===
        b.elem
    }).length
  };
  var xb = /^t(?:able|d|h)$/i,
    Ia = /^(?:body|html)$/i;
  c.fn.offset = "getBoundingClientRect" in t.documentElement ? function(a) {
    var b = this[0],
      d;
    if (a) return this.each(function(l) {
      c.offset.setOffset(this, a, l)
    });
    if (!b || !b.ownerDocument) return null;
    if (b === b.ownerDocument.body) return c.offset.bodyOffset(b);
    try {
      d = b.getBoundingClientRect()
    } catch (e) {}
    var f = b.ownerDocument,
      h = f.documentElement;
    if (!d || !c.contains(h, b)) return d || {
      top: 0,
      left: 0
    };
    b = f.body;
    f = fa(f);
    return {
      top: d.top + (f.pageYOffset || c.support.boxModel &&
        h.scrollTop || b.scrollTop) - (h.clientTop || b.clientTop || 0),
      left: d.left + (f.pageXOffset || c.support.boxModel && h.scrollLeft || b.scrollLeft) - (h.clientLeft || b.clientLeft || 0)
    }
  } : function(a) {
    var b = this[0];
    if (a) return this.each(function(x) {
      c.offset.setOffset(this, a, x)
    });
    if (!b || !b.ownerDocument) return null;
    if (b === b.ownerDocument.body) return c.offset.bodyOffset(b);
    c.offset.initialize();
    var d, e = b.offsetParent,
      f = b.ownerDocument,
      h = f.documentElement,
      l = f.body;
    d = (f = f.defaultView) ? f.getComputedStyle(b, null) : b.currentStyle;
    for (var k = b.offsetTop, o = b.offsetLeft;
      (b = b.parentNode) && b !== l && b !== h;) {
      if (c.offset.supportsFixedPosition && d.position === "fixed") break;
      d = f ? f.getComputedStyle(b, null) : b.currentStyle;
      k -= b.scrollTop;
      o -= b.scrollLeft;
      if (b === e) {
        k += b.offsetTop;
        o += b.offsetLeft;
        if (c.offset.doesNotAddBorder && !(c.offset.doesAddBorderForTableAndCells && xb.test(b.nodeName))) {
          k += parseFloat(d.borderTopWidth) || 0;
          o += parseFloat(d.borderLeftWidth) || 0
        }
        e = b.offsetParent
      }
      if (c.offset.subtractsBorderForOverflowNotVisible && d.overflow !== "visible") {
        k +=
          parseFloat(d.borderTopWidth) || 0;
        o += parseFloat(d.borderLeftWidth) || 0
      }
      d = d
    }
    if (d.position === "relative" || d.position === "static") {
      k += l.offsetTop;
      o += l.offsetLeft
    }
    if (c.offset.supportsFixedPosition && d.position === "fixed") {
      k += Math.max(h.scrollTop, l.scrollTop);
      o += Math.max(h.scrollLeft, l.scrollLeft)
    }
    return {
      top: k,
      left: o
    }
  };
  c.offset = {
    initialize: function() {
      var a = t.body,
        b = t.createElement("div"),
        d, e, f, h = parseFloat(c.css(a, "marginTop")) || 0;
      c.extend(b.style, {
        position: "absolute",
        top: 0,
        left: 0,
        margin: 0,
        border: 0,
        width: "1px",
        height: "1px",
        visibility: "hidden"
      });
      b.innerHTML = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
      a.insertBefore(b, a.firstChild);
      d = b.firstChild;
      e = d.firstChild;
      f = d.nextSibling.firstChild.firstChild;
      this.doesNotAddBorder = e.offsetTop !== 5;
      this.doesAddBorderForTableAndCells =
        f.offsetTop === 5;
      e.style.position = "fixed";
      e.style.top = "20px";
      this.supportsFixedPosition = e.offsetTop === 20 || e.offsetTop === 15;
      e.style.position = e.style.top = "";
      d.style.overflow = "hidden";
      d.style.position = "relative";
      this.subtractsBorderForOverflowNotVisible = e.offsetTop === -5;
      this.doesNotIncludeMarginInBodyOffset = a.offsetTop !== h;
      a.removeChild(b);
      c.offset.initialize = c.noop
    },
    bodyOffset: function(a) {
      var b = a.offsetTop,
        d = a.offsetLeft;
      c.offset.initialize();
      if (c.offset.doesNotIncludeMarginInBodyOffset) {
        b += parseFloat(c.css(a,
          "marginTop")) || 0;
        d += parseFloat(c.css(a, "marginLeft")) || 0
      }
      return {
        top: b,
        left: d
      }
    },
    setOffset: function(a, b, d) {
      var e = c.css(a, "position");
      if (e === "static") a.style.position = "relative";
      var f = c(a),
        h = f.offset(),
        l = c.css(a, "top"),
        k = c.css(a, "left"),
        o = e === "absolute" && c.inArray("auto", [l, k]) > -1;
      e = {};
      var x = {};
      if (o) x = f.position();
      l = o ? x.top : parseInt(l, 10) || 0;
      k = o ? x.left : parseInt(k, 10) || 0;
      if (c.isFunction(b)) b = b.call(a, d, h);
      if (b.top != null) e.top = b.top - h.top + l;
      if (b.left != null) e.left = b.left - h.left + k;
      "using" in b ? b.using.call(a,
        e) : f.css(e)
    }
  };
  c.fn.extend({
    position: function() {
      if (!this[0]) return null;
      var a = this[0],
        b = this.offsetParent(),
        d = this.offset(),
        e = Ia.test(b[0].nodeName) ? {
          top: 0,
          left: 0
        } : b.offset();
      d.top -= parseFloat(c.css(a, "marginTop")) || 0;
      d.left -= parseFloat(c.css(a, "marginLeft")) || 0;
      e.top += parseFloat(c.css(b[0], "borderTopWidth")) || 0;
      e.left += parseFloat(c.css(b[0], "borderLeftWidth")) || 0;
      return {
        top: d.top - e.top,
        left: d.left - e.left
      }
    },
    offsetParent: function() {
      return this.map(function() {
        for (var a = this.offsetParent || t.body; a && !Ia.test(a.nodeName) &&
          c.css(a, "position") === "static";) a = a.offsetParent;
        return a
      })
    }
  });
  c.each(["Left", "Top"], function(a, b) {
    var d = "scroll" + b;
    c.fn[d] = function(e) {
      var f = this[0],
        h;
      if (!f) return null;
      if (e !== B) return this.each(function() {
        if (h = fa(this)) h.scrollTo(!a ? e : c(h).scrollLeft(), a ? e : c(h).scrollTop());
        else this[d] = e
      });
      else return (h = fa(f)) ? "pageXOffset" in h ? h[a ? "pageYOffset" : "pageXOffset"] : c.support.boxModel && h.document.documentElement[d] || h.document.body[d] : f[d]
    }
  });
  c.each(["Height", "Width"], function(a, b) {
    var d = b.toLowerCase();
    c.fn["inner" + b] = function() {
      return this[0] ? parseFloat(c.css(this[0], d, "padding")) : null
    };
    c.fn["outer" + b] = function(e) {
      return this[0] ? parseFloat(c.css(this[0], d, e ? "margin" : "border")) : null
    };
    c.fn[d] = function(e) {
      var f = this[0];
      if (!f) return e == null ? null : this;
      if (c.isFunction(e)) return this.each(function(l) {
        var k = c(this);
        k[d](e.call(this, l, k[d]()))
      });
      if (c.isWindow(f)) return f.document.compatMode === "CSS1Compat" && f.document.documentElement["client" + b] || f.document.body["client" + b];
      else if (f.nodeType === 9) return Math.max(f.documentElement["client" +
        b], f.body["scroll" + b], f.documentElement["scroll" + b], f.body["offset" + b], f.documentElement["offset" + b]);
      else if (e === B) {
        f = c.css(f, d);
        var h = parseFloat(f);
        return c.isNaN(h) ? f : h
      } else return this.css(d, typeof e === "string" ? e : e + "px")
    }
  })
})(window);
jQuery.noConflict();
$j = jQuery;
/*! RESOURCE: ITGDN - getGlobalSearchResults */
function getGlobalSearchResults(search) {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "getSearchResults");
  gajax.addParam("searchTerm", search);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var spinner = document.getElementById('modal');
    spinner.style.display = "block";
    var dataCounter = 0;
    var output = '';
    var dataKB = serverResponse.responseXML.getElementsByTagName("resultKB");
    if (dataKB.length > 0) {
      output += "<div id='searchResults'>";
      output += "<h2>Knowledge Base</h2>";
      for (var i = 0; i < dataKB.length; i++) {
        var kb_sys_id = dataKB[i].getAttribute("kb_sys_id").toString();
        var kb_short_description = dataKB[i].getAttribute("kb_short_description").toString();
        var kb_text = dataKB[i].getAttribute("kb_text").toString();
        output += '<div class="searchResultRow">';
        output += '<div class="searchResultTitle"><a href="knowledge_detail.do?sys_id=' + kb_sys_id + '">' + kb_short_description + '<a/></div>';
        output += '<div class="searchResultText">' + kb_text + '</div>';
        output += '</div>';
      }
      output += "</div>";
    } else {
      dataCounter++;
    }
    var dataCat = serverResponse.responseXML.getElementsByTagName("resultCat");
    var dataCall = serverResponse.responseXML.getElementsByTagName("resultCall");
    if (dataCall.length > 0) {
      if (dataKB.length > 0) {
        output += '<hr/>';
      }
      output += "<div id='searchResults'>";
      output += "<h2>Incidents</h2>";
      for (var i = 0; i < dataCall.length; i++) {
        var cal_sys_id = dataCall[i].getAttribute("call_sys_id").toString();
        var cal_short_description = dataCall[i].getAttribute("call_short_description").toString();
        var cal_number = dataCall[i].getAttribute("call_number").toString();
        output += '<div class="searchResultRow">';
        output += '<div class="searchResultTitle"><a href="status_detail.do?sys_id=' + cal_sys_id + '%26sysparm_view=ess">' + cal_number + '<a/></div>';
        output += '<div class="searchResultText">' + cal_short_description + '</div>';
        output += '</div>';
      }
      output += "</div>";
    } else {
      dataCounter++;
    }
    if (output == '') {
      output = '' + getMessage("cms_search_no_result");
    }
    $j("div#wrapper").html(output);
    spinner.style.display = "none";
  }
}
/*! RESOURCE: ScrumAddSprints */
var ScrumAddSprints = Class.create({
  initialize: function(gr) {
    this._gr = gr;
    this._prmNms = ["spName", "spDuration", "spStartDate", "spStartNum", "spNum", "_tn", "_sys_id"];
    this._dateFN = ["spStartDate"];
    this._refObs = [];
    this._prmVls = [];
    for (var i = 0; i < this._prmNms.length; i++) {
      this._prmVls[this._prmNms[i]] = "";
    }
    this._prmErr = [];
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._crtDlg = new dialogClass("scrum_add_sprints_dialog");
    this._crtDlg.setTitle("Add Sprints");
    this._crtDlg.setPreference("_tn", this._gr.getTableName());
    this._crtDlg.setPreference("_sys_id", (this._gr.getUniqueValue()));
    this._crtDlg.setPreference("handler", this);
  },
  showDialog: function() {
    this._crtDlg.render();
  },
  onSubmit: function() {
    this._readFormValues();
    if (!this._validate()) {
      var errMsg = "Before you submit:";
      for (var i = 0; i < this._prmErr.length; i++) {
        errMsg += "\n * " + this._prmErr[i];
      }
      alert(errMsg);
      $j('#spName').focus();
      return false;
    }
    this._crtDlg.destroy();
    var ga = new GlideAjax("ScrumAddSprintsAjaxProcessor");
    ga.addParam("sysparm_name", "checkDuration");
    for (var i = 0; i < this._prmNms.length; i++) {
      ga.addParam(this._prmNms[i], this._prmVls[this._prmNms[i]]);
    }
    ga.getXML(this.checkComplete.bind(this));
    return false;
  },
  checkComplete: function(response) {
    var resp = response.responseXML.getElementsByTagName("item");
    if (resp[0].getAttribute("result") == "success") {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._plsWtDlg = new dialogClass("scrum_please_wait");
      this._plsWtDlg.setTitle("Working.  Please wait.");
      this._plsWtDlg.render();
      var ga = new GlideAjax("ScrumAddSprintsAjaxProcessor");
      ga.addParam("sysparm_name", "addSprints");
      for (var i = 0; i < this._prmNms.length; i++) {
        ga.addParam(this._prmNms[i], this._prmVls[this._prmNms[i]]);
      }
      ga.getXML(this.createComplete.bind(this));
      return false;
    }
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._rlsPshDlg = new dialogClass("scrum_release_push_confirm_dialog");
    this._rlsPshDlg.setTitle("Modify Release Dates");
    this._rlsPshDlg.setPreference("handler", this);
    this._rlsPshDlg.render();
  },
  confirmReleasePush: function() {
    this._rlsPshDlg.destroy();
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._plsWtDlg = new dialogClass("scrum_please_wait");
    this._plsWtDlg.setTitle("Working.  Please wait.");
    this._plsWtDlg.render();
    var ga = new GlideAjax("ScrumAddSprintsAjaxProcessor");
    ga.addParam("sysparm_name", "addSprints");
    for (var i = 0; i < this._prmNms.length; i++) {
      ga.addParam(this._prmNms[i], this._prmVls[this._prmNms[i]]);
    }
    ga.getXML(this.createComplete.bind(this));
    return false;
  },
  cancelReleasePush: function(response) {
    this._rlsPshDlg.destroy();
    window.location.reload();
    return false;
  },
  createComplete: function(response) {
    this._plsWtDlg.destroy();
    var resp = response.responseXML.getElementsByTagName("item");
    if (resp[0].getAttribute("result") == "success") {
      this._sprints = response.responseXML.documentElement.getAttribute("answer");
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._viewConfirm = new dialogClass("scrum_sprints_view_confirm_dialog");
      this._viewConfirm.setTitle("Sprints Created");
      this._viewConfirm.setPreference("handler", this);
      this._viewConfirm.render();
    } else {
      var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
      this._createError = new dialogClass("scrum_error");
      this._createError.setTitle("Error Creating Sprints");
      this._createError.setPreference("handler", this);
      this._createError.render();
    }
  },
  viewConfirmed: function() {
    this._viewConfirm.destroy();
    window.location = "rm_sprint_list.do?sysparm_query=numberIN" + this._sprints + "&sysparm_view=scrum";
    return false;
  },
  viewCancelled: function() {
    this._viewConfirm.destroy();
    window.location.reload();
    return false;
  },
  popCal: function(dateFieldId) {
    return new GwtDateTimePicker(dateFieldId, g_user_date_time_format, true);
  },
  _validate: function() {
    var valid = true;
    this._prmErr = [];
    if (this._prmVls["spName"] == "") {
      this._prmErr.push("You must supply a Name");
      valid = false;
    }
    if (this._prmVls["spDuration"] == "" || isNaN(this._prmVls['spDuration'])) {
      this._prmErr.push("You must supply a valid numeric duration");
      valid = false;
    }
    if (this._prmVls["spStartDate"] == "") {
      this._prmErr.push("You must supply a Start Date");
      valid = false;
    }
    if (this._prmVls["spNum"] == "" || isNaN(this._prmVls['spNum'])) {
      this._prmErr.push("You must supply a valid Number of Sprints to create");
      valid = false;
    }
    if (this._prmVls["spStartNum"] == "" || isNaN(this._prmVls['spStartNum'])) {
      this._prmErr.push("You must supply a valid starting number");
      valid = false;
    }
    return valid;
  },
  _readFormValues: function() {
    for (var i = 0; i < this._prmNms.length; i++) {
      var frmVl = this._getValue(this._prmNms[i]);
      if ((typeof frmVl === "undefined") || frmVl == "undefined" || frmVl == null || frmVl == "null") {
        frmVl = "";
      }
      this._prmVls[this._prmNms[i]] = frmVl;
    }
  },
  _getValue: function(inptNm) {
    return gel(inptNm).value;
  },
  type: "ScrumAddSprints"
});
/*! RESOURCE: ITGDN - getKnowledgeDetail */
function getKnowledgeDetail(sys_id) {
  var gajax = new GlideAjax("itgdnUtils");
  gajax.addParam("sysparm_name", "getKnowledgeBaseDetail");
  gajax.addParam("knowledge_sys_id", sys_id);
  gajax.getXML(ajaxResponse);

  function ajaxResponse(serverResponse) {
    var data = serverResponse.responseXML.getElementsByTagName("result");
    if (data.length > 0) {
      var output = "<div id='knowledgeDetailWrapper'>";
      output += '<h2>' + data[0].getAttribute("knowledge_name").toString() + '</h2>';
      output += '<div class="knowledgeText">' + data[0].getAttribute("knowledge_text").toString() + '</div>';
      output += '</div>';
      $j("div#wrapper").html(output);
    } else {
      $j("div#wrapper").html('No record found.');
    }
  }
}
/*! RESOURCE: excel_browser.js */
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f
      }
      var l = n[o] = {
        exports: {}
      };
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e)
      }, l, l.exports, e, t, n, r)
    }
    return n[o].exports
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s
})({
  1: [function(require, module, exports) {
    "use strict";
    var utils = require('./utils');
    var debug = require('debug')('Cell');
    var Cell = function(row, cellNode) {
      this._row = row;
      this._cellNode = cellNode;
    };
    Cell.prototype.toString = function() {
      return utils.getNodeInfo(this._cellNode, {
        address: this.getFullAddress()
      });
    };
    Cell.prototype.getRow = function() {
      return this._row;
    };
    Cell.prototype.getSheet = function() {
      return this.getRow().getSheet();
    };
    Cell.prototype.getAddress = function() {
      return this._cellNode.getAttribute("r");
    };
    Cell.prototype.getRowNumber = function() {
      return utils.addressToRowAndColumn(this.getAddress()).row;
    };
    Cell.prototype.getColumnNumber = function() {
      return utils.addressToRowAndColumn(this.getAddress()).column;
    };
    Cell.prototype.getColumnName = function() {
      return utils.columnNumberToName(this.getColumnNumber());
    };
    Cell.prototype.getFullAddress = function() {
      return utils.addressToFullAddress(this.getSheet().getName(), this.getAddress());
    };
    Cell.prototype.setValue = function(value) {
      this._clearContents();
      var isNode, tNode, vNode, textNode;
      if (typeof value === "string") {
        this._cellNode.setAttribute("t", "inlineStr");
        isNode = this._cellNode.ownerDocument.createElement("is");
        this._cellNode.appendChild(isNode);
        tNode = this._cellNode.ownerDocument.createElement("t");
        isNode.appendChild(tNode);
        textNode = this._cellNode.ownerDocument.createTextNode(value);
        tNode.appendChild(textNode);
      } else if (typeof value === "boolean") {
        this._cellNode.setAttribute("t", "b");
        vNode = this._cellNode.ownerDocument.createElement("v");
        this._cellNode.appendChild(vNode);
        textNode = this._cellNode.ownerDocument.createTextNode(value ? 1 : 0);
        vNode.appendChild(textNode);
      } else if (typeof value === "number") {
        vNode = this._cellNode.ownerDocument.createElement("v");
        this._cellNode.appendChild(vNode);
        textNode = this._cellNode.ownerDocument.createTextNode(value);
        vNode.appendChild(textNode);
      } else if (value instanceof Date) {
        vNode = this._cellNode.ownerDocument.createElement("v");
        this._cellNode.appendChild(vNode);
        textNode = this._cellNode.ownerDocument.createTextNode(utils.dateToExcelNumber(value));
        vNode.appendChild(textNode);
      }
      return this;
    };
    Cell.prototype.getRelativeCell = function(rowOffset, columnOffset) {
      if (!utils.isInteger(rowOffset)) {
        throw new Error(
          this,
          'Expected row offset to be an integer',
          rowOffset
        );
      }
      if (!utils.isInteger(columnOffset)) {
        throw new Error(
          this,
          'Expected column offset to be an integer',
          columnOffset
        );
      }
      var absoluteRow = rowOffset + this.getRowNumber();
      if (absoluteRow < 0) {
        throw new Error(
          this,
          'Expected relative row to be a non-negative integer',
          absoluteRow
        );
      }
      var absoluteColumn = columnOffset + this.getColumnNumber();
      if (absoluteColumn < 0) {
        throw new Error(
          this,
          'Expected relative column to be a non-negative integer',
          absoluteColumn
        );
      }
      return this.getSheet().getCell(absoluteRow, absoluteColumn);
    };
    Cell.prototype.setFormula = function(formula, calculatedValue, sharedIndex, sharedRef) {
      this.setValue(calculatedValue);
      var fNode = this._cellNode.ownerDocument.createElement('f');
      this._cellNode.appendChild(fNode);
      if (typeof formula === 'string') {
        if (formula.length > 0) {
          var textNode = this._cellNode.ownerDocument.createTextNode(formula);
          fNode.appendChild(textNode);
        }
      }
      if (utils.isInteger(sharedIndex)) {
        if (sharedIndex >= 0) {
          fNode.setAttribute('t', 'shared');
          fNode.setAttribute('si', String(sharedIndex));
        }
      }
      if (typeof sharedRef === 'string') {
        fNode.setAttribute('ref', sharedRef);
      }
      return this;
    };
    Cell.prototype._isSharedFormula = function(isSource) {
      isSource = isSource || false;
      var fNode = this._cellNode.getElementsByTagName('f')[0];
      if (!fNode) {
        debug('Cell %s', this);
        debug('Node <f> (formula) not found');
        debug('Node %s', utils.getNodeInfo(this._cellNode));
        return false;
      }
      if (isSource) {
        var fNodeText = utils.getNodeText(fNode);
        if (!fNodeText || !fNodeText.length) {
          debug('Cell %s', this);
          debug('Node <f> (formula) is empty');
          return false;
        }
        var fNodeRef = fNode.getAttribute('ref');
        if (!fNodeRef || !fNodeRef.length) {
          debug('Cell %s', this);
          debug('Node <f> (formula) attribute ref (address range) is empty');
          debug('Node <f> %s', utils.getNodeInfo(fNode));
          return false;
        }
      }
      var fNodeType = fNode.getAttribute('t');
      if (fNodeType !== 'shared') {
        debug('Cell %s', this);
        debug('Node <f> (formula) attribute t (type) not shared');
        debug('Node <f> %s', utils.getNodeInfo(fNode));
        return false;
      }
      var fNodeSharedIndex = fNode.getAttribute('si');
      if (!fNodeSharedIndex || !fNodeSharedIndex.length) {
        debug('Cell %s', this);
        debug('Node <f> (formula) attribute si (shared index) is empty');
        debug('Node <f> %s', utils.getNodeInfo(fNode));
        return false;
      }
      return true;
    };
    Cell.prototype.shareFormulaUntil = function(lastSharedCell) {
      if (this._isSharedFormula(true) === false) {
        throw new Error('Expected cell to be a shared formula source');
      }
      var fNode = this._cellNode.getElementsByTagName('f')[0];
      var sharedIndex = parseInt(fNode.getAttribute('si'));
      if (!utils.isInteger(sharedIndex) || sharedIndex < 0) {
        throw new Error(
          this,
          'Expected shared index to be a non-negative integer',
          utils.getNodeInfo(fNode)
        );
      }
      if (typeof lastSharedCell === 'string') {
        lastSharedCell = this.getSheet().getCell(lastSharedCell);
      }
      if (lastSharedCell instanceof Cell === false) {
        throw new Error(
          this,
          'Expected lastSharedCell to be a cell',
          lastSharedCell
        );
      }
      var cell;
      var rowNumber = this.getRowNumber();
      var columnNumber = this.getColumnNumber();
      var lastSharedCellRowNumber = lastSharedCell.getRowNumber();
      var lastSharedCellColumnNumber = lastSharedCell.getColumnNumber();
      if (rowNumber === lastSharedCellRowNumber) {
        for (var c = 1 + columnNumber; c <= lastSharedCellColumnNumber; c++) {
          this
            .getSheet()
            .getCell(rowNumber, c)
            .setFormula(undefined, undefined, sharedIndex);
        }
      } else if (columnNumber === lastSharedCellColumnNumber) {
        for (var r = 1 + rowNumber; r <= lastSharedCellRowNumber; r++) {
          this
            .getSheet()
            .getCell(r, columnNumber)
            .setFormula(undefined, undefined, sharedIndex);
        }
      } else {
        throw new Error(
          this,
          'Expected last shared forumla cell to align either row-wise or column-wise with shared formula source',
          lastSharedCell
        );
      }
      var sharedRef = this.getAddress() + ':' + lastSharedCell.getAddress();
      fNode.setAttribute('ref', sharedRef);
      return this;
    };
    Cell.prototype._clearContents = function() {
      while (this._cellNode.firstChild) {
        this._cellNode.removeChild(this._cellNode.firstChild);
      }
      this._cellNode.removeAttribute("t");
    };
    module.exports = Cell;
  }, {
    "./utils": 5,
    "debug": 11
  }],
  2: [function(require, module, exports) {
    "use strict";
    var utils = require('./utils');
    var Cell = require('./Cell');
    var Row = function(sheet, rowNode) {
      this._sheet = sheet;
      this._sheet._cacheCells = this._sheet._cacheCells || {};
      this._rowNode = rowNode;
    };
    Row.prototype.getSheet = function() {
      return this._sheet;
    };
    Row.prototype.getRowNumber = function() {
      return parseInt(this._rowNode.getAttribute("r"));
    };
    Row.prototype.getCell = function(columnNumber) {
      var address = utils.rowAndColumnToAddress(this.getRowNumber(), columnNumber);
      var getNodeColumnNumber = function(node) {
        return utils.addressToRowAndColumn(node.getAttribute("r")).column;
      };
      var nextNode;
      var searchResult = {
        found: false,
        index: 0
      };
      if (!searchResult.found) {
        if (columnNumber in this._sheet._cacheCells) {
          var cachedIndex = this._sheet._cacheCells[columnNumber];
          var cachedNode = this._rowNode.childNodes[cachedIndex];
          if (cachedNode) {
            if (getNodeColumnNumber(cachedNode) === columnNumber) {
              searchResult = {
                found: true,
                index: cachedIndex
              };
            }
          }
        }
      }
      if (!searchResult.found) {
        if (this._rowNode.hasChildNodes()) {
          searchResult = utils.binarySearch(columnNumber, this._rowNode.childNodes, getNodeColumnNumber);
        }
      }
      nextNode = this._rowNode.childNodes[searchResult.index];
      var cellNode;
      if (searchResult.found) {
        cellNode = nextNode;
      } else {
        cellNode = this._rowNode.ownerDocument.createElement("c");
        cellNode.setAttribute("r", address);
        if (nextNode) {
          this._rowNode.insertBefore(cellNode, nextNode);
        } else {
          this._rowNode.appendChild(cellNode);
        }
      }
      this._sheet._cacheCells[columnNumber] = searchResult.index;
      return new Cell(this, cellNode);
    };
    module.exports = Row;
  }, {
    "./Cell": 1,
    "./utils": 5
  }],
  3: [function(require, module, exports) {
    "use strict";
    var xpath = require('./xpath');
    var utils = require('./utils');
    var Row = require('./Row');
    var Sheet = function(workbook, sheetNode, sheetXML) {
      this._workbook = workbook;
      this._sheetNode = sheetNode;
      this._sheetXML = sheetXML;
      this._sheetDataNode = xpath('sml:sheetData', sheetXML)[0];
      this._cacheRows = {};
    };
    Sheet.prototype.getWorkbook = function() {
      return this._workbook;
    };
    Sheet.prototype.getName = function() {
      return this._sheetNode.getAttribute("name");
    };
    Sheet.prototype.setName = function(name) {
      this._sheetNode.setAttribute("name", name);
    };
    Sheet.prototype.getRow = function(rowNumber) {
      var getNodeRowNumber = function(node) {
        return parseInt(node.getAttribute("r"));
      };
      var nextNode;
      var searchResult = {
        found: false,
        index: 0
      };
      if (!searchResult.found) {
        if (rowNumber in this._cacheRows) {
          var cachedIndex = this._cacheRows[rowNumber];
          var cachedNode = this._sheetDataNode.childNodes[cachedIndex];
          if (cachedNode) {
            if (getNodeRowNumber(cachedNode) === rowNumber) {
              searchResult = {
                found: true,
                index: cachedIndex
              };
            }
          }
        }
      }
      if (!searchResult.found) {
        if (this._sheetDataNode.hasChildNodes()) {
          searchResult = utils.binarySearch(rowNumber, this._sheetDataNode.childNodes, getNodeRowNumber);
        }
      }
      nextNode = this._sheetDataNode.childNodes[searchResult.index];
      var rowNode;
      if (searchResult.found) {
        rowNode = nextNode;
      } else {
        rowNode = this._sheetDataNode.ownerDocument.createElement("row");
        rowNode.setAttribute("r", rowNumber);
        if (nextNode) {
          this._sheetDataNode.insertBefore(rowNode, nextNode);
        } else {
          this._sheetDataNode.appendChild(rowNode);
        }
      }
      this._cacheRows[rowNumber] = searchResult.index;
      return new Row(this, rowNode);
    };
    Sheet.prototype.getCell = function() {
      var rowNumber, columnNumber;
      if (arguments.length === 1) {
        var address = arguments[0];
        var ref = utils.addressToRowAndColumn(address);
        rowNumber = ref.row;
        columnNumber = ref.column;
      } else {
        rowNumber = arguments[0];
        columnNumber = arguments[1];
      }
      return this.getRow(rowNumber).getCell(columnNumber);
    };
    module.exports = Sheet;
  }, {
    "./Row": 2,
    "./utils": 5,
    "./xpath": 6
  }],
  4: [function(require, module, exports) {
    "use strict";
    var fs = require('fs');
    var JSZip = require('jszip');
    var JSZipUtils = require('jszip-utils');
    var utils = require('./utils');
    var Sheet = require('./Sheet');
    var path = require("path");
    var DOMParser = require('xmldom').DOMParser;
    var parser = new DOMParser();
    var xpath = require("./xpath");
    var Buffer = require('buffer').Buffer;
    var Workbook = function(data) {
      data = data || Buffer(
        'UEsDBBQAAAAIAAAAIQC1VTAj7AAAAEwCAAALAAAAX3JlbHMvLnJlbHONks1OwzAMgO9IvEPk++puSAihpbsgpN0QKg9gEvdHbeMoCdC9PeGAoNIYPcaxP3+2vD/M06jeOcRenIZtUYJiZ8T2rtXwUj9u7kDFRM7SKI41nDjCobq+2j/zSCkXxa73UWWKixq6lPw9YjQdTxQL8ezyTyNhopSfoUVPZqCWcVeWtxh+M6BaMNXRaghHewOqPnlew5am6Q0/iHmb2KUzLZDnxM6y3fiQ60Pq8zSqptBy0mDFPOVwRPK+yGjA80a79UZ/T4sTJ7KUCI0EvuzzlXFJaLte6P8VLTN+bOYRPyQMryLDtwsubqD6BFBLAwQUAAAACAAAACEA3kEW2XsBAAARAwAAEAAAAGRvY1Byb3BzL2FwcC54bWydkkFP4zAQhe9I/IfId+oElhWqHCNUQBwWbaUWOBtn0lg4tuUZopZfj5OqIV32xO3NzNPLlxmL621rsw4iGu9KVsxyloHTvjJuU7Kn9f3ZFcuQlKuU9Q5KtgNk1/L0RCyjDxDJAGYpwmHJGqIw5xx1A63CWRq7NKl9bBWlMm64r2uj4dbr9xYc8fM8/81hS+AqqM7CGMj2ifOOfhpaed3z4fN6F1KeFDchWKMVpb+Uj0ZHj76m7G6rwQo+HYoUtAL9Hg3tZC74tBQrrSwsUrCslUUQ/KshHkD1S1sqE1GKjuYdaPIxQ/OR1nbOsleF0OOUrFPRKEdsb9sXg7YBKcoXH9+wASAUfGwOcuqdavNLFoMhiWMjH0GSPkZcG7KAf+ulivQf4mJKPDCwCeOq5yu+8R2+9E/2wrdBubRAPqo/xr3hU1j7W0VwWOdxU6waFaFKFxjXPTbEQ+KKtvcvGuU2UB083wf98Z/3L1wWl7P8Is+Hmx96gn+9ZfkJUEsDBBQAAAAIAOehdkc+qGWw1QAAAG0BAAARAAAAZG9jUHJvcHMvY29yZS54bWxtkE1Lw0AQhu9C/0PYezKJBZGQpDdPCkIVvA67Y7qY/WBnNO2/7zZoFOxxeJ95mHm73dFNxRcltsH3qqlqVZDXwVg/9ur15aG8VwULeoNT8NSrE7HaDZubTsdWh0TPKURKYomLbPLc6tirg0hsAVgfyCFXmfA5fA/JoeQxjRBRf+BIcFvXd+BI0KAgXIRlXI3qW2n0qoyfaVoERgNN5MgLQ1M18MsKJcdXF5bkD+msnCJdRX/ClT6yXcF5nqt5u6D5/gbenh73y6ul9ZeuNKmhg38FDWdQSwMEFAAAAAAA2aF2RwAAAAAAAAAAAAAAAAkAAAB4bC9fcmVscy9QSwMEFAAAAAgAAAAhAI2H2nDaAAAALQIAABoAAAB4bC9fcmVscy93b3JrYm9vay54bWwucmVsc62R3YrCMBCF7xf2HcLcb9NWWGQx9UYWeiv1AUI6/cE2CZlZtW9vXMEfEPHCq+FMmO+cySyWh3EQOwzUO6sgS1IQaI2re9sq2FS/X3MQxNrWenAWFUxIsCw+PxZrHDTHIep6TyJSLCnomP2PlGQ6HDUlzqONL40Lo+YoQyu9NlvdoszT9FuGWwYUd0xR1gpCWc9AVJPHV9iuaXqDK2f+RrT8wEIST0NcQFQ6tMgKzjqJHJCP7fN32nOcxav7vzw3s2cZsndm2LuwpQ6RrzkurfhBp3IJI++OXBwBUEsDBBQAAAAIAAAAIQDeI/LTbgIAALEFAAANAAAAeGwvc3R5bGVzLnhtbKWUXWvbMBSG7wf7D0L3rmw3zpJguyxNDYVuDJrBbhVbTkT1YSSlSzb233tkO7FDxzbWK53z6ug5rz7s9OYgBXpmxnKtMhxdhRgxVeqKq22Gv66LYIaRdVRVVGjFMnxkFt/k79+l1h0Fe9wx5hAglM3wzrlmQYgtd0xSe6UbpmCm1kZSB6nZEtsYRivrF0lB4jCcEkm5wh1hIct/gUhqnvZNUGrZUMc3XHB3bFkYyXJxv1Xa0I0Aq4doQssTu01e4SUvjba6dleAI7quecleu5yTOQFSntZaOYtKvVcOzgrQHrp4Uvq7KvyUF7uqPLU/0DMVoESY5GmphTbIQVfmi0BRVLKu4pYKvjHcizWVXBw7OfZCa7Svkxy25kXSdWgHC4u4EGdXMe6EPIXTccyoAhLUx+tjA+0VXGSHaev+Ur019BjFyWhBO0DfjTYVPJzhPE5SngpWO1hg+HbnR6cb4iedg1PO04rTrVZUeORpRR8AtmRCPPrH9a2+YB9qpPaykO6+yjA8U7/7UwiG+rDDdInnj2kd+81YdKgv+Wd02+iCflaRv+8Mf/YPWQwItNlz4bj6jWFgVofBazvr/Mu+7AKMitV0L9z6PJnhIf7EKr6X8bnqC3/Wrq8a4gd/U9HU92AH92BdO6K94Rn+ebf8MF/dFXEwC5ezYHLNkmCeLFdBMrldrlbFPIzD21+jD+0Nn1n7O4BLiSYLK6DK9JvtzT8OWoZHSWe/PT+wPfY+j6fhxyQKg+I6jILJlM6C2fQ6CYokilfTyfIuKZKR9+T/vEchiaLBfLJwXDLBFbu0vx6rcEmQ/mET5HQTZPjX5i9QSwMEFAAAAAAA2aF2RwAAAAAAAAAAAAAAAAkAAAB4bC90aGVtZS9QSwMEFAAAAAgAAAAhAIuCblj1BQAAjhoAABMAAAB4bC90aGVtZS90aGVtZTEueG1s7VlPjxs1FL8j8R2suafzfyZZNVslk6SF7rZVd1vUozNxMm4842js7G5UVULtEQkJURAXJG4cEFCplbiUT7NQBEXqV8DjyR9P4tCFbqWCmkjJ+Pn3nn9+7/nZM3Px0klKwBHKGaZZ07AvWAZAWUwHOBs1jVuHvVrdAIzDbAAJzVDTmCFmXNp9/72LcIcnKEVA6GdsBzaNhPPJjmmyWIghu0AnKBN9Q5qnkItmPjIHOTwWdlNiOpYVmCnEmQEymAqz14dDHCNwWJg0dhfGu0T8ZJwVgpjkB7EcUdWQ2MHYLv7YjEUkB0eQNA0xzoAeH6ITbgACGRcdTcOSH8PcvWgulQjfoqvo9eRnrjdXGIwdqZeP+ktFz/O9oLW075T2N3HdsBt0g6U9CYBxLGZqb2D9dqPd8edYBVReamx3wo5rV/CKfXcD3/KLbwXvrvDeBr7Xi1Y+VEDlpa/xSehEXgXvr/DBBj60Wh0vrOAlKCE4G2+gLT9wo8Vsl5AhJVe08Ibv9UJnDl+hTCW7Sv2Mb8u1FN6leU8AZHAhxxngswkawljgIkhwP8dgD48SkXgTmFEmxJZj9SxX/BZfT15Jj8AdBBXtUhSzDVHBB7A4xxPeND4UVg0F8vLZ9y+fPQEvnz0+ffD09MFPpw8fnj74UaN4BWYjVfHFt5/9+fXH4I8n37x49IUez1T8rz988svPn+uBXAU+//Lxb08fP//q09+/e6SBt3LYV+GHOEUMXEPH4CZNxdw0A6B+/s80DhOIKxowEUgNsMuTCvDaDBIdro2qzrudiyKhA16e3q1wPUjyKcca4NUkrQD3KSVtmmunc7UYS53ONBvpB8+nKu4mhEe6saO10HanE5HtWGcySlCF5g0iog1HKEMcFH10jJBG7Q7GFb/u4zinjA45uINBG2KtSw5xn+uVruBUxGWmIyhCXfHN/m3QpkRnvoOOqkixICDRmUSk4sbLcMphqmUMU6Ii9yBPdCQPZnlccTjjItIjRCjoDhBjOp3r+axC96ooLvqw75NZWkXmHI91yD1IqYrs0HGUwHSi5YyzRMV+wMYiRSG4QbmWBK2ukKIt4gCzreG+jVEl3K9e1rdEXdUnSNEzzXVLAtHqepyRIUTSuLlWzVOcvbK0rxV1/11R1xf1Vo61S2u9lG/D/QcLeAdOsxtIrBkN9F39fle///f1e9taPv+qvSrUZqmonN3TrUf3ISbkgM8I2mOyxDMxvUFPCGVDKi3vFCaJuJwPV8GNciivQU75R5gnBwmciGFsOcKIzU2PGJhQJjYJY6vtooNM0306KKW2vbg5FQqQr+Rik1nIxZbES2kQru7CluZla8RUAr40enYSymBVEq6GROiejYRtnReLhoZF3f47FqYSFbH+ACyea/heyUjkGyRoUMSp1F9E99wjvc2Z1Wk7muk1vLM5+QyRrpBQ0q1KQknDBA7QuvicY91YhbRCz9HSCOtvItbmZm0gWbUFjsWac31hJoaTpjEUx0NxmU6EPVbUTUhGWdOI+dzR/6ayTHLGO5AlJUx2lfNPMUc5IDgVua6GgWQrbrYTWm8vuYb19nnOXA8yGg5RzLdIVk3RVxrR9r4muGjQqSB9kAyOQZ9M85tQOMoP7cKBA8z40psDnCvJvfLiWrmaL8XKQ7PVEoVkksD5jqIW8xIur5d0lHlIpuuzqrbnk+mPeuex675aqehQiuaWDSTcWsXe3CavsHL1rHxtrWvUl1L9LvH6G4JCra6n5uqpWVuoneOBQBku2OK35R5x3rvBetaayrlStjbeTtD+XZH5HXFcnRLOJFV0Iu4RosVz5bISSOmiupxwMM1x07hn+S0vcvyoZtX9bs1zPatW91tureX7rt31bavTdu4Lp/Aktf1y7J64nyGz+csXKd94AZMujtkXYpqaVJ6DTaksX8DYzvYXMAALz9wLnF7DbbSDWsNt9Wpep12vNaKgXesEUdjpdSK/3ujdN8CRBHstN/KCbr0W2FFU8wKroF9v1ELPcVpe2Kp3vdb9ua/FzBf/C/dKXrt/AVBLAwQUAAAACAAAACEAfDzuwy4CAACbBAAADwAAAHhsL3dvcmtib29rLnhtbK2UTY+bMBCG75X6H5DvhI9AN0Ehq81H1UjVarXN7l5yccwQ3Bib2qZJVPW/d4CSps1lK+0Fj8344Z13bCa3x1I430EbrmRKgoFPHJBMZVzuUvK0/uiOiGMslRkVSkJKTmDI7fT9u8lB6f1Wqb2DAGlSUlhbJZ5nWAElNQNVgcQ3udIltTjVO89UGmhmCgBbCi/0/Q9eSbkkHSHRr2GoPOcMForVJUjbQTQIalG+KXhlelrJXoMrqd7XlctUWSFiywW3pxZKnJIlq51Umm4Fln0M4p6M4RW65Ewro3I7QNRvkVf1Br4XBF3J00nOBTx3tju0qu5p2XxFEEdQY5cZt5ClBGUIdYC/FnRdzWoucBJEUegTb3puxYN2MshpLewaZfV4TIyHYRg2mVjUnbCgJbUwV9Kih2/kV8ueFwoLdx7hW801mM626QSflCV0ax6oLZxai5TMk82TQX2b7KsqpFFyM1cZbI7CHN1KVTV2FDaCbzcXrtNrif/hO2WNAd5ZZRf/68Z00hj5zOFg/vjaTJ3jC5eZOqRkPMQ7cupnGB/a8IVntkhJOPRvzmufgO8Kiw3wh12nvAt6K7AfHdkegC9NHOCNa8ZV02NseMIx0KssaAn9NkYFw4Y3Q5sYh3HQZsDRfja2HdFrnpIfQeTf3fjjyPWXw9iNRuPQHUXD0J1Hi3AZ3ywXy1n8822PN1KSi2PJCqrtWlO2x//KI+QzaqAprikIdXbPVrXX75r+AlBLAwQUAAAAAADZoXZHAAAAAAAAAAAAAAAADgAAAHhsL3dvcmtzaGVldHMvUEsDBBQAAAAIAAAAIQDmVajjXQEAAIQCAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDEueG1sjZJPawIxEMXvhX6HkLtGbW2ruEpBpB4Kpf/u2ezsbjDJLMlY9dt3dq1S8OJtXibz471JZou9d+IHYrIYMjnsD6SAYLCwocrk1+eq9yRFIh0K7TBAJg+Q5GJ+ezPbYdykGoAEE0LKZE3UTJVKpgavUx8bCNwpMXpNLGOlUhNBF92Qd2o0GDwor22QR8I0XsPAsrQGlmi2HgIdIRGcJvafatukE82ba3Bex8226Rn0DSNy6ywdOqgU3kzXVcCoc8e598N7bU7sTlzgvTURE5bUZ9yf0cvMEzVRTJrPCssJ2rWLCGUmn4dSzWfdxW8Lu/SvFqTzD3BgCAp+Iyna3eeIm7a55qNBO6ouZldd0LcoCij11tE77l7AVjUxZMxZ2hTT4rCEZHiXjOmPxmcTS02a60ZX8KpjZUMSDsru1qMU8YjpasKmqxiZIxH6k6o5OcRW3UlRItJJtG7P/2f+C1BLAwQUAAAACAAAACEApFPFz0EBAAAIBAAAEwAAAFtDb250ZW50X1R5cGVzXS54bWytk89OAjEQxu8mvkPTK9kWPBhjWDj456gc8AFqO8s2dNumUxDe3tmCHgiKBC/b7M583+/bdjqebjrH1pDQBl/zkRhyBl4HY/2i5m/z5+qOM8zKG+WCh5pvAfl0cn01nm8jICO1x5q3Ocd7KVG30CkUIYKnShNSpzK9poWMSi/VAuTNcHgrdfAZfK5y78En40do1Mpl9rShz7skCRxy9rBr7Fk1VzE6q1Wmulx7c0Cp9gRBytKDrY04oAYujxL6ys+Ave6VtiZZA2ymUn5RHXXJjZMfIS3fQ1iK302OpAxNYzWYoFcdSQTGBMpgC5A7J8oqOmX94DS/NKMsy+ifg3z7n8iR6bxh97w8QrE5AcS8dYAXow62vZj+RibhLIWINLkJzqd/jWavriIZQcr2j0SyPh948LvQT70Bc4Qtyz2efAJQSwECFAAUAAAACAAAACEAtVUwI+wAAABMAgAACwAAAAAAAAABAAAAAAAAAAAAX3JlbHMvLnJlbHNQSwECFAAUAAAACAAAACEA3kEW2XsBAAARAwAAEAAAAAAAAAABAAAAAAAVAQAAZG9jUHJvcHMvYXBwLnhtbFBLAQIUABQAAAAIAOehdkc+qGWw1QAAAG0BAAARAAAAAAAAAAEAIAAAAL4CAABkb2NQcm9wcy9jb3JlLnhtbFBLAQIUABQAAAAAANmhdkcAAAAAAAAAAAAAAAAJAAAAAAAAAAAAEAAAAMIDAAB4bC9fcmVscy9QSwECFAAUAAAACAAAACEAjYfacNoAAAAtAgAAGgAAAAAAAAABAAAAAADpAwAAeGwvX3JlbHMvd29ya2Jvb2sueG1sLnJlbHNQSwECFAAUAAAACAAAACEA3iPy024CAACxBQAADQAAAAAAAAABAAAAAAD7BAAAeGwvc3R5bGVzLnhtbFBLAQIUABQAAAAAANmhdkcAAAAAAAAAAAAAAAAJAAAAAAAAAAAAEAAAAJQHAAB4bC90aGVtZS9QSwECFAAUAAAACAAAACEAi4JuWPUFAACOGgAAEwAAAAAAAAABAAAAAAC7BwAAeGwvdGhlbWUvdGhlbWUxLnhtbFBLAQIUABQAAAAIAAAAIQB8PO7DLgIAAJsEAAAPAAAAAAAAAAEAAAAAAOENAAB4bC93b3JrYm9vay54bWxQSwECFAAUAAAAAADZoXZHAAAAAAAAAAAAAAAADgAAAAAAAAAAABAAAAA8EAAAeGwvd29ya3NoZWV0cy9QSwECFAAUAAAACAAAACEA5lWo410BAACEAgAAGAAAAAAAAAABAAAAAABoEAAAeGwvd29ya3NoZWV0cy9zaGVldDEueG1sUEsBAhQAFAAAAAgAAAAhAKRTxc9BAQAACAQAABMAAAAAAAAAAQAAAAAA+xEAAFtDb250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAwADADoAgAAbRMAAAAA',
        'base64'
      );
      this._initialize(data);
    };
    Workbook.prototype._initialize = function(data) {
      this._zip = new JSZip(data, {
        base64: false,
        checkCRC32: true
      });
      var workbookText = this._zip.file("xl/workbook.xml").asText();
      this._workbookXML = parser.parseFromString(workbookText).documentElement;
      var relsText = this._zip.file("xl/_rels/workbook.xml.rels").asText();
      this._relsXML = parser.parseFromString(relsText).documentElement;
      this._sheets = [];
      this._sheetsNode = xpath("sml:sheets", this._workbookXML)[0];
      var sheetNodes = this._sheetsNode.childNodes;
      for (var i = 0; i < sheetNodes.length; i++) {
        var sheetText = this._zip.file("xl/worksheets/sheet" + (i + 1) + ".xml").asText();
        var sheetXML = parser.parseFromString(sheetText).documentElement;
        var valueNodes = xpath("sml:sheetData/sml:row/sml:c/sml:f/../sml:*[name(.) !='f']", sheetXML);
        valueNodes.forEach(function(valueNode) {
          valueNode.parentNode.removeChild(valueNode);
        });
        var sheet = new Sheet(this, sheetNodes[i], sheetXML);
        this._sheets.push(sheet);
      }
    };
    Workbook.prototype.createSheet = function(sheetName, index) {
      if (index === undefined) index = this._sheets.length;
      if (!utils.isInteger(index) || index < 0 || index > this._sheets.length) {
        throw new Error("Invalid sheet index.");
      }
      var sheetXML = parser.parseFromString('<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><sheetData/></worksheet>').documentElement;
      var sheetNode = parser.parseFromString('<sheet name="' + sheetName + '"/>').documentElement;
      if (index === this._sheets.length) {
        this._sheetsNode.appendChild(sheetNode);
      } else {
        this._sheetsNode.insertBefore(sheetNode, this._sheetsNode.childNodes[index]);
      }
      for (var i = this._relsXML.childNodes.length - 1; i >= 0; i--) {
        var rnode = this._relsXML.childNodes[i];
        if (rnode.getAttribute("Type") === "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet") {
          this._relsXML.removeChild(rnode);
        }
      }
      for (var j = 0; j < this._sheetsNode.childNodes.length; j++) {
        var id = j + 1;
        var snode = this._sheetsNode.childNodes[j];
        snode.setAttribute("sheetId", id);
        snode.setAttribute("r:id", "xpopId" + id);
        var relNode = parser.parseFromString('<Relationship Id="xpopId' + id + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet' + id + '.xml"/>');
        this._relsXML.appendChild(relNode);
      }
      var sheet = new Sheet(this, sheetNode, sheetXML);
      this._sheets.splice(index, 0, sheet);
      return sheet;
    };
    Workbook.prototype.getSheet = function(sheetNameOrIndex) {
      if (utils.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];
      for (var i = 0; i < this._sheets.length; i++) {
        var sheet = this._sheets[i];
        if (sheet.getName() === sheetNameOrIndex) return sheet;
      }
    };
    Workbook.prototype.getNamedCell = function(cellName) {
      var definedName = xpath("sml:definedNames/sml:definedName[@name='" + cellName + "']", this._workbookXML)[0];
      if (!definedName) return;
      var address = definedName.firstChild.nodeValue;
      var ref = utils.addressToRowAndColumn(address);
      if (!ref) return;
      return this.getSheet(ref.sheet).getCell(ref.row, ref.column);
    };
    Workbook.prototype.output = function(options) {
      options = options || {
        'type': 'nodebuffer'
      };
      this._zip.file("xl/workbook.xml", this._workbookXML.toString());
      this._zip.file("xl/_rels/workbook.xml.rels", this._relsXML.toString());
      for (var i = 0; i < this._sheets.length; i++) {
        var index = i + 1;
        var sheet = this._sheets[i];
        this._zip.file("xl/worksheets/sheet" + index + ".xml", sheet._sheetXML.toString());
      }
      this._zip.remove("xl/calcChain.xml");
      return this._zip.generate(options);
    };
    Workbook.prototype.toFile = function(path, cb) {
      fs.writeFile(path, this.output(), cb);
    };
    Workbook.prototype.toFileSync = function(path) {
      fs.writeFileSync(path, this.output());
    };
    Workbook.prototype.toBlob = function() {
      return this.output({
        'type': 'blob',
        'mimeType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      });
    };
    Workbook.fromFile = function(path, cb) {
      var f = function(err, data) {
        cb(err, new Workbook(data));
      };
      if (utils.isBrowser()) {
        JSZipUtils.getBinaryContent(path, f);
      } else {
        fs.readFile(path, f);
      }
    };
    Workbook.fromFileSync = function(path) {
      if (utils.isBrowser()) {
        throw new Error('fromFileSync is unavailable to client-side applications');
      } else {
        var data = fs.readFileSync(path);
        return new Workbook(data);
      }
    };
    module.exports = Workbook;
  }, {
    "./Sheet": 3,
    "./utils": 5,
    "./xpath": 6,
    "buffer": 10,
    "fs": 9,
    "jszip": 25,
    "jszip-utils": 15,
    "path": 57,
    "xmldom": 59
  }],
  5: [function(require, module, exports) {
    (function(process) {
      "use strict";
      var addressRegex = /^\s*(?:'?(.+?)'?\!)?\$?([A-Z]+)\$?(\d+)\s*$/i;
      var dateBase = new Date(1900, 0, 0);
      var incorrectLeapDate = new Date(1900, 1, 28);
      var millisecondsInDay = 1000 * 60 * 60 * 24;
      module.exports = {
        isBrowser: function() {
          return process.browser === true;
        },
        binarySearch: function(targetValue, sortedArray, getComparableValue) {
          getComparableValue = getComparableValue || function(value) {
            return value;
          };
          var getValue = function(index) {
            var item = sortedArray[index];
            if (!item) return undefined;
            return getComparableValue(item);
          };
          var leftIndex = 0;
          var rightIndex = sortedArray.length;
          while (leftIndex <= rightIndex) {
            var middleIndex = Math.floor((leftIndex + rightIndex) / 2);
            var middleValue = getValue(middleIndex);
            if (targetValue < middleValue) {
              rightIndex = middleIndex - 1;
              continue;
            }
            if (targetValue > middleValue) {
              leftIndex = middleIndex + 1;
              continue;
            }
            if (targetValue === middleValue) {
              return {
                found: true,
                index: middleIndex
              };
            }
            break;
          }
          return {
            found: false,
            index: leftIndex
          };
        },
        isInteger: function(value) {
          return value === parseInt(value);
        },
        columnNumberToName: function(number) {
          if (!this.isInteger(number) || number <= 0) return;
          var dividend = number;
          var name = '';
          var modulo = 0;
          while (dividend > 0) {
            modulo = (dividend - 1) % 26;
            name = String.fromCharCode('A'.charCodeAt(0) + modulo) + name;
            dividend = Math.floor((dividend - modulo) / 26);
          }
          return name;
        },
        columnNameToNumber: function(name) {
          if (!name || typeof name !== "string") return;
          name = name.toUpperCase();
          var sum = 0;
          for (var i = 0; i < name.length; i++) {
            sum *= 26;
            sum += name[i].charCodeAt(0) - 'A'.charCodeAt(0) + 1;
          }
          return sum;
        },
        rowAndColumnToAddress: function(row, column, sheet) {
          if (!this.isInteger(row) || !this.isInteger(column) || row <= 0 || column <= 0) return;
          var address = this.columnNumberToName(column) + row;
          if (sheet) address = this.addressToFullAddress(sheet, address);
          return address;
        },
        addressToFullAddress: function(sheet, address) {
          return "'" + sheet + "'!" + address;
        },
        addressToRowAndColumn: function(address) {
          var match = addressRegex.exec(address);
          if (!match) return;
          var ref = {
            row: parseInt(match[3]),
            column: this.columnNameToNumber(match[2])
          };
          if (match[1]) ref.sheet = match[1];
          return ref;
        },
        dateToExcelNumber: function(date) {
          var num = (date - dateBase) / millisecondsInDay;
          if (date > incorrectLeapDate) num += 1;
          return num;
        },
        getNodeType: function(node) {
          return {
            1: 'element',
            2: 'attribute',
            3: 'text',
            8: 'comment',
            9: 'document'
          }[node.nodeType];
        },
        getNodeText: function(node) {
          for (var i = 0; i < node.childNodes.length; i++) {
            if (this.getNodeType(node.childNodes[i]) === 'text') {
              return node.childNodes[i].nodeValue;
            }
          }
          return undefined;
        },
        getNodeInfo: function(node, info) {
          info = info || {};
          info.nodeName = node.nodeName;
          info.nodeType = this.getNodeType(node);
          info.nodeText = this.getNodeText(node);
          info.nodeValue = node.nodeValue;
          return JSON.stringify(info);
        }
      };
    }).call(this, require('_process'))
  }, {
    "_process": 58
  }],
  6: [function(require, module, exports) {
    "use strict";
    var xpath = require('xpath');
    module.exports = xpath.useNamespaces({
      sml: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
    });
  }, {
    "xpath": 62
  }],
  7: [function(require, module, exports) {
    var Workbook = require('./lib/Workbook');
    exports.Workbook = Workbook;
    window.Workbook = Workbook;
    var Sheet = require('./lib/Sheet');
    exports.Sheet = Sheet;
    window.Sheet = Sheet;
    var Row = require('./lib/Row');
    exports.Row = Row;
    window.Row = Row;
    var Cell = require('./lib/Cell');
    exports.Cell = Cell;
    window.Cell = Cell;
  }, {
    "./lib/Cell": 1,
    "./lib/Row": 2,
    "./lib/Sheet": 3,
    "./lib/Workbook": 4
  }],
  8: [function(require, module, exports) {
    'use strict'
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray
    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63

    function placeHoldersCount(b64) {
      var len = b64.length
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
      return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
    }

    function byteLength(b64) {
      return b64.length * 3 / 4 - placeHoldersCount(b64)
    }

    function toByteArray(b64) {
      var i, j, l, tmp, placeHolders, arr
      var len = b64.length
      placeHolders = placeHoldersCount(b64)
      arr = new Arr(len * 3 / 4 - placeHolders)
      l = placeHolders > 0 ? len - 4 : len
      var L = 0
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
        arr[L++] = (tmp >> 16) & 0xFF
        arr[L++] = (tmp >> 8) & 0xFF
        arr[L++] = tmp & 0xFF
      }
      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[L++] = tmp & 0xFF
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[L++] = (tmp >> 8) & 0xFF
        arr[L++] = tmp & 0xFF
      }
      return arr
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk(uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }

    function fromByteArray(uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3
      var output = ''
      var parts = []
      var maxChunkLength = 16383
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        output += lookup[tmp >> 2]
        output += lookup[(tmp << 4) & 0x3F]
        output += '=='
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
        output += lookup[tmp >> 10]
        output += lookup[(tmp >> 4) & 0x3F]
        output += lookup[(tmp << 2) & 0x3F]
        output += '='
      }
      parts.push(output)
      return parts.join('')
    }
  }, {}],
  9: [function(require, module, exports) {}, {}],
  10: [function(require, module, exports) {
    (function(global) {
      'use strict'
      var base64 = require('base64-js')
      var ieee754 = require('ieee754')
      var isArray = require('isarray')
      exports.Buffer = Buffer
      exports.SlowBuffer = SlowBuffer
      exports.INSPECT_MAX_BYTES = 50
      Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ?
        global.TYPED_ARRAY_SUPPORT :
        typedArraySupport()
      exports.kMaxLength = kMaxLength()

      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1)
          arr.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function() {
              return 42
            }
          }
          return arr.foo() === 42 &&
            typeof arr.subarray === 'function' &&
            arr.subarray(1, 1).byteLength === 0
        } catch (e) {
          return false
        }
      }

      function kMaxLength() {
        return Buffer.TYPED_ARRAY_SUPPORT ?
          0x7fffffff :
          0x3fffffff
      }

      function createBuffer(that, length) {
        if (kMaxLength() < length) {
          throw new RangeError('Invalid typed array length')
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length)
          that.__proto__ = Buffer.prototype
        } else {
          if (that === null) {
            that = new Buffer(length)
          }
          that.length = length
        }
        return that
      }

      function Buffer(arg, encodingOrOffset, length) {
        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
          return new Buffer(arg, encodingOrOffset, length)
        }
        if (typeof arg === 'number') {
          if (typeof encodingOrOffset === 'string') {
            throw new Error(
              'If encoding is specified then the first argument must be a string'
            )
          }
          return allocUnsafe(this, arg)
        }
        return from(this, arg, encodingOrOffset, length)
      }
      Buffer.poolSize = 8192
      Buffer._augment = function(arr) {
        arr.__proto__ = Buffer.prototype
        return arr
      }

      function from(that, value, encodingOrOffset, length) {
        if (typeof value === 'number') {
          throw new TypeError('"value" argument must not be a number')
        }
        if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length)
        }
        if (typeof value === 'string') {
          return fromString(that, value, encodingOrOffset)
        }
        return fromObject(that, value)
      }
      Buffer.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length)
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array
        if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer[Symbol.species] === Buffer) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true
          })
        }
      }

      function assertSize(size) {
        if (typeof size !== 'number') {
          throw new TypeError('"size" argument must be a number')
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative')
        }
      }

      function alloc(that, size, fill, encoding) {
        assertSize(size)
        if (size <= 0) {
          return createBuffer(that, size)
        }
        if (fill !== undefined) {
          return typeof encoding === 'string' ?
            createBuffer(that, size).fill(fill, encoding) :
            createBuffer(that, size).fill(fill)
        }
        return createBuffer(that, size)
      }
      Buffer.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding)
      }

      function allocUnsafe(that, size) {
        assertSize(size)
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
        if (!Buffer.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0
          }
        }
        return that
      }
      Buffer.allocUnsafe = function(size) {
        return allocUnsafe(null, size)
      }
      Buffer.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size)
      }

      function fromString(that, string, encoding) {
        if (typeof encoding !== 'string' || encoding === '') {
          encoding = 'utf8'
        }
        if (!Buffer.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding')
        }
        var length = byteLength(string, encoding) | 0
        that = createBuffer(that, length)
        var actual = that.write(string, encoding)
        if (actual !== length) {
          that = that.slice(0, actual)
        }
        return that
      }

      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0
        that = createBuffer(that, length)
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255
        }
        return that
      }

      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('\'offset\' is out of bounds')
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('\'length\' is out of bounds')
        }
        if (byteOffset === undefined && length === undefined) {
          array = new Uint8Array(array)
        } else if (length === undefined) {
          array = new Uint8Array(array, byteOffset)
        } else {
          array = new Uint8Array(array, byteOffset, length)
        }
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          that = array
          that.__proto__ = Buffer.prototype
        } else {
          that = fromArrayLike(that, array)
        }
        return that
      }

      function fromObject(that, obj) {
        if (Buffer.isBuffer(obj)) {
          var len = checked(obj.length) | 0
          that = createBuffer(that, len)
          if (that.length === 0) {
            return that
          }
          obj.copy(that, 0, 0, len)
          return that
        }
        if (obj) {
          if ((typeof ArrayBuffer !== 'undefined' &&
              obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
            if (typeof obj.length !== 'number' || isnan(obj.length)) {
              return createBuffer(that, 0)
            }
            return fromArrayLike(that, obj)
          }
          if (obj.type === 'Buffer' && isArray(obj.data)) {
            return fromArrayLike(that, obj.data)
          }
        }
        throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
      }

      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
            'size: 0x' + kMaxLength().toString(16) + ' bytes')
        }
        return length | 0
      }

      function SlowBuffer(length) {
        if (+length != length) {
          length = 0
        }
        return Buffer.alloc(+length)
      }
      Buffer.isBuffer = function isBuffer(b) {
        return !!(b != null && b._isBuffer)
      }
      Buffer.compare = function compare(a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
          throw new TypeError('Arguments must be Buffers')
        }
        if (a === b) return 0
        var x = a.length
        var y = b.length
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i]
            y = b[i]
            break
          }
        }
        if (x < y) return -1
        if (y < x) return 1
        return 0
      }
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'latin1':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true
          default:
            return false
        }
      }
      Buffer.concat = function concat(list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        if (list.length === 0) {
          return Buffer.alloc(0)
        }
        var i
        if (length === undefined) {
          length = 0
          for (i = 0; i < list.length; ++i) {
            length += list[i].length
          }
        }
        var buffer = Buffer.allocUnsafe(length)
        var pos = 0
        for (i = 0; i < list.length; ++i) {
          var buf = list[i]
          if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }
          buf.copy(buffer, pos)
          pos += buf.length
        }
        return buffer
      }

      function byteLength(string, encoding) {
        if (Buffer.isBuffer(string)) {
          return string.length
        }
        if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength
        }
        if (typeof string !== 'string') {
          string = '' + string
        }
        var len = string.length
        if (len === 0) return 0
        var loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return len
            case 'utf8':
            case 'utf-8':
            case undefined:
              return utf8ToBytes(string).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2
            case 'hex':
              return len >>> 1
            case 'base64':
              return base64ToBytes(string).length
            default:
              if (loweredCase) return utf8ToBytes(string).length
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }
      Buffer.byteLength = byteLength

      function slowToString(encoding, start, end) {
        var loweredCase = false
        if (start === undefined || start < 0) {
          start = 0
        }
        if (start > this.length) {
          return ''
        }
        if (end === undefined || end > this.length) {
          end = this.length
        }
        if (end <= 0) {
          return ''
        }
        end >>>= 0
        start >>>= 0
        if (end <= start) {
          return ''
        }
        if (!encoding) encoding = 'utf8'
        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end)
            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end)
            case 'ascii':
              return asciiSlice(this, start, end)
            case 'latin1':
            case 'binary':
              return latin1Slice(this, start, end)
            case 'base64':
              return base64Slice(this, start, end)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end)
            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = (encoding + '').toLowerCase()
              loweredCase = true
          }
        }
      }
      Buffer.prototype._isBuffer = true

      function swap(b, n, m) {
        var i = b[n]
        b[n] = b[m]
        b[m] = i
      }
      Buffer.prototype.swap16 = function swap16() {
        var len = this.length
        if (len % 2 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 16-bits')
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1)
        }
        return this
      }
      Buffer.prototype.swap32 = function swap32() {
        var len = this.length
        if (len % 4 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 32-bits')
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3)
          swap(this, i + 1, i + 2)
        }
        return this
      }
      Buffer.prototype.swap64 = function swap64() {
        var len = this.length
        if (len % 8 !== 0) {
          throw new RangeError('Buffer size must be a multiple of 64-bits')
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7)
          swap(this, i + 1, i + 6)
          swap(this, i + 2, i + 5)
          swap(this, i + 3, i + 4)
        }
        return this
      }
      Buffer.prototype.toString = function toString() {
        var length = this.length | 0
        if (length === 0) return ''
        if (arguments.length === 0) return utf8Slice(this, 0, length)
        return slowToString.apply(this, arguments)
      }
      Buffer.prototype.equals = function equals(b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
        if (this === b) return true
        return Buffer.compare(this, b) === 0
      }
      Buffer.prototype.inspect = function inspect() {
        var str = ''
        var max = exports.INSPECT_MAX_BYTES
        if (this.length > 0) {
          str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
          if (this.length > max) str += ' ... '
        }
        return '<Buffer ' + str + '>'
      }
      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (!Buffer.isBuffer(target)) {
          throw new TypeError('Argument must be a Buffer')
        }
        if (start === undefined) {
          start = 0
        }
        if (end === undefined) {
          end = target ? target.length : 0
        }
        if (thisStart === undefined) {
          thisStart = 0
        }
        if (thisEnd === undefined) {
          thisEnd = this.length
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError('out of range index')
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0
        }
        if (thisStart >= thisEnd) {
          return -1
        }
        if (start >= end) {
          return 1
        }
        start >>>= 0
        end >>>= 0
        thisStart >>>= 0
        thisEnd >>>= 0
        if (this === target) return 0
        var x = thisEnd - thisStart
        var y = end - start
        var len = Math.min(x, y)
        var thisCopy = this.slice(thisStart, thisEnd)
        var targetCopy = target.slice(start, end)
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i]
            y = targetCopy[i]
            break
          }
        }
        if (x < y) return -1
        if (y < x) return 1
        return 0
      }

      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1
        if (typeof byteOffset === 'string') {
          encoding = byteOffset
          byteOffset = 0
        } else if (byteOffset > 0x7fffffff) {
          byteOffset = 0x7fffffff
        } else if (byteOffset < -0x80000000) {
          byteOffset = -0x80000000
        }
        byteOffset = +byteOffset
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : (buffer.length - 1)
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset
        if (byteOffset >= buffer.length) {
          if (dir) return -1
          else byteOffset = buffer.length - 1
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0
          else return -1
        }
        if (typeof val === 'string') {
          val = Buffer.from(val, encoding)
        }
        if (Buffer.isBuffer(val)) {
          if (val.length === 0) {
            return -1
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
        } else if (typeof val === 'number') {
          val = val & 0xFF
          if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
        }
        throw new TypeError('val must be string, number or Buffer')
      }

      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1
        var arrLength = arr.length
        var valLength = val.length
        if (encoding !== undefined) {
          encoding = String(encoding).toLowerCase()
          if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
              return -1
            }
            indexSize = 2
            arrLength /= 2
            valLength /= 2
            byteOffset /= 2
          }
        }

        function read(buf, i) {
          if (indexSize === 1) {
            return buf[i]
          } else {
            return buf.readUInt16BE(i * indexSize)
          }
        }
        var i
        if (dir) {
          var foundIndex = -1
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
            } else {
              if (foundIndex !== -1) i -= i - foundIndex
              foundIndex = -1
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
          for (i = byteOffset; i >= 0; i--) {
            var found = true
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false
                break
              }
            }
            if (found) return i
          }
        }
        return -1
      }
      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1
      }
      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
      }
      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
      }

      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0
        var remaining = buf.length - offset
        if (!length) {
          length = remaining
        } else {
          length = Number(length)
          if (length > remaining) {
            length = remaining
          }
        }
        var strLen = string.length
        if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
        if (length > strLen / 2) {
          length = strLen / 2
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16)
          if (isNaN(parsed)) return i
          buf[offset + i] = parsed
        }
        return i
      }

      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
      }

      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length)
      }

      function latin1Write(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
      }

      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length)
      }

      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
      }
      Buffer.prototype.write = function write(string, offset, length, encoding) {
        if (offset === undefined) {
          encoding = 'utf8'
          length = this.length
          offset = 0
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset
          length = this.length
          offset = 0
        } else if (isFinite(offset)) {
          offset = offset | 0
          if (isFinite(length)) {
            length = length | 0
            if (encoding === undefined) encoding = 'utf8'
          } else {
            encoding = length
            length = undefined
          }
        } else {
          throw new Error(
            'Buffer.write(string, encoding, offset[, length]) is no longer supported'
          )
        }
        var remaining = this.length - offset
        if (length === undefined || length > remaining) length = remaining
        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
          throw new RangeError('Attempt to write outside buffer bounds')
        }
        if (!encoding) encoding = 'utf8'
        var loweredCase = false
        for (;;) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length)
            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length)
            case 'ascii':
              return asciiWrite(this, string, offset, length)
            case 'latin1':
            case 'binary':
              return latin1Write(this, string, offset, length)
            case 'base64':
              return base64Write(this, string, offset, length)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length)
            default:
              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
              encoding = ('' + encoding).toLowerCase()
              loweredCase = true
          }
        }
      }
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      }

      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf)
        } else {
          return base64.fromByteArray(buf.slice(start, end))
        }
      }

      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end)
        var res = []
        var i = start
        while (i < end) {
          var firstByte = buf[i]
          var codePoint = null
          var bytesPerSequence = (firstByte > 0xEF) ? 4 :
            (firstByte > 0xDF) ? 3 :
            (firstByte > 0xBF) ? 2 :
            1
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte
                }
                break
              case 2:
                secondByte = buf[i + 1]
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 3:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint
                  }
                }
                break
              case 4:
                secondByte = buf[i + 1]
                thirdByte = buf[i + 2]
                fourthByte = buf[i + 3]
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 0xFFFD
            bytesPerSequence = 1
          } else if (codePoint > 0xFFFF) {
            codePoint -= 0x10000
            res.push(codePoint >>> 10 & 0x3FF | 0xD800)
            codePoint = 0xDC00 | codePoint & 0x3FF
          }
          res.push(codePoint)
          i += bytesPerSequence
        }
        return decodeCodePointsArray(res)
      }
      var MAX_ARGUMENTS_LENGTH = 0x1000

      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints)
        }
        var res = ''
        var i = 0
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          )
        }
        return res
      }

      function asciiSlice(buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 0x7F)
        }
        return ret
      }

      function latin1Slice(buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i])
        }
        return ret
      }

      function hexSlice(buf, start, end) {
        var len = buf.length
        if (!start || start < 0) start = 0
        if (!end || end < 0 || end > len) end = len
        var out = ''
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i])
        }
        return out
      }

      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end)
        var res = ''
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
        }
        return res
      }
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length
        start = ~~start
        end = end === undefined ? len : ~~end
        if (start < 0) {
          start += len
          if (start < 0) start = 0
        } else if (start > len) {
          start = len
        }
        if (end < 0) {
          end += len
          if (end < 0) end = 0
        } else if (end > len) {
          end = len
        }
        if (end < start) end = start
        var newBuf
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end)
          newBuf.__proto__ = Buffer.prototype
        } else {
          var sliceLen = end - start
          newBuf = new Buffer(sliceLen, undefined)
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start]
          }
        }
        return newBuf
      }

      function checkOffset(offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
      }
      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)
        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }
        return val
      }
      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length)
        }
        var val = this[offset + --byteLength]
        var mul = 1
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul
        }
        return val
      }
      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length)
        return this[offset]
      }
      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        return this[offset] | (this[offset + 1] << 8)
      }
      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        return (this[offset] << 8) | this[offset + 1]
      }
      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
      }
      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return (this[offset] * 0x1000000) +
          ((this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3])
      }
      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)
        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul
        }
        mul *= 0x80
        if (val >= mul) val -= Math.pow(2, 8 * byteLength)
        return val
      }
      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) checkOffset(offset, byteLength, this.length)
        var i = byteLength
        var mul = 1
        var val = this[offset + --i]
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul
        }
        mul *= 0x80
        if (val >= mul) val -= Math.pow(2, 8 * byteLength)
        return val
      }
      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 1, this.length)
        if (!(this[offset] & 0x80)) return (this[offset])
        return ((0xff - this[offset] + 1) * -1)
      }
      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        var val = this[offset] | (this[offset + 1] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }
      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 2, this.length)
        var val = this[offset + 1] | (this[offset] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
      }
      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return (this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16) |
          (this[offset + 3] << 24)
      }
      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return (this[offset] << 24) |
          (this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          (this[offset + 3])
      }
      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, true, 23, 4)
      }
      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, false, 23, 4)
      }
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, true, 52, 8)
      }
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert) checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, false, 52, 8)
      }

      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
      }
      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }
        var mul = 1
        var i = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }
        return offset + byteLength
      }
      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        byteLength = byteLength | 0
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1
          checkInt(this, value, offset, byteLength, maxBytes, 0)
        }
        var i = byteLength - 1
        var mul = 1
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF
        }
        return offset + byteLength
      }
      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        this[offset] = (value & 0xff)
        return offset + 1
      }

      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
        }
      }
      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
        } else {
          objectWriteUInt16(this, value, offset, true)
        }
        return offset + 2
      }
      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
        } else {
          objectWriteUInt16(this, value, offset, false)
        }
        return offset + 2
      }

      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffffffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
        }
      }
      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = (value >>> 24)
          this[offset + 2] = (value >>> 16)
          this[offset + 1] = (value >>> 8)
          this[offset] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, true)
        }
        return offset + 4
      }
      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, false)
        }
        return offset + 4
      }
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1)
          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }
        var i = 0
        var mul = 1
        var sub = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }
        return offset + byteLength
      }
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1)
          checkInt(this, value, offset, byteLength, limit - 1, -limit)
        }
        var i = byteLength - 1
        var mul = 1
        var sub = 0
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1
          }
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
        }
        return offset + byteLength
      }
      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        if (value < 0) value = 0xff + value + 1
        this[offset] = (value & 0xff)
        return offset + 1
      }
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
        } else {
          objectWriteUInt16(this, value, offset, true)
        }
        return offset + 2
      }
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
        } else {
          objectWriteUInt16(this, value, offset, false)
        }
        return offset + 2
      }
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          this[offset + 2] = (value >>> 16)
          this[offset + 3] = (value >>> 24)
        } else {
          objectWriteUInt32(this, value, offset, true)
        }
        return offset + 4
      }
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value
        offset = offset | 0
        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (value < 0) value = 0xffffffff + value + 1
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
        } else {
          objectWriteUInt32(this, value, offset, false)
        }
        return offset + 4
      }

      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError('Index out of range')
        if (offset < 0) throw new RangeError('Index out of range')
      }

      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4)
        return offset + 4
      }
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
      }
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
      }

      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8)
        return offset + 8
      }
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
      }
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
      }
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start) start = 0
        if (!end && end !== 0) end = this.length
        if (targetStart >= target.length) targetStart = target.length
        if (!targetStart) targetStart = 0
        if (end > 0 && end < start) end = start
        if (end === start) return 0
        if (target.length === 0 || this.length === 0) return 0
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds')
        }
        if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
        if (end < 0) throw new RangeError('sourceEnd out of bounds')
        if (end > this.length) end = this.length
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start
        }
        var len = end - start
        var i
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start]
          }
        } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start]
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          )
        }
        return len
      }
      Buffer.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === 'string') {
          if (typeof start === 'string') {
            encoding = start
            start = 0
            end = this.length
          } else if (typeof end === 'string') {
            encoding = end
            end = this.length
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0)
            if (code < 256) {
              val = code
            }
          }
          if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string')
          }
          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }
        } else if (typeof val === 'number') {
          val = val & 255
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError('Out of range index')
        }
        if (end <= start) {
          return this
        }
        start = start >>> 0
        end = end === undefined ? this.length : end >>> 0
        if (!val) val = 0
        var i
        if (typeof val === 'number') {
          for (i = start; i < end; ++i) {
            this[i] = val
          }
        } else {
          var bytes = Buffer.isBuffer(val) ?
            val :
            utf8ToBytes(new Buffer(val, encoding).toString())
          var len = bytes.length
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len]
          }
        }
        return this
      }
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, '')
        if (str.length < 2) return ''
        while (str.length % 4 !== 0) {
          str = str + '='
        }
        return str
      }

      function stringtrim(str) {
        if (str.trim) return str.trim()
        return str.replace(/^\s+|\s+$/g, '')
      }

      function toHex(n) {
        if (n < 16) return '0' + n.toString(16)
        return n.toString(16)
      }

      function utf8ToBytes(string, units) {
        units = units || Infinity
        var codePoint
        var length = string.length
        var leadSurrogate = null
        var bytes = []
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i)
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
            if (!leadSurrogate) {
              if (codePoint > 0xDBFF) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                continue
              }
              leadSurrogate = codePoint
              continue
            }
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              leadSurrogate = codePoint
              continue
            }
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          }
          leadSurrogate = null
          if (codePoint < 0x80) {
            if ((units -= 1) < 0) break
            bytes.push(codePoint)
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break
            bytes.push(
              codePoint >> 0x6 | 0xC0,
              codePoint & 0x3F | 0x80
            )
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break
            bytes.push(
              codePoint >> 0xC | 0xE0,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            )
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break
            bytes.push(
              codePoint >> 0x12 | 0xF0,
              codePoint >> 0xC & 0x3F | 0x80,
              codePoint >> 0x6 & 0x3F | 0x80,
              codePoint & 0x3F | 0x80
            )
          } else {
            throw new Error('Invalid code point')
          }
        }
        return bytes
      }

      function asciiToBytes(str) {
        var byteArray = []
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 0xFF)
        }
        return byteArray
      }

      function utf16leToBytes(str, units) {
        var c, hi, lo
        var byteArray = []
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break
          c = str.charCodeAt(i)
          hi = c >> 8
          lo = c % 256
          byteArray.push(lo)
          byteArray.push(hi)
        }
        return byteArray
      }

      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str))
      }

      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if ((i + offset >= dst.length) || (i >= src.length)) break
          dst[i + offset] = src[i]
        }
        return i
      }

      function isnan(val) {
        return val !== val
      }
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, {
    "base64-js": 8,
    "ieee754": 13,
    "isarray": 14
  }],
  11: [function(require, module, exports) {
    (function(process) {
      exports = module.exports = require('./debug');
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = 'undefined' != typeof chrome &&
        'undefined' != typeof chrome.storage ?
        chrome.storage.local :
        localstorage();
      exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
      ];

      function useColors() {
        if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
          return true;
        }
        return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
          (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
          (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
          (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
      }
      exports.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return '[UnexpectedJSONParseError]: ' + err.message;
        }
      };

      function formatArgs(args) {
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '') +
          this.namespace +
          (useColors ? ' %c' : ' ') +
          args[0] +
          (useColors ? '%c ' : ' ') +
          '+' + exports.humanize(this.diff);
        if (!useColors) return;
        var c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit')
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
          if ('%%' === match) return;
          index++;
          if ('%c' === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }

      function log() {
        return 'object' === typeof console &&
          console.log &&
          Function.prototype.apply.call(console.log, console, arguments);
      }

      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem('debug');
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }

      function load() {
        try {
          return exports.storage.debug;
        } catch (e) {}
        if (typeof process !== 'undefined' && 'env' in process) {
          return process.env.DEBUG;
        }
      }
      exports.enable(load());

      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }).call(this, require('_process'))
  }, {
    "./debug": 12,
    "_process": 58
  }],
  12: [function(require, module, exports) {
    exports = module.exports = createDebug.debug = createDebug.default = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require('ms');
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;

    function selectColor(namespace) {
      var hash = 0,
        i;
      for (i in namespace) {
        hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled) return;
        var self = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          args.unshift('%O');
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }
      return debug;
    }

    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    function disable() {
      exports.enable('');
    }

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }, {
    "ms": 40
  }],
  13: [function(require, module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
      i += d
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
      value = Math.abs(value)
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
      buffer[offset + i - d] |= s * 128
    }
  }, {}],
  14: [function(require, module, exports) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == '[object Array]';
    };
  }, {}],
  15: [function(require, module, exports) {
    'use strict';
    var JSZipUtils = {};
    JSZipUtils._getBinaryFromXHR = function(xhr) {
      return xhr.response || xhr.responseText;
    };

    function createStandardXHR() {
      try {
        return new window.XMLHttpRequest();
      } catch (e) {}
    }

    function createActiveXHR() {
      try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
      } catch (e) {}
    }
    var createXHR = window.ActiveXObject ?
      function() {
        return createStandardXHR() || createActiveXHR();
      } :
      createStandardXHR;
    JSZipUtils.getBinaryContent = function(path, callback) {
      try {
        var xhr = createXHR();
        xhr.open('GET', path, true);
        if ("responseType" in xhr) {
          xhr.responseType = "arraybuffer";
        }
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }
        xhr.onreadystatechange = function(evt) {
          var file, err;
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              file = null;
              err = null;
              try {
                file = JSZipUtils._getBinaryFromXHR(xhr);
              } catch (e) {
                err = new Error(e);
              }
              callback(err, file);
            } else {
              callback(new Error("Ajax error for " + path + " : " + this.status + " " + this.statusText), null);
            }
          }
        };
        xhr.send();
      } catch (e) {
        callback(new Error(e), null);
      }
    };
    module.exports = JSZipUtils;
  }, {}],
  16: [function(require, module, exports) {
    'use strict';
    var DataReader = require('./dataReader');

    function ArrayReader(data) {
      if (data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
        for (var i = 0; i < this.data.length; i++) {
          data[i] = data[i] & 0xFF;
        }
      }
    }
    ArrayReader.prototype = new DataReader();
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = ArrayReader;
  }, {
    "./dataReader": 21
  }],
  17: [function(require, module, exports) {
    'use strict';
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports.encode = function(input, utf8) {
      var output = "";
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
      }
      return output;
    };
    exports.decode = function(input, utf8) {
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output = output + String.fromCharCode(chr1);
        if (enc3 != 64) {
          output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
          output = output + String.fromCharCode(chr3);
        }
      }
      return output;
    };
  }, {}],
  18: [function(require, module, exports) {
    'use strict';

    function CompressedObject() {
      this.compressedSize = 0;
      this.uncompressedSize = 0;
      this.crc32 = 0;
      this.compressionMethod = null;
      this.compressedContent = null;
    }
    CompressedObject.prototype = {
      getContent: function() {
        return null;
      },
      getCompressedContent: function() {
        return null;
      }
    };
    module.exports = CompressedObject;
  }, {}],
  19: [function(require, module, exports) {
    'use strict';
    exports.STORE = {
      magic: "\x00\x00",
      compress: function(content, compressionOptions) {
        return content;
      },
      uncompress: function(content) {
        return content;
      },
      compressInputType: null,
      uncompressInputType: null
    };
    exports.DEFLATE = require('./flate');
  }, {
    "./flate": 24
  }],
  20: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');
    var table = [
      0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
      0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
      0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
      0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
      0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
      0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
      0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
      0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
      0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
      0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
      0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
      0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
      0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
      0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
      0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
      0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
      0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
      0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
      0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
      0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
      0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
      0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
      0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
      0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
      0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
      0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
      0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
      0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
      0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
      0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
      0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
      0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
      0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
      0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
      0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
      0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
      0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
      0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
      0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
      0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
      0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
      0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
      0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
      0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
      0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
      0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
      0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
      0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
      0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
      0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
      0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
      0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
      0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
      0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
      0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
      0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
      0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
      0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
      0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
      0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
      0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
      0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
      0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
      0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    ];
    module.exports = function crc32(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (typeof(crc) == "undefined") {
        crc = 0;
      }
      var x = 0;
      var y = 0;
      var b = 0;
      crc = crc ^ (-1);
      for (var i = 0, iTop = input.length; i < iTop; i++) {
        b = isArray ? input[i] : input.charCodeAt(i);
        y = (crc ^ b) & 0xFF;
        x = table[y];
        crc = (crc >>> 8) ^ x;
      }
      return crc ^ (-1);
    };
  }, {
    "./utils": 37
  }],
  21: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');

    function DataReader(data) {
      this.data = null;
      this.length = 0;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
      },
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      byteAt: function(i) {},
      readInt: function(size) {
        var result = 0,
          i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      readString: function(size) {
        return utils.transformTo("string", this.readData(size));
      },
      readData: function(size) {},
      lastIndexOfSignature: function(sig) {},
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(
          ((dostime >> 25) & 0x7f) + 1980,
          ((dostime >> 21) & 0x0f) - 1,
          (dostime >> 16) & 0x1f,
          (dostime >> 11) & 0x1f,
          (dostime >> 5) & 0x3f,
          (dostime & 0x1f) << 1);
      }
    };
    module.exports = DataReader;
  }, {
    "./utils": 37
  }],
  22: [function(require, module, exports) {
    'use strict';
    exports.base64 = false;
    exports.binary = false;
    exports.dir = false;
    exports.createFolders = false;
    exports.date = null;
    exports.compression = null;
    exports.compressionOptions = null;
    exports.comment = null;
    exports.unixPermissions = null;
    exports.dosPermissions = null;
  }, {}],
  23: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');
    exports.string2binary = function(str) {
      return utils.string2binary(str);
    };
    exports.string2Uint8Array = function(str) {
      return utils.transformTo("uint8array", str);
    };
    exports.uint8Array2String = function(array) {
      return utils.transformTo("string", array);
    };
    exports.string2Blob = function(str) {
      var buffer = utils.transformTo("arraybuffer", str);
      return utils.arrayBuffer2Blob(buffer);
    };
    exports.arrayBuffer2Blob = function(buffer) {
      return utils.arrayBuffer2Blob(buffer);
    };
    exports.transformTo = function(outputType, input) {
      return utils.transformTo(outputType, input);
    };
    exports.getTypeOf = function(input) {
      return utils.getTypeOf(input);
    };
    exports.checkSupport = function(type) {
      return utils.checkSupport(type);
    };
    exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
    exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
    exports.pretty = function(str) {
      return utils.pretty(str);
    };
    exports.findCompression = function(compressionMethod) {
      return utils.findCompression(compressionMethod);
    };
    exports.isRegExp = function(object) {
      return utils.isRegExp(object);
    };
  }, {
    "./utils": 37
  }],
  24: [function(require, module, exports) {
    'use strict';
    var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');
    var pako = require("pako");
    exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.magic = "\x08\x00";
    exports.compress = function(input, compressionOptions) {
      return pako.deflateRaw(input, {
        level: compressionOptions.level || -1
      });
    };
    exports.uncompress = function(input) {
      return pako.inflateRaw(input);
    };
  }, {
    "pako": 41
  }],
  25: [function(require, module, exports) {
    'use strict';
    var base64 = require('./base64');

    function JSZip(data, options) {
      if (!(this instanceof JSZip)) return new JSZip(data, options);
      this.files = {};
      this.comment = null;
      this.root = "";
      if (data) {
        this.load(data, options);
      }
      this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip.prototype = require('./object');
    JSZip.prototype.load = require('./load');
    JSZip.support = require('./support');
    JSZip.defaults = require('./defaults');
    JSZip.utils = require('./deprecatedPublicUtils');
    JSZip.base64 = {
      encode: function(input) {
        return base64.encode(input);
      },
      decode: function(input) {
        return base64.decode(input);
      }
    };
    JSZip.compressions = require('./compressions');
    module.exports = JSZip;
  }, {
    "./base64": 17,
    "./compressions": 19,
    "./defaults": 22,
    "./deprecatedPublicUtils": 23,
    "./load": 26,
    "./object": 29,
    "./support": 33
  }],
  26: [function(require, module, exports) {
    'use strict';
    var base64 = require('./base64');
    var utf8 = require('./utf8');
    var utils = require('./utils');
    var ZipEntries = require('./zipEntries');
    module.exports = function(data, options) {
      var files, zipEntries, i, input;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (options.base64) {
        data = base64.decode(data);
      }
      zipEntries = new ZipEntries(data, options);
      files = zipEntries.files;
      for (i = 0; i < files.length; i++) {
        input = files[i];
        this.file(input.fileNameStr, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
      }
      if (zipEntries.zipComment.length) {
        this.comment = zipEntries.zipComment;
      }
      return this;
    };
  }, {
    "./base64": 17,
    "./utf8": 36,
    "./utils": 37,
    "./zipEntries": 38
  }],
  27: [function(require, module, exports) {
    (function(Buffer) {
      'use strict';
      module.exports = function(data, encoding) {
        return new Buffer(data, encoding);
      };
      module.exports.test = function(b) {
        return Buffer.isBuffer(b);
      };
    }).call(this, require("buffer").Buffer)
  }, {
    "buffer": 10
  }],
  28: [function(require, module, exports) {
    'use strict';
    var Uint8ArrayReader = require('./uint8ArrayReader');

    function NodeBufferReader(data) {
      this.data = data;
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    NodeBufferReader.prototype = new Uint8ArrayReader();
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = NodeBufferReader;
  }, {
    "./uint8ArrayReader": 34
  }],
  29: [function(require, module, exports) {
    'use strict';
    var support = require('./support');
    var utils = require('./utils');
    var crc32 = require('./crc32');
    var signature = require('./signature');
    var defaults = require('./defaults');
    var base64 = require('./base64');
    var compressions = require('./compressions');
    var CompressedObject = require('./compressedObject');
    var nodeBuffer = require('./nodeBuffer');
    var utf8 = require('./utf8');
    var StringWriter = require('./stringWriter');
    var Uint8ArrayWriter = require('./uint8ArrayWriter');
    var getRawData = function(file) {
      if (file._data instanceof CompressedObject) {
        file._data = file._data.getContent();
        file.options.binary = true;
        file.options.base64 = false;
        if (utils.getTypeOf(file._data) === "uint8array") {
          var copy = file._data;
          file._data = new Uint8Array(copy.length);
          if (copy.length !== 0) {
            file._data.set(copy, 0);
          }
        }
      }
      return file._data;
    };
    var getBinaryData = function(file) {
      var result = getRawData(file),
        type = utils.getTypeOf(result);
      if (type === "string") {
        if (!file.options.binary) {
          if (support.nodebuffer) {
            return nodeBuffer(result, "utf-8");
          }
        }
        return file.asBinary();
      }
      return result;
    };
    var dataToString = function(asUTF8) {
      var result = getRawData(this);
      if (result === null || typeof result === "undefined") {
        return "";
      }
      if (this.options.base64) {
        result = base64.decode(result);
      }
      if (asUTF8 && this.options.binary) {
        result = out.utf8decode(result);
      } else {
        result = utils.transformTo("string", result);
      }
      if (!asUTF8 && !this.options.binary) {
        result = utils.transformTo("string", out.utf8encode(result));
      }
      return result;
    };
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this.options = options;
      this._initialMetadata = {
        dir: options.dir,
        date: options.date
      };
    };
    ZipObject.prototype = {
      asText: function() {
        return dataToString.call(this, true);
      },
      asBinary: function() {
        return dataToString.call(this, false);
      },
      asNodeBuffer: function() {
        var result = getBinaryData(this);
        return utils.transformTo("nodebuffer", result);
      },
      asUint8Array: function() {
        var result = getBinaryData(this);
        return utils.transformTo("uint8array", result);
      },
      asArrayBuffer: function() {
        return this.asUint8Array().buffer;
      }
    };
    var decToHex = function(dec, bytes) {
      var hex = "",
        i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
      }
      return hex;
    };
    var prepareFileAttrs = function(o) {
      o = o || {};
      if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
        o.binary = true;
      }
      o = utils.extend(o, defaults);
      o.date = o.date || new Date();
      if (o.compression !== null) o.compression = o.compression.toUpperCase();
      return o;
    };
    var fileAdd = function(name, data, o) {
      var dataType = utils.getTypeOf(data),
        parent;
      o = prepareFileAttrs(o);
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
      }
      if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      if (o.dir || data === null || typeof data === "undefined") {
        o.base64 = false;
        o.binary = false;
        data = null;
        dataType = null;
      } else if (dataType === "string") {
        if (o.binary && !o.base64) {
          if (o.optimizedBinaryString !== true) {
            data = utils.string2binary(data);
          }
        }
      } else {
        o.base64 = false;
        o.binary = true;
        if (!dataType && !(data instanceof CompressedObject)) {
          throw new Error("The data of '" + name + "' is in an unsupported format !");
        }
        if (dataType === "arraybuffer") {
          data = utils.transformTo("uint8array", data);
        }
      }
      var object = new ZipObject(name, data, o);
      this.files[name] = object;
      return object;
    };
    var parentFolder = function(path) {
      if (path.slice(-1) == '/') {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf('/');
      return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path) {
      if (path.slice(-1) != "/") {
        path += "/";
      }
      return path;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders: createFolders
        });
      }
      return this.files[name];
    };
    var generateCompressedObjectFrom = function(file, compression, compressionOptions) {
      var result = new CompressedObject(),
        content;
      if (file._data instanceof CompressedObject) {
        result.uncompressedSize = file._data.uncompressedSize;
        result.crc32 = file._data.crc32;
        if (result.uncompressedSize === 0 || file.dir) {
          compression = compressions['STORE'];
          result.compressedContent = "";
          result.crc32 = 0;
        } else if (file._data.compressionMethod === compression.magic) {
          result.compressedContent = file._data.getCompressedContent();
        } else {
          content = file._data.getContent();
          result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
        }
      } else {
        content = getBinaryData(file);
        if (!content || content.length === 0 || file.dir) {
          compression = compressions['STORE'];
          content = "";
        }
        result.uncompressedSize = content.length;
        result.crc32 = crc32(content);
        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
      }
      result.compressedSize = result.compressedContent.length;
      result.compressionMethod = compression.magic;
      return result;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 0x41fd : 0x81b4;
      }
      return (result & 0xFFFF) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions, isDir) {
      return (dosPermissions || 0) & 0x3F;
    };
    var generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {
      var data = compressedObject.compressedContent,
        useCustomEncoding = encodeFileName !== utf8.utf8encode,
        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
        comment = file.comment || "",
        encodedComment = utils.transformTo("string", encodeFileName(comment)),
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
        useUTF8ForComment = utfEncodedComment.length !== comment.length,
        o = file.options,
        dosTime,
        dosDate,
        extraFields = "",
        unicodePathExtraField = "",
        unicodeCommentExtraField = "",
        dir, date;
      if (file._initialMetadata.dir !== file.dir) {
        dir = file.dir;
      } else {
        dir = o.dir;
      }
      if (file._initialMetadata.date !== file.date) {
        date = file.date;
      } else {
        date = o.date;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 0x00010;
      }
      if (platform === "UNIX") {
        versionMadeBy = 0x031E;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 0x0014;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getSeconds() / 2;
      dosDate = date.getFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | (date.getMonth() + 1);
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField =
          decToHex(1, 1) +
          decToHex(crc32(encodedFileName), 4) +
          utfEncodedFileName;
        extraFields +=
          "\x75\x70" +
          decToHex(unicodePathExtraField.length, 2) +
          unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField =
          decToHex(1, 1) +
          decToHex(this.crc32(encodedComment), 4) +
          utfEncodedComment;
        extraFields +=
          "\x75\x63" +
          decToHex(unicodeCommentExtraField.length, 2) +
          unicodeCommentExtraField;
      }
      var header = "";
      header += "\x0A\x00";
      header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\x00\x08" : "\x00\x00";
      header += compressedObject.compressionMethod;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(compressedObject.crc32, 4);
      header += decToHex(compressedObject.compressedSize, 4);
      header += decToHex(compressedObject.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER +
        decToHex(versionMadeBy, 2) +
        header +
        decToHex(encodedComment.length, 2) +
        "\x00\x00" +
        "\x00\x00" +
        decToHex(extFileAttr, 4) +
        decToHex(offset, 4) +
        encodedFileName +
        extraFields +
        encodedComment;
      return {
        fileRecord: fileRecord,
        dirRecord: dirRecord,
        compressedObject: compressedObject
      };
    };
    var out = {
      load: function(stream, options) {
        throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
      },
      filter: function(search) {
        var result = [],
          filename, relativePath, file, fileClone;
        for (filename in this.files) {
          if (!this.files.hasOwnProperty(filename)) {
            continue;
          }
          file = this.files[filename];
          fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));
          relativePath = filename.slice(this.root.length, filename.length);
          if (filename.slice(0, this.root.length) === this.root &&
            search(relativePath, fileClone)) {
            result.push(fileClone);
          }
        }
        return result;
      },
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (utils.isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            return this.filter(function(relativePath, file) {
              return !file.dir && relativePath === name;
            })[0] || null;
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (utils.isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) != "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file) {
            return file.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      generate: function(options) {
        options = utils.extend(options || {}, {
          base64: true,
          compression: "STORE",
          compressionOptions: null,
          type: "base64",
          platform: "DOS",
          comment: null,
          mimeType: 'application/zip',
          encodeFileName: utf8.utf8encode
        });
        utils.checkSupport(options.type);
        if (
          options.platform === 'darwin' ||
          options.platform === 'freebsd' ||
          options.platform === 'linux' ||
          options.platform === 'sunos'
        ) {
          options.platform = "UNIX";
        }
        if (options.platform === 'win32') {
          options.platform = "DOS";
        }
        var zipData = [],
          localDirLength = 0,
          centralDirLength = 0,
          writer, i,
          encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
        for (var name in this.files) {
          if (!this.files.hasOwnProperty(name)) {
            continue;
          }
          var file = this.files[name];
          var compressionName = file.options.compression || options.compression.toUpperCase();
          var compression = compressions[compressionName];
          if (!compression) {
            throw new Error(compressionName + " is not a valid compression method !");
          }
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
          var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
          localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
          centralDirLength += zipPart.dirRecord.length;
          zipData.push(zipPart);
        }
        var dirEnd = "";
        dirEnd = signature.CENTRAL_DIRECTORY_END +
          "\x00\x00" +
          "\x00\x00" +
          decToHex(zipData.length, 2) +
          decToHex(zipData.length, 2) +
          decToHex(centralDirLength, 4) +
          decToHex(localDirLength, 4) +
          decToHex(encodedComment.length, 2) +
          encodedComment;
        var typeName = options.type.toLowerCase();
        if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
          writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
        } else {
          writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
        }
        for (i = 0; i < zipData.length; i++) {
          writer.append(zipData[i].fileRecord);
          writer.append(zipData[i].compressedObject.compressedContent);
        }
        for (i = 0; i < zipData.length; i++) {
          writer.append(zipData[i].dirRecord);
        }
        writer.append(dirEnd);
        var zip = writer.finalize();
        switch (options.type.toLowerCase()) {
          case "uint8array":
          case "arraybuffer":
          case "nodebuffer":
            return utils.transformTo(options.type.toLowerCase(), zip);
          case "blob":
            return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
          case "base64":
            return (options.base64) ? base64.encode(zip) : zip;
          default:
            return zip;
        }
      },
      crc32: function(input, crc) {
        return crc32(input, crc);
      },
      utf8encode: function(string) {
        return utils.transformTo("string", utf8.utf8encode(string));
      },
      utf8decode: function(input) {
        return utf8.utf8decode(input);
      }
    };
    module.exports = out;
  }, {
    "./base64": 17,
    "./compressedObject": 18,
    "./compressions": 19,
    "./crc32": 20,
    "./defaults": 22,
    "./nodeBuffer": 27,
    "./signature": 30,
    "./stringWriter": 32,
    "./support": 33,
    "./uint8ArrayWriter": 35,
    "./utf8": 36,
    "./utils": 37
  }],
  30: [function(require, module, exports) {
    'use strict';
    exports.LOCAL_FILE_HEADER = "PK\x03\x04";
    exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
    exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
    exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
    exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
    exports.DATA_DESCRIPTOR = "PK\x07\x08";
  }, {}],
  31: [function(require, module, exports) {
    'use strict';
    var DataReader = require('./dataReader');
    var utils = require('./utils');

    function StringReader(data, optimizedBinaryString) {
      this.data = data;
      if (!optimizedBinaryString) {
        this.data = utils.string2binary(this.data);
      }
      this.length = this.data.length;
      this.index = 0;
      this.zero = 0;
    }
    StringReader.prototype = new DataReader();
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = StringReader;
  }, {
    "./dataReader": 21,
    "./utils": 37
  }],
  32: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');
    var StringWriter = function() {
      this.data = [];
    };
    StringWriter.prototype = {
      append: function(input) {
        input = utils.transformTo("string", input);
        this.data.push(input);
      },
      finalize: function() {
        return this.data.join("");
      }
    };
    module.exports = StringWriter;
  }, {
    "./utils": 37
  }],
  33: [function(require, module, exports) {
    (function(Buffer) {
      'use strict';
      exports.base64 = true;
      exports.array = true;
      exports.string = true;
      exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
      exports.nodebuffer = typeof Buffer !== "undefined";
      exports.uint8array = typeof Uint8Array !== "undefined";
      if (typeof ArrayBuffer === "undefined") {
        exports.blob = false;
      } else {
        var buffer = new ArrayBuffer(0);
        try {
          exports.blob = new Blob([buffer], {
            type: "application/zip"
          }).size === 0;
        } catch (e) {
          try {
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
          } catch (e) {
            exports.blob = false;
          }
        }
      }
    }).call(this, require("buffer").Buffer)
  }, {
    "buffer": 10
  }],
  34: [function(require, module, exports) {
    'use strict';
    var ArrayReader = require('./arrayReader');

    function Uint8ArrayReader(data) {
      if (data) {
        this.data = data;
        this.length = this.data.length;
        this.index = 0;
        this.zero = 0;
      }
    }
    Uint8ArrayReader.prototype = new ArrayReader();
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module.exports = Uint8ArrayReader;
  }, {
    "./arrayReader": 16
  }],
  35: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');
    var Uint8ArrayWriter = function(length) {
      this.data = new Uint8Array(length);
      this.index = 0;
    };
    Uint8ArrayWriter.prototype = {
      append: function(input) {
        if (input.length !== 0) {
          input = utils.transformTo("uint8array", input);
          this.data.set(input, this.index);
          this.index += input.length;
        }
      },
      finalize: function() {
        return this.data;
      }
    };
    module.exports = Uint8ArrayWriter;
  }, {
    "./utils": 37
  }],
  36: [function(require, module, exports) {
    'use strict';
    var utils = require('./utils');
    var support = require('./support');
    var nodeBuffer = require('./nodeBuffer');
    var _utf8len = new Array(256);
    for (var i = 0; i < 256; i++) {
      _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length,
        buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | (c >>> 6);
          buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | (c >>> 12);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        } else {
          buf[i++] = 0xf0 | (c >>> 18);
          buf[i++] = 0x80 | (c >>> 12 & 0x3f);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        }
      }
      return buf;
    };
    var utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };
    var buf2string = function(buf) {
      var str, i, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = (c << 6) | (buf[i++] & 0x3f);
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
          utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodeBuffer(str, "utf-8");
      }
      return string2buf(str);
    };
    exports.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      var result = [],
        k = 0,
        len = buf.length,
        chunk = 65536;
      while (k < len) {
        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
        if (support.uint8array) {
          result.push(buf2string(buf.subarray(k, nextBoundary)));
        } else {
          result.push(buf2string(buf.slice(k, nextBoundary)));
        }
        k = nextBoundary;
      }
      return result.join("");
    };
  }, {
    "./nodeBuffer": 27,
    "./support": 33,
    "./utils": 37
  }],
  37: [function(require, module, exports) {
    'use strict';
    var support = require('./support');
    var compressions = require('./compressions');
    var nodeBuffer = require('./nodeBuffer');
    exports.string2binary = function(str) {
      var result = "";
      for (var i = 0; i < str.length; i++) {
        result += String.fromCharCode(str.charCodeAt(i) & 0xff);
      }
      return result;
    };
    exports.arrayBuffer2Blob = function(buffer, mimeType) {
      exports.checkSupport("blob");
      mimeType = mimeType || 'application/zip';
      try {
        return new Blob([buffer], {
          type: mimeType
        });
      } catch (e) {
        try {
          var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
          var builder = new Builder();
          builder.append(buffer);
          return builder.getBlob(mimeType);
        } catch (e) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };

    function identity(input) {
      return input;
    }

    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
      }
      return array;
    }

    function arrayLikeToString(array) {
      var chunk = 65536;
      var result = [],
        len = array.length,
        type = exports.getTypeOf(array),
        k = 0,
        canUseApply = true;
      try {
        switch (type) {
          case "uint8array":
            String.fromCharCode.apply(null, new Uint8Array(0));
            break;
          case "nodebuffer":
            String.fromCharCode.apply(null, nodeBuffer(0));
            break;
        }
      } catch (e) {
        canUseApply = false;
      }
      if (!canUseApply) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      }
      while (k < len && chunk > 1) {
        try {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        } catch (e) {
          chunk = Math.floor(chunk / 2);
        }
      }
      return result.join("");
    }
    exports.applyFromCharCode = arrayLikeToString;

    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodeBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodeBuffer(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodeBuffer(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodeBuffer(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodeBuffer.test(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this browser");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = '',
        code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    exports.isRegExp = function(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    };
    exports.extend = function() {
      var result = {},
        i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
  }, {
    "./compressions": 19,
    "./nodeBuffer": 27,
    "./support": 33
  }],
  38: [function(require, module, exports) {
    'use strict';
    var StringReader = require('./stringReader');
    var NodeBufferReader = require('./nodeBufferReader');
    var Uint8ArrayReader = require('./uint8ArrayReader');
    var ArrayReader = require('./arrayReader');
    var utils = require('./utils');
    var sig = require('./signature');
    var ZipEntry = require('./zipEntry');
    var support = require('./support');
    var jszipProto = require('./object');

    function ZipEntries(data, loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
      if (data) {
        this.load(data);
      }
    }
    ZipEntries.prototype = {
      checkSignature: function(expectedSignature) {
        var signature = this.reader.readString(4);
        if (signature !== expectedSignature) {
          throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.versionMadeBy = this.reader.readString(2);
        this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
          index = 0,
          extraFieldId,
          extraFieldLength,
          extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readString(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {}
        }
      },
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? " +
              "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip : can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {} else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        var type = utils.getTypeOf(data);
        utils.checkSupport(type);
        if (type === "string" && !support.uint8array) {
          this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
        } else if (type === "nodebuffer") {
          this.reader = new NodeBufferReader(data);
        } else if (support.uint8array) {
          this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));
        } else if (support.array) {
          this.reader = new ArrayReader(utils.transformTo("array", data));
        } else {
          throw new Error("Unexpected error: unsupported type '" + type + "'");
        }
      },
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module.exports = ZipEntries;
  }, {
    "./arrayReader": 16,
    "./nodeBufferReader": 28,
    "./object": 29,
    "./signature": 30,
    "./stringReader": 31,
    "./support": 33,
    "./uint8ArrayReader": 34,
    "./utils": 37,
    "./zipEntry": 39
  }],
  39: [function(require, module, exports) {
    'use strict';
    var StringReader = require('./stringReader');
    var utils = require('./utils');
    var CompressedObject = require('./compressedObject');
    var jszipProto = require('./object');
    var support = require('./support');
    var MADE_BY_DOS = 0x00;
    var MADE_BY_UNIX = 0x03;

    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      isEncrypted: function() {
        return (this.bitFlag & 0x0001) === 0x0001;
      },
      useUTF8: function() {
        return (this.bitFlag & 0x0800) === 0x0800;
      },
      prepareCompressedContent: function(reader, from, length) {
        return function() {
          var previousIndex = reader.index;
          reader.setIndex(from);
          var compressedFileData = reader.readData(length);
          reader.setIndex(previousIndex);
          return compressedFileData;
        };
      },
      prepareContent: function(reader, from, length, compression, uncompressedSize) {
        return function() {
          var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
          var uncompressedFileData = compression.uncompress(compressedFileData);
          if (uncompressedFileData.length !== uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
          return uncompressedFileData;
        };
      },
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize == -1 || this.uncompressedSize == -1) {
          throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
        }
        compression = utils.findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject();
        this.decompressed.compressedSize = this.compressedSize;
        this.decompressed.uncompressedSize = this.uncompressedSize;
        this.decompressed.crc32 = this.crc32;
        this.decompressed.compressionMethod = this.compressionMethod;
        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
        if (this.loadOptions.checkCRC32) {
          this.decompressed = utils.transformTo("string", this.decompressed.getContent());
          if (jszipProto.crc32(this.decompressed) !== this.crc32) {
            throw new Error("Corrupted zip : CRC32 mismatch");
          }
        }
      },
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        this.fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        this.fileName = reader.readData(this.fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 0x3F;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
          this.dir = true;
        }
      },
      parseZIP64ExtraField: function(reader) {
        if (!this.extraFields[0x0001]) {
          return;
        }
        var extraReader = new StringReader(this.extraFields[0x0001].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      readExtraFields: function(reader) {
        var start = reader.index,
          extraFieldId,
          extraFieldLength,
          extraFieldValue;
        this.extraFields = this.extraFields || {};
        while (reader.index < start + this.extraFieldsLength) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readString(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = jszipProto.utf8decode(this.fileName);
          this.fileCommentStr = jszipProto.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
          var extraReader = new StringReader(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));
        }
        return null;
      },
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
          var extraReader = new StringReader(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
        }
        return null;
      }
    };
    module.exports = ZipEntry;
  }, {
    "./compressedObject": 18,
    "./object": 29,
    "./stringReader": 31,
    "./support": 33,
    "./utils": 37
  }],
  40: [function(require, module, exports) {
    var s = 1000
    var m = s * 60
    var h = m * 60
    var d = h * 24
    var y = d * 365.25
    module.exports = function(val, options) {
      options = options || {}
      var type = typeof val
      if (type === 'string' && val.length > 0) {
        return parse(val)
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ?
          fmtLong(val) :
          fmtShort(val)
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
    }

    function parse(str) {
      str = String(str)
      if (str.length > 10000) {
        return
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
      if (!match) {
        return
      }
      var n = parseFloat(match[1])
      var type = (match[2] || 'ms').toLowerCase()
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y
        case 'days':
        case 'day':
        case 'd':
          return n * d
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n
        default:
          return undefined
      }
    }

    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd'
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h'
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm'
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's'
      }
      return ms + 'ms'
    }

    function fmtLong(ms) {
      return plural(ms, d, 'day') ||
        plural(ms, h, 'hour') ||
        plural(ms, m, 'minute') ||
        plural(ms, s, 'second') ||
        ms + ' ms'
    }

    function plural(ms, n, name) {
      if (ms < n) {
        return
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name
      }
      return Math.ceil(ms / n) + ' ' + name + 's'
    }
  }, {}],
  41: [function(require, module, exports) {
    'use strict';
    var assign = require('./lib/utils/common').assign;
    var deflate = require('./lib/deflate');
    var inflate = require('./lib/inflate');
    var constants = require('./lib/zlib/constants');
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }, {
    "./lib/deflate": 42,
    "./lib/inflate": 43,
    "./lib/utils/common": 44,
    "./lib/zlib/constants": 47
  }],
  42: [function(require, module, exports) {
    'use strict';
    var zlib_deflate = require('./zlib/deflate');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var msg = require('./zlib/messages');
    var ZStream = require('./zlib/zstream');
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;

    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ''
      }, options || {});
      var opt = this.options;
      if (opt.raw && (opt.windowBits > 0)) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = '';
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === 'string') {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
      if (typeof data === 'string') {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
          if (this.options.to === 'string') {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };

    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }

    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }

    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }, {
    "./utils/common": 44,
    "./utils/strings": 45,
    "./zlib/deflate": 49,
    "./zlib/messages": 54,
    "./zlib/zstream": 56
  }],
  43: [function(require, module, exports) {
    'use strict';
    var zlib_inflate = require('./zlib/inflate');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var c = require('./zlib/constants');
    var msg = require('./zlib/messages');
    var ZStream = require('./zlib/zstream');
    var GZheader = require('./zlib/gzheader');
    var toString = Object.prototype.toString;

    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ''
      }, options || {});
      var opt = this.options;
      if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
        !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = '';
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var dict;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
      if (typeof data === 'string') {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          if (typeof dictionary === 'string') {
            dict = strings.string2buf(dictionary);
          } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
            dict = new Uint8Array(dictionary);
          } else {
            dict = dictionary;
          }
          status = zlib_inflate.inflateSetDictionary(this.strm, dict);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
            if (this.options.to === 'string') {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };

    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }

    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }, {
    "./utils/common": 44,
    "./utils/strings": 45,
    "./zlib/constants": 47,
    "./zlib/gzheader": 50,
    "./zlib/inflate": 52,
    "./zlib/messages": 54,
    "./zlib/zstream": 56
  }],
  44: [function(require, module, exports) {
    'use strict';
    var TYPED_OK = (typeof Uint8Array !== 'undefined') &&
      (typeof Uint16Array !== 'undefined') &&
      (typeof Int32Array !== 'undefined');
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== 'object') {
          throw new TypeError(source + 'must be non-object');
        }
        for (var p in source) {
          if (source.hasOwnProperty(p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }, {}],
  45: [function(require, module, exports) {
    'use strict';
    var utils = require('./common');
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (var q = 0; q < 256; q++) {
      _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length,
        buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | (c >>> 6);
          buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | (c >>> 12);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        } else {
          buf[i++] = 0xf0 | (c >>> 18);
          buf[i++] = 0x80 | (c >>> 12 & 0x3f);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        }
      }
      return buf;
    };

    function buf2binstring(buf, len) {
      if (len < 65537) {
        if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = '';
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len;) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = (c << 6) | (buf[i++] & 0x3f);
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
          utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };
  }, {
    "./common": 44
  }],
  46: [function(require, module, exports) {
    'use strict';

    function adler32(adler, buf, len, pos) {
      var s1 = (adler & 0xffff) | 0,
        s2 = ((adler >>> 16) & 0xffff) | 0,
        n = 0;
      while (len !== 0) {
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
          s1 = (s1 + buf[pos++]) | 0;
          s2 = (s2 + s1) | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return (s1 | (s2 << 16)) | 0;
    }
    module.exports = adler32;
  }, {}],
  47: [function(require, module, exports) {
    'use strict';
    module.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }, {}],
  48: [function(require, module, exports) {
    'use strict';

    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();

    function crc32(crc, buf, len, pos) {
      var t = crcTable,
        end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
      }
      return (crc ^ (-1));
    }
    module.exports = crc32;
  }, {}],
  49: [function(require, module, exports) {
    'use strict';
    var utils = require('../utils/common');
    var trees = require('./trees');
    var adler32 = require('./adler32');
    var crc32 = require('./crc32');
    var msg = require('./messages');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;

    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }

    function rank(f) {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }

    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }

    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }

    function flush_block_only(s, last) {
      trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }

    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }

    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }

    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }

    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end ||
          _win[match + best_len - 1] !== scan_end1 ||
          _win[match] !== _win[scan] ||
          _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
          scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }

    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }

    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (;;) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }

    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }

    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match &&
          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 &&
            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }

    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (;;) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] &&
              prev === _win[++scan] && prev === _win[++scan] &&
              scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }

    function deflate_huff(s, flush) {
      var bflush;
      for (;;) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }

    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];

    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }

    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }

    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ?
        0 :
        1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }

    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }

    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }

    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << (memLevel + 6);
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }

    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }

    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state ||
        flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output ||
        (!strm.input && strm.avail_in !== 0) ||
        (s.status === FINISH_STATE && flush !== Z_FINISH)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 :
              (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) +
              (s.gzhead.hcrc ? 2 : 0) +
              (!s.gzhead.extra ? 0 : 4) +
              (!s.gzhead.name ? 0 : 8) +
              (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 :
              (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - (header % 31);
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
        flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 ||
        (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
          (s.strategy === Z_RLE ? deflate_rle(s, flush) :
            configuration_table[s.level].func(s, flush));
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }

    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE &&
        status !== EXTRA_STATE &&
        status !== NAME_STATE &&
        status !== COMMENT_STATE &&
        status !== HCRC_STATE &&
        status !== BUSY_STATE &&
        status !== FINISH_STATE
      ) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }

    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  }, {
    "../utils/common": 44,
    "./adler32": 46,
    "./crc32": 48,
    "./messages": 54,
    "./trees": 55
  }],
  50: [function(require, module, exports) {
    'use strict';

    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = '';
      this.comment = '';
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }, {}],
  51: [function(require, module, exports) {
    'use strict';
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (;;) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = (here >>> 16) & 0xff;
              if (op === 0) {
                output[_out++] = here & 0xffff;
              } else if (op & 16) {
                len = here & 0xffff;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & ((1 << op) - 1);
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (;;) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = (here >>> 16) & 0xff;
                    if (op & 16) {
                      dist = here & 0xffff;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & ((1 << op) - 1);
                      if (dist > dmax) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                      continue dodist;
                    } else {
                      strm.msg = 'invalid distance code';
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
      strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }, {}],
  52: [function(require, module, exports) {
    'use strict';
    var utils = require('../utils/common');
    var adler32 = require('./adler32');
    var crc32 = require('./crc32');
    var inflate_fast = require('./inffast');
    var inflate_table = require('./inftrees');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;

    function zswap32(q) {
      return (((q >>> 24) & 0xff) +
        ((q >>> 8) & 0xff00) +
        ((q & 0xff00) << 8) +
        ((q & 0xff) << 24));
    }

    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }

    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }

    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }

    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }

    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }

    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix, distfix;

    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
          bits: 9
        });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
          bits: 5
        });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }

    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }

    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output ||
        (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (;;) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((state.wrap & 2) && hold === 0x8b1f) {
                state.check = 0;
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) ||
                (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                strm.msg = 'incorrect header check';
                state.mode = BAD;
                break;
              }
              if ((hold & 0x0f) !== Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 0x0f) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = 'invalid window size';
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 0x200 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 0xff) !== Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              }
              if (state.flags & 0xe000) {
                strm.msg = 'unknown header flags set';
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = ((hold >> 8) & 1);
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                hbuf[2] = (hold >>> 16) & 0xff;
                hbuf[3] = (hold >>> 24) & 0xff;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = (hold & 0xff);
                state.head.os = (hold >> 8);
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 0x0400) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 0x0200) {
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = (hold >>> 8) & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 0x0400) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      copy,
                      len
                    );
                  }
                  if (state.flags & 0x0200) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 0x0800) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len &&
                    (state.length < 65536)) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 0x1000) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len &&
                    (state.length < 65536)) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 0x0200) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 0xffff)) {
                  strm.msg = 'header crc mismatch';
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = ((state.flags >> 9) & 1);
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = (hold & 0x01);
              hold >>>= 1;
              bits -= 1;
              switch ((hold & 0x03)) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = 'invalid block type';
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                strm.msg = 'invalid stored block lengths';
                state.mode = BAD;
                break;
              }
              state.length = hold & 0xffff;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 0x1f) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 0x1f) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 0x0f) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = 'too many length or distance symbols';
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = (hold & 0x07);
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = 'invalid code lengths set';
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (;;) {
                  here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;
                  if ((here_bits) <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = 'invalid bit length repeat';
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 0x03);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 0x07);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 0x7f);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = 'invalid code -- missing end-of-block';
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = 'invalid literal/lengths set';
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = 'invalid distances set';
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (;;) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;
                  if ((last_bits + here_bits) <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & ((1 << state.extra) - 1);
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (;;) {
                here = state.distcode[hold & ((1 << state.distbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (;;) {
                  here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = (here >>> 16) & 0xff;
                  here_val = here & 0xffff;
                  if ((last_bits + here_bits) <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = 'invalid distance code';
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = (here_op) & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & ((1 << state.extra) - 1);
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check =
                    (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = 'incorrect data check';
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 0xffffffff)) {
                  strm.msg = 'incorrect length check';
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
          (state.mode < CHECK || flush !== Z_FINISH))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check =
          (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) +
        (state.mode === TYPE ? 128 : 0) +
        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }

    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }

    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }

    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  }, {
    "../utils/common": 44,
    "./adler32": 46,
    "./crc32": 48,
    "./inffast": 51,
    "./inftrees": 53
  }],
  53: [function(require, module, exports) {
    'use strict';
    var utils = require('../utils/common');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ];
    var lext = [
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ];
    var dbase = [
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
      257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
      8193, 12289, 16385, 24577, 0, 0
    ];
    var dext = [
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
      23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
      28, 28, 29, 29, 64, 64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
        max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }
      for (;;) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if ((type === LENS && used > ENOUGH_LENS) ||
            (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
          }
          low = huff & mask;
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }
      opts.bits = root;
      return 0;
    };
  }, {
    "../utils/common": 44
  }],
  54: [function(require, module, exports) {
    'use strict';
    module.exports = {
      2: 'need dictionary',
      1: 'stream end',
      0: '',
      '-1': 'file error',
      '-2': 'stream error',
      '-3': 'data error',
      '-4': 'insufficient memory',
      '-5': 'buffer error',
      '-6': 'incompatible version'
    };
  }, {}],
  55: [function(require, module, exports) {
    'use strict';
    var utils = require('../utils/common');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;

    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);

    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;

    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }

    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }

    function put_short(s, w) {
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }

    function send_bits(s, value, length) {
      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    }

    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }

    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }

    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }

    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }

    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }

    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }

    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }

    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }

    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }

    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return (tree[_n2] < tree[_m2] ||
        (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
    }

    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len &&
          smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }

    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }

    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = (s.heap_len >> 1); n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }

    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }

    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }

    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }

    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }

    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 ||
        s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;

    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }

    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }

    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }

    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }

    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return (s.last_lit === s.lit_bufsize - 1);
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }, {
    "../utils/common": 44
  }],
  56: [function(require, module, exports) {
    'use strict';

    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = '';
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }, {}],
  57: [function(require, module, exports) {
    (function(process) {
      function normalizeArray(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      }
      var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      var splitPath = function(filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      exports.resolve = function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : process.cwd();
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      };
      exports.normalize = function(path) {
        var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
        path = normalizeArray(filter(path.split('/'), function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      };
      exports.isAbsolute = function(path) {
        return path.charAt(0) === '/';
      };
      exports.join = function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return exports.normalize(filter(paths, function(p, index) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }).join('/'));
      };
      exports.relative = function(from, to) {
        from = exports.resolve(from).substr(1);
        to = exports.resolve(to).substr(1);

        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      };
      exports.sep = '/';
      exports.delimiter = ':';
      exports.dirname = function(path) {
        var result = splitPath(path),
          root = result[0],
          dir = result[1];
        if (!root && !dir) {
          return '.';
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      };
      exports.basename = function(path, ext) {
        var f = splitPath(path)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
          f = f.substr(0, f.length - ext.length);
        }
        return f;
      };
      exports.extname = function(path) {
        return splitPath(path)[3];
      };

      function filter(xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
      }
      var substr = 'ab'.substr(-1) === 'b' ?
        function(str, start, len) {
          return str.substr(start, len)
        } :
        function(str, start, len) {
          if (start < 0) start = str.length + start;
          return str.substr(start, len);
        };
    }).call(this, require('_process'))
  }, {
    "_process": 58
  }],
  58: [function(require, module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function() {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }())

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };

    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};

    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.binding = function(name) {
      throw new Error('process.binding is not supported');
    };
    process.cwd = function() {
      return '/'
    };
    process.chdir = function(dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function() {
      return 0;
    };
  }, {}],
  59: [function(require, module, exports) {
    function DOMParser(options) {
      this.options = options || {
        locator: {}
      };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var entityMap = {
        'lt': '<',
        'gt': '>',
        'amp': '&',
        'quot': '"',
        'apos': "'"
      }
      if (locator) {
        domBuilder.setDocumentLocator(locator)
      }
      sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax.domBuilder = options.domBuilder || domBuilder;
      if (/\/x?html?$/.test(mimeType)) {
        entityMap.nbsp = '\xa0';
        entityMap.copy = '\xa9';
        defaultNSMap[''] = 'http://www.w3.org/1999/xhtml';
      }
      defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
      if (source) {
        sax.parse(source, defaultNSMap, entityMap);
      } else {
        sax.errorHandler.error("invalid document source");
      }
      return domBuilder.document;
    }

    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {}
      var isCallback = errorImpl instanceof Function;
      locator = locator || {}

      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg)
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn('[xmldom ' + key + ']\t' + msg + _locator(locator));
        } || function() {};
      }
      build('warning');
      build('error');
      build('fatalError');
      return errorHandler;
    }

    function DOMHandler() {
      this.cdata = false;
    }

    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.document = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.document.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.document;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el)
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          if (attr.getOffset) {
            position(attr.getOffset(1), attr)
          }
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr)
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {},
      endPrefixMapping: function(prefix) {},
      processingInstruction: function(target, data) {
        var ins = this.document.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins)
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {},
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments)
        if (this.currentElement && chars) {
          if (this.cdata) {
            var charNode = this.document.createCDATASection(chars);
            this.currentElement.appendChild(charNode);
          } else {
            var charNode = this.document.createTextNode(chars);
            this.currentElement.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode)
        }
      },
      skippedEntity: function(name) {},
      endDocument: function() {
        this.document.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments)
        var comm = this.document.createComment(chars);
        this.locator && position(this.locator, comm)
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.document.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt)
          appendElement(this, dt);
        }
      },
      warning: function(error) {
        console.warn('[xmldom warning]\t' + error, _locator(this.locator));
      },
      error: function(error) {
        console.error('[xmldom error]\t' + error, _locator(this.locator));
      },
      fatalError: function(error) {
        console.error('[xmldom fatalError]\t' + error, _locator(this.locator));
        throw error;
      }
    }

    function _locator(l) {
      if (l) {
        return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']'
      }
    }

    function _toString(chars, start, length) {
      if (typeof chars == 'string') {
        return chars.substr(start, length)
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + '';
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null
      }
    })

    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.document.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    if (typeof require == 'function') {
      var XMLReader = require('./sax').XMLReader;
      var DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;
      exports.XMLSerializer = require('./dom').XMLSerializer;
      exports.DOMParser = DOMParser;
    }
  }, {
    "./dom": 60,
    "./sax": 61
  }],
  60: [function(require, module, exports) {
    function copy(src, dest) {
      for (var p in src) {
        dest[p] = src[p];
      }
    }

    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (Object.create) {
        var ppt = Object.create(Super.prototype)
        pt.__proto__ = ppt;
      }
      if (!(pt instanceof Super)) {
        function t() {};
        t.prototype = Super.prototype;
        t = new t();
        copy(pt, t);
        Class.prototype = pt = t;
      }
      if (pt.constructor != Class) {
        if (typeof Class != 'function') {
          console.error("unknow Class:" + Class)
        }
        pt.constructor = Class
      }
    }
    var htmlns = 'http://www.w3.org/1999/xhtml';
    var NodeType = {}
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {}
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = ((ExceptionMessage[1] = "Index size error"), 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = ((ExceptionMessage[2] = "DOMString size error"), 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = ((ExceptionMessage[3] = "Hierarchy request error"), 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = ((ExceptionMessage[4] = "Wrong document"), 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = ((ExceptionMessage[5] = "Invalid character"), 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = ((ExceptionMessage[6] = "No data allowed"), 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7] = "No modification allowed"), 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = ((ExceptionMessage[8] = "Not found"), 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = ((ExceptionMessage[9] = "Not supported"), 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = ((ExceptionMessage[10] = "Attribute in use"), 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = ((ExceptionMessage[11] = "Invalid state"), 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = ((ExceptionMessage[12] = "Syntax error"), 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = ((ExceptionMessage[13] = "Invalid modification"), 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = ((ExceptionMessage[14] = "Invalid namespace"), 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = ((ExceptionMessage[15] = "Invalid access"), 15);

    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    };
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException)

    function NodeList() {};
    NodeList.prototype = {
      length: 0,
      item: function(index) {
        return this[index] || null;
      },
      toString: function() {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf);
        }
        return buf.join('');
      }
    };

    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh
      _updateLiveList(this);
    }

    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc != inc) {
        var ls = list._refresh(list._node);
        __set__(list, 'length', ls.length);
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i];
    }
    _extends(LiveNodeList, NodeList);

    function NamedNodeMap() {};

    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i
        }
      }
    }

    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }

    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1
        while (i < lastIndex) {
          list[i] = list[++i]
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw DOMException(NOT_FOUND_ERR, new Error())
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement,
          oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };

    function DOMImplementation(features) {
      this._features = {};
      if (features) {
        for (var feature in features) {
          this._features = features[feature];
        }
      }
    };
    DOMImplementation.prototype = {
      hasFeature: function(feature, version) {
        var versions = this._features[feature.toLowerCase()];
        if (versions && (!version || version in versions)) {
          return true;
        } else {
          return false;
        }
      },
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId;
        node.systemId = systemId;
        return node;
      }
    };

    function Node() {};
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        this.insertBefore(newChild, oldChild);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (map[n] == namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (prefix in map) {
              return map[prefix];
            }
          }
          el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };

    function _xmlEncoder(c) {
      return c == '<' && '&lt;' ||
        c == '>' && '&gt;' ||
        c == '&' && '&amp;' ||
        c == '"' && '&quot;' ||
        '&#' + c.charCodeAt() + ';'
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);

    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true
          }
        } while (node = node.nextSibling)
      }
    }

    function Document() {}

    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns == 'http://www.w3.org/2000/xmlns/') {
        el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value
      }
    }

    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns == 'http://www.w3.org/2000/xmlns/') {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : '']
      }
    }

    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
        }
      }
    }

    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }

    function _insertBefore(parentNode, newChild, nextChild) {
      var cp = newChild.parentNode;
      if (cp) {
        cp.removeChild(newChild);
      }
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = newChild.firstChild;
        if (newFirst == null) {
          return newChild;
        }
        var newLast = newChild.lastChild;
      } else {
        newFirst = newLast = newChild;
      }
      var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = nextChild;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parentNode.firstChild = newFirst;
      }
      if (nextChild == null) {
        parentNode.lastChild = newLast;
      } else {
        nextChild.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parentNode;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling))
      _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        newChild.firstChild = newChild.lastChild = null;
      }
      return newChild;
    }

    function _appendSingleChild(parentNode, newChild) {
      var cp = newChild.parentNode;
      if (cp) {
        var pre = parentNode.lastChild;
        cp.removeChild(newChild);
        var pre = parentNode.lastChild;
      }
      var pre = parentNode.lastChild;
      newChild.parentNode = parentNode;
      newChild.previousSibling = pre;
      newChild.nextSibling = null;
      if (pre) {
        pre.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      nodeName: '#document',
      nodeType: DOCUMENT_NODE,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        if (this.documentElement == null && newChild.nodeType == 1) {
          this.documentElement = newChild;
        }
        return _insertBefore(this, newChild, refChild), (newChild.ownerDocument = this), newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == 1) {
            if (node.getAttribute('id') == id) {
              rtv = node;
              return true;
            }
          }
        })
        return rtv;
      },
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data)
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data)
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data)
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(':');
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(':');
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);

    function Element() {
      this._nsMap = {};
    };
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || '';
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr)
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name)
        attr && this.removeAttributeNode(attr);
      },
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || '';
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr)
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);

    function Attr() {};
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);

    function CharacterData() {};
    CharacterData.prototype = {
      data: '',
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[3])
        return Node.prototype.appendChild.apply(this, arguments)
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    }
    _extends(CharacterData, Node);

    function Text() {};
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    }
    _extends(Text, CharacterData);

    function Comment() {};
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    }
    _extends(Comment, CharacterData);

    function CDATASection() {};
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    }
    _extends(CDATASection, CharacterData);

    function DocumentType() {};
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);

    function Notation() {};
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);

    function Entity() {};
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);

    function EntityReference() {};
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);

    function DocumentFragment() {};
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);

    function ProcessingInstruction() {}
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);

    function XMLSerializer() {}
    XMLSerializer.prototype.serializeToString = function(node, attributeSorter) {
      return node.toString(attributeSorter);
    }
    Node.prototype.toString = function(attributeSorter) {
      var buf = [];
      serializeToString(this, buf, attributeSorter);
      return buf.join('');
    }

    function serializeToString(node, buf, attributeSorter, isHTML) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = (htmlns === node.namespaceURI) || isHTML
          buf.push('<', nodeName);
          if (attributeSorter) {
            buf.sort.apply(attrs, attributeSorter);
          }
          for (var i = 0; i < len; i++) {
            serializeToString(attrs.item(i), buf, attributeSorter, isHTML);
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)) {
            buf.push('>');
            if (isHTML && /^script$/i.test(nodeName)) {
              if (child) {
                buf.push(child.data);
              }
            } else {
              while (child) {
                serializeToString(child, buf, attributeSorter, isHTML);
                child = child.nextSibling;
              }
            }
            buf.push('</', nodeName, '>');
          } else {
            buf.push('/>');
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, attributeSorter, isHTML);
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return buf.push(' ', node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));
        case CDATA_SECTION_NODE:
          return buf.push('<![CDATA[', node.data, ']]>');
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push('<!DOCTYPE ', node.name);
          if (pubid) {
            buf.push(' PUBLIC "', pubid);
            if (sysid && sysid != '.') {
              buf.push('" "', sysid);
            }
            buf.push('">');
          } else if (sysid && sysid != '.') {
            buf.push(' SYSTEM "', sysid, '">');
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push('&', node.nodeName, ';');
        default:
          buf.push('??', node.nodeName);
      }
    }

    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }

    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        var v = node[n];
        if (typeof v != 'object') {
          if (v != node2[n]) {
            node2[n] = v;
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }

    function __set__(object, key, value) {
      object[key] = value
    }
    try {
      if (Object.defineProperty) {
        Object.defineProperty(LiveNodeList.prototype, 'length', {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, 'textContent', {
          get: function() {
            return getTextContent(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case 1:
              case 11:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = value;
                this.nodeValue = data;
            }
          }
        })

        function getTextContent(node) {
          switch (node.nodeType) {
            case 1:
            case 11:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent(node));
                }
                node = node.nextSibling;
              }
              return buf.join('');
            default:
              return node.nodeValue;
          }
        }
        __set__ = function(object, key, value) {
          object['$$' + key] = value
        }
      }
    } catch (e) {}
    if (typeof require == 'function') {
      exports.DOMImplementation = DOMImplementation;
      exports.XMLSerializer = XMLSerializer;
    }
  }, {}],
  61: [function(require, module, exports) {
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\u00B7\u0300-\u036F\\u203F-\u2040]");
    var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_S = 2;
    var S_EQ = 3;
    var S_V = 4;
    var S_E = 5;
    var S_S = 6;
    var S_C = 7;

    function XMLReader() {}
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {})
        parse(source, defaultNSMap, entityMap,
          domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    }

    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 0xffff) {
          code -= 0x10000;
          var surrogate1 = 0xd800 + (code >> 10),
            surrogate2 = 0xdc00 + (code & 0x3ff);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }

      function entityReplacer(a) {
        var k = a.slice(1, -1);
        if (k in entityMap) {
          return entityMap[k];
        } else if (k.charAt(0) === '#') {
          return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')))
        } else {
          errorHandler.error('entity not found:' + a);
          return a;
        }
      }

      function appendText(end) {
        if (end > start) {
          var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end - start);
          start = end
        }
      }

      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.+(?:\r\n?|\n)|.*$/g
      var locator = domBuilder.locator;
      var parseStack = [{
        currentNSMap: defaultNSMapCopy
      }]
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf('<', start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.document;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case '/':
              var end = source.indexOf('>', tagStart + 3);
              var tagName = source.substring(tagStart + 2, end);
              var config = parseStack.pop();
              var localNSMap = config.localNSMap;
              if (config.tagName != tagName) {
                errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName);
              }
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  domBuilder.endPrefixMapping(prefix);
                }
              }
              end++;
              break;
            case '?':
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case '!':
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var end = parseElementStartPart(source, tagStart, el, entityReplacer, errorHandler);
              var len = el.length;
              if (locator) {
                if (len) {
                  for (var i = 0; i < len; i++) {
                    var a = el[i];
                    position(a.offset);
                    a.offset = copyLocator(locator, {});
                  }
                }
                position(end);
              }
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning('unclosed xml attribute');
                }
              }
              appendElement(el, domBuilder, parseStack);
              if (el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder)
              } else {
                end++;
              }
          }
        } catch (e) {
          errorHandler.error('element parse error: ' + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }

    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }

    function parseElementStartPart(source, start, el, entityReplacer, errorHandler) {
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case '=':
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_S) {
              s = S_EQ;
            } else {
              throw new Error('attribute equal must after attrName');
            }
            break;
          case '\'':
          case '"':
            if (s === S_EQ) {
              start = p + 1;
              p = source.indexOf(c, start)
              if (p > 0) {
                value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                el.add(attrName, value, start - 1);
                s = S_E;
              } else {
                throw new Error('attribute value no end \'' + c + '\' match');
              }
            } else if (s == S_V) {
              value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
              el.add(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
              start = p + 1;
              s = S_E
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case '/':
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_E:
              case S_S:
              case S_C:
                s = S_C;
                el.closed = true;
              case S_V:
              case S_ATTR:
              case S_ATTR_S:
                break;
              default:
                throw new Error("attribute invalid close char('/')")
            }
            break;
          case '':
            errorHandler.error('unexpected end of input');
          case '>':
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_E:
              case S_S:
              case S_C:
                break;
              case S_V:
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === '/') {
                  el.closed = true;
                  value = value.slice(0, -1)
                }
              case S_ATTR_S:
                if (s === S_ATTR_S) {
                  value = attrName;
                }
                if (s == S_V) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  el.add(attrName, value.replace(/&#?\w+;/g, entityReplacer), start)
                } else {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!')
                  el.add(value, value, start)
                }
                break;
              case S_EQ:
                throw new Error('attribute value missed!!');
            }
            return p;
          case '\u0080':
            c = ' ';
          default:
            if (c <= ' ') {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_S;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p)
                  s = S_ATTR_S;
                  break;
                case S_V:
                  var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  el.add(attrName, value, start)
                case S_E:
                  s = S_S;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_S:
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead!!')
                  el.add(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_E:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!')
                case S_S:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_V;
                  start = p;
                  break;
                case S_C:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }

    function appendElement(el, domBuilder, parseStack) {
      var tagName = el.tagName;
      var localNSMap = null;
      var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(':');
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === 'xmlns' && localName
        } else {
          localName = qName;
          prefix = null
          nsPrefix = qName === 'xmlns' && ''
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {}
            _copy(currentNSMap, currentNSMap = {})
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = 'http://www.w3.org/2000/xmlns/'
          domBuilder.startPrefixMapping(nsPrefix, value)
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === 'xml') {
            a.uri = 'http://www.w3.org/XML/1998/namespace';
          }
          if (prefix !== 'xmlns') {
            a.uri = currentNSMap[prefix]
          }
        }
      }
      var nsp = tagName.indexOf(':');
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ''];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            domBuilder.endPrefixMapping(prefix)
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        parseStack.push(el);
      }
    }

    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }

    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = closeMap[tagName] = source.lastIndexOf('</' + tagName + '>')
      }
      return pos < elStartEnd;
    }

    function _copy(source, target) {
      for (var n in source) {
        target[n] = source[n]
      }
    }

    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2)
      switch (next) {
        case '-':
          if (source.charAt(start + 3) === '-') {
            var end = source.indexOf('-->', start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == 'CDATA[') {
            var end = source.indexOf(']]>', start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA()
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
            var sysid = len > 4 && matchs[4][0];
            var lastMatch = matchs[len - 1]
            domBuilder.startDTD(name, pubid && pubid.replace(/^(['"])(.*?)\1$/, '$2'),
              sysid && sysid.replace(/^(['"])(.*?)\1$/, '$2'));
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length
          }
      }
      return -1;
    }

    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf('?>', start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }

    function ElementAttributes(source) {}
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error('invalid tagName:' + tagName)
        }
        this.tagName = tagName
      },
      add: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error('invalid attribute:' + qName)
        }
        this[this.length++] = {
          qName: qName,
          value: value,
          offset: offset
        }
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName
      },
      getOffset: function(i) {
        return this[i].offset
      },
      getQName: function(i) {
        return this[i].qName
      },
      getURI: function(i) {
        return this[i].uri
      },
      getValue: function(i) {
        return this[i].value
      }
    }

    function _set_proto_(thiz, parent) {
      thiz.__proto__ = parent;
      return thiz;
    }
    if (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {
      _set_proto_ = function(thiz, parent) {
        function p() {};
        p.prototype = parent;
        p = new p();
        for (parent in thiz) {
          p[parent] = thiz[parent];
        }
        return p;
      }
    }

    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    if (typeof require == 'function') {
      exports.XMLReader = XMLReader;
    }
  }, {}],
  62: [function(require, module, exports) {
    var xpath = (typeof exports === 'undefined') ? {} : exports;
    (function(exports) {
      "use strict";
      XPathParser.prototype = new Object();
      XPathParser.prototype.constructor = XPathParser;
      XPathParser.superclass = Object.prototype;

      function XPathParser() {
        this.init();
      }
      XPathParser.prototype.init = function() {
        this.reduceActions = [];
        this.reduceActions[3] = function(rhs) {
          return new OrOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[5] = function(rhs) {
          return new AndOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[7] = function(rhs) {
          return new EqualsOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[8] = function(rhs) {
          return new NotEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[10] = function(rhs) {
          return new LessThanOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[11] = function(rhs) {
          return new GreaterThanOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[12] = function(rhs) {
          return new LessThanOrEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[13] = function(rhs) {
          return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[15] = function(rhs) {
          return new PlusOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[16] = function(rhs) {
          return new MinusOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[18] = function(rhs) {
          return new MultiplyOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[19] = function(rhs) {
          return new DivOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[20] = function(rhs) {
          return new ModOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[22] = function(rhs) {
          return new UnaryMinusOperation(rhs[1]);
        };
        this.reduceActions[24] = function(rhs) {
          return new BarOperation(rhs[0], rhs[2]);
        };
        this.reduceActions[25] = function(rhs) {
          return new PathExpr(undefined, undefined, rhs[0]);
        };
        this.reduceActions[27] = function(rhs) {
          rhs[0].locationPath = rhs[2];
          return rhs[0];
        };
        this.reduceActions[28] = function(rhs) {
          rhs[0].locationPath = rhs[2];
          rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
          return rhs[0];
        };
        this.reduceActions[29] = function(rhs) {
          return new PathExpr(rhs[0], [], undefined);
        };
        this.reduceActions[30] = function(rhs) {
          if (Utilities.instance_of(rhs[0], PathExpr)) {
            if (rhs[0].filterPredicates == undefined) {
              rhs[0].filterPredicates = [];
            }
            rhs[0].filterPredicates.push(rhs[1]);
            return rhs[0];
          } else {
            return new PathExpr(rhs[0], [rhs[1]], undefined);
          }
        };
        this.reduceActions[32] = function(rhs) {
          return rhs[1];
        };
        this.reduceActions[33] = function(rhs) {
          return new XString(rhs[0]);
        };
        this.reduceActions[34] = function(rhs) {
          return new XNumber(rhs[0]);
        };
        this.reduceActions[36] = function(rhs) {
          return new FunctionCall(rhs[0], []);
        };
        this.reduceActions[37] = function(rhs) {
          return new FunctionCall(rhs[0], rhs[2]);
        };
        this.reduceActions[38] = function(rhs) {
          return [rhs[0]];
        };
        this.reduceActions[39] = function(rhs) {
          rhs[2].unshift(rhs[0]);
          return rhs[2];
        };
        this.reduceActions[43] = function(rhs) {
          return new LocationPath(true, []);
        };
        this.reduceActions[44] = function(rhs) {
          rhs[1].absolute = true;
          return rhs[1];
        };
        this.reduceActions[46] = function(rhs) {
          return new LocationPath(false, [rhs[0]]);
        };
        this.reduceActions[47] = function(rhs) {
          rhs[0].steps.push(rhs[2]);
          return rhs[0];
        };
        this.reduceActions[49] = function(rhs) {
          return new Step(rhs[0], rhs[1], []);
        };
        this.reduceActions[50] = function(rhs) {
          return new Step(Step.CHILD, rhs[0], []);
        };
        this.reduceActions[51] = function(rhs) {
          return new Step(rhs[0], rhs[1], rhs[2]);
        };
        this.reduceActions[52] = function(rhs) {
          return new Step(Step.CHILD, rhs[0], rhs[1]);
        };
        this.reduceActions[54] = function(rhs) {
          return [rhs[0]];
        };
        this.reduceActions[55] = function(rhs) {
          rhs[1].unshift(rhs[0]);
          return rhs[1];
        };
        this.reduceActions[56] = function(rhs) {
          if (rhs[0] == "ancestor") {
            return Step.ANCESTOR;
          } else if (rhs[0] == "ancestor-or-self") {
            return Step.ANCESTORORSELF;
          } else if (rhs[0] == "attribute") {
            return Step.ATTRIBUTE;
          } else if (rhs[0] == "child") {
            return Step.CHILD;
          } else if (rhs[0] == "descendant") {
            return Step.DESCENDANT;
          } else if (rhs[0] == "descendant-or-self") {
            return Step.DESCENDANTORSELF;
          } else if (rhs[0] == "following") {
            return Step.FOLLOWING;
          } else if (rhs[0] == "following-sibling") {
            return Step.FOLLOWINGSIBLING;
          } else if (rhs[0] == "namespace") {
            return Step.NAMESPACE;
          } else if (rhs[0] == "parent") {
            return Step.PARENT;
          } else if (rhs[0] == "preceding") {
            return Step.PRECEDING;
          } else if (rhs[0] == "preceding-sibling") {
            return Step.PRECEDINGSIBLING;
          } else if (rhs[0] == "self") {
            return Step.SELF;
          }
          return -1;
        };
        this.reduceActions[57] = function(rhs) {
          return Step.ATTRIBUTE;
        };
        this.reduceActions[59] = function(rhs) {
          if (rhs[0] == "comment") {
            return new NodeTest(NodeTest.COMMENT, undefined);
          } else if (rhs[0] == "text") {
            return new NodeTest(NodeTest.TEXT, undefined);
          } else if (rhs[0] == "processing-instruction") {
            return new NodeTest(NodeTest.PI, undefined);
          } else if (rhs[0] == "node") {
            return new NodeTest(NodeTest.NODE, undefined);
          }
          return new NodeTest(-1, undefined);
        };
        this.reduceActions[60] = function(rhs) {
          return new NodeTest(NodeTest.PI, rhs[2]);
        };
        this.reduceActions[61] = function(rhs) {
          return rhs[1];
        };
        this.reduceActions[63] = function(rhs) {
          rhs[1].absolute = true;
          rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
          return rhs[1];
        };
        this.reduceActions[64] = function(rhs) {
          rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
          rhs[0].steps.push(rhs[2]);
          return rhs[0];
        };
        this.reduceActions[65] = function(rhs) {
          return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
        };
        this.reduceActions[66] = function(rhs) {
          return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
        };
        this.reduceActions[67] = function(rhs) {
          return new VariableReference(rhs[1]);
        };
        this.reduceActions[68] = function(rhs) {
          return new NodeTest(NodeTest.NAMETESTANY, undefined);
        };
        this.reduceActions[69] = function(rhs) {
          var prefix = rhs[0].substring(0, rhs[0].indexOf(":"));
          return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
        };
        this.reduceActions[70] = function(rhs) {
          return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
        };
      };
      XPathParser.actionTable = [
        " s s        sssssssss    s ss  s  ss",
        "                 s                  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "                rrrrr               ",
        " s s        sssssssss    s ss  s  ss",
        "rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
        " s s        sssssssss    s ss  s  ss",
        "                            s       ",
        "                            s       ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "  s                                 ",
        "                            s       ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "a                                   ",
        "r       s                    rr  r  ",
        "r      sr                    rr  r  ",
        "r   s  rr            s       rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrrs  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r  srrrrrrrr         rrrrrrs rr sr  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "                sssss               ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             s      ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "              s                     ",
        "                             s      ",
        "                rrrrr               ",
        " s s        sssssssss    s sss s  ss",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s s        sssssssss      ss  s  ss",
        " s s        sssssssss    s ss  s  ss",
        " s           s  sssss          s  s ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        " s           s  sssss          s  s ",
        " s           s  sssss          s  s ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr sr  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             s      ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             rr     ",
        "                             s      ",
        "                             rs     ",
        "r      sr                    rr  r  ",
        "r   s  rr            s       rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rssrr            rss     rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrr            rrrss   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrsss         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrr   rr  r  ",
        "r   rrrrrrrr         rrrrrr  rr  r  ",
        "                                 r  ",
        "                                 s  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  srrrrrrrr         rrrrrrs rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr  r  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        " s s        sssssssss    s ss  s  ss",
        "r  rrrrrrrrr         rrrrrrr rr rr  ",
        "                             r      "
      ];
      XPathParser.actionTableNumber = [
        " 1 0        /.-,+*)('    & %$  #  \"!",
        "                 J                  ",
        "a  aaaaaaaaa         aaaaaaa aa  a  ",
        "                YYYYY               ",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        "K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        "                            N       ",
        "                            O       ",
        "e  eeeeeeeee         eeeeeee ee ee  ",
        "f  fffffffff         fffffff ff ff  ",
        "d  ddddddddd         ddddddd dd dd  ",
        "B  BBBBBBBBB         BBBBBBB BB BB  ",
        "A  AAAAAAAAA         AAAAAAA AA AA  ",
        "  P                                 ",
        "                            Q       ",
        " 1           .  +*)('          #  \" ",
        "b  bbbbbbbbb         bbbbbbb bb  b  ",
        "                                    ",
        "!       S                    !!  !  ",
        "\"      T\"                    \"\"  \"  ",
        "$   V  $$            U       $$  $  ",
        "&   &ZY&&            &XW     &&  &  ",
        ")   )))))            )))\\[   ))  )  ",
        ".   ....._^]         .....   ..  .  ",
        "1   11111111         11111   11  1  ",
        "5   55555555         55555`  55  5  ",
        "7   77777777         777777  77  7  ",
        "9   99999999         999999  99  9  ",
        ":  c::::::::         ::::::b :: a:  ",
        "I  fIIIIIIII         IIIIIIe II  I  ",
        "=  =========         ======= == ==  ",
        "?  ?????????         ??????? ?? ??  ",
        "C  CCCCCCCCC         CCCCCCC CC CC  ",
        "J   JJJJJJJJ         JJJJJJ  JJ  J  ",
        "M   MMMMMMMM         MMMMMM  MM  M  ",
        "N  NNNNNNNNN         NNNNNNN NN  N  ",
        "P  PPPPPPPPP         PPPPPPP PP  P  ",
        "                +*)('               ",
        "R  RRRRRRRRR         RRRRRRR RR aR  ",
        "U  UUUUUUUUU         UUUUUUU UU  U  ",
        "Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
        "c  ccccccccc         ccccccc cc cc  ",
        "                             j      ",
        "L  fLLLLLLLL         LLLLLLe LL  L  ",
        "6   66666666         66666   66  6  ",
        "              k                     ",
        "                             l      ",
        "                XXXXX               ",
        " 1 0        /.-,+*)('    & %$m #  \"!",
        "_  f________         ______e __  _  ",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1 0        /.-,+*)('      %$  #  \"!",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        " 1           .  +*)('          #  \" ",
        " 1           .  +*)('          #  \" ",
        ">  >>>>>>>>>         >>>>>>> >> >>  ",
        " 1           .  +*)('          #  \" ",
        " 1           .  +*)('          #  \" ",
        "Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
        "V  VVVVVVVVV         VVVVVVV VV aV  ",
        "T  TTTTTTTTT         TTTTTTT TT  T  ",
        "@  @@@@@@@@@         @@@@@@@ @@ @@  ",
        "                             \x87      ",
        "[  [[[[[[[[[         [[[[[[[ [[ [[  ",
        "D  DDDDDDDDD         DDDDDDD DD DD  ",
        "                             HH     ",
        "                             \x88      ",
        "                             F\x89     ",
        "#      T#                    ##  #  ",
        "%   V  %%            U       %%  %  ",
        "'   'ZY''            'XW     ''  '  ",
        "(   (ZY((            (XW     ((  (  ",
        "+   +++++            +++\\[   ++  +  ",
        "*   *****            ***\\[   **  *  ",
        "-   -----            ---\\[   --  -  ",
        ",   ,,,,,            ,,,\\[   ,,  ,  ",
        "0   00000_^]         00000   00  0  ",
        "/   /////_^]         /////   //  /  ",
        "2   22222222         22222   22  2  ",
        "3   33333333         33333   33  3  ",
        "4   44444444         44444   44  4  ",
        "8   88888888         888888  88  8  ",
        "                                 ^  ",
        "                                 \x8a  ",
        ";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
        "<  f<<<<<<<<         <<<<<<e <<  <  ",
        "O  OOOOOOOOO         OOOOOOO OO  O  ",
        "`  `````````         ``````` ``  `  ",
        "S  SSSSSSSSS         SSSSSSS SS  S  ",
        "W  WWWWWWWWW         WWWWWWW WW  W  ",
        "\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
        "E  EEEEEEEEE         EEEEEEE EE EE  ",
        " 1 0        /.-,+*)('    & %$  #  \"!",
        "]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
        "                             G      "
      ];
      XPathParser.gotoTable = [
        "3456789:;<=>?@ AB  CDEFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "L456789:;<=>?@ AB  CDEFGH IJ ",
        "            M        EFGH IJ ",
        "       N;<=>?@ AB  CDEFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "            S        EFGH IJ ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "              e              ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                        h  J ",
        "              i          j   ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "o456789:;<=>?@ ABpqCDEFGH IJ ",
        "                             ",
        "  r6789:;<=>?@ AB  CDEFGH IJ ",
        "   s789:;<=>?@ AB  CDEFGH IJ ",
        "    t89:;<=>?@ AB  CDEFGH IJ ",
        "    u89:;<=>?@ AB  CDEFGH IJ ",
        "     v9:;<=>?@ AB  CDEFGH IJ ",
        "     w9:;<=>?@ AB  CDEFGH IJ ",
        "     x9:;<=>?@ AB  CDEFGH IJ ",
        "     y9:;<=>?@ AB  CDEFGH IJ ",
        "      z:;<=>?@ AB  CDEFGH IJ ",
        "      {:;<=>?@ AB  CDEFGH IJ ",
        "       |;<=>?@ AB  CDEFGH IJ ",
        "       };<=>?@ AB  CDEFGH IJ ",
        "       ~;<=>?@ AB  CDEFGH IJ ",
        "         \x7f=>?@ AB  CDEFGH IJ ",
        "\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
        "            \x82        EFGH IJ ",
        "            \x83        EFGH IJ ",
        "                             ",
        "                     \x84 GH IJ ",
        "                     \x85 GH IJ ",
        "              i          \x86   ",
        "              i          \x87   ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "                             ",
        "o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
        "                             ",
        "                             "
      ];
      XPathParser.productions = [
        [1, 1, 2],
        [2, 1, 3],
        [3, 1, 4],
        [3, 3, 3, -9, 4],
        [4, 1, 5],
        [4, 3, 4, -8, 5],
        [5, 1, 6],
        [5, 3, 5, -22, 6],
        [5, 3, 5, -5, 6],
        [6, 1, 7],
        [6, 3, 6, -23, 7],
        [6, 3, 6, -24, 7],
        [6, 3, 6, -6, 7],
        [6, 3, 6, -7, 7],
        [7, 1, 8],
        [7, 3, 7, -25, 8],
        [7, 3, 7, -26, 8],
        [8, 1, 9],
        [8, 3, 8, -12, 9],
        [8, 3, 8, -11, 9],
        [8, 3, 8, -10, 9],
        [9, 1, 10],
        [9, 2, -26, 9],
        [10, 1, 11],
        [10, 3, 10, -27, 11],
        [11, 1, 12],
        [11, 1, 13],
        [11, 3, 13, -28, 14],
        [11, 3, 13, -4, 14],
        [13, 1, 15],
        [13, 2, 13, 16],
        [15, 1, 17],
        [15, 3, -29, 2, -30],
        [15, 1, -15],
        [15, 1, -16],
        [15, 1, 18],
        [18, 3, -13, -29, -30],
        [18, 4, -13, -29, 19, -30],
        [19, 1, 20],
        [19, 3, 20, -31, 19],
        [20, 1, 2],
        [12, 1, 14],
        [12, 1, 21],
        [21, 1, -28],
        [21, 2, -28, 14],
        [21, 1, 22],
        [14, 1, 23],
        [14, 3, 14, -28, 23],
        [14, 1, 24],
        [23, 2, 25, 26],
        [23, 1, 26],
        [23, 3, 25, 26, 27],
        [23, 2, 26, 27],
        [23, 1, 28],
        [27, 1, 16],
        [27, 2, 16, 27],
        [25, 2, -14, -3],
        [25, 1, -32],
        [26, 1, 29],
        [26, 3, -20, -29, -30],
        [26, 4, -21, -29, -15, -30],
        [16, 3, -33, 30, -34],
        [30, 1, 2],
        [22, 2, -4, 14],
        [24, 3, 14, -4, 23],
        [28, 1, -35],
        [28, 1, -2],
        [17, 2, -36, -18],
        [29, 1, -17],
        [29, 1, -19],
        [29, 1, -18]
      ];
      XPathParser.DOUBLEDOT = 2;
      XPathParser.DOUBLECOLON = 3;
      XPathParser.DOUBLESLASH = 4;
      XPathParser.NOTEQUAL = 5;
      XPathParser.LESSTHANOREQUAL = 6;
      XPathParser.GREATERTHANOREQUAL = 7;
      XPathParser.AND = 8;
      XPathParser.OR = 9;
      XPathParser.MOD = 10;
      XPathParser.DIV = 11;
      XPathParser.MULTIPLYOPERATOR = 12;
      XPathParser.FUNCTIONNAME = 13;
      XPathParser.AXISNAME = 14;
      XPathParser.LITERAL = 15;
      XPathParser.NUMBER = 16;
      XPathParser.ASTERISKNAMETEST = 17;
      XPathParser.QNAME = 18;
      XPathParser.NCNAMECOLONASTERISK = 19;
      XPathParser.NODETYPE = 20;
      XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
      XPathParser.EQUALS = 22;
      XPathParser.LESSTHAN = 23;
      XPathParser.GREATERTHAN = 24;
      XPathParser.PLUS = 25;
      XPathParser.MINUS = 26;
      XPathParser.BAR = 27;
      XPathParser.SLASH = 28;
      XPathParser.LEFTPARENTHESIS = 29;
      XPathParser.RIGHTPARENTHESIS = 30;
      XPathParser.COMMA = 31;
      XPathParser.AT = 32;
      XPathParser.LEFTBRACKET = 33;
      XPathParser.RIGHTBRACKET = 34;
      XPathParser.DOT = 35;
      XPathParser.DOLLAR = 36;
      XPathParser.prototype.tokenize = function(s1) {
        var types = [];
        var values = [];
        var s = s1 + '\0';
        var pos = 0;
        var c = s.charAt(pos++);
        while (1) {
          while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
            c = s.charAt(pos++);
          }
          if (c == '\0' || pos >= s.length) {
            break;
          }
          if (c == '(') {
            types.push(XPathParser.LEFTPARENTHESIS);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == ')') {
            types.push(XPathParser.RIGHTPARENTHESIS);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '[') {
            types.push(XPathParser.LEFTBRACKET);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == ']') {
            types.push(XPathParser.RIGHTBRACKET);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '@') {
            types.push(XPathParser.AT);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == ',') {
            types.push(XPathParser.COMMA);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '|') {
            types.push(XPathParser.BAR);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '+') {
            types.push(XPathParser.PLUS);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '-') {
            types.push(XPathParser.MINUS);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '=') {
            types.push(XPathParser.EQUALS);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '$') {
            types.push(XPathParser.DOLLAR);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == '.') {
            c = s.charAt(pos++);
            if (c == '.') {
              types.push(XPathParser.DOUBLEDOT);
              values.push("..");
              c = s.charAt(pos++);
              continue;
            }
            if (c >= '0' && c <= '9') {
              var number = "." + c;
              c = s.charAt(pos++);
              while (c >= '0' && c <= '9') {
                number += c;
                c = s.charAt(pos++);
              }
              types.push(XPathParser.NUMBER);
              values.push(number);
              continue;
            }
            types.push(XPathParser.DOT);
            values.push('.');
            continue;
          }
          if (c == '\'' || c == '"') {
            var delimiter = c;
            var literal = "";
            while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
              literal += c;
              pos += 1;
            }
            if (c !== delimiter) {
              throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
            }
            pos += 1;
            types.push(XPathParser.LITERAL);
            values.push(literal);
            c = s.charAt(pos++);
            continue;
          }
          if (c >= '0' && c <= '9') {
            var number = c;
            c = s.charAt(pos++);
            while (c >= '0' && c <= '9') {
              number += c;
              c = s.charAt(pos++);
            }
            if (c == '.') {
              if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
                number += c;
                number += s.charAt(pos++);
                c = s.charAt(pos++);
                while (c >= '0' && c <= '9') {
                  number += c;
                  c = s.charAt(pos++);
                }
              }
            }
            types.push(XPathParser.NUMBER);
            values.push(number);
            continue;
          }
          if (c == '*') {
            if (types.length > 0) {
              var last = types[types.length - 1];
              if (last != XPathParser.AT &&
                last != XPathParser.DOUBLECOLON &&
                last != XPathParser.LEFTPARENTHESIS &&
                last != XPathParser.LEFTBRACKET &&
                last != XPathParser.AND &&
                last != XPathParser.OR &&
                last != XPathParser.MOD &&
                last != XPathParser.DIV &&
                last != XPathParser.MULTIPLYOPERATOR &&
                last != XPathParser.SLASH &&
                last != XPathParser.DOUBLESLASH &&
                last != XPathParser.BAR &&
                last != XPathParser.PLUS &&
                last != XPathParser.MINUS &&
                last != XPathParser.EQUALS &&
                last != XPathParser.NOTEQUAL &&
                last != XPathParser.LESSTHAN &&
                last != XPathParser.LESSTHANOREQUAL &&
                last != XPathParser.GREATERTHAN &&
                last != XPathParser.GREATERTHANOREQUAL) {
                types.push(XPathParser.MULTIPLYOPERATOR);
                values.push(c);
                c = s.charAt(pos++);
                continue;
              }
            }
            types.push(XPathParser.ASTERISKNAMETEST);
            values.push(c);
            c = s.charAt(pos++);
            continue;
          }
          if (c == ':') {
            if (s.charAt(pos) == ':') {
              types.push(XPathParser.DOUBLECOLON);
              values.push("::");
              pos++;
              c = s.charAt(pos++);
              continue;
            }
          }
          if (c == '/') {
            c = s.charAt(pos++);
            if (c == '/') {
              types.push(XPathParser.DOUBLESLASH);
              values.push("//");
              c = s.charAt(pos++);
              continue;
            }
            types.push(XPathParser.SLASH);
            values.push('/');
            continue;
          }
          if (c == '!') {
            if (s.charAt(pos) == '=') {
              types.push(XPathParser.NOTEQUAL);
              values.push("!=");
              pos++;
              c = s.charAt(pos++);
              continue;
            }
          }
          if (c == '<') {
            if (s.charAt(pos) == '=') {
              types.push(XPathParser.LESSTHANOREQUAL);
              values.push("<=");
              pos++;
              c = s.charAt(pos++);
              continue;
            }
            types.push(XPathParser.LESSTHAN);
            values.push('<');
            c = s.charAt(pos++);
            continue;
          }
          if (c == '>') {
            if (s.charAt(pos) == '=') {
              types.push(XPathParser.GREATERTHANOREQUAL);
              values.push(">=");
              pos++;
              c = s.charAt(pos++);
              continue;
            }
            types.push(XPathParser.GREATERTHAN);
            values.push('>');
            c = s.charAt(pos++);
            continue;
          }
          if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
            var name = c;
            c = s.charAt(pos++);
            while (Utilities.isNCNameChar(c.charCodeAt(0))) {
              name += c;
              c = s.charAt(pos++);
            }
            if (types.length > 0) {
              var last = types[types.length - 1];
              if (last != XPathParser.AT &&
                last != XPathParser.DOUBLECOLON &&
                last != XPathParser.LEFTPARENTHESIS &&
                last != XPathParser.LEFTBRACKET &&
                last != XPathParser.AND &&
                last != XPathParser.OR &&
                last != XPathParser.MOD &&
                last != XPathParser.DIV &&
                last != XPathParser.MULTIPLYOPERATOR &&
                last != XPathParser.SLASH &&
                last != XPathParser.DOUBLESLASH &&
                last != XPathParser.BAR &&
                last != XPathParser.PLUS &&
                last != XPathParser.MINUS &&
                last != XPathParser.EQUALS &&
                last != XPathParser.NOTEQUAL &&
                last != XPathParser.LESSTHAN &&
                last != XPathParser.LESSTHANOREQUAL &&
                last != XPathParser.GREATERTHAN &&
                last != XPathParser.GREATERTHANOREQUAL) {
                if (name == "and") {
                  types.push(XPathParser.AND);
                  values.push(name);
                  continue;
                }
                if (name == "or") {
                  types.push(XPathParser.OR);
                  values.push(name);
                  continue;
                }
                if (name == "mod") {
                  types.push(XPathParser.MOD);
                  values.push(name);
                  continue;
                }
                if (name == "div") {
                  types.push(XPathParser.DIV);
                  values.push(name);
                  continue;
                }
              }
            }
            if (c == ':') {
              if (s.charAt(pos) == '*') {
                types.push(XPathParser.NCNAMECOLONASTERISK);
                values.push(name + ":*");
                pos++;
                c = s.charAt(pos++);
                continue;
              }
              if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
                name += ':';
                c = s.charAt(pos++);
                while (Utilities.isNCNameChar(c.charCodeAt(0))) {
                  name += c;
                  c = s.charAt(pos++);
                }
                if (c == '(') {
                  types.push(XPathParser.FUNCTIONNAME);
                  values.push(name);
                  continue;
                }
                types.push(XPathParser.QNAME);
                values.push(name);
                continue;
              }
              if (s.charAt(pos) == ':') {
                types.push(XPathParser.AXISNAME);
                values.push(name);
                continue;
              }
            }
            if (c == '(') {
              if (name == "comment" || name == "text" || name == "node") {
                types.push(XPathParser.NODETYPE);
                values.push(name);
                continue;
              }
              if (name == "processing-instruction") {
                if (s.charAt(pos) == ')') {
                  types.push(XPathParser.NODETYPE);
                } else {
                  types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
                }
                values.push(name);
                continue;
              }
              types.push(XPathParser.FUNCTIONNAME);
              values.push(name);
              continue;
            }
            types.push(XPathParser.QNAME);
            values.push(name);
            continue;
          }
          throw new Error("Unexpected character " + c);
        }
        types.push(1);
        values.push("[EOF]");
        return [types, values];
      };
      XPathParser.SHIFT = 's';
      XPathParser.REDUCE = 'r';
      XPathParser.ACCEPT = 'a';
      XPathParser.prototype.parse = function(s) {
        var types;
        var values;
        var res = this.tokenize(s);
        if (res == undefined) {
          return undefined;
        }
        types = res[0];
        values = res[1];
        var tokenPos = 0;
        var state = [];
        var tokenType = [];
        var tokenValue = [];
        var s;
        var a;
        var t;
        state.push(0);
        tokenType.push(1);
        tokenValue.push("_S");
        a = types[tokenPos];
        t = values[tokenPos++];
        while (1) {
          s = state[state.length - 1];
          switch (XPathParser.actionTable[s].charAt(a - 1)) {
            case XPathParser.SHIFT:
              tokenType.push(-a);
              tokenValue.push(t);
              state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
              a = types[tokenPos];
              t = values[tokenPos++];
              break;
            case XPathParser.REDUCE:
              var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
              var rhs = [];
              for (var i = 0; i < num; i++) {
                tokenType.pop();
                rhs.unshift(tokenValue.pop());
                state.pop();
              }
              var s_ = state[state.length - 1];
              tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
              if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
                tokenValue.push(rhs[0]);
              } else {
                tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
              }
              state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
              break;
            case XPathParser.ACCEPT:
              return new XPath(tokenValue.pop());
            default:
              throw new Error("XPath parse error");
          }
        }
      };
      XPath.prototype = new Object();
      XPath.prototype.constructor = XPath;
      XPath.superclass = Object.prototype;

      function XPath(e) {
        this.expression = e;
      }
      XPath.prototype.toString = function() {
        return this.expression.toString();
      };
      XPath.prototype.evaluate = function(c) {
        c.contextNode = c.expressionContextNode;
        c.contextSize = 1;
        c.contextPosition = 1;
        c.caseInsensitive = false;
        if (c.contextNode != null) {
          var doc = c.contextNode;
          if (doc.nodeType != 9) {
            doc = doc.ownerDocument;
          }
          try {
            c.caseInsensitive = doc.implementation.hasFeature("HTML", "2.0");
          } catch (e) {
            c.caseInsensitive = true;
          }
        }
        return this.expression.evaluate(c);
      };
      XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
      XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";
      Expression.prototype = new Object();
      Expression.prototype.constructor = Expression;
      Expression.superclass = Object.prototype;

      function Expression() {}
      Expression.prototype.init = function() {};
      Expression.prototype.toString = function() {
        return "<Expression>";
      };
      Expression.prototype.evaluate = function(c) {
        throw new Error("Could not evaluate expression.");
      };
      UnaryOperation.prototype = new Expression();
      UnaryOperation.prototype.constructor = UnaryOperation;
      UnaryOperation.superclass = Expression.prototype;

      function UnaryOperation(rhs) {
        if (arguments.length > 0) {
          this.init(rhs);
        }
      }
      UnaryOperation.prototype.init = function(rhs) {
        this.rhs = rhs;
      };
      UnaryMinusOperation.prototype = new UnaryOperation();
      UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
      UnaryMinusOperation.superclass = UnaryOperation.prototype;

      function UnaryMinusOperation(rhs) {
        if (arguments.length > 0) {
          this.init(rhs);
        }
      }
      UnaryMinusOperation.prototype.init = function(rhs) {
        UnaryMinusOperation.superclass.init.call(this, rhs);
      };
      UnaryMinusOperation.prototype.evaluate = function(c) {
        return this.rhs.evaluate(c).number().negate();
      };
      UnaryMinusOperation.prototype.toString = function() {
        return "-" + this.rhs.toString();
      };
      BinaryOperation.prototype = new Expression();
      BinaryOperation.prototype.constructor = BinaryOperation;
      BinaryOperation.superclass = Expression.prototype;

      function BinaryOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      BinaryOperation.prototype.init = function(lhs, rhs) {
        this.lhs = lhs;
        this.rhs = rhs;
      };
      OrOperation.prototype = new BinaryOperation();
      OrOperation.prototype.constructor = OrOperation;
      OrOperation.superclass = BinaryOperation.prototype;

      function OrOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      OrOperation.prototype.init = function(lhs, rhs) {
        OrOperation.superclass.init.call(this, lhs, rhs);
      };
      OrOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
      };
      OrOperation.prototype.evaluate = function(c) {
        var b = this.lhs.evaluate(c).bool();
        if (b.booleanValue()) {
          return b;
        }
        return this.rhs.evaluate(c).bool();
      };
      AndOperation.prototype = new BinaryOperation();
      AndOperation.prototype.constructor = AndOperation;
      AndOperation.superclass = BinaryOperation.prototype;

      function AndOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      AndOperation.prototype.init = function(lhs, rhs) {
        AndOperation.superclass.init.call(this, lhs, rhs);
      };
      AndOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
      };
      AndOperation.prototype.evaluate = function(c) {
        var b = this.lhs.evaluate(c).bool();
        if (!b.booleanValue()) {
          return b;
        }
        return this.rhs.evaluate(c).bool();
      };
      EqualsOperation.prototype = new BinaryOperation();
      EqualsOperation.prototype.constructor = EqualsOperation;
      EqualsOperation.superclass = BinaryOperation.prototype;

      function EqualsOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      EqualsOperation.prototype.init = function(lhs, rhs) {
        EqualsOperation.superclass.init.call(this, lhs, rhs);
      };
      EqualsOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
      };
      EqualsOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
      };
      NotEqualOperation.prototype = new BinaryOperation();
      NotEqualOperation.prototype.constructor = NotEqualOperation;
      NotEqualOperation.superclass = BinaryOperation.prototype;

      function NotEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      NotEqualOperation.prototype.init = function(lhs, rhs) {
        NotEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      NotEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
      };
      NotEqualOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
      };
      LessThanOperation.prototype = new BinaryOperation();
      LessThanOperation.prototype.constructor = LessThanOperation;
      LessThanOperation.superclass = BinaryOperation.prototype;

      function LessThanOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      LessThanOperation.prototype.init = function(lhs, rhs) {
        LessThanOperation.superclass.init.call(this, lhs, rhs);
      };
      LessThanOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
      };
      LessThanOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
      };
      GreaterThanOperation.prototype = new BinaryOperation();
      GreaterThanOperation.prototype.constructor = GreaterThanOperation;
      GreaterThanOperation.superclass = BinaryOperation.prototype;

      function GreaterThanOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      GreaterThanOperation.prototype.init = function(lhs, rhs) {
        GreaterThanOperation.superclass.init.call(this, lhs, rhs);
      };
      GreaterThanOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
      };
      GreaterThanOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
      };
      LessThanOrEqualOperation.prototype = new BinaryOperation();
      LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
      LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

      function LessThanOrEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
        LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      LessThanOrEqualOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
      };
      LessThanOrEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
      };
      GreaterThanOrEqualOperation.prototype = new BinaryOperation();
      GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
      GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

      function GreaterThanOrEqualOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
        GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
      };
      GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
      };
      GreaterThanOrEqualOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
      };
      PlusOperation.prototype = new BinaryOperation();
      PlusOperation.prototype.constructor = PlusOperation;
      PlusOperation.superclass = BinaryOperation.prototype;

      function PlusOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      PlusOperation.prototype.init = function(lhs, rhs) {
        PlusOperation.superclass.init.call(this, lhs, rhs);
      };
      PlusOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
      };
      PlusOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
      };
      MinusOperation.prototype = new BinaryOperation();
      MinusOperation.prototype.constructor = MinusOperation;
      MinusOperation.superclass = BinaryOperation.prototype;

      function MinusOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      MinusOperation.prototype.init = function(lhs, rhs) {
        MinusOperation.superclass.init.call(this, lhs, rhs);
      };
      MinusOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
      };
      MinusOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
      };
      MultiplyOperation.prototype = new BinaryOperation();
      MultiplyOperation.prototype.constructor = MultiplyOperation;
      MultiplyOperation.superclass = BinaryOperation.prototype;

      function MultiplyOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      MultiplyOperation.prototype.init = function(lhs, rhs) {
        MultiplyOperation.superclass.init.call(this, lhs, rhs);
      };
      MultiplyOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
      };
      MultiplyOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
      };
      DivOperation.prototype = new BinaryOperation();
      DivOperation.prototype.constructor = DivOperation;
      DivOperation.superclass = BinaryOperation.prototype;

      function DivOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      DivOperation.prototype.init = function(lhs, rhs) {
        DivOperation.superclass.init.call(this, lhs, rhs);
      };
      DivOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
      };
      DivOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
      };
      ModOperation.prototype = new BinaryOperation();
      ModOperation.prototype.constructor = ModOperation;
      ModOperation.superclass = BinaryOperation.prototype;

      function ModOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      ModOperation.prototype.init = function(lhs, rhs) {
        ModOperation.superclass.init.call(this, lhs, rhs);
      };
      ModOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
      };
      ModOperation.prototype.toString = function() {
        return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
      };
      BarOperation.prototype = new BinaryOperation();
      BarOperation.prototype.constructor = BarOperation;
      BarOperation.superclass = BinaryOperation.prototype;

      function BarOperation(lhs, rhs) {
        if (arguments.length > 0) {
          this.init(lhs, rhs);
        }
      }
      BarOperation.prototype.init = function(lhs, rhs) {
        BarOperation.superclass.init.call(this, lhs, rhs);
      };
      BarOperation.prototype.evaluate = function(c) {
        return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
      };
      BarOperation.prototype.toString = function() {
        return this.lhs.toString() + " | " + this.rhs.toString();
      };
      PathExpr.prototype = new Expression();
      PathExpr.prototype.constructor = PathExpr;
      PathExpr.superclass = Expression.prototype;

      function PathExpr(filter, filterPreds, locpath) {
        if (arguments.length > 0) {
          this.init(filter, filterPreds, locpath);
        }
      }
      PathExpr.prototype.init = function(filter, filterPreds, locpath) {
        PathExpr.superclass.init.call(this);
        this.filter = filter;
        this.filterPredicates = filterPreds;
        this.locationPath = locpath;
      };

      function findRoot(node) {
        while (node && node.parentNode) {
          node = node.parentNode;
        }
        return node;
      }
      PathExpr.prototype.evaluate = function(c) {
        var nodes;
        var xpc = new XPathContext();
        xpc.variableResolver = c.variableResolver;
        xpc.functionResolver = c.functionResolver;
        xpc.namespaceResolver = c.namespaceResolver;
        xpc.expressionContextNode = c.expressionContextNode;
        xpc.virtualRoot = c.virtualRoot;
        xpc.caseInsensitive = c.caseInsensitive;
        if (this.filter == null) {
          nodes = [c.contextNode];
        } else {
          var ns = this.filter.evaluate(c);
          if (!Utilities.instance_of(ns, XNodeSet)) {
            if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
              throw new Error("Path expression filter must evaluate to a nodset if predicates or location path are used");
            }
            return ns;
          }
          nodes = ns.toUnsortedArray();
          if (this.filterPredicates != null) {
            for (var j = 0; j < this.filterPredicates.length; j++) {
              var pred = this.filterPredicates[j];
              var newNodes = [];
              xpc.contextSize = nodes.length;
              for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
                xpc.contextNode = nodes[xpc.contextPosition - 1];
                if (this.predicateMatches(pred, xpc)) {
                  newNodes.push(xpc.contextNode);
                }
              }
              nodes = newNodes;
            }
          }
        }
        if (this.locationPath != null) {
          if (this.locationPath.absolute) {
            if (nodes[0].nodeType != 9) {
              if (xpc.virtualRoot != null) {
                nodes = [xpc.virtualRoot];
              } else {
                if (nodes[0].ownerDocument == null) {
                  var n = nodes[0];
                  while (n.parentNode != null) {
                    n = n.parentNode;
                  }
                  nodes = [n];
                } else {
                  nodes = [nodes[0].ownerDocument];
                }
              }
            } else {
              nodes = [nodes[0]];
            }
          }
          for (var i = 0; i < this.locationPath.steps.length; i++) {
            var step = this.locationPath.steps[i];
            var newNodes = [];
            for (var j = 0; j < nodes.length; j++) {
              xpc.contextNode = nodes[j];
              switch (step.axis) {
                case Step.ANCESTOR:
                  if (xpc.contextNode === xpc.virtualRoot) {
                    break;
                  }
                  var m;
                  if (xpc.contextNode.nodeType == 2) {
                    m = this.getOwnerElement(xpc.contextNode);
                  } else {
                    m = xpc.contextNode.parentNode;
                  }
                  while (m != null) {
                    if (step.nodeTest.matches(m, xpc)) {
                      newNodes.push(m);
                    }
                    if (m === xpc.virtualRoot) {
                      break;
                    }
                    m = m.parentNode;
                  }
                  break;
                case Step.ANCESTORORSELF:
                  for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 ? this.getOwnerElement(m) : m.parentNode) {
                    if (step.nodeTest.matches(m, xpc)) {
                      newNodes.push(m);
                    }
                    if (m === xpc.virtualRoot) {
                      break;
                    }
                  }
                  break;
                case Step.ATTRIBUTE:
                  var nnm = xpc.contextNode.attributes;
                  if (nnm != null) {
                    for (var k = 0; k < nnm.length; k++) {
                      var m = nnm.item(k);
                      if (step.nodeTest.matches(m, xpc)) {
                        newNodes.push(m);
                      }
                    }
                  }
                  break;
                case Step.CHILD:
                  for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
                    if (step.nodeTest.matches(m, xpc)) {
                      newNodes.push(m);
                    }
                  }
                  break;
                case Step.DESCENDANT:
                  var st = [xpc.contextNode.firstChild];
                  while (st.length > 0) {
                    for (var m = st.pop(); m != null;) {
                      if (step.nodeTest.matches(m, xpc)) {
                        newNodes.push(m);
                      }
                      if (m.firstChild != null) {
                        st.push(m.nextSibling);
                        m = m.firstChild;
                      } else {
                        m = m.nextSibling;
                      }
                    }
                  }
                  break;
                case Step.DESCENDANTORSELF:
                  if (step.nodeTest.matches(xpc.contextNode, xpc)) {
                    newNodes.push(xpc.contextNode);
                  }
                  var st = [xpc.contextNode.firstChild];
                  while (st.length > 0) {
                    for (var m = st.pop(); m != null;) {
                      if (step.nodeTest.matches(m, xpc)) {
                        newNodes.push(m);
                      }
                      if (m.firstChild != null) {
                        st.push(m.nextSibling);
                        m = m.firstChild;
                      } else {
                        m = m.nextSibling;
                      }
                    }
                  }
                  break;
                case Step.FOLLOWING:
                  if (xpc.contextNode === xpc.virtualRoot) {
                    break;
                  }
                  var st = [];
                  if (xpc.contextNode.firstChild != null) {
                    st.unshift(xpc.contextNode.firstChild);
                  } else {
                    st.unshift(xpc.contextNode.nextSibling);
                  }
                  for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 && m !== xpc.virtualRoot; m = m.parentNode) {
                    st.unshift(m.nextSibling);
                  }
                  do {
                    for (var m = st.pop(); m != null;) {
                      if (step.nodeTest.matches(m, xpc)) {
                        newNodes.push(m);
                      }
                      if (m.firstChild != null) {
                        st.push(m.nextSibling);
                        m = m.firstChild;
                      } else {
                        m = m.nextSibling;
                      }
                    }
                  } while (st.length > 0);
                  break;
                case Step.FOLLOWINGSIBLING:
                  if (xpc.contextNode === xpc.virtualRoot) {
                    break;
                  }
                  for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
                    if (step.nodeTest.matches(m, xpc)) {
                      newNodes.push(m);
                    }
                  }
                  break;
                case Step.NAMESPACE:
                  var n = {};
                  if (xpc.contextNode.nodeType == 1) {
                    n["xml"] = XPath.XML_NAMESPACE_URI;
                    n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
                    for (var m = xpc.contextNode; m != null && m.nodeType == 1; m = m.parentNode) {
                      for (var k = 0; k < m.attributes.length; k++) {
                        var attr = m.attributes.item(k);
                        var nm = String(attr.name);
                        if (nm == "xmlns") {
                          if (n[""] == undefined) {
                            n[""] = attr.value;
                          }
                        } else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
                          var pre = nm.substring(6, nm.length);
                          if (n[pre] == undefined) {
                            n[pre] = attr.value;
                          }
                        }
                      }
                    }
                    for (var pre in n) {
                      var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
                      if (step.nodeTest.matches(nsn, xpc)) {
                        newNodes.push(nsn);
                      }
                    }
                  }
                  break;
                case Step.PARENT:
                  m = null;
                  if (xpc.contextNode !== xpc.virtualRoot) {
                    if (xpc.contextNode.nodeType == 2) {
                      m = this.getOwnerElement(xpc.contextNode);
                    } else {
                      m = xpc.contextNode.parentNode;
                    }
                  }
                  if (m != null && step.nodeTest.matches(m, xpc)) {
                    newNodes.push(m);
                  }
                  break;
                case Step.PRECEDING:
                  var st;
                  if (xpc.virtualRoot != null) {
                    st = [xpc.virtualRoot];
                  } else {
                    st = [findRoot(xpc.contextNode)];
                  }
                  outer: while (st.length > 0) {
                    for (var m = st.pop(); m != null;) {
                      if (m == xpc.contextNode) {
                        break outer;
                      }
                      if (step.nodeTest.matches(m, xpc)) {
                        newNodes.unshift(m);
                      }
                      if (m.firstChild != null) {
                        st.push(m.nextSibling);
                        m = m.firstChild;
                      } else {
                        m = m.nextSibling;
                      }
                    }
                  }
                  break;
                case Step.PRECEDINGSIBLING:
                  if (xpc.contextNode === xpc.virtualRoot) {
                    break;
                  }
                  for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
                    if (step.nodeTest.matches(m, xpc)) {
                      newNodes.push(m);
                    }
                  }
                  break;
                case Step.SELF:
                  if (step.nodeTest.matches(xpc.contextNode, xpc)) {
                    newNodes.push(xpc.contextNode);
                  }
                  break;
                default:
              }
            }
            nodes = newNodes;
            for (var j = 0; j < step.predicates.length; j++) {
              var pred = step.predicates[j];
              var newNodes = [];
              xpc.contextSize = nodes.length;
              for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {
                xpc.contextNode = nodes[xpc.contextPosition - 1];
                if (this.predicateMatches(pred, xpc)) {
                  newNodes.push(xpc.contextNode);
                } else {}
              }
              nodes = newNodes;
            }
          }
        }
        var ns = new XNodeSet();
        ns.addArray(nodes);
        return ns;
      };
      PathExpr.prototype.predicateMatches = function(pred, c) {
        var res = pred.evaluate(c);
        if (Utilities.instance_of(res, XNumber)) {
          return c.contextPosition == res.numberValue();
        }
        return res.booleanValue();
      };
      PathExpr.prototype.toString = function() {
        if (this.filter != undefined) {
          var s = this.filter.toString();
          if (Utilities.instance_of(this.filter, XString)) {
            s = "'" + s + "'";
          }
          if (this.filterPredicates != undefined) {
            for (var i = 0; i < this.filterPredicates.length; i++) {
              s = s + "[" + this.filterPredicates[i].toString() + "]";
            }
          }
          if (this.locationPath != undefined) {
            if (!this.locationPath.absolute) {
              s += "/";
            }
            s += this.locationPath.toString();
          }
          return s;
        }
        return this.locationPath.toString();
      };
      PathExpr.prototype.getOwnerElement = function(n) {
        if (n.ownerElement) {
          return n.ownerElement;
        }
        try {
          if (n.selectSingleNode) {
            return n.selectSingleNode("..");
          }
        } catch (e) {}
        var doc = n.nodeType == 9 ?
          n :
          n.ownerDocument;
        var elts = doc.getElementsByTagName("*");
        for (var i = 0; i < elts.length; i++) {
          var elt = elts.item(i);
          var nnm = elt.attributes;
          for (var j = 0; j < nnm.length; j++) {
            var an = nnm.item(j);
            if (an === n) {
              return elt;
            }
          }
        }
        return null;
      };
      LocationPath.prototype = new Object();
      LocationPath.prototype.constructor = LocationPath;
      LocationPath.superclass = Object.prototype;

      function LocationPath(abs, steps) {
        if (arguments.length > 0) {
          this.init(abs, steps);
        }
      }
      LocationPath.prototype.init = function(abs, steps) {
        this.absolute = abs;
        this.steps = steps;
      };
      LocationPath.prototype.toString = function() {
        var s;
        if (this.absolute) {
          s = "/";
        } else {
          s = "";
        }
        for (var i = 0; i < this.steps.length; i++) {
          if (i != 0) {
            s += "/";
          }
          s += this.steps[i].toString();
        }
        return s;
      };
      Step.prototype = new Object();
      Step.prototype.constructor = Step;
      Step.superclass = Object.prototype;

      function Step(axis, nodetest, preds) {
        if (arguments.length > 0) {
          this.init(axis, nodetest, preds);
        }
      }
      Step.prototype.init = function(axis, nodetest, preds) {
        this.axis = axis;
        this.nodeTest = nodetest;
        this.predicates = preds;
      };
      Step.prototype.toString = function() {
        var s;
        switch (this.axis) {
          case Step.ANCESTOR:
            s = "ancestor";
            break;
          case Step.ANCESTORORSELF:
            s = "ancestor-or-self";
            break;
          case Step.ATTRIBUTE:
            s = "attribute";
            break;
          case Step.CHILD:
            s = "child";
            break;
          case Step.DESCENDANT:
            s = "descendant";
            break;
          case Step.DESCENDANTORSELF:
            s = "descendant-or-self";
            break;
          case Step.FOLLOWING:
            s = "following";
            break;
          case Step.FOLLOWINGSIBLING:
            s = "following-sibling";
            break;
          case Step.NAMESPACE:
            s = "namespace";
            break;
          case Step.PARENT:
            s = "parent";
            break;
          case Step.PRECEDING:
            s = "preceding";
            break;
          case Step.PRECEDINGSIBLING:
            s = "preceding-sibling";
            break;
          case Step.SELF:
            s = "self";
            break;
        }
        s += "::";
        s += this.nodeTest.toString();
        for (var i = 0; i < this.predicates.length; i++) {
          s += "[" + this.predicates[i].toString() + "]";
        }
        return s;
      };
      Step.ANCESTOR = 0;
      Step.ANCESTORORSELF = 1;
      Step.ATTRIBUTE = 2;
      Step.CHILD = 3;
      Step.DESCENDANT = 4;
      Step.DESCENDANTORSELF = 5;
      Step.FOLLOWING = 6;
      Step.FOLLOWINGSIBLING = 7;
      Step.NAMESPACE = 8;
      Step.PARENT = 9;
      Step.PRECEDING = 10;
      Step.PRECEDINGSIBLING = 11;
      Step.SELF = 12;
      NodeTest.prototype = new Object();
      NodeTest.prototype.constructor = NodeTest;
      NodeTest.superclass = Object.prototype;

      function NodeTest(type, value) {
        if (arguments.length > 0) {
          this.init(type, value);
        }
      }
      NodeTest.prototype.init = function(type, value) {
        this.type = type;
        this.value = value;
      };
      NodeTest.prototype.toString = function() {
        switch (this.type) {
          case NodeTest.NAMETESTANY:
            return "*";
          case NodeTest.NAMETESTPREFIXANY:
            return this.value + ":*";
          case NodeTest.NAMETESTRESOLVEDANY:
            return "{" + this.value + "}*";
          case NodeTest.NAMETESTQNAME:
            return this.value;
          case NodeTest.NAMETESTRESOLVEDNAME:
            return "{" + this.namespaceURI + "}" + this.value;
          case NodeTest.COMMENT:
            return "comment()";
          case NodeTest.TEXT:
            return "text()";
          case NodeTest.PI:
            if (this.value != undefined) {
              return "processing-instruction(\"" + this.value + "\")";
            }
            return "processing-instruction()";
          case NodeTest.NODE:
            return "node()";
        }
        return "<unknown nodetest type>";
      };
      NodeTest.prototype.matches = function(n, xpc) {
        var nType = n.nodeType;
        switch (this.type) {
          case NodeTest.NAMETESTANY:
            if (nType === 2 ||
              nType === 1 ||
              nType === XPathNamespace.XPATH_NAMESPACE_NODE) {
              return true;
            }
            return false;
          case NodeTest.NAMETESTPREFIXANY:
            if (nType === 2 || nType === 1) {
              var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
              if (ns == null) {
                throw new Error("Cannot resolve QName " + this.value);
              }
              return ns === (n.namespaceURI || '');
            }
            return false;
          case NodeTest.NAMETESTQNAME:
            if (nType === 2 ||
              nType === 1 ||
              nType === XPathNamespace.XPATH_NAMESPACE_NODE) {
              var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
              if (test[0] == null) {
                throw new Error("Cannot resolve QName " + this.value);
              }
              test[0] = String(test[0]) || null;
              test[1] = String(test[1]);
              var node = [
                String(n.namespaceURI || '') || null,
                String(n.localName || n.nodeName)
              ];
              if (xpc.caseInsensitive) {
                return test[0] === node[0] && test[1].toLowerCase() === node[1].toLowerCase();
              }
              return test[0] === node[0] && test[1] === node[1];
            }
            return false;
          case NodeTest.COMMENT:
            return nType === 8;
          case NodeTest.TEXT:
            return nType === 3 || nType == 4;
          case NodeTest.PI:
            return nType === 7 &&
              (this.value == null || n.nodeName == this.value);
          case NodeTest.NODE:
            return nType === 9 ||
              nType === 1 ||
              nType === 2 ||
              nType === 3 ||
              nType === 4 ||
              nType === 8 ||
              nType === 7;
        }
        return false;
      };
      NodeTest.NAMETESTANY = 0;
      NodeTest.NAMETESTPREFIXANY = 1;
      NodeTest.NAMETESTQNAME = 2;
      NodeTest.COMMENT = 3;
      NodeTest.TEXT = 4;
      NodeTest.PI = 5;
      NodeTest.NODE = 6;
      VariableReference.prototype = new Expression();
      VariableReference.prototype.constructor = VariableReference;
      VariableReference.superclass = Expression.prototype;

      function VariableReference(v) {
        if (arguments.length > 0) {
          this.init(v);
        }
      }
      VariableReference.prototype.init = function(v) {
        this.variable = v;
      };
      VariableReference.prototype.toString = function() {
        return "$" + this.variable;
      };
      VariableReference.prototype.evaluate = function(c) {
        var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);
        if (parts[0] == null) {
          throw new Error("Cannot resolve QName " + fn);
        }
        var result = c.variableResolver.getVariable(parts[1], parts[0]);
        if (!result) {
          throw XPathException.fromMessage("Undeclared variable: " + this.toString());
        }
        return result;
      };
      FunctionCall.prototype = new Expression();
      FunctionCall.prototype.constructor = FunctionCall;
      FunctionCall.superclass = Expression.prototype;

      function FunctionCall(fn, args) {
        if (arguments.length > 0) {
          this.init(fn, args);
        }
      }
      FunctionCall.prototype.init = function(fn, args) {
        this.functionName = fn;
        this.arguments = args;
      };
      FunctionCall.prototype.toString = function() {
        var s = this.functionName + "(";
        for (var i = 0; i < this.arguments.length; i++) {
          if (i > 0) {
            s += ", ";
          }
          s += this.arguments[i].toString();
        }
        return s + ")";
      };
      FunctionCall.prototype.evaluate = function(c) {
        var f = FunctionResolver.getFunctionFromContext(this.functionName, c);
        if (!f) {
          throw new Error("Unknown function " + fn);
        }
        var a = [c].concat(this.arguments);
        return f.apply(c.functionResolver.thisArg, a);
      };
      XString.prototype = new Expression();
      XString.prototype.constructor = XString;
      XString.superclass = Expression.prototype;

      function XString(s) {
        if (arguments.length > 0) {
          this.init(s);
        }
      }
      XString.prototype.init = function(s) {
        this.str = String(s);
      };
      XString.prototype.toString = function() {
        return this.str;
      };
      XString.prototype.evaluate = function(c) {
        return this;
      };
      XString.prototype.string = function() {
        return this;
      };
      XString.prototype.number = function() {
        return new XNumber(this.str);
      };
      XString.prototype.bool = function() {
        return new XBoolean(this.str);
      };
      XString.prototype.nodeset = function() {
        throw new Error("Cannot convert string to nodeset");
      };
      XString.prototype.stringValue = function() {
        return this.str;
      };
      XString.prototype.numberValue = function() {
        return this.number().numberValue();
      };
      XString.prototype.booleanValue = function() {
        return this.bool().booleanValue();
      };
      XString.prototype.equals = function(r) {
        if (Utilities.instance_of(r, XBoolean)) {
          return this.bool().equals(r);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.number().equals(r);
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithString(this, Operators.equals);
        }
        return new XBoolean(this.str == r.str);
      };
      XString.prototype.notequal = function(r) {
        if (Utilities.instance_of(r, XBoolean)) {
          return this.bool().notequal(r);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.number().notequal(r);
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithString(this, Operators.notequal);
        }
        return new XBoolean(this.str != r.str);
      };
      XString.prototype.lessthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
        }
        return this.number().lessthan(r.number());
      };
      XString.prototype.greaterthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.lessthanorequal);
        }
        return this.number().greaterthan(r.number());
      };
      XString.prototype.lessthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.greaterthan);
        }
        return this.number().lessthanorequal(r.number());
      };
      XString.prototype.greaterthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.lessthan);
        }
        return this.number().greaterthanorequal(r.number());
      };
      XNumber.prototype = new Expression();
      XNumber.prototype.constructor = XNumber;
      XNumber.superclass = Expression.prototype;

      function XNumber(n) {
        if (arguments.length > 0) {
          this.init(n);
        }
      }
      XNumber.prototype.init = function(n) {
        this.num = typeof n === "string" ? this.parse(n) : Number(n);
      };
      XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;
      XNumber.prototype.parse = function(s) {
        return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;
      };
      XNumber.prototype.toString = function() {
        return this.num;
      };
      XNumber.prototype.evaluate = function(c) {
        return this;
      };
      XNumber.prototype.string = function() {
        return new XString(this.num);
      };
      XNumber.prototype.number = function() {
        return this;
      };
      XNumber.prototype.bool = function() {
        return new XBoolean(this.num);
      };
      XNumber.prototype.nodeset = function() {
        throw new Error("Cannot convert number to nodeset");
      };
      XNumber.prototype.stringValue = function() {
        return this.string().stringValue();
      };
      XNumber.prototype.numberValue = function() {
        return this.num;
      };
      XNumber.prototype.booleanValue = function() {
        return this.bool().booleanValue();
      };
      XNumber.prototype.negate = function() {
        return new XNumber(-this.num);
      };
      XNumber.prototype.equals = function(r) {
        if (Utilities.instance_of(r, XBoolean)) {
          return this.bool().equals(r);
        }
        if (Utilities.instance_of(r, XString)) {
          return this.equals(r.number());
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.equals);
        }
        return new XBoolean(this.num == r.num);
      };
      XNumber.prototype.notequal = function(r) {
        if (Utilities.instance_of(r, XBoolean)) {
          return this.bool().notequal(r);
        }
        if (Utilities.instance_of(r, XString)) {
          return this.notequal(r.number());
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.notequal);
        }
        return new XBoolean(this.num != r.num);
      };
      XNumber.prototype.lessthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.greaterthanorequal);
        }
        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
          return this.lessthan(r.number());
        }
        return new XBoolean(this.num < r.num);
      };
      XNumber.prototype.greaterthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.lessthanorequal);
        }
        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
          return this.greaterthan(r.number());
        }
        return new XBoolean(this.num > r.num);
      };
      XNumber.prototype.lessthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.greaterthan);
        }
        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
          return this.lessthanorequal(r.number());
        }
        return new XBoolean(this.num <= r.num);
      };
      XNumber.prototype.greaterthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this, Operators.lessthan);
        }
        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
          return this.greaterthanorequal(r.number());
        }
        return new XBoolean(this.num >= r.num);
      };
      XNumber.prototype.plus = function(r) {
        return new XNumber(this.num + r.num);
      };
      XNumber.prototype.minus = function(r) {
        return new XNumber(this.num - r.num);
      };
      XNumber.prototype.multiply = function(r) {
        return new XNumber(this.num * r.num);
      };
      XNumber.prototype.div = function(r) {
        return new XNumber(this.num / r.num);
      };
      XNumber.prototype.mod = function(r) {
        return new XNumber(this.num % r.num);
      };
      XBoolean.prototype = new Expression();
      XBoolean.prototype.constructor = XBoolean;
      XBoolean.superclass = Expression.prototype;

      function XBoolean(b) {
        if (arguments.length > 0) {
          this.init(b);
        }
      }
      XBoolean.prototype.init = function(b) {
        this.b = Boolean(b);
      };
      XBoolean.prototype.toString = function() {
        return this.b.toString();
      };
      XBoolean.prototype.evaluate = function(c) {
        return this;
      };
      XBoolean.prototype.string = function() {
        return new XString(this.b);
      };
      XBoolean.prototype.number = function() {
        return new XNumber(this.b);
      };
      XBoolean.prototype.bool = function() {
        return this;
      };
      XBoolean.prototype.nodeset = function() {
        throw new Error("Cannot convert boolean to nodeset");
      };
      XBoolean.prototype.stringValue = function() {
        return this.string().stringValue();
      };
      XBoolean.prototype.numberValue = function() {
        return this.num().numberValue();
      };
      XBoolean.prototype.booleanValue = function() {
        return this.b;
      };
      XBoolean.prototype.not = function() {
        return new XBoolean(!this.b);
      };
      XBoolean.prototype.equals = function(r) {
        if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
          return this.equals(r.bool());
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithBoolean(this, Operators.equals);
        }
        return new XBoolean(this.b == r.b);
      };
      XBoolean.prototype.notequal = function(r) {
        if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
          return this.notequal(r.bool());
        }
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithBoolean(this, Operators.notequal);
        }
        return new XBoolean(this.b != r.b);
      };
      XBoolean.prototype.lessthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
        }
        return this.number().lessthan(r.number());
      };
      XBoolean.prototype.greaterthan = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.lessthanorequal);
        }
        return this.number().greaterthan(r.number());
      };
      XBoolean.prototype.lessthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.greaterthan);
        }
        return this.number().lessthanorequal(r.number());
      };
      XBoolean.prototype.greaterthanorequal = function(r) {
        if (Utilities.instance_of(r, XNodeSet)) {
          return r.compareWithNumber(this.number(), Operators.lessthan);
        }
        return this.number().greaterthanorequal(r.number());
      };
      AVLTree.prototype = new Object();
      AVLTree.prototype.constructor = AVLTree;
      AVLTree.superclass = Object.prototype;

      function AVLTree(n) {
        this.init(n);
      }
      AVLTree.prototype.init = function(n) {
        this.left = null;
        this.right = null;
        this.node = n;
        this.depth = 1;
      };
      AVLTree.prototype.balance = function() {
        var ldepth = this.left == null ? 0 : this.left.depth;
        var rdepth = this.right == null ? 0 : this.right.depth;
        if (ldepth > rdepth + 1) {
          var lldepth = this.left.left == null ? 0 : this.left.left.depth;
          var lrdepth = this.left.right == null ? 0 : this.left.right.depth;
          if (lldepth < lrdepth) {
            this.left.rotateRR();
          }
          this.rotateLL();
        } else if (ldepth + 1 < rdepth) {
          var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
          var rldepth = this.right.left == null ? 0 : this.right.left.depth;
          if (rldepth > rrdepth) {
            this.right.rotateLL();
          }
          this.rotateRR();
        }
      };
      AVLTree.prototype.rotateLL = function() {
        var nodeBefore = this.node;
        var rightBefore = this.right;
        this.node = this.left.node;
        this.right = this.left;
        this.left = this.left.left;
        this.right.left = this.right.right;
        this.right.right = rightBefore;
        this.right.node = nodeBefore;
        this.right.updateInNewLocation();
        this.updateInNewLocation();
      };
      AVLTree.prototype.rotateRR = function() {
        var nodeBefore = this.node;
        var leftBefore = this.left;
        this.node = this.right.node;
        this.left = this.right;
        this.right = this.right.right;
        this.left.right = this.left.left;
        this.left.left = leftBefore;
        this.left.node = nodeBefore;
        this.left.updateInNewLocation();
        this.updateInNewLocation();
      };
      AVLTree.prototype.updateInNewLocation = function() {
        this.getDepthFromChildren();
      };
      AVLTree.prototype.getDepthFromChildren = function() {
        this.depth = this.node == null ? 0 : 1;
        if (this.left != null) {
          this.depth = this.left.depth + 1;
        }
        if (this.right != null && this.depth <= this.right.depth) {
          this.depth = this.right.depth + 1;
        }
      };

      function nodeOrder(n1, n2) {
        if (n1 === n2) {
          return 0;
        }
        if (n1.compareDocumentPosition) {
          var cpos = n1.compareDocumentPosition(n2);
          if (cpos & 0x01) {
            return 1;
          }
          if (cpos & 0x0A) {
            return 1;
          }
          if (cpos & 0x14) {
            return -1;
          }
          return 0;
        }
        var d1 = 0,
          d2 = 0;
        for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
          d1++;
        }
        for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
          d2++;
        }
        if (d1 > d2) {
          while (d1 > d2) {
            n1 = n1.parentNode || n1.ownerElement;
            d1--;
          }
          if (n1 === n2) {
            return 1;
          }
        } else if (d2 > d1) {
          while (d2 > d1) {
            n2 = n2.parentNode || n2.ownerElement;
            d2--;
          }
          if (n1 === n2) {
            return -1;
          }
        }
        var n1Par = n1.parentNode || n1.ownerElement,
          n2Par = n2.parentNode || n2.ownerElement;
        while (n1Par !== n2Par) {
          n1 = n1Par;
          n2 = n2Par;
          n1Par = n1.parentNode || n1.ownerElement;
          n2Par = n2.parentNode || n2.ownerElement;
        }
        var n1isAttr = Utilities.isAttribute(n1);
        var n2isAttr = Utilities.isAttribute(n2);
        if (n1isAttr && !n2isAttr) {
          return -1;
        }
        if (!n1isAttr && n2isAttr) {
          return 1;
        }
        if (n1Par) {
          var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,
            len = cn.length;
          for (var i = 0; i < len; i += 1) {
            var n = cn[i];
            if (n === n1) {
              return -1;
            }
            if (n === n2) {
              return 1;
            }
          }
        }
        throw new Error('Unexpected: could not determine node order');
      }
      AVLTree.prototype.add = function(n) {
        if (n === this.node) {
          return false;
        }
        var o = nodeOrder(n, this.node);
        var ret = false;
        if (o == -1) {
          if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
          } else {
            ret = this.left.add(n);
            if (ret) {
              this.balance();
            }
          }
        } else if (o == 1) {
          if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
          } else {
            ret = this.right.add(n);
            if (ret) {
              this.balance();
            }
          }
        }
        if (ret) {
          this.getDepthFromChildren();
        }
        return ret;
      };
      XNodeSet.prototype = new Expression();
      XNodeSet.prototype.constructor = XNodeSet;
      XNodeSet.superclass = Expression.prototype;

      function XNodeSet() {
        this.init();
      }
      XNodeSet.prototype.init = function() {
        this.tree = null;
        this.nodes = [];
        this.size = 0;
      };
      XNodeSet.prototype.toString = function() {
        var p = this.first();
        if (p == null) {
          return "";
        }
        return this.stringForNode(p);
      };
      XNodeSet.prototype.evaluate = function(c) {
        return this;
      };
      XNodeSet.prototype.string = function() {
        return new XString(this.toString());
      };
      XNodeSet.prototype.stringValue = function() {
        return this.toString();
      };
      XNodeSet.prototype.number = function() {
        return new XNumber(this.string());
      };
      XNodeSet.prototype.numberValue = function() {
        return Number(this.string());
      };
      XNodeSet.prototype.bool = function() {
        return new XBoolean(this.booleanValue());
      };
      XNodeSet.prototype.booleanValue = function() {
        return !!this.size;
      };
      XNodeSet.prototype.nodeset = function() {
        return this;
      };
      XNodeSet.prototype.stringForNode = function(n) {
        if (n.nodeType == 9 ||
          n.nodeType == 1 ||
          n.nodeType === 11) {
          return this.stringForContainerNode(n);
        }
        if (n.nodeType === 2) {
          return n.value || n.nodeValue;
        }
        if (n.isNamespaceNode) {
          return n.namespace;
        }
        return n.nodeValue;
      };
      XNodeSet.prototype.stringForContainerNode = function(n) {
        var s = "";
        for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
          var nt = n2.nodeType;
          if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {
            s += this.stringForNode(n2);
          }
        }
        return s;
      };
      XNodeSet.prototype.buildTree = function() {
        if (!this.tree && this.nodes.length) {
          this.tree = new AVLTree(this.nodes[0]);
          for (var i = 1; i < this.nodes.length; i += 1) {
            this.tree.add(this.nodes[i]);
          }
        }
        return this.tree;
      };
      XNodeSet.prototype.first = function() {
        var p = this.buildTree();
        if (p == null) {
          return null;
        }
        while (p.left != null) {
          p = p.left;
        }
        return p.node;
      };
      XNodeSet.prototype.add = function(n) {
        for (var i = 0; i < this.nodes.length; i += 1) {
          if (n === this.nodes[i]) {
            return;
          }
        }
        this.tree = null;
        this.nodes.push(n);
        this.size += 1;
      };
      XNodeSet.prototype.addArray = function(ns) {
        for (var i = 0; i < ns.length; i += 1) {
          this.add(ns[i]);
        }
      };
      XNodeSet.prototype.toArray = function() {
        var a = [];
        this.toArrayRec(this.buildTree(), a);
        return a;
      };
      XNodeSet.prototype.toArrayRec = function(t, a) {
        if (t != null) {
          this.toArrayRec(t.left, a);
          a.push(t.node);
          this.toArrayRec(t.right, a);
        }
      };
      XNodeSet.prototype.toUnsortedArray = function() {
        return this.nodes.slice();
      };
      XNodeSet.prototype.compareWithString = function(r, o) {
        var a = this.toUnsortedArray();
        for (var i = 0; i < a.length; i++) {
          var n = a[i];
          var l = new XString(this.stringForNode(n));
          var res = o(l, r);
          if (res.booleanValue()) {
            return res;
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.prototype.compareWithNumber = function(r, o) {
        var a = this.toUnsortedArray();
        for (var i = 0; i < a.length; i++) {
          var n = a[i];
          var l = new XNumber(this.stringForNode(n));
          var res = o(l, r);
          if (res.booleanValue()) {
            return res;
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.prototype.compareWithBoolean = function(r, o) {
        return o(this.bool(), r);
      };
      XNodeSet.prototype.compareWithNodeSet = function(r, o) {
        var a = this.toUnsortedArray();
        for (var i = 0; i < a.length; i++) {
          var n = a[i];
          var l = new XString(this.stringForNode(n));
          var b = r.toUnsortedArray();
          for (var j = 0; j < b.length; j++) {
            var n2 = b[j];
            var r = new XString(this.stringForNode(n2));
            var res = o(l, r);
            if (res.booleanValue()) {
              return res;
            }
          }
        }
        return new XBoolean(false);
      };
      XNodeSet.prototype.equals = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithString(r, Operators.equals);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.equals);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.equals);
        }
        return this.compareWithNodeSet(r, Operators.equals);
      };
      XNodeSet.prototype.notequal = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithString(r, Operators.notequal);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.notequal);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.notequal);
        }
        return this.compareWithNodeSet(r, Operators.notequal);
      };
      XNodeSet.prototype.lessthan = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithNumber(r.number(), Operators.lessthan);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.lessthan);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.lessthan);
        }
        return this.compareWithNodeSet(r, Operators.lessthan);
      };
      XNodeSet.prototype.greaterthan = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithNumber(r.number(), Operators.greaterthan);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.greaterthan);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.greaterthan);
        }
        return this.compareWithNodeSet(r, Operators.greaterthan);
      };
      XNodeSet.prototype.lessthanorequal = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithNumber(r.number(), Operators.lessthanorequal);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.lessthanorequal);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.lessthanorequal);
        }
        return this.compareWithNodeSet(r, Operators.lessthanorequal);
      };
      XNodeSet.prototype.greaterthanorequal = function(r) {
        if (Utilities.instance_of(r, XString)) {
          return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
        }
        if (Utilities.instance_of(r, XNumber)) {
          return this.compareWithNumber(r, Operators.greaterthanorequal);
        }
        if (Utilities.instance_of(r, XBoolean)) {
          return this.compareWithBoolean(r, Operators.greaterthanorequal);
        }
        return this.compareWithNodeSet(r, Operators.greaterthanorequal);
      };
      XNodeSet.prototype.union = function(r) {
        var ns = new XNodeSet();
        ns.addArray(this.toUnsortedArray());
        ns.addArray(r.toUnsortedArray());
        return ns;
      };
      XPathNamespace.prototype = new Object();
      XPathNamespace.prototype.constructor = XPathNamespace;
      XPathNamespace.superclass = Object.prototype;

      function XPathNamespace(pre, ns, p) {
        this.isXPathNamespace = true;
        this.ownerDocument = p.ownerDocument;
        this.nodeName = "#namespace";
        this.prefix = pre;
        this.localName = pre;
        this.namespaceURI = ns;
        this.nodeValue = ns;
        this.ownerElement = p;
        this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
      }
      XPathNamespace.prototype.toString = function() {
        return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
      };
      var Operators = new Object();
      Operators.equals = function(l, r) {
        return l.equals(r);
      };
      Operators.notequal = function(l, r) {
        return l.notequal(r);
      };
      Operators.lessthan = function(l, r) {
        return l.lessthan(r);
      };
      Operators.greaterthan = function(l, r) {
        return l.greaterthan(r);
      };
      Operators.lessthanorequal = function(l, r) {
        return l.lessthanorequal(r);
      };
      Operators.greaterthanorequal = function(l, r) {
        return l.greaterthanorequal(r);
      };
      XPathContext.prototype = new Object();
      XPathContext.prototype.constructor = XPathContext;
      XPathContext.superclass = Object.prototype;

      function XPathContext(vr, nr, fr) {
        this.variableResolver = vr != null ? vr : new VariableResolver();
        this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
        this.functionResolver = fr != null ? fr : new FunctionResolver();
      }
      VariableResolver.prototype = new Object();
      VariableResolver.prototype.constructor = VariableResolver;
      VariableResolver.superclass = Object.prototype;

      function VariableResolver() {}
      VariableResolver.prototype.getVariable = function(ln, ns) {
        return null;
      };
      FunctionResolver.prototype = new Object();
      FunctionResolver.prototype.constructor = FunctionResolver;
      FunctionResolver.superclass = Object.prototype;

      function FunctionResolver(thisArg) {
        this.thisArg = thisArg != null ? thisArg : Functions;
        this.functions = new Object();
        this.addStandardFunctions();
      }
      FunctionResolver.prototype.addStandardFunctions = function() {
        this.functions["{}last"] = Functions.last;
        this.functions["{}position"] = Functions.position;
        this.functions["{}count"] = Functions.count;
        this.functions["{}id"] = Functions.id;
        this.functions["{}local-name"] = Functions.localName;
        this.functions["{}namespace-uri"] = Functions.namespaceURI;
        this.functions["{}name"] = Functions.name;
        this.functions["{}string"] = Functions.string;
        this.functions["{}concat"] = Functions.concat;
        this.functions["{}starts-with"] = Functions.startsWith;
        this.functions["{}contains"] = Functions.contains;
        this.functions["{}substring-before"] = Functions.substringBefore;
        this.functions["{}substring-after"] = Functions.substringAfter;
        this.functions["{}substring"] = Functions.substring;
        this.functions["{}string-length"] = Functions.stringLength;
        this.functions["{}normalize-space"] = Functions.normalizeSpace;
        this.functions["{}translate"] = Functions.translate;
        this.functions["{}boolean"] = Functions.boolean_;
        this.functions["{}not"] = Functions.not;
        this.functions["{}true"] = Functions.true_;
        this.functions["{}false"] = Functions.false_;
        this.functions["{}lang"] = Functions.lang;
        this.functions["{}number"] = Functions.number;
        this.functions["{}sum"] = Functions.sum;
        this.functions["{}floor"] = Functions.floor;
        this.functions["{}ceiling"] = Functions.ceiling;
        this.functions["{}round"] = Functions.round;
      };
      FunctionResolver.prototype.addFunction = function(ns, ln, f) {
        this.functions["{" + ns + "}" + ln] = f;
      };
      FunctionResolver.getFunctionFromContext = function(qName, context) {
        var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);
        if (parts[0] === null) {
          throw new Error("Cannot resolve QName " + name);
        }
        return context.functionResolver.getFunction(parts[1], parts[0]);
      };
      FunctionResolver.prototype.getFunction = function(localName, namespace) {
        return this.functions["{" + namespace + "}" + localName];
      };
      NamespaceResolver.prototype = new Object();
      NamespaceResolver.prototype.constructor = NamespaceResolver;
      NamespaceResolver.superclass = Object.prototype;

      function NamespaceResolver() {}
      NamespaceResolver.prototype.getNamespace = function(prefix, n) {
        if (prefix == "xml") {
          return XPath.XML_NAMESPACE_URI;
        } else if (prefix == "xmlns") {
          return XPath.XMLNS_NAMESPACE_URI;
        }
        if (n.nodeType == 9) {
          n = n.documentElement;
        } else if (n.nodeType == 2) {
          n = PathExpr.prototype.getOwnerElement(n);
        } else if (n.nodeType != 1) {
          n = n.parentNode;
        }
        while (n != null && n.nodeType == 1) {
          var nnm = n.attributes;
          for (var i = 0; i < nnm.length; i++) {
            var a = nnm.item(i);
            var aname = a.name || a.nodeName;
            if ((aname === "xmlns" && prefix === "") ||
              aname === "xmlns:" + prefix) {
              return String(a.value || a.nodeValue);
            }
          }
          n = n.parentNode;
        }
        return null;
      };
      var Functions = new Object();
      Functions.last = function() {
        var c = arguments[0];
        if (arguments.length != 1) {
          throw new Error("Function last expects ()");
        }
        return new XNumber(c.contextSize);
      };
      Functions.position = function() {
        var c = arguments[0];
        if (arguments.length != 1) {
          throw new Error("Function position expects ()");
        }
        return new XNumber(c.contextPosition);
      };
      Functions.count = function() {
        var c = arguments[0];
        var ns;
        if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
          throw new Error("Function count expects (node-set)");
        }
        return new XNumber(ns.size);
      };
      Functions.id = function() {
        var c = arguments[0];
        var id;
        if (arguments.length != 2) {
          throw new Error("Function id expects (object)");
        }
        id = arguments[1].evaluate(c);
        if (Utilities.instance_of(id, XNodeSet)) {
          id = id.toArray().join(" ");
        } else {
          id = id.stringValue();
        }
        var ids = id.split(/[\x0d\x0a\x09\x20]+/);
        var count = 0;
        var ns = new XNodeSet();
        var doc = c.contextNode.nodeType == 9 ?
          c.contextNode :
          c.contextNode.ownerDocument;
        for (var i = 0; i < ids.length; i++) {
          var n;
          if (doc.getElementById) {
            n = doc.getElementById(ids[i]);
          } else {
            n = Utilities.getElementById(doc, ids[i]);
          }
          if (n != null) {
            ns.add(n);
            count++;
          }
        }
        return ns;
      };
      Functions.localName = function() {
        var c = arguments[0];
        var n;
        if (arguments.length == 1) {
          n = c.contextNode;
        } else if (arguments.length == 2) {
          n = arguments[1].evaluate(c).first();
        } else {
          throw new Error("Function local-name expects (node-set?)");
        }
        if (n == null) {
          return new XString("");
        }
        return new XString(n.localName ||
          n.baseName ||
          n.target ||
          n.nodeName ||
          "");
      };
      Functions.namespaceURI = function() {
        var c = arguments[0];
        var n;
        if (arguments.length == 1) {
          n = c.contextNode;
        } else if (arguments.length == 2) {
          n = arguments[1].evaluate(c).first();
        } else {
          throw new Error("Function namespace-uri expects (node-set?)");
        }
        if (n == null) {
          return new XString("");
        }
        return new XString(n.namespaceURI);
      };
      Functions.name = function() {
        var c = arguments[0];
        var n;
        if (arguments.length == 1) {
          n = c.contextNode;
        } else if (arguments.length == 2) {
          n = arguments[1].evaluate(c).first();
        } else {
          throw new Error("Function name expects (node-set?)");
        }
        if (n == null) {
          return new XString("");
        }
        if (n.nodeType == 1) {
          return new XString(n.nodeName);
        } else if (n.nodeType == 2) {
          return new XString(n.name || n.nodeName);
        } else if (n.nodeType === 7) {
          return new XString(n.target || n.nodeName);
        } else if (n.localName == null) {
          return new XString("");
        } else {
          return new XString(n.localName);
        }
      };
      Functions.string = function() {
        var c = arguments[0];
        if (arguments.length == 1) {
          return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
        } else if (arguments.length == 2) {
          return arguments[1].evaluate(c).string();
        }
        throw new Error("Function string expects (object?)");
      };
      Functions.concat = function() {
        var c = arguments[0];
        if (arguments.length < 3) {
          throw new Error("Function concat expects (string, string, string*)");
        }
        var s = "";
        for (var i = 1; i < arguments.length; i++) {
          s += arguments[i].evaluate(c).stringValue();
        }
        return new XString(s);
      };
      Functions.startsWith = function() {
        var c = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function startsWith expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c).stringValue();
        var s2 = arguments[2].evaluate(c).stringValue();
        return new XBoolean(s1.substring(0, s2.length) == s2);
      };
      Functions.contains = function() {
        var c = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function contains expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c).stringValue();
        var s2 = arguments[2].evaluate(c).stringValue();
        return new XBoolean(s1.indexOf(s2) !== -1);
      };
      Functions.substringBefore = function() {
        var c = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function substring-before expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c).stringValue();
        var s2 = arguments[2].evaluate(c).stringValue();
        return new XString(s1.substring(0, s1.indexOf(s2)));
      };
      Functions.substringAfter = function() {
        var c = arguments[0];
        if (arguments.length != 3) {
          throw new Error("Function substring-after expects (string, string)");
        }
        var s1 = arguments[1].evaluate(c).stringValue();
        var s2 = arguments[2].evaluate(c).stringValue();
        if (s2.length == 0) {
          return new XString(s1);
        }
        var i = s1.indexOf(s2);
        if (i == -1) {
          return new XString("");
        }
        return new XString(s1.substring(i + s2.length));
      };
      Functions.substring = function() {
        var c = arguments[0];
        if (!(arguments.length == 3 || arguments.length == 4)) {
          throw new Error("Function substring expects (string, number, number?)");
        }
        var s = arguments[1].evaluate(c).stringValue();
        var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
        var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
        return new XString(s.substring(n1, n2));
      };
      Functions.stringLength = function() {
        var c = arguments[0];
        var s;
        if (arguments.length == 1) {
          s = XNodeSet.prototype.stringForNode(c.contextNode);
        } else if (arguments.length == 2) {
          s = arguments[1].evaluate(c).stringValue();
        } else {
          throw new Error("Function string-length expects (string?)");
        }
        return new XNumber(s.length);
      };
      Functions.normalizeSpace = function() {
        var c = arguments[0];
        var s;
        if (arguments.length == 1) {
          s = XNodeSet.prototype.stringForNode(c.contextNode);
        } else if (arguments.length == 2) {
          s = arguments[1].evaluate(c).stringValue();
        } else {
          throw new Error("Function normalize-space expects (string?)");
        }
        var i = 0;
        var j = s.length - 1;
        while (Utilities.isSpace(s.charCodeAt(j))) {
          j--;
        }
        var t = "";
        while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
          i++;
        }
        while (i <= j) {
          if (Utilities.isSpace(s.charCodeAt(i))) {
            t += " ";
            while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
              i++;
            }
          } else {
            t += s.charAt(i);
            i++;
          }
        }
        return new XString(t);
      };
      Functions.translate = function() {
        var c = arguments[0];
        if (arguments.length != 4) {
          throw new Error("Function translate expects (string, string, string)");
        }
        var s1 = arguments[1].evaluate(c).stringValue();
        var s2 = arguments[2].evaluate(c).stringValue();
        var s3 = arguments[3].evaluate(c).stringValue();
        var map = [];
        for (var i = 0; i < s2.length; i++) {
          var j = s2.charCodeAt(i);
          if (map[j] == undefined) {
            var k = i > s3.length ? "" : s3.charAt(i);
            map[j] = k;
          }
        }
        var t = "";
        for (var i = 0; i < s1.length; i++) {
          var c = s1.charCodeAt(i);
          var r = map[c];
          if (r == undefined) {
            t += s1.charAt(i);
          } else {
            t += r;
          }
        }
        return new XString(t);
      };
      Functions.boolean_ = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function boolean expects (object)");
        }
        return arguments[1].evaluate(c).bool();
      };
      Functions.not = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function not expects (object)");
        }
        return arguments[1].evaluate(c).bool().not();
      };
      Functions.true_ = function() {
        if (arguments.length != 1) {
          throw new Error("Function true expects ()");
        }
        return new XBoolean(true);
      };
      Functions.false_ = function() {
        if (arguments.length != 1) {
          throw new Error("Function false expects ()");
        }
        return new XBoolean(false);
      };
      Functions.lang = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function lang expects (string)");
        }
        var lang;
        for (var n = c.contextNode; n != null && n.nodeType != 9; n = n.parentNode) {
          var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
          if (a != null) {
            lang = String(a);
            break;
          }
        }
        if (lang == null) {
          return new XBoolean(false);
        }
        var s = arguments[1].evaluate(c).stringValue();
        return new XBoolean(lang.substring(0, s.length) == s &&
          (lang.length == s.length || lang.charAt(s.length) == '-'));
      };
      Functions.number = function() {
        var c = arguments[0];
        if (!(arguments.length == 1 || arguments.length == 2)) {
          throw new Error("Function number expects (object?)");
        }
        if (arguments.length == 1) {
          return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
        }
        return arguments[1].evaluate(c).number();
      };
      Functions.sum = function() {
        var c = arguments[0];
        var ns;
        if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
          throw new Error("Function sum expects (node-set)");
        }
        ns = ns.toUnsortedArray();
        var n = 0;
        for (var i = 0; i < ns.length; i++) {
          n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
        }
        return new XNumber(n);
      };
      Functions.floor = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function floor expects (number)");
        }
        return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
      };
      Functions.ceiling = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function ceiling expects (number)");
        }
        return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
      };
      Functions.round = function() {
        var c = arguments[0];
        if (arguments.length != 2) {
          throw new Error("Function round expects (number)");
        }
        return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
      };
      var Utilities = new Object();
      Utilities.isAttribute = function(val) {
        return val && (val.nodeType === 2 || val.ownerElement);
      }
      Utilities.splitQName = function(qn) {
        var i = qn.indexOf(":");
        if (i == -1) {
          return [null, qn];
        }
        return [qn.substring(0, i), qn.substring(i + 1)];
      };
      Utilities.resolveQName = function(qn, nr, n, useDefault) {
        var parts = Utilities.splitQName(qn);
        if (parts[0] != null) {
          parts[0] = nr.getNamespace(parts[0], n);
        } else {
          if (useDefault) {
            parts[0] = nr.getNamespace("", n);
            if (parts[0] == null) {
              parts[0] = "";
            }
          } else {
            parts[0] = "";
          }
        }
        return parts;
      };
      Utilities.isSpace = function(c) {
        return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
      };
      Utilities.isLetter = function(c) {
        return c >= 0x0041 && c <= 0x005A ||
          c >= 0x0061 && c <= 0x007A ||
          c >= 0x00C0 && c <= 0x00D6 ||
          c >= 0x00D8 && c <= 0x00F6 ||
          c >= 0x00F8 && c <= 0x00FF ||
          c >= 0x0100 && c <= 0x0131 ||
          c >= 0x0134 && c <= 0x013E ||
          c >= 0x0141 && c <= 0x0148 ||
          c >= 0x014A && c <= 0x017E ||
          c >= 0x0180 && c <= 0x01C3 ||
          c >= 0x01CD && c <= 0x01F0 ||
          c >= 0x01F4 && c <= 0x01F5 ||
          c >= 0x01FA && c <= 0x0217 ||
          c >= 0x0250 && c <= 0x02A8 ||
          c >= 0x02BB && c <= 0x02C1 ||
          c == 0x0386 ||
          c >= 0x0388 && c <= 0x038A ||
          c == 0x038C ||
          c >= 0x038E && c <= 0x03A1 ||
          c >= 0x03A3 && c <= 0x03CE ||
          c >= 0x03D0 && c <= 0x03D6 ||
          c == 0x03DA ||
          c == 0x03DC ||
          c == 0x03DE ||
          c == 0x03E0 ||
          c >= 0x03E2 && c <= 0x03F3 ||
          c >= 0x0401 && c <= 0x040C ||
          c >= 0x040E && c <= 0x044F ||
          c >= 0x0451 && c <= 0x045C ||
          c >= 0x045E && c <= 0x0481 ||
          c >= 0x0490 && c <= 0x04C4 ||
          c >= 0x04C7 && c <= 0x04C8 ||
          c >= 0x04CB && c <= 0x04CC ||
          c >= 0x04D0 && c <= 0x04EB ||
          c >= 0x04EE && c <= 0x04F5 ||
          c >= 0x04F8 && c <= 0x04F9 ||
          c >= 0x0531 && c <= 0x0556 ||
          c == 0x0559 ||
          c >= 0x0561 && c <= 0x0586 ||
          c >= 0x05D0 && c <= 0x05EA ||
          c >= 0x05F0 && c <= 0x05F2 ||
          c >= 0x0621 && c <= 0x063A ||
          c >= 0x0641 && c <= 0x064A ||
          c >= 0x0671 && c <= 0x06B7 ||
          c >= 0x06BA && c <= 0x06BE ||
          c >= 0x06C0 && c <= 0x06CE ||
          c >= 0x06D0 && c <= 0x06D3 ||
          c == 0x06D5 ||
          c >= 0x06E5 && c <= 0x06E6 ||
          c >= 0x0905 && c <= 0x0939 ||
          c == 0x093D ||
          c >= 0x0958 && c <= 0x0961 ||
          c >= 0x0985 && c <= 0x098C ||
          c >= 0x098F && c <= 0x0990 ||
          c >= 0x0993 && c <= 0x09A8 ||
          c >= 0x09AA && c <= 0x09B0 ||
          c == 0x09B2 ||
          c >= 0x09B6 && c <= 0x09B9 ||
          c >= 0x09DC && c <= 0x09DD ||
          c >= 0x09DF && c <= 0x09E1 ||
          c >= 0x09F0 && c <= 0x09F1 ||
          c >= 0x0A05 && c <= 0x0A0A ||
          c >= 0x0A0F && c <= 0x0A10 ||
          c >= 0x0A13 && c <= 0x0A28 ||
          c >= 0x0A2A && c <= 0x0A30 ||
          c >= 0x0A32 && c <= 0x0A33 ||
          c >= 0x0A35 && c <= 0x0A36 ||
          c >= 0x0A38 && c <= 0x0A39 ||
          c >= 0x0A59 && c <= 0x0A5C ||
          c == 0x0A5E ||
          c >= 0x0A72 && c <= 0x0A74 ||
          c >= 0x0A85 && c <= 0x0A8B ||
          c == 0x0A8D ||
          c >= 0x0A8F && c <= 0x0A91 ||
          c >= 0x0A93 && c <= 0x0AA8 ||
          c >= 0x0AAA && c <= 0x0AB0 ||
          c >= 0x0AB2 && c <= 0x0AB3 ||
          c >= 0x0AB5 && c <= 0x0AB9 ||
          c == 0x0ABD ||
          c == 0x0AE0 ||
          c >= 0x0B05 && c <= 0x0B0C ||
          c >= 0x0B0F && c <= 0x0B10 ||
          c >= 0x0B13 && c <= 0x0B28 ||
          c >= 0x0B2A && c <= 0x0B30 ||
          c >= 0x0B32 && c <= 0x0B33 ||
          c >= 0x0B36 && c <= 0x0B39 ||
          c == 0x0B3D ||
          c >= 0x0B5C && c <= 0x0B5D ||
          c >= 0x0B5F && c <= 0x0B61 ||
          c >= 0x0B85 && c <= 0x0B8A ||
          c >= 0x0B8E && c <= 0x0B90 ||
          c >= 0x0B92 && c <= 0x0B95 ||
          c >= 0x0B99 && c <= 0x0B9A ||
          c == 0x0B9C ||
          c >= 0x0B9E && c <= 0x0B9F ||
          c >= 0x0BA3 && c <= 0x0BA4 ||
          c >= 0x0BA8 && c <= 0x0BAA ||
          c >= 0x0BAE && c <= 0x0BB5 ||
          c >= 0x0BB7 && c <= 0x0BB9 ||
          c >= 0x0C05 && c <= 0x0C0C ||
          c >= 0x0C0E && c <= 0x0C10 ||
          c >= 0x0C12 && c <= 0x0C28 ||
          c >= 0x0C2A && c <= 0x0C33 ||
          c >= 0x0C35 && c <= 0x0C39 ||
          c >= 0x0C60 && c <= 0x0C61 ||
          c >= 0x0C85 && c <= 0x0C8C ||
          c >= 0x0C8E && c <= 0x0C90 ||
          c >= 0x0C92 && c <= 0x0CA8 ||
          c >= 0x0CAA && c <= 0x0CB3 ||
          c >= 0x0CB5 && c <= 0x0CB9 ||
          c == 0x0CDE ||
          c >= 0x0CE0 && c <= 0x0CE1 ||
          c >= 0x0D05 && c <= 0x0D0C ||
          c >= 0x0D0E && c <= 0x0D10 ||
          c >= 0x0D12 && c <= 0x0D28 ||
          c >= 0x0D2A && c <= 0x0D39 ||
          c >= 0x0D60 && c <= 0x0D61 ||
          c >= 0x0E01 && c <= 0x0E2E ||
          c == 0x0E30 ||
          c >= 0x0E32 && c <= 0x0E33 ||
          c >= 0x0E40 && c <= 0x0E45 ||
          c >= 0x0E81 && c <= 0x0E82 ||
          c == 0x0E84 ||
          c >= 0x0E87 && c <= 0x0E88 ||
          c == 0x0E8A ||
          c == 0x0E8D ||
          c >= 0x0E94 && c <= 0x0E97 ||
          c >= 0x0E99 && c <= 0x0E9F ||
          c >= 0x0EA1 && c <= 0x0EA3 ||
          c == 0x0EA5 ||
          c == 0x0EA7 ||
          c >= 0x0EAA && c <= 0x0EAB ||
          c >= 0x0EAD && c <= 0x0EAE ||
          c == 0x0EB0 ||
          c >= 0x0EB2 && c <= 0x0EB3 ||
          c == 0x0EBD ||
          c >= 0x0EC0 && c <= 0x0EC4 ||
          c >= 0x0F40 && c <= 0x0F47 ||
          c >= 0x0F49 && c <= 0x0F69 ||
          c >= 0x10A0 && c <= 0x10C5 ||
          c >= 0x10D0 && c <= 0x10F6 ||
          c == 0x1100 ||
          c >= 0x1102 && c <= 0x1103 ||
          c >= 0x1105 && c <= 0x1107 ||
          c == 0x1109 ||
          c >= 0x110B && c <= 0x110C ||
          c >= 0x110E && c <= 0x1112 ||
          c == 0x113C ||
          c == 0x113E ||
          c == 0x1140 ||
          c == 0x114C ||
          c == 0x114E ||
          c == 0x1150 ||
          c >= 0x1154 && c <= 0x1155 ||
          c == 0x1159 ||
          c >= 0x115F && c <= 0x1161 ||
          c == 0x1163 ||
          c == 0x1165 ||
          c == 0x1167 ||
          c == 0x1169 ||
          c >= 0x116D && c <= 0x116E ||
          c >= 0x1172 && c <= 0x1173 ||
          c == 0x1175 ||
          c == 0x119E ||
          c == 0x11A8 ||
          c == 0x11AB ||
          c >= 0x11AE && c <= 0x11AF ||
          c >= 0x11B7 && c <= 0x11B8 ||
          c == 0x11BA ||
          c >= 0x11BC && c <= 0x11C2 ||
          c == 0x11EB ||
          c == 0x11F0 ||
          c == 0x11F9 ||
          c >= 0x1E00 && c <= 0x1E9B ||
          c >= 0x1EA0 && c <= 0x1EF9 ||
          c >= 0x1F00 && c <= 0x1F15 ||
          c >= 0x1F18 && c <= 0x1F1D ||
          c >= 0x1F20 && c <= 0x1F45 ||
          c >= 0x1F48 && c <= 0x1F4D ||
          c >= 0x1F50 && c <= 0x1F57 ||
          c == 0x1F59 ||
          c == 0x1F5B ||
          c == 0x1F5D ||
          c >= 0x1F5F && c <= 0x1F7D ||
          c >= 0x1F80 && c <= 0x1FB4 ||
          c >= 0x1FB6 && c <= 0x1FBC ||
          c == 0x1FBE ||
          c >= 0x1FC2 && c <= 0x1FC4 ||
          c >= 0x1FC6 && c <= 0x1FCC ||
          c >= 0x1FD0 && c <= 0x1FD3 ||
          c >= 0x1FD6 && c <= 0x1FDB ||
          c >= 0x1FE0 && c <= 0x1FEC ||
          c >= 0x1FF2 && c <= 0x1FF4 ||
          c >= 0x1FF6 && c <= 0x1FFC ||
          c == 0x2126 ||
          c >= 0x212A && c <= 0x212B ||
          c == 0x212E ||
          c >= 0x2180 && c <= 0x2182 ||
          c >= 0x3041 && c <= 0x3094 ||
          c >= 0x30A1 && c <= 0x30FA ||
          c >= 0x3105 && c <= 0x312C ||
          c >= 0xAC00 && c <= 0xD7A3 ||
          c >= 0x4E00 && c <= 0x9FA5 ||
          c == 0x3007 ||
          c >= 0x3021 && c <= 0x3029;
      };
      Utilities.isNCNameChar = function(c) {
        return c >= 0x0030 && c <= 0x0039 ||
          c >= 0x0660 && c <= 0x0669 ||
          c >= 0x06F0 && c <= 0x06F9 ||
          c >= 0x0966 && c <= 0x096F ||
          c >= 0x09E6 && c <= 0x09EF ||
          c >= 0x0A66 && c <= 0x0A6F ||
          c >= 0x0AE6 && c <= 0x0AEF ||
          c >= 0x0B66 && c <= 0x0B6F ||
          c >= 0x0BE7 && c <= 0x0BEF ||
          c >= 0x0C66 && c <= 0x0C6F ||
          c >= 0x0CE6 && c <= 0x0CEF ||
          c >= 0x0D66 && c <= 0x0D6F ||
          c >= 0x0E50 && c <= 0x0E59 ||
          c >= 0x0ED0 && c <= 0x0ED9 ||
          c >= 0x0F20 && c <= 0x0F29 ||
          c == 0x002E ||
          c == 0x002D ||
          c == 0x005F ||
          Utilities.isLetter(c) ||
          c >= 0x0300 && c <= 0x0345 ||
          c >= 0x0360 && c <= 0x0361 ||
          c >= 0x0483 && c <= 0x0486 ||
          c >= 0x0591 && c <= 0x05A1 ||
          c >= 0x05A3 && c <= 0x05B9 ||
          c >= 0x05BB && c <= 0x05BD ||
          c == 0x05BF ||
          c >= 0x05C1 && c <= 0x05C2 ||
          c == 0x05C4 ||
          c >= 0x064B && c <= 0x0652 ||
          c == 0x0670 ||
          c >= 0x06D6 && c <= 0x06DC ||
          c >= 0x06DD && c <= 0x06DF ||
          c >= 0x06E0 && c <= 0x06E4 ||
          c >= 0x06E7 && c <= 0x06E8 ||
          c >= 0x06EA && c <= 0x06ED ||
          c >= 0x0901 && c <= 0x0903 ||
          c == 0x093C ||
          c >= 0x093E && c <= 0x094C ||
          c == 0x094D ||
          c >= 0x0951 && c <= 0x0954 ||
          c >= 0x0962 && c <= 0x0963 ||
          c >= 0x0981 && c <= 0x0983 ||
          c == 0x09BC ||
          c == 0x09BE ||
          c == 0x09BF ||
          c >= 0x09C0 && c <= 0x09C4 ||
          c >= 0x09C7 && c <= 0x09C8 ||
          c >= 0x09CB && c <= 0x09CD ||
          c == 0x09D7 ||
          c >= 0x09E2 && c <= 0x09E3 ||
          c == 0x0A02 ||
          c == 0x0A3C ||
          c == 0x0A3E ||
          c == 0x0A3F ||
          c >= 0x0A40 && c <= 0x0A42 ||
          c >= 0x0A47 && c <= 0x0A48 ||
          c >= 0x0A4B && c <= 0x0A4D ||
          c >= 0x0A70 && c <= 0x0A71 ||
          c >= 0x0A81 && c <= 0x0A83 ||
          c == 0x0ABC ||
          c >= 0x0ABE && c <= 0x0AC5 ||
          c >= 0x0AC7 && c <= 0x0AC9 ||
          c >= 0x0ACB && c <= 0x0ACD ||
          c >= 0x0B01 && c <= 0x0B03 ||
          c == 0x0B3C ||
          c >= 0x0B3E && c <= 0x0B43 ||
          c >= 0x0B47 && c <= 0x0B48 ||
          c >= 0x0B4B && c <= 0x0B4D ||
          c >= 0x0B56 && c <= 0x0B57 ||
          c >= 0x0B82 && c <= 0x0B83 ||
          c >= 0x0BBE && c <= 0x0BC2 ||
          c >= 0x0BC6 && c <= 0x0BC8 ||
          c >= 0x0BCA && c <= 0x0BCD ||
          c == 0x0BD7 ||
          c >= 0x0C01 && c <= 0x0C03 ||
          c >= 0x0C3E && c <= 0x0C44 ||
          c >= 0x0C46 && c <= 0x0C48 ||
          c >= 0x0C4A && c <= 0x0C4D ||
          c >= 0x0C55 && c <= 0x0C56 ||
          c >= 0x0C82 && c <= 0x0C83 ||
          c >= 0x0CBE && c <= 0x0CC4 ||
          c >= 0x0CC6 && c <= 0x0CC8 ||
          c >= 0x0CCA && c <= 0x0CCD ||
          c >= 0x0CD5 && c <= 0x0CD6 ||
          c >= 0x0D02 && c <= 0x0D03 ||
          c >= 0x0D3E && c <= 0x0D43 ||
          c >= 0x0D46 && c <= 0x0D48 ||
          c >= 0x0D4A && c <= 0x0D4D ||
          c == 0x0D57 ||
          c == 0x0E31 ||
          c >= 0x0E34 && c <= 0x0E3A ||
          c >= 0x0E47 && c <= 0x0E4E ||
          c == 0x0EB1 ||
          c >= 0x0EB4 && c <= 0x0EB9 ||
          c >= 0x0EBB && c <= 0x0EBC ||
          c >= 0x0EC8 && c <= 0x0ECD ||
          c >= 0x0F18 && c <= 0x0F19 ||
          c == 0x0F35 ||
          c == 0x0F37 ||
          c == 0x0F39 ||
          c == 0x0F3E ||
          c == 0x0F3F ||
          c >= 0x0F71 && c <= 0x0F84 ||
          c >= 0x0F86 && c <= 0x0F8B ||
          c >= 0x0F90 && c <= 0x0F95 ||
          c == 0x0F97 ||
          c >= 0x0F99 && c <= 0x0FAD ||
          c >= 0x0FB1 && c <= 0x0FB7 ||
          c == 0x0FB9 ||
          c >= 0x20D0 && c <= 0x20DC ||
          c == 0x20E1 ||
          c >= 0x302A && c <= 0x302F ||
          c == 0x3099 ||
          c == 0x309A ||
          c == 0x00B7 ||
          c == 0x02D0 ||
          c == 0x02D1 ||
          c == 0x0387 ||
          c == 0x0640 ||
          c == 0x0E46 ||
          c == 0x0EC6 ||
          c == 0x3005 ||
          c >= 0x3031 && c <= 0x3035 ||
          c >= 0x309D && c <= 0x309E ||
          c >= 0x30FC && c <= 0x30FE;
      };
      Utilities.coalesceText = function(n) {
        for (var m = n.firstChild; m != null; m = m.nextSibling) {
          if (m.nodeType == 3 || m.nodeType == 4) {
            var s = m.nodeValue;
            var first = m;
            m = m.nextSibling;
            while (m != null && (m.nodeType == 3 || m.nodeType == 4)) {
              s += m.nodeValue;
              var del = m;
              m = m.nextSibling;
              del.parentNode.removeChild(del);
            }
            if (first.nodeType == 4) {
              var p = first.parentNode;
              if (first.nextSibling == null) {
                p.removeChild(first);
                p.appendChild(p.ownerDocument.createTextNode(s));
              } else {
                var next = first.nextSibling;
                p.removeChild(first);
                p.insertBefore(p.ownerDocument.createTextNode(s), next);
              }
            } else {
              first.nodeValue = s;
            }
            if (m == null) {
              break;
            }
          } else if (m.nodeType == 1) {
            Utilities.coalesceText(m);
          }
        }
      };
      Utilities.instance_of = function(o, c) {
        while (o != null) {
          if (o.constructor === c) {
            return true;
          }
          if (o === Object) {
            return false;
          }
          o = o.constructor.superclass;
        }
        return false;
      };
      Utilities.getElementById = function(n, id) {
        if (n.nodeType == 1) {
          if (n.getAttribute("id") == id ||
            n.getAttributeNS(null, "id") == id) {
            return n;
          }
        }
        for (var m = n.firstChild; m != null; m = m.nextSibling) {
          var res = Utilities.getElementById(m, id);
          if (res != null) {
            return res;
          }
        }
        return null;
      };
      var XPathException = (function() {
        function getMessage(code, exception) {
          var msg = exception ? ": " + exception.toString() : "";
          switch (code) {
            case XPathException.INVALID_EXPRESSION_ERR:
              return "Invalid expression" + msg;
            case XPathException.TYPE_ERR:
              return "Type error" + msg;
          }
          return null;
        }

        function XPathException(code, error, message) {
          var err = Error.call(this, getMessage(code, error) || message);
          err.code = code;
          err.exception = error;
          return err;
        }
        XPathException.prototype = Object.create(Error.prototype);
        XPathException.prototype.constructor = XPathException;
        XPathException.superclass = Error;
        XPathException.prototype.toString = function() {
          return this.message;
        };
        XPathException.fromMessage = function(message, error) {
          return new XPathException(null, error, message);
        };
        XPathException.INVALID_EXPRESSION_ERR = 51;
        XPathException.TYPE_ERR = 52;
        return XPathException;
      })();
      XPathExpression.prototype = {};
      XPathExpression.prototype.constructor = XPathExpression;
      XPathExpression.superclass = Object.prototype;

      function XPathExpression(e, r, p) {
        this.xpath = p.parse(e);
        this.context = new XPathContext();
        this.context.namespaceResolver = new XPathNSResolverWrapper(r);
      }
      XPathExpression.prototype.evaluate = function(n, t, res) {
        this.context.expressionContextNode = n;
        var result = this.xpath.evaluate(this.context);
        return new XPathResult(result, t);
      }
      XPathNSResolverWrapper.prototype = {};
      XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
      XPathNSResolverWrapper.superclass = Object.prototype;

      function XPathNSResolverWrapper(r) {
        this.xpathNSResolver = r;
      }
      XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
        if (this.xpathNSResolver == null) {
          return null;
        }
        return this.xpathNSResolver.lookupNamespaceURI(prefix);
      };
      NodeXPathNSResolver.prototype = {};
      NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
      NodeXPathNSResolver.superclass = Object.prototype;

      function NodeXPathNSResolver(n) {
        this.node = n;
        this.namespaceResolver = new NamespaceResolver();
      }
      NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
        return this.namespaceResolver.getNamespace(prefix, this.node);
      };
      XPathResult.prototype = {};
      XPathResult.prototype.constructor = XPathResult;
      XPathResult.superclass = Object.prototype;

      function XPathResult(v, t) {
        if (t == XPathResult.ANY_TYPE) {
          if (v.constructor === XString) {
            t = XPathResult.STRING_TYPE;
          } else if (v.constructor === XNumber) {
            t = XPathResult.NUMBER_TYPE;
          } else if (v.constructor === XBoolean) {
            t = XPathResult.BOOLEAN_TYPE;
          } else if (v.constructor === XNodeSet) {
            t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
          }
        }
        this.resultType = t;
        switch (t) {
          case XPathResult.NUMBER_TYPE:
            this.numberValue = v.numberValue();
            return;
          case XPathResult.STRING_TYPE:
            this.stringValue = v.stringValue();
            return;
          case XPathResult.BOOLEAN_TYPE:
            this.booleanValue = v.booleanValue();
            return;
          case XPathResult.ANY_UNORDERED_NODE_TYPE:
          case XPathResult.FIRST_ORDERED_NODE_TYPE:
            if (v.constructor === XNodeSet) {
              this.singleNodeValue = v.first();
              return;
            }
            break;
          case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
          case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
            if (v.constructor === XNodeSet) {
              this.invalidIteratorState = false;
              this.nodes = v.toArray();
              this.iteratorIndex = 0;
              return;
            }
            break;
          case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
          case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
            if (v.constructor === XNodeSet) {
              this.nodes = v.toArray();
              this.snapshotLength = this.nodes.length;
              return;
            }
            break;
        }
        throw new XPathException(XPathException.TYPE_ERR);
      };
      XPathResult.prototype.iterateNext = function() {
        if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE &&
          this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
          throw new XPathException(XPathException.TYPE_ERR);
        }
        return this.nodes[this.iteratorIndex++];
      };
      XPathResult.prototype.snapshotItem = function(i) {
        if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE &&
          this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
          throw new XPathException(XPathException.TYPE_ERR);
        }
        return this.nodes[i];
      };
      XPathResult.ANY_TYPE = 0;
      XPathResult.NUMBER_TYPE = 1;
      XPathResult.STRING_TYPE = 2;
      XPathResult.BOOLEAN_TYPE = 3;
      XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
      XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
      XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
      XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
      XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

      function installDOM3XPathSupport(doc, p) {
        doc.createExpression = function(e, r) {
          try {
            return new XPathExpression(e, r, p);
          } catch (e) {
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
          }
        };
        doc.createNSResolver = function(n) {
          return new NodeXPathNSResolver(n);
        };
        doc.evaluate = function(e, cn, r, t, res) {
          if (t < 0 || t > 9) {
            throw {
              code: 0,
              toString: function() {
                return "Request type not supported";
              }
            };
          }
          return doc.createExpression(e, r, p).evaluate(cn, t, res);
        };
      };
      try {
        var shouldInstall = true;
        try {
          if (document.implementation &&
            document.implementation.hasFeature &&
            document.implementation.hasFeature("XPath", null)) {
            shouldInstall = false;
          }
        } catch (e) {}
        if (shouldInstall) {
          installDOM3XPathSupport(document, new XPathParser());
        }
      } catch (e) {}
      installDOM3XPathSupport(exports, new XPathParser());
      (function() {
        var parser = new XPathParser();
        var defaultNSResolver = new NamespaceResolver();
        var defaultFunctionResolver = new FunctionResolver();
        var defaultVariableResolver = new VariableResolver();

        function makeNSResolverFromFunction(func) {
          return {
            getNamespace: function(prefix, node) {
              var ns = func(prefix, node);
              return ns || defaultNSResolver.getNamespace(prefix, node);
            }
          };
        }

        function makeNSResolverFromObject(obj) {
          return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
        }

        function makeNSResolverFromMap(map) {
          return makeNSResolverFromFunction(function(prefix) {
            return map[prefix];
          });
        }

        function makeNSResolver(resolver) {
          if (resolver && typeof resolver.getNamespace === "function") {
            return makeNSResolverFromObject(resolver);
          }
          if (typeof resolver === "function") {
            return makeNSResolverFromFunction(resolver);
          }
          if (typeof resolver === "object") {
            return makeNSResolverFromMap(resolver);
          }
          return defaultNSResolver;
        }

        function convertValue(value) {
          if (value === null ||
            typeof value === "undefined" ||
            value instanceof XString ||
            value instanceof XBoolean ||
            value instanceof XNumber ||
            value instanceof XNodeSet) {
            return value;
          }
          switch (typeof value) {
            case "string":
              return new XString(value);
            case "boolean":
              return new XBoolean(value);
            case "number":
              return new XNumber(value);
          }
          var ns = new XNodeSet();
          ns.addArray([].concat(value));
          return ns;
        }

        function makeEvaluator(func) {
          return function(context) {
            var args = Array.prototype.slice.call(arguments, 1).map(function(arg) {
              return arg.evaluate(context);
            });
            var result = func.apply(this, [].concat(context, args));
            return convertValue(result);
          };
        }

        function makeFunctionResolverFromFunction(func) {
          return {
            getFunction: function(name, namespace) {
              var found = func(name, namespace);
              if (found) {
                return makeEvaluator(found);
              }
              return defaultFunctionResolver.getFunction(name, namespace);
            }
          };
        }

        function makeFunctionResolverFromObject(obj) {
          return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
        }

        function makeFunctionResolverFromMap(map) {
          return makeFunctionResolverFromFunction(function(name) {
            return map[name];
          });
        }

        function makeFunctionResolver(resolver) {
          if (resolver && typeof resolver.getFunction === "function") {
            return makeFunctionResolverFromObject(resolver);
          }
          if (typeof resolver === "function") {
            return makeFunctionResolverFromFunction(resolver);
          }
          if (typeof resolver === "object") {
            return makeFunctionResolverFromMap(resolver);
          }
          return defaultFunctionResolver;
        }

        function makeVariableResolverFromFunction(func) {
          return {
            getVariable: function(name, namespace) {
              var value = func(name, namespace);
              return convertValue(value);
            }
          };
        }

        function makeVariableResolver(resolver) {
          if (resolver) {
            if (typeof resolver.getVariable === "function") {
              return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
            }
            if (typeof resolver === "function") {
              return makeVariableResolverFromFunction(resolver);
            }
            if (typeof resolver === "object") {
              return makeVariableResolverFromFunction(function(name) {
                return resolver[name];
              });
            }
          }
          return defaultVariableResolver;
        }

        function makeContext(options) {
          var context = new XPathContext();
          if (options) {
            context.namespaceResolver = makeNSResolver(options.namespaces);
            context.functionResolver = makeFunctionResolver(options.functions);
            context.variableResolver = makeVariableResolver(options.variables);
            context.expressionContextNode = options.node;
          } else {
            context.namespaceResolver = defaultNSResolver;
          }
          return context;
        }

        function evaluate(parsedExpression, options) {
          var context = makeContext(options);
          return parsedExpression.evaluate(context);
        }
        var evaluatorPrototype = {
          evaluate: function(options) {
            return evaluate(this.expression, options);
          },
          evaluateNumber: function(options) {
            return this.evaluate(options).numberValue();
          },
          evaluateString: function(options) {
            return this.evaluate(options).stringValue();
          },
          evaluateBoolean: function(options) {
            return this.evaluate(options).booleanValue();
          },
          evaluateNodeSet: function(options) {
            return this.evaluate(options).nodeset();
          },
          select: function(options) {
            return this.evaluateNodeSet(options).toArray()
          },
          select1: function(options) {
            return this.select(options)[0];
          }
        };

        function parse(xpath) {
          var parsed = parser.parse(xpath);
          return Object.create(evaluatorPrototype, {
            expression: {
              value: parsed
            }
          });
        }
        exports.parse = parse;
      })();
      exports.XPath = XPath;
      exports.XPathParser = XPathParser;
      exports.XPathResult = XPathResult;
      exports.Step = Step;
      exports.NodeTest = NodeTest;
      exports.BarOperation = BarOperation;
      exports.NamespaceResolver = NamespaceResolver;
      exports.FunctionResolver = FunctionResolver;
      exports.VariableResolver = VariableResolver;
      exports.Utilities = Utilities;
      exports.XPathContext = XPathContext;
      exports.XNodeSet = XNodeSet;
      exports.XBoolean = XBoolean;
      exports.XString = XString;
      exports.XNumber = XNumber;
      exports.select = function(e, doc, single) {
        return exports.selectWithResolver(e, doc, null, single);
      };
      exports.useNamespaces = function(mappings) {
        var resolver = {
          mappings: mappings || {},
          lookupNamespaceURI: function(prefix) {
            return this.mappings[prefix];
          }
        };
        return function(e, doc, single) {
          return exports.selectWithResolver(e, doc, resolver, single);
        };
      };
      exports.selectWithResolver = function(e, doc, resolver, single) {
        var expression = new XPathExpression(e, resolver, new XPathParser());
        var type = XPathResult.ANY_TYPE;
        var result = expression.evaluate(doc, type, null);
        if (result.resultType == XPathResult.STRING_TYPE) {
          result = result.stringValue;
        } else if (result.resultType == XPathResult.NUMBER_TYPE) {
          result = result.numberValue;
        } else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
          result = result.booleanValue;
        } else {
          result = result.nodes;
          if (single) {
            result = result[0];
          }
        }
        return result;
      };
      exports.select1 = function(e, doc) {
        return exports.select(e, doc, true);
      };
    })(xpath);
  }, {}]
}, {}, [7]);
/*! RESOURCE: pdb_HighchartsConfigBuilder */
var HighchartsBuilder = {
  getChartConfig: function(chartOptions, tzOffset) {
    var chartTitle = chartOptions.title.text,
      xAxisTitle = chartOptions.xAxis.title.text,
      xAxisCategories = chartOptions.xAxis.categories,
      yAxisTitle = chartOptions.yAxis.title.text,
      series = chartOptions.series;
    this.convertEpochtoMs(xAxisCategories);
    this.formatDataSeries(xAxisCategories, series);
    var config = {
      chart: {
        type: 'area',
        zoomType: 'x'
      },
      credits: {
        enabled: false
      },
      title: {
        text: chartTitle
      },
      xAxis: {
        type: 'datetime',
        title: {
          text: xAxisTitle,
          style: {
            textTransform: 'capitalize'
          }
        }
      },
      yAxis: {
        reversedStacks: false,
        title: {
          text: yAxisTitle,
          style: {
            textTransform: 'capitalize'
          }
        }
      },
      plotOptions: {
        area: {
          stacking: 'normal'
        },
        series: {
          marker: {
            enabled: true,
            symbol: 'circle',
            radius: 2
          },
          step: 'center'
        }
      },
      tooltip: {
        valueDecimals: 2,
        style: {
          whiteSpace: "wrap",
          width: "200px"
        }
      },
      series: series
    };
    var convertedOffset = -1 * (tzOffset / 60);
    Highcharts.setOptions({
      lang: {
        thousandsSep: ','
      },
      global: {
        timezoneOffset: convertedOffset
      }
    });
    return config;
  },
  convertEpochtoMs: function(categories) {
    categories.forEach(function(point, index, arr) {
      arr[index] *= 1000;
    });
  },
  formatDataSeries: function(categories, series) {
    series.forEach(function(row, index, arr) {
      arr[index].data.forEach(function(innerRow, innerIndex, innerArr) {
        var value = innerRow;
        if (value == "NaN") {
          value = 0;
        }
        var xValue = categories[innerIndex];
        innerArr[innerIndex] = [xValue, value];
      });
    });
  }
};
/*! RESOURCE: Updatesetpicker */
addLoadEvent(moveUpdateSetPicker);

function moveUpdateSetPicker() {
  try {
    if ($('navpage_header_control_button')) {
      $('update_set_picker_select').className = '';
      if ($('update_set_picker').select('li')[0]) {
        $('update_set_picker').select('ul')[0].style.marginBottom = "0px";
        $('update_set_picker').select('li')[0].className = '';
        $('update_set_picker').select('li')[0].style.paddingRight = "5px";
        $('update_set_picker').select('li')[0].style.listStyleType = "none";
        $('update_set_picker').select('li')[0].select('a')[0].style.color = "#FFF";
        $('update_set_picker').select('li')[0].select('a')[0].style.border = "none";
        $('update_set_picker').select('li')[0].select('a')[1].style.color = "#FFF";
        $('update_set_picker').select('li')[0].select('a')[1].style.border = "none";
        $('update_set_picker').select('li')[0].select('a')[2].style.color = "#FFF";
        $('update_set_picker').select('li')[0].select('a')[2].style.border = "none";
        $('update_set_picker_select').style.color = "#000";
        $$('.btn-icon').each(function(d) {
          d.style.lineHeight = 'inherit';
        });
      }
      if ($('update_set_picker').select('legend')[0]) {
        $('update_set_picker').select('legend')[0].remove();
      }
      $('nav_header_stripe_decorations').insert({
        top: $('update_set_picker')
      });
      $('update_set_picker').id = 'update_set_picker_new';
    }
  } catch (e) {}
}
/*! RESOURCE: ScrumCloneReleaseTeamDialog */
var ScrumCloneReleaseTeamDialog = Class.create();
ScrumCloneReleaseTeamDialog.prototype = {
  initialize: function() {
    this.setUpFacade();
  },
  setUpFacade: function() {
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("task_window");
    this._mstrDlg.setTitle(getMessage("Add Team Members"));
    this._mstrDlg.setBody(this.getMarkUp(), false, false);
  },
  setUpEvents: function() {
    var dialog = this._mstrDlg;
    var _this = this;
    var okButton = $("ok");
    if (okButton) {
      okButton.on("click", function() {
        var mapData = {};
        if (_this.fillDataMap(mapData)) {
          var processor = new GlideAjax("ScrumAjaxAddReleaseTeamMembers2Processor");
          for (var strKey in mapData) {
            processor.addParam(strKey, mapData[strKey]);
          }
          _this.showStatus(getMessage("Adding team members..."));
          processor.getXML(function() {
            _this.refresh();
            dialog.destroy();
          });
        } else {
          dialog.destroy();
        }
      });
    }
    var cancelButton = $("cancel");
    if (cancelButton) {
      cancelButton.on("click", function() {
        dialog.destroy();
      });
    }
    var okNGButton = $("okNG");
    if (okNGButton) {
      okNGButton.on("click", function() {
        dialog.destroy();
      });
    }
    var cancelNGButton = $("cancelNG");
    if (cancelNGButton) {
      cancelNGButton.on("click", function() {
        dialog.destroy();
      });
    }
    var teamCombo = $("teamId");
    if (teamCombo) {
      teamCombo.on("change", function() {
        _this.updateMembers();
      });
    }
  },
  updateMembers: function() {
    var arrMemberInfo = [];
    var teamCombo = $("teamId");
    if (teamCombo) {
      var strTeamSysId = teamCombo.value;
      var recTeamMember = new GlideRecord("scrum_pp_release_team_member");
      recTeamMember.addQuery("team", strTeamSysId);
      recTeamMember.query();
      while (recTeamMember.next()) {
        var recSysUser = new GlideRecord("sys_user");
        recSysUser.addQuery("sys_id", recTeamMember.name);
        recSysUser.query();
        var strName = recSysUser.next() ? recSysUser.name : "";
        var strPoints = recTeamMember.default_sprint_points + "";
        arrMemberInfo.push({
          name: strName,
          points: strPoints
        });
      }
    }
    if (arrMemberInfo.length > 0) {
      var strHtml = "<tr><th style='text-align: left; white-space: nowrap'>" +
        "Member</th><th style='text-align: left; white-space: nowrap'>Sprint Points</th><tr>";
      for (var nSlot = 0; nSlot < arrMemberInfo.length; ++nSlot) {
        var strMemberName = arrMemberInfo[nSlot].name + "";
        var strMemberPoints = arrMemberInfo[nSlot].points + "";
        strHtml += "<tr><td  style='text-align: left; white-space: nowrap'>" + strMemberName +
          "</td><td style='text-align: left; white-space: nowrap'>" + strMemberPoints + "</td></tr>";
      }
      $("memberId").update(strHtml);
    } else {
      $("memberId").update("<tr><td style='font-weight: bold'>" + getMessage("No team members") + "</td></tr>");
    }
  },
  refresh: function() {
    GlideList2.get("scrum_pp_team.scrum_pp_release_team_member.team").refresh();
  },
  getScrumReleaseTeamSysId: function() {
    return g_form.getUniqueValue() + "";
  },
  getUserChosenTeamSysIds: function() {
    return $F('teamId') + "";
  },
  showStatus: function(strMessage) {
    $("task_controls").update(strMessage);
  },
  display: function(bIsVisible) {
    $("task_window").style.visibility = (bIsVisible ? "visible" : "hidden");
  },
  getMarkUp: function() {
    var groupAjax = new GlideAjax('ScrumUserGroupsAjax');
    groupAjax.addParam('sysparm_name', 'getTeamInfo');
    groupAjax.addParam('sysparm_scrum_team_sysid', this.getScrumReleaseTeamSysId());
    groupAjax.getXML(this.generateMarkUp.bind(this));
  },
  generateMarkUp: function(response) {
    var mapTeamInfo = {};
    var teamData = response.responseXML.getElementsByTagName("team");
    var strName, strSysId;
    for (var i = 0; i < teamData.length; i++) {
      strName = teamData[i].getAttribute("name");
      strSysId = teamData[i].getAttribute("sysid");
      mapTeamInfo[strName] = {
        name: strName,
        sysid: strSysId
      };
    }
    var arrTeamNames = [];
    for (var strTeamName in mapTeamInfo) {
      arrTeamNames.push(strTeamName + "");
    }
    arrTeamNames.sort();
    var strMarkUp = "";
    if (arrTeamNames.length > 0) {
      var strTable = "<div class='row'><div class='form-group'><label class='col-sm-3 control-label' for='teamId'>" + getMessage("Team") + "</label><span class='col-sm-9'><select class='form-control' id='teamId'>";
      for (var nSlot = 0; nSlot < arrTeamNames.length; ++nSlot) {
        strName = arrTeamNames[nSlot];
        strSysId = mapTeamInfo[strName].sysid;
        strTable += "<option value='" + strSysId + "'>" + strName + "</option>";
      }
      strTable += "</select></span></div></div>";
      var strTable2 = "<div class='row' style='padding-top:10px;'><div id='memberId' class='col-sm-12'></div></div>";
      strMarkUp = "<div id='task_controls'>" + strTable + strTable2 +
        "<div style='text-align:right;padding-top:20px;'>" +
        "<button id='cancel' class='btn btn-default' type='button'>" + getMessage("Cancel") + "</button>" +
        "&nbsp;&nbsp;<button id='ok' class='btn btn-primary' type='button'>" + getMessage("OK") + "</button>" +
        "</div></div>";
    } else {
      strMarkUp = "<div id='task_controls'><p>No release teams found</p>" +
        "<div style='padding-top:20px;text-align:right;'>" +
        "<button id='cancelNG' class='btn btn-default' type='button'>" + getMessage("Cancel") + "</button>" +
        "&nbsp;&nbsp;<button id='okNG' class='btn btn-primary' type='button'>" + getMessage("OK") + "</button>" +
        "</div></div>";
    }
    this._mstrDlg.setBody(strMarkUp, false, false);
    this.setUpEvents();
    this.display(true);
  },
  fillDataMap: function(mapData) {
    var strChosenTeamSysId = this.getUserChosenTeamSysIds();
    if (strChosenTeamSysId) {
      mapData.sysparm_name = "createReleaseTeamMembers";
      mapData.sysparm_sys_id = this.getScrumReleaseTeamSysId();
      mapData.sysparm_teams = strChosenTeamSysId;
      return true;
    } else {
      return false;
    }
  }
};
/*! RESOURCE: ScrumAdjustRankHandler */
var ScrumAdjustRankHandler = Class.create({
  initialize: function(gr) {
    this._gr = gr;
  },
  showLoadingDialog: function() {
    this.loadingDialog = new GlideDialogWindow("dialog_loading", true, 300);
    this.loadingDialog.setPreference('table', 'loading');
    this.loadingDialog.render();
  },
  hideLoadingDialog: function() {
    this.loadingDialog && this.loadingDialog.destroy();
  },
  showProductDialog: function() {
    this._context = 'product';
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("scrum_adjust_rank_dialog");
    var titleMsg = getMessage("Select Product");
    this._mstrDlg.setTitle(titleMsg);
    this._mstrDlg.setPreference('handler', this);
    this._mstrDlg.setPreference('sysparam_reference_table', 'cmdb_application_product_model');
    this._mstrDlg.setPreference('sysparam_query', 'active=true');
    this._mstrDlg.setPreference('sysparam_field_label', getMessage('Product'));
    this._mstrDlg.render();
  },
  showGroupDialog: function() {
    this._context = 'group';
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._mstrDlg = new dialogClass("scrum_adjust_rank_dialog");
    var titleMsg = getMessage("Select Group");
    this._mstrDlg.setTitle(titleMsg);
    this._mstrDlg.setPreference('handler', this);
    this._mstrDlg.setPreference('sysparam_reference_table', 'sys_user_group');
    this._mstrDlg.setPreference('sysparam_query', 'active=true^typeLIKE1bff3b1493030200ea933007f67ffb6d^EQ');
    this._mstrDlg.setPreference('sysparam_field_label', getMessage('Group'));
    this._mstrDlg.render();
  },
  adjustOverallRank: function() {
    this._context = 'overall';
    this._contextId = -1;
    try {
      var ga = new GlideAjax("agile2_AjaxProcessor");
      ga.addParam('sysparm_name', 'compactStoryRanks');
      ga.addParam('sysparm_context', this._context);
      ga.addParam('sysparm_context_id', this._contextId);
      this.showLoadingDialog();
      ga.getXML(this.callback.bind(this));
    } catch (err) {
      this._displayErrorDialog();
      console.log(err);
    }
  },
  onSubmit: function() {
    try {
      if (!this._validate()) {
        return false;
      }
      var ga = new GlideAjax("agile2_AjaxProcessor");
      ga.addParam('sysparm_name', 'compactStoryRanks');
      ga.addParam('sysparm_context', this._context);
      ga.addParam('sysparm_context_id', this._contextId);
      this.showLoadingDialog();
      ga.getXML(this.callback.bind(this));
    } catch (err) {
      this._displayErrorDialog();
      console.log(err);
    }
    return false;
  },
  callback: function(response) {
    this.hideLoadingDialog();
    if (this._mstrDlg)
      this._mstrDlg.destroy();
    var resp = response.responseXML.getElementsByTagName("result");
    if (resp[0] && resp[0].getAttribute("status") == "success") {
      window.location.reload();
    } else if (resp[0] && resp[0].getAttribute("status") == "no_data") {
      this._displayNotification(getMessage("Didn't find any story with rank. Please rank the stories first and perform this action"));
    } else {
      this._displayErrorDialog();
    }
  },
  _displayErrorDialog: function() {
    var dialogClass = window.GlideModal ? GlideModal : GlideDialogWindow;
    this._createError = new dialogClass("ppm_int_error_dialog");
    this._createError.setTitle(getMessage("Error while adjusting ranks for Stories."));
    this._createError.render();
  },
  _displayNotification: function(msg) {
    var span = document.createElement('span');
    span.setAttribute('data-type', 'info');
    span.setAttribute('data-text', msg);
    span.setAttribute('data-duration', '4000');
    var notification = {
      xml: span
    };
    GlideUI.get().fire(new GlideUINotification(notification));
  },
  _validate: function() {
    if (this._context == 'product')
      this._contextId = this._getValue('cmdb_application_product_model_ref');
    if (this._context == 'group')
      this._contextId = this._getValue('sys_user_group_ref');
    if (typeof this._contextId == 'undefined' || this._contextId.trim() == '') {
      var errMsg;
      if (this._context == 'product')
        errMsg = getMessage('Product field cannot be empty');
      if (this._context == 'group')
        errMsg = getMessage('Group field cannot be empty');
      this._showFieldError('ref_rank_field', errMsg);
      return false;
    } else
      return true;
  },
  _getValue: function(inptNm) {
    return gel(inptNm).value;
  },
  _showFieldError: function(groupId, message) {
    var $group = $j('#' + groupId);
    var $helpBlock = $group.find('.help-block');
    if (!$group.hasClass('has-error'))
      $group.addClass('has-error');
    if ($helpBlock.css('display') != "inline") {
      $helpBlock.text(message);
      $helpBlock.css('display', 'inline');
    }
    var elem;
    if (this._context == 'product')
      elem = gel("sys_display.cmdb_application_product_model_ref");
    else if (this._context == 'group')
      elem = gel("sys_display.sys_user_group_ref");
    if (elem)
      elem.focus();
  },
  type: "ScrumAdjustRankHandler"
});
/*! RESOURCE: PmClientDateAndDurationHandler */
var PmClientDateAndDurationHandler = Class.create();
PmClientDateAndDurationHandler.prototype = {
  initialize: function(_gForm) {
    this._gForm = _gForm;
  },
  showErrorMessage: function(column, message) {
    jslog("Into PmClientDateAndDurationHandler.showErrorMessage -> " + column);
    if (!column) {
      this._gForm.addErrorMessage("Enter a valid date");
    } else {
      try {
        if (!message)
          this._gForm.showFieldMsg(column, 'Enter a valid date', 'error');
        else
          this._gForm.showFieldMsg(column, message, 'error');
      } catch (e) {
        jslog("PmClientDateAndDurationHandler.showErrorMessage: " + colum + " is not available on the form");
      }
    }
  },
  isValidClientDate: function(column) {
    jslog("Into PmClientDateAndDurationHandler.isValidClientDate -> " + column);
    var dateValue = this._gForm.getValue(column);
    if (dateValue == null || dateValue == '') {
      this.showErrorMessage(column);
      return false;
    }
    var date = new Date(dateValue);
    if (date != 'Invalid Date' && String(date.getFullYear()).length != 4) {
      this.showErrorMessage(column);
      return false;
    }
    return true;
  },
  isValidServerDate: function(column, dateValue, callback) {
    jslog("Into PmClientDateAndDurationHandler.isValidServerDate -> " + column + " - " + dateValue);
    this.callback = callback;
    var ga = new GlideAjax('AjaxProjectTaskUtil');
    ga.addParam('sysparm_name', 'validateDisplayDate');
    ga.addParam('sysparm_column', column);
    ga.addParam('sysparm_date', dateValue);
    ga.getXMLAnswer(this.validateResponse);
    return false;
  },
  validateResponse: function(serverResponse) {
    jslog("Into validateResponse.validateResponse -> " + serverResponse);
    if (serverResponse && serverResponse.responseXML) {
      var result = serverResponse.responseXML.getElementByTagName("result");
      var status = result.getAttribute("status");
      var column = result.getAttribute("column");
      if (status == 'error') {
        this.showErrorMessage(column);
      } else {
        jslog("Into validateResponse.validateResponse -> Calling Callback PmClientDateAndDurationHandler");
        this.callback();
      }
    }
  },
  type: 'PmClientDateAndDurationHandler'
};
/*! RESOURCE: /scripts/lib/jquery/jquery_clean.js */
(function() {
  if (!window.jQuery)
    return;
  if (!window.$j_glide)
    window.$j = jQuery.noConflict();
  if (window.$j_glide && jQuery != window.$j_glide) {
    if (window.$j_glide)
      jQuery.noConflict(true);
    window.$j = window.$j_glide;
  }
})();;;