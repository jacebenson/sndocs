/*! RESOURCE: /scripts/js_includes_sp.js */
/*! RESOURCE: /scripts/js_includes_sp_deps.js */
/*! RESOURCE: /scripts/lib/jquery/jquery-2.1.js */
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ?
      factory(global, true) :
      function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var
    document = window.document,
    version = "2.1.4",
    jQuery = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    },
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,
    fcamelCase = function(all, letter) {
      return letter.toUpperCase();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ?
        (num < 0 ? this[num + this.length] : this[num]) :
        slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
    },
    globalEval: function(code) {
      var script,
        indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ?
        "" :
        (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret,
            typeof arr === "string" ? [arr] : arr
          );
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike(elems),
        ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArraylike(obj) {
    var length = "length" in obj && obj.length,
      type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || length === 0 ||
      typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle =
    (function(window) {
      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
            len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
        "*([*^$|!~]?=)" + whitespace +
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
        "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" +
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        ".*" +
        ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
            String.fromCharCode(high + 0x10000) :
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ?
            function(target, els) {
              push_native.apply(target, slice.call(els));
            } : function(target, els) {
              var j = target.length,
                i = 0;
              while ((target[j++] = els[i++])) {}
              target.length = j - 1;
            }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var match, elem, m, nodeType,
          i, groups, old, nid, newContext, newSelector;
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        results = results || [];
        nodeType = context.nodeType;
        if (typeof selector !== "string" || !selector ||
          nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed && documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                elem = context.getElementById(m);
                if (elem && elem.parentNode) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                  contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType !== 1 && selector;
            if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
              groups = tokenize(selector);
              if ((old = context.getAttribute("id"))) {
                nid = old.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", nid);
              }
              nid = "[id='" + nid + "'] ";
              i = groups.length;
              while (i--) {
                groups[i] = nid + toSelector(groups[i]);
              }
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              newSelector = groups.join(",");
            }
            if (newSelector) {
              try {
                push.apply(results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {} finally {
                if (!old) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }

      function createCache() {
        var keys = [];

        function cache(key, value) {
          if (keys.push(key + " ") > Expr.cacheLength) {
            delete cache[keys.shift()];
          }
          return (cache[key + " "] = value);
        }
        return cache;
      }

      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      function assert(fn) {
        var div = document.createElement("div");
        try {
          return !!fn(div);
        } catch (e) {
          return false;
        } finally {
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
          div = null;
        }
      }

      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
          i = attrs.length;
        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }

      function siblingCheck(a, b) {
        var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);
        if (diff) {
          return diff;
        }
        if (cur) {
          while ((cur = cur.nextSibling)) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }

      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }

      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }

      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
            while (i--) {
              if (seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }
      support = Sizzle.support = {};
      isXML = Sizzle.isXML = function(elem) {
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare, parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }
        document = doc;
        docElem = doc.documentElement;
        parent = doc.defaultView;
        if (parent && parent !== parent.top) {
          if (parent.addEventListener) {
            parent.addEventListener("unload", unloadHandler, false);
          } else if (parent.attachEvent) {
            parent.attachEvent("onunload", unloadHandler);
          }
        }
        documentIsHTML = !isXML(doc);
        support.attributes = assert(function(div) {
          div.className = "i";
          return !div.getAttribute("className");
        });
        support.getElementsByTagName = assert(function(div) {
          div.appendChild(doc.createComment(""));
          return !div.getElementsByTagName("*").length;
        });
        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
        support.getById = assert(function(div) {
          docElem.appendChild(div).id = expando;
          return !doc.getElementsByName || !doc.getElementsByName(expando).length;
        });
        if (support.getById) {
          Expr.find["ID"] = function(id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var m = context.getElementById(id);
              return m && m.parentNode ? [m] : [];
            }
          };
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
        } else {
          delete Expr.find["ID"];
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };
        }
        Expr.find["TAG"] = support.getElementsByTagName ?
          function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          } :
          function(tag, context) {
            var elem,
              tmp = [],
              i = 0,
              results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while ((elem = results[i++])) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
          if (documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if ((support.qsa = rnative.test(doc.querySelectorAll))) {
          assert(function(div) {
            docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
              "<select id='" + expando + "-\f]' msallowcapture=''>" +
              "<option selected=''></option></select>";
            if (div.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }
            if (!div.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!div.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            if (!div.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function(div) {
            var input = doc.createElement("input");
            input.setAttribute("type", "hidden");
            div.appendChild(input).setAttribute("name", "D");
            if (div.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }
            if (!div.querySelectorAll(":enabled").length) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
            docElem.webkitMatchesSelector ||
            docElem.mozMatchesSelector ||
            docElem.oMatchesSelector ||
            docElem.msMatchesSelector)))) {
          assert(function(div) {
            support.disconnectedMatch = matches.call(div, "div");
            matches.call(div, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains = hasCompare || rnative.test(docElem.contains) ?
          function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (
              adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
          } :
          function(a, b) {
            if (b) {
              while ((b = b.parentNode)) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
        sortOrder = hasCompare ?
          function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
              a.compareDocumentPosition(b) :
              1;
            if (compare & 1 ||
              (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
              if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;
            }
            return compare & 4 ? -1 : 1;
          } :
          function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b];
            if (!aup || !bup) {
              return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while ((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while ((cur = cur.parentNode)) {
              bp.unshift(cur);
            }
            while (ap[i] === bp[i]) {
              i++;
            }
            return i ?
              siblingCheck(ap[i], bp[i]) :
              ap[i] === preferredDoc ? -1 :
              bp[i] === preferredDoc ? 1 :
              0;
          };
        return doc;
      };
      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };
      Sizzle.matchesSelector = function(elem, expr) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        expr = expr.replace(rattributeQuotes, "='$1']");
        if (support.matchesSelector && documentIsHTML &&
          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
          (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support.disconnectedMatch ||
              elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }
        return Sizzle(expr, document, null, [elem]).length > 0;
      };
      Sizzle.contains = function(context, elem) {
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle.attr = function(elem, name) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          undefined;
        return val !== undefined ?
          val :
          support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) && val.specified ?
          val.value :
          null;
      };
      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle.uniqueSort = function(results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while ((elem = results[i++])) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle.getText = function(elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
        if (!nodeType) {
          while ((node = elem[i++])) {
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function(match) {
            match[1] = match[1].replace(runescape, funescape);
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
          },
          "CHILD": function(match) {
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
              if (!match[3]) {
                Sizzle.error(match[0]);
              }
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +((match[7] + match[8]) || match[3] === "odd");
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }
            return match;
          },
          "PSEUDO": function(match) {
            var excess,
              unquoted = !match[6] && match[2];
            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }
            if (match[3]) {
              match[2] = match[4] || match[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) &&
              (excess = tokenize(unquoted, true)) &&
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ?
              function() {
                return true;
              } :
              function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
          },
          "CLASS": function(className) {
            var pattern = classCache[className + " "];
            return pattern ||
              (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
              classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
          },
          "ATTR": function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check :
                operator === "!=" ? result !== check :
                operator === "^=" ? check && result.indexOf(check) === 0 :
                operator === "*=" ? check && result.indexOf(check) > -1 :
                operator === "$=" ? check && result.slice(-check.length) === check :
                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                false;
            };
          },
          "CHILD": function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
            return first === 1 && last === 0 ?
              function(elem) {
                return !!elem.parentNode;
              } :
              function(elem, context, xml) {
                var cache, outerCache, node, diff, nodeIndex, start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType;
                if (parent) {
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = cache[0] === dirruns && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while ((node = ++nodeIndex && node && node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                    diff = cache[1];
                  } else {
                    while ((node = ++nodeIndex && node && node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        if (useCache) {
                          (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || (diff % first === 0 && diff / first >= 0);
                }
              };
          },
          "PSEUDO": function(pseudo, argument) {
            var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                markFunction(function(seed, matches) {
                  var idx,
                    matched = fn(seed, argument),
                    i = matched.length;
                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) :
                function(elem) {
                  return fn(elem, 0, args);
                };
            }
            return fn;
          }
        },
        pseudos: {
          "not": markFunction(function(selector) {
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ?
              markFunction(function(seed, matches, context, xml) {
                var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length;
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) :
              function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
          }),
          "has": markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          "contains": markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          "lang": markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if ((elemLang = documentIsHTML ?
                    elem.lang :
                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          "target": function(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function(elem) {
            return elem === docElem;
          },
          "focus": function(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          "enabled": function(elem) {
            return elem.disabled === false;
          },
          "disabled": function(elem) {
            return elem.disabled === true;
          },
          "checked": function(elem) {
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
          },
          "selected": function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          "empty": function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          "parent": function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          "header": function(elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function(elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          "text": function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
              elem.type === "text" &&
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          "first": createPositionalPseudo(function() {
            return [0];
          }),
          "last": createPositionalPseudo(function(matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; --i >= 0;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; ++i < length;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in {
          submit: true,
          reset: true
        }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[selector + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }
          matched = false;
          if ((match = rcombinators.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ?
          soFar.length :
          soFar ?
          Sizzle.error(selector) :
          tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for (; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
        return combinator.first ?
          function(elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          } :
          function(elem, context, xml) {
            var oldCache, outerCache,
              newCache = [dirruns, doneName];
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if ((oldCache = outerCache[dir]) &&
                    oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return (newCache[2] = oldCache[2]);
                  } else {
                    outerCache[dir] = newCache;
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ?
          function(elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } :
          matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
        for (; i < len; i++) {
          if ((elem = unmatched[i])) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }
        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,
            matcherOut = matcher ?
            postFinder || (seed ? preFilter : preexisting || postFilter) ? [] :
            results :
            matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            i = temp.length;
            while (i--) {
              if ((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i])) {
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(
              matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
              (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
        for (; i < len; i++) {
          if ((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
            if (matcher[expando]) {
              j = ++i;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher(matchers),
                i > 1 && toSelector(
                  tokens.slice(0, i - 1).concat({
                    value: tokens[i - 2].type === " " ? "*" : ""
                  })
                ).replace(rtrim, "$1"),
                matcher,
                i < j && matcherFromTokens(tokens.slice(i, j)),
                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 &&
                (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
        return bySet ?
          markFunction(superMatcher) :
          superMatcher;
      }
      compile = Sizzle.compile = function(selector, match) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
        if (!cached) {
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
          cached.selector = selector;
        }
        return cached;
      };
      select = Sizzle.select = function(selector, context, results, seed) {
        var i, tokens, token, type, find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
        results = results || [];
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
            support.getById && context.nodeType === 9 && documentIsHTML &&
            Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {
              if ((seed = find(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                ))) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile(selector, match))(
          seed,
          context, !documentIsHTML,
          results,
          rsibling.test(selector) && testContext(context.parentNode) || context
        );
        return results;
      };
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support.detectDuplicates = !!hasDuplicate;
      setDocument();
      support.sortDetached = assert(function(div1) {
        return div1.compareDocumentPosition(document.createElement("div")) & 1;
      });
      if (!assert(function(div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support.attributes || !assert(function(div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
        addHandle("value", function(elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() :
              (val = elem.getAttributeNode(name)) && val.specified ?
              val.value :
              null;
          }
        });
      }
      return Sizzle;
    })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;

  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ?
      jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
      jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
        return elem.nodeType === 1;
      }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
        len = this.length,
        ret = [],
        self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(
        this,
        typeof selector === "string" && rneedsContext.test(selector) ?
        jQuery(selector) :
        selector || [],
        false
      ).length;
    }
  });
  var rootjQuery,
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    init = jQuery.fn.init = function(selector, context) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document,
              true
            ));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return typeof rootjQuery.ready !== "undefined" ?
          rootjQuery.ready(selector) :
          selector(jQuery);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
        truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
        l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
        jQuery(selectors, context || this.context) :
        0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ?
              pos.index(cur) > -1 :
              cur.nodeType === 1 &&
              jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this,
        elem.jquery ? elem[0] : elem
      );
    },
    add: function(selector, context) {
      return this.pushStack(
        jQuery.unique(
          jQuery.merge(this.get(), jQuery(selector, context))
        )
      );
    },
    addBack: function(selector) {
      return this.add(selector == null ?
        this.prevObject : this.prevObject.filter(selector)
      );
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};

  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ?
      (optionsCache[options] || createOptions(options)) :
      jQuery.extend({}, options);
    var
      memory,
      fired,
      firing,
      firingStart,
      firingLength,
      firingIndex,
      list = [],
      stack = !options.once && [],
      fire = function(data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      self = {
        add: function() {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function(_, arg) {
                var type = jQuery.type(arg);
                if (type === "function") {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function() {
          if (list) {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function() {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function() {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function() {
          return !list;
        },
        lock: function() {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function() {
          return !stack;
        },
        fireWith: function(context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function() {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function() {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [
          ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery.Callbacks("memory")]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(i, tuple) {
                var fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise()
                      .done(newDefer.resolve)
                      .fail(newDefer.reject)
                      .progress(newDefer.notify);
                  } else {
                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
        deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
          stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
        resolveValues = slice.call(arguments),
        length = resolveValues.length,
        remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        updateFunc = function(i, contexts, values) {
          return function(value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!(--remaining)) {
              deferred.resolveWith(contexts, values);
            }
          };
        },
        progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise()
              .done(updateFunc(i, resolveContexts, resolveValues))
              .fail(deferred.reject)
              .progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ?
      elems :
      bulk ?
      fn.call(elems) :
      len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };

  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
        unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {
            value: unlock
          };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ?
        cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined ||
        ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ?
          stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i, name, camel,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(
        this.cache[owner[this.expando]] || {}
      );
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true :
            data === "false" ? false :
            data === "null" ? null :
            +data + "" === data ? +data :
            rbrace.test(data) ? jQuery.parseJSON(data) :
            data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i, name, data,
        elem = this[0],
        attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
          camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function() {
          jQuery.dequeue(elem, type);
        };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ?
        this :
        this.each(function() {
          var queue = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
          if (!(--count)) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) &&
            (!handler || handler.guid === handleObj.guid) &&
            (!tmp || tmp.test(handleObj.namespace)) &&
            (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ?
        event :
        new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ?
        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
        null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] :
        jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ?
          bubbleType :
          special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
          jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj,
        handlerQueue = [],
        args = slice.call(arguments),
        handlers = (data_priv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
              .apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i, matches, sel, handleObj,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ?
                  jQuery(sel, this).index(cur) >= 0 :
                  jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc, doc, body,
          button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy,
        type = event.type,
        originalEvent = event,
        fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook =
          rmouseEvent.test(type) ? this.mouseHooks :
          rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {
        noBubble: true
      },
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(
        new jQuery.Event(),
        event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        }
      );
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &&
        src.returnValue === false ?
        returnTrue :
        returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    wrapMap = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") &&
      jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?
      elem.getElementsByTagName("tbody")[0] ||
      elem.appendChild(elem.ownerDocument.createElement("tbody")) :
      elem;
  }

  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }

  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;
    for (; i < l; i++) {
      data_priv.set(
        elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
      );
    }
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }

  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
      context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ?
      jQuery.merge([context], ret) :
      ret;
  }

  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
        !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data, elem, type, key,
        special = jQuery.event.special,
        i = 0;
      for (;
        (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ?
          jQuery.text(this) :
          this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
        elems = selector ? jQuery.filter(selector, this) : this,
        i = 0;
      for (;
        (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
        i = 0;
      for (;
        (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
          i = 0,
          l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) &&
          !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc,
        i = 0,
        l = this.length,
        set = this,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
      if (isFunction ||
        (l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") &&
                !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
        ret = [],
        insert = jQuery(selector),
        last = insert.length - 1,
        i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
    elemdisplay = {};

  function actualDisplay(name, doc) {
    var style,
      elem = jQuery(doc.createElement(name)).appendTo(doc.body),
      display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?
      style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }

  function defaultDisplay(nodeName) {
    var doc = document,
      display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };

  function curCSS(elem, name, computed) {
    var width, minWidth, maxWidth, ret,
      style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ?
      ret + "" :
      ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    return {
      get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }
  (function() {
    var pixelPositionVal, boxSizingReliableVal,
      docElem = document.documentElement,
      container = document.createElement("div"),
      div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
      "position:absolute";
    container.appendChild(div);

    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText =
        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
        "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
            marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret, name,
      old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
    cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    cssPrefixes = ["Webkit", "O", "Moz", "ms"];

  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
      origName = name,
      i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ?
      Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
      value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ?
      4 :
      name === "width" ? 1 : 0,
      val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
      val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
      styles = getStyles(elem),
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox &&
        (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      )
    ) + "px";
  }

  function showHide(elements, show) {
    var display, elem, hidden,
      values = [],
      index = 0,
      length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks,
        origName = jQuery.camelCase(name),
        style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val, num, hooks,
        origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
            jQuery.swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, name, extra);
            }) :
            getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ?
          augmentWidthOrHeight(
            elem,
            name,
            extra,
            jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            styles
          ) : 0
        );
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
    function(elem, computed) {
      if (computed) {
        return jQuery.swap(elem, {
            "display": "inline-block"
          },
          curCSS, [elem, "marginRight"]);
      }
    }
  );
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function(value) {
        var i = 0,
          expanded = {},
          parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] =
            parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles, len,
          map = {},
          i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ?
          jQuery.style(elem, name, value) :
          jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ?
        hooks.get(this) :
        Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent, this.options.duration * percent, 0, 1, this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null &&
          (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
    rrun = /queueHooks$/,
    animationPrefilters = [defaultPrefilter],
    tweeners = {
      "*": [function(prop, value) {
        var tween = this.createTween(prop, value),
          target = tween.cur(),
          parts = rfxnum.exec(value),
          unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          start = (jQuery.cssNumber[prop] || unit !== "px" && +target) &&
          rfxnum.exec(jQuery.css(tween.elem, prop)),
          scale = 1,
          maxIterations = 20;
        if (start && start[3] !== unit) {
          unit = unit || start[3];
          parts = parts || [];
          start = +target || 1;
          do {
            scale = scale || ".5";
            start = start / scale;
            jQuery.style(tween.elem, prop, start + unit);
          } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
        }
        if (parts) {
          start = tween.start = +start || +target || 0;
          tween.unit = unit;
          tween.end = parts[1] ?
            start + (parts[1] + 1) * parts[2] :
            +parts[2];
        }
        return tween;
      }]
    };

  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }

  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = {
        height: type
      };
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
      collection = (tweeners[prop] || []).concat(tweeners["*"]),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHidden(elem),
      dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ?
        data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = animationPrefilters.length,
      deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }),
      tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {}
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end,
            animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index = 0,
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      })
    );
    return animation.progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
        index = 0,
        length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing ||
        jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show()
        .end().animate({
          opacity: to
        }, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ?
        this.each(doAnimation) :
        this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
          data = data_priv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ?
        cssFn.apply(this, arguments) :
        this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
      i = 0,
      timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks, ret,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ?
          undefined :
          ret;
      }
    },
    removeAttr: function(elem, value) {
      var name, propName,
        i = 0,
        attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function(elem, value) {
          if (!support.radioValue && value === "radio" &&
            jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    }
  });
  boolHook = {
    set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret, handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ?
          name.toLowerCase() :
          null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret, hooks, notxml,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
          ret :
          (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
          ret :
          elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
            elem.tabIndex :
            -1;
        }
      }
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
  ], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = typeof value === "string" && value,
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            " "
          );
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = arguments.length === 0 || typeof value === "string" && value,
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            ""
          );
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
            i = 0,
            self = jQuery(this),
            classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
        i = 0,
        l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function(value) {
      var hooks, ret, isFunction,
        elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ?
            ret.replace(rreturn, "") :
            ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ?
            val :
            jQuery.trim(jQuery.text(elem));
        }
      },
      select: {
        get: function(elem) {
          var value, option,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one" || index < 0,
            values = one ? null : [],
            max = one ? index + 1 : options.length,
            i = index < 0 ?
            max :
            one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) &&
              (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet, option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {
      set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ?
        this.on(name, null, data, fn) :
        this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml, tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var
    rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    prefilters = {},
    transports = {},
    allTypes = "*/".concat("*"),
    ajaxLocation = window.location.href,
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
      seekingTransport = (structure === transports);

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }

  function ajaxExtend(target, src) {
    var key, deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }

  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev,
      converters = {},
      dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] ||
                  converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ?
        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
        ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
        cacheURL,
        responseHeadersString,
        responseHeaders,
        timeoutTimer,
        parts,
        fireGlobals,
        i,
        s = jQuery.ajaxSetup({}, options),
        callbackContext = s.context || s,
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ?
        jQuery(callbackContext) :
        jQuery.event,
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        statusCode = s.statusCode || {},
        requestHeaders = {},
        requestHeadersNames = {},
        state = 0,
        strAbort = "canceled",
        jqXHR = {
          readyState: 0,
          getResponseHeader: function(key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while ((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function() {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function(name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function(type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function(map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
        .replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts &&
          (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
            (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
            (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
        );
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ?
            cacheURL.replace(rts, "$1_=" + nonce++) :
            cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
        s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
        s.accepts["*"]
      );
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }

      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified,
          statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
          contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
      s = [],
      add = function(key, value) {
        value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        })
        .filter(function() {
          var type = this.type;
          return this.name && !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type));
        })
        .map(function(i, elem) {
          var val = jQuery(this).val();
          return val == null ?
            null :
            jQuery.isArray(val) ?
            jQuery.map(val, function(val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            }) : {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
        }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
    xhrCallbacks = {},
    xhrSuccessStatus = {
      0: 200,
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
            xhr = options.xhr(),
            id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(
                    xhr.status,
                    xhr.statusText
                  );
                } else {
                  complete(
                    xhrSuccessStatus[xhr.status] || xhr.status,
                    xhr.statusText,
                    typeof xhr.responseText === "string" ? {
                      text: xhr.responseText
                    } : undefined,
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on(
            "load error",
            callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            }
          );
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer,
      jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
        "url" :
        typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
      );
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
        s.jsonpCallback() :
        s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
      scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response,
      self = this,
      off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ?
          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
          responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;

  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {
    setOffset: function(elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") &&
        (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ?
          this :
          this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
      }
      var docElem, win,
        elem = this[0],
        box = {
          top: 0,
          left: 0
        },
        doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset,
        elem = this[0],
        parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset,
            top ? val : window.pageYOffset
          );
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
      function(elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed) ?
            jQuery(elem).position()[prop] + "px" :
            computed;
        }
      }
    );
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(
              elem.body["scroll" + name], doc["scroll" + name],
              elem.body["offset" + name], doc["offset" + name],
              doc["client" + name]
            );
          }
          return value === undefined ?
            jQuery.css(elem, type, extra) :
            jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("jquery", [], function() {
      return jQuery;
    });
  }
  var
    _jQuery = window.jQuery,
    _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));;
/*! RESOURCE: /scripts/angular_includes_no_min_1.5.8.js */
/*! RESOURCE: /scripts/angular_1.5.8/angular.js */
(function(window) {
  'use strict';

  function minErr(module, ErrorConstructor) {
    ErrorConstructor = ErrorConstructor || Error;
    return function() {
      var SKIP_INDEXES = 2;
      var templateArgs = arguments,
        code = templateArgs[0],
        message = '[' + (module ? module + ':' : '') + code + '] ',
        template = templateArgs[1],
        paramPrefix, i;
      message += template.replace(/\{\d+\}/g, function(match) {
        var index = +match.slice(1, -1),
          shiftedIndex = index + SKIP_INDEXES;
        if (shiftedIndex < templateArgs.length) {
          return toDebugString(templateArgs[shiftedIndex]);
        }
        return match;
      });
      message += '\nhttp://errors.angularjs.org/1.5.8/' +
        (module ? module + '/' : '') + code;
      for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
        message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' +
          encodeURIComponent(toDebugString(templateArgs[i]));
      }
      return new ErrorConstructor(message);
    };
  }
  var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
  var VALIDITY_STATE_PROPERTY = 'validity';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var lowercase = function(string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function(string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function(s) {
    return isString(s) ?
      s.replace(/[A-Z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) | 32);
      }) :
      s;
  };
  var manualUppercase = function(s) {
    return isString(s) ?
      s.replace(/[a-z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) & ~32);
      }) :
      s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var
    msie,
    jqLite,
    jQuery,
    slice = [].slice,
    splice = [].splice,
    push = [].push,
    toString = Object.prototype.toString,
    getPrototypeOf = Object.getPrototypeOf,
    ngMinErr = minErr('ng'),
    angular = window.angular || (window.angular = {}),
    angularModule,
    uid = 0;
  msie = window.document.documentMode;

  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) return false;
    if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true;
    var length = "length" in Object(obj) && obj.length;
    return isNumber(length) &&
      (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
  }

  function forEach(obj, iterator, context) {
    var key, length;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (isArray(obj) || isArrayLike(obj)) {
        var isPrimitive = typeof obj !== 'object';
        for (key = 0, length = obj.length; key < length; key++) {
          if (isPrimitive || key in obj) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context, obj);
      } else if (isBlankObject(obj)) {
        for (key in obj) {
          iterator.call(context, obj[key], key, obj);
        }
      } else if (typeof obj.hasOwnProperty === 'function') {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else {
        for (key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      }
    }
    return obj;
  }

  function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort();
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }

  function reverseParams(iteratorFn) {
    return function(value, key) {
      iteratorFn(key, value);
    };
  }

  function nextUid() {
    return ++uid;
  }

  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }

  function baseExtend(dst, objs, deep) {
    var h = dst.$$hashKey;
    for (var i = 0, ii = objs.length; i < ii; ++i) {
      var obj = objs[i];
      if (!isObject(obj) && !isFunction(obj)) continue;
      var keys = Object.keys(obj);
      for (var j = 0, jj = keys.length; j < jj; j++) {
        var key = keys[j];
        var src = obj[key];
        if (deep && isObject(src)) {
          if (isDate(src)) {
            dst[key] = new Date(src.valueOf());
          } else if (isRegExp(src)) {
            dst[key] = new RegExp(src);
          } else if (src.nodeName) {
            dst[key] = src.cloneNode(true);
          } else if (isElement(src)) {
            dst[key] = src.clone();
          } else {
            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
            baseExtend(dst[key], [src], true);
          }
        } else {
          dst[key] = src;
        }
      }
    }
    setHashKey(dst, h);
    return dst;
  }

  function extend(dst) {
    return baseExtend(dst, slice.call(arguments, 1), false);
  }

  function merge(dst) {
    return baseExtend(dst, slice.call(arguments, 1), true);
  }

  function toInt(str) {
    return parseInt(str, 10);
  }

  function inherit(parent, extra) {
    return extend(Object.create(parent), extra);
  }

  function noop() {}
  noop.$inject = [];

  function identity($) {
    return $;
  }
  identity.$inject = [];

  function valueFn(value) {
    return function valueRef() {
      return value;
    };
  }

  function hasCustomToString(obj) {
    return isFunction(obj.toString) && obj.toString !== toString;
  }

  function isUndefined(value) {
    return typeof value === 'undefined';
  }

  function isDefined(value) {
    return typeof value !== 'undefined';
  }

  function isObject(value) {
    return value !== null && typeof value === 'object';
  }

  function isBlankObject(value) {
    return value !== null && typeof value === 'object' && !getPrototypeOf(value);
  }

  function isString(value) {
    return typeof value === 'string';
  }

  function isNumber(value) {
    return typeof value === 'number';
  }

  function isDate(value) {
    return toString.call(value) === '[object Date]';
  }
  var isArray = Array.isArray;

  function isFunction(value) {
    return typeof value === 'function';
  }

  function isRegExp(value) {
    return toString.call(value) === '[object RegExp]';
  }

  function isWindow(obj) {
    return obj && obj.window === obj;
  }

  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }

  function isFile(obj) {
    return toString.call(obj) === '[object File]';
  }

  function isFormData(obj) {
    return toString.call(obj) === '[object FormData]';
  }

  function isBlob(obj) {
    return toString.call(obj) === '[object Blob]';
  }

  function isBoolean(value) {
    return typeof value === 'boolean';
  }

  function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
  }
  var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;

  function isTypedArray(value) {
    return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
  }

  function isArrayBuffer(obj) {
    return toString.call(obj) === '[object ArrayBuffer]';
  }
  var trim = function(value) {
    return isString(value) ? value.trim() : value;
  };
  var escapeForRegexp = function(s) {
    return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
    replace(/\x08/g, '\\x08');
  };

  function isElement(node) {
    return !!(node &&
      (node.nodeName ||
        (node.prop && node.attr && node.find)));
  }

  function makeMap(str) {
    var obj = {},
      items = str.split(','),
      i;
    for (i = 0; i < items.length; i++) {
      obj[items[i]] = true;
    }
    return obj;
  }

  function nodeName_(element) {
    return lowercase(element.nodeName || (element[0] && element[0].nodeName));
  }

  function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) != -1;
  }

  function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index >= 0) {
      array.splice(index, 1);
    }
    return index;
  }

  function copy(source, destination) {
    var stackSource = [];
    var stackDest = [];
    if (destination) {
      if (isTypedArray(destination) || isArrayBuffer(destination)) {
        throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
      }
      if (source === destination) {
        throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
      }
      if (isArray(destination)) {
        destination.length = 0;
      } else {
        forEach(destination, function(value, key) {
          if (key !== '$$hashKey') {
            delete destination[key];
          }
        });
      }
      stackSource.push(source);
      stackDest.push(destination);
      return copyRecurse(source, destination);
    }
    return copyElement(source);

    function copyRecurse(source, destination) {
      var h = destination.$$hashKey;
      var key;
      if (isArray(source)) {
        for (var i = 0, ii = source.length; i < ii; i++) {
          destination.push(copyElement(source[i]));
        }
      } else if (isBlankObject(source)) {
        for (key in source) {
          destination[key] = copyElement(source[key]);
        }
      } else if (source && typeof source.hasOwnProperty === 'function') {
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      } else {
        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      }
      setHashKey(destination, h);
      return destination;
    }

    function copyElement(source) {
      if (!isObject(source)) {
        return source;
      }
      var index = stackSource.indexOf(source);
      if (index !== -1) {
        return stackDest[index];
      }
      if (isWindow(source) || isScope(source)) {
        throw ngMinErr('cpws',
          "Can't copy! Making copies of Window or Scope instances is not supported.");
      }
      var needsRecurse = false;
      var destination = copyType(source);
      if (destination === undefined) {
        destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
        needsRecurse = true;
      }
      stackSource.push(source);
      stackDest.push(destination);
      return needsRecurse ?
        copyRecurse(source, destination) :
        destination;
    }

    function copyType(source) {
      switch (toString.call(source)) {
        case '[object Int8Array]':
        case '[object Int16Array]':
        case '[object Int32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Uint16Array]':
        case '[object Uint32Array]':
          return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
        case '[object ArrayBuffer]':
          if (!source.slice) {
            var copied = new ArrayBuffer(source.byteLength);
            new Uint8Array(copied).set(new Uint8Array(source));
            return copied;
          }
          return source.slice(0);
        case '[object Boolean]':
        case '[object Number]':
        case '[object String]':
        case '[object Date]':
          return new source.constructor(source.valueOf());
        case '[object RegExp]':
          var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
          re.lastIndex = source.lastIndex;
          return re;
        case '[object Blob]':
          return new source.constructor([source], {
            type: source.type
          });
      }
      if (isFunction(source.cloneNode)) {
        return source.cloneNode(true);
      }
    }
  }

  function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 && o2 !== o2) return true;
    var t1 = typeof o1,
      t2 = typeof o2,
      length, key, keySet;
    if (t1 == t2 && t1 == 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) == o2.length) {
          for (key = 0; key < length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        if (!isDate(o2)) return false;
        return equals(o1.getTime(), o2.getTime());
      } else if (isRegExp(o1)) {
        if (!isRegExp(o2)) return false;
        return o1.toString() == o2.toString();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
          isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
        keySet = createMap();
        for (key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for (key in o2) {
          if (!(key in keySet) &&
            key.charAt(0) !== '$' &&
            isDefined(o2[key]) &&
            !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
    return false;
  }
  var csp = function() {
    if (!isDefined(csp.rules)) {
      var ngCspElement = (window.document.querySelector('[ng-csp]') ||
        window.document.querySelector('[data-ng-csp]'));
      if (ngCspElement) {
        var ngCspAttribute = ngCspElement.getAttribute('ng-csp') ||
          ngCspElement.getAttribute('data-ng-csp');
        csp.rules = {
          noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
          noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
        };
      } else {
        csp.rules = {
          noUnsafeEval: noUnsafeEval(),
          noInlineStyle: false
        };
      }
    }
    return csp.rules;

    function noUnsafeEval() {
      try {
        new Function('');
        return false;
      } catch (e) {
        return true;
      }
    }
  };
  var jq = function() {
    if (isDefined(jq.name_)) return jq.name_;
    var el;
    var i, ii = ngAttrPrefixes.length,
      prefix, name;
    for (i = 0; i < ii; ++i) {
      prefix = ngAttrPrefixes[i];
      if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
        name = el.getAttribute(prefix + 'jq');
        break;
      }
    }
    return (jq.name_ = name);
  };

  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }

  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }

  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ?
        function() {
          return arguments.length ?
            fn.apply(self, concat(curryArgs, arguments, 0)) :
            fn.apply(self, curryArgs);
        } :
        function() {
          return arguments.length ?
            fn.apply(self, arguments) :
            fn.call(self);
        };
    } else {
      return fn;
    }
  }

  function toJsonReplacer(key, value) {
    var val = value;
    if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && window.document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }

  function toJson(obj, pretty) {
    if (isUndefined(obj)) return undefined;
    if (!isNumber(pretty)) {
      pretty = pretty ? 2 : null;
    }
    return JSON.stringify(obj, toJsonReplacer, pretty);
  }

  function fromJson(json) {
    return isString(json) ?
      JSON.parse(json) :
      json;
  }
  var ALL_COLONS = /:/g;

  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(ALL_COLONS, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }

  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.empty();
    } catch (e) {}
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
        elemHtml.
      match(/^(<[^>]+>)/)[1].
      replace(/^<([\w\-]+)/, function(match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }

  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {}
  }

  function parseKeyValue(keyValue) {
    var obj = {};
    forEach((keyValue || "").split('&'), function(keyValue) {
      var splitPoint, key, val;
      if (keyValue) {
        key = keyValue = keyValue.replace(/\+/g, '%20');
        splitPoint = keyValue.indexOf('=');
        if (splitPoint !== -1) {
          key = keyValue.substring(0, splitPoint);
          val = keyValue.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);
        if (isDefined(key)) {
          val = isDefined(val) ? tryDecodeURIComponent(val) : true;
          if (!hasOwnProperty.call(obj, key)) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [obj[key], val];
          }
        }
      }
    });
    return obj;
  }

  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function(value, key) {
      if (isArray(value)) {
        forEach(value, function(arrayValue) {
          parts.push(encodeUriQuery(key, true) +
            (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
        });
      } else {
        parts.push(encodeUriQuery(key, true) +
          (value === true ? '' : '=' + encodeUriQuery(value, true)));
      }
    });
    return parts.length ? parts.join('&') : '';
  }

  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).
    replace(/%26/gi, '&').
    replace(/%3D/gi, '=').
    replace(/%2B/gi, '+');
  }

  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%3B/gi, ';').
    replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
  }
  var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];

  function getNgAttribute(element, ngAttr) {
    var attr, i, ii = ngAttrPrefixes.length;
    for (i = 0; i < ii; ++i) {
      attr = ngAttrPrefixes[i] + ngAttr;
      if (isString(attr = element.getAttribute(attr))) {
        return attr;
      }
    }
    return null;
  }

  function angularInit(element, bootstrap) {
    var appElement,
      module,
      config = {};
    forEach(ngAttrPrefixes, function(prefix) {
      var name = prefix + 'app';
      if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
        appElement = element;
        module = element.getAttribute(name);
      }
    });
    forEach(ngAttrPrefixes, function(prefix) {
      var name = prefix + 'app';
      var candidate;
      if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
        appElement = candidate;
        module = candidate.getAttribute(name);
      }
    });
    if (appElement) {
      config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
      bootstrap(appElement, module ? [module] : [], config);
    }
  }

  function bootstrap(element, modules, config) {
    if (!isObject(config)) config = {};
    var defaultConfig = {
      strictDi: false
    };
    config = extend(defaultConfig, config);
    var doBootstrap = function() {
      element = jqLite(element);
      if (element.injector()) {
        var tag = (element[0] === window.document) ? 'document' : startingTag(element);
        throw ngMinErr(
          'btstrpd',
          "App already bootstrapped with this element '{0}'",
          tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
      }
      modules = modules || [];
      modules.unshift(['$provide', function($provide) {
        $provide.value('$rootElement', element);
      }]);
      if (config.debugInfoEnabled) {
        modules.push(['$compileProvider', function($compileProvider) {
          $compileProvider.debugInfoEnabled(true);
        }]);
      }
      modules.unshift('ng');
      var injector = createInjector(modules, config.strictDi);
      injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
        function bootstrapApply(scope, element, compile, injector) {
          scope.$apply(function() {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
      config.debugInfoEnabled = true;
      window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
    }
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function(extraModules) {
      forEach(extraModules, function(module) {
        modules.push(module);
      });
      return doBootstrap();
    };
    if (isFunction(angular.resumeDeferredBootstrap)) {
      angular.resumeDeferredBootstrap();
    }
  }

  function reloadWithDebugInfo() {
    window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
    window.location.reload();
  }

  function getTestability(rootElement) {
    var injector = angular.element(rootElement).injector();
    if (!injector) {
      throw ngMinErr('test',
        'no injector found for element argument to getTestability');
    }
    return injector.get('$$testability');
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;

  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  var bindJQueryFired = false;

  function bindJQuery() {
    var originalCleanData;
    if (bindJQueryFired) {
      return;
    }
    var jqName = jq();
    jQuery = isUndefined(jqName) ? window.jQuery :
      !jqName ? undefined :
      window[jqName];
    if (jQuery && jQuery.fn.on) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      originalCleanData = jQuery.cleanData;
      jQuery.cleanData = function(elems) {
        var events;
        for (var i = 0, elem;
          (elem = elems[i]) != null; i++) {
          events = jQuery._data(elem, "events");
          if (events && events.$destroy) {
            jQuery(elem).triggerHandler('$destroy');
          }
        }
        originalCleanData(elems);
      };
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
    bindJQueryFired = true;
  }

  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
    }
    return arg;
  }

  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' +
      (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }

  function assertNotHasOwnProperty(name, context) {
    if (name === 'hasOwnProperty') {
      throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
    }
  }

  function getter(obj, path, bindFnToScope) {
    if (!path) return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }

  function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
      if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
          blockNodes = jqLite(slice.call(nodes, 0, i));
        }
        blockNodes.push(node);
      }
    }
    return blockNodes || nodes;
  }

  function createMap() {
    return Object.create(null);
  }
  var NODE_TYPE_ELEMENT = 1;
  var NODE_TYPE_ATTRIBUTE = 2;
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_COMMENT = 8;
  var NODE_TYPE_DOCUMENT = 9;
  var NODE_TYPE_DOCUMENT_FRAGMENT = 11;

  function setupModuleLoader(window) {
    var $injectorMinErr = minErr('$injector');
    var ngMinErr = minErr('ng');

    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, 'angular', Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, 'module', function() {
      var modules = {};
      return function module(name, requires, configFn) {
        var assertNotHasOwnProperty = function(name, context) {
          if (name === 'hasOwnProperty') {
            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
          }
        };
        assertNotHasOwnProperty(name, 'module');
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function() {
          if (!requires) {
            throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
              "the module name or forgot to load it. If registering a module ensure that you " +
              "specify the dependencies as the second argument.", name);
          }
          var invokeQueue = [];
          var configBlocks = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
          var moduleInstance = {
            _invokeQueue: invokeQueue,
            _configBlocks: configBlocks,
            _runBlocks: runBlocks,
            requires: requires,
            name: name,
            provider: invokeLaterAndSetModuleName('$provide', 'provider'),
            factory: invokeLaterAndSetModuleName('$provide', 'factory'),
            service: invokeLaterAndSetModuleName('$provide', 'service'),
            value: invokeLater('$provide', 'value'),
            constant: invokeLater('$provide', 'constant', 'unshift'),
            decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
            animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
            filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
            controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
            directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
            component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
            config: config,
            run: function(block) {
              runBlocks.push(block);
              return this;
            }
          };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;

          function invokeLater(provider, method, insertMethod, queue) {
            if (!queue) queue = invokeQueue;
            return function() {
              queue[insertMethod || 'push']([provider, method, arguments]);
              return moduleInstance;
            };
          }

          function invokeLaterAndSetModuleName(provider, method) {
            return function(recipeName, factoryFunction) {
              if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
              invokeQueue.push([provider, method, arguments]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }

  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }

  function serializeObject(obj) {
    var seen = [];
    return JSON.stringify(obj, function(key, val) {
      val = toJsonReplacer(key, val);
      if (isObject(val)) {
        if (seen.indexOf(val) >= 0) return '...';
        seen.push(val);
      }
      return val;
    });
  }

  function toDebugString(obj) {
    if (typeof obj === 'function') {
      return obj.toString().replace(/ \{[\s\S]*$/, '');
    } else if (isUndefined(obj)) {
      return 'undefined';
    } else if (typeof obj !== 'string') {
      return serializeObject(obj);
    }
    return obj;
  }
  var version = {
    full: '1.5.8',
    major: 1,
    minor: 5,
    dot: 8,
    codeName: 'arbitrary-fallbacks'
  };

  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'merge': merge,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': {
        $$counter: 0
      },
      'getTestability': getTestability,
      '$$minErr': minErr,
      '$$csp': csp,
      'reloadWithDebugInfo': reloadWithDebugInfo
    });
    angularModule = setupModuleLoader(window);
    angularModule('ng', ['ngLocale'], ['$provide',
      function ngModule($provide) {
        $provide.provider({
          $$sanitizeUri: $$SanitizeUriProvider
        });
        $provide.provider('$compile', $CompileProvider).
        directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtml: ngBindHtmlDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngIf: ngIfDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          pattern: patternDirective,
          ngPattern: patternDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          minlength: minlengthDirective,
          ngMinlength: minlengthDirective,
          maxlength: maxlengthDirective,
          ngMaxlength: maxlengthDirective,
          ngValue: ngValueDirective,
          ngModelOptions: ngModelOptionsDirective
        }).
        directive({
          ngInclude: ngIncludeFillContentDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $animate: $AnimateProvider,
          $animateCss: $CoreAnimateCssProvider,
          $$animateJs: $$CoreAnimateJsProvider,
          $$animateQueue: $$CoreAnimateQueueProvider,
          $$AnimateRunner: $$AnimateRunnerFactoryProvider,
          $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $$forceReflow: $$ForceReflowProvider,
          $interpolate: $InterpolateProvider,
          $interval: $IntervalProvider,
          $http: $HttpProvider,
          $httpParamSerializer: $HttpParamSerializerProvider,
          $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
          $httpBackend: $HttpBackendProvider,
          $xhrFactory: $xhrFactoryProvider,
          $jsonpCallbacks: $jsonpCallbacksProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $$q: $$QProvider,
          $sce: $SceProvider,
          $sceDelegate: $SceDelegateProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $templateRequest: $TemplateRequestProvider,
          $$testability: $$TestabilityProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider,
          $$rAF: $$RAFProvider,
          $$jqLite: $$jqLiteProvider,
          $$HashMap: $$HashMapProvider,
          $$cookieReader: $$CookieReaderProvider
        });
      }
    ]);
  }
  JQLite.expando = 'ng339';
  var jqCache = JQLite.cache = {},
    jqId = 1,
    addEventListenerFn = function(element, type, fn) {
      element.addEventListener(type, fn, false);
    },
    removeEventListenerFn = function(element, type, fn) {
      element.removeEventListener(type, fn, false);
    };
  JQLite._data = function(node) {
    return this.cache[node[this.expando]] || {};
  };

  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var MOUSE_EVENT_MAP = {
    mouseleave: "mouseout",
    mouseenter: "mouseover"
  };
  var jqLiteMinErr = minErr('jqLite');

  function camelCase(name) {
    return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
  var HTML_REGEXP = /<|&#?\w+;/;
  var TAG_NAME_REGEXP = /<([\w:-]+)/;
  var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
  var wrapMap = {
    'option': [1, '<select multiple="multiple">', '</select>'],
    'thead': [1, '<table>', '</table>'],
    'col': [2, '<table><colgroup>', '</colgroup></table>'],
    'tr': [2, '<table><tbody>', '</tbody></table>'],
    'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
    '_default': [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
  }

  function jqLiteAcceptsData(node) {
    var nodeType = node.nodeType;
    return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
  }

  function jqLiteHasData(node) {
    for (var key in jqCache[node.ng339]) {
      return true;
    }
    return false;
  }

  function jqLiteCleanData(nodes) {
    for (var i = 0, ii = nodes.length; i < ii; i++) {
      jqLiteRemoveData(nodes[i]);
    }
  }

  function jqLiteBuildFragment(html, context) {
    var tmp, tag, wrap,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i;
    if (jqLiteIsTextNode(html)) {
      nodes.push(context.createTextNode(html));
    } else {
      tmp = fragment.appendChild(context.createElement("div"));
      tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
      wrap = wrapMap[tag] || wrapMap._default;
      tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
      i = wrap[0];
      while (i--) {
        tmp = tmp.lastChild;
      }
      nodes = concat(nodes, tmp.childNodes);
      tmp = fragment.firstChild;
      tmp.textContent = "";
    }
    fragment.textContent = "";
    fragment.innerHTML = "";
    forEach(nodes, function(node) {
      fragment.appendChild(node);
    });
    return fragment;
  }

  function jqLiteParseHTML(html, context) {
    context = context || window.document;
    var parsed;
    if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
      return [context.createElement(parsed[1])];
    }
    if ((parsed = jqLiteBuildFragment(html, context))) {
      return parsed.childNodes;
    }
    return [];
  }

  function jqLiteWrapNode(node, wrapper) {
    var parent = node.parentNode;
    if (parent) {
      parent.replaceChild(wrapper, node);
    }
    wrapper.appendChild(node);
  }
  var jqLiteContains = window.Node.prototype.contains || function(arg) {
    return !!(this.compareDocumentPosition(arg) & 16);
  };

  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    var argIsString;
    if (isString(element)) {
      element = trim(element);
      argIsString = true;
    }
    if (!(this instanceof JQLite)) {
      if (argIsString && element.charAt(0) != '<') {
        throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
      }
      return new JQLite(element);
    }
    if (argIsString) {
      jqLiteAddNodes(this, jqLiteParseHTML(element));
    } else {
      jqLiteAddNodes(this, element);
    }
  }

  function jqLiteClone(element) {
    return element.cloneNode(true);
  }

  function jqLiteDealoc(element, onlyDescendants) {
    if (!onlyDescendants) jqLiteRemoveData(element);
    if (element.querySelectorAll) {
      var descendants = element.querySelectorAll('*');
      for (var i = 0, l = descendants.length; i < l; i++) {
        jqLiteRemoveData(descendants[i]);
      }
    }
  }

  function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var handle = expandoStore && expandoStore.handle;
    if (!handle) return;
    if (!type) {
      for (type in events) {
        if (type !== '$destroy') {
          removeEventListenerFn(element, type, handle);
        }
        delete events[type];
      }
    } else {
      var removeHandler = function(type) {
        var listenerFns = events[type];
        if (isDefined(fn)) {
          arrayRemove(listenerFns || [], fn);
        }
        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
          removeEventListenerFn(element, type, handle);
          delete events[type];
        }
      };
      forEach(type.split(' '), function(type) {
        removeHandler(type);
        if (MOUSE_EVENT_MAP[type]) {
          removeHandler(MOUSE_EVENT_MAP[type]);
        }
      });
    }
  }

  function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339;
    var expandoStore = expandoId && jqCache[expandoId];
    if (expandoStore) {
      if (name) {
        delete expandoStore.data[name];
        return;
      }
      if (expandoStore.handle) {
        if (expandoStore.events.$destroy) {
          expandoStore.handle({}, '$destroy');
        }
        jqLiteOff(element);
      }
      delete jqCache[expandoId];
      element.ng339 = undefined;
    }
  }

  function jqLiteExpandoStore(element, createIfNecessary) {
    var expandoId = element.ng339,
      expandoStore = expandoId && jqCache[expandoId];
    if (createIfNecessary && !expandoStore) {
      element.ng339 = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {
        events: {},
        data: {},
        handle: undefined
      };
    }
    return expandoStore;
  }

  function jqLiteData(element, key, value) {
    if (jqLiteAcceptsData(element)) {
      var isSimpleSetter = isDefined(value);
      var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
      var massGetter = !key;
      var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
      var data = expandoStore && expandoStore.data;
      if (isSimpleSetter) {
        data[key] = value;
      } else {
        if (massGetter) {
          return data;
        } else {
          if (isSimpleGetter) {
            return data && data[key];
          } else {
            extend(data, key);
          }
        }
      }
    }
  }

  function jqLiteHasClass(element, selector) {
    if (!element.getAttribute) return false;
    return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
  }

  function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      forEach(cssClasses.split(' '), function(cssClass) {
        element.setAttribute('class', trim(
          (" " + (element.getAttribute('class') || '') + " ")
          .replace(/[\n\t]/g, " ")
          .replace(" " + trim(cssClass) + " ", " ")));
      });
    }
  }

  function jqLiteAddClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
        .replace(/[\n\t]/g, " ");
      forEach(cssClasses.split(' '), function(cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
          existingClasses += cssClass + ' ';
        }
      });
      element.setAttribute('class', trim(existingClasses));
    }
  }

  function jqLiteAddNodes(root, elements) {
    if (elements) {
      if (elements.nodeType) {
        root[root.length++] = elements;
      } else {
        var length = elements.length;
        if (typeof length === 'number' && elements.window !== elements) {
          if (length) {
            for (var i = 0; i < length; i++) {
              root[root.length++] = elements[i];
            }
          }
        } else {
          root[root.length++] = elements;
        }
      }
    }
  }

  function jqLiteController(element, name) {
    return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }

  function jqLiteInheritedData(element, name, value) {
    if (element.nodeType == NODE_TYPE_DOCUMENT) {
      element = element.documentElement;
    }
    var names = isArray(name) ? name : [name];
    while (element) {
      for (var i = 0, ii = names.length; i < ii; i++) {
        if (isDefined(value = jqLite.data(element, names[i]))) return value;
      }
      element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
    }
  }

  function jqLiteEmpty(element) {
    jqLiteDealoc(element, true);
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function jqLiteRemove(element, keepData) {
    if (!keepData) jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  }

  function jqLiteDocumentLoaded(action, win) {
    win = win || window;
    if (win.document.readyState === 'complete') {
      win.setTimeout(action);
    } else {
      jqLite(win).on('load', action);
    }
  }
  var JQLitePrototype = JQLite.prototype = {
    ready: function(fn) {
      var fired = false;

      function trigger() {
        if (fired) return;
        fired = true;
        fn();
      }
      if (window.document.readyState === 'complete') {
        window.setTimeout(trigger);
      } else {
        this.on('DOMContentLoaded', trigger);
        JQLite(window).on('load', trigger);
      }
    },
    toString: function() {
      var value = [];
      forEach(this, function(e) {
        value.push('' + e);
      });
      return '[' + value.join(', ') + ']';
    },
    eq: function(index) {
      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice
  };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
    BOOLEAN_ELEMENTS[value] = true;
  });
  var ALIASED_ATTR = {
    'ngMinlength': 'minlength',
    'ngMaxlength': 'maxlength',
    'ngMin': 'min',
    'ngMax': 'max',
    'ngPattern': 'pattern'
  };

  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
  }

  function getAliasedAttrName(name) {
    return ALIASED_ATTR[name];
  }
  forEach({
    data: jqLiteData,
    removeData: jqLiteRemoveData,
    hasData: jqLiteHasData,
    cleanData: jqLiteCleanData
  }, function(fn, name) {
    JQLite[name] = fn;
  });
  forEach({
    data: jqLiteData,
    inheritedData: jqLiteInheritedData,
    scope: function(element) {
      return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
    },
    isolateScope: function(element) {
      return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
    },
    controller: jqLiteController,
    injector: function(element) {
      return jqLiteInheritedData(element, '$injector');
    },
    removeAttr: function(element, name) {
      element.removeAttribute(name);
    },
    hasClass: jqLiteHasClass,
    css: function(element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        return element.style[name];
      }
    },
    attr: function(element, name, value) {
      var nodeType = element.nodeType;
      if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
        return;
      }
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return (element[name] ||
              (element.attributes.getNamedItem(name) || noop).specified) ?
            lowercasedName :
            undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function(element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: (function() {
      getText.$dv = '';
      return getText;

      function getText(element, value) {
        if (isUndefined(value)) {
          var nodeType = element.nodeType;
          return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
        }
        element.textContent = value;
      }
    })(),
    val: function(element, value) {
      if (isUndefined(value)) {
        if (element.multiple && nodeName_(element) === 'select') {
          var result = [];
          forEach(element.options, function(option) {
            if (option.selected) {
              result.push(option.value || option.text);
            }
          });
          return result.length === 0 ? null : result;
        }
        return element.value;
      }
      element.value = value;
    },
    html: function(element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      jqLiteDealoc(element, true);
      element.innerHTML = value;
    },
    empty: jqLiteEmpty
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2) {
      var i, key;
      var nodeCount = this.length;
      if (fn !== jqLiteEmpty &&
        (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
        if (isObject(arg1)) {
          for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          var value = fn.$dv;
          var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
          for (var j = 0; j < jj; j++) {
            var nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
          }
          return value;
        }
      } else {
        for (i = 0; i < nodeCount; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
    };
  });

  function createEventHandler(element, events) {
    var eventHandler = function(event, type) {
      event.isDefaultPrevented = function() {
        return event.defaultPrevented;
      };
      var eventFns = events[type || event.type];
      var eventFnsLength = eventFns ? eventFns.length : 0;
      if (!eventFnsLength) return;
      if (isUndefined(event.immediatePropagationStopped)) {
        var originalStopImmediatePropagation = event.stopImmediatePropagation;
        event.stopImmediatePropagation = function() {
          event.immediatePropagationStopped = true;
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (originalStopImmediatePropagation) {
            originalStopImmediatePropagation.call(event);
          }
        };
      }
      event.isImmediatePropagationStopped = function() {
        return event.immediatePropagationStopped === true;
      };
      var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
      if ((eventFnsLength > 1)) {
        eventFns = shallowCopy(eventFns);
      }
      for (var i = 0; i < eventFnsLength; i++) {
        if (!event.isImmediatePropagationStopped()) {
          handlerWrapper(element, event, eventFns[i]);
        }
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }

  function defaultHandlerWrapper(element, event, handler) {
    handler.call(element, event);
  }

  function specialMouseHandlerWrapper(target, event, handler) {
    var related = event.relatedTarget;
    if (!related || (related !== target && !jqLiteContains.call(target, related))) {
      handler.call(target, event);
    }
  }
  forEach({
    removeData: jqLiteRemoveData,
    on: function jqLiteOn(element, type, fn, unsupported) {
      if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
      if (!jqLiteAcceptsData(element)) {
        return;
      }
      var expandoStore = jqLiteExpandoStore(element, true);
      var events = expandoStore.events;
      var handle = expandoStore.handle;
      if (!handle) {
        handle = expandoStore.handle = createEventHandler(element, events);
      }
      var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
      var i = types.length;
      var addHandler = function(type, specialHandlerWrapper, noEventListener) {
        var eventFns = events[type];
        if (!eventFns) {
          eventFns = events[type] = [];
          eventFns.specialHandlerWrapper = specialHandlerWrapper;
          if (type !== '$destroy' && !noEventListener) {
            addEventListenerFn(element, type, handle);
          }
        }
        eventFns.push(fn);
      };
      while (i--) {
        type = types[i];
        if (MOUSE_EVENT_MAP[type]) {
          addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
          addHandler(type, undefined, true);
        } else {
          addHandler(type);
        }
      }
    },
    off: jqLiteOff,
    one: function(element, type, fn) {
      element = jqLite(element);
      element.on(type, function onFn() {
        element.off(type, fn);
        element.off(type, onFn);
      });
      element.on(type, fn);
    },
    replaceWith: function(element, replaceNode) {
      var index, parent = element.parentNode;
      jqLiteDealoc(element);
      forEach(new JQLite(replaceNode), function(node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function(element) {
      var children = [];
      forEach(element.childNodes, function(element) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
          children.push(element);
        }
      });
      return children;
    },
    contents: function(element) {
      return element.contentDocument || element.childNodes || [];
    },
    append: function(element, node) {
      var nodeType = element.nodeType;
      if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
      node = new JQLite(node);
      for (var i = 0, ii = node.length; i < ii; i++) {
        var child = node[i];
        element.appendChild(child);
      }
    },
    prepend: function(element, node) {
      if (element.nodeType === NODE_TYPE_ELEMENT) {
        var index = element.firstChild;
        forEach(new JQLite(node), function(child) {
          element.insertBefore(child, index);
        });
      }
    },
    wrap: function(element, wrapNode) {
      jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
    },
    remove: jqLiteRemove,
    detach: function(element) {
      jqLiteRemove(element, true);
    },
    after: function(element, newElement) {
      var index = element,
        parent = element.parentNode;
      newElement = new JQLite(newElement);
      for (var i = 0, ii = newElement.length; i < ii; i++) {
        var node = newElement[i];
        parent.insertBefore(node, index.nextSibling);
        index = node;
      }
    },
    addClass: jqLiteAddClass,
    removeClass: jqLiteRemoveClass,
    toggleClass: function(element, selector, condition) {
      if (selector) {
        forEach(selector.split(' '), function(className) {
          var classCondition = condition;
          if (isUndefined(classCondition)) {
            classCondition = !jqLiteHasClass(element, className);
          }
          (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
        });
      }
    },
    parent: function(element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
    },
    next: function(element) {
      return element.nextElementSibling;
    },
    find: function(element, selector) {
      if (element.getElementsByTagName) {
        return element.getElementsByTagName(selector);
      } else {
        return [];
      }
    },
    clone: jqLiteClone,
    triggerHandler: function(element, event, extraParameters) {
      var dummyEvent, eventFnsCopy, handlerArgs;
      var eventName = event.type || event;
      var expandoStore = jqLiteExpandoStore(element);
      var events = expandoStore && expandoStore.events;
      var eventFns = events && events[eventName];
      if (eventFns) {
        dummyEvent = {
          preventDefault: function() {
            this.defaultPrevented = true;
          },
          isDefaultPrevented: function() {
            return this.defaultPrevented === true;
          },
          stopImmediatePropagation: function() {
            this.immediatePropagationStopped = true;
          },
          isImmediatePropagationStopped: function() {
            return this.immediatePropagationStopped === true;
          },
          stopPropagation: noop,
          type: eventName,
          target: element
        };
        if (event.type) {
          dummyEvent = extend(dummyEvent, event);
        }
        eventFnsCopy = shallowCopy(eventFns);
        handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
        forEach(eventFnsCopy, function(fn) {
          if (!dummyEvent.isImmediatePropagationStopped()) {
            fn.apply(element, handlerArgs);
          }
        });
      }
    }
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2, arg3) {
      var value;
      for (var i = 0, ii = this.length; i < ii; i++) {
        if (isUndefined(value)) {
          value = fn(this[i], arg1, arg2, arg3);
          if (isDefined(value)) {
            value = jqLite(value);
          }
        } else {
          jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
        }
      }
      return isDefined(value) ? value : this;
    };
    JQLite.prototype.bind = JQLite.prototype.on;
    JQLite.prototype.unbind = JQLite.prototype.off;
  });

  function $$jqLiteProvider() {
    this.$get = function $$jqLite() {
      return extend(JQLite, {
        hasClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteHasClass(node, classes);
        },
        addClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteAddClass(node, classes);
        },
        removeClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteRemoveClass(node, classes);
        }
      });
    };
  }

  function hashKey(obj, nextUidFn) {
    var key = obj && obj.$$hashKey;
    if (key) {
      if (typeof key === 'function') {
        key = obj.$$hashKey();
      }
      return key;
    }
    var objType = typeof obj;
    if (objType == 'function' || (objType == 'object' && obj !== null)) {
      key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
    } else {
      key = objType + ':' + obj;
    }
    return key;
  }

  function HashMap(array, isolatedUid) {
    if (isolatedUid) {
      var uid = 0;
      this.nextUid = function() {
        return ++uid;
      };
    }
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function(key, value) {
      this[hashKey(key, this.nextUid)] = value;
    },
    get: function(key) {
      return this[hashKey(key, this.nextUid)];
    },
    remove: function(key) {
      var value = this[key = hashKey(key, this.nextUid)];
      delete this[key];
      return value;
    }
  };
  var $$HashMapProvider = [function() {
    this.$get = [function() {
      return HashMap;
    }];
  }];
  var ARROW_ARG = /^([^\(]+?)=>/;
  var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
  var $injectorMinErr = minErr('$injector');

  function stringifyFn(fn) {
    return Function.prototype.toString.call(fn) + ' ';
  }

  function extractArgs(fn) {
    var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
      args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    return args;
  }

  function anonFn(fn) {
    var args = extractArgs(fn);
    if (args) {
      return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
    }
    return 'fn';
  }

  function annotate(fn, strictDi, name) {
    var $inject,
      argDecl,
      last;
    if (typeof fn === 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
          if (strictDi) {
            if (!isString(name) || !name) {
              name = fn.name || anonFn(fn);
            }
            throw $injectorMinErr('strictdi',
              '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
          }
          argDecl = extractArgs(fn);
          forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
              $inject.push(name);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }

  function createInjector(modulesToLoad, strictDi) {
    strictDi = (strictDi === true);
    var INSTANTIATING = {},
      providerSuffix = 'Provider',
      path = [],
      loadedModules = new HashMap([], true),
      providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      },
      providerInjector = (providerCache.$injector =
        createInternalInjector(providerCache, function(serviceName, caller) {
          if (angular.isString(caller)) {
            path.push(caller);
          }
          throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
        })),
      instanceCache = {},
      protoInstanceInjector =
      createInternalInjector(instanceCache, function(serviceName, caller) {
        var provider = providerInjector.get(serviceName + providerSuffix, caller);
        return instanceInjector.invoke(
          provider.$get, provider, undefined, serviceName);
      }),
      instanceInjector = protoInstanceInjector;
    providerCache['$injector' + providerSuffix] = {
      $get: valueFn(protoInstanceInjector)
    };
    var runBlocks = loadModules(modulesToLoad);
    instanceInjector = protoInstanceInjector.get('$injector');
    instanceInjector.strictDi = strictDi;
    forEach(runBlocks, function(fn) {
      if (fn) instanceInjector.invoke(fn);
    });
    return instanceInjector;

    function supportObject(delegate) {
      return function(key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }

    function provider(name, provider_) {
      assertNotHasOwnProperty(name, 'service');
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
      }
      return providerCache[name + providerSuffix] = provider_;
    }

    function enforceReturnValue(name, factory) {
      return function enforcedReturnValue() {
        var result = instanceInjector.invoke(factory, this);
        if (isUndefined(result)) {
          throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
        }
        return result;
      };
    }

    function factory(name, factoryFn, enforce) {
      return provider(name, {
        $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
      });
    }

    function service(name, constructor) {
      return factory(name, ['$injector', function($injector) {
        return $injector.instantiate(constructor);
      }]);
    }

    function value(name, val) {
      return factory(name, valueFn(val), false);
    }

    function constant(name, value) {
      assertNotHasOwnProperty(name, 'constant');
      providerCache[name] = value;
      instanceCache[name] = value;
    }

    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;
      origProvider.$get = function() {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance
        });
      };
    }

    function loadModules(modulesToLoad) {
      assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
      var runBlocks = [],
        moduleFn;
      forEach(modulesToLoad, function(module) {
        if (loadedModules.get(module)) return;
        loadedModules.put(module, true);

        function runInvokeQueue(queue) {
          var i, ii;
          for (i = 0, ii = queue.length; i < ii; i++) {
            var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        }
        try {
          if (isString(module)) {
            moduleFn = angularModule(module);
            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
            runInvokeQueue(moduleFn._invokeQueue);
            runInvokeQueue(moduleFn._configBlocks);
          } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, 'module');
          }
        } catch (e) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
            e = e.message + '\n' + e.stack;
          }
          throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
            module, e.stack || e.message || e);
        }
      });
      return runBlocks;
    }

    function createInternalInjector(cache, factory) {
      function getService(serviceName, caller) {
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
              serviceName + ' <- ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName, caller);
          } catch (err) {
            if (cache[serviceName] === INSTANTIATING) {
              delete cache[serviceName];
            }
            throw err;
          } finally {
            path.shift();
          }
        }
      }

      function injectionArgs(fn, locals, serviceName) {
        var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName);
        for (var i = 0, length = $inject.length; i < length; i++) {
          var key = $inject[i];
          if (typeof key !== 'string') {
            throw $injectorMinErr('itkn',
              'Incorrect injection token! Expected service name as string, got {0}', key);
          }
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] :
            getService(key, serviceName));
        }
        return args;
      }

      function isClass(func) {
        if (msie <= 11) {
          return false;
        }
        return typeof func === 'function' &&
          /^(?:class\b|constructor\()/.test(stringifyFn(func));
      }

      function invoke(fn, self, locals, serviceName) {
        if (typeof locals === 'string') {
          serviceName = locals;
          locals = null;
        }
        var args = injectionArgs(fn, locals, serviceName);
        if (isArray(fn)) {
          fn = fn[fn.length - 1];
        }
        if (!isClass(fn)) {
          return fn.apply(self, args);
        } else {
          args.unshift(null);
          return new(Function.prototype.bind.apply(fn, args))();
        }
      }

      function instantiate(Type, locals, serviceName) {
        var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
        var args = injectionArgs(Type, locals, serviceName);
        args.unshift(null);
        return new(Function.prototype.bind.apply(ctor, args))();
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: createInjector.$$annotate,
        has: function(name) {
          return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
        }
      };
    }
  }
  createInjector.$$annotate = annotate;

  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function() {
      autoScrollingEnabled = false;
    };
    this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
      var document = $window.document;

      function getFirstAnchor(list) {
        var result = null;
        Array.prototype.some.call(list, function(element) {
          if (nodeName_(element) === 'a') {
            result = element;
            return true;
          }
        });
        return result;
      }

      function getYOffset() {
        var offset = scroll.yOffset;
        if (isFunction(offset)) {
          offset = offset();
        } else if (isElement(offset)) {
          var elem = offset[0];
          var style = $window.getComputedStyle(elem);
          if (style.position !== 'fixed') {
            offset = 0;
          } else {
            offset = elem.getBoundingClientRect().bottom;
          }
        } else if (!isNumber(offset)) {
          offset = 0;
        }
        return offset;
      }

      function scrollTo(elem) {
        if (elem) {
          elem.scrollIntoView();
          var offset = getYOffset();
          if (offset) {
            var elemTop = elem.getBoundingClientRect().top;
            $window.scrollBy(0, elemTop - offset);
          }
        } else {
          $window.scrollTo(0, 0);
        }
      }

      function scroll(hash) {
        hash = isString(hash) ? hash : $location.hash();
        var elm;
        if (!hash) scrollTo(null);
        else if ((elm = document.getElementById(hash))) scrollTo(elm);
        else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
        else if (hash === 'top') scrollTo(null);
      }
      if (autoScrollingEnabled) {
        $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          },
          function autoScrollWatchAction(newVal, oldVal) {
            if (newVal === oldVal && newVal === '') return;
            jqLiteDocumentLoaded(function() {
              $rootScope.$evalAsync(scroll);
            });
          });
      }
      return scroll;
    }];
  }
  var $animateMinErr = minErr('$animate');
  var ELEMENT_NODE = 1;
  var NG_ANIMATE_CLASSNAME = 'ng-animate';

  function mergeClasses(a, b) {
    if (!a && !b) return '';
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(' ');
    if (isArray(b)) b = b.join(' ');
    return a + ' ' + b;
  }

  function extractElementNode(element) {
    for (var i = 0; i < element.length; i++) {
      var elm = element[i];
      if (elm.nodeType === ELEMENT_NODE) {
        return elm;
      }
    }
  }

  function splitClasses(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }
    var obj = createMap();
    forEach(classes, function(klass) {
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  function prepareAnimateOptions(options) {
    return isObject(options) ?
      options :
      {};
  }
  var $$CoreAnimateJsProvider = function() {
    this.$get = noop;
  };
  var $$CoreAnimateQueueProvider = function() {
    var postDigestQueue = new HashMap();
    var postDigestElements = [];
    this.$get = ['$$AnimateRunner', '$rootScope',
      function($$AnimateRunner, $rootScope) {
        return {
          enabled: noop,
          on: noop,
          off: noop,
          pin: noop,
          push: function(element, event, options, domOperation) {
            domOperation && domOperation();
            options = options || {};
            options.from && element.css(options.from);
            options.to && element.css(options.to);
            if (options.addClass || options.removeClass) {
              addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
            }
            var runner = new $$AnimateRunner();
            runner.complete();
            return runner;
          }
        };

        function updateData(data, classes, value) {
          var changed = false;
          if (classes) {
            classes = isString(classes) ? classes.split(' ') :
              isArray(classes) ? classes : [];
            forEach(classes, function(className) {
              if (className) {
                changed = true;
                data[className] = value;
              }
            });
          }
          return changed;
        }

        function handleCSSClassChanges() {
          forEach(postDigestElements, function(element) {
            var data = postDigestQueue.get(element);
            if (data) {
              var existing = splitClasses(element.attr('class'));
              var toAdd = '';
              var toRemove = '';
              forEach(data, function(status, className) {
                var hasClass = !!existing[className];
                if (status !== hasClass) {
                  if (status) {
                    toAdd += (toAdd.length ? ' ' : '') + className;
                  } else {
                    toRemove += (toRemove.length ? ' ' : '') + className;
                  }
                }
              });
              forEach(element, function(elm) {
                toAdd && jqLiteAddClass(elm, toAdd);
                toRemove && jqLiteRemoveClass(elm, toRemove);
              });
              postDigestQueue.remove(element);
            }
          });
          postDigestElements.length = 0;
        }

        function addRemoveClassesPostDigest(element, add, remove) {
          var data = postDigestQueue.get(element) || {};
          var classesAdded = updateData(data, add, true);
          var classesRemoved = updateData(data, remove, false);
          if (classesAdded || classesRemoved) {
            postDigestQueue.put(element, data);
            postDigestElements.push(element);
            if (postDigestElements.length === 1) {
              $rootScope.$$postDigest(handleCSSClassChanges);
            }
          }
        }
      }
    ];
  };
  var $AnimateProvider = ['$provide', function($provide) {
    var provider = this;
    this.$$registeredAnimations = Object.create(null);
    this.register = function(name, factory) {
      if (name && name.charAt(0) !== '.') {
        throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
      }
      var key = name + '-animation';
      provider.$$registeredAnimations[name.substr(1)] = key;
      $provide.factory(key, factory);
    };
    this.classNameFilter = function(expression) {
      if (arguments.length === 1) {
        this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
        if (this.$$classNameFilter) {
          var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
          if (reservedRegex.test(this.$$classNameFilter.toString())) {
            throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
          }
        }
      }
      return this.$$classNameFilter;
    };
    this.$get = ['$$animateQueue', function($$animateQueue) {
      function domInsert(element, parentElement, afterElement) {
        if (afterElement) {
          var afterNode = extractElementNode(afterElement);
          if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
            afterElement = null;
          }
        }
        afterElement ? afterElement.after(element) : parentElement.prepend(element);
      }
      return {
        on: $$animateQueue.on,
        off: $$animateQueue.off,
        pin: $$animateQueue.pin,
        enabled: $$animateQueue.enabled,
        cancel: function(runner) {
          runner.end && runner.end();
        },
        enter: function(element, parent, after, options) {
          parent = parent && jqLite(parent);
          after = after && jqLite(after);
          parent = parent || after.parent();
          domInsert(element, parent, after);
          return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
        },
        move: function(element, parent, after, options) {
          parent = parent && jqLite(parent);
          after = after && jqLite(after);
          parent = parent || after.parent();
          domInsert(element, parent, after);
          return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
        },
        leave: function(element, options) {
          return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
            element.remove();
          });
        },
        addClass: function(element, className, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addclass, className);
          return $$animateQueue.push(element, 'addClass', options);
        },
        removeClass: function(element, className, options) {
          options = prepareAnimateOptions(options);
          options.removeClass = mergeClasses(options.removeClass, className);
          return $$animateQueue.push(element, 'removeClass', options);
        },
        setClass: function(element, add, remove, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addClass, add);
          options.removeClass = mergeClasses(options.removeClass, remove);
          return $$animateQueue.push(element, 'setClass', options);
        },
        animate: function(element, from, to, className, options) {
          options = prepareAnimateOptions(options);
          options.from = options.from ? extend(options.from, from) : from;
          options.to = options.to ? extend(options.to, to) : to;
          className = className || 'ng-inline-animate';
          options.tempClasses = mergeClasses(options.tempClasses, className);
          return $$animateQueue.push(element, 'animate', options);
        }
      };
    }];
  }];
  var $$AnimateAsyncRunFactoryProvider = function() {
    this.$get = ['$$rAF', function($$rAF) {
      var waitQueue = [];

      function waitForTick(fn) {
        waitQueue.push(fn);
        if (waitQueue.length > 1) return;
        $$rAF(function() {
          for (var i = 0; i < waitQueue.length; i++) {
            waitQueue[i]();
          }
          waitQueue = [];
        });
      }
      return function() {
        var passed = false;
        waitForTick(function() {
          passed = true;
        });
        return function(callback) {
          passed ? callback() : waitForTick(callback);
        };
      };
    }];
  };
  var $$AnimateRunnerFactoryProvider = function() {
    this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout',
      function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function(chain, callback) {
          var index = 0;
          next();

          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function(response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function(runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function(runner) {
            runner.done(onProgress);
          });

          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };

        function AnimateRunner(host) {
          this.setHost(host);
          var rafTick = $$animateAsyncRun();
          var timeoutTick = function(fn) {
            $timeout(fn, 0, false);
          };
          this._doneCallbacks = [];
          this._tick = function(fn) {
            var doc = $document[0];
            if (doc && doc.hidden) {
              timeoutTick(fn);
            } else {
              rafTick(fn);
            }
          };
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function(host) {
            this.host = host || {};
          },
          done: function(fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function() {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function(resolve, reject) {
                self.done(function(status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function(resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          'catch': function(handler) {
            return this.getPromise()['catch'](handler);
          },
          'finally': function(handler) {
            return this.getPromise()['finally'](handler);
          },
          pause: function() {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function() {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function() {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function() {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function(response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._tick(function() {
                self._resolve(response);
              });
            }
          },
          _resolve: function(response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function(fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          }
        };
        return AnimateRunner;
      }
    ];
  };
  var $CoreAnimateCssProvider = function() {
    this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
      return function(element, initialOptions) {
        var options = initialOptions || {};
        if (!options.$$prepared) {
          options = copy(options);
        }
        if (options.cleanupStyles) {
          options.from = options.to = null;
        }
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
        var closed, runner = new $$AnimateRunner();
        return {
          start: run,
          end: run
        };

        function run() {
          $$rAF(function() {
            applyAnimationContents();
            if (!closed) {
              runner.complete();
            }
            closed = true;
          });
          return runner;
        }

        function applyAnimationContents() {
          if (options.addClass) {
            element.addClass(options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            element.removeClass(options.removeClass);
            options.removeClass = null;
          }
          if (options.to) {
            element.css(options.to);
            options.to = null;
          }
        }
      };
    }];
  };

  function Browser(window, document, $log, $sniffer) {
    var self = this,
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function() {
      outstandingRequestCount++;
    };

    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }

    function getHash(url) {
      var index = url.indexOf('#');
      return index === -1 ? '' : url.substr(index);
    }
    self.notifyWhenNoOutstandingRequests = function(callback) {
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var cachedState, lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      pendingLocation = null,
      getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
        try {
          return history.state;
        } catch (e) {}
      };
    cacheState();
    lastHistoryState = cachedState;
    self.url = function(url, replace, state) {
      if (isUndefined(state)) {
        state = null;
      }
      if (location !== window.location) location = window.location;
      if (history !== window.history) history = window.history;
      if (url) {
        var sameState = lastHistoryState === state;
        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
          return self;
        }
        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
        lastBrowserUrl = url;
        lastHistoryState = state;
        if ($sniffer.history && (!sameBase || !sameState)) {
          history[replace ? 'replaceState' : 'pushState'](state, '', url);
          cacheState();
          lastHistoryState = cachedState;
        } else {
          if (!sameBase) {
            pendingLocation = url;
          }
          if (replace) {
            location.replace(url);
          } else if (!sameBase) {
            location.href = url;
          } else {
            location.hash = getHash(url);
          }
          if (location.href !== url) {
            pendingLocation = url;
          }
        }
        if (pendingLocation) {
          pendingLocation = url;
        }
        return self;
      } else {
        return pendingLocation || location.href.replace(/%27/g, "'");
      }
    };
    self.state = function() {
      return cachedState;
    };
    var urlChangeListeners = [],
      urlChangeInit = false;

    function cacheStateAndFireUrlChange() {
      pendingLocation = null;
      cacheState();
      fireUrlChange();
    }
    var lastCachedState = null;

    function cacheState() {
      cachedState = getCurrentState();
      cachedState = isUndefined(cachedState) ? null : cachedState;
      if (equals(cachedState, lastCachedState)) {
        cachedState = lastCachedState;
      }
      lastCachedState = cachedState;
    }

    function fireUrlChange() {
      if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
        return;
      }
      lastBrowserUrl = self.url();
      lastHistoryState = cachedState;
      forEach(urlChangeListeners, function(listener) {
        listener(self.url(), cachedState);
      });
    }
    self.onUrlChange = function(callback) {
      if (!urlChangeInit) {
        if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange);
        jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.$$applicationDestroyed = function() {
      jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
    };
    self.$$checkUrlChange = fireUrlChange;
    self.baseHref = function() {
      var href = baseElement.attr('href');
      return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
    };
    self.defer = function(fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function() {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function(deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }

  function $BrowserProvider() {
    this.$get = ['$window', '$log', '$sniffer', '$document',
      function($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }

  function $CacheFactoryProvider() {
    this.$get = function() {
      var caches = {};

      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
        }
        var size = 0,
          stats = extend({}, options, {
            id: cacheId
          }),
          data = createMap(),
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = createMap(),
          freshEnd = null,
          staleEnd = null;
        return caches[cacheId] = {
          put: function(key, value) {
            if (isUndefined(value)) return;
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key] || (lruHash[key] = {
                key: key
              });
              refresh(lruEntry);
            }
            if (!(key in data)) size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
            return value;
          },
          get: function(key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              refresh(lruEntry);
            }
            return data[key];
          },
          remove: function(key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              if (lruEntry == freshEnd) freshEnd = lruEntry.p;
              if (lruEntry == staleEnd) staleEnd = lruEntry.n;
              link(lruEntry.n, lruEntry.p);
              delete lruHash[key];
            }
            if (!(key in data)) return;
            delete data[key];
            size--;
          },
          removeAll: function() {
            data = createMap();
            size = 0;
            lruHash = createMap();
            freshEnd = staleEnd = null;
          },
          destroy: function() {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function() {
            return extend({}, stats, {
              size: size
            });
          }
        };

        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }

        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function() {
        var info = {};
        forEach(caches, function(cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function(cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }

  function $TemplateCacheProvider() {
    this.$get = ['$cacheFactory', function($cacheFactory) {
      return $cacheFactory('templates');
    }];
  }
  var $compileMinErr = minErr('$compile');

  function UNINITIALIZED_VALUE() {}
  var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
  $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];

  function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
      ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    var bindingCache = createMap();

    function parseIsolateBindings(scope, directiveName, isController) {
      var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
      var bindings = createMap();
      forEach(scope, function(definition, scopeName) {
        if (definition in bindingCache) {
          bindings[scopeName] = bindingCache[definition];
          return;
        }
        var match = definition.match(LOCAL_REGEXP);
        if (!match) {
          throw $compileMinErr('iscp',
            "Invalid {3} for directive '{0}'." +
            " Definition: {... {1}: '{2}' ...}",
            directiveName, scopeName, definition,
            (isController ? "controller bindings definition" :
              "isolate scope definition"));
        }
        bindings[scopeName] = {
          mode: match[1][0],
          collection: match[2] === '*',
          optional: match[3] === '?',
          attrName: match[4] || scopeName
        };
        if (match[4]) {
          bindingCache[definition] = bindings[scopeName];
        }
      });
      return bindings;
    }

    function parseDirectiveBindings(directive, directiveName) {
      var bindings = {
        isolateScope: null,
        bindToController: null
      };
      if (isObject(directive.scope)) {
        if (directive.bindToController === true) {
          bindings.bindToController = parseIsolateBindings(directive.scope,
            directiveName, true);
          bindings.isolateScope = {};
        } else {
          bindings.isolateScope = parseIsolateBindings(directive.scope,
            directiveName, false);
        }
      }
      if (isObject(directive.bindToController)) {
        bindings.bindToController =
          parseIsolateBindings(directive.bindToController, directiveName, true);
      }
      if (isObject(bindings.bindToController)) {
        var controller = directive.controller;
        var controllerAs = directive.controllerAs;
        if (!controller) {
          throw $compileMinErr('noctrl',
            "Cannot bind to controller without directive '{0}'s controller.",
            directiveName);
        } else if (!identifierForController(controller, controllerAs)) {
          throw $compileMinErr('noident',
            "Cannot bind to controller without identifier for directive '{0}'.",
            directiveName);
        }
      }
      return bindings;
    }

    function assertValidDirectiveName(name) {
      var letter = name.charAt(0);
      if (!letter || letter !== lowercase(letter)) {
        throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
      }
      if (name !== name.trim()) {
        throw $compileMinErr('baddir',
          "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
          name);
      }
    }

    function getDirectiveRequire(directive) {
      var require = directive.require || (directive.controller && directive.name);
      if (!isArray(require) && isObject(require)) {
        forEach(require, function(value, key) {
          var match = value.match(REQUIRE_PREFIX_REGEXP);
          var name = value.substring(match[0].length);
          if (!name) require[key] = match[0] + key;
        });
      }
      return require;
    }
    this.directive = function registerDirective(name, directiveFactory) {
      assertNotHasOwnProperty(name, 'directive');
      if (isString(name)) {
        assertValidDirectiveName(name);
        assertArg(directiveFactory, 'directiveFactory');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
            function($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function(directiveFactory, index) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = {
                      compile: valueFn(directive)
                    };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.index = index;
                  directive.name = directive.name || name;
                  directive.require = getDirectiveRequire(directive);
                  directive.restrict = directive.restrict || 'EA';
                  directive.$$moduleName = directiveFactory.$$moduleName;
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.component = function registerComponent(name, options) {
      var controller = options.controller || function() {};

      function factory($injector) {
        function makeInjectable(fn) {
          if (isFunction(fn) || isArray(fn)) {
            return function(tElement, tAttrs) {
              return $injector.invoke(fn, this, {
                $element: tElement,
                $attrs: tAttrs
              });
            };
          } else {
            return fn;
          }
        }
        var template = (!options.template && !options.templateUrl ? '' : options.template);
        var ddo = {
          controller: controller,
          controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
          template: makeInjectable(template),
          templateUrl: makeInjectable(options.templateUrl),
          transclude: options.transclude,
          scope: {},
          bindToController: options.bindings || {},
          restrict: 'E',
          require: options.require
        };
        forEach(options, function(val, key) {
          if (key.charAt(0) === '$') ddo[key] = val;
        });
        return ddo;
      }
      forEach(options, function(val, key) {
        if (key.charAt(0) === '$') {
          factory[key] = val;
          if (isFunction(controller)) controller[key] = val;
        }
      });
      factory.$inject = ['$injector'];
      return this.directive(name, factory);
    };
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
      }
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
      }
    };
    var debugInfoEnabled = true;
    this.debugInfoEnabled = function(enabled) {
      if (isDefined(enabled)) {
        debugInfoEnabled = enabled;
        return this;
      }
      return debugInfoEnabled;
    };
    var TTL = 10;
    this.onChangesTtl = function(value) {
      if (arguments.length) {
        TTL = value;
        return this;
      }
      return TTL;
    };
    this.$get = [
      '$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse',
      '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri',
      function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse,
        $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
        var SIMPLE_ATTR_NAME = /^\w/;
        var specialAttrHolder = window.document.createElement('div');
        var onChangesTtl = TTL;
        var onChangesQueue;

        function flushOnChangesQueue() {
          try {
            if (!(--onChangesTtl)) {
              onChangesQueue = undefined;
              throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
            }
            $rootScope.$apply(function() {
              var errors = [];
              for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                try {
                  onChangesQueue[i]();
                } catch (e) {
                  errors.push(e);
                }
              }
              onChangesQueue = undefined;
              if (errors.length) {
                throw errors;
              }
            });
          } finally {
            onChangesTtl++;
          }
        }

        function Attributes(element, attributesToCopy) {
          if (attributesToCopy) {
            var keys = Object.keys(attributesToCopy);
            var i, l, key;
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$$element = element;
        }
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $addClass: function(classVal) {
            if (classVal && classVal.length > 0) {
              $animate.addClass(this.$$element, classVal);
            }
          },
          $removeClass: function(classVal) {
            if (classVal && classVal.length > 0) {
              $animate.removeClass(this.$$element, classVal);
            }
          },
          $updateClass: function(newClasses, oldClasses) {
            var toAdd = tokenDifference(newClasses, oldClasses);
            if (toAdd && toAdd.length) {
              $animate.addClass(this.$$element, toAdd);
            }
            var toRemove = tokenDifference(oldClasses, newClasses);
            if (toRemove && toRemove.length) {
              $animate.removeClass(this.$$element, toRemove);
            }
          },
          $set: function(key, value, writeAttr, attrName) {
            var node = this.$$element[0],
              booleanKey = getBooleanAttrName(node, key),
              aliasedKey = getAliasedAttrName(key),
              observer = key,
              nodeName;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            } else if (aliasedKey) {
              this[aliasedKey] = value;
              observer = aliasedKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            nodeName = nodeName_(this.$$element);
            if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) ||
              (nodeName === 'img' && key === 'src')) {
              this[key] = value = $$sanitizeUri(value, key === 'src');
            } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
              var result = "";
              var trimmedSrcset = trim(value);
              var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
              var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
              var rawUris = trimmedSrcset.split(pattern);
              var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
              for (var i = 0; i < nbrUrisWith2parts; i++) {
                var innerIdx = i * 2;
                result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                result += (" " + trim(rawUris[innerIdx + 1]));
              }
              var lastTuple = trim(rawUris[i * 2]).split(/\s/);
              result += $$sanitizeUri(trim(lastTuple[0]), true);
              if (lastTuple.length === 2) {
                result += (" " + trim(lastTuple[1]));
              }
              this[key] = value = result;
            }
            if (writeAttr !== false) {
              if (value === null || isUndefined(value)) {
                this.$$element.removeAttr(attrName);
              } else {
                if (SIMPLE_ATTR_NAME.test(attrName)) {
                  this.$$element.attr(attrName, value);
                } else {
                  setSpecialAttr(this.$$element[0], attrName, value);
                }
              }
            }
            var $$observers = this.$$observers;
            $$observers && forEach($$observers[observer], function(fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function(key, fn) {
            var attrs = this,
              $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
              listeners = ($$observers[key] || ($$observers[key] = []));
            listeners.push(fn);
            $rootScope.$evalAsync(function() {
              if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                fn(attrs[key]);
              }
            });
            return function() {
              arrayRemove(listeners, fn);
            };
          }
        };

        function setSpecialAttr(element, attrName, value) {
          specialAttrHolder.innerHTML = "<span " + attrName + ">";
          var attributes = specialAttrHolder.firstChild.attributes;
          var attribute = attributes[0];
          attributes.removeNamedItem(attribute.name);
          attribute.value = value;
          element.attributes.setNamedItem(attribute);
        }

        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {}
        }
        var startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ?
          identity :
          function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          },
          NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
        compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
          var bindings = $element.data('$binding') || [];
          if (isArray(binding)) {
            bindings = bindings.concat(binding);
          } else {
            bindings.push(binding);
          }
          $element.data('$binding', bindings);
        } : noop;
        compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
          safeAddClass($element, 'ng-binding');
        } : noop;
        compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
          var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
          $element.data(dataName, scope);
        } : noop;
        compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
          safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
        } : noop;
        compile.$$createComment = function(directiveName, comment) {
          var content = '';
          if (debugInfoEnabled) {
            content = ' ' + (directiveName || '') + ': ';
            if (comment) content += comment + ' ';
          }
          return window.document.createComment(content);
        };
        return compile;

        function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
          previousCompileContext) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          var NOT_EMPTY = /\S+/;
          for (var i = 0, len = $compileNodes.length; i < len; i++) {
            var domNode = $compileNodes[i];
            if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
              jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
            }
          }
          var compositeLinkFn =
            compileNodes($compileNodes, transcludeFn, $compileNodes,
              maxPriority, ignoreDirective, previousCompileContext);
          compile.$$addScopeClass($compileNodes);
          var namespace = null;
          return function publicLinkFn(scope, cloneConnectFn, options) {
            assertArg(scope, 'scope');
            if (previousCompileContext && previousCompileContext.needsNewScope) {
              scope = scope.$parent.$new();
            }
            options = options || {};
            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
              transcludeControllers = options.transcludeControllers,
              futureParentElement = options.futureParentElement;
            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
              parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
            }
            if (!namespace) {
              namespace = detectNamespaceForChildElements(futureParentElement);
            }
            var $linkNode;
            if (namespace !== 'html') {
              $linkNode = jqLite(
                wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html())
              );
            } else if (cloneConnectFn) {
              $linkNode = JQLitePrototype.clone.call($compileNodes);
            } else {
              $linkNode = $compileNodes;
            }
            if (transcludeControllers) {
              for (var controllerName in transcludeControllers) {
                $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
              }
            }
            compile.$$addScopeInfo($linkNode, scope);
            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
            if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
            return $linkNode;
          };
        }

        function detectNamespaceForChildElements(parentElement) {
          var node = parentElement && parentElement[0];
          if (!node) {
            return 'html';
          } else {
            return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
          }
        }

        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
          previousCompileContext) {
          var linkFns = [],
            attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
              ignoreDirective);
            nodeLinkFn = (directives.length) ?
              applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                null, [], [], previousCompileContext) :
              null;
            if (nodeLinkFn && nodeLinkFn.scope) {
              compile.$$addScopeClass(attrs.$$element);
            }
            childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                !(childNodes = nodeList[i].childNodes) ||
                !childNodes.length) ?
              null :
              compileNodes(childNodes,
                nodeLinkFn ? (
                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) &&
                  nodeLinkFn.transclude) : transcludeFn);
            if (nodeLinkFn || childLinkFn) {
              linkFns.push(i, nodeLinkFn, childLinkFn);
              linkFnFound = true;
              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
            }
            previousCompileContext = null;
          }
          return linkFnFound ? compositeLinkFn : null;

          function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
            var stableNodeList;
            if (nodeLinkFnFound) {
              var nodeListLength = nodeList.length;
              stableNodeList = new Array(nodeListLength);
              for (i = 0; i < linkFns.length; i += 3) {
                idx = linkFns[i];
                stableNodeList[idx] = nodeList[idx];
              }
            } else {
              stableNodeList = nodeList;
            }
            for (i = 0, ii = linkFns.length; i < ii;) {
              node = stableNodeList[linkFns[i++]];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new();
                  compile.$$addScopeInfo(jqLite(node), childScope);
                } else {
                  childScope = scope;
                }
                if (nodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                  childBoundTranscludeFn = parentBoundTranscludeFn;
                } else if (!parentBoundTranscludeFn && transcludeFn) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                } else {
                  childBoundTranscludeFn = null;
                }
                nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
              }
            }
          }
        }

        function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
          function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
            if (!transcludedScope) {
              transcludedScope = scope.$new(false, containingScope);
              transcludedScope.$$transcluded = true;
            }
            return transcludeFn(transcludedScope, cloneFn, {
              parentBoundTranscludeFn: previousBoundTranscludeFn,
              transcludeControllers: controllers,
              futureParentElement: futureParentElement
            });
          }
          var boundSlots = boundTranscludeFn.$$slots = createMap();
          for (var slotName in transcludeFn.$$slots) {
            if (transcludeFn.$$slots[slotName]) {
              boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
            } else {
              boundSlots[slotName] = null;
            }
          }
          return boundTranscludeFn;
        }

        function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
          var nodeType = node.nodeType,
            attrsMap = attrs.$attr,
            match,
            className;
          switch (nodeType) {
            case NODE_TYPE_ELEMENT:
              addDirective(directives,
                directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
              for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
                  j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                var attrStartName = false;
                var attrEndName = false;
                attr = nAttrs[j];
                name = attr.name;
                value = trim(attr.value);
                ngAttrName = directiveNormalize(name);
                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                  name = name.replace(PREFIX_REGEXP, '')
                    .substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                }
                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                  attrStartName = name;
                  attrEndName = name.substr(0, name.length - 5) + 'end';
                  name = name.substr(0, name.length - 6);
                }
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true;
                  }
                }
                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
                  attrEndName);
              }
              className = node.className;
              if (isObject(className)) {
                className = className.animVal;
              }
              if (isString(className) && className !== '') {
                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                  nName = directiveNormalize(match[2]);
                  if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                    attrs[nName] = trim(match[3]);
                  }
                  className = className.substr(match.index + match[0].length);
                }
              }
              break;
            case NODE_TYPE_TEXT:
              if (msie === 11) {
                while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                  node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                  node.parentNode.removeChild(node.nextSibling);
                }
              }
              addTextInterpolateDirective(directives, node.nodeValue);
              break;
            case NODE_TYPE_COMMENT:
              collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
              break;
          }
          directives.sort(byPriority);
          return directives;
        }

        function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
          try {
            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              var nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {}
        }

        function groupScan(node, attrStart, attrEnd) {
          var nodes = [];
          var depth = 0;
          if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
            do {
              if (!node) {
                throw $compileMinErr('uterdir',
                  "Unterminated attribute, found '{0}' but no matching '{1}' found.",
                  attrStart, attrEnd);
              }
              if (node.nodeType == NODE_TYPE_ELEMENT) {
                if (node.hasAttribute(attrStart)) depth++;
                if (node.hasAttribute(attrEnd)) depth--;
              }
              nodes.push(node);
              node = node.nextSibling;
            } while (depth > 0);
          } else {
            nodes.push(node);
          }
          return jqLite(nodes);
        }

        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
          return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
            element = groupScan(element[0], attrStart, attrEnd);
            return linkFn(scope, element, attrs, controllers, transcludeFn);
          };
        }

        function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
          var compiled;
          if (eager) {
            return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
          }
          return function lazyCompilation() {
            if (!compiled) {
              compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
              $compileNodes = transcludeFn = previousCompileContext = null;
            }
            return compiled.apply(this, arguments);
          };
        }

        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
          jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
          previousCompileContext) {
          previousCompileContext = previousCompileContext || {};
          var terminalPriority = -Number.MAX_VALUE,
            newScopeDirective = previousCompileContext.newScopeDirective,
            controllerDirectives = previousCompileContext.controllerDirectives,
            newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
            templateDirective = previousCompileContext.templateDirective,
            nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
            hasTranscludeDirective = false,
            hasTemplate = false,
            hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
            $compileNode = templateAttrs.$$element = jqLite(compileNode),
            directive,
            directiveName,
            $template,
            replaceDirective = originalReplaceDirective,
            childTranscludeFn = transcludeFn,
            linkFn,
            didScanForMultipleTransclusion = false,
            mightHaveMultipleTransclusionError = false,
            directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            var attrStart = directive.$$start;
            var attrEnd = directive.$$end;
            if (attrStart) {
              $compileNode = groupScan(compileNode, attrStart, attrEnd);
            }
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              if (!directive.templateUrl) {
                if (isObject(directiveValue)) {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
                    directive, $compileNode);
                  newIsolateScopeDirective = directive;
                } else {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
                    $compileNode);
                }
              }
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) ||
                (directive.transclude && !directive.$$tlb))) {
              var candidateDirective;
              for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];) {
                if ((candidateDirective.transclude && !candidateDirective.$$tlb) ||
                  (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                  mightHaveMultipleTransclusionError = true;
                  break;
                }
              }
              didScanForMultipleTransclusion = true;
            }
            if (!directive.templateUrl && directive.controller) {
              directiveValue = directive.controller;
              controllerDirectives = controllerDirectives || createMap();
              assertNoDuplicate("'" + directiveName + "' controller",
                controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              hasTranscludeDirective = true;
              if (!directive.$$tlb) {
                assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                nonTlbTranscludeDirective = directive;
              }
              if (directiveValue == 'element') {
                hasElementTranscludeDirective = true;
                terminalPriority = directive.priority;
                $template = $compileNode;
                $compileNode = templateAttrs.$$element =
                  jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, sliceArgs($template), compileNode);
                $template[0].$$parentNode = $template[0].parentNode;
                childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority,
                  replaceDirective && replaceDirective.name, {
                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                  });
              } else {
                var slots = createMap();
                $template = jqLite(jqLiteClone(compileNode)).contents();
                if (isObject(directiveValue)) {
                  $template = [];
                  var slotMap = createMap();
                  var filledSlots = createMap();
                  forEach(directiveValue, function(elementSelector, slotName) {
                    var optional = (elementSelector.charAt(0) === '?');
                    elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                    slotMap[elementSelector] = slotName;
                    slots[slotName] = null;
                    filledSlots[slotName] = optional;
                  });
                  forEach($compileNode.contents(), function(node) {
                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                    if (slotName) {
                      filledSlots[slotName] = true;
                      slots[slotName] = slots[slotName] || [];
                      slots[slotName].push(node);
                    } else {
                      $template.push(node);
                    }
                  });
                  forEach(filledSlots, function(filled, slotName) {
                    if (!filled) {
                      throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                    }
                  });
                  for (var slotName in slots) {
                    if (slots[slotName]) {
                      slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                    }
                  }
                }
                $compileNode.empty();
                childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined,
                  undefined, {
                    needsNewScope: directive.$$isolateScope || directive.$$newScope
                  });
                childTranscludeFn.$$slots = slots;
              }
            }
            if (directive.template) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = (isFunction(directive.template)) ?
                directive.template($compileNode, templateAttrs) :
                directive.template;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                replaceDirective = directive;
                if (jqLiteIsTextNode(directiveValue)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt',
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    directiveName, '');
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = {
                  $attr: {}
                };
                var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                if (newIsolateScopeDirective || newScopeDirective) {
                  markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                }
                directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              if (directive.replace) {
                replaceDirective = directive;
              }
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
                templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                var context = directive.$$originalDirective || directive;
                if (isFunction(linkFn)) {
                  addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                } else if (linkFn) {
                  addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
          nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
          nodeLinkFn.templateOnThisElement = hasTemplate;
          nodeLinkFn.transclude = childTranscludeFn;
          previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
          return nodeLinkFn;

          function addLinkFns(pre, post, attrStart, attrEnd) {
            if (pre) {
              if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
              pre.require = directive.require;
              pre.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                pre = cloneAndAnnotateFn(pre, {
                  isolateScope: true
                });
              }
              preLinkFns.push(pre);
            }
            if (post) {
              if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
              post.require = directive.require;
              post.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                post = cloneAndAnnotateFn(post, {
                  isolateScope: true
                });
              }
              postLinkFns.push(post);
            }
          }

          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element,
              attrs, scopeBindingInfo;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
              $element = templateAttrs.$$element;
            } else {
              $element = jqLite(linkNode);
              attrs = new Attributes($element, templateAttrs);
            }
            controllerScope = scope;
            if (newIsolateScopeDirective) {
              isolateScope = scope.$new(true);
            } else if (newScopeDirective) {
              controllerScope = scope.$parent;
            }
            if (boundTranscludeFn) {
              transcludeFn = controllersBoundTransclude;
              transcludeFn.$$boundTransclude = boundTranscludeFn;
              transcludeFn.isSlotFilled = function(slotName) {
                return !!boundTranscludeFn.$$slots[slotName];
              };
            }
            if (controllerDirectives) {
              elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
            }
            if (newIsolateScopeDirective) {
              compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective ||
                templateDirective === newIsolateScopeDirective.$$originalDirective)));
              compile.$$addScopeClass($element, true);
              isolateScope.$$isolateBindings =
                newIsolateScopeDirective.$$isolateBindings;
              scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope,
                isolateScope.$$isolateBindings,
                newIsolateScopeDirective);
              if (scopeBindingInfo.removeWatches) {
                isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
              }
            }
            for (var name in elementControllers) {
              var controllerDirective = controllerDirectives[name];
              var controller = elementControllers[name];
              var bindings = controllerDirective.$$bindings.bindToController;
              if (controller.identifier && bindings) {
                controller.bindingInfo =
                  initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
              } else {
                controller.bindingInfo = {};
              }
              var controllerResult = controller();
              if (controllerResult !== controller.instance) {
                controller.instance = controllerResult;
                $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                controller.bindingInfo =
                  initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
              }
            }
            forEach(controllerDirectives, function(controllerDirective, name) {
              var require = controllerDirective.require;
              if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
              }
            });
            forEach(elementControllers, function(controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$onChanges)) {
                try {
                  controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$onInit)) {
                try {
                  controllerInstance.$onInit();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (isFunction(controllerInstance.$doCheck)) {
                controllerScope.$watch(function() {
                  controllerInstance.$doCheck();
                });
                controllerInstance.$doCheck();
              }
              if (isFunction(controllerInstance.$onDestroy)) {
                controllerScope.$on('$destroy', function callOnDestroyHook() {
                  controllerInstance.$onDestroy();
                });
              }
            });
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              linkFn = preLinkFns[i];
              invokeLinkFn(linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
                transcludeFn
              );
            }
            var scopeToChild = scope;
            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
              scopeToChild = isolateScope;
            }
            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = postLinkFns.length - 1; i >= 0; i--) {
              linkFn = postLinkFns[i];
              invokeLinkFn(linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
                transcludeFn
              );
            }
            forEach(elementControllers, function(controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$postLink)) {
                controllerInstance.$postLink();
              }
            });

            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
              var transcludeControllers;
              if (!isScope(scope)) {
                slotName = futureParentElement;
                futureParentElement = cloneAttachFn;
                cloneAttachFn = scope;
                scope = undefined;
              }
              if (hasElementTranscludeDirective) {
                transcludeControllers = elementControllers;
              }
              if (!futureParentElement) {
                futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
              }
              if (slotName) {
                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                if (slotTranscludeFn) {
                  return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                } else if (isUndefined(slotTranscludeFn)) {
                  throw $compileMinErr('noslot',
                    'No parent directive that requires a transclusion with slot name "{0}". ' +
                    'Element: {1}',
                    slotName, startingTag($element));
                }
              } else {
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
        }

        function getControllers(directiveName, require, $element, elementControllers) {
          var value;
          if (isString(require)) {
            var match = require.match(REQUIRE_PREFIX_REGEXP);
            var name = require.substring(match[0].length);
            var inheritType = match[1] || match[3];
            var optional = match[2] === '?';
            if (inheritType === '^^') {
              $element = $element.parent();
            } else {
              value = elementControllers && elementControllers[name];
              value = value && value.instance;
            }
            if (!value) {
              var dataName = '$' + name + 'Controller';
              value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
            }
            if (!value && !optional) {
              throw $compileMinErr('ctreq',
                "Controller '{0}', required by directive '{1}', can't be found!",
                name, directiveName);
            }
          } else if (isArray(require)) {
            value = [];
            for (var i = 0, ii = require.length; i < ii; i++) {
              value[i] = getControllers(directiveName, require[i], $element, elementControllers);
            }
          } else if (isObject(require)) {
            value = {};
            forEach(require, function(controller, property) {
              value[property] = getControllers(directiveName, controller, $element, elementControllers);
            });
          }
          return value || null;
        }

        function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
          var elementControllers = createMap();
          for (var controllerKey in controllerDirectives) {
            var directive = controllerDirectives[controllerKey];
            var locals = {
              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn
            };
            var controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }
            var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
            elementControllers[directive.name] = controllerInstance;
            $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
          }
          return elementControllers;
        }

        function markDirectiveScope(directives, isolateScope, newScope) {
          for (var j = 0, jj = directives.length; j < jj; j++) {
            directives[j] = inherit(directives[j], {
              $$isolateScope: isolateScope,
              $$newScope: newScope
            });
          }
        }

        function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
          endAttrName) {
          if (name === ignoreDirective) return null;
          var match = null;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix),
                i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((isUndefined(maxPriority) || maxPriority > directive.priority) &&
                  directive.restrict.indexOf(location) != -1) {
                  if (startAttrName) {
                    directive = inherit(directive, {
                      $$start: startAttrName,
                      $$end: endAttrName
                    });
                  }
                  if (!directive.$$bindings) {
                    var bindings = directive.$$bindings =
                      parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                  }
                  tDirectives.push(directive);
                  match = directive;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }

        function directiveIsMultiElement(name) {
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix),
                i = 0, ii = directives.length; i < ii; i++) {
              directive = directives[i];
              if (directive.multiElement) {
                return true;
              }
            }
          }
          return false;
        }

        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr,
            dstAttr = dst.$attr,
            $element = dst.$$element;
          forEach(dst, function(value, key) {
            if (key.charAt(0) != '$') {
              if (src[key] && src[key] !== value) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function(value, key) {
            if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
              dst[key] = value;
              if (key !== 'class' && key !== 'style') {
                dstAttr[key] = srcAttr[key];
              }
            }
          });
        }

        function compileTemplateUrl(directives, $compileNode, tAttrs,
          $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
          var linkQueue = [],
            afterTemplateNodeLinkFn,
            afterTemplateChildLinkFn,
            beforeTemplateCompileNode = $compileNode[0],
            origAsyncDirective = directives.shift(),
            derivedSyncDirective = inherit(origAsyncDirective, {
              templateUrl: null,
              transclude: null,
              replace: null,
              $$originalDirective: origAsyncDirective
            }),
            templateUrl = (isFunction(origAsyncDirective.templateUrl)) ?
            origAsyncDirective.templateUrl($compileNode, tAttrs) :
            origAsyncDirective.templateUrl,
            templateNamespace = origAsyncDirective.templateNamespace;
          $compileNode.empty();
          $templateRequest(templateUrl)
            .then(function(content) {
              var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt',
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {
                  $attr: {}
                };
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
                childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
                previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                  beforeTemplateLinkNode = linkQueue.shift(),
                  linkRootElement = linkQueue.shift(),
                  boundTranscludeFn = linkQueue.shift(),
                  linkNode = $compileNode[0];
                if (scope.$$destroyed) continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective &&
                      origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
                  childBoundTranscludeFn);
              }
              linkQueue = null;
            });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
            var childBoundTranscludeFn = boundTranscludeFn;
            if (scope.$$destroyed) return;
            if (linkQueue) {
              linkQueue.push(scope,
                node,
                rootElement,
                childBoundTranscludeFn);
            } else {
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
              }
              afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
            }
          };
        }

        function byPriority(a, b) {
          var diff = b.priority - a.priority;
          if (diff !== 0) return diff;
          if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
          return a.index - b.index;
        }

        function assertNoDuplicate(what, previousDirective, directive, element) {
          function wrapModuleNameIfDefined(moduleName) {
            return moduleName ?
              (' (module: ' + moduleName + ')') :
              '';
          }
          if (previousDirective) {
            throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}',
              previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),
              directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
          }
        }

        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: function textInterpolateCompileFn(templateNode) {
                var templateNodeParent = templateNode.parent(),
                  hasCompileParent = !!templateNodeParent.length;
                if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                return function textInterpolateLinkFn(scope, node) {
                  var parent = node.parent();
                  if (!hasCompileParent) compile.$$addBindingClass(parent);
                  compile.$$addBindingInfo(parent, interpolateFn.expressions);
                  scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                    node[0].nodeValue = value;
                  });
                };
              }
            });
          }
        }

        function wrapTemplate(type, template) {
          type = lowercase(type || 'html');
          switch (type) {
            case 'svg':
            case 'math':
              var wrapper = window.document.createElement('div');
              wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
              return wrapper.childNodes[0].childNodes;
            default:
              return template;
          }
        }

        function getTrustedContext(node, attrNormalizedName) {
          if (attrNormalizedName == "srcdoc") {
            return $sce.HTML;
          }
          var tag = nodeName_(node);
          if (attrNormalizedName == "xlinkHref" ||
            (tag == "form" && attrNormalizedName == "action") ||
            (tag != "img" && (attrNormalizedName == "src" ||
              attrNormalizedName == "ngSrc"))) {
            return $sce.RESOURCE_URL;
          }
        }

        function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
          var trustedContext = getTrustedContext(node, name);
          allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
          var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
          if (!interpolateFn) return;
          if (name === "multiple" && nodeName_(node) === "select") {
            throw $compileMinErr("selmulti",
              "Binding to the 'multiple' attribute is not supported. Element: {0}",
              startingTag(node));
          }
          directives.push({
            priority: 100,
            compile: function() {
              return {
                pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                  var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                  if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr('nodomevents',
                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                      "ng- versions (such as ng-click instead of onclick) instead.");
                  }
                  var newValue = attr[name];
                  if (newValue !== value) {
                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                    value = newValue;
                  }
                  if (!interpolateFn) return;
                  attr[name] = interpolateFn(scope);
                  ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                  (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    if (name === 'class' && newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
                }
              };
            }
          });
        }

        function replaceWith($rootElement, elementsToRemove, newNode) {
          var firstElementToRemove = elementsToRemove[0],
            removeCount = elementsToRemove.length,
            parent = firstElementToRemove.parentNode,
            i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == firstElementToRemove) {
                $rootElement[i++] = newNode;
                for (var j = i, j2 = j + removeCount - 1,
                    jj = $rootElement.length; j < jj; j++, j2++) {
                  if (j2 < jj) {
                    $rootElement[j] = $rootElement[j2];
                  } else {
                    delete $rootElement[j];
                  }
                }
                $rootElement.length -= removeCount - 1;
                if ($rootElement.context === firstElementToRemove) {
                  $rootElement.context = newNode;
                }
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, firstElementToRemove);
          }
          var fragment = window.document.createDocumentFragment();
          for (i = 0; i < removeCount; i++) {
            fragment.appendChild(elementsToRemove[i]);
          }
          if (jqLite.hasData(firstElementToRemove)) {
            jqLite.data(newNode, jqLite.data(firstElementToRemove));
            jqLite(firstElementToRemove).off('$destroy');
          }
          jqLite.cleanData(fragment.querySelectorAll('*'));
          for (i = 1; i < removeCount; i++) {
            delete elementsToRemove[i];
          }
          elementsToRemove[0] = newNode;
          elementsToRemove.length = 1;
        }

        function cloneAndAnnotateFn(fn, annotation) {
          return extend(function() {
            return fn.apply(null, arguments);
          }, fn, annotation);
        }

        function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
          try {
            linkFn(scope, $element, attrs, controllers, transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
          var removeWatchCollection = [];
          var initialChanges = {};
          var changes;
          forEach(bindings, function initializeBinding(definition, scopeName) {
            var attrName = definition.attrName,
              optional = definition.optional,
              mode = definition.mode,
              lastValue,
              parentGet, parentSet, compare, removeWatch;
            switch (mode) {
              case '@':
                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                  destination[scopeName] = attrs[attrName] = void 0;
                }
                attrs.$observe(attrName, function(value) {
                  if (isString(value) || isBoolean(value)) {
                    var oldValue = destination[scopeName];
                    recordChanges(scopeName, value, oldValue);
                    destination[scopeName] = value;
                  }
                });
                attrs.$$observers[attrName].$$scope = scope;
                lastValue = attrs[attrName];
                if (isString(lastValue)) {
                  destination[scopeName] = $interpolate(lastValue)(scope);
                } else if (isBoolean(lastValue)) {
                  destination[scopeName] = lastValue;
                }
                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                break;
              case '=':
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = void 0;
                }
                if (optional && !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function simpleCompare(a, b) {
                    return a === b || (a !== a && b !== b);
                  };
                }
                parentSet = parentGet.assign || function() {
                  lastValue = destination[scopeName] = parentGet(scope);
                  throw $compileMinErr('nonassign',
                    "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                    attrs[attrName], attrName, directive.name);
                };
                lastValue = destination[scopeName] = parentGet(scope);
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      destination[scopeName] = parentValue;
                    } else {
                      parentSet(scope, parentValue = destination[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                };
                parentValueWatch.$stateful = true;
                if (definition.collection) {
                  removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                } else {
                  removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                }
                removeWatchCollection.push(removeWatch);
                break;
              case '<':
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = void 0;
                }
                if (optional && !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                var initialValue = destination[scopeName] = parentGet(scope);
                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                  if (oldValue === newValue) {
                    if (oldValue === initialValue) return;
                    oldValue = initialValue;
                  }
                  recordChanges(scopeName, newValue, oldValue);
                  destination[scopeName] = newValue;
                }, parentGet.literal);
                removeWatchCollection.push(removeWatch);
                break;
              case '&':
                parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                if (parentGet === noop && optional) break;
                destination[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });

          function recordChanges(key, currentValue, previousValue) {
            if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
              if (!onChangesQueue) {
                scope.$$postDigest(flushOnChangesQueue);
                onChangesQueue = [];
              }
              if (!changes) {
                changes = {};
                onChangesQueue.push(triggerOnChangesHook);
              }
              if (changes[key]) {
                previousValue = changes[key].previousValue;
              }
              changes[key] = new SimpleChange(previousValue, currentValue);
            }
          }

          function triggerOnChangesHook() {
            destination.$onChanges(changes);
            changes = undefined;
          }
          return {
            initialChanges: initialChanges,
            removeWatches: removeWatchCollection.length && function removeWatches() {
              for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            }
          };
        }
      }
    ];
  }

  function SimpleChange(previous, current) {
    this.previousValue = previous;
    this.currentValue = current;
  }
  SimpleChange.prototype.isFirstChange = function() {
    return this.previousValue === _UNINITIALIZED_VALUE;
  };
  var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;

  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }

  function nodesetLinkingFn(
    scope,
    nodeList,
    rootElement,
    boundTranscludeFn
  ) {}

  function directiveLinkingFn(
    nodesetLinkingFn,
    scope,
    node,
    rootElement,
    boundTranscludeFn
  ) {}

  function tokenDifference(str1, str2) {
    var values = '',
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);
    outer:
      for (var i = 0; i < tokens1.length; i++) {
        var token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
          if (token == tokens2[j]) continue outer;
        }
        values += (values.length > 0 ? ' ' : '') + token;
      }
    return values;
  }

  function removeComments(jqNodes) {
    jqNodes = jqLite(jqNodes);
    var i = jqNodes.length;
    if (i <= 1) {
      return jqNodes;
    }
    while (i--) {
      var node = jqNodes[i];
      if (node.nodeType === NODE_TYPE_COMMENT) {
        splice.call(jqNodes, i, 1);
      }
    }
    return jqNodes;
  }
  var $controllerMinErr = minErr('$controller');
  var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;

  function identifierForController(controller, ident) {
    if (ident && isString(ident)) return ident;
    if (isString(controller)) {
      var match = CNTRL_REG.exec(controller);
      if (match) return match[3];
    }
  }

  function $ControllerProvider() {
    var controllers = {},
      globals = false;
    this.has = function(name) {
      return controllers.hasOwnProperty(name);
    };
    this.register = function(name, constructor) {
      assertNotHasOwnProperty(name, 'controller');
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.allowGlobals = function() {
      globals = true;
    };
    this.$get = ['$injector', '$window', function($injector, $window) {
      return function $controller(expression, locals, later, ident) {
        var instance, match, constructor, identifier;
        later = later === true;
        if (ident && isString(ident)) {
          identifier = ident;
        }
        if (isString(expression)) {
          match = expression.match(CNTRL_REG);
          if (!match) {
            throw $controllerMinErr('ctrlfmt',
              "Badly formed controller string '{0}'. " +
              "Must match `__name__ as __id__` or `__name__`.", expression);
          }
          constructor = match[1],
            identifier = identifier || match[3];
          expression = controllers.hasOwnProperty(constructor) ?
            controllers[constructor] :
            getter(locals.$scope, constructor, true) ||
            (globals ? getter($window, constructor, true) : undefined);
          assertArgFn(expression, constructor, true);
        }
        if (later) {
          var controllerPrototype = (isArray(expression) ?
            expression[expression.length - 1] : expression).prototype;
          instance = Object.create(controllerPrototype || null);
          if (identifier) {
            addIdentifier(locals, identifier, instance, constructor || expression.name);
          }
          var instantiate;
          return instantiate = extend(function $controllerInit() {
            var result = $injector.invoke(expression, instance, locals, constructor);
            if (result !== instance && (isObject(result) || isFunction(result))) {
              instance = result;
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
            }
            return instance;
          }, {
            instance: instance,
            identifier: identifier
          });
        }
        instance = $injector.instantiate(expression, locals, constructor);
        if (identifier) {
          addIdentifier(locals, identifier, instance, constructor || expression.name);
        }
        return instance;
      };

      function addIdentifier(locals, identifier, instance, name) {
        if (!(locals && isObject(locals.$scope))) {
          throw minErr('$controller')('noscp',
            "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
            name, identifier);
        }
        locals.$scope[identifier] = instance;
      }
    }];
  }

  function $DocumentProvider() {
    this.$get = ['$window', function(window) {
      return jqLite(window.document);
    }];
  }

  function $ExceptionHandlerProvider() {
    this.$get = ['$log', function($log) {
      return function(exception, cause) {
        $log.error.apply($log, arguments);
      };
    }];
  }
  var $$ForceReflowProvider = function() {
    this.$get = ['$document', function($document) {
      return function(domNode) {
        if (domNode) {
          if (!domNode.nodeType && domNode instanceof jqLite) {
            domNode = domNode[0];
          }
        } else {
          domNode = $document[0].body;
        }
        return domNode.offsetWidth + 1;
      };
    }];
  };
  var APPLICATION_JSON = 'application/json';
  var CONTENT_TYPE_APPLICATION_JSON = {
    'Content-Type': APPLICATION_JSON + ';charset=utf-8'
  };
  var JSON_START = /^\[|^\{(?!\{)/;
  var JSON_ENDS = {
    '[': /]$/,
    '{': /}$/
  };
  var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
  var $httpMinErr = minErr('$http');
  var $httpMinErrLegacyFn = function(method) {
    return function() {
      throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
    };
  };

  function serializeValue(v) {
    if (isObject(v)) {
      return isDate(v) ? v.toISOString() : toJson(v);
    }
    return v;
  }

  function $HttpParamSerializerProvider() {
    this.$get = function() {
      return function ngParamSerializer(params) {
        if (!params) return '';
        var parts = [];
        forEachSorted(params, function(value, key) {
          if (value === null || isUndefined(value)) return;
          if (isArray(value)) {
            forEach(value, function(v) {
              parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
            });
          } else {
            parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
          }
        });
        return parts.join('&');
      };
    };
  }

  function $HttpParamSerializerJQLikeProvider() {
    this.$get = function() {
      return function jQueryLikeParamSerializer(params) {
        if (!params) return '';
        var parts = [];
        serialize(params, '', true);
        return parts.join('&');

        function serialize(toSerialize, prefix, topLevel) {
          if (toSerialize === null || isUndefined(toSerialize)) return;
          if (isArray(toSerialize)) {
            forEach(toSerialize, function(value, index) {
              serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
            });
          } else if (isObject(toSerialize) && !isDate(toSerialize)) {
            forEachSorted(toSerialize, function(value, key) {
              serialize(value, prefix +
                (topLevel ? '' : '[') +
                key +
                (topLevel ? '' : ']'));
            });
          } else {
            parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
          }
        }
      };
    };
  }

  function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
      var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
      if (tempData) {
        var contentType = headers('Content-Type');
        if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
          data = fromJson(tempData);
        }
      }
    }
    return data;
  }

  function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
  }

  function parseHeaders(headers) {
    var parsed = createMap(),
      i;

    function fillInParsed(key, val) {
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
    if (isString(headers)) {
      forEach(headers.split('\n'), function(line) {
        i = line.indexOf(':');
        fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
      });
    } else if (isObject(headers)) {
      forEach(headers, function(headerVal, headerKey) {
        fillInParsed(lowercase(headerKey), trim(headerVal));
      });
    }
    return parsed;
  }

  function headersGetter(headers) {
    var headersObj;
    return function(name) {
      if (!headersObj) headersObj = parseHeaders(headers);
      if (name) {
        var value = headersObj[lowercase(name)];
        if (value === void 0) {
          value = null;
        }
        return value;
      }
      return headersObj;
    };
  }

  function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
      return fns(data, headers, status);
    }
    forEach(fns, function(fn) {
      data = fn(data, headers, status);
    });
    return data;
  }

  function isSuccess(status) {
    return 200 <= status && status < 300;
  }

  function $HttpProvider() {
    var defaults = this.defaults = {
      transformResponse: [defaultHttpResponseTransform],
      transformRequest: [function(d) {
        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
      }],
      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*'
        },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
      },
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      paramSerializer: '$httpParamSerializer'
    };
    var useApplyAsync = false;
    this.useApplyAsync = function(value) {
      if (isDefined(value)) {
        useApplyAsync = !!value;
        return this;
      }
      return useApplyAsync;
    };
    var useLegacyPromise = true;
    this.useLegacyPromiseExtensions = function(value) {
      if (isDefined(value)) {
        useLegacyPromise = !!value;
        return this;
      }
      return useLegacyPromise;
    };
    var interceptorFactories = this.interceptors = [];
    this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector',
      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http');
        defaults.paramSerializer = isString(defaults.paramSerializer) ?
          $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function(interceptorFactory) {
          reversedInterceptors.unshift(isString(interceptorFactory) ?
            $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
        });

        function $http(requestConfig) {
          if (!isObject(requestConfig)) {
            throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
          }
          if (!isString(requestConfig.url)) {
            throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
          }
          var config = extend({
            method: 'get',
            transformRequest: defaults.transformRequest,
            transformResponse: defaults.transformResponse,
            paramSerializer: defaults.paramSerializer
          }, requestConfig);
          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer) ?
            $injector.get(config.paramSerializer) : config.paramSerializer;
          var requestInterceptors = [];
          var responseInterceptors = [];
          var promise = $q.when(config);
          forEach(reversedInterceptors, function(interceptor) {
            if (interceptor.request || interceptor.requestError) {
              requestInterceptors.unshift(interceptor.request, interceptor.requestError);
            }
            if (interceptor.response || interceptor.responseError) {
              responseInterceptors.push(interceptor.response, interceptor.responseError);
            }
          });
          promise = chainInterceptors(promise, requestInterceptors);
          promise = promise.then(serverRequest);
          promise = chainInterceptors(promise, responseInterceptors);
          if (useLegacyPromise) {
            promise.success = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
            promise.error = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(null, function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
          } else {
            promise.success = $httpMinErrLegacyFn('success');
            promise.error = $httpMinErrLegacyFn('error');
          }
          return promise;

          function chainInterceptors(promise, interceptors) {
            for (var i = 0, ii = interceptors.length; i < ii;) {
              var thenFn = interceptors[i++];
              var rejectFn = interceptors[i++];
              promise = promise.then(thenFn, rejectFn);
            }
            interceptors.length = 0;
            return promise;
          }

          function executeHeaderFns(headers, config) {
            var headerContent, processedHeaders = {};
            forEach(headers, function(headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn(config);
                if (headerContent != null) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });
            return processedHeaders;
          }

          function mergeHeaders(config) {
            var defHeaders = defaults.headers,
              reqHeaders = extend({}, config.headers),
              defHeaderName, lowercaseDefHeaderName, reqHeaderName;
            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
            defaultHeadersIteration:
              for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
            return executeHeaderFns(reqHeaders, shallowCopy(config));
          }

          function serverRequest(config) {
            var headers = config.headers;
            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
            if (isUndefined(reqData)) {
              forEach(headers, function(value, header) {
                if (lowercase(header) === 'content-type') {
                  delete headers[header];
                }
              });
            }
            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
              config.withCredentials = defaults.withCredentials;
            }
            return sendReq(config, reqData).then(transformResponse, transformResponse);
          }

          function transformResponse(response) {
            var resp = extend({}, response);
            resp.data = transformData(response.data, response.headers, response.status,
              config.transformResponse);
            return (isSuccess(response.status)) ?
              resp :
              $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put', 'patch');
        $http.defaults = defaults;
        return $http;

        function createShortMethods(names) {
          forEach(arguments, function(name) {
            $http[name] = function(url, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }

        function createShortMethodsWithData(name) {
          forEach(arguments, function(name) {
            $http[name] = function(url, data, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }

        function sendReq(config, reqData) {
          var deferred = $q.defer(),
            promise = deferred.promise,
            cache,
            cachedResp,
            reqHeaders = config.headers,
            url = buildUrl(config.url, config.paramSerializer(config.params));
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if ((config.cache || defaults.cache) && config.cache !== false &&
            (config.method === 'GET' || config.method === 'JSONP')) {
            cache = isObject(config.cache) ? config.cache :
              isObject(defaults.cache) ? defaults.cache :
              defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                } else {
                  resolvePromise(cachedResp, 200, {}, 'OK');
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (isUndefined(cachedResp)) {
            var xsrfValue = urlIsSameOrigin(config.url) ?
              $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] :
              undefined;
            if (xsrfValue) {
              reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
            }
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
              config.withCredentials, config.responseType,
              createApplyHandlers(config.eventHandlers),
              createApplyHandlers(config.uploadEventHandlers));
          }
          return promise;

          function createApplyHandlers(eventHandlers) {
            if (eventHandlers) {
              var applyHandlers = {};
              forEach(eventHandlers, function(eventHandler, key) {
                applyHandlers[key] = function(event) {
                  if (useApplyAsync) {
                    $rootScope.$applyAsync(callEventHandler);
                  } else if ($rootScope.$$phase) {
                    callEventHandler();
                  } else {
                    $rootScope.$apply(callEventHandler);
                  }

                  function callEventHandler() {
                    eventHandler(event);
                  }
                };
              });
              return applyHandlers;
            }
          }

          function done(status, response, headersString, statusText) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [status, response, parseHeaders(headersString), statusText]);
              } else {
                cache.remove(url);
              }
            }

            function resolveHttpPromise() {
              resolvePromise(response, status, headersString, statusText);
            }
            if (useApplyAsync) {
              $rootScope.$applyAsync(resolveHttpPromise);
            } else {
              resolveHttpPromise();
              if (!$rootScope.$$phase) $rootScope.$apply();
            }
          }

          function resolvePromise(response, status, headers, statusText) {
            status = status >= -1 ? status : 0;
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config,
              statusText: statusText
            });
          }

          function resolvePromiseWithResult(result) {
            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
          }

          function removePendingReq() {
            var idx = $http.pendingRequests.indexOf(config);
            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
          }
        }

        function buildUrl(url, serializedParams) {
          if (serializedParams.length > 0) {
            url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
          }
          return url;
        }
      }
    ];
  }

  function $xhrFactoryProvider() {
    this.$get = function() {
      return function createXhr() {
        return new window.XMLHttpRequest();
      };
    };
  }

  function $HttpBackendProvider() {
    this.$get = ['$browser', '$jsonpCallbacks', '$document', '$xhrFactory', function($browser, $jsonpCallbacks, $document, $xhrFactory) {
      return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
    }];
  }

  function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
    return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) === 'jsonp') {
        var callbackPath = callbacks.createCallback(url);
        var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
          var response = (status === 200) && callbacks.getResponse(callbackPath);
          completeRequest(callback, status, response, "", text);
          callbacks.removeCallback(callbackPath);
        });
      } else {
        var xhr = createXhr(method, url);
        xhr.open(method, url, true);
        forEach(headers, function(value, key) {
          if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
          }
        });
        xhr.onload = function requestLoaded() {
          var statusText = xhr.statusText || '';
          var response = ('response' in xhr) ? xhr.response : xhr.responseText;
          var status = xhr.status === 1223 ? 204 : xhr.status;
          if (status === 0) {
            status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
          }
          completeRequest(callback,
            status,
            response,
            xhr.getAllResponseHeaders(),
            statusText);
        };
        var requestError = function() {
          completeRequest(callback, -1, null, null, '');
        };
        xhr.onerror = requestError;
        xhr.onabort = requestError;
        forEach(eventHandlers, function(value, key) {
          xhr.addEventListener(key, value);
        });
        forEach(uploadEventHandlers, function(value, key) {
          xhr.upload.addEventListener(key, value);
        });
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        if (responseType) {
          try {
            xhr.responseType = responseType;
          } catch (e) {
            if (responseType !== 'json') {
              throw e;
            }
          }
        }
        xhr.send(isUndefined(post) ? null : post);
      }
      if (timeout > 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
      } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
      }

      function timeoutRequest() {
        jsonpDone && jsonpDone();
        xhr && xhr.abort();
      }

      function completeRequest(callback, status, response, headersString, statusText) {
        if (isDefined(timeoutId)) {
          $browserDefer.cancel(timeoutId);
        }
        jsonpDone = xhr = null;
        callback(status, response, headersString, statusText);
        $browser.$$completeOutstandingRequest(noop);
      }
    };

    function jsonpReq(url, callbackPath, done) {
      url = url.replace('JSON_CALLBACK', callbackPath);
      var script = rawDocument.createElement('script'),
        callback = null;
      script.type = "text/javascript";
      script.src = url;
      script.async = true;
      callback = function(event) {
        removeEventListenerFn(script, "load", callback);
        removeEventListenerFn(script, "error", callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = "unknown";
        if (event) {
          if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
            event = {
              type: "error"
            };
          }
          text = event.type;
          status = event.type === "error" ? 404 : 200;
        }
        if (done) {
          done(status, text);
        }
      };
      addEventListenerFn(script, "load", callback);
      addEventListenerFn(script, "error", callback);
      rawDocument.body.appendChild(script);
      return callback;
    }
  }
  var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
  $interpolateMinErr.throwNoconcat = function(text) {
    throw $interpolateMinErr('noconcat',
      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
      "interpolations that concatenate multiple expressions when a trusted value is " +
      "required.  See http://docs.angularjs.org/api/ng.$sce", text);
  };
  $interpolateMinErr.interr = function(text, err) {
    return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
  };

  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function(value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function(value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
      var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length,
        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');

      function escape(ch) {
        return '\\\\\\' + ch;
      }

      function unescapeText(text) {
        return text.replace(escapedStartRegexp, startSymbol).
        replace(escapedEndRegexp, endSymbol);
      }

      function stringify(value) {
        if (value == null) {
          return '';
        }
        switch (typeof value) {
          case 'string':
            break;
          case 'number':
            value = '' + value;
            break;
          default:
            value = toJson(value);
        }
        return value;
      }

      function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
        var unwatch;
        return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
          unwatch();
          return constantInterp(scope);
        }, listener, objectEquality);
      }

      function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
        if (!text.length || text.indexOf(startSymbol) === -1) {
          var constantInterp;
          if (!mustHaveExpression) {
            var unescapedText = unescapeText(text);
            constantInterp = valueFn(unescapedText);
            constantInterp.exp = text;
            constantInterp.expressions = [];
            constantInterp.$$watchDelegate = constantWatchDelegate;
          }
          return constantInterp;
        }
        allOrNothing = !!allOrNothing;
        var startIndex,
          endIndex,
          index = 0,
          expressions = [],
          parseFns = [],
          textLength = text.length,
          exp,
          concat = [],
          expressionPositions = [];
        while (index < textLength) {
          if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&
            ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
            if (index !== startIndex) {
              concat.push(unescapeText(text.substring(index, startIndex)));
            }
            exp = text.substring(startIndex + startSymbolLength, endIndex);
            expressions.push(exp);
            parseFns.push($parse(exp, parseStringifyInterceptor));
            index = endIndex + endSymbolLength;
            expressionPositions.push(concat.length);
            concat.push('');
          } else {
            if (index !== textLength) {
              concat.push(unescapeText(text.substring(index)));
            }
            break;
          }
        }
        if (trustedContext && concat.length > 1) {
          $interpolateMinErr.throwNoconcat(text);
        }
        if (!mustHaveExpression || expressions.length) {
          var compute = function(values) {
            for (var i = 0, ii = expressions.length; i < ii; i++) {
              if (allOrNothing && isUndefined(values[i])) return;
              concat[expressionPositions[i]] = values[i];
            }
            return concat.join('');
          };
          var getValue = function(value) {
            return trustedContext ?
              $sce.getTrusted(trustedContext, value) :
              $sce.valueOf(value);
          };
          return extend(function interpolationFn(context) {
            var i = 0;
            var ii = expressions.length;
            var values = new Array(ii);
            try {
              for (; i < ii; i++) {
                values[i] = parseFns[i](context);
              }
              return compute(values);
            } catch (err) {
              $exceptionHandler($interpolateMinErr.interr(text, err));
            }
          }, {
            exp: text,
            expressions: expressions,
            $$watchDelegate: function(scope, listener) {
              var lastValue;
              return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                var currValue = compute(values);
                if (isFunction(listener)) {
                  listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                }
                lastValue = currValue;
              });
            }
          });
        }

        function parseStringifyInterceptor(value) {
          try {
            value = getValue(value);
            return allOrNothing && !isDefined(value) ? value : stringify(value);
          } catch (err) {
            $exceptionHandler($interpolateMinErr.interr(text, err));
          }
        }
      }
      $interpolate.startSymbol = function() {
        return startSymbol;
      };
      $interpolate.endSymbol = function() {
        return endSymbol;
      };
      return $interpolate;
    }];
  }

  function $IntervalProvider() {
    this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser',
      function($rootScope, $window, $q, $$q, $browser) {
        var intervals = {};

        function interval(fn, delay, count, invokeApply) {
          var hasParams = arguments.length > 4,
            args = hasParams ? sliceArgs(arguments, 4) : [],
            setInterval = $window.setInterval,
            clearInterval = $window.clearInterval,
            iteration = 0,
            skipApply = (isDefined(invokeApply) && !invokeApply),
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise;
          count = isDefined(count) ? count : 0;
          promise.$$intervalId = setInterval(function tick() {
            if (skipApply) {
              $browser.defer(callback);
            } else {
              $rootScope.$evalAsync(callback);
            }
            deferred.notify(iteration++);
            if (count > 0 && iteration >= count) {
              deferred.resolve(iteration);
              clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          intervals[promise.$$intervalId] = deferred;
          return promise;

          function callback() {
            if (!hasParams) {
              fn(iteration);
            } else {
              fn.apply(null, args);
            }
          }
        }
        interval.cancel = function(promise) {
          if (promise && promise.$$intervalId in intervals) {
            intervals[promise.$$intervalId].reject('canceled');
            $window.clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
            return true;
          }
          return false;
        };
        return interval;
      }
    ];
  }
  var $jsonpCallbacksProvider = function() {
    this.$get = ['$window', function($window) {
      var callbacks = $window.angular.callbacks;
      var callbackMap = {};

      function createCallback(callbackId) {
        var callback = function(data) {
          callback.data = data;
          callback.called = true;
        };
        callback.id = callbackId;
        return callback;
      }
      return {
        createCallback: function(url) {
          var callbackId = '_' + (callbacks.$$counter++).toString(36);
          var callbackPath = 'angular.callbacks.' + callbackId;
          var callback = createCallback(callbackId);
          callbackMap[callbackPath] = callbacks[callbackId] = callback;
          return callbackPath;
        },
        wasCalled: function(callbackPath) {
          return callbackMap[callbackPath].called;
        },
        getResponse: function(callbackPath) {
          return callbackMap[callbackPath].data;
        },
        removeCallback: function(callbackPath) {
          var callback = callbackMap[callbackPath];
          delete callbacks[callback.id];
          delete callbackMap[callbackPath];
        }
      };
    }];
  };
  var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  var $locationMinErr = minErr('$location');

  function encodePath(path) {
    var segments = path.split('/'),
      i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }

  function parseAbsoluteUrl(absoluteUrl, locationObj) {
    var parsedUrl = urlResolve(absoluteUrl);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
  }

  function parseAppUrl(relativeUrl, locationObj) {
    var prefixed = (relativeUrl.charAt(0) !== '/');
    if (prefixed) {
      relativeUrl = '/' + relativeUrl;
    }
    var match = urlResolve(relativeUrl);
    locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
      match.pathname.substring(1) : match.pathname);
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
      locationObj.$$path = '/' + locationObj.$$path;
    }
  }

  function startsWith(haystack, needle) {
    return haystack.lastIndexOf(needle, 0) === 0;
  }

  function stripBaseUrl(base, url) {
    if (startsWith(url, base)) {
      return url.substr(base.length);
    }
  }

  function stripHash(url) {
    var index = url.indexOf('#');
    return index == -1 ? url : url.substr(0, index);
  }

  function trimEmptyHash(url) {
    return url.replace(/(#.+)|#$/, '$1');
  }

  function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
  }

  function serverBase(url) {
    return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
  }

  function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || '';
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function(url) {
      var pathUrl = stripBaseUrl(appBaseNoFile, url);
      if (!isString(pathUrl)) {
        throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
          appBaseNoFile);
      }
      parseAppUrl(pathUrl, this);
      if (!this.$$path) {
        this.$$path = '/';
      }
      this.$$compose();
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    };
    this.$$parseLinkUrl = function(url, relHref) {
      if (relHref && relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
      }
      var appUrl, prevAppUrl;
      var rewrittenUrl;
      if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
        prevAppUrl = appUrl;
        if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
          rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
        } else {
          rewrittenUrl = appBase + prevAppUrl;
        }
      } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
        rewrittenUrl = appBaseNoFile + appUrl;
      } else if (appBaseNoFile == url + '/') {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
  }

  function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function(url) {
      var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
      var withoutHashUrl;
      if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
        withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
        if (isUndefined(withoutHashUrl)) {
          withoutHashUrl = withoutBaseUrl;
        }
      } else {
        if (this.$$html5) {
          withoutHashUrl = withoutBaseUrl;
        } else {
          withoutHashUrl = '';
          if (isUndefined(withoutBaseUrl)) {
            appBase = url;
            this.replace();
          }
        }
      }
      parseAppUrl(withoutHashUrl, this);
      this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
      this.$$compose();

      function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (startsWith(url, base)) {
          url = url.replace(base, '');
        }
        if (windowsFilePathExp.exec(url)) {
          return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
      }
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
    };
    this.$$parseLinkUrl = function(url, relHref) {
      if (stripHash(appBase) == stripHash(url)) {
        this.$$parse(url);
        return true;
      }
      return false;
    };
  }

  function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    this.$$parseLinkUrl = function(url, relHref) {
      if (relHref && relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
      }
      var rewrittenUrl;
      var appUrl;
      if (appBase == stripHash(url)) {
        rewrittenUrl = url;
      } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
        rewrittenUrl = appBase + hashPrefix + appUrl;
      } else if (appBaseNoFile === url + '/') {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBase + hashPrefix + this.$$url;
    };
  }
  var locationPrototype = {
    $$absUrl: '',
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function(url) {
      if (isUndefined(url)) {
        return this.$$url;
      }
      var match = PATH_MATCH.exec(url);
      if (match[1] || url === '') this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1] || url === '') this.search(match[3] || '');
      this.hash(match[5] || '');
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function(path) {
      path = path !== null ? path.toString() : '';
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function(search, paramValue) {
      switch (arguments.length) {
        case 0:
          return this.$$search;
        case 1:
          if (isString(search) || isNumber(search)) {
            search = search.toString();
            this.$$search = parseKeyValue(search);
          } else if (isObject(search)) {
            search = copy(search, {});
            forEach(search, function(value, key) {
              if (value == null) delete search[key];
            });
            this.$$search = search;
          } else {
            throw $locationMinErr('isrcharg',
              'The first argument of the `$location#search()` call must be a string or an object.');
          }
          break;
        default:
          if (isUndefined(paramValue) || paramValue === null) {
            delete this.$$search[search];
          } else {
            this.$$search[search] = paramValue;
          }
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', function(hash) {
      return hash !== null ? hash.toString() : '';
    }),
    replace: function() {
      this.$$replace = true;
      return this;
    }
  };
  forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
    Location.prototype = Object.create(locationPrototype);
    Location.prototype.state = function(state) {
      if (!arguments.length) {
        return this.$$state;
      }
      if (Location !== LocationHtml5Url || !this.$$html5) {
        throw $locationMinErr('nostate', 'History API state support is available only ' +
          'in HTML5 mode and only in browsers supporting HTML5 History API');
      }
      this.$$state = isUndefined(state) ? null : state;
      return this;
    };
  });

  function locationGetter(property) {
    return function() {
      return this[property];
    };
  }

  function locationGetterSetter(property, preprocess) {
    return function(value) {
      if (isUndefined(value)) {
        return this[property];
      }
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }

  function $LocationProvider() {
    var hashPrefix = '',
      html5Mode = {
        enabled: false,
        requireBase: true,
        rewriteLinks: true
      };
    this.hashPrefix = function(prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function(mode) {
      if (isBoolean(mode)) {
        html5Mode.enabled = mode;
        return this;
      } else if (isObject(mode)) {
        if (isBoolean(mode.enabled)) {
          html5Mode.enabled = mode.enabled;
        }
        if (isBoolean(mode.requireBase)) {
          html5Mode.requireBase = mode.requireBase;
        }
        if (isBoolean(mode.rewriteLinks)) {
          html5Mode.rewriteLinks = mode.rewriteLinks;
        }
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window',
      function($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location,
          LocationMode,
          baseHref = $browser.baseHref(),
          initialUrl = $browser.url(),
          appBase;
        if (html5Mode.enabled) {
          if (!baseHref && html5Mode.requireBase) {
            throw $locationMinErr('nobase',
              "$location in HTML5 mode requires a <base> tag to be present!");
          }
          appBase = serverBase(initialUrl) + (baseHref || '/');
          LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
        } else {
          appBase = stripHash(initialUrl);
          LocationMode = LocationHashbangUrl;
        }
        var appBaseNoFile = stripFile(appBase);
        $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;

        function setBrowserUrlWithFallback(url, replace, state) {
          var oldUrl = $location.url();
          var oldState = $location.$$state;
          try {
            $browser.url(url, replace, state);
            $location.$$state = $browser.state();
          } catch (e) {
            $location.url(oldUrl);
            $location.$$state = oldState;
            throw e;
          }
        }
        $rootElement.on('click', function(event) {
          if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
          var elm = jqLite(event.target);
          while (nodeName_(elm[0]) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
          }
          var absHref = elm.prop('href');
          var relHref = elm.attr('href') || elm.attr('xlink:href');
          if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
            absHref = urlResolve(absHref.animVal).href;
          }
          if (IGNORE_URI_REGEXP.test(absHref)) return;
          if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              event.preventDefault();
              if ($location.absUrl() != $browser.url()) {
                $rootScope.$apply();
                $window.angular['ff-684208-preventDefault'] = true;
              }
            }
          }
        });
        if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
          $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function(newUrl, newState) {
          if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
            $window.location.href = newUrl;
            return;
          }
          $rootScope.$evalAsync(function() {
            var oldUrl = $location.absUrl();
            var oldState = $location.$$state;
            var defaultPrevented;
            newUrl = trimEmptyHash(newUrl);
            $location.$$parse(newUrl);
            $location.$$state = newState;
            defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
              newState, oldState).defaultPrevented;
            if ($location.absUrl() !== newUrl) return;
            if (defaultPrevented) {
              $location.$$parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, false, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
          if (!$rootScope.$$phase) $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = trimEmptyHash($browser.url());
          var newUrl = trimEmptyHash($location.absUrl());
          var oldState = $browser.state();
          var currentReplace = $location.$$replace;
          var urlOrStateChanged = oldUrl !== newUrl ||
            ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
          if (initializing || urlOrStateChanged) {
            initializing = false;
            $rootScope.$evalAsync(function() {
              var newUrl = $location.absUrl();
              var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
                $location.$$state, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl) return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(newUrl, currentReplace,
                    oldState === $location.$$state ? null : $location.$$state);
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
          $location.$$replace = false;
        });
        return $location;

        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl,
            $location.$$state, oldState);
        }
      }
    ];
  }

  function $LogProvider() {
    var debug = true,
      self = this;
    this.debugEnabled = function(flag) {
      if (isDefined(flag)) {
        debug = flag;
        return this;
      } else {
        return debug;
      }
    };
    this.$get = ['$window', function($window) {
      return {
        log: consoleLog('log'),
        info: consoleLog('info'),
        warn: consoleLog('warn'),
        error: consoleLog('error'),
        debug: (function() {
          var fn = consoleLog('debug');
          return function() {
            if (debug) {
              fn.apply(self, arguments);
            }
          };
        }())
      };

      function formatError(arg) {
        if (arg instanceof Error) {
          if (arg.stack) {
            arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ?
              'Error: ' + arg.message + '\n' + arg.stack :
              arg.stack;
          } else if (arg.sourceURL) {
            arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
          }
        }
        return arg;
      }

      function consoleLog(type) {
        var console = $window.console || {},
          logFn = console[type] || console.log || noop,
          hasApply = false;
        try {
          hasApply = !!logFn.apply;
        } catch (e) {}
        if (hasApply) {
          return function() {
            var args = [];
            forEach(arguments, function(arg) {
              args.push(formatError(arg));
            });
            return logFn.apply(console, args);
          };
        }
        return function(arg1, arg2) {
          logFn(arg1, arg2 == null ? '' : arg2);
        };
      }
    }];
  }
  var $parseMinErr = minErr('$parse');

  function ensureSafeMemberName(name, fullExpression) {
    if (name === "__defineGetter__" || name === "__defineSetter__" ||
      name === "__lookupGetter__" || name === "__lookupSetter__" ||
      name === "__proto__") {
      throw $parseMinErr('isecfld',
        'Attempting to access a disallowed field in Angular expressions! ' +
        'Expression: {0}', fullExpression);
    }
    return name;
  }

  function getStringValue(name) {
    return name + '';
  }

  function ensureSafeObject(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj.window === obj) {
        throw $parseMinErr('isecwindow',
          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
        throw $parseMinErr('isecdom',
          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj === Object) {
        throw $parseMinErr('isecobj',
          'Referencing Object in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      }
    }
    return obj;
  }
  var CALL = Function.prototype.call;
  var APPLY = Function.prototype.apply;
  var BIND = Function.prototype.bind;

  function ensureSafeFunction(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (obj === CALL || obj === APPLY || obj === BIND) {
        throw $parseMinErr('isecff',
          'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      }
    }
  }

  function ensureSafeAssignContext(obj, fullExpression) {
    if (obj) {
      if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor ||
        obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
        throw $parseMinErr('isecaf',
          'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
      }
    }
  }
  var OPERATORS = createMap();
  forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
    OPERATORS[operator] = true;
  });
  var ESCAPE = {
    "n": "\n",
    "f": "\f",
    "r": "\r",
    "t": "\t",
    "v": "\v",
    "'": "'",
    '"': '"'
  };
  var Lexer = function(options) {
    this.options = options;
  };
  Lexer.prototype = {
    constructor: Lexer,
    lex: function(text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        if (ch === '"' || ch === "'") {
          this.readString(ch);
        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
          this.readNumber();
        } else if (this.isIdentifierStart(this.peekMultichar())) {
          this.readIdent();
        } else if (this.is(ch, '(){}[].,;:?')) {
          this.tokens.push({
            index: this.index,
            text: ch
          });
          this.index++;
        } else if (this.isWhitespace(ch)) {
          this.index++;
        } else {
          var ch2 = ch + this.peek();
          var ch3 = ch2 + this.peek(2);
          var op1 = OPERATORS[ch];
          var op2 = OPERATORS[ch2];
          var op3 = OPERATORS[ch3];
          if (op1 || op2 || op3) {
            var token = op3 ? ch3 : (op2 ? ch2 : ch);
            this.tokens.push({
              index: this.index,
              text: token,
              operator: true
            });
            this.index += token.length;
          } else {
            this.throwError('Unexpected next character ', this.index, this.index + 1);
          }
        }
      }
      return this.tokens;
    },
    is: function(ch, chars) {
      return chars.indexOf(ch) !== -1;
    },
    peek: function(i) {
      var num = i || 1;
      return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
    },
    isNumber: function(ch) {
      return ('0' <= ch && ch <= '9') && typeof ch === "string";
    },
    isWhitespace: function(ch) {
      return (ch === ' ' || ch === '\r' || ch === '\t' ||
        ch === '\n' || ch === '\v' || ch === '\u00A0');
    },
    isIdentifierStart: function(ch) {
      return this.options.isIdentifierStart ?
        this.options.isIdentifierStart(ch, this.codePointAt(ch)) :
        this.isValidIdentifierStart(ch);
    },
    isValidIdentifierStart: function(ch) {
      return ('a' <= ch && ch <= 'z' ||
        'A' <= ch && ch <= 'Z' ||
        '_' === ch || ch === '$');
    },
    isIdentifierContinue: function(ch) {
      return this.options.isIdentifierContinue ?
        this.options.isIdentifierContinue(ch, this.codePointAt(ch)) :
        this.isValidIdentifierContinue(ch);
    },
    isValidIdentifierContinue: function(ch, cp) {
      return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
    },
    codePointAt: function(ch) {
      if (ch.length === 1) return ch.charCodeAt(0);
      return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
    },
    peekMultichar: function() {
      var ch = this.text.charAt(this.index);
      var peek = this.peek();
      if (!peek) {
        return ch;
      }
      var cp1 = ch.charCodeAt(0);
      var cp2 = peek.charCodeAt(0);
      if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
        return ch + peek;
      }
      return ch;
    },
    isExpOperator: function(ch) {
      return (ch === '-' || ch === '+' || this.isNumber(ch));
    },
    throwError: function(error, start, end) {
      end = end || this.index;
      var colStr = (isDefined(start) ?
        's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' :
        ' ' + end);
      throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
        error, colStr, this.text);
    },
    readNumber: function() {
      var number = '';
      var start = this.index;
      while (this.index < this.text.length) {
        var ch = lowercase(this.text.charAt(this.index));
        if (ch == '.' || this.isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = this.peek();
          if (ch == 'e' && this.isExpOperator(peekCh)) {
            number += ch;
          } else if (this.isExpOperator(ch) &&
            peekCh && this.isNumber(peekCh) &&
            number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) == 'e') {
            this.throwError('Invalid exponent');
          } else {
            break;
          }
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: number,
        constant: true,
        value: Number(number)
      });
    },
    readIdent: function() {
      var start = this.index;
      this.index += this.peekMultichar().length;
      while (this.index < this.text.length) {
        var ch = this.peekMultichar();
        if (!this.isIdentifierContinue(ch)) {
          break;
        }
        this.index += ch.length;
      }
      this.tokens.push({
        index: start,
        text: this.text.slice(start, this.index),
        identifier: true
      });
    },
    readString: function(quote) {
      var start = this.index;
      this.index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        rawString += ch;
        if (escape) {
          if (ch === 'u') {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
              this.throwError('Invalid unicode escape [\\u' + hex + ']');
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            string = string + (rep || ch);
          }
          escape = false;
        } else if (ch === '\\') {
          escape = true;
        } else if (ch === quote) {
          this.index++;
          this.tokens.push({
            index: start,
            text: rawString,
            constant: true,
            value: string
          });
          return;
        } else {
          string += ch;
        }
        this.index++;
      }
      this.throwError('Unterminated quote', start);
    }
  };
  var AST = function(lexer, options) {
    this.lexer = lexer;
    this.options = options;
  };
  AST.Program = 'Program';
  AST.ExpressionStatement = 'ExpressionStatement';
  AST.AssignmentExpression = 'AssignmentExpression';
  AST.ConditionalExpression = 'ConditionalExpression';
  AST.LogicalExpression = 'LogicalExpression';
  AST.BinaryExpression = 'BinaryExpression';
  AST.UnaryExpression = 'UnaryExpression';
  AST.CallExpression = 'CallExpression';
  AST.MemberExpression = 'MemberExpression';
  AST.Identifier = 'Identifier';
  AST.Literal = 'Literal';
  AST.ArrayExpression = 'ArrayExpression';
  AST.Property = 'Property';
  AST.ObjectExpression = 'ObjectExpression';
  AST.ThisExpression = 'ThisExpression';
  AST.LocalsExpression = 'LocalsExpression';
  AST.NGValueParameter = 'NGValueParameter';
  AST.prototype = {
    ast: function(text) {
      this.text = text;
      this.tokens = this.lexer.lex(text);
      var value = this.program();
      if (this.tokens.length !== 0) {
        this.throwError('is an unexpected token', this.tokens[0]);
      }
      return value;
    },
    program: function() {
      var body = [];
      while (true) {
        if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
          body.push(this.expressionStatement());
        if (!this.expect(';')) {
          return {
            type: AST.Program,
            body: body
          };
        }
      }
    },
    expressionStatement: function() {
      return {
        type: AST.ExpressionStatement,
        expression: this.filterChain()
      };
    },
    filterChain: function() {
      var left = this.expression();
      var token;
      while ((token = this.expect('|'))) {
        left = this.filter(left);
      }
      return left;
    },
    expression: function() {
      return this.assignment();
    },
    assignment: function() {
      var result = this.ternary();
      if (this.expect('=')) {
        result = {
          type: AST.AssignmentExpression,
          left: result,
          right: this.assignment(),
          operator: '='
        };
      }
      return result;
    },
    ternary: function() {
      var test = this.logicalOR();
      var alternate;
      var consequent;
      if (this.expect('?')) {
        alternate = this.expression();
        if (this.consume(':')) {
          consequent = this.expression();
          return {
            type: AST.ConditionalExpression,
            test: test,
            alternate: alternate,
            consequent: consequent
          };
        }
      }
      return test;
    },
    logicalOR: function() {
      var left = this.logicalAND();
      while (this.expect('||')) {
        left = {
          type: AST.LogicalExpression,
          operator: '||',
          left: left,
          right: this.logicalAND()
        };
      }
      return left;
    },
    logicalAND: function() {
      var left = this.equality();
      while (this.expect('&&')) {
        left = {
          type: AST.LogicalExpression,
          operator: '&&',
          left: left,
          right: this.equality()
        };
      }
      return left;
    },
    equality: function() {
      var left = this.relational();
      var token;
      while ((token = this.expect('==', '!=', '===', '!=='))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.relational()
        };
      }
      return left;
    },
    relational: function() {
      var left = this.additive();
      var token;
      while ((token = this.expect('<', '>', '<=', '>='))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.additive()
        };
      }
      return left;
    },
    additive: function() {
      var left = this.multiplicative();
      var token;
      while ((token = this.expect('+', '-'))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.multiplicative()
        };
      }
      return left;
    },
    multiplicative: function() {
      var left = this.unary();
      var token;
      while ((token = this.expect('*', '/', '%'))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.unary()
        };
      }
      return left;
    },
    unary: function() {
      var token;
      if ((token = this.expect('+', '-', '!'))) {
        return {
          type: AST.UnaryExpression,
          operator: token.text,
          prefix: true,
          argument: this.unary()
        };
      } else {
        return this.primary();
      }
    },
    primary: function() {
      var primary;
      if (this.expect('(')) {
        primary = this.filterChain();
        this.consume(')');
      } else if (this.expect('[')) {
        primary = this.arrayDeclaration();
      } else if (this.expect('{')) {
        primary = this.object();
      } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
        primary = copy(this.selfReferential[this.consume().text]);
      } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
        primary = {
          type: AST.Literal,
          value: this.options.literals[this.consume().text]
        };
      } else if (this.peek().identifier) {
        primary = this.identifier();
      } else if (this.peek().constant) {
        primary = this.constant();
      } else {
        this.throwError('not a primary expression', this.peek());
      }
      var next;
      while ((next = this.expect('(', '[', '.'))) {
        if (next.text === '(') {
          primary = {
            type: AST.CallExpression,
            callee: primary,
            arguments: this.parseArguments()
          };
          this.consume(')');
        } else if (next.text === '[') {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.expression(),
            computed: true
          };
          this.consume(']');
        } else if (next.text === '.') {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.identifier(),
            computed: false
          };
        } else {
          this.throwError('IMPOSSIBLE');
        }
      }
      return primary;
    },
    filter: function(baseExpression) {
      var args = [baseExpression];
      var result = {
        type: AST.CallExpression,
        callee: this.identifier(),
        arguments: args,
        filter: true
      };
      while (this.expect(':')) {
        args.push(this.expression());
      }
      return result;
    },
    parseArguments: function() {
      var args = [];
      if (this.peekToken().text !== ')') {
        do {
          args.push(this.filterChain());
        } while (this.expect(','));
      }
      return args;
    },
    identifier: function() {
      var token = this.consume();
      if (!token.identifier) {
        this.throwError('is not a valid identifier', token);
      }
      return {
        type: AST.Identifier,
        name: token.text
      };
    },
    constant: function() {
      return {
        type: AST.Literal,
        value: this.consume().value
      };
    },
    arrayDeclaration: function() {
      var elements = [];
      if (this.peekToken().text !== ']') {
        do {
          if (this.peek(']')) {
            break;
          }
          elements.push(this.expression());
        } while (this.expect(','));
      }
      this.consume(']');
      return {
        type: AST.ArrayExpression,
        elements: elements
      };
    },
    object: function() {
      var properties = [],
        property;
      if (this.peekToken().text !== '}') {
        do {
          if (this.peek('}')) {
            break;
          }
          property = {
            type: AST.Property,
            kind: 'init'
          };
          if (this.peek().constant) {
            property.key = this.constant();
            property.computed = false;
            this.consume(':');
            property.value = this.expression();
          } else if (this.peek().identifier) {
            property.key = this.identifier();
            property.computed = false;
            if (this.peek(':')) {
              this.consume(':');
              property.value = this.expression();
            } else {
              property.value = property.key;
            }
          } else if (this.peek('[')) {
            this.consume('[');
            property.key = this.expression();
            this.consume(']');
            property.computed = true;
            this.consume(':');
            property.value = this.expression();
          } else {
            this.throwError("invalid key", this.peek());
          }
          properties.push(property);
        } while (this.expect(','));
      }
      this.consume('}');
      return {
        type: AST.ObjectExpression,
        properties: properties
      };
    },
    throwError: function(msg, token) {
      throw $parseMinErr('syntax',
        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
        token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
    },
    consume: function(e1) {
      if (this.tokens.length === 0) {
        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
      }
      var token = this.expect(e1);
      if (!token) {
        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
      }
      return token;
    },
    peekToken: function() {
      if (this.tokens.length === 0) {
        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
      }
      return this.tokens[0];
    },
    peek: function(e1, e2, e3, e4) {
      return this.peekAhead(0, e1, e2, e3, e4);
    },
    peekAhead: function(i, e1, e2, e3, e4) {
      if (this.tokens.length > i) {
        var token = this.tokens[i];
        var t = token.text;
        if (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 && !e2 && !e3 && !e4)) {
          return token;
        }
      }
      return false;
    },
    expect: function(e1, e2, e3, e4) {
      var token = this.peek(e1, e2, e3, e4);
      if (token) {
        this.tokens.shift();
        return token;
      }
      return false;
    },
    selfReferential: {
      'this': {
        type: AST.ThisExpression
      },
      '$locals': {
        type: AST.LocalsExpression
      }
    }
  };

  function ifDefined(v, d) {
    return typeof v !== 'undefined' ? v : d;
  }

  function plusFn(l, r) {
    if (typeof l === 'undefined') return r;
    if (typeof r === 'undefined') return l;
    return l + r;
  }

  function isStateless($filter, filterName) {
    var fn = $filter(filterName);
    return !fn.$stateful;
  }

  function findConstantAndWatchExpressions(ast, $filter) {
    var allConstants;
    var argsToWatch;
    switch (ast.type) {
      case AST.Program:
        allConstants = true;
        forEach(ast.body, function(expr) {
          findConstantAndWatchExpressions(expr.expression, $filter);
          allConstants = allConstants && expr.expression.constant;
        });
        ast.constant = allConstants;
        break;
      case AST.Literal:
        ast.constant = true;
        ast.toWatch = [];
        break;
      case AST.UnaryExpression:
        findConstantAndWatchExpressions(ast.argument, $filter);
        ast.constant = ast.argument.constant;
        ast.toWatch = ast.argument.toWatch;
        break;
      case AST.BinaryExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
        break;
      case AST.LogicalExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.ConditionalExpression:
        findConstantAndWatchExpressions(ast.test, $filter);
        findConstantAndWatchExpressions(ast.alternate, $filter);
        findConstantAndWatchExpressions(ast.consequent, $filter);
        ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.Identifier:
        ast.constant = false;
        ast.toWatch = [ast];
        break;
      case AST.MemberExpression:
        findConstantAndWatchExpressions(ast.object, $filter);
        if (ast.computed) {
          findConstantAndWatchExpressions(ast.property, $filter);
        }
        ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
        ast.toWatch = [ast];
        break;
      case AST.CallExpression:
        allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
        argsToWatch = [];
        forEach(ast.arguments, function(expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
        break;
      case AST.AssignmentExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = [ast];
        break;
      case AST.ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.elements, function(expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants && expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.properties, function(property) {
          findConstantAndWatchExpressions(property.value, $filter);
          allConstants = allConstants && property.value.constant && !property.computed;
          if (!property.value.constant) {
            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ThisExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
      case AST.LocalsExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    }
  }

  function getInputs(body) {
    if (body.length != 1) return;
    var lastExpression = body[0].expression;
    var candidate = lastExpression.toWatch;
    if (candidate.length !== 1) return candidate;
    return candidate[0] !== lastExpression ? candidate : undefined;
  }

  function isAssignable(ast) {
    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
  }

  function assignableAST(ast) {
    if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
      return {
        type: AST.AssignmentExpression,
        left: ast.body[0].expression,
        right: {
          type: AST.NGValueParameter
        },
        operator: '='
      };
    }
  }

  function isLiteral(ast) {
    return ast.body.length === 0 ||
      ast.body.length === 1 && (
        ast.body[0].expression.type === AST.Literal ||
        ast.body[0].expression.type === AST.ArrayExpression ||
        ast.body[0].expression.type === AST.ObjectExpression);
  }

  function isConstant(ast) {
    return ast.constant;
  }

  function ASTCompiler(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTCompiler.prototype = {
    compile: function(expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.state = {
        nextId: 0,
        filters: {},
        expensiveChecks: expensiveChecks,
        fn: {
          vars: [],
          body: [],
          own: {}
        },
        assign: {
          vars: [],
          body: [],
          own: {}
        },
        inputs: []
      };
      findConstantAndWatchExpressions(ast, self.$filter);
      var extra = '';
      var assignable;
      this.stage = 'assign';
      if ((assignable = assignableAST(ast))) {
        this.state.computing = 'assign';
        var result = this.nextId();
        this.recurse(assignable, result);
        this.return_(result);
        extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
      }
      var toWatch = getInputs(ast.body);
      self.stage = 'inputs';
      forEach(toWatch, function(watch, key) {
        var fnKey = 'fn' + key;
        self.state[fnKey] = {
          vars: [],
          body: [],
          own: {}
        };
        self.state.computing = fnKey;
        var intoId = self.nextId();
        self.recurse(watch, intoId);
        self.return_(intoId);
        self.state.inputs.push(fnKey);
        watch.watchId = key;
      });
      this.state.computing = 'fn';
      this.stage = 'main';
      this.recurse(ast);
      var fnString =
        '"' + this.USE + ' ' + this.STRICT + '";\n' +
        this.filterPrefix() +
        'var fn=' + this.generateFunction('fn', 's,l,a,i') +
        extra +
        this.watchFns() +
        'return fn;';
      var fn = (new Function('$filter',
        'ensureSafeMemberName',
        'ensureSafeObject',
        'ensureSafeFunction',
        'getStringValue',
        'ensureSafeAssignContext',
        'ifDefined',
        'plus',
        'text',
        fnString))(
        this.$filter,
        ensureSafeMemberName,
        ensureSafeObject,
        ensureSafeFunction,
        getStringValue,
        ensureSafeAssignContext,
        ifDefined,
        plusFn,
        expression);
      this.state = this.stage = undefined;
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    USE: 'use',
    STRICT: 'strict',
    watchFns: function() {
      var result = [];
      var fns = this.state.inputs;
      var self = this;
      forEach(fns, function(name) {
        result.push('var ' + name + '=' + self.generateFunction(name, 's'));
      });
      if (fns.length) {
        result.push('fn.inputs=[' + fns.join(',') + '];');
      }
      return result.join('');
    },
    generateFunction: function(name, params) {
      return 'function(' + params + '){' +
        this.varsPrefix(name) +
        this.body(name) +
        '};';
    },
    filterPrefix: function() {
      var parts = [];
      var self = this;
      forEach(this.state.filters, function(id, filter) {
        parts.push(id + '=$filter(' + self.escape(filter) + ')');
      });
      if (parts.length) return 'var ' + parts.join(',') + ';';
      return '';
    },
    varsPrefix: function(section) {
      return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
    },
    body: function(section) {
      return this.state[section].body.join('');
    },
    recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
      var left, right, self = this,
        args, expression, computed;
      recursionFn = recursionFn || noop;
      if (!skipWatchIdCheck && isDefined(ast.watchId)) {
        intoId = intoId || this.nextId();
        this.if_('i',
          this.lazyAssign(intoId, this.computedMember('i', ast.watchId)),
          this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
        );
        return;
      }
      switch (ast.type) {
        case AST.Program:
          forEach(ast.body, function(expression, pos) {
            self.recurse(expression.expression, undefined, undefined, function(expr) {
              right = expr;
            });
            if (pos !== ast.body.length - 1) {
              self.current().body.push(right, ';');
            } else {
              self.return_(right);
            }
          });
          break;
        case AST.Literal:
          expression = this.escape(ast.value);
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.UnaryExpression:
          this.recurse(ast.argument, undefined, undefined, function(expr) {
            right = expr;
          });
          expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.BinaryExpression:
          this.recurse(ast.left, undefined, undefined, function(expr) {
            left = expr;
          });
          this.recurse(ast.right, undefined, undefined, function(expr) {
            right = expr;
          });
          if (ast.operator === '+') {
            expression = this.plus(left, right);
          } else if (ast.operator === '-') {
            expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
          } else {
            expression = '(' + left + ')' + ast.operator + '(' + right + ')';
          }
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.LogicalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.left, intoId);
          self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
          recursionFn(intoId);
          break;
        case AST.ConditionalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.test, intoId);
          self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
          recursionFn(intoId);
          break;
        case AST.Identifier:
          intoId = intoId || this.nextId();
          if (nameId) {
            nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
            nameId.computed = false;
            nameId.name = ast.name;
          }
          ensureSafeMemberName(ast.name);
          self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)),
            function() {
              self.if_(self.stage === 'inputs' || 's', function() {
                if (create && create !== 1) {
                  self.if_(
                    self.not(self.nonComputedMember('s', ast.name)),
                    self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                }
                self.assign(intoId, self.nonComputedMember('s', ast.name));
              });
            }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name))
          );
          if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
            self.addEnsureSafeObject(intoId);
          }
          recursionFn(intoId);
          break;
        case AST.MemberExpression:
          left = nameId && (nameId.context = this.nextId()) || this.nextId();
          intoId = intoId || this.nextId();
          self.recurse(ast.object, left, undefined, function() {
            self.if_(self.notNull(left), function() {
              if (create && create !== 1) {
                self.addEnsureSafeAssignContext(left);
              }
              if (ast.computed) {
                right = self.nextId();
                self.recurse(ast.property, right);
                self.getStringValue(right);
                self.addEnsureSafeMemberName(right);
                if (create && create !== 1) {
                  self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                }
                expression = self.ensureSafeObject(self.computedMember(left, right));
                self.assign(intoId, expression);
                if (nameId) {
                  nameId.computed = true;
                  nameId.name = right;
                }
              } else {
                ensureSafeMemberName(ast.property.name);
                if (create && create !== 1) {
                  self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                }
                expression = self.nonComputedMember(left, ast.property.name);
                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                  expression = self.ensureSafeObject(expression);
                }
                self.assign(intoId, expression);
                if (nameId) {
                  nameId.computed = false;
                  nameId.name = ast.property.name;
                }
              }
            }, function() {
              self.assign(intoId, 'undefined');
            });
            recursionFn(intoId);
          }, !!create);
          break;
        case AST.CallExpression:
          intoId = intoId || this.nextId();
          if (ast.filter) {
            right = self.filter(ast.callee.name);
            args = [];
            forEach(ast.arguments, function(expr) {
              var argument = self.nextId();
              self.recurse(expr, argument);
              args.push(argument);
            });
            expression = right + '(' + args.join(',') + ')';
            self.assign(intoId, expression);
            recursionFn(intoId);
          } else {
            right = self.nextId();
            left = {};
            args = [];
            self.recurse(ast.callee, right, left, function() {
              self.if_(self.notNull(right), function() {
                self.addEnsureSafeFunction(right);
                forEach(ast.arguments, function(expr) {
                  self.recurse(expr, self.nextId(), undefined, function(argument) {
                    args.push(self.ensureSafeObject(argument));
                  });
                });
                if (left.name) {
                  if (!self.state.expensiveChecks) {
                    self.addEnsureSafeObject(left.context);
                  }
                  expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                } else {
                  expression = right + '(' + args.join(',') + ')';
                }
                expression = self.ensureSafeObject(expression);
                self.assign(intoId, expression);
              }, function() {
                self.assign(intoId, 'undefined');
              });
              recursionFn(intoId);
            });
          }
          break;
        case AST.AssignmentExpression:
          right = this.nextId();
          left = {};
          if (!isAssignable(ast.left)) {
            throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
          }
          this.recurse(ast.left, undefined, left, function() {
            self.if_(self.notNull(left.context), function() {
              self.recurse(ast.right, right);
              self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
              self.addEnsureSafeAssignContext(left.context);
              expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
              self.assign(intoId, expression);
              recursionFn(intoId || expression);
            });
          }, 1);
          break;
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function(expr) {
            self.recurse(expr, self.nextId(), undefined, function(argument) {
              args.push(argument);
            });
          });
          expression = '[' + args.join(',') + ']';
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.ObjectExpression:
          args = [];
          computed = false;
          forEach(ast.properties, function(property) {
            if (property.computed) {
              computed = true;
            }
          });
          if (computed) {
            intoId = intoId || this.nextId();
            this.assign(intoId, '{}');
            forEach(ast.properties, function(property) {
              if (property.computed) {
                left = self.nextId();
                self.recurse(property.key, left);
              } else {
                left = property.key.type === AST.Identifier ?
                  property.key.name :
                  ('' + property.key.value);
              }
              right = self.nextId();
              self.recurse(property.value, right);
              self.assign(self.member(intoId, left, property.computed), right);
            });
          } else {
            forEach(ast.properties, function(property) {
              self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                args.push(self.escape(
                    property.key.type === AST.Identifier ? property.key.name :
                    ('' + property.key.value)) +
                  ':' + expr);
              });
            });
            expression = '{' + args.join(',') + '}';
            this.assign(intoId, expression);
          }
          recursionFn(intoId || expression);
          break;
        case AST.ThisExpression:
          this.assign(intoId, 's');
          recursionFn('s');
          break;
        case AST.LocalsExpression:
          this.assign(intoId, 'l');
          recursionFn('l');
          break;
        case AST.NGValueParameter:
          this.assign(intoId, 'v');
          recursionFn('v');
          break;
      }
    },
    getHasOwnProperty: function(element, property) {
      var key = element + '.' + property;
      var own = this.current().own;
      if (!own.hasOwnProperty(key)) {
        own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
      }
      return own[key];
    },
    assign: function(id, value) {
      if (!id) return;
      this.current().body.push(id, '=', value, ';');
      return id;
    },
    filter: function(filterName) {
      if (!this.state.filters.hasOwnProperty(filterName)) {
        this.state.filters[filterName] = this.nextId(true);
      }
      return this.state.filters[filterName];
    },
    ifDefined: function(id, defaultValue) {
      return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
    },
    plus: function(left, right) {
      return 'plus(' + left + ',' + right + ')';
    },
    return_: function(id) {
      this.current().body.push('return ', id, ';');
    },
    if_: function(test, alternate, consequent) {
      if (test === true) {
        alternate();
      } else {
        var body = this.current().body;
        body.push('if(', test, '){');
        alternate();
        body.push('}');
        if (consequent) {
          body.push('else{');
          consequent();
          body.push('}');
        }
      }
    },
    not: function(expression) {
      return '!(' + expression + ')';
    },
    notNull: function(expression) {
      return expression + '!=null';
    },
    nonComputedMember: function(left, right) {
      var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
      var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
      if (SAFE_IDENTIFIER.test(right)) {
        return left + '.' + right;
      } else {
        return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
      }
    },
    computedMember: function(left, right) {
      return left + '[' + right + ']';
    },
    member: function(left, right, computed) {
      if (computed) return this.computedMember(left, right);
      return this.nonComputedMember(left, right);
    },
    addEnsureSafeObject: function(item) {
      this.current().body.push(this.ensureSafeObject(item), ';');
    },
    addEnsureSafeMemberName: function(item) {
      this.current().body.push(this.ensureSafeMemberName(item), ';');
    },
    addEnsureSafeFunction: function(item) {
      this.current().body.push(this.ensureSafeFunction(item), ';');
    },
    addEnsureSafeAssignContext: function(item) {
      this.current().body.push(this.ensureSafeAssignContext(item), ';');
    },
    ensureSafeObject: function(item) {
      return 'ensureSafeObject(' + item + ',text)';
    },
    ensureSafeMemberName: function(item) {
      return 'ensureSafeMemberName(' + item + ',text)';
    },
    ensureSafeFunction: function(item) {
      return 'ensureSafeFunction(' + item + ',text)';
    },
    getStringValue: function(item) {
      this.assign(item, 'getStringValue(' + item + ')');
    },
    ensureSafeAssignContext: function(item) {
      return 'ensureSafeAssignContext(' + item + ',text)';
    },
    lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
      var self = this;
      return function() {
        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
      };
    },
    lazyAssign: function(id, value) {
      var self = this;
      return function() {
        self.assign(id, value);
      };
    },
    stringEscapeRegex: /[^ a-zA-Z0-9]/g,
    stringEscapeFn: function(c) {
      return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
    },
    escape: function(value) {
      if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
      if (isNumber(value)) return value.toString();
      if (value === true) return 'true';
      if (value === false) return 'false';
      if (value === null) return 'null';
      if (typeof value === 'undefined') return 'undefined';
      throw $parseMinErr('esc', 'IMPOSSIBLE');
    },
    nextId: function(skip, init) {
      var id = 'v' + (this.state.nextId++);
      if (!skip) {
        this.current().vars.push(id + (init ? '=' + init : ''));
      }
      return id;
    },
    current: function() {
      return this.state[this.state.computing];
    }
  };

  function ASTInterpreter(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTInterpreter.prototype = {
    compile: function(expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.expression = expression;
      this.expensiveChecks = expensiveChecks;
      findConstantAndWatchExpressions(ast, self.$filter);
      var assignable;
      var assign;
      if ((assignable = assignableAST(ast))) {
        assign = this.recurse(assignable);
      }
      var toWatch = getInputs(ast.body);
      var inputs;
      if (toWatch) {
        inputs = [];
        forEach(toWatch, function(watch, key) {
          var input = self.recurse(watch);
          watch.input = input;
          inputs.push(input);
          watch.watchId = key;
        });
      }
      var expressions = [];
      forEach(ast.body, function(expression) {
        expressions.push(self.recurse(expression.expression));
      });
      var fn = ast.body.length === 0 ? noop :
        ast.body.length === 1 ? expressions[0] :
        function(scope, locals) {
          var lastValue;
          forEach(expressions, function(exp) {
            lastValue = exp(scope, locals);
          });
          return lastValue;
        };
      if (assign) {
        fn.assign = function(scope, value, locals) {
          return assign(scope, locals, value);
        };
      }
      if (inputs) {
        fn.inputs = inputs;
      }
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    recurse: function(ast, context, create) {
      var left, right, self = this,
        args, expression;
      if (ast.input) {
        return this.inputs(ast.input, ast.watchId);
      }
      switch (ast.type) {
        case AST.Literal:
          return this.value(ast.value, context);
        case AST.UnaryExpression:
          right = this.recurse(ast.argument);
          return this['unary' + ast.operator](right, context);
        case AST.BinaryExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this['binary' + ast.operator](left, right, context);
        case AST.LogicalExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this['binary' + ast.operator](left, right, context);
        case AST.ConditionalExpression:
          return this['ternary?:'](
            this.recurse(ast.test),
            this.recurse(ast.alternate),
            this.recurse(ast.consequent),
            context
          );
        case AST.Identifier:
          ensureSafeMemberName(ast.name, self.expression);
          return self.identifier(ast.name,
            self.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
            context, create, self.expression);
        case AST.MemberExpression:
          left = this.recurse(ast.object, false, !!create);
          if (!ast.computed) {
            ensureSafeMemberName(ast.property.name, self.expression);
            right = ast.property.name;
          }
          if (ast.computed) right = this.recurse(ast.property);
          return ast.computed ?
            this.computedMember(left, right, context, create, self.expression) :
            this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
        case AST.CallExpression:
          args = [];
          forEach(ast.arguments, function(expr) {
            args.push(self.recurse(expr));
          });
          if (ast.filter) right = this.$filter(ast.callee.name);
          if (!ast.filter) right = this.recurse(ast.callee, true);
          return ast.filter ?
            function(scope, locals, assign, inputs) {
              var values = [];
              for (var i = 0; i < args.length; ++i) {
                values.push(args[i](scope, locals, assign, inputs));
              }
              var value = right.apply(undefined, values, inputs);
              return context ? {
                context: undefined,
                name: undefined,
                value: value
              } : value;
            } :
            function(scope, locals, assign, inputs) {
              var rhs = right(scope, locals, assign, inputs);
              var value;
              if (rhs.value != null) {
                ensureSafeObject(rhs.context, self.expression);
                ensureSafeFunction(rhs.value, self.expression);
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                }
                value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
              }
              return context ? {
                value: value
              } : value;
            };
        case AST.AssignmentExpression:
          left = this.recurse(ast.left, true, 1);
          right = this.recurse(ast.right);
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            ensureSafeObject(lhs.value, self.expression);
            ensureSafeAssignContext(lhs.context);
            lhs.context[lhs.name] = rhs;
            return context ? {
              value: rhs
            } : rhs;
          };
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function(expr) {
            args.push(self.recurse(expr));
          });
          return function(scope, locals, assign, inputs) {
            var value = [];
            for (var i = 0; i < args.length; ++i) {
              value.push(args[i](scope, locals, assign, inputs));
            }
            return context ? {
              value: value
            } : value;
          };
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function(property) {
            if (property.computed) {
              args.push({
                key: self.recurse(property.key),
                computed: true,
                value: self.recurse(property.value)
              });
            } else {
              args.push({
                key: property.key.type === AST.Identifier ?
                  property.key.name :
                  ('' + property.key.value),
                computed: false,
                value: self.recurse(property.value)
              });
            }
          });
          return function(scope, locals, assign, inputs) {
            var value = {};
            for (var i = 0; i < args.length; ++i) {
              if (args[i].computed) {
                value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
              } else {
                value[args[i].key] = args[i].value(scope, locals, assign, inputs);
              }
            }
            return context ? {
              value: value
            } : value;
          };
        case AST.ThisExpression:
          return function(scope) {
            return context ? {
              value: scope
            } : scope;
          };
        case AST.LocalsExpression:
          return function(scope, locals) {
            return context ? {
              value: locals
            } : locals;
          };
        case AST.NGValueParameter:
          return function(scope, locals, assign) {
            return context ? {
              value: assign
            } : assign;
          };
      }
    },
    'unary+': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = +arg;
        } else {
          arg = 0;
        }
        return context ? {
          value: arg
        } : arg;
      };
    },
    'unary-': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = -arg;
        } else {
          arg = 0;
        }
        return context ? {
          value: arg
        } : arg;
      };
    },
    'unary!': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = !argument(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary+': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = plusFn(lhs, rhs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary-': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary*': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary/': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary%': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary===': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary!==': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary==': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary!=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary<': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary>': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary<=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary>=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&&': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary||': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'ternary?:': function(test, alternate, consequent, context) {
      return function(scope, locals, assign, inputs) {
        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    value: function(value, context) {
      return function() {
        return context ? {
          context: undefined,
          name: undefined,
          value: value
        } : value;
      };
    },
    identifier: function(name, expensiveChecks, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var base = locals && (name in locals) ? locals : scope;
        if (create && create !== 1 && base && !(base[name])) {
          base[name] = {};
        }
        var value = base ? base[name] : undefined;
        if (expensiveChecks) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: base,
            name: name,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    computedMember: function(left, right, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs;
        var value;
        if (lhs != null) {
          rhs = right(scope, locals, assign, inputs);
          rhs = getStringValue(rhs);
          ensureSafeMemberName(rhs, expression);
          if (create && create !== 1) {
            ensureSafeAssignContext(lhs);
            if (lhs && !(lhs[rhs])) {
              lhs[rhs] = {};
            }
          }
          value = lhs[rhs];
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: lhs,
            name: rhs,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        if (create && create !== 1) {
          ensureSafeAssignContext(lhs);
          if (lhs && !(lhs[right])) {
            lhs[right] = {};
          }
        }
        var value = lhs != null ? lhs[right] : undefined;
        if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: lhs,
            name: right,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    inputs: function(input, watchId) {
      return function(scope, value, locals, inputs) {
        if (inputs) return inputs[watchId];
        return input(scope, value, locals);
      };
    }
  };
  var Parser = function(lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
    this.ast = new AST(lexer, options);
    this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) :
      new ASTCompiler(this.ast, $filter);
  };
  Parser.prototype = {
    constructor: Parser,
    parse: function(text) {
      return this.astCompiler.compile(text, this.options.expensiveChecks);
    }
  };

  function isPossiblyDangerousMemberName(name) {
    return name == 'constructor';
  }
  var objectValueOf = Object.prototype.valueOf;

  function getValueOf(value) {
    return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
  }

  function $ParseProvider() {
    var cacheDefault = createMap();
    var cacheExpensive = createMap();
    var literals = {
      'true': true,
      'false': false,
      'null': null,
      'undefined': undefined
    };
    var identStart, identContinue;
    this.addLiteral = function(literalName, literalValue) {
      literals[literalName] = literalValue;
    };
    this.setIdentifierFns = function(identifierStart, identifierContinue) {
      identStart = identifierStart;
      identContinue = identifierContinue;
      return this;
    };
    this.$get = ['$filter', function($filter) {
      var noUnsafeEval = csp().noUnsafeEval;
      var $parseOptions = {
          csp: noUnsafeEval,
          expensiveChecks: false,
          literals: copy(literals),
          isIdentifierStart: isFunction(identStart) && identStart,
          isIdentifierContinue: isFunction(identContinue) && identContinue
        },
        $parseOptionsExpensive = {
          csp: noUnsafeEval,
          expensiveChecks: true,
          literals: copy(literals),
          isIdentifierStart: isFunction(identStart) && identStart,
          isIdentifierContinue: isFunction(identContinue) && identContinue
        };
      var runningChecksEnabled = false;
      $parse.$$runningExpensiveChecks = function() {
        return runningChecksEnabled;
      };
      return $parse;

      function $parse(exp, interceptorFn, expensiveChecks) {
        var parsedExpression, oneTime, cacheKey;
        expensiveChecks = expensiveChecks || runningChecksEnabled;
        switch (typeof exp) {
          case 'string':
            exp = exp.trim();
            cacheKey = exp;
            var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
            parsedExpression = cache[cacheKey];
            if (!parsedExpression) {
              if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                oneTime = true;
                exp = exp.substring(2);
              }
              var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
              var lexer = new Lexer(parseOptions);
              var parser = new Parser(lexer, $filter, parseOptions);
              parsedExpression = parser.parse(exp);
              if (parsedExpression.constant) {
                parsedExpression.$$watchDelegate = constantWatchDelegate;
              } else if (oneTime) {
                parsedExpression.$$watchDelegate = parsedExpression.literal ?
                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
              } else if (parsedExpression.inputs) {
                parsedExpression.$$watchDelegate = inputsWatchDelegate;
              }
              if (expensiveChecks) {
                parsedExpression = expensiveChecksInterceptor(parsedExpression);
              }
              cache[cacheKey] = parsedExpression;
            }
            return addInterceptor(parsedExpression, interceptorFn);
          case 'function':
            return addInterceptor(exp, interceptorFn);
          default:
            return addInterceptor(noop, interceptorFn);
        }
      }

      function expensiveChecksInterceptor(fn) {
        if (!fn) return fn;
        expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
        expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
        expensiveCheckFn.constant = fn.constant;
        expensiveCheckFn.literal = fn.literal;
        for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
          fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
        }
        expensiveCheckFn.inputs = fn.inputs;
        return expensiveCheckFn;

        function expensiveCheckFn(scope, locals, assign, inputs) {
          var expensiveCheckOldValue = runningChecksEnabled;
          runningChecksEnabled = true;
          try {
            return fn(scope, locals, assign, inputs);
          } finally {
            runningChecksEnabled = expensiveCheckOldValue;
          }
        }
      }

      function expressionInputDirtyCheck(newValue, oldValueOfValue) {
        if (newValue == null || oldValueOfValue == null) {
          return newValue === oldValueOfValue;
        }
        if (typeof newValue === 'object') {
          newValue = getValueOf(newValue);
          if (typeof newValue === 'object') {
            return false;
          }
        }
        return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
      }

      function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
        var inputExpressions = parsedExpression.inputs;
        var lastResult;
        if (inputExpressions.length === 1) {
          var oldInputValueOf = expressionInputDirtyCheck;
          inputExpressions = inputExpressions[0];
          return scope.$watch(function expressionInputWatch(scope) {
            var newInputValue = inputExpressions(scope);
            if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
              lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
              oldInputValueOf = newInputValue && getValueOf(newInputValue);
            }
            return lastResult;
          }, listener, objectEquality, prettyPrintExpression);
        }
        var oldInputValueOfValues = [];
        var oldInputValues = [];
        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
          oldInputValueOfValues[i] = expressionInputDirtyCheck;
          oldInputValues[i] = null;
        }
        return scope.$watch(function expressionInputsWatch(scope) {
          var changed = false;
          for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
            var newInputValue = inputExpressions[i](scope);
            if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
              oldInputValues[i] = newInputValue;
              oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
            }
          }
          if (changed) {
            lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
          }
          return lastResult;
        }, listener, objectEquality, prettyPrintExpression);
      }

      function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch, lastValue;
        return unwatch = scope.$watch(function oneTimeWatch(scope) {
          return parsedExpression(scope);
        }, function oneTimeListener(value, old, scope) {
          lastValue = value;
          if (isFunction(listener)) {
            listener.apply(this, arguments);
          }
          if (isDefined(value)) {
            scope.$$postDigest(function() {
              if (isDefined(lastValue)) {
                unwatch();
              }
            });
          }
        }, objectEquality);
      }

      function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch, lastValue;
        return unwatch = scope.$watch(function oneTimeWatch(scope) {
          return parsedExpression(scope);
        }, function oneTimeListener(value, old, scope) {
          lastValue = value;
          if (isFunction(listener)) {
            listener.call(this, value, old, scope);
          }
          if (isAllDefined(value)) {
            scope.$$postDigest(function() {
              if (isAllDefined(lastValue)) unwatch();
            });
          }
        }, objectEquality);

        function isAllDefined(value) {
          var allDefined = true;
          forEach(value, function(val) {
            if (!isDefined(val)) allDefined = false;
          });
          return allDefined;
        }
      }

      function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch;
        return unwatch = scope.$watch(function constantWatch(scope) {
          unwatch();
          return parsedExpression(scope);
        }, listener, objectEquality);
      }

      function addInterceptor(parsedExpression, interceptorFn) {
        if (!interceptorFn) return parsedExpression;
        var watchDelegate = parsedExpression.$$watchDelegate;
        var useInputs = false;
        var regularWatch =
          watchDelegate !== oneTimeLiteralWatchDelegate &&
          watchDelegate !== oneTimeWatchDelegate;
        var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
          var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
          return interceptorFn(value, scope, locals);
        } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
          var value = parsedExpression(scope, locals, assign, inputs);
          var result = interceptorFn(value, scope, locals);
          return isDefined(value) ? result : value;
        };
        if (parsedExpression.$$watchDelegate &&
          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
          fn.$$watchDelegate = parsedExpression.$$watchDelegate;
        } else if (!interceptorFn.$stateful) {
          fn.$$watchDelegate = inputsWatchDelegate;
          useInputs = !parsedExpression.inputs;
          fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
        }
        return fn;
      }
    }];
  }

  function $QProvider() {
    this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
      return qFactory(function(callback) {
        $rootScope.$evalAsync(callback);
      }, $exceptionHandler);
    }];
  }

  function $$QProvider() {
    this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
      return qFactory(function(callback) {
        $browser.defer(callback);
      }, $exceptionHandler);
    }];
  }

  function qFactory(nextTick, exceptionHandler) {
    var $qMinErr = minErr('$q', TypeError);
    var defer = function() {
      var d = new Deferred();
      d.resolve = simpleBind(d, d.resolve);
      d.reject = simpleBind(d, d.reject);
      d.notify = simpleBind(d, d.notify);
      return d;
    };

    function Promise() {
      this.$$state = {
        status: 0
      };
    }
    extend(Promise.prototype, {
      then: function(onFulfilled, onRejected, progressBack) {
        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
          return this;
        }
        var result = new Deferred();
        this.$$state.pending = this.$$state.pending || [];
        this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
        if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
        return result.promise;
      },
      "catch": function(callback) {
        return this.then(null, callback);
      },
      "finally": function(callback, progressBack) {
        return this.then(function(value) {
          return handleCallback(value, true, callback);
        }, function(error) {
          return handleCallback(error, false, callback);
        }, progressBack);
      }
    });

    function simpleBind(context, fn) {
      return function(value) {
        fn.call(context, value);
      };
    }

    function processQueue(state) {
      var fn, deferred, pending;
      pending = state.pending;
      state.processScheduled = false;
      state.pending = undefined;
      for (var i = 0, ii = pending.length; i < ii; ++i) {
        deferred = pending[i][0];
        fn = pending[i][state.status];
        try {
          if (isFunction(fn)) {
            deferred.resolve(fn(state.value));
          } else if (state.status === 1) {
            deferred.resolve(state.value);
          } else {
            deferred.reject(state.value);
          }
        } catch (e) {
          deferred.reject(e);
          exceptionHandler(e);
        }
      }
    }

    function scheduleProcessQueue(state) {
      if (state.processScheduled || !state.pending) return;
      state.processScheduled = true;
      nextTick(function() {
        processQueue(state);
      });
    }

    function Deferred() {
      this.promise = new Promise();
    }
    extend(Deferred.prototype, {
      resolve: function(val) {
        if (this.promise.$$state.status) return;
        if (val === this.promise) {
          this.$$reject($qMinErr(
            'qcycle',
            "Expected promise to be resolved with value other than itself '{0}'",
            val));
        } else {
          this.$$resolve(val);
        }
      },
      $$resolve: function(val) {
        var then;
        var that = this;
        var done = false;
        try {
          if ((isObject(val) || isFunction(val))) then = val && val.then;
          if (isFunction(then)) {
            this.promise.$$state.status = -1;
            then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
          } else {
            this.promise.$$state.value = val;
            this.promise.$$state.status = 1;
            scheduleProcessQueue(this.promise.$$state);
          }
        } catch (e) {
          rejectPromise(e);
          exceptionHandler(e);
        }

        function resolvePromise(val) {
          if (done) return;
          done = true;
          that.$$resolve(val);
        }

        function rejectPromise(val) {
          if (done) return;
          done = true;
          that.$$reject(val);
        }
      },
      reject: function(reason) {
        if (this.promise.$$state.status) return;
        this.$$reject(reason);
      },
      $$reject: function(reason) {
        this.promise.$$state.value = reason;
        this.promise.$$state.status = 2;
        scheduleProcessQueue(this.promise.$$state);
      },
      notify: function(progress) {
        var callbacks = this.promise.$$state.pending;
        if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
          nextTick(function() {
            var callback, result;
            for (var i = 0, ii = callbacks.length; i < ii; i++) {
              result = callbacks[i][0];
              callback = callbacks[i][3];
              try {
                result.notify(isFunction(callback) ? callback(progress) : progress);
              } catch (e) {
                exceptionHandler(e);
              }
            }
          });
        }
      }
    });
    var reject = function(reason) {
      var result = new Deferred();
      result.reject(reason);
      return result.promise;
    };
    var makePromise = function makePromise(value, resolved) {
      var result = new Deferred();
      if (resolved) {
        result.resolve(value);
      } else {
        result.reject(value);
      }
      return result.promise;
    };
    var handleCallback = function handleCallback(value, isResolved, callback) {
      var callbackOutput = null;
      try {
        if (isFunction(callback)) callbackOutput = callback();
      } catch (e) {
        return makePromise(e, false);
      }
      if (isPromiseLike(callbackOutput)) {
        return callbackOutput.then(function() {
          return makePromise(value, isResolved);
        }, function(error) {
          return makePromise(error, false);
        });
      } else {
        return makePromise(value, isResolved);
      }
    };
    var when = function(value, callback, errback, progressBack) {
      var result = new Deferred();
      result.resolve(value);
      return result.promise.then(callback, errback, progressBack);
    };
    var resolve = when;

    function all(promises) {
      var deferred = new Deferred(),
        counter = 0,
        results = isArray(promises) ? [] : {};
      forEach(promises, function(promise, key) {
        counter++;
        when(promise).then(function(value) {
          if (results.hasOwnProperty(key)) return;
          results[key] = value;
          if (!(--counter)) deferred.resolve(results);
        }, function(reason) {
          if (results.hasOwnProperty(key)) return;
          deferred.reject(reason);
        });
      });
      if (counter === 0) {
        deferred.resolve(results);
      }
      return deferred.promise;
    }

    function race(promises) {
      var deferred = defer();
      forEach(promises, function(promise) {
        when(promise).then(deferred.resolve, deferred.reject);
      });
      return deferred.promise;
    }
    var $Q = function Q(resolver) {
      if (!isFunction(resolver)) {
        throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
      }
      var deferred = new Deferred();

      function resolveFn(value) {
        deferred.resolve(value);
      }

      function rejectFn(reason) {
        deferred.reject(reason);
      }
      resolver(resolveFn, rejectFn);
      return deferred.promise;
    };
    $Q.prototype = Promise.prototype;
    $Q.defer = defer;
    $Q.reject = reject;
    $Q.when = when;
    $Q.resolve = resolve;
    $Q.all = all;
    $Q.race = race;
    return $Q;
  }

  function $$RAFProvider() {
    this.$get = ['$window', '$timeout', function($window, $timeout) {
      var requestAnimationFrame = $window.requestAnimationFrame ||
        $window.webkitRequestAnimationFrame;
      var cancelAnimationFrame = $window.cancelAnimationFrame ||
        $window.webkitCancelAnimationFrame ||
        $window.webkitCancelRequestAnimationFrame;
      var rafSupported = !!requestAnimationFrame;
      var raf = rafSupported ?
        function(fn) {
          var id = requestAnimationFrame(fn);
          return function() {
            cancelAnimationFrame(id);
          };
        } :
        function(fn) {
          var timer = $timeout(fn, 16.66, false);
          return function() {
            $timeout.cancel(timer);
          };
        };
      raf.supported = rafSupported;
      return raf;
    }];
  }

  function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr('$rootScope');
    var lastDirtyWatch = null;
    var applyAsyncId = null;
    this.digestTtl = function(value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };

    function createChildScopeClass(parent) {
      function ChildScope() {
        this.$$watchers = this.$$nextSibling =
          this.$$childHead = this.$$childTail = null;
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$watchersCount = 0;
        this.$id = nextUid();
        this.$$ChildScope = null;
      }
      ChildScope.prototype = parent;
      return ChildScope;
    }
    this.$get = ['$exceptionHandler', '$parse', '$browser',
      function($exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
          $event.currentScope.$$destroyed = true;
        }

        function cleanUpScope($scope) {
          if (msie === 9) {
            $scope.$$childHead && cleanUpScope($scope.$$childHead);
            $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
          }
          $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead =
            $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
        }

        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers =
            this.$$nextSibling = this.$$prevSibling =
            this.$$childHead = this.$$childTail = null;
          this.$root = this;
          this.$$destroyed = false;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$$isolateBindings = null;
        }
        Scope.prototype = {
          constructor: Scope,
          $new: function(isolate, parent) {
            var child;
            parent = parent || this;
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              if (!this.$$ChildScope) {
                this.$$ChildScope = createChildScopeClass(this);
              }
              child = new this.$$ChildScope();
            }
            child.$parent = parent;
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = child;
              parent.$$childTail = child;
            } else {
              parent.$$childHead = parent.$$childTail = child;
            }
            if (isolate || parent != this) child.$on('$destroy', destroyChildScope);
            return child;
          },
          $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
            var get = $parse(watchExp);
            if (get.$$watchDelegate) {
              return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
            }
            var scope = this,
              array = scope.$$watchers,
              watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: prettyPrintExpression || watchExp,
                eq: !!objectEquality
              };
            lastDirtyWatch = null;
            if (!isFunction(listener)) {
              watcher.fn = noop;
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            incrementWatchersCount(this, 1);
            return function deregisterWatch() {
              if (arrayRemove(array, watcher) >= 0) {
                incrementWatchersCount(scope, -1);
              }
              lastDirtyWatch = null;
            };
          },
          $watchGroup: function(watchExpressions, listener) {
            var oldValues = new Array(watchExpressions.length);
            var newValues = new Array(watchExpressions.length);
            var deregisterFns = [];
            var self = this;
            var changeReactionScheduled = false;
            var firstRun = true;
            if (!watchExpressions.length) {
              var shouldCall = true;
              self.$evalAsync(function() {
                if (shouldCall) listener(newValues, newValues, self);
              });
              return function deregisterWatchGroup() {
                shouldCall = false;
              };
            }
            if (watchExpressions.length === 1) {
              return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                newValues[0] = value;
                oldValues[0] = oldValue;
                listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
              });
            }
            forEach(watchExpressions, function(expr, i) {
              var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                newValues[i] = value;
                oldValues[i] = oldValue;
                if (!changeReactionScheduled) {
                  changeReactionScheduled = true;
                  self.$evalAsync(watchGroupAction);
                }
              });
              deregisterFns.push(unwatchFn);
            });

            function watchGroupAction() {
              changeReactionScheduled = false;
              if (firstRun) {
                firstRun = false;
                listener(newValues, newValues, self);
              } else {
                listener(newValues, oldValues, self);
              }
            }
            return function deregisterWatchGroup() {
              while (deregisterFns.length) {
                deregisterFns.shift()();
              }
            };
          },
          $watchCollection: function(obj, listener) {
            $watchCollectionInterceptor.$stateful = true;
            var self = this;
            var newValue;
            var oldValue;
            var veryOldValue;
            var trackVeryOldValue = (listener.length > 1);
            var changeDetected = 0;
            var changeDetector = $parse(obj, $watchCollectionInterceptor);
            var internalArray = [];
            var internalObject = {};
            var initRun = true;
            var oldLength = 0;

            function $watchCollectionInterceptor(_value) {
              newValue = _value;
              var newLength, key, bothNaN, newItem, oldItem;
              if (isUndefined(newValue)) return;
              if (!isObject(newValue)) {
                if (oldValue !== newValue) {
                  oldValue = newValue;
                  changeDetected++;
                }
              } else if (isArrayLike(newValue)) {
                if (oldValue !== internalArray) {
                  oldValue = internalArray;
                  oldLength = oldValue.length = 0;
                  changeDetected++;
                }
                newLength = newValue.length;
                if (oldLength !== newLength) {
                  changeDetected++;
                  oldValue.length = oldLength = newLength;
                }
                for (var i = 0; i < newLength; i++) {
                  oldItem = oldValue[i];
                  newItem = newValue[i];
                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                  if (!bothNaN && (oldItem !== newItem)) {
                    changeDetected++;
                    oldValue[i] = newItem;
                  }
                }
              } else {
                if (oldValue !== internalObject) {
                  oldValue = internalObject = {};
                  oldLength = 0;
                  changeDetected++;
                }
                newLength = 0;
                for (key in newValue) {
                  if (hasOwnProperty.call(newValue, key)) {
                    newLength++;
                    newItem = newValue[key];
                    oldItem = oldValue[key];
                    if (key in oldValue) {
                      bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                      if (!bothNaN && (oldItem !== newItem)) {
                        changeDetected++;
                        oldValue[key] = newItem;
                      }
                    } else {
                      oldLength++;
                      oldValue[key] = newItem;
                      changeDetected++;
                    }
                  }
                }
                if (oldLength > newLength) {
                  changeDetected++;
                  for (key in oldValue) {
                    if (!hasOwnProperty.call(newValue, key)) {
                      oldLength--;
                      delete oldValue[key];
                    }
                  }
                }
              }
              return changeDetected;
            }

            function $watchCollectionAction() {
              if (initRun) {
                initRun = false;
                listener(newValue, newValue, self);
              } else {
                listener(newValue, veryOldValue, self);
              }
              if (trackVeryOldValue) {
                if (!isObject(newValue)) {
                  veryOldValue = newValue;
                } else if (isArrayLike(newValue)) {
                  veryOldValue = new Array(newValue.length);
                  for (var i = 0; i < newValue.length; i++) {
                    veryOldValue[i] = newValue[i];
                  }
                } else {
                  veryOldValue = {};
                  for (var key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      veryOldValue[key] = newValue[key];
                    }
                  }
                }
              }
            }
            return this.$watch(changeDetector, $watchCollectionAction);
          },
          $digest: function() {
            var watch, value, last, fn, get,
              watchers,
              length,
              dirty, ttl = TTL,
              next, current, target = this,
              watchLog = [],
              logIdx, asyncTask;
            beginPhase('$digest');
            $browser.$$checkUrlChange();
            if (this === $rootScope && applyAsyncId !== null) {
              $browser.defer.cancel(applyAsyncId);
              flushApplyAsync();
            }
            lastDirtyWatch = null;
            do {
              dirty = false;
              current = target;
              for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                try {
                  asyncTask = asyncQueue[asyncQueuePosition];
                  asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                } catch (e) {
                  $exceptionHandler(e);
                }
                lastDirtyWatch = null;
              }
              asyncQueue.length = 0;
              traverseScopesLoop:
                do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) &&
                            !(watch.eq ?
                              equals(value, last) :
                              (typeof value === 'number' && typeof last === 'number' &&
                                isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx]) watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) ||
                      (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
              if ((dirty || asyncQueue.length) && !(ttl--)) {
                clearPhase();
                throw $rootScopeMinErr('infdig',
                  '{0} $digest() iterations reached. Aborting!\n' +
                  'Watchers fired in the last 5 iterations: {1}',
                  TTL, watchLog);
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
            while (postDigestQueuePosition < postDigestQueue.length) {
              try {
                postDigestQueue[postDigestQueuePosition++]();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            postDigestQueue.length = postDigestQueuePosition = 0;
          },
          $destroy: function() {
            if (this.$$destroyed) return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (this === $rootScope) {
              $browser.$$applicationDestroyed();
            }
            incrementWatchersCount(this, -this.$$watchersCount);
            for (var eventName in this.$$listenerCount) {
              decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
            }
            if (parent && parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
            if (parent && parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
            this.$on = this.$watch = this.$watchGroup = function() {
              return noop;
            };
            this.$$listeners = {};
            this.$$nextSibling = null;
            cleanUpScope(this);
          },
          $eval: function(expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function(expr, locals) {
            if (!$rootScope.$$phase && !asyncQueue.length) {
              $browser.defer(function() {
                if (asyncQueue.length) {
                  $rootScope.$digest();
                }
              });
            }
            asyncQueue.push({
              scope: this,
              expression: $parse(expr),
              locals: locals
            });
          },
          $$postDigest: function(fn) {
            postDigestQueue.push(fn);
          },
          $apply: function(expr) {
            try {
              beginPhase('$apply');
              try {
                return this.$eval(expr);
              } finally {
                clearPhase();
              }
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $applyAsync: function(expr) {
            var scope = this;
            expr && applyAsyncQueue.push($applyAsyncExpression);
            expr = $parse(expr);
            scheduleApplyAsync();

            function $applyAsyncExpression() {
              scope.$eval(expr);
            }
          },
          $on: function(name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            var current = this;
            do {
              if (!current.$$listenerCount[name]) {
                current.$$listenerCount[name] = 0;
              }
              current.$$listenerCount[name]++;
            } while ((current = current.$parent));
            var self = this;
            return function() {
              var indexOfListener = namedListeners.indexOf(listener);
              if (indexOfListener !== -1) {
                namedListeners[indexOfListener] = null;
                decrementListenerCount(self, 1, name);
              }
            };
          },
          $emit: function(name, args) {
            var empty = [],
              namedListeners,
              scope = this,
              stopPropagation = false,
              event = {
                name: name,
                targetScope: scope,
                stopPropagation: function() {
                  stopPropagation = true;
                },
                preventDefault: function() {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              },
              listenerArgs = concat([event], arguments, 1),
              i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (stopPropagation) {
                event.currentScope = null;
                return event;
              }
              scope = scope.$parent;
            } while (scope);
            event.currentScope = null;
            return event;
          },
          $broadcast: function(name, args) {
            var target = this,
              current = target,
              next = target,
              event = {
                name: name,
                targetScope: target,
                preventDefault: function() {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              };
            if (!target.$$listenerCount[name]) return event;
            var listenerArgs = concat([event], arguments, 1),
              listeners, i, length;
            while ((current = next)) {
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
                  (current !== target && current.$$nextSibling)))) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            }
            event.currentScope = null;
            return event;
          }
        };
        var $rootScope = new Scope();
        var asyncQueue = $rootScope.$$asyncQueue = [];
        var postDigestQueue = $rootScope.$$postDigestQueue = [];
        var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
        var postDigestQueuePosition = 0;
        return $rootScope;

        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
          }
          $rootScope.$$phase = phase;
        }

        function clearPhase() {
          $rootScope.$$phase = null;
        }

        function incrementWatchersCount(current, count) {
          do {
            current.$$watchersCount += count;
          } while ((current = current.$parent));
        }

        function decrementListenerCount(current, count, name) {
          do {
            current.$$listenerCount[name] -= count;
            if (current.$$listenerCount[name] === 0) {
              delete current.$$listenerCount[name];
            }
          } while ((current = current.$parent));
        }

        function initWatchVal() {}

        function flushApplyAsync() {
          while (applyAsyncQueue.length) {
            try {
              applyAsyncQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          applyAsyncId = null;
        }

        function scheduleApplyAsync() {
          if (applyAsyncId === null) {
            applyAsyncId = $browser.defer(function() {
              $rootScope.$apply(flushApplyAsync);
            });
          }
        }
      }
    ];
  }

  function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
      imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
      }
      return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
      }
      return imgSrcSanitizationWhitelist;
    };
    this.$get = function() {
      return function sanitizeUri(uri, isImage) {
        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
        var normalizedVal;
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== '' && !normalizedVal.match(regex)) {
          return 'unsafe:' + normalizedVal;
        }
        return uri;
      };
    };
  }
  var $sceMinErr = minErr('$sce');
  var SCE_CONTEXTS = {
    HTML: 'html',
    CSS: 'css',
    URL: 'url',
    RESOURCE_URL: 'resourceUrl',
    JS: 'js'
  };

  function adjustMatcher(matcher) {
    if (matcher === 'self') {
      return matcher;
    } else if (isString(matcher)) {
      if (matcher.indexOf('***') > -1) {
        throw $sceMinErr('iwcard',
          'Illegal sequence *** in string matcher.  String: {0}', matcher);
      }
      matcher = escapeForRegexp(matcher).
      replace('\\*\\*', '.*').
      replace('\\*', '[^:/.?&;]*');
      return new RegExp('^' + matcher + '$');
    } else if (isRegExp(matcher)) {
      return new RegExp('^' + matcher.source + '$');
    } else {
      throw $sceMinErr('imatcher',
        'Matchers may only be "self", string patterns or RegExp objects');
    }
  }

  function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
      forEach(matchers, function(matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
      });
    }
    return adjustedMatchers;
  }

  function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = ['self'],
      resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function(value) {
      if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
      }
      return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function(value) {
      if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
      }
      return resourceUrlBlacklist;
    };
    this.$get = ['$injector', function($injector) {
      var htmlSanitizer = function htmlSanitizer(html) {
        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
      };
      if ($injector.has('$sanitize')) {
        htmlSanitizer = $injector.get('$sanitize');
      }

      function matchUrl(matcher, parsedUrl) {
        if (matcher === 'self') {
          return urlIsSameOrigin(parsedUrl);
        } else {
          return !!matcher.exec(parsedUrl.href);
        }
      }

      function isResourceUrlAllowedByPolicy(url) {
        var parsedUrl = urlResolve(url.toString());
        var i, n, allowed = false;
        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
          if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
            allowed = true;
            break;
          }
        }
        if (allowed) {
          for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
            if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
              allowed = false;
              break;
            }
          }
        }
        return allowed;
      }

      function generateHolderType(Base) {
        var holderType = function TrustedValueHolderType(trustedValue) {
          this.$$unwrapTrustedValue = function() {
            return trustedValue;
          };
        };
        if (Base) {
          holderType.prototype = new Base();
        }
        holderType.prototype.valueOf = function sceValueOf() {
          return this.$$unwrapTrustedValue();
        };
        holderType.prototype.toString = function sceToString() {
          return this.$$unwrapTrustedValue().toString();
        };
        return holderType;
      }
      var trustedValueHolderBase = generateHolderType(),
        byType = {};
      byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);

      function trustAs(type, trustedValue) {
        var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
        if (!Constructor) {
          throw $sceMinErr('icontext',
            'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
            type, trustedValue);
        }
        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
          return trustedValue;
        }
        if (typeof trustedValue !== 'string') {
          throw $sceMinErr('itype',
            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
            type);
        }
        return new Constructor(trustedValue);
      }

      function valueOf(maybeTrusted) {
        if (maybeTrusted instanceof trustedValueHolderBase) {
          return maybeTrusted.$$unwrapTrustedValue();
        } else {
          return maybeTrusted;
        }
      }

      function getTrusted(type, maybeTrusted) {
        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
          return maybeTrusted;
        }
        var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
        if (constructor && maybeTrusted instanceof constructor) {
          return maybeTrusted.$$unwrapTrustedValue();
        }
        if (type === SCE_CONTEXTS.RESOURCE_URL) {
          if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
            return maybeTrusted;
          } else {
            throw $sceMinErr('insecurl',
              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
              maybeTrusted.toString());
          }
        } else if (type === SCE_CONTEXTS.HTML) {
          return htmlSanitizer(maybeTrusted);
        }
        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
      }
      return {
        trustAs: trustAs,
        getTrusted: getTrusted,
        valueOf: valueOf
      };
    }];
  }

  function $SceProvider() {
    var enabled = true;
    this.enabled = function(value) {
      if (arguments.length) {
        enabled = !!value;
      }
      return enabled;
    };
    this.$get = ['$parse', '$sceDelegate', function(
      $parse, $sceDelegate) {
      if (enabled && msie < 8) {
        throw $sceMinErr('iequirks',
          'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' +
          'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
          'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
      }
      var sce = shallowCopy(SCE_CONTEXTS);
      sce.isEnabled = function() {
        return enabled;
      };
      sce.trustAs = $sceDelegate.trustAs;
      sce.getTrusted = $sceDelegate.getTrusted;
      sce.valueOf = $sceDelegate.valueOf;
      if (!enabled) {
        sce.trustAs = sce.getTrusted = function(type, value) {
          return value;
        };
        sce.valueOf = identity;
      }
      sce.parseAs = function sceParseAs(type, expr) {
        var parsed = $parse(expr);
        if (parsed.literal && parsed.constant) {
          return parsed;
        } else {
          return $parse(expr, function(value) {
            return sce.getTrusted(type, value);
          });
        }
      };
      var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;
      forEach(SCE_CONTEXTS, function(enumValue, name) {
        var lName = lowercase(name);
        sce[camelCase("parse_as_" + lName)] = function(expr) {
          return parse(enumValue, expr);
        };
        sce[camelCase("get_trusted_" + lName)] = function(value) {
          return getTrusted(enumValue, value);
        };
        sce[camelCase("trust_as_" + lName)] = function(value) {
          return trustAs(enumValue, value);
        };
      });
      return sce;
    }];
  }

  function $SnifferProvider() {
    this.$get = ['$window', '$document', function($window, $document) {
      var eventSupport = {},
        isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
        hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
        android =
        toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
        document = $document[0] || {},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = false,
        animations = false,
        match;
      if (bodyStyle) {
        for (var prop in bodyStyle) {
          if (match = vendorRegex.exec(prop)) {
            vendorPrefix = match[0];
            vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
            break;
          }
        }
        if (!vendorPrefix) {
          vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
        }
        transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
        animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
        if (android && (!transitions || !animations)) {
          transitions = isString(bodyStyle.webkitTransition);
          animations = isString(bodyStyle.webkitAnimation);
        }
      }
      return {
        history: !!(hasHistoryPushState && !(android < 4) && !boxee),
        hasEvent: function(event) {
          if (event === 'input' && msie <= 11) return false;
          if (isUndefined(eventSupport[event])) {
            var divElm = document.createElement('div');
            eventSupport[event] = 'on' + event in divElm;
          }
          return eventSupport[event];
        },
        csp: csp(),
        vendorPrefix: vendorPrefix,
        transitions: transitions,
        animations: animations,
        android: android
      };
    }];
  }
  var $templateRequestMinErr = minErr('$compile');

  function $TemplateRequestProvider() {
    var httpOptions;
    this.httpOptions = function(val) {
      if (val) {
        httpOptions = val;
        return this;
      }
      return httpOptions;
    };
    this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
      function handleRequestFn(tpl, ignoreRequestError) {
        handleRequestFn.totalPendingRequests++;
        if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
          tpl = $sce.getTrustedResourceUrl(tpl);
        }
        var transformResponse = $http.defaults && $http.defaults.transformResponse;
        if (isArray(transformResponse)) {
          transformResponse = transformResponse.filter(function(transformer) {
            return transformer !== defaultHttpResponseTransform;
          });
        } else if (transformResponse === defaultHttpResponseTransform) {
          transformResponse = null;
        }
        return $http.get(tpl, extend({
            cache: $templateCache,
            transformResponse: transformResponse
          }, httpOptions))['finally'](function() {
            handleRequestFn.totalPendingRequests--;
          })
          .then(function(response) {
            $templateCache.put(tpl, response.data);
            return response.data;
          }, handleError);

        function handleError(resp) {
          if (!ignoreRequestError) {
            throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})',
              tpl, resp.status, resp.statusText);
          }
          return $q.reject(resp);
        }
      }
      handleRequestFn.totalPendingRequests = 0;
      return handleRequestFn;
    }];
  }

  function $$TestabilityProvider() {
    this.$get = ['$rootScope', '$browser', '$location',
      function($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function(element, expression, opt_exactMatch) {
          var bindings = element.getElementsByClassName('ng-binding');
          var matches = [];
          forEach(bindings, function(binding) {
            var dataBinding = angular.element(binding).data('$binding');
            if (dataBinding) {
              forEach(dataBinding, function(bindingName) {
                if (opt_exactMatch) {
                  var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                  if (matcher.test(bindingName)) {
                    matches.push(binding);
                  }
                } else {
                  if (bindingName.indexOf(expression) != -1) {
                    matches.push(binding);
                  }
                }
              });
            }
          });
          return matches;
        };
        testability.findModels = function(element, expression, opt_exactMatch) {
          var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
          for (var p = 0; p < prefixes.length; ++p) {
            var attributeEquals = opt_exactMatch ? '=' : '*=';
            var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
            var elements = element.querySelectorAll(selector);
            if (elements.length) {
              return elements;
            }
          }
        };
        testability.getLocation = function() {
          return $location.url();
        };
        testability.setLocation = function(url) {
          if (url !== $location.url()) {
            $location.url(url);
            $rootScope.$digest();
          }
        };
        testability.whenStable = function(callback) {
          $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
      }
    ];
  }

  function $TimeoutProvider() {
    this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler',
      function($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};

        function timeout(fn, delay, invokeApply) {
          if (!isFunction(fn)) {
            invokeApply = delay;
            delay = fn;
            fn = noop;
          }
          var args = sliceArgs(arguments, 3),
            skipApply = (isDefined(invokeApply) && !invokeApply),
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise,
            timeoutId;
          timeoutId = $browser.defer(function() {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function(promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  var urlParsingNode = window.document.createElement("a");
  var originUrl = urlResolve(window.location.href);

  function urlResolve(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
        urlParsingNode.pathname :
        '/' + urlParsingNode.pathname
    };
  }

  function urlIsSameOrigin(requestUrl) {
    var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
    return (parsed.protocol === originUrl.protocol &&
      parsed.host === originUrl.host);
  }

  function $WindowProvider() {
    this.$get = valueFn(window);
  }

  function $$CookieReader($document) {
    var rawDocument = $document[0] || {};
    var lastCookies = {};
    var lastCookieString = '';

    function safeDecodeURIComponent(str) {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    return function() {
      var cookieArray, cookie, i, index, name;
      var currentCookieString = rawDocument.cookie || '';
      if (currentCookieString !== lastCookieString) {
        lastCookieString = currentCookieString;
        cookieArray = lastCookieString.split('; ');
        lastCookies = {};
        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index > 0) {
            name = safeDecodeURIComponent(cookie.substring(0, index));
            if (isUndefined(lastCookies[name])) {
              lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    };
  }
  $$CookieReader.$inject = ['$document'];

  function $$CookieReaderProvider() {
    this.$get = $$CookieReader;
  }
  $FilterProvider.$inject = ['$provide'];

  function $FilterProvider($provide) {
    var suffix = 'Filter';

    function register(name, factory) {
      if (isObject(name)) {
        var filters = {};
        forEach(name, function(filter, key) {
          filters[key] = register(key, filter);
        });
        return filters;
      } else {
        return $provide.factory(name + suffix, factory);
      }
    }
    this.register = register;
    this.$get = ['$injector', function($injector) {
      return function(name) {
        return $injector.get(name + suffix);
      };
    }];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }

  function filterFilter() {
    return function(array, expression, comparator, anyPropertyKey) {
      if (!isArrayLike(array)) {
        if (array == null) {
          return array;
        } else {
          throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
        }
      }
      anyPropertyKey = anyPropertyKey || '$';
      var expressionType = getTypeForFilter(expression);
      var predicateFn;
      var matchAgainstAnyProp;
      switch (expressionType) {
        case 'function':
          predicateFn = expression;
          break;
        case 'boolean':
        case 'null':
        case 'number':
        case 'string':
          matchAgainstAnyProp = true;
        case 'object':
          predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
          break;
        default:
          return array;
      }
      return Array.prototype.filter.call(array, predicateFn);
    };
  }

  function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
    var shouldMatchPrimitives = isObject(expression) && (anyPropertyKey in expression);
    var predicateFn;
    if (comparator === true) {
      comparator = equals;
    } else if (!isFunction(comparator)) {
      comparator = function(actual, expected) {
        if (isUndefined(actual)) {
          return false;
        }
        if ((actual === null) || (expected === null)) {
          return actual === expected;
        }
        if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
          return false;
        }
        actual = lowercase('' + actual);
        expected = lowercase('' + expected);
        return actual.indexOf(expected) !== -1;
      };
    }
    predicateFn = function(item) {
      if (shouldMatchPrimitives && !isObject(item)) {
        return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
      }
      return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
    };
    return predicateFn;
  }

  function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
    var actualType = getTypeForFilter(actual);
    var expectedType = getTypeForFilter(expected);
    if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
      return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
    } else if (isArray(actual)) {
      return actual.some(function(item) {
        return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
      });
    }
    switch (actualType) {
      case 'object':
        var key;
        if (matchAgainstAnyProp) {
          for (key in actual) {
            if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
              return true;
            }
          }
          return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
        } else if (expectedType === 'object') {
          for (key in expected) {
            var expectedVal = expected[key];
            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
              continue;
            }
            var matchAnyProperty = key === anyPropertyKey;
            var actualVal = matchAnyProperty ? actual : actual[key];
            if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
              return false;
            }
          }
          return true;
        } else {
          return comparator(actual, expected);
        }
        break;
      case 'function':
        return false;
      default:
        return comparator(actual, expected);
    }
  }

  function getTypeForFilter(val) {
    return (val === null) ? 'null' : typeof val;
  }
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = '.';
  var ZERO_CHAR = '0';
  currencyFilter.$inject = ['$locale'];

  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(amount, currencySymbol, fractionSize) {
      if (isUndefined(currencySymbol)) {
        currencySymbol = formats.CURRENCY_SYM;
      }
      if (isUndefined(fractionSize)) {
        fractionSize = formats.PATTERNS[1].maxFrac;
      }
      return (amount == null) ?
        amount :
        formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
      replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];

  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(number, fractionSize) {
      return (number == null) ?
        number :
        formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
          fractionSize);
    };
  }

  function parse(numStr) {
    var exponent = 0,
      digits, numberOfIntegerDigits;
    var i, j, zeros;
    if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
      numStr = numStr.replace(DECIMAL_SEP, '');
    }
    if ((i = numStr.search(/e/i)) > 0) {
      if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
      numberOfIntegerDigits += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (numberOfIntegerDigits < 0) {
      numberOfIntegerDigits = numStr.length;
    }
    for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
    if (i == (zeros = numStr.length)) {
      digits = [0];
      numberOfIntegerDigits = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) == ZERO_CHAR) zeros--;
      numberOfIntegerDigits -= i;
      digits = [];
      for (j = 0; i <= zeros; i++, j++) {
        digits[j] = +numStr.charAt(i);
      }
    }
    if (numberOfIntegerDigits > MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = numberOfIntegerDigits - 1;
      numberOfIntegerDigits = 1;
    }
    return {
      d: digits,
      e: exponent,
      i: numberOfIntegerDigits
    };
  }

  function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
    var digits = parsedNumber.d;
    var fractionLen = digits.length - parsedNumber.i;
    fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
    var roundAt = fractionSize + parsedNumber.i;
    var digit = digits[roundAt];
    if (roundAt > 0) {
      digits.splice(Math.max(parsedNumber.i, roundAt));
      for (var j = roundAt; j < digits.length; j++) {
        digits[j] = 0;
      }
    } else {
      fractionLen = Math.max(0, fractionLen);
      parsedNumber.i = 1;
      digits.length = Math.max(1, roundAt = fractionSize + 1);
      digits[0] = 0;
      for (var i = 1; i < roundAt; i++) digits[i] = 0;
    }
    if (digit >= 5) {
      if (roundAt - 1 < 0) {
        for (var k = 0; k > roundAt; k--) {
          digits.unshift(0);
          parsedNumber.i++;
        }
        digits.unshift(1);
        parsedNumber.i++;
      } else {
        digits[roundAt - 1]++;
      }
    }
    for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
    var carry = digits.reduceRight(function(carry, d, i, digits) {
      d = d + carry;
      digits[i] = d % 10;
      return Math.floor(d / 10);
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.i++;
    }
  }

  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (!(isString(number) || isNumber(number)) || isNaN(number)) return '';
    var isInfinity = !isFinite(number);
    var isZero = false;
    var numStr = Math.abs(number) + '',
      formattedText = '',
      parsedNumber;
    if (isInfinity) {
      formattedText = '\u221e';
    } else {
      parsedNumber = parse(numStr);
      roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
      var digits = parsedNumber.d;
      var integerLen = parsedNumber.i;
      var exponent = parsedNumber.e;
      var decimals = [];
      isZero = digits.reduce(function(isZero, d) {
        return isZero && !d;
      }, true);
      while (integerLen < 0) {
        digits.unshift(0);
        integerLen++;
      }
      if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
      } else {
        decimals = digits;
        digits = [0];
      }
      var groups = [];
      if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
      }
      while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
      }
      if (digits.length) {
        groups.unshift(digits.join(''));
      }
      formattedText = groups.join(groupSep);
      if (decimals.length) {
        formattedText += decimalSep + decimals.join('');
      }
      if (exponent) {
        formattedText += 'e+' + exponent;
      }
    }
    if (number < 0 && !isZero) {
      return pattern.negPre + formattedText + pattern.negSuf;
    } else {
      return pattern.posPre + formattedText + pattern.posSuf;
    }
  }

  function padNumber(num, digits, trim, negWrap) {
    var neg = '';
    if (num < 0 || (negWrap && num <= 0)) {
      if (negWrap) {
        num = -num + 1;
      } else {
        num = -num;
        neg = '-';
      }
    }
    num = '' + num;
    while (num.length < digits) num = ZERO_CHAR + num;
    if (trim) {
      num = num.substr(num.length - digits);
    }
    return neg + num;
  }

  function dateGetter(name, size, offset, trim, negWrap) {
    offset = offset || 0;
    return function(date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset) {
        value += offset;
      }
      if (value === 0 && offset == -12) value = 12;
      return padNumber(value, size, trim, negWrap);
    };
  }

  function dateStrGetter(name, shortForm, standAlone) {
    return function(date, formats) {
      var value = date['get' + name]();
      var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
      var get = uppercase(propPrefix + name);
      return formats[get][value];
    };
  }

  function timeZoneGetter(date, formats, offset) {
    var zone = -1 * offset;
    var paddedZone = (zone >= 0) ? "+" : "";
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
      padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }

  function getFirstThursdayOfYear(year) {
    var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
    return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
  }

  function getThursdayThisWeek(datetime) {
    return new Date(datetime.getFullYear(), datetime.getMonth(),
      datetime.getDate() + (4 - datetime.getDay()));
  }

  function weekGetter(size) {
    return function(date) {
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
        thisThurs = getThursdayThisWeek(date);
      var diff = +thisThurs - +firstThurs,
        result = 1 + Math.round(diff / 6.048e8);
      return padNumber(result, size);
    };
  }

  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }

  function eraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
  }

  function longEraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
  }
  var DATE_FORMATS = {
    yyyy: dateGetter('FullYear', 4, 0, false, true),
    yy: dateGetter('FullYear', 2, 0, true, true),
    y: dateGetter('FullYear', 1, 0, false, true),
    MMMM: dateStrGetter('Month'),
    MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
    M: dateGetter('Month', 1, 1),
    LLLL: dateStrGetter('Month', false, true),
    dd: dateGetter('Date', 2),
    d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
    H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
    h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
    m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
    s: dateGetter('Seconds', 1),
    sss: dateGetter('Milliseconds', 3),
    EEEE: dateStrGetter('Day'),
    EEE: dateStrGetter('Day', true),
    a: ampmGetter,
    Z: timeZoneGetter,
    ww: weekGetter(2),
    w: weekGetter(1),
    G: eraGetter,
    GG: eraGetter,
    GGG: eraGetter,
    GGGG: longEraGetter
  };
  var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;
  dateFilter.$inject = ['$locale'];

  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;

    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0),
          tzHour = 0,
          tzMin = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
          tzHour = toInt(match[9] + match[10]);
          tzMin = toInt(match[9] + match[11]);
        }
        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
        var h = toInt(match[4] || 0) - tzHour;
        var m = toInt(match[5] || 0) - tzMin;
        var s = toInt(match[6] || 0);
        var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
        timeSetter.call(date, h, m, s, ms);
        return date;
      }
      return string;
    }
    return function(date, format, timezone) {
      var text = '',
        parts = [],
        fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date) || !isFinite(date.getTime())) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      var dateTimezoneOffset = date.getTimezoneOffset();
      if (timezone) {
        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        date = convertTimezoneToLocal(date, timezone, true);
      }
      forEach(parts, function(value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) :
          value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
      });
      return text;
    };
  }

  function jsonFilter() {
    return function(object, spacing) {
      if (isUndefined(spacing)) {
        spacing = 2;
      }
      return toJson(object, spacing);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);

  function limitToFilter() {
    return function(input, limit, begin) {
      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = toInt(limit);
      }
      if (isNaN(limit)) return input;
      if (isNumber(input)) input = input.toString();
      if (!isArrayLike(input)) return input;
      begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
      begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
      if (limit >= 0) {
        return sliceFn(input, begin, begin + limit);
      } else {
        if (begin === 0) {
          return sliceFn(input, limit, input.length);
        } else {
          return sliceFn(input, Math.max(0, begin + limit), begin);
        }
      }
    };
  }

  function sliceFn(input, begin, end) {
    if (isString(input)) return input.slice(begin, end);
    return slice.call(input, begin, end);
  }
  orderByFilter.$inject = ['$parse'];

  function orderByFilter($parse) {
    return function(array, sortPredicate, reverseOrder, compareFn) {
      if (array == null) return array;
      if (!isArrayLike(array)) {
        throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
      }
      if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
      }
      if (sortPredicate.length === 0) {
        sortPredicate = ['+'];
      }
      var predicates = processPredicates(sortPredicate);
      var descending = reverseOrder ? -1 : 1;
      var compare = isFunction(compareFn) ? compareFn : defaultCompare;
      var compareValues = Array.prototype.map.call(array, getComparisonObject);
      compareValues.sort(doComparison);
      array = compareValues.map(function(item) {
        return item.value;
      });
      return array;

      function getComparisonObject(value, index) {
        return {
          value: value,
          tieBreaker: {
            value: index,
            type: 'number',
            index: index
          },
          predicateValues: predicates.map(function(predicate) {
            return getPredicateValue(predicate.get(value), index);
          })
        };
      }

      function doComparison(v1, v2) {
        for (var i = 0, ii = predicates.length; i < ii; i++) {
          var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
          if (result) {
            return result * predicates[i].descending * descending;
          }
        }
        return compare(v1.tieBreaker, v2.tieBreaker) * descending;
      }
    };

    function processPredicates(sortPredicates) {
      return sortPredicates.map(function(predicate) {
        var descending = 1,
          get = identity;
        if (isFunction(predicate)) {
          get = predicate;
        } else if (isString(predicate)) {
          if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
            descending = predicate.charAt(0) == '-' ? -1 : 1;
            predicate = predicate.substring(1);
          }
          if (predicate !== '') {
            get = $parse(predicate);
            if (get.constant) {
              var key = get();
              get = function(value) {
                return value[key];
              };
            }
          }
        }
        return {
          get: get,
          descending: descending
        };
      });
    }

    function isPrimitive(value) {
      switch (typeof value) {
        case 'number':
        case 'boolean':
        case 'string':
          return true;
        default:
          return false;
      }
    }

    function objectValue(value) {
      if (isFunction(value.valueOf)) {
        value = value.valueOf();
        if (isPrimitive(value)) return value;
      }
      if (hasCustomToString(value)) {
        value = value.toString();
        if (isPrimitive(value)) return value;
      }
      return value;
    }

    function getPredicateValue(value, index) {
      var type = typeof value;
      if (value === null) {
        type = 'string';
        value = 'null';
      } else if (type === 'object') {
        value = objectValue(value);
      }
      return {
        value: value,
        type: type,
        index: index
      };
    }

    function defaultCompare(v1, v2) {
      var result = 0;
      var type1 = v1.type;
      var type2 = v2.type;
      if (type1 === type2) {
        var value1 = v1.value;
        var value2 = v2.value;
        if (type1 === 'string') {
          value1 = value1.toLowerCase();
          value2 = value2.toLowerCase();
        } else if (type1 === 'object') {
          if (isObject(value1)) value1 = v1.index;
          if (isObject(value2)) value2 = v2.index;
        }
        if (value1 !== value2) {
          result = value1 < value2 ? -1 : 1;
        }
      } else {
        result = type1 < type2 ? -1 : 1;
      }
      return result;
    }
  }

  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = {
        link: directive
      };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
    restrict: 'E',
    compile: function(element, attr) {
      if (!attr.href && !attr.xlinkHref) {
        return function(scope, element) {
          if (element[0].nodeName.toLowerCase() !== 'a') return;
          var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
            'xlink:href' : 'href';
          element.on('click', function(event) {
            if (!element.attr(href)) {
              event.preventDefault();
            }
          });
        };
      }
    }
  });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function(propName, attrName) {
    if (propName == "multiple") return;

    function defaultLinkFn(scope, element, attr) {
      scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
        attr.$set(attrName, !!value);
      });
    }
    var normalized = directiveNormalize('ng-' + attrName);
    var linkFn = defaultLinkFn;
    if (propName === 'checked') {
      linkFn = function(scope, element, attr) {
        if (attr.ngModel !== attr[normalized]) {
          defaultLinkFn(scope, element, attr);
        }
      };
    }
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        restrict: 'A',
        priority: 100,
        link: linkFn
      };
    };
  });
  forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
    ngAttributeAliasDirectives[ngAttr] = function() {
      return {
        priority: 100,
        link: function(scope, element, attr) {
          if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
              attr.$set("ngPattern", new RegExp(match[1], match[2]));
              return;
            }
          }
          scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
          });
        }
      };
    };
  });
  forEach(['src', 'srcset', 'href'], function(attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        priority: 99,
        link: function(scope, element, attr) {
          var propName = attrName,
            name = attrName;
          if (attrName === 'href' &&
            toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
            name = 'xlinkHref';
            attr.$attr[name] = 'xlink:href';
            propName = null;
          }
          attr.$observe(normalized, function(value) {
            if (!value) {
              if (attrName === 'href') {
                attr.$set(name, null);
              }
              return;
            }
            attr.$set(name, value);
            if (msie && propName) element.prop(propName, attr[name]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $$renameControl: nullFormRenameControl,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop,
      $setPristine: noop,
      $setSubmitted: noop
    },
    SUBMITTED_CLASS = 'ng-submitted';

  function nullFormRenameControl(control, name) {
    control.$name = name;
  }
  FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];

  function FormController(element, attrs, $scope, $animate, $interpolate) {
    var form = this,
      controls = [];
    form.$error = {};
    form.$$success = {};
    form.$pending = undefined;
    form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    form.$submitted = false;
    form.$$parentForm = nullFormCtrl;
    form.$rollbackViewValue = function() {
      forEach(controls, function(control) {
        control.$rollbackViewValue();
      });
    };
    form.$commitViewValue = function() {
      forEach(controls, function(control) {
        control.$commitViewValue();
      });
    };
    form.$addControl = function(control) {
      assertNotHasOwnProperty(control.$name, 'input');
      controls.push(control);
      if (control.$name) {
        form[control.$name] = control;
      }
      control.$$parentForm = form;
    };
    form.$$renameControl = function(control, newName) {
      var oldName = control.$name;
      if (form[oldName] === control) {
        delete form[oldName];
      }
      form[newName] = control;
      control.$name = newName;
    };
    form.$removeControl = function(control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(form.$pending, function(value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$error, function(value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$$success, function(value, name) {
        form.$setValidity(name, null, control);
      });
      arrayRemove(controls, control);
      control.$$parentForm = nullFormCtrl;
    };
    addSetValidityMethod({
      ctrl: this,
      $element: element,
      set: function(object, property, controller) {
        var list = object[property];
        if (!list) {
          object[property] = [controller];
        } else {
          var index = list.indexOf(controller);
          if (index === -1) {
            list.push(controller);
          }
        }
      },
      unset: function(object, property, controller) {
        var list = object[property];
        if (!list) {
          return;
        }
        arrayRemove(list, controller);
        if (list.length === 0) {
          delete object[property];
        }
      },
      $animate: $animate
    });
    form.$setDirty = function() {
      $animate.removeClass(element, PRISTINE_CLASS);
      $animate.addClass(element, DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      form.$$parentForm.$setDirty();
    };
    form.$setPristine = function() {
      $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
      form.$dirty = false;
      form.$pristine = true;
      form.$submitted = false;
      forEach(controls, function(control) {
        control.$setPristine();
      });
    };
    form.$setUntouched = function() {
      forEach(controls, function(control) {
        control.$setUntouched();
      });
    };
    form.$setSubmitted = function() {
      $animate.addClass(element, SUBMITTED_CLASS);
      form.$submitted = true;
      form.$$parentForm.$setSubmitted();
    };
  }
  var formDirectiveFactory = function(isNgForm) {
    return ['$timeout', '$parse', function($timeout, $parse) {
      var formDirective = {
        name: 'form',
        restrict: isNgForm ? 'EAC' : 'E',
        require: ['form', '^^?form'],
        controller: FormController,
        compile: function ngFormCompile(formElement, attr) {
          formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
          var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
          return {
            pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
              var controller = ctrls[0];
              if (!('action' in attr)) {
                var handleFormSubmission = function(event) {
                  scope.$apply(function() {
                    controller.$commitViewValue();
                    controller.$setSubmitted();
                  });
                  event.preventDefault();
                };
                addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                formElement.on('$destroy', function() {
                  $timeout(function() {
                    removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                  }, 0, false);
                });
              }
              var parentFormCtrl = ctrls[1] || controller.$$parentForm;
              parentFormCtrl.$addControl(controller);
              var setter = nameAttr ? getSetter(controller.$name) : noop;
              if (nameAttr) {
                setter(scope, controller);
                attr.$observe(nameAttr, function(newValue) {
                  if (controller.$name === newValue) return;
                  setter(scope, undefined);
                  controller.$$parentForm.$$renameControl(controller, newValue);
                  setter = getSetter(controller.$name);
                  setter(scope, controller);
                });
              }
              formElement.on('$destroy', function() {
                controller.$$parentForm.$removeControl(controller);
                setter(scope, undefined);
                extend(controller, nullFormCtrl);
              });
            }
          };
        }
      };
      return formDirective;

      function getSetter(expression) {
        if (expression === '') {
          return $parse('this[""]').assign;
        }
        return $parse(expression).assign || noop;
      }
    }];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
  var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
  var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
  var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
  var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
  var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
  var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
  var PARTIAL_VALIDATION_TYPES = createMap();
  forEach('date,datetime-local,month,time,week'.split(','), function(type) {
    PARTIAL_VALIDATION_TYPES[type] = true;
  });
  var inputType = {
    'text': textInputType,
    'date': createDateInputType('date', DATE_REGEXP,
      createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),
      'yyyy-MM-dd'),
    'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP,
      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']),
      'yyyy-MM-ddTHH:mm:ss.sss'),
    'time': createDateInputType('time', TIME_REGEXP,
      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),
      'HH:mm:ss.sss'),
    'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
    'month': createDateInputType('month', MONTH_REGEXP,
      createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),
      'yyyy-MM'),
    'number': numberInputType,
    'url': urlInputType,
    'email': emailInputType,
    'radio': radioInputType,
    'checkbox': checkboxInputType,
    'hidden': noop,
    'button': noop,
    'submit': noop,
    'reset': noop,
    'file': noop
  };

  function stringBasedInputType(ctrl) {
    ctrl.$formatters.push(function(value) {
      return ctrl.$isEmpty(value) ? value : value.toString();
    });
  }

  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
  }

  function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var type = lowercase(element[0].type);
    if (!$sniffer.android) {
      var composing = false;
      element.on('compositionstart', function() {
        composing = true;
      });
      element.on('compositionend', function() {
        composing = false;
        listener();
      });
    }
    var timeout;
    var listener = function(ev) {
      if (timeout) {
        $browser.defer.cancel(timeout);
        timeout = null;
      }
      if (composing) return;
      var value = element.val(),
        event = ev && ev.type;
      if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
        value = trim(value);
      }
      if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
        ctrl.$setViewValue(value, event);
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.on('input', listener);
    } else {
      var deferListener = function(ev, input, origValue) {
        if (!timeout) {
          timeout = $browser.defer(function() {
            timeout = null;
            if (!input || input.value !== origValue) {
              listener(ev);
            }
          });
        }
      };
      element.on('keydown', function(event) {
        var key = event.keyCode;
        if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;
        deferListener(event, this, this.value);
      });
      if ($sniffer.hasEvent('paste')) {
        element.on('paste cut', deferListener);
      }
    }
    element.on('change', listener);
    if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
      element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
        if (!timeout) {
          var validity = this[VALIDITY_STATE_PROPERTY];
          var origBadInput = validity.badInput;
          var origTypeMismatch = validity.typeMismatch;
          timeout = $browser.defer(function() {
            timeout = null;
            if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
              listener(ev);
            }
          });
        }
      });
    }
    ctrl.$render = function() {
      var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
      if (element.val() !== value) {
        element.val(value);
      }
    };
  }

  function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
      return isoWeek;
    }
    if (isString(isoWeek)) {
      WEEK_REGEXP.lastIndex = 0;
      var parts = WEEK_REGEXP.exec(isoWeek);
      if (parts) {
        var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;
        if (existingDate) {
          hours = existingDate.getHours();
          minutes = existingDate.getMinutes();
          seconds = existingDate.getSeconds();
          milliseconds = existingDate.getMilliseconds();
        }
        return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
      }
    }
    return NaN;
  }

  function createDateParser(regexp, mapping) {
    return function(iso, date) {
      var parts, map;
      if (isDate(iso)) {
        return iso;
      }
      if (isString(iso)) {
        if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
          iso = iso.substring(1, iso.length - 1);
        }
        if (ISO_DATE_REGEXP.test(iso)) {
          return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);
        if (parts) {
          parts.shift();
          if (date) {
            map = {
              yyyy: date.getFullYear(),
              MM: date.getMonth() + 1,
              dd: date.getDate(),
              HH: date.getHours(),
              mm: date.getMinutes(),
              ss: date.getSeconds(),
              sss: date.getMilliseconds() / 1000
            };
          } else {
            map = {
              yyyy: 1970,
              MM: 1,
              dd: 1,
              HH: 0,
              mm: 0,
              ss: 0,
              sss: 0
            };
          }
          forEach(parts, function(part, index) {
            if (index < mapping.length) {
              map[mapping[index]] = +part;
            }
          });
          return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
        }
      }
      return NaN;
    };
  }

  function createDateInputType(type, regexp, parseDate, format) {
    return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
      badInputChecker(scope, element, attr, ctrl);
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
      var previousDate;
      ctrl.$$parserName = type;
      ctrl.$parsers.push(function(value) {
        if (ctrl.$isEmpty(value)) return null;
        if (regexp.test(value)) {
          var parsedDate = parseDate(value, previousDate);
          if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
          }
          return parsedDate;
        }
        return undefined;
      });
      ctrl.$formatters.push(function(value) {
        if (value && !isDate(value)) {
          throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
        }
        if (isValidDate(value)) {
          previousDate = value;
          if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
          }
          return $filter('date')(value, format, timezone);
        } else {
          previousDate = null;
          return '';
        }
      });
      if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function(value) {
          return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
        };
        attr.$observe('min', function(val) {
          minVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function(value) {
          return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
        };
        attr.$observe('max', function(val) {
          maxVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }

      function isValidDate(value) {
        return value && !(value.getTime && value.getTime() !== value.getTime());
      }

      function parseObservedDateValue(val) {
        return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
      }
    };
  }

  function badInputChecker(scope, element, attr, ctrl) {
    var node = element[0];
    var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
    if (nativeValidation) {
      ctrl.$parsers.push(function(value) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
        return validity.badInput || validity.typeMismatch ? undefined : value;
      });
    }
  }

  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$$parserName = 'number';
    ctrl.$parsers.push(function(value) {
      if (ctrl.$isEmpty(value)) return null;
      if (NUMBER_REGEXP.test(value)) return parseFloat(value);
      return undefined;
    });
    ctrl.$formatters.push(function(value) {
      if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
          throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
        }
        value = value.toString();
      }
      return value;
    });
    if (isDefined(attr.min) || attr.ngMin) {
      var minVal;
      ctrl.$validators.min = function(value) {
        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
      };
      attr.$observe('min', function(val) {
        if (isDefined(val) && !isNumber(val)) {
          val = parseFloat(val);
        }
        minVal = isNumber(val) && !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
    if (isDefined(attr.max) || attr.ngMax) {
      var maxVal;
      ctrl.$validators.max = function(value) {
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
      };
      attr.$observe('max', function(val) {
        if (isDefined(val) && !isNumber(val)) {
          val = parseFloat(val);
        }
        maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
  }

  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'url';
    ctrl.$validators.url = function(modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
  }

  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'email';
    ctrl.$validators.email = function(modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
  }

  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    var listener = function(ev) {
      if (element[0].checked) {
        ctrl.$setViewValue(attr.value, ev && ev.type);
      }
    };
    element.on('click', listener);
    ctrl.$render = function() {
      var value = attr.value;
      element[0].checked = (value == ctrl.$viewValue);
    };
    attr.$observe('value', ctrl.$render);
  }

  function parseConstantExpr($parse, context, name, expression, fallback) {
    var parseFn;
    if (isDefined(expression)) {
      parseFn = $parse(expression);
      if (!parseFn.constant) {
        throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' +
          '`{1}`.', name, expression);
      }
      return parseFn(context);
    }
    return fallback;
  }

  function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
    var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
    var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
    var listener = function(ev) {
      ctrl.$setViewValue(element[0].checked, ev && ev.type);
    };
    element.on('click', listener);
    ctrl.$render = function() {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function(value) {
      return value === false;
    };
    ctrl.$formatters.push(function(value) {
      return equals(value, trueValue);
    });
    ctrl.$parsers.push(function(value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
    function($browser, $sniffer, $filter, $parse) {
      return {
        restrict: 'E',
        require: ['?ngModel'],
        link: {
          pre: function(scope, element, attr, ctrls) {
            if (ctrls[0]) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
                $browser, $filter, $parse);
            }
          }
        }
      };
    }
  ];
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function() {
    return {
      restrict: 'A',
      priority: 100,
      compile: function(tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function ngValueConstantLink(scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function ngValueLink(scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ['$compile', function($compile) {
    return {
      restrict: 'AC',
      compile: function ngBindCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindLink(scope, element, attr) {
          $compile.$$addBindingInfo(element, attr.ngBind);
          element = element[0];
          scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
            element.textContent = isUndefined(value) ? '' : value;
          });
        };
      }
    };
  }];
  var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
    return {
      compile: function ngBindTemplateCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindTemplateLink(scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          $compile.$$addBindingInfo(element, interpolateFn.expressions);
          element = element[0];
          attr.$observe('ngBindTemplate', function(value) {
            element.textContent = isUndefined(value) ? '' : value;
          });
        };
      }
    };
  }];
  var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
    return {
      restrict: 'A',
      compile: function ngBindHtmlCompile(tElement, tAttrs) {
        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
          return $sce.valueOf(val);
        });
        $compile.$$addBindingClass(tElement);
        return function ngBindHtmlLink(scope, element, attr) {
          $compile.$$addBindingInfo(element, attr.ngBindHtml);
          scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
            var value = ngBindHtmlGetter(scope);
            element.html($sce.getTrustedHtml(value) || '');
          });
        };
      }
    };
  }];
  var ngChangeDirective = valueFn({
    restrict: 'A',
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      ctrl.$viewChangeListeners.push(function() {
        scope.$eval(attr.ngChange);
      });
    }
  });

  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ['$animate', function($animate) {
      return {
        restrict: 'AC',
        link: function(scope, element, attr) {
          var oldVal;
          scope.$watch(attr[name], ngClassWatchAction, true);
          attr.$observe('class', function(value) {
            ngClassWatchAction(scope.$eval(attr[name]));
          });
          if (name !== 'ngClass') {
            scope.$watch('$index', function($index, old$index) {
              var mod = $index & 1;
              if (mod !== (old$index & 1)) {
                var classes = arrayClasses(scope.$eval(attr[name]));
                mod === selector ?
                  addClasses(classes) :
                  removeClasses(classes);
              }
            });
          }

          function addClasses(classes) {
            var newClasses = digestClassCounts(classes, 1);
            attr.$addClass(newClasses);
          }

          function removeClasses(classes) {
            var newClasses = digestClassCounts(classes, -1);
            attr.$removeClass(newClasses);
          }

          function digestClassCounts(classes, count) {
            var classCounts = element.data('$classCounts') || createMap();
            var classesToUpdate = [];
            forEach(classes, function(className) {
              if (count > 0 || classCounts[className]) {
                classCounts[className] = (classCounts[className] || 0) + count;
                if (classCounts[className] === +(count > 0)) {
                  classesToUpdate.push(className);
                }
              }
            });
            element.data('$classCounts', classCounts);
            return classesToUpdate.join(' ');
          }

          function updateClasses(oldClasses, newClasses) {
            var toAdd = arrayDifference(newClasses, oldClasses);
            var toRemove = arrayDifference(oldClasses, newClasses);
            toAdd = digestClassCounts(toAdd, 1);
            toRemove = digestClassCounts(toRemove, -1);
            if (toAdd && toAdd.length) {
              $animate.addClass(element, toAdd);
            }
            if (toRemove && toRemove.length) {
              $animate.removeClass(element, toRemove);
            }
          }

          function ngClassWatchAction(newVal) {
            if (selector === true || (scope.$index & 1) === selector) {
              var newClasses = arrayClasses(newVal || []);
              if (!oldVal) {
                addClasses(newClasses);
              } else if (!equals(newVal, oldVal)) {
                var oldClasses = arrayClasses(oldVal);
                updateClasses(oldClasses, newClasses);
              }
            }
            if (isArray(newVal)) {
              oldVal = newVal.map(function(v) {
                return shallowCopy(v);
              });
            } else {
              oldVal = shallowCopy(newVal);
            }
          }
        }
      };

      function arrayDifference(tokens1, tokens2) {
        var values = [];
        outer:
          for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
              if (token == tokens2[j]) continue outer;
            }
            values.push(token);
          }
        return values;
      }

      function arrayClasses(classVal) {
        var classes = [];
        if (isArray(classVal)) {
          forEach(classVal, function(v) {
            classes = classes.concat(arrayClasses(v));
          });
          return classes;
        } else if (isString(classVal)) {
          return classVal.split(' ');
        } else if (isObject(classVal)) {
          forEach(classVal, function(v, k) {
            if (v) {
              classes = classes.concat(k.split(' '));
            }
          });
          return classes;
        }
        return classVal;
      }
    }];
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
    compile: function(element, attr) {
      attr.$set('ngCloak', undefined);
      element.removeClass('ng-cloak');
    }
  });
  var ngControllerDirective = [function() {
    return {
      restrict: 'A',
      scope: true,
      controller: '@',
      priority: 500
    };
  }];
  var ngEventDirectives = {};
  var forceAsyncEvents = {
    'blur': true,
    'focus': true
  };
  forEach(
    'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
    function(eventName) {
      var directiveName = directiveNormalize('ng-' + eventName);
      ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
        return {
          restrict: 'A',
          compile: function($element, attr) {
            var fn = $parse(attr[directiveName], null, true);
            return function ngEventHandler(scope, element) {
              element.on(eventName, function(event) {
                var callback = function() {
                  fn(scope, {
                    $event: event
                  });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                  scope.$evalAsync(callback);
                } else {
                  scope.$apply(callback);
                }
              });
            };
          }
        };
      }];
    }
  );
  var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
    return {
      multiElement: true,
      transclude: 'element',
      priority: 600,
      terminal: true,
      restrict: 'A',
      $$tlb: true,
      link: function($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (value) {
            if (!childScope) {
              $transclude(function(clone, newScope) {
                childScope = newScope;
                clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {
            if (previousElements) {
              previousElements.remove();
              previousElements = null;
            }
            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }
            if (block) {
              previousElements = getBlockNodes(block.clone);
              $animate.leave(previousElements).then(function() {
                previousElements = null;
              });
              block = null;
            }
          }
        });
      }
    };
  }];
  var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate',
    function($templateRequest, $anchorScroll, $animate) {
      return {
        restrict: 'ECA',
        priority: 400,
        terminal: true,
        transclude: 'element',
        controller: angular.noop,
        compile: function(element, attr) {
          var srcExp = attr.ngInclude || attr.src,
            onloadExp = attr.onload || '',
            autoScrollExp = attr.autoscroll;
          return function(scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
            var cleanupLastIncludeContent = function() {
              if (previousElement) {
                previousElement.remove();
                previousElement = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                $animate.leave(currentElement).then(function() {
                  previousElement = null;
                });
                previousElement = currentElement;
                currentElement = null;
              }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
              var afterAnimation = function() {
                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              };
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(function(response) {
                  if (scope.$$destroyed) return;
                  if (thisChangeId !== changeCounter) return;
                  var newScope = scope.$new();
                  ctrl.template = response;
                  var clone = $transclude(newScope, function(clone) {
                    cleanupLastIncludeContent();
                    $animate.enter(clone, null, $element).then(afterAnimation);
                  });
                  currentScope = newScope;
                  currentElement = clone;
                  currentScope.$emit('$includeContentLoaded', src);
                  scope.$eval(onloadExp);
                }, function() {
                  if (scope.$$destroyed) return;
                  if (thisChangeId === changeCounter) {
                    cleanupLastIncludeContent();
                    scope.$emit('$includeContentError', src);
                  }
                });
                scope.$emit('$includeContentRequested', src);
              } else {
                cleanupLastIncludeContent();
                ctrl.template = null;
              }
            });
          };
        }
      };
    }
  ];
  var ngIncludeFillContentDirective = ['$compile',
    function($compile) {
      return {
        restrict: 'ECA',
        priority: -400,
        require: 'ngInclude',
        link: function(scope, $element, $attr, ctrl) {
          if (toString.call($element[0]).match(/SVG/)) {
            $element.empty();
            $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope,
              function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {
                futureParentElement: $element
              });
            return;
          }
          $element.html(ctrl.template);
          $compile($element.contents())(scope);
        }
      };
    }
  ];
  var ngInitDirective = ngDirective({
    priority: 450,
    compile: function() {
      return {
        pre: function(scope, element, attrs) {
          scope.$eval(attrs.ngInit);
        }
      };
    }
  });
  var ngListDirective = function() {
    return {
      restrict: 'A',
      priority: 100,
      require: 'ngModel',
      link: function(scope, element, attr, ctrl) {
        var ngList = element.attr(attr.$attr.ngList) || ', ';
        var trimValues = attr.ngTrim !== 'false';
        var separator = trimValues ? trim(ngList) : ngList;
        var parse = function(viewValue) {
          if (isUndefined(viewValue)) return;
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function(value) {
              if (value) list.push(trimValues ? trim(value) : value);
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function(value) {
          if (isArray(value)) {
            return value.join(ngList);
          }
          return undefined;
        });
        ctrl.$isEmpty = function(value) {
          return !value || !value.length;
        };
      }
    };
  };
  var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty',
    UNTOUCHED_CLASS = 'ng-untouched',
    TOUCHED_CLASS = 'ng-touched',
    PENDING_CLASS = 'ng-pending',
    EMPTY_CLASS = 'ng-empty',
    NOT_EMPTY_CLASS = 'ng-not-empty';
  var ngModelMinErr = minErr('ngModel');
  var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate',
    function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
      this.$viewValue = Number.NaN;
      this.$modelValue = Number.NaN;
      this.$$rawModelValue = undefined;
      this.$validators = {};
      this.$asyncValidators = {};
      this.$parsers = [];
      this.$formatters = [];
      this.$viewChangeListeners = [];
      this.$untouched = true;
      this.$touched = false;
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$error = {};
      this.$$success = {};
      this.$pending = undefined;
      this.$name = $interpolate($attr.name || '', false)($scope);
      this.$$parentForm = nullFormCtrl;
      var parsedNgModel = $parse($attr.ngModel),
        parsedNgModelAssign = parsedNgModel.assign,
        ngModelGet = parsedNgModel,
        ngModelSet = parsedNgModelAssign,
        pendingDebounce = null,
        parserValid,
        ctrl = this;
      this.$$setOptions = function(options) {
        ctrl.$options = options;
        if (options && options.getterSetter) {
          var invokeModelGetter = $parse($attr.ngModel + '()'),
            invokeModelSetter = $parse($attr.ngModel + '($$$p)');
          ngModelGet = function($scope) {
            var modelValue = parsedNgModel($scope);
            if (isFunction(modelValue)) {
              modelValue = invokeModelGetter($scope);
            }
            return modelValue;
          };
          ngModelSet = function($scope, newValue) {
            if (isFunction(parsedNgModel($scope))) {
              invokeModelSetter($scope, {
                $$$p: newValue
              });
            } else {
              parsedNgModelAssign($scope, newValue);
            }
          };
        } else if (!parsedNgModel.assign) {
          throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
            $attr.ngModel, startingTag($element));
        }
      };
      this.$render = noop;
      this.$isEmpty = function(value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
      };
      this.$$updateEmptyClasses = function(value) {
        if (ctrl.$isEmpty(value)) {
          $animate.removeClass($element, NOT_EMPTY_CLASS);
          $animate.addClass($element, EMPTY_CLASS);
        } else {
          $animate.removeClass($element, EMPTY_CLASS);
          $animate.addClass($element, NOT_EMPTY_CLASS);
        }
      };
      var currentValidationRunId = 0;
      addSetValidityMethod({
        ctrl: this,
        $element: $element,
        set: function(object, property) {
          object[property] = true;
        },
        unset: function(object, property) {
          delete object[property];
        },
        $animate: $animate
      });
      this.$setPristine = function() {
        ctrl.$dirty = false;
        ctrl.$pristine = true;
        $animate.removeClass($element, DIRTY_CLASS);
        $animate.addClass($element, PRISTINE_CLASS);
      };
      this.$setDirty = function() {
        ctrl.$dirty = true;
        ctrl.$pristine = false;
        $animate.removeClass($element, PRISTINE_CLASS);
        $animate.addClass($element, DIRTY_CLASS);
        ctrl.$$parentForm.$setDirty();
      };
      this.$setUntouched = function() {
        ctrl.$touched = false;
        ctrl.$untouched = true;
        $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
      };
      this.$setTouched = function() {
        ctrl.$touched = true;
        ctrl.$untouched = false;
        $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
      };
      this.$rollbackViewValue = function() {
        $timeout.cancel(pendingDebounce);
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
        ctrl.$render();
      };
      this.$validate = function() {
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          return;
        }
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = ctrl.$$rawModelValue;
        var prevValid = ctrl.$valid;
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
          if (!allowInvalid && prevValid !== allValid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        });
      };
      this.$$runValidators = function(modelValue, viewValue, doneCallback) {
        currentValidationRunId++;
        var localValidationRunId = currentValidationRunId;
        if (!processParseErrors()) {
          validationDone(false);
          return;
        }
        if (!processSyncValidators()) {
          validationDone(false);
          return;
        }
        processAsyncValidators();

        function processParseErrors() {
          var errorKey = ctrl.$$parserName || 'parse';
          if (isUndefined(parserValid)) {
            setValidity(errorKey, null);
          } else {
            if (!parserValid) {
              forEach(ctrl.$validators, function(v, name) {
                setValidity(name, null);
              });
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
            }
            setValidity(errorKey, parserValid);
            return parserValid;
          }
          return true;
        }

        function processSyncValidators() {
          var syncValidatorsValid = true;
          forEach(ctrl.$validators, function(validator, name) {
            var result = validator(modelValue, viewValue);
            syncValidatorsValid = syncValidatorsValid && result;
            setValidity(name, result);
          });
          if (!syncValidatorsValid) {
            forEach(ctrl.$asyncValidators, function(v, name) {
              setValidity(name, null);
            });
            return false;
          }
          return true;
        }

        function processAsyncValidators() {
          var validatorPromises = [];
          var allValid = true;
          forEach(ctrl.$asyncValidators, function(validator, name) {
            var promise = validator(modelValue, viewValue);
            if (!isPromiseLike(promise)) {
              throw ngModelMinErr('nopromise',
                "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
            }
            setValidity(name, undefined);
            validatorPromises.push(promise.then(function() {
              setValidity(name, true);
            }, function() {
              allValid = false;
              setValidity(name, false);
            }));
          });
          if (!validatorPromises.length) {
            validationDone(true);
          } else {
            $q.all(validatorPromises).then(function() {
              validationDone(allValid);
            }, noop);
          }
        }

        function setValidity(name, isValid) {
          if (localValidationRunId === currentValidationRunId) {
            ctrl.$setValidity(name, isValid);
          }
        }

        function validationDone(allValid) {
          if (localValidationRunId === currentValidationRunId) {
            doneCallback(allValid);
          }
        }
      };
      this.$commitViewValue = function() {
        var viewValue = ctrl.$viewValue;
        $timeout.cancel(pendingDebounce);
        if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
          return;
        }
        ctrl.$$updateEmptyClasses(viewValue);
        ctrl.$$lastCommittedViewValue = viewValue;
        if (ctrl.$pristine) {
          this.$setDirty();
        }
        this.$$parseAndValidate();
      };
      this.$$parseAndValidate = function() {
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = viewValue;
        parserValid = isUndefined(modelValue) ? undefined : true;
        if (parserValid) {
          for (var i = 0; i < ctrl.$parsers.length; i++) {
            modelValue = ctrl.$parsers[i](modelValue);
            if (isUndefined(modelValue)) {
              parserValid = false;
              break;
            }
          }
        }
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          ctrl.$modelValue = ngModelGet($scope);
        }
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$rawModelValue = modelValue;
        if (allowInvalid) {
          ctrl.$modelValue = modelValue;
          writeToModelIfNeeded();
        }
        ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
          if (!allowInvalid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            writeToModelIfNeeded();
          }
        });

        function writeToModelIfNeeded() {
          if (ctrl.$modelValue !== prevModelValue) {
            ctrl.$$writeModelToScope();
          }
        }
      };
      this.$$writeModelToScope = function() {
        ngModelSet($scope, ctrl.$modelValue);
        forEach(ctrl.$viewChangeListeners, function(listener) {
          try {
            listener();
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      };
      this.$setViewValue = function(value, trigger) {
        ctrl.$viewValue = value;
        if (!ctrl.$options || ctrl.$options.updateOnDefault) {
          ctrl.$$debounceViewValueCommit(trigger);
        }
      };
      this.$$debounceViewValueCommit = function(trigger) {
        var debounceDelay = 0,
          options = ctrl.$options,
          debounce;
        if (options && isDefined(options.debounce)) {
          debounce = options.debounce;
          if (isNumber(debounce)) {
            debounceDelay = debounce;
          } else if (isNumber(debounce[trigger])) {
            debounceDelay = debounce[trigger];
          } else if (isNumber(debounce['default'])) {
            debounceDelay = debounce['default'];
          }
        }
        $timeout.cancel(pendingDebounce);
        if (debounceDelay) {
          pendingDebounce = $timeout(function() {
            ctrl.$commitViewValue();
          }, debounceDelay);
        } else if ($rootScope.$$phase) {
          ctrl.$commitViewValue();
        } else {
          $scope.$apply(function() {
            ctrl.$commitViewValue();
          });
        }
      };
      $scope.$watch(function ngModelWatch() {
        var modelValue = ngModelGet($scope);
        if (modelValue !== ctrl.$modelValue &&
          (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
        ) {
          ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
          parserValid = undefined;
          var formatters = ctrl.$formatters,
            idx = formatters.length;
          var viewValue = modelValue;
          while (idx--) {
            viewValue = formatters[idx](viewValue);
          }
          if (ctrl.$viewValue !== viewValue) {
            ctrl.$$updateEmptyClasses(viewValue);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
            ctrl.$render();
            ctrl.$$runValidators(modelValue, viewValue, noop);
          }
        }
        return modelValue;
      });
    }
  ];
  var ngModelDirective = ['$rootScope', function($rootScope) {
    return {
      restrict: 'A',
      require: ['ngModel', '^?form', '^?ngModelOptions'],
      controller: NgModelController,
      priority: 1,
      compile: function ngModelCompile(element) {
        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
        return {
          pre: function ngModelPreLink(scope, element, attr, ctrls) {
            var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || modelCtrl.$$parentForm;
            modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
            formCtrl.$addControl(modelCtrl);
            attr.$observe('name', function(newValue) {
              if (modelCtrl.$name !== newValue) {
                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
              }
            });
            scope.$on('$destroy', function() {
              modelCtrl.$$parentForm.$removeControl(modelCtrl);
            });
          },
          post: function ngModelPostLink(scope, element, attr, ctrls) {
            var modelCtrl = ctrls[0];
            if (modelCtrl.$options && modelCtrl.$options.updateOn) {
              element.on(modelCtrl.$options.updateOn, function(ev) {
                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
              });
            }
            element.on('blur', function() {
              if (modelCtrl.$touched) return;
              if ($rootScope.$$phase) {
                scope.$evalAsync(modelCtrl.$setTouched);
              } else {
                scope.$apply(modelCtrl.$setTouched);
              }
            });
          }
        };
      }
    };
  }];
  var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
  var ngModelOptionsDirective = function() {
    return {
      restrict: 'A',
      controller: ['$scope', '$attrs', function($scope, $attrs) {
        var that = this;
        this.$options = copy($scope.$eval($attrs.ngModelOptions));
        if (isDefined(this.$options.updateOn)) {
          this.$options.updateOnDefault = false;
          this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
            that.$options.updateOnDefault = true;
            return ' ';
          }));
        } else {
          this.$options.updateOnDefault = true;
        }
      }]
    };
  };

  function addSetValidityMethod(context) {
    var ctrl = context.ctrl,
      $element = context.$element,
      classCache = {},
      set = context.set,
      unset = context.unset,
      $animate = context.$animate;
    classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
    ctrl.$setValidity = setValidity;

    function setValidity(validationErrorKey, state, controller) {
      if (isUndefined(state)) {
        createAndSet('$pending', validationErrorKey, controller);
      } else {
        unsetAndCleanup('$pending', validationErrorKey, controller);
      }
      if (!isBoolean(state)) {
        unset(ctrl.$error, validationErrorKey, controller);
        unset(ctrl.$$success, validationErrorKey, controller);
      } else {
        if (state) {
          unset(ctrl.$error, validationErrorKey, controller);
          set(ctrl.$$success, validationErrorKey, controller);
        } else {
          set(ctrl.$error, validationErrorKey, controller);
          unset(ctrl.$$success, validationErrorKey, controller);
        }
      }
      if (ctrl.$pending) {
        cachedToggleClass(PENDING_CLASS, true);
        ctrl.$valid = ctrl.$invalid = undefined;
        toggleValidationCss('', null);
      } else {
        cachedToggleClass(PENDING_CLASS, false);
        ctrl.$valid = isObjectEmpty(ctrl.$error);
        ctrl.$invalid = !ctrl.$valid;
        toggleValidationCss('', ctrl.$valid);
      }
      var combinedState;
      if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (ctrl.$error[validationErrorKey]) {
        combinedState = false;
      } else if (ctrl.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }
      toggleValidationCss(validationErrorKey, combinedState);
      ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
    }

    function createAndSet(name, value, controller) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      set(ctrl[name], value, controller);
    }

    function unsetAndCleanup(name, value, controller) {
      if (ctrl[name]) {
        unset(ctrl[name], value, controller);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }

    function cachedToggleClass(className, switchValue) {
      if (switchValue && !classCache[className]) {
        $animate.addClass($element, className);
        classCache[className] = true;
      } else if (!switchValue && classCache[className]) {
        $animate.removeClass($element, className);
        classCache[className] = false;
      }
    }

    function toggleValidationCss(validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
      cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
    }
  }

  function isObjectEmpty(obj) {
    if (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
    }
    return true;
  }
  var ngNonBindableDirective = ngDirective({
    terminal: true,
    priority: 1000
  });
  var ngOptionsMinErr = minErr('ngOptions');
  var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
  var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
    function parseOptionsExpression(optionsExp, selectElement, scope) {
      var match = optionsExp.match(NG_OPTIONS_REGEXP);
      if (!(match)) {
        throw ngOptionsMinErr('iexp',
          "Expected expression in form of " +
          "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
          " but got '{0}'. Element: {1}",
          optionsExp, startingTag(selectElement));
      }
      var valueName = match[5] || match[7];
      var keyName = match[6];
      var selectAs = / as /.test(match[0]) && match[1];
      var trackBy = match[9];
      var valueFn = $parse(match[2] ? match[1] : valueName);
      var selectAsFn = selectAs && $parse(selectAs);
      var viewValueFn = selectAsFn || valueFn;
      var trackByFn = trackBy && $parse(trackBy);
      var getTrackByValueFn = trackBy ?
        function(value, locals) {
          return trackByFn(scope, locals);
        } :
        function getHashOfValue(value) {
          return hashKey(value);
        };
      var getTrackByValue = function(value, key) {
        return getTrackByValueFn(value, getLocals(value, key));
      };
      var displayFn = $parse(match[2] || match[1]);
      var groupByFn = $parse(match[3] || '');
      var disableWhenFn = $parse(match[4] || '');
      var valuesFn = $parse(match[8]);
      var locals = {};
      var getLocals = keyName ? function(value, key) {
        locals[keyName] = key;
        locals[valueName] = value;
        return locals;
      } : function(value) {
        locals[valueName] = value;
        return locals;
      };

      function Option(selectValue, viewValue, label, group, disabled) {
        this.selectValue = selectValue;
        this.viewValue = viewValue;
        this.label = label;
        this.group = group;
        this.disabled = disabled;
      }

      function getOptionValuesKeys(optionValues) {
        var optionValuesKeys;
        if (!keyName && isArrayLike(optionValues)) {
          optionValuesKeys = optionValues;
        } else {
          optionValuesKeys = [];
          for (var itemKey in optionValues) {
            if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
              optionValuesKeys.push(itemKey);
            }
          }
        }
        return optionValuesKeys;
      }
      return {
        trackBy: trackBy,
        getTrackByValue: getTrackByValue,
        getWatchables: $parse(valuesFn, function(optionValues) {
          var watchedArray = [];
          optionValues = optionValues || [];
          var optionValuesKeys = getOptionValuesKeys(optionValues);
          var optionValuesLength = optionValuesKeys.length;
          for (var index = 0; index < optionValuesLength; index++) {
            var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
            var value = optionValues[key];
            var locals = getLocals(value, key);
            var selectValue = getTrackByValueFn(value, locals);
            watchedArray.push(selectValue);
            if (match[2] || match[1]) {
              var label = displayFn(scope, locals);
              watchedArray.push(label);
            }
            if (match[4]) {
              var disableWhen = disableWhenFn(scope, locals);
              watchedArray.push(disableWhen);
            }
          }
          return watchedArray;
        }),
        getOptions: function() {
          var optionItems = [];
          var selectValueMap = {};
          var optionValues = valuesFn(scope) || [];
          var optionValuesKeys = getOptionValuesKeys(optionValues);
          var optionValuesLength = optionValuesKeys.length;
          for (var index = 0; index < optionValuesLength; index++) {
            var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
            var value = optionValues[key];
            var locals = getLocals(value, key);
            var viewValue = viewValueFn(scope, locals);
            var selectValue = getTrackByValueFn(viewValue, locals);
            var label = displayFn(scope, locals);
            var group = groupByFn(scope, locals);
            var disabled = disableWhenFn(scope, locals);
            var optionItem = new Option(selectValue, viewValue, label, group, disabled);
            optionItems.push(optionItem);
            selectValueMap[selectValue] = optionItem;
          }
          return {
            items: optionItems,
            selectValueMap: selectValueMap,
            getOptionFromViewValue: function(value) {
              return selectValueMap[getTrackByValue(value)];
            },
            getViewValueFromOption: function(option) {
              return trackBy ? angular.copy(option.viewValue) : option.viewValue;
            }
          };
        }
      };
    }
    var optionTemplate = window.document.createElement('option'),
      optGroupTemplate = window.document.createElement('optgroup');

    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
      var selectCtrl = ctrls[0];
      var ngModelCtrl = ctrls[1];
      var multiple = attr.multiple;
      var emptyOption;
      for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
        if (children[i].value === '') {
          emptyOption = children.eq(i);
          break;
        }
      }
      var providedEmptyOption = !!emptyOption;
      var unknownOption = jqLite(optionTemplate.cloneNode(false));
      unknownOption.val('?');
      var options;
      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
      var listFragment = $document[0].createDocumentFragment();
      var renderEmptyOption = function() {
        if (!providedEmptyOption) {
          selectElement.prepend(emptyOption);
        }
        selectElement.val('');
        emptyOption.prop('selected', true);
        emptyOption.attr('selected', true);
      };
      var removeEmptyOption = function() {
        if (!providedEmptyOption) {
          emptyOption.remove();
        }
      };
      var renderUnknownOption = function() {
        selectElement.prepend(unknownOption);
        selectElement.val('?');
        unknownOption.prop('selected', true);
        unknownOption.attr('selected', true);
      };
      var removeUnknownOption = function() {
        unknownOption.remove();
      };
      if (!multiple) {
        selectCtrl.writeValue = function writeNgOptionsValue(value) {
          var option = options.getOptionFromViewValue(value);
          if (option) {
            if (selectElement[0].value !== option.selectValue) {
              removeUnknownOption();
              removeEmptyOption();
              selectElement[0].value = option.selectValue;
              option.element.selected = true;
            }
            option.element.setAttribute('selected', 'selected');
          } else {
            if (value === null || providedEmptyOption) {
              removeUnknownOption();
              renderEmptyOption();
            } else {
              removeEmptyOption();
              renderUnknownOption();
            }
          }
        };
        selectCtrl.readValue = function readNgOptionsValue() {
          var selectedOption = options.selectValueMap[selectElement.val()];
          if (selectedOption && !selectedOption.disabled) {
            removeEmptyOption();
            removeUnknownOption();
            return options.getViewValueFromOption(selectedOption);
          }
          return null;
        };
        if (ngOptions.trackBy) {
          scope.$watch(
            function() {
              return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            },
            function() {
              ngModelCtrl.$render();
            }
          );
        }
      } else {
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
        selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
          options.items.forEach(function(option) {
            option.element.selected = false;
          });
          if (value) {
            value.forEach(function(item) {
              var option = options.getOptionFromViewValue(item);
              if (option) option.element.selected = true;
            });
          }
        };
        selectCtrl.readValue = function readNgOptionsMultiple() {
          var selectedValues = selectElement.val() || [],
            selections = [];
          forEach(selectedValues, function(value) {
            var option = options.selectValueMap[value];
            if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
          });
          return selections;
        };
        if (ngOptions.trackBy) {
          scope.$watchCollection(function() {
            if (isArray(ngModelCtrl.$viewValue)) {
              return ngModelCtrl.$viewValue.map(function(value) {
                return ngOptions.getTrackByValue(value);
              });
            }
          }, function() {
            ngModelCtrl.$render();
          });
        }
      }
      if (providedEmptyOption) {
        emptyOption.remove();
        $compile(emptyOption)(scope);
        emptyOption.removeClass('ng-scope');
      } else {
        emptyOption = jqLite(optionTemplate.cloneNode(false));
      }
      selectElement.empty();
      updateOptions();
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);

      function addOptionElement(option, parent) {
        var optionElement = optionTemplate.cloneNode(false);
        parent.appendChild(optionElement);
        updateOptionElement(option, optionElement);
      }

      function updateOptionElement(option, element) {
        option.element = element;
        element.disabled = option.disabled;
        if (option.label !== element.label) {
          element.label = option.label;
          element.textContent = option.label;
        }
        if (option.value !== element.value) element.value = option.selectValue;
      }

      function updateOptions() {
        var previousValue = options && selectCtrl.readValue();
        if (options) {
          for (var i = options.items.length - 1; i >= 0; i--) {
            var option = options.items[i];
            if (isDefined(option.group)) {
              jqLiteRemove(option.element.parentNode);
            } else {
              jqLiteRemove(option.element);
            }
          }
        }
        options = ngOptions.getOptions();
        var groupElementMap = {};
        if (providedEmptyOption) {
          selectElement.prepend(emptyOption);
        }
        options.items.forEach(function addOption(option) {
          var groupElement;
          if (isDefined(option.group)) {
            groupElement = groupElementMap[option.group];
            if (!groupElement) {
              groupElement = optGroupTemplate.cloneNode(false);
              listFragment.appendChild(groupElement);
              groupElement.label = option.group === null ? 'null' : option.group;
              groupElementMap[option.group] = groupElement;
            }
            addOptionElement(option, groupElement);
          } else {
            addOptionElement(option, listFragment);
          }
        });
        selectElement[0].appendChild(listFragment);
        ngModelCtrl.$render();
        if (!ngModelCtrl.$isEmpty(previousValue)) {
          var nextValue = selectCtrl.readValue();
          var isNotPrimitive = ngOptions.trackBy || multiple;
          if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          }
        }
      }
    }
    return {
      restrict: 'A',
      terminal: true,
      require: ['select', 'ngModel'],
      link: {
        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
          ctrls[0].registerOption = noop;
        },
        post: ngOptionsPostLink
      }
    };
  }];
  var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
    var BRACE = /{}/g,
      IS_WHEN = /^when(Minus)?(.+)$/;
    return {
      link: function(scope, element, attr) {
        var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when),
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || {},
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
          watchRemover = angular.noop,
          lastCount;
        forEach(attr, function(expression, attributeName) {
          var tmpMatch = IS_WHEN.exec(attributeName);
          if (tmpMatch) {
            var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
            whens[whenKey] = element.attr(attr.$attr[attributeName]);
          }
        });
        forEach(whens, function(expression, key) {
          whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
        });
        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
          var count = parseFloat(newVal);
          var countIsNaN = isNaN(count);
          if (!countIsNaN && !(count in whens)) {
            count = $locale.pluralCat(count - offset);
          }
          if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
            watchRemover();
            var whenExpFn = whensExpFns[count];
            if (isUndefined(whenExpFn)) {
              if (newVal != null) {
                $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
              }
              watchRemover = noop;
              updateElementText();
            } else {
              watchRemover = scope.$watch(whenExpFn, updateElementText);
            }
            lastCount = count;
          }
        });

        function updateElementText(newText) {
          element.text(newText || '');
        }
      }
    };
  }];
  var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
    var NG_REMOVED = '$$NG_REMOVED';
    var ngRepeatMinErr = minErr('ngRepeat');
    var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
      scope[valueIdentifier] = value;
      if (keyIdentifier) scope[keyIdentifier] = key;
      scope.$index = index;
      scope.$first = (index === 0);
      scope.$last = (index === (arrayLength - 1));
      scope.$middle = !(scope.$first || scope.$last);
      scope.$odd = !(scope.$even = (index & 1) === 0);
    };
    var getBlockStart = function(block) {
      return block.clone[0];
    };
    var getBlockEnd = function(block) {
      return block.clone[block.clone.length - 1];
    };
    return {
      restrict: 'A',
      multiElement: true,
      transclude: 'element',
      priority: 1000,
      terminal: true,
      $$tlb: true,
      compile: function ngRepeatCompile($element, $attr) {
        var expression = $attr.ngRepeat;
        var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }
        var lhs = match[1];
        var rhs = match[2];
        var aliasAs = match[3];
        var trackByExp = match[4];
        match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
            lhs);
        }
        var valueIdentifier = match[3] || match[1];
        var keyIdentifier = match[2];
        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
            /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
          throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
            aliasAs);
        }
        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
        var hashFnLocals = {
          $id: hashKey
        };
        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }
        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
          if (trackByExpGetter) {
            trackByIdExpFn = function(key, value, index) {
              if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
              hashFnLocals[valueIdentifier] = value;
              hashFnLocals.$index = index;
              return trackByExpGetter($scope, hashFnLocals);
            };
          }
          var lastBlockMap = createMap();
          $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
            var index, length,
              previousNode = $element[0],
              nextNode,
              nextBlockMap = createMap(),
              collectionLength,
              key, value,
              trackById,
              trackByIdFn,
              collectionKeys,
              block,
              nextBlockOrder,
              elementsToRemove;
            if (aliasAs) {
              $scope[aliasAs] = collection;
            }
            if (isArrayLike(collection)) {
              collectionKeys = collection;
              trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
            } else {
              trackByIdFn = trackByIdExpFn || trackByIdObjFn;
              collectionKeys = [];
              for (var itemKey in collection) {
                if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                  collectionKeys.push(itemKey);
                }
              }
            }
            collectionLength = collectionKeys.length;
            nextBlockOrder = new Array(collectionLength);
            for (index = 0; index < collectionLength; index++) {
              key = (collection === collectionKeys) ? index : collectionKeys[index];
              value = collection[key];
              trackById = trackByIdFn(key, value, index);
              if (lastBlockMap[trackById]) {
                block = lastBlockMap[trackById];
                delete lastBlockMap[trackById];
                nextBlockMap[trackById] = block;
                nextBlockOrder[index] = block;
              } else if (nextBlockMap[trackById]) {
                forEach(nextBlockOrder, function(block) {
                  if (block && block.scope) lastBlockMap[block.id] = block;
                });
                throw ngRepeatMinErr('dupes',
                  "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                  expression, trackById, value);
              } else {
                nextBlockOrder[index] = {
                  id: trackById,
                  scope: undefined,
                  clone: undefined
                };
                nextBlockMap[trackById] = true;
              }
            }
            for (var blockKey in lastBlockMap) {
              block = lastBlockMap[blockKey];
              elementsToRemove = getBlockNodes(block.clone);
              $animate.leave(elementsToRemove);
              if (elementsToRemove[0].parentNode) {
                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                  elementsToRemove[index][NG_REMOVED] = true;
                }
              }
              block.scope.$destroy();
            }
            for (index = 0; index < collectionLength; index++) {
              key = (collection === collectionKeys) ? index : collectionKeys[index];
              value = collection[key];
              block = nextBlockOrder[index];
              if (block.scope) {
                nextNode = previousNode;
                do {
                  nextNode = nextNode.nextSibling;
                } while (nextNode && nextNode[NG_REMOVED]);
                if (getBlockStart(block) != nextNode) {
                  $animate.move(getBlockNodes(block.clone), null, previousNode);
                }
                previousNode = getBlockEnd(block);
                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
              } else {
                $transclude(function ngRepeatTransclude(clone, scope) {
                  block.scope = scope;
                  var endNode = ngRepeatEndComment.cloneNode(false);
                  clone[clone.length++] = endNode;
                  $animate.enter(clone, null, previousNode);
                  previousNode = endNode;
                  block.clone = clone;
                  nextBlockMap[block.id] = block;
                  updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                });
              }
            }
            lastBlockMap = nextBlockMap;
          });
        };
      }
    };
  }];
  var NG_HIDE_CLASS = 'ng-hide';
  var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
  var ngShowDirective = ['$animate', function($animate) {
    return {
      restrict: 'A',
      multiElement: true,
      link: function(scope, element, attr) {
        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
          $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
          });
        });
      }
    };
  }];
  var ngHideDirective = ['$animate', function($animate) {
    return {
      restrict: 'A',
      multiElement: true,
      link: function(scope, element, attr) {
        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
          $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
          });
        });
      }
    };
  }];
  var ngStyleDirective = ngDirective(function(scope, element, attr) {
    scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
      if (oldStyles && (newStyles !== oldStyles)) {
        forEach(oldStyles, function(val, style) {
          element.css(style, '');
        });
      }
      if (newStyles) element.css(newStyles);
    }, true);
  });
  var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
    return {
      require: 'ngSwitch',
      controller: ['$scope', function ngSwitchController() {
        this.cases = {};
      }],
      link: function(scope, element, attr, ngSwitchController) {
        var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes = [],
          selectedElements = [],
          previousLeaveAnimations = [],
          selectedScopes = [];
        var spliceFactory = function(array, index) {
          return function() {
            array.splice(index, 1);
          };
        };
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          var i, ii;
          for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
            $animate.cancel(previousLeaveAnimations[i]);
          }
          previousLeaveAnimations.length = 0;
          for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
            var selected = getBlockNodes(selectedElements[i].clone);
            selectedScopes[i].$destroy();
            var promise = previousLeaveAnimations[i] = $animate.leave(selected);
            promise.then(spliceFactory(previousLeaveAnimations, i));
          }
          selectedElements.length = 0;
          selectedScopes.length = 0;
          if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
            forEach(selectedTranscludes, function(selectedTransclude) {
              selectedTransclude.transclude(function(caseElement, selectedScope) {
                selectedScopes.push(selectedScope);
                var anchor = selectedTransclude.element;
                caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                var block = {
                  clone: caseElement
                };
                selectedElements.push(block);
                $animate.enter(caseElement, anchor.parent(), anchor);
              });
            });
          }
        });
      }
    };
  }];
  var ngSwitchWhenDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function(scope, element, attrs, ctrl, $transclude) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngSwitchDefaultDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function(scope, element, attr, ctrl, $transclude) {
      ctrl.cases['?'] = (ctrl.cases['?'] || []);
      ctrl.cases['?'].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngTranscludeMinErr = minErr('ngTransclude');
  var ngTranscludeDirective = ['$compile', function($compile) {
    return {
      restrict: 'EAC',
      terminal: true,
      compile: function ngTranscludeCompile(tElement) {
        var fallbackLinkFn = $compile(tElement.contents());
        tElement.empty();
        return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan',
              'Illegal use of ngTransclude directive in the template! ' +
              'No parent directive that requires a transclusion found. ' +
              'Element: {0}',
              startingTag($element));
          }
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
          if (slotName && !$transclude.isSlotFilled(slotName)) {
            useFallbackContent();
          }

          function ngTranscludeCloneAttachFn(clone, transcludedScope) {
            if (clone.length) {
              $element.append(clone);
            } else {
              useFallbackContent();
              transcludedScope.$destroy();
            }
          }

          function useFallbackContent() {
            fallbackLinkFn($scope, function(clone) {
              $element.append(clone);
            });
          }
        };
      }
    };
  }];
  var scriptDirective = ['$templateCache', function($templateCache) {
    return {
      restrict: 'E',
      terminal: true,
      compile: function(element, attr) {
        if (attr.type == 'text/ng-template') {
          var templateUrl = attr.id,
            text = element[0].text;
          $templateCache.put(templateUrl, text);
        }
      }
    };
  }];
  var noopNgModelController = {
    $setViewValue: noop,
    $render: noop
  };

  function chromeHack(optionElement) {
    if (optionElement[0].hasAttribute('selected')) {
      optionElement[0].selected = true;
    }
  }
  var SelectController = ['$element', '$scope', function($element, $scope) {
    var self = this,
      optionsMap = new HashMap();
    self.ngModelCtrl = noopNgModelController;
    self.unknownOption = jqLite(window.document.createElement('option'));
    self.renderUnknownOption = function(val) {
      var unknownVal = '? ' + hashKey(val) + ' ?';
      self.unknownOption.val(unknownVal);
      $element.prepend(self.unknownOption);
      $element.val(unknownVal);
    };
    $scope.$on('$destroy', function() {
      self.renderUnknownOption = noop;
    });
    self.removeUnknownOption = function() {
      if (self.unknownOption.parent()) self.unknownOption.remove();
    };
    self.readValue = function readSingleValue() {
      self.removeUnknownOption();
      return $element.val();
    };
    self.writeValue = function writeSingleValue(value) {
      if (self.hasOption(value)) {
        self.removeUnknownOption();
        $element.val(value);
        if (value === '') self.emptyOption.prop('selected', true);
      } else {
        if (value == null && self.emptyOption) {
          self.removeUnknownOption();
          $element.val('');
        } else {
          self.renderUnknownOption(value);
        }
      }
    };
    self.addOption = function(value, element) {
      if (element[0].nodeType === NODE_TYPE_COMMENT) return;
      assertNotHasOwnProperty(value, '"option value"');
      if (value === '') {
        self.emptyOption = element;
      }
      var count = optionsMap.get(value) || 0;
      optionsMap.put(value, count + 1);
      self.ngModelCtrl.$render();
      chromeHack(element);
    };
    self.removeOption = function(value) {
      var count = optionsMap.get(value);
      if (count) {
        if (count === 1) {
          optionsMap.remove(value);
          if (value === '') {
            self.emptyOption = undefined;
          }
        } else {
          optionsMap.put(value, count - 1);
        }
      }
    };
    self.hasOption = function(value) {
      return !!optionsMap.get(value);
    };
    self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
      if (interpolateValueFn) {
        var oldVal;
        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
          if (isDefined(oldVal)) {
            self.removeOption(oldVal);
          }
          oldVal = newVal;
          self.addOption(newVal, optionElement);
        });
      } else if (interpolateTextFn) {
        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
          optionAttrs.$set('value', newVal);
          if (oldVal !== newVal) {
            self.removeOption(oldVal);
          }
          self.addOption(newVal, optionElement);
        });
      } else {
        self.addOption(optionAttrs.value, optionElement);
      }
      optionElement.on('$destroy', function() {
        self.removeOption(optionAttrs.value);
        self.ngModelCtrl.$render();
      });
    };
  }];
  var selectDirective = function() {
    return {
      restrict: 'E',
      require: ['select', '?ngModel'],
      controller: SelectController,
      priority: 1,
      link: {
        pre: selectPreLink,
        post: selectPostLink
      }
    };

    function selectPreLink(scope, element, attr, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      selectCtrl.ngModelCtrl = ngModelCtrl;
      element.on('change', function() {
        scope.$apply(function() {
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        });
      });
      if (attr.multiple) {
        selectCtrl.readValue = function readMultipleValue() {
          var array = [];
          forEach(element.find('option'), function(option) {
            if (option.selected) {
              array.push(option.value);
            }
          });
          return array;
        };
        selectCtrl.writeValue = function writeMultipleValue(value) {
          var items = new HashMap(value);
          forEach(element.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };
        var lastView, lastViewRef = NaN;
        scope.$watch(function selectMultipleWatch() {
          if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          }
          lastViewRef = ngModelCtrl.$viewValue;
        });
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      }
    }

    function selectPostLink(scope, element, attrs, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      ngModelCtrl.$render = function() {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      };
    }
  };
  var optionDirective = ['$interpolate', function($interpolate) {
    return {
      restrict: 'E',
      priority: 100,
      compile: function(element, attr) {
        if (isDefined(attr.value)) {
          var interpolateValueFn = $interpolate(attr.value, true);
        } else {
          var interpolateTextFn = $interpolate(element.text(), true);
          if (!interpolateTextFn) {
            attr.$set('value', element.text());
          }
        }
        return function(scope, element, attr) {
          var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
            parent.parent().data(selectCtrlName);
          if (selectCtrl) {
            selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
          }
        };
      }
    };
  }];
  var styleDirective = valueFn({
    restrict: 'E',
    terminal: false
  });
  var requiredDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        attr.required = true;
        ctrl.$validators.required = function(modelValue, viewValue) {
          return !attr.required || !ctrl.$isEmpty(viewValue);
        };
        attr.$observe('required', function() {
          ctrl.$validate();
        });
      }
    };
  };
  var patternDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var regexp, patternExp = attr.ngPattern || attr.pattern;
        attr.$observe('pattern', function(regex) {
          if (isString(regex) && regex.length > 0) {
            regex = new RegExp('^' + regex + '$');
          }
          if (regex && !regex.test) {
            throw minErr('ngPattern')('noregexp',
              'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp,
              regex, startingTag(elm));
          }
          regexp = regex || undefined;
          ctrl.$validate();
        });
        ctrl.$validators.pattern = function(modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
        };
      }
    };
  };
  var maxlengthDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var maxlength = -1;
        attr.$observe('maxlength', function(value) {
          var intVal = toInt(value);
          maxlength = isNaN(intVal) ? -1 : intVal;
          ctrl.$validate();
        });
        ctrl.$validators.maxlength = function(modelValue, viewValue) {
          return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
        };
      }
    };
  };
  var minlengthDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var minlength = 0;
        attr.$observe('minlength', function(value) {
          minlength = toInt(value) || 0;
          ctrl.$validate();
        });
        ctrl.$validators.minlength = function(modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
        };
      }
    };
  };
  if (window.angular.bootstrap) {
    if (window.console) {
      console.log('WARNING: Tried to load angular more than once.');
    }
    return;
  }
  bindJQuery();
  publishExternalAPI(angular);
  angular.module("ngLocale", [], ["$provide", function($provide) {
    var PLURAL_CATEGORY = {
      ZERO: "zero",
      ONE: "one",
      TWO: "two",
      FEW: "few",
      MANY: "many",
      OTHER: "other"
    };

    function getDecimals(n) {
      n = n + '';
      var i = n.indexOf('.');
      return (i == -1) ? 0 : n.length - i - 1;
    }

    function getVF(n, opt_precision) {
      var v = opt_precision;
      if (undefined === v) {
        v = Math.min(getDecimals(n), 3);
      }
      var base = Math.pow(10, v);
      var f = ((n * base) | 0) % base;
      return {
        v: v,
        f: f
      };
    }
    $provide.value("$locale", {
      "DATETIME_FORMATS": {
        "AMPMS": [
          "AM",
          "PM"
        ],
        "DAY": [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ],
        "ERANAMES": [
          "Before Christ",
          "Anno Domini"
        ],
        "ERAS": [
          "BC",
          "AD"
        ],
        "FIRSTDAYOFWEEK": 6,
        "MONTH": [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        "SHORTDAY": [
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat"
        ],
        "SHORTMONTH": [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        "STANDALONEMONTH": [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        "WEEKENDRANGE": [
          5,
          6
        ],
        "fullDate": "EEEE, MMMM d, y",
        "longDate": "MMMM d, y",
        "medium": "MMM d, y h:mm:ss a",
        "mediumDate": "MMM d, y",
        "mediumTime": "h:mm:ss a",
        "short": "M/d/yy h:mm a",
        "shortDate": "M/d/yy",
        "shortTime": "h:mm a"
      },
      "NUMBER_FORMATS": {
        "CURRENCY_SYM": "$",
        "DECIMAL_SEP": ".",
        "GROUP_SEP": ",",
        "PATTERNS": [{
            "gSize": 3,
            "lgSize": 3,
            "maxFrac": 3,
            "minFrac": 0,
            "minInt": 1,
            "negPre": "-",
            "negSuf": "",
            "posPre": "",
            "posSuf": ""
          },
          {
            "gSize": 3,
            "lgSize": 3,
            "maxFrac": 2,
            "minFrac": 2,
            "minInt": 1,
            "negPre": "-\u00a4",
            "negSuf": "",
            "posPre": "\u00a4",
            "posSuf": ""
          }
        ]
      },
      "id": "en-us",
      "localeID": "en_US",
      "pluralCat": function(n, opt_precision) {
        var i = n | 0;
        var vf = getVF(n, opt_precision);
        if (i == 1 && vf.v == 0) {
          return PLURAL_CATEGORY.ONE;
        }
        return PLURAL_CATEGORY.OTHER;
      }
    });
  }]);
  jqLite(window.document).ready(function() {
    angularInit(window.document, bootstrap);
  });
})(window);
!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');;
/*! RESOURCE: /scripts/angular_1.5.8/angular-sanitize.js */
(function(window, angular) {
  'use strict';
  var $sanitizeMinErr = angular.$$minErr('$sanitize');
  var bind;
  var extend;
  var forEach;
  var isDefined;
  var lowercase;
  var noop;
  var htmlParser;
  var htmlSanitizeWriter;

  function $SanitizeProvider() {
    var svgEnabled = false;
    this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
      if (svgEnabled) {
        extend(validElements, svgElements);
      }
      return function(html) {
        var buf = [];
        htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
          return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
        }));
        return buf.join('');
      };
    }];
    this.enableSvg = function(enableSvg) {
      if (isDefined(enableSvg)) {
        svgEnabled = enableSvg;
        return this;
      } else {
        return svgEnabled;
      }
    };
    bind = angular.bind;
    extend = angular.extend;
    forEach = angular.forEach;
    isDefined = angular.isDefined;
    lowercase = angular.lowercase;
    noop = angular.noop;
    htmlParser = htmlParserImpl;
    htmlSanitizeWriter = htmlSanitizeWriterImpl;
    var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    var voidElements = toMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
      optionalEndTagInlineElements = toMap("rp,rt"),
      optionalEndTagElements = extend({},
        optionalEndTagInlineElements,
        optionalEndTagBlockElements);
    var blockElements = extend({}, optionalEndTagBlockElements, toMap("address,article," +
      "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
      "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
    var inlineElements = extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
      "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
      "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
      "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
      "radialGradient,rect,stop,svg,switch,text,title,tspan");
    var blockedElements = toMap("script,style");
    var validElements = extend({},
      voidElements,
      blockElements,
      inlineElements,
      optionalEndTagElements);
    var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
    var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
      'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
      'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
      'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
      'valign,value,vspace,width');
    var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
      'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
      'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
      'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
      'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
      'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
      'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
      'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
      'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
      'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
      'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
      'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
      'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
      'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
      'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
    var validAttrs = extend({},
      uriAttrs,
      svgAttrs,
      htmlAttrs);

    function toMap(str, lowercaseKeys) {
      var obj = {},
        items = str.split(','),
        i;
      for (i = 0; i < items.length; i++) {
        obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
      }
      return obj;
    }
    var inertBodyElement;
    (function(window) {
      var doc;
      if (window.document && window.document.implementation) {
        doc = window.document.implementation.createHTMLDocument("inert");
      } else {
        throw $sanitizeMinErr('noinert', "Can't create an inert html document");
      }
      var docElement = doc.documentElement || doc.getDocumentElement();
      var bodyElements = docElement.getElementsByTagName('body');
      if (bodyElements.length === 1) {
        inertBodyElement = bodyElements[0];
      } else {
        var html = doc.createElement('html');
        inertBodyElement = doc.createElement('body');
        html.appendChild(inertBodyElement);
        doc.appendChild(html);
      }
    })(window);

    function htmlParserImpl(html, handler) {
      if (html === null || html === undefined) {
        html = '';
      } else if (typeof html !== 'string') {
        html = '' + html;
      }
      inertBodyElement.innerHTML = html;
      var mXSSAttempts = 5;
      do {
        if (mXSSAttempts === 0) {
          throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
        }
        mXSSAttempts--;
        if (window.document.documentMode) {
          stripCustomNsAttrs(inertBodyElement);
        }
        html = inertBodyElement.innerHTML;
        inertBodyElement.innerHTML = html;
      } while (html !== inertBodyElement.innerHTML);
      var node = inertBodyElement.firstChild;
      while (node) {
        switch (node.nodeType) {
          case 1:
            handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
            break;
          case 3:
            handler.chars(node.textContent);
            break;
        }
        var nextNode;
        if (!(nextNode = node.firstChild)) {
          if (node.nodeType == 1) {
            handler.end(node.nodeName.toLowerCase());
          }
          nextNode = node.nextSibling;
          if (!nextNode) {
            while (nextNode == null) {
              node = node.parentNode;
              if (node === inertBodyElement) break;
              nextNode = node.nextSibling;
              if (node.nodeType == 1) {
                handler.end(node.nodeName.toLowerCase());
              }
            }
          }
        }
        node = nextNode;
      }
      while (node = inertBodyElement.firstChild) {
        inertBodyElement.removeChild(node);
      }
    }

    function attrToMap(attrs) {
      var map = {};
      for (var i = 0, ii = attrs.length; i < ii; i++) {
        var attr = attrs[i];
        map[attr.name] = attr.value;
      }
      return map;
    }

    function encodeEntities(value) {
      return value.
      replace(/&/g, '&amp;').
      replace(SURROGATE_PAIR_REGEXP, function(value) {
        var hi = value.charCodeAt(0);
        var low = value.charCodeAt(1);
        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
      }).
      replace(NON_ALPHANUMERIC_REGEXP, function(value) {
        return '&#' + value.charCodeAt(0) + ';';
      }).
      replace(/</g, '&lt;').
      replace(/>/g, '&gt;');
    }

    function htmlSanitizeWriterImpl(buf, uriValidator) {
      var ignoreCurrentElement = false;
      var out = bind(buf, buf.push);
      return {
        start: function(tag, attrs) {
          tag = lowercase(tag);
          if (!ignoreCurrentElement && blockedElements[tag]) {
            ignoreCurrentElement = tag;
          }
          if (!ignoreCurrentElement && validElements[tag] === true) {
            out('<');
            out(tag);
            forEach(attrs, function(value, key) {
              var lkey = lowercase(key);
              var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
              if (validAttrs[lkey] === true &&
                (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                out(' ');
                out(key);
                out('="');
                out(encodeEntities(value));
                out('"');
              }
            });
            out('>');
          }
        },
        end: function(tag) {
          tag = lowercase(tag);
          if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
            out('</');
            out(tag);
            out('>');
          }
          if (tag == ignoreCurrentElement) {
            ignoreCurrentElement = false;
          }
        },
        chars: function(chars) {
          if (!ignoreCurrentElement) {
            out(encodeEntities(chars));
          }
        }
      };
    }

    function stripCustomNsAttrs(node) {
      if (node.nodeType === window.Node.ELEMENT_NODE) {
        var attrs = node.attributes;
        for (var i = 0, l = attrs.length; i < l; i++) {
          var attrNode = attrs[i];
          var attrName = attrNode.name.toLowerCase();
          if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
            node.removeAttributeNode(attrNode);
            i--;
            l--;
          }
        }
      }
      var nextNode = node.firstChild;
      if (nextNode) {
        stripCustomNsAttrs(nextNode);
      }
      nextNode = node.nextSibling;
      if (nextNode) {
        stripCustomNsAttrs(nextNode);
      }
    }
  }

  function sanitizeText(chars) {
    var buf = [];
    var writer = htmlSanitizeWriter(buf, noop);
    writer.chars(chars);
    return buf.join('');
  }
  angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
  angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
    var LINKY_URL_REGEXP =
      /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;
    var linkyMinErr = angular.$$minErr('linky');
    var isDefined = angular.isDefined;
    var isFunction = angular.isFunction;
    var isObject = angular.isObject;
    var isString = angular.isString;
    return function(text, target, attributes) {
      if (text == null || text === '') return text;
      if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
      var attributesFn =
        isFunction(attributes) ? attributes :
        isObject(attributes) ? function getAttributesObject() {
          return attributes;
        } :
        function getEmptyAttributesObject() {
          return {};
        };
      var match;
      var raw = text;
      var html = [];
      var url;
      var i;
      while ((match = raw.match(LINKY_URL_REGEXP))) {
        url = match[0];
        if (!match[2] && !match[4]) {
          url = (match[3] ? 'http://' : 'mailto:') + url;
        }
        i = match.index;
        addText(raw.substr(0, i));
        addLink(url, match[0].replace(MAILTO_REGEXP, ''));
        raw = raw.substring(i + match[0].length);
      }
      addText(raw);
      return $sanitize(html.join(''));

      function addText(text) {
        if (!text) {
          return;
        }
        html.push(sanitizeText(text));
      }

      function addLink(url, text) {
        var key, linkAttributes = attributesFn(url);
        html.push('<a ');
        for (key in linkAttributes) {
          html.push(key + '="' + linkAttributes[key] + '" ');
        }
        if (isDefined(target) && !('target' in linkAttributes)) {
          html.push('target="',
            target,
            '" ');
        }
        html.push('href="',
          url.replace(/"/g, '&quot;'),
          '">');
        addText(text);
        html.push('</a>');
      }
    };
  }]);
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-animate.js */
(function(window, angular) {
  'use strict';
  var ELEMENT_NODE = 1;
  var COMMENT_NODE = 8;
  var ADD_CLASS_SUFFIX = '-add';
  var REMOVE_CLASS_SUFFIX = '-remove';
  var EVENT_CLASS_PREFIX = 'ng-';
  var ACTIVE_CLASS_SUFFIX = '-active';
  var PREPARE_CLASS_SUFFIX = '-prepare';
  var NG_ANIMATE_CLASSNAME = 'ng-animate';
  var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
  var CSS_PREFIX = '',
    TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
  if ((window.ontransitionend === void 0) && (window.onwebkittransitionend !== void 0)) {
    CSS_PREFIX = '-webkit-';
    TRANSITION_PROP = 'WebkitTransition';
    TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
  } else {
    TRANSITION_PROP = 'transition';
    TRANSITIONEND_EVENT = 'transitionend';
  }
  if ((window.onanimationend === void 0) && (window.onwebkitanimationend !== void 0)) {
    CSS_PREFIX = '-webkit-';
    ANIMATION_PROP = 'WebkitAnimation';
    ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
  } else {
    ANIMATION_PROP = 'animation';
    ANIMATIONEND_EVENT = 'animationend';
  }
  var DURATION_KEY = 'Duration';
  var PROPERTY_KEY = 'Property';
  var DELAY_KEY = 'Delay';
  var TIMING_KEY = 'TimingFunction';
  var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
  var ANIMATION_PLAYSTATE_KEY = 'PlayState';
  var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
  var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
  var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
  var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
  var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
  var ngMinErr = angular.$$minErr('ng');

  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
    }
    return arg;
  }

  function mergeClasses(a, b) {
    if (!a && !b) return '';
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(' ');
    if (isArray(b)) b = b.join(' ');
    return a + ' ' + b;
  }

  function packageStyles(options) {
    var styles = {};
    if (options && (options.to || options.from)) {
      styles.to = options.to;
      styles.from = options.from;
    }
    return styles;
  }

  function pendClasses(classes, fix, isPrefix) {
    var className = '';
    classes = isArray(classes) ?
      classes :
      classes && isString(classes) && classes.length ?
      classes.split(/\s+/) :
      [];
    forEach(classes, function(klass, i) {
      if (klass && klass.length > 0) {
        className += (i > 0) ? ' ' : '';
        className += isPrefix ? fix + klass :
          klass + fix;
      }
    });
    return className;
  }

  function removeFromArray(arr, val) {
    var index = arr.indexOf(val);
    if (val >= 0) {
      arr.splice(index, 1);
    }
  }

  function stripCommentsFromElement(element) {
    if (element instanceof jqLite) {
      switch (element.length) {
        case 0:
          return element;
        case 1:
          if (element[0].nodeType === ELEMENT_NODE) {
            return element;
          }
          break;
        default:
          return jqLite(extractElementNode(element));
      }
    }
    if (element.nodeType === ELEMENT_NODE) {
      return jqLite(element);
    }
  }

  function extractElementNode(element) {
    if (!element[0]) return element;
    for (var i = 0; i < element.length; i++) {
      var elm = element[i];
      if (elm.nodeType == ELEMENT_NODE) {
        return elm;
      }
    }
  }

  function $$addClass($$jqLite, element, className) {
    forEach(element, function(elm) {
      $$jqLite.addClass(elm, className);
    });
  }

  function $$removeClass($$jqLite, element, className) {
    forEach(element, function(elm) {
      $$jqLite.removeClass(elm, className);
    });
  }

  function applyAnimationClassesFactory($$jqLite) {
    return function(element, options) {
      if (options.addClass) {
        $$addClass($$jqLite, element, options.addClass);
        options.addClass = null;
      }
      if (options.removeClass) {
        $$removeClass($$jqLite, element, options.removeClass);
        options.removeClass = null;
      }
    };
  }

  function prepareAnimationOptions(options) {
    options = options || {};
    if (!options.$$prepared) {
      var domOperation = options.domOperation || noop;
      options.domOperation = function() {
        options.$$domOperationFired = true;
        domOperation();
        domOperation = noop;
      };
      options.$$prepared = true;
    }
    return options;
  }

  function applyAnimationStyles(element, options) {
    applyAnimationFromStyles(element, options);
    applyAnimationToStyles(element, options);
  }

  function applyAnimationFromStyles(element, options) {
    if (options.from) {
      element.css(options.from);
      options.from = null;
    }
  }

  function applyAnimationToStyles(element, options) {
    if (options.to) {
      element.css(options.to);
      options.to = null;
    }
  }

  function mergeAnimationDetails(element, oldAnimation, newAnimation) {
    var target = oldAnimation.options || {};
    var newOptions = newAnimation.options || {};
    var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
    var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
    var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
    if (newOptions.preparationClasses) {
      target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
      delete newOptions.preparationClasses;
    }
    var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
    extend(target, newOptions);
    if (realDomOperation) {
      target.domOperation = realDomOperation;
    }
    if (classes.addClass) {
      target.addClass = classes.addClass;
    } else {
      target.addClass = null;
    }
    if (classes.removeClass) {
      target.removeClass = classes.removeClass;
    } else {
      target.removeClass = null;
    }
    oldAnimation.addClass = target.addClass;
    oldAnimation.removeClass = target.removeClass;
    return target;
  }

  function resolveElementClasses(existing, toAdd, toRemove) {
    var ADD_CLASS = 1;
    var REMOVE_CLASS = -1;
    var flags = {};
    existing = splitClassesToLookup(existing);
    toAdd = splitClassesToLookup(toAdd);
    forEach(toAdd, function(value, key) {
      flags[key] = ADD_CLASS;
    });
    toRemove = splitClassesToLookup(toRemove);
    forEach(toRemove, function(value, key) {
      flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
    });
    var classes = {
      addClass: '',
      removeClass: ''
    };
    forEach(flags, function(val, klass) {
      var prop, allow;
      if (val === ADD_CLASS) {
        prop = 'addClass';
        allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
      } else if (val === REMOVE_CLASS) {
        prop = 'removeClass';
        allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
      }
      if (allow) {
        if (classes[prop].length) {
          classes[prop] += ' ';
        }
        classes[prop] += klass;
      }
    });

    function splitClassesToLookup(classes) {
      if (isString(classes)) {
        classes = classes.split(' ');
      }
      var obj = {};
      forEach(classes, function(klass) {
        if (klass.length) {
          obj[klass] = true;
        }
      });
      return obj;
    }
    return classes;
  }

  function getDomNode(element) {
    return (element instanceof jqLite) ? element[0] : element;
  }

  function applyGeneratedPreparationClasses(element, event, options) {
    var classes = '';
    if (event) {
      classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
    }
    if (options.addClass) {
      classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
    }
    if (options.removeClass) {
      classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
    }
    if (classes.length) {
      options.preparationClasses = classes;
      element.addClass(classes);
    }
  }

  function clearGeneratedClasses(element, options) {
    if (options.preparationClasses) {
      element.removeClass(options.preparationClasses);
      options.preparationClasses = null;
    }
    if (options.activeClasses) {
      element.removeClass(options.activeClasses);
      options.activeClasses = null;
    }
  }

  function blockTransitions(node, duration) {
    var value = duration ? '-' + duration + 's' : '';
    applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
    return [TRANSITION_DELAY_PROP, value];
  }

  function blockKeyframeAnimations(node, applyBlock) {
    var value = applyBlock ? 'paused' : '';
    var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
    applyInlineStyle(node, [key, value]);
    return [key, value];
  }

  function applyInlineStyle(node, styleTuple) {
    var prop = styleTuple[0];
    var value = styleTuple[1];
    node.style[prop] = value;
  }

  function concatWithSpace(a, b) {
    if (!a) return b;
    if (!b) return a;
    return a + ' ' + b;
  }
  var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
    var queue, cancelFn;

    function scheduler(tasks) {
      queue = queue.concat(tasks);
      nextTick();
    }
    queue = scheduler.queue = [];
    scheduler.waitUntilQuiet = function(fn) {
      if (cancelFn) cancelFn();
      cancelFn = $$rAF(function() {
        cancelFn = null;
        fn();
        nextTick();
      });
    };
    return scheduler;

    function nextTick() {
      if (!queue.length) return;
      var items = queue.shift();
      for (var i = 0; i < items.length; i++) {
        items[i]();
      }
      if (!cancelFn) {
        $$rAF(function() {
          if (!cancelFn) nextTick();
        });
      }
    }
  }];
  var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
    return {
      link: function(scope, element, attrs) {
        var val = attrs.ngAnimateChildren;
        if (isString(val) && val.length === 0) {
          element.data(NG_ANIMATE_CHILDREN_DATA, true);
        } else {
          setData($interpolate(val)(scope));
          attrs.$observe('ngAnimateChildren', setData);
        }

        function setData(value) {
          value = value === 'on' || value === 'true';
          element.data(NG_ANIMATE_CHILDREN_DATA, value);
        }
      }
    };
  }];
  var ANIMATE_TIMER_KEY = '$$animateCss';
  var ONE_SECOND = 1000;
  var BASE_TEN = 10;
  var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
  var CLOSING_TIME_BUFFER = 1.5;
  var DETECT_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP,
    animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
  };
  var DETECT_STAGGER_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP
  };

  function getCssKeyframeDurationStyle(duration) {
    return [ANIMATION_DURATION_PROP, duration + 's'];
  }

  function getCssDelayStyle(delay, isKeyframeAnimation) {
    var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
    return [prop, delay + 's'];
  }

  function computeCssStyles($window, element, properties) {
    var styles = Object.create(null);
    var detectedStyles = $window.getComputedStyle(element) || {};
    forEach(properties, function(formalStyleName, actualStyleName) {
      var val = detectedStyles[formalStyleName];
      if (val) {
        var c = val.charAt(0);
        if (c === '-' || c === '+' || c >= 0) {
          val = parseMaxTime(val);
        }
        if (val === 0) {
          val = null;
        }
        styles[actualStyleName] = val;
      }
    });
    return styles;
  }

  function parseMaxTime(str) {
    var maxValue = 0;
    var values = str.split(/\s*,\s*/);
    forEach(values, function(value) {
      if (value.charAt(value.length - 1) == 's') {
        value = value.substring(0, value.length - 1);
      }
      value = parseFloat(value) || 0;
      maxValue = maxValue ? Math.max(value, maxValue) : value;
    });
    return maxValue;
  }

  function truthyTimingValue(val) {
    return val === 0 || val != null;
  }

  function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
    var style = TRANSITION_PROP;
    var value = duration + 's';
    if (applyOnlyDuration) {
      style += DURATION_KEY;
    } else {
      value += ' linear all';
    }
    return [style, value];
  }

  function createLocalCacheLookup() {
    var cache = Object.create(null);
    return {
      flush: function() {
        cache = Object.create(null);
      },
      count: function(key) {
        var entry = cache[key];
        return entry ? entry.total : 0;
      },
      get: function(key) {
        var entry = cache[key];
        return entry && entry.value;
      },
      put: function(key, value) {
        if (!cache[key]) {
          cache[key] = {
            total: 1,
            value: value
          };
        } else {
          cache[key].total++;
        }
      }
    };
  }

  function registerRestorableStyles(backup, node, properties) {
    forEach(properties, function(prop) {
      backup[prop] = isDefined(backup[prop]) ?
        backup[prop] :
        node.style.getPropertyValue(prop);
    });
  }
  var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
    var gcsLookup = createLocalCacheLookup();
    var gcsStaggerLookup = createLocalCacheLookup();
    this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
      '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
      function($window, $$jqLite, $$AnimateRunner, $timeout,
        $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        var parentCounter = 0;

        function gcsHashFn(node, extraClasses) {
          var KEY = "$$ngAnimateParentKey";
          var parentNode = node.parentNode;
          var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
          return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
        }

        function computeCachedCssStyles(node, className, cacheKey, properties) {
          var timings = gcsLookup.get(cacheKey);
          if (!timings) {
            timings = computeCssStyles($window, node, properties);
            if (timings.animationIterationCount === 'infinite') {
              timings.animationIterationCount = 1;
            }
          }
          gcsLookup.put(cacheKey, timings);
          return timings;
        }

        function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
          var stagger;
          if (gcsLookup.count(cacheKey) > 0) {
            stagger = gcsStaggerLookup.get(cacheKey);
            if (!stagger) {
              var staggerClassName = pendClasses(className, '-stagger');
              $$jqLite.addClass(node, staggerClassName);
              stagger = computeCssStyles($window, node, properties);
              stagger.animationDuration = Math.max(stagger.animationDuration, 0);
              stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
              $$jqLite.removeClass(node, staggerClassName);
              gcsStaggerLookup.put(cacheKey, stagger);
            }
          }
          return stagger || {};
        }
        var cancelLastRAFRequest;
        var rafWaitQueue = [];

        function waitUntilQuiet(callback) {
          rafWaitQueue.push(callback);
          $$rAFScheduler.waitUntilQuiet(function() {
            gcsLookup.flush();
            gcsStaggerLookup.flush();
            var pageWidth = $$forceReflow();
            for (var i = 0; i < rafWaitQueue.length; i++) {
              rafWaitQueue[i](pageWidth);
            }
            rafWaitQueue.length = 0;
          });
        }

        function computeTimings(node, className, cacheKey) {
          var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
          var aD = timings.animationDelay;
          var tD = timings.transitionDelay;
          timings.maxDelay = aD && tD ?
            Math.max(aD, tD) :
            (aD || tD);
          timings.maxDuration = Math.max(
            timings.animationDuration * timings.animationIterationCount,
            timings.transitionDuration);
          return timings;
        }
        return function init(element, initialOptions) {
          var options = initialOptions || {};
          if (!options.$$prepared) {
            options = prepareAnimationOptions(copy(options));
          }
          var restoreStyles = {};
          var node = getDomNode(element);
          if (!node ||
            !node.parentNode ||
            !$$animateQueue.enabled()) {
            return closeAndReturnNoopAnimator();
          }
          var temporaryStyles = [];
          var classes = element.attr('class');
          var styles = packageStyles(options);
          var animationClosed;
          var animationPaused;
          var animationCompleted;
          var runner;
          var runnerHost;
          var maxDelay;
          var maxDelayTime;
          var maxDuration;
          var maxDurationTime;
          var startTime;
          var events = [];
          if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
            return closeAndReturnNoopAnimator();
          }
          var method = options.event && isArray(options.event) ?
            options.event.join(' ') :
            options.event;
          var isStructural = method && options.structural;
          var structuralClassName = '';
          var addRemoveClassName = '';
          if (isStructural) {
            structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
          } else if (method) {
            structuralClassName = method;
          }
          if (options.addClass) {
            addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
          }
          if (options.removeClass) {
            if (addRemoveClassName.length) {
              addRemoveClassName += ' ';
            }
            addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
          }
          if (options.applyClassesEarly && addRemoveClassName.length) {
            applyAnimationClasses(element, options);
          }
          var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
          var fullClassName = classes + ' ' + preparationClasses;
          var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
          var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
          var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
          if (!containsKeyframeAnimation &&
            !hasToStyles &&
            !preparationClasses) {
            return closeAndReturnNoopAnimator();
          }
          var cacheKey, stagger;
          if (options.stagger > 0) {
            var staggerVal = parseFloat(options.stagger);
            stagger = {
              transitionDelay: staggerVal,
              animationDelay: staggerVal,
              transitionDuration: 0,
              animationDuration: 0
            };
          } else {
            cacheKey = gcsHashFn(node, fullClassName);
            stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
          }
          if (!options.$$skipPreparationClasses) {
            $$jqLite.addClass(element, preparationClasses);
          }
          var applyOnlyDuration;
          if (options.transitionStyle) {
            var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
            applyInlineStyle(node, transitionStyle);
            temporaryStyles.push(transitionStyle);
          }
          if (options.duration >= 0) {
            applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
            var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
            applyInlineStyle(node, durationStyle);
            temporaryStyles.push(durationStyle);
          }
          if (options.keyframeStyle) {
            var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
            applyInlineStyle(node, keyframeStyle);
            temporaryStyles.push(keyframeStyle);
          }
          var itemIndex = stagger ?
            options.staggerIndex >= 0 ?
            options.staggerIndex :
            gcsLookup.count(cacheKey) :
            0;
          var isFirst = itemIndex === 0;
          if (isFirst && !options.skipBlocking) {
            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
          }
          var timings = computeTimings(node, fullClassName, cacheKey);
          var relativeDelay = timings.maxDelay;
          maxDelay = Math.max(relativeDelay, 0);
          maxDuration = timings.maxDuration;
          var flags = {};
          flags.hasTransitions = timings.transitionDuration > 0;
          flags.hasAnimations = timings.animationDuration > 0;
          flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
          flags.applyTransitionDuration = hasToStyles && (
            (flags.hasTransitions && !flags.hasTransitionAll) ||
            (flags.hasAnimations && !flags.hasTransitions));
          flags.applyAnimationDuration = options.duration && flags.hasAnimations;
          flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
          flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
          flags.recalculateTimingStyles = addRemoveClassName.length > 0;
          if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
            maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
            if (flags.applyTransitionDuration) {
              flags.hasTransitions = true;
              timings.transitionDuration = maxDuration;
              applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
              temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
            }
            if (flags.applyAnimationDuration) {
              flags.hasAnimations = true;
              timings.animationDuration = maxDuration;
              temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
            }
          }
          if (maxDuration === 0 && !flags.recalculateTimingStyles) {
            return closeAndReturnNoopAnimator();
          }
          if (options.delay != null) {
            var delayStyle;
            if (typeof options.delay !== "boolean") {
              delayStyle = parseFloat(options.delay);
              maxDelay = Math.max(delayStyle, 0);
            }
            if (flags.applyTransitionDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle));
            }
            if (flags.applyAnimationDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle, true));
            }
          }
          if (options.duration == null && timings.transitionDuration > 0) {
            flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
          }
          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;
          if (!options.skipBlocking) {
            flags.blockTransition = timings.transitionDuration > 0;
            flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
              stagger.animationDelay > 0 &&
              stagger.animationDuration === 0;
          }
          if (options.from) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
            }
            applyAnimationFromStyles(element, options);
          }
          if (flags.blockTransition || flags.blockKeyframeAnimation) {
            applyBlocking(maxDuration);
          } else if (!options.skipBlocking) {
            blockTransitions(node, false);
          }
          return {
            $$willAnimate: true,
            end: endFn,
            start: function() {
              if (animationClosed) return;
              runnerHost = {
                end: endFn,
                cancel: cancelFn,
                resume: null,
                pause: null
              };
              runner = new $$AnimateRunner(runnerHost);
              waitUntilQuiet(start);
              return runner;
            }
          };

          function endFn() {
            close();
          }

          function cancelFn() {
            close(true);
          }

          function close(rejected) {
            if (animationClosed || (animationCompleted && animationPaused)) return;
            animationClosed = true;
            animationPaused = false;
            if (!options.$$skipPreparationClasses) {
              $$jqLite.removeClass(element, preparationClasses);
            }
            $$jqLite.removeClass(element, activeClasses);
            blockKeyframeAnimations(node, false);
            blockTransitions(node, false);
            forEach(temporaryStyles, function(entry) {
              node.style[entry[0]] = '';
            });
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            if (Object.keys(restoreStyles).length) {
              forEach(restoreStyles, function(value, prop) {
                value ? node.style.setProperty(prop, value) :
                  node.style.removeProperty(prop);
              });
            }
            if (options.onDone) {
              options.onDone();
            }
            if (events && events.length) {
              element.off(events.join(' '), onAnimationProgress);
            }
            var animationTimerData = element.data(ANIMATE_TIMER_KEY);
            if (animationTimerData) {
              $timeout.cancel(animationTimerData[0].timer);
              element.removeData(ANIMATE_TIMER_KEY);
            }
            if (runner) {
              runner.complete(!rejected);
            }
          }

          function applyBlocking(duration) {
            if (flags.blockTransition) {
              blockTransitions(node, duration);
            }
            if (flags.blockKeyframeAnimation) {
              blockKeyframeAnimations(node, !!duration);
            }
          }

          function closeAndReturnNoopAnimator() {
            runner = new $$AnimateRunner({
              end: endFn,
              cancel: cancelFn
            });
            waitUntilQuiet(noop);
            close();
            return {
              $$willAnimate: false,
              start: function() {
                return runner;
              },
              end: endFn
            };
          }

          function onAnimationProgress(event) {
            event.stopPropagation();
            var ev = event.originalEvent || event;
            var timeStamp = ev.$manualTimeStamp || Date.now();
            var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
            if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
              animationCompleted = true;
              close();
            }
          }

          function start() {
            if (animationClosed) return;
            if (!node.parentNode) {
              close();
              return;
            }
            var playPause = function(playAnimation) {
              if (!animationCompleted) {
                animationPaused = !playAnimation;
                if (timings.animationDuration) {
                  var value = blockKeyframeAnimations(node, animationPaused);
                  animationPaused
                    ?
                    temporaryStyles.push(value) :
                    removeFromArray(temporaryStyles, value);
                }
              } else if (animationPaused && playAnimation) {
                animationPaused = false;
                close();
              }
            };
            var maxStagger = itemIndex > 0 &&
              ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                (timings.animationDuration && stagger.animationDuration === 0)) &&
              Math.max(stagger.animationDelay, stagger.transitionDelay);
            if (maxStagger) {
              $timeout(triggerAnimationStart,
                Math.floor(maxStagger * itemIndex * ONE_SECOND),
                false);
            } else {
              triggerAnimationStart();
            }
            runnerHost.resume = function() {
              playPause(true);
            };
            runnerHost.pause = function() {
              playPause(false);
            };

            function triggerAnimationStart() {
              if (animationClosed) return;
              applyBlocking(false);
              forEach(temporaryStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[key] = value;
              });
              applyAnimationClasses(element, options);
              $$jqLite.addClass(element, activeClasses);
              if (flags.recalculateTimingStyles) {
                fullClassName = node.className + ' ' + preparationClasses;
                cacheKey = gcsHashFn(node, fullClassName);
                timings = computeTimings(node, fullClassName, cacheKey);
                relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0);
                maxDuration = timings.maxDuration;
                if (maxDuration === 0) {
                  close();
                  return;
                }
                flags.hasTransitions = timings.transitionDuration > 0;
                flags.hasAnimations = timings.animationDuration > 0;
              }
              if (flags.applyAnimationDelay) {
                relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ?
                  parseFloat(options.delay) :
                  relativeDelay;
                maxDelay = Math.max(relativeDelay, 0);
                timings.animationDelay = relativeDelay;
                delayStyle = getCssDelayStyle(relativeDelay, true);
                temporaryStyles.push(delayStyle);
                node.style[delayStyle[0]] = delayStyle[1];
              }
              maxDelayTime = maxDelay * ONE_SECOND;
              maxDurationTime = maxDuration * ONE_SECOND;
              if (options.easing) {
                var easeProp, easeVal = options.easing;
                if (flags.hasTransitions) {
                  easeProp = TRANSITION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
                if (flags.hasAnimations) {
                  easeProp = ANIMATION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
              }
              if (timings.transitionDuration) {
                events.push(TRANSITIONEND_EVENT);
              }
              if (timings.animationDuration) {
                events.push(ANIMATIONEND_EVENT);
              }
              startTime = Date.now();
              var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
              var endTime = startTime + timerTime;
              var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
              var setupFallbackTimer = true;
              if (animationsData.length) {
                var currentTimerData = animationsData[0];
                setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                if (setupFallbackTimer) {
                  $timeout.cancel(currentTimerData.timer);
                } else {
                  animationsData.push(close);
                }
              }
              if (setupFallbackTimer) {
                var timer = $timeout(onAnimationExpired, timerTime, false);
                animationsData[0] = {
                  timer: timer,
                  expectedEndTime: endTime
                };
                animationsData.push(close);
                element.data(ANIMATE_TIMER_KEY, animationsData);
              }
              if (events.length) {
                element.on(events.join(' '), onAnimationProgress);
              }
              if (options.to) {
                if (options.cleanupStyles) {
                  registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                }
                applyAnimationToStyles(element, options);
              }
            }

            function onAnimationExpired() {
              var animationsData = element.data(ANIMATE_TIMER_KEY);
              if (animationsData) {
                for (var i = 1; i < animationsData.length; i++) {
                  animationsData[i]();
                }
                element.removeData(ANIMATE_TIMER_KEY);
              }
            }
          }
        };
      }
    ];
  }];
  var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
    $$animationProvider.drivers.push('$$animateCssDriver');
    var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
    var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
    var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
    var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

    function isDocumentFragment(node) {
      return node.parentNode && node.parentNode.nodeType === 11;
    }
    this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
      function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
        if (!$sniffer.animations && !$sniffer.transitions) return noop;
        var bodyNode = $document[0].body;
        var rootNode = getDomNode($rootElement);
        var rootBodyElement = jqLite(
          isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
        );
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        return function initDriverFn(animationDetails) {
          return animationDetails.from && animationDetails.to ?
            prepareFromToAnchorAnimation(animationDetails.from,
              animationDetails.to,
              animationDetails.classes,
              animationDetails.anchors) :
            prepareRegularAnimation(animationDetails);
        };

        function filterCssClasses(classes) {
          return classes.replace(/\bng-\S+\b/g, '');
        }

        function getUniqueValues(a, b) {
          if (isString(a)) a = a.split(' ');
          if (isString(b)) b = b.split(' ');
          return a.filter(function(val) {
            return b.indexOf(val) === -1;
          }).join(' ');
        }

        function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
          var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
          var startingClasses = filterCssClasses(getClassVal(clone));
          outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
          rootBodyElement.append(clone);
          var animatorIn, animatorOut = prepareOutAnimation();
          if (!animatorOut) {
            animatorIn = prepareInAnimation();
            if (!animatorIn) {
              return end();
            }
          }
          var startingAnimator = animatorOut || animatorIn;
          return {
            start: function() {
              var runner;
              var currentAnimation = startingAnimator.start();
              currentAnimation.done(function() {
                currentAnimation = null;
                if (!animatorIn) {
                  animatorIn = prepareInAnimation();
                  if (animatorIn) {
                    currentAnimation = animatorIn.start();
                    currentAnimation.done(function() {
                      currentAnimation = null;
                      end();
                      runner.complete();
                    });
                    return currentAnimation;
                  }
                }
                end();
                runner.complete();
              });
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              return runner;

              function endFn() {
                if (currentAnimation) {
                  currentAnimation.end();
                }
              }
            }
          };

          function calculateAnchorStyles(anchor) {
            var styles = {};
            var coords = getDomNode(anchor).getBoundingClientRect();
            forEach(['width', 'height', 'top', 'left'], function(key) {
              var value = coords[key];
              switch (key) {
                case 'top':
                  value += bodyNode.scrollTop;
                  break;
                case 'left':
                  value += bodyNode.scrollLeft;
                  break;
              }
              styles[key] = Math.floor(value) + 'px';
            });
            return styles;
          }

          function prepareOutAnimation() {
            var animator = $animateCss(clone, {
              addClass: NG_OUT_ANCHOR_CLASS_NAME,
              delay: true,
              from: calculateAnchorStyles(outAnchor)
            });
            return animator.$$willAnimate ? animator : null;
          }

          function getClassVal(element) {
            return element.attr('class') || '';
          }

          function prepareInAnimation() {
            var endingClasses = filterCssClasses(getClassVal(inAnchor));
            var toAdd = getUniqueValues(endingClasses, startingClasses);
            var toRemove = getUniqueValues(startingClasses, endingClasses);
            var animator = $animateCss(clone, {
              to: calculateAnchorStyles(inAnchor),
              addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
              removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
              delay: true
            });
            return animator.$$willAnimate ? animator : null;
          }

          function end() {
            clone.remove();
            outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
          }
        }

        function prepareFromToAnchorAnimation(from, to, classes, anchors) {
          var fromAnimation = prepareRegularAnimation(from, noop);
          var toAnimation = prepareRegularAnimation(to, noop);
          var anchorAnimations = [];
          forEach(anchors, function(anchor) {
            var outElement = anchor['out'];
            var inElement = anchor['in'];
            var animator = prepareAnchoredAnimation(classes, outElement, inElement);
            if (animator) {
              anchorAnimations.push(animator);
            }
          });
          if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;
          return {
            start: function() {
              var animationRunners = [];
              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }
              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }
              forEach(anchorAnimations, function(animation) {
                animationRunners.push(animation.start());
              });
              var runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              $$AnimateRunner.all(animationRunners, function(status) {
                runner.complete(status);
              });
              return runner;

              function endFn() {
                forEach(animationRunners, function(runner) {
                  runner.end();
                });
              }
            }
          };
        }

        function prepareRegularAnimation(animationDetails) {
          var element = animationDetails.element;
          var options = animationDetails.options || {};
          if (animationDetails.structural) {
            options.event = animationDetails.event;
            options.structural = true;
            options.applyClassesEarly = true;
            if (animationDetails.event === 'leave') {
              options.onDone = options.domOperation;
            }
          }
          if (options.preparationClasses) {
            options.event = concatWithSpace(options.event, options.preparationClasses);
          }
          var animator = $animateCss(element, options);
          return animator.$$willAnimate ? animator : null;
        }
      }
    ];
  }];
  var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
    this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
      function($injector, $$AnimateRunner, $$jqLite) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        return function(element, event, classes, options) {
          var animationClosed = false;
          if (arguments.length === 3 && isObject(classes)) {
            options = classes;
            classes = null;
          }
          options = prepareAnimationOptions(options);
          if (!classes) {
            classes = element.attr('class') || '';
            if (options.addClass) {
              classes += ' ' + options.addClass;
            }
            if (options.removeClass) {
              classes += ' ' + options.removeClass;
            }
          }
          var classesToAdd = options.addClass;
          var classesToRemove = options.removeClass;
          var animations = lookupAnimations(classes);
          var before, after;
          if (animations.length) {
            var afterFn, beforeFn;
            if (event == 'leave') {
              beforeFn = 'leave';
              afterFn = 'afterLeave';
            } else {
              beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
              afterFn = event;
            }
            if (event !== 'enter' && event !== 'move') {
              before = packageAnimations(element, event, options, animations, beforeFn);
            }
            after = packageAnimations(element, event, options, animations, afterFn);
          }
          if (!before && !after) return;

          function applyOptions() {
            options.domOperation();
            applyAnimationClasses(element, options);
          }

          function close() {
            animationClosed = true;
            applyOptions();
            applyAnimationStyles(element, options);
          }
          var runner;
          return {
            $$willAnimate: true,
            end: function() {
              if (runner) {
                runner.end();
              } else {
                close();
                runner = new $$AnimateRunner();
                runner.complete(true);
              }
              return runner;
            },
            start: function() {
              if (runner) {
                return runner;
              }
              runner = new $$AnimateRunner();
              var closeActiveAnimations;
              var chain = [];
              if (before) {
                chain.push(function(fn) {
                  closeActiveAnimations = before(fn);
                });
              }
              if (chain.length) {
                chain.push(function(fn) {
                  applyOptions();
                  fn(true);
                });
              } else {
                applyOptions();
              }
              if (after) {
                chain.push(function(fn) {
                  closeActiveAnimations = after(fn);
                });
              }
              runner.setHost({
                end: function() {
                  endAnimations();
                },
                cancel: function() {
                  endAnimations(true);
                }
              });
              $$AnimateRunner.chain(chain, onComplete);
              return runner;

              function onComplete(success) {
                close(success);
                runner.complete(success);
              }

              function endAnimations(cancelled) {
                if (!animationClosed) {
                  (closeActiveAnimations || noop)(cancelled);
                  onComplete(cancelled);
                }
              }
            }
          };

          function executeAnimationFn(fn, element, event, options, onDone) {
            var args;
            switch (event) {
              case 'animate':
                args = [element, options.from, options.to, onDone];
                break;
              case 'setClass':
                args = [element, classesToAdd, classesToRemove, onDone];
                break;
              case 'addClass':
                args = [element, classesToAdd, onDone];
                break;
              case 'removeClass':
                args = [element, classesToRemove, onDone];
                break;
              default:
                args = [element, onDone];
                break;
            }
            args.push(options);
            var value = fn.apply(fn, args);
            if (value) {
              if (isFunction(value.start)) {
                value = value.start();
              }
              if (value instanceof $$AnimateRunner) {
                value.done(onDone);
              } else if (isFunction(value)) {
                return value;
              }
            }
            return noop;
          }

          function groupEventedAnimations(element, event, options, animations, fnName) {
            var operations = [];
            forEach(animations, function(ani) {
              var animation = ani[fnName];
              if (!animation) return;
              operations.push(function() {
                var runner;
                var endProgressCb;
                var resolved = false;
                var onAnimationComplete = function(rejected) {
                  if (!resolved) {
                    resolved = true;
                    (endProgressCb || noop)(rejected);
                    runner.complete(!rejected);
                  }
                };
                runner = new $$AnimateRunner({
                  end: function() {
                    onAnimationComplete();
                  },
                  cancel: function() {
                    onAnimationComplete(true);
                  }
                });
                endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                  var cancelled = result === false;
                  onAnimationComplete(cancelled);
                });
                return runner;
              });
            });
            return operations;
          }

          function packageAnimations(element, event, options, animations, fnName) {
            var operations = groupEventedAnimations(element, event, options, animations, fnName);
            if (operations.length === 0) {
              var a, b;
              if (fnName === 'beforeSetClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
              } else if (fnName === 'setClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
              }
              if (a) {
                operations = operations.concat(a);
              }
              if (b) {
                operations = operations.concat(b);
              }
            }
            if (operations.length === 0) return;
            return function startAnimation(callback) {
              var runners = [];
              if (operations.length) {
                forEach(operations, function(animateFn) {
                  runners.push(animateFn());
                });
              }
              runners.length ? $$AnimateRunner.all(runners, callback) : callback();
              return function endFn(reject) {
                forEach(runners, function(runner) {
                  reject ? runner.cancel() : runner.end();
                });
              };
            };
          }
        };

        function lookupAnimations(classes) {
          classes = isArray(classes) ? classes : classes.split(' ');
          var matches = [],
            flagMap = {};
          for (var i = 0; i < classes.length; i++) {
            var klass = classes[i],
              animationFactory = $animateProvider.$$registeredAnimations[klass];
            if (animationFactory && !flagMap[klass]) {
              matches.push($injector.get(animationFactory));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }
    ];
  }];
  var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
    $$animationProvider.drivers.push('$$animateJsDriver');
    this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
      return function initDriverFn(animationDetails) {
        if (animationDetails.from && animationDetails.to) {
          var fromAnimation = prepareAnimation(animationDetails.from);
          var toAnimation = prepareAnimation(animationDetails.to);
          if (!fromAnimation && !toAnimation) return;
          return {
            start: function() {
              var animationRunners = [];
              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }
              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }
              $$AnimateRunner.all(animationRunners, done);
              var runner = new $$AnimateRunner({
                end: endFnFactory(),
                cancel: endFnFactory()
              });
              return runner;

              function endFnFactory() {
                return function() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                };
              }

              function done(status) {
                runner.complete(status);
              }
            }
          };
        } else {
          return prepareAnimation(animationDetails);
        }
      };

      function prepareAnimation(animationDetails) {
        var element = animationDetails.element;
        var event = animationDetails.event;
        var options = animationDetails.options;
        var classes = animationDetails.classes;
        return $$animateJs(element, event, classes, options);
      }
    }];
  }];
  var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
  var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
  var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
    var PRE_DIGEST_STATE = 1;
    var RUNNING_STATE = 2;
    var ONE_SPACE = ' ';
    var rules = this.rules = {
      skip: [],
      cancel: [],
      join: []
    };

    function makeTruthyCssClassMap(classString) {
      if (!classString) {
        return null;
      }
      var keys = classString.split(ONE_SPACE);
      var map = Object.create(null);
      forEach(keys, function(key) {
        map[key] = true;
      });
      return map;
    }

    function hasMatchingClasses(newClassString, currentClassString) {
      if (newClassString && currentClassString) {
        var currentClassMap = makeTruthyCssClassMap(currentClassString);
        return newClassString.split(ONE_SPACE).some(function(className) {
          return currentClassMap[className];
        });
      }
    }

    function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
      return rules[ruleType].some(function(fn) {
        return fn(element, currentAnimation, previousAnimation);
      });
    }

    function hasAnimationClasses(animation, and) {
      var a = (animation.addClass || '').length > 0;
      var b = (animation.removeClass || '').length > 0;
      return and ? a && b : a || b;
    }
    rules.join.push(function(element, newAnimation, currentAnimation) {
      return !newAnimation.structural && hasAnimationClasses(newAnimation);
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return !newAnimation.structural && !hasAnimationClasses(newAnimation);
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.event == 'leave' && newAnimation.structural;
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.structural && newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      if (currentAnimation.structural) return false;
      var nA = newAnimation.addClass;
      var nR = newAnimation.removeClass;
      var cA = currentAnimation.addClass;
      var cR = currentAnimation.removeClass;
      if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
        return false;
      }
      return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
    });
    this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
      '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
      function($$rAF, $rootScope, $rootElement, $document, $$HashMap,
        $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
        var activeAnimationsLookup = new $$HashMap();
        var disabledElementsLookup = new $$HashMap();
        var animationsEnabled = null;

        function postDigestTaskFactory() {
          var postDigestCalled = false;
          return function(fn) {
            if (postDigestCalled) {
              fn();
            } else {
              $rootScope.$$postDigest(function() {
                postDigestCalled = true;
                fn();
              });
            }
          };
        }
        var deregisterWatch = $rootScope.$watch(
          function() {
            return $templateRequest.totalPendingRequests === 0;
          },
          function(isEmpty) {
            if (!isEmpty) return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          }
        );
        var callbackRegistry = Object.create(null);
        var classNameFilter = $animateProvider.classNameFilter();
        var isAnimatableClassName = !classNameFilter ?
          function() {
            return true;
          } :
          function(className) {
            return classNameFilter.test(className);
          };
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

        function normalizeAnimationDetails(element, animation) {
          return mergeAnimationDetails(element, animation, {});
        }
        var contains = window.Node.prototype.contains || function(arg) {
          return this === arg || !!(this.compareDocumentPosition(arg) & 16);
        };

        function findCallbacks(parent, element, event) {
          var targetNode = getDomNode(element);
          var targetParentNode = getDomNode(parent);
          var matches = [];
          var entries = callbackRegistry[event];
          if (entries) {
            forEach(entries, function(entry) {
              if (contains.call(entry.node, targetNode)) {
                matches.push(entry.callback);
              } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                matches.push(entry.callback);
              }
            });
          }
          return matches;
        }

        function filterFromRegistry(list, matchContainer, matchCallback) {
          var containerNode = extractElementNode(matchContainer);
          return list.filter(function(entry) {
            var isMatch = entry.node === containerNode &&
              (!matchCallback || entry.callback === matchCallback);
            return !isMatch;
          });
        }

        function cleanupEventListeners(phase, element) {
          if (phase === 'close' && !element[0].parentNode) {
            $animate.off(element);
          }
        }
        var $animate = {
          on: function(event, container, callback) {
            var node = extractElementNode(container);
            callbackRegistry[event] = callbackRegistry[event] || [];
            callbackRegistry[event].push({
              node: node,
              callback: callback
            });
            jqLite(container).on('$destroy', function() {
              var animationDetails = activeAnimationsLookup.get(node);
              if (!animationDetails) {
                $animate.off(event, container, callback);
              }
            });
          },
          off: function(event, container, callback) {
            if (arguments.length === 1 && !isString(arguments[0])) {
              container = arguments[0];
              for (var eventType in callbackRegistry) {
                callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
              }
              return;
            }
            var entries = callbackRegistry[event];
            if (!entries) return;
            callbackRegistry[event] = arguments.length === 1 ?
              null :
              filterFromRegistry(entries, container, callback);
          },
          pin: function(element, parentElement) {
            assertArg(isElement(element), 'element', 'not an element');
            assertArg(isElement(parentElement), 'parentElement', 'not an element');
            element.data(NG_ANIMATE_PIN_DATA, parentElement);
          },
          push: function(element, event, options, domOperation) {
            options = options || {};
            options.domOperation = domOperation;
            return queueAnimation(element, event, options);
          },
          enabled: function(element, bool) {
            var argCount = arguments.length;
            if (argCount === 0) {
              bool = !!animationsEnabled;
            } else {
              var hasElement = isElement(element);
              if (!hasElement) {
                bool = animationsEnabled = !!element;
              } else {
                var node = getDomNode(element);
                if (argCount === 1) {
                  bool = !disabledElementsLookup.get(node);
                } else {
                  disabledElementsLookup.put(node, !bool);
                }
              }
            }
            return bool;
          }
        };
        return $animate;

        function queueAnimation(element, event, initialOptions) {
          var options = copy(initialOptions);
          var node, parent;
          element = stripCommentsFromElement(element);
          if (element) {
            node = getDomNode(element);
            parent = element.parent();
          }
          options = prepareAnimationOptions(options);
          var runner = new $$AnimateRunner();
          var runInNextPostDigestOrNow = postDigestTaskFactory();
          if (isArray(options.addClass)) {
            options.addClass = options.addClass.join(' ');
          }
          if (options.addClass && !isString(options.addClass)) {
            options.addClass = null;
          }
          if (isArray(options.removeClass)) {
            options.removeClass = options.removeClass.join(' ');
          }
          if (options.removeClass && !isString(options.removeClass)) {
            options.removeClass = null;
          }
          if (options.from && !isObject(options.from)) {
            options.from = null;
          }
          if (options.to && !isObject(options.to)) {
            options.to = null;
          }
          if (!node) {
            close();
            return runner;
          }
          var className = [node.className, options.addClass, options.removeClass].join(' ');
          if (!isAnimatableClassName(className)) {
            close();
            return runner;
          }
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
          var documentHidden = $document[0].hidden;
          var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
          var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
          var hasExistingAnimation = !!existingAnimation.state;
          if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
            skipAnimations = !areAnimationsAllowed(element, parent, event);
          }
          if (skipAnimations) {
            if (documentHidden) notifyProgress(runner, event, 'start');
            close();
            if (documentHidden) notifyProgress(runner, event, 'close');
            return runner;
          }
          if (isStructural) {
            closeChildAnimations(element);
          }
          var newAnimation = {
            structural: isStructural,
            element: element,
            event: event,
            addClass: options.addClass,
            removeClass: options.removeClass,
            close: close,
            options: options,
            runner: runner
          };
          if (hasExistingAnimation) {
            var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
            if (skipAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                close();
                return runner;
              } else {
                mergeAnimationDetails(element, existingAnimation, newAnimation);
                return existingAnimation.runner;
              }
            }
            var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
            if (cancelAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                existingAnimation.runner.end();
              } else if (existingAnimation.structural) {
                existingAnimation.close();
              } else {
                mergeAnimationDetails(element, existingAnimation, newAnimation);
                return existingAnimation.runner;
              }
            } else {
              var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
              if (joinAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  normalizeAnimationDetails(element, newAnimation);
                } else {
                  applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                  event = newAnimation.event = existingAnimation.event;
                  options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
            }
          } else {
            normalizeAnimationDetails(element, newAnimation);
          }
          var isValidAnimation = newAnimation.structural;
          if (!isValidAnimation) {
            isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) ||
              hasAnimationClasses(newAnimation);
          }
          if (!isValidAnimation) {
            close();
            clearElementAnimationState(element);
            return runner;
          }
          var counter = (existingAnimation.counter || 0) + 1;
          newAnimation.counter = counter;
          markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
          $rootScope.$$postDigest(function() {
            var animationDetails = activeAnimationsLookup.get(node);
            var animationCancelled = !animationDetails;
            animationDetails = animationDetails || {};
            var parentElement = element.parent() || [];
            var isValidAnimation = parentElement.length > 0 &&
              (animationDetails.event === 'animate' ||
                animationDetails.structural ||
                hasAnimationClasses(animationDetails));
            if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
              if (animationCancelled) {
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
              }
              if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                options.domOperation();
                runner.end();
              }
              if (!isValidAnimation) {
                clearElementAnimationState(element);
              }
              return;
            }
            event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ?
              'setClass' :
              animationDetails.event;
            markElementAnimationState(element, RUNNING_STATE);
            var realRunner = $$animation(element, event, animationDetails.options);
            runner.setHost(realRunner);
            notifyProgress(runner, event, 'start', {});
            realRunner.done(function(status) {
              close(!status);
              var animationDetails = activeAnimationsLookup.get(node);
              if (animationDetails && animationDetails.counter === counter) {
                clearElementAnimationState(getDomNode(element));
              }
              notifyProgress(runner, event, 'close', {});
            });
          });
          return runner;

          function notifyProgress(runner, event, phase, data) {
            runInNextPostDigestOrNow(function() {
              var callbacks = findCallbacks(parent, element, event);
              if (callbacks.length) {
                $$rAF(function() {
                  forEach(callbacks, function(callback) {
                    callback(element, phase, data);
                  });
                  cleanupEventListeners(phase, element);
                });
              } else {
                cleanupEventListeners(phase, element);
              }
            });
            runner.progress(event, phase, data);
          }

          function close(reject) {
            clearGeneratedClasses(element, options);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            runner.complete(!reject);
          }
        }

        function closeChildAnimations(element) {
          var node = getDomNode(element);
          var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
          forEach(children, function(child) {
            var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
            var animationDetails = activeAnimationsLookup.get(child);
            if (animationDetails) {
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                case PRE_DIGEST_STATE:
                  activeAnimationsLookup.remove(child);
                  break;
              }
            }
          });
        }

        function clearElementAnimationState(element) {
          var node = getDomNode(element);
          node.removeAttribute(NG_ANIMATE_ATTR_NAME);
          activeAnimationsLookup.remove(node);
        }

        function isMatchingElement(nodeOrElmA, nodeOrElmB) {
          return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
        }

        function areAnimationsAllowed(element, parentElement, event) {
          var bodyElement = jqLite($document[0].body);
          var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
          var rootElementDetected = isMatchingElement(element, $rootElement);
          var parentAnimationDetected = false;
          var animateChildren;
          var elementDisabled = disabledElementsLookup.get(getDomNode(element));
          var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            parentElement = parentHost;
          }
          parentElement = getDomNode(parentElement);
          while (parentElement) {
            if (!rootElementDetected) {
              rootElementDetected = isMatchingElement(parentElement, $rootElement);
            }
            if (parentElement.nodeType !== ELEMENT_NODE) {
              break;
            }
            var details = activeAnimationsLookup.get(parentElement) || {};
            if (!parentAnimationDetected) {
              var parentElementDisabled = disabledElementsLookup.get(parentElement);
              if (parentElementDisabled === true && elementDisabled !== false) {
                elementDisabled = true;
                break;
              } else if (parentElementDisabled === false) {
                elementDisabled = false;
              }
              parentAnimationDetected = details.structural;
            }
            if (isUndefined(animateChildren) || animateChildren === true) {
              var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
              if (isDefined(value)) {
                animateChildren = value;
              }
            }
            if (parentAnimationDetected && animateChildren === false) break;
            if (!bodyElementDetected) {
              bodyElementDetected = isMatchingElement(parentElement, bodyElement);
            }
            if (bodyElementDetected && rootElementDetected) {
              break;
            }
            if (!rootElementDetected) {
              parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
              if (parentHost) {
                parentElement = getDomNode(parentHost);
                continue;
              }
            }
            parentElement = parentElement.parentNode;
          }
          var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
          return allowAnimation && rootElementDetected && bodyElementDetected;
        }

        function markElementAnimationState(element, state, details) {
          details = details || {};
          details.state = state;
          var node = getDomNode(element);
          node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
          var oldValue = activeAnimationsLookup.get(node);
          var newValue = oldValue ?
            extend(oldValue, details) :
            details;
          activeAnimationsLookup.put(node, newValue);
        }
      }
    ];
  }];
  var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
    var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
    var drivers = this.drivers = [];
    var RUNNER_STORAGE_KEY = '$$animationRunner';

    function setRunner(element, runner) {
      element.data(RUNNER_STORAGE_KEY, runner);
    }

    function removeRunner(element) {
      element.removeData(RUNNER_STORAGE_KEY);
    }

    function getRunner(element) {
      return element.data(RUNNER_STORAGE_KEY);
    }
    this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
      function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
        var animationQueue = [];
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

        function sortAnimations(animations) {
          var tree = {
            children: []
          };
          var i, lookup = new $$HashMap();
          for (i = 0; i < animations.length; i++) {
            var animation = animations[i];
            lookup.put(animation.domNode, animations[i] = {
              domNode: animation.domNode,
              fn: animation.fn,
              children: []
            });
          }
          for (i = 0; i < animations.length; i++) {
            processNode(animations[i]);
          }
          return flatten(tree);

          function processNode(entry) {
            if (entry.processed) return entry;
            entry.processed = true;
            var elementNode = entry.domNode;
            var parentNode = elementNode.parentNode;
            lookup.put(elementNode, entry);
            var parentEntry;
            while (parentNode) {
              parentEntry = lookup.get(parentNode);
              if (parentEntry) {
                if (!parentEntry.processed) {
                  parentEntry = processNode(parentEntry);
                }
                break;
              }
              parentNode = parentNode.parentNode;
            }
            (parentEntry || tree).children.push(entry);
            return entry;
          }

          function flatten(tree) {
            var result = [];
            var queue = [];
            var i;
            for (i = 0; i < tree.children.length; i++) {
              queue.push(tree.children[i]);
            }
            var remainingLevelEntries = queue.length;
            var nextLevelEntries = 0;
            var row = [];
            for (i = 0; i < queue.length; i++) {
              var entry = queue[i];
              if (remainingLevelEntries <= 0) {
                remainingLevelEntries = nextLevelEntries;
                nextLevelEntries = 0;
                result.push(row);
                row = [];
              }
              row.push(entry.fn);
              entry.children.forEach(function(childEntry) {
                nextLevelEntries++;
                queue.push(childEntry);
              });
              remainingLevelEntries--;
            }
            if (row.length) {
              result.push(row);
            }
            return result;
          }
        }
        return function(element, event, options) {
          options = prepareAnimationOptions(options);
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
          var runner = new $$AnimateRunner({
            end: function() {
              close();
            },
            cancel: function() {
              close(true);
            }
          });
          if (!drivers.length) {
            close();
            return runner;
          }
          setRunner(element, runner);
          var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
          var tempClasses = options.tempClasses;
          if (tempClasses) {
            classes += ' ' + tempClasses;
            options.tempClasses = null;
          }
          var prepareClassName;
          if (isStructural) {
            prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
            $$jqLite.addClass(element, prepareClassName);
          }
          animationQueue.push({
            element: element,
            classes: classes,
            event: event,
            structural: isStructural,
            options: options,
            beforeStart: beforeStart,
            close: close
          });
          element.on('$destroy', handleDestroyedElement);
          if (animationQueue.length > 1) return runner;
          $rootScope.$$postDigest(function() {
            var animations = [];
            forEach(animationQueue, function(entry) {
              if (getRunner(entry.element)) {
                animations.push(entry);
              } else {
                entry.close();
              }
            });
            animationQueue.length = 0;
            var groupedAnimations = groupAnimations(animations);
            var toBeSortedAnimations = [];
            forEach(groupedAnimations, function(animationEntry) {
              toBeSortedAnimations.push({
                domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                fn: function triggerAnimationStart() {
                  animationEntry.beforeStart();
                  var startAnimationFn, closeFn = animationEntry.close;
                  var targetElement = animationEntry.anchors ?
                    (animationEntry.from.element || animationEntry.to.element) :
                    animationEntry.element;
                  if (getRunner(targetElement)) {
                    var operation = invokeFirstDriver(animationEntry);
                    if (operation) {
                      startAnimationFn = operation.start;
                    }
                  }
                  if (!startAnimationFn) {
                    closeFn();
                  } else {
                    var animationRunner = startAnimationFn();
                    animationRunner.done(function(status) {
                      closeFn(!status);
                    });
                    updateAnimationRunners(animationEntry, animationRunner);
                  }
                }
              });
            });
            $$rAFScheduler(sortAnimations(toBeSortedAnimations));
          });
          return runner;

          function getAnchorNodes(node) {
            var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
            var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ?
              [node] :
              node.querySelectorAll(SELECTOR);
            var anchors = [];
            forEach(items, function(node) {
              var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
              if (attr && attr.length) {
                anchors.push(node);
              }
            });
            return anchors;
          }

          function groupAnimations(animations) {
            var preparedAnimations = [];
            var refLookup = {};
            forEach(animations, function(animation, index) {
              var element = animation.element;
              var node = getDomNode(element);
              var event = animation.event;
              var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
              var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
              if (anchorNodes.length) {
                var direction = enterOrMove ? 'to' : 'from';
                forEach(anchorNodes, function(anchor) {
                  var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                  refLookup[key] = refLookup[key] || {};
                  refLookup[key][direction] = {
                    animationID: index,
                    element: jqLite(anchor)
                  };
                });
              } else {
                preparedAnimations.push(animation);
              }
            });
            var usedIndicesLookup = {};
            var anchorGroups = {};
            forEach(refLookup, function(operations, key) {
              var from = operations.from;
              var to = operations.to;
              if (!from || !to) {
                var index = from ? from.animationID : to.animationID;
                var indexKey = index.toString();
                if (!usedIndicesLookup[indexKey]) {
                  usedIndicesLookup[indexKey] = true;
                  preparedAnimations.push(animations[index]);
                }
                return;
              }
              var fromAnimation = animations[from.animationID];
              var toAnimation = animations[to.animationID];
              var lookupKey = from.animationID.toString();
              if (!anchorGroups[lookupKey]) {
                var group = anchorGroups[lookupKey] = {
                  structural: true,
                  beforeStart: function() {
                    fromAnimation.beforeStart();
                    toAnimation.beforeStart();
                  },
                  close: function() {
                    fromAnimation.close();
                    toAnimation.close();
                  },
                  classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                  from: fromAnimation,
                  to: toAnimation,
                  anchors: []
                };
                if (group.classes.length) {
                  preparedAnimations.push(group);
                } else {
                  preparedAnimations.push(fromAnimation);
                  preparedAnimations.push(toAnimation);
                }
              }
              anchorGroups[lookupKey].anchors.push({
                'out': from.element,
                'in': to.element
              });
            });
            return preparedAnimations;
          }

          function cssClassesIntersection(a, b) {
            a = a.split(' ');
            b = b.split(' ');
            var matches = [];
            for (var i = 0; i < a.length; i++) {
              var aa = a[i];
              if (aa.substring(0, 3) === 'ng-') continue;
              for (var j = 0; j < b.length; j++) {
                if (aa === b[j]) {
                  matches.push(aa);
                  break;
                }
              }
            }
            return matches.join(' ');
          }

          function invokeFirstDriver(animationDetails) {
            for (var i = drivers.length - 1; i >= 0; i--) {
              var driverName = drivers[i];
              var factory = $injector.get(driverName);
              var driver = factory(animationDetails);
              if (driver) {
                return driver;
              }
            }
          }

          function beforeStart() {
            element.addClass(NG_ANIMATE_CLASSNAME);
            if (tempClasses) {
              $$jqLite.addClass(element, tempClasses);
            }
            if (prepareClassName) {
              $$jqLite.removeClass(element, prepareClassName);
              prepareClassName = null;
            }
          }

          function updateAnimationRunners(animation, newRunner) {
            if (animation.from && animation.to) {
              update(animation.from.element);
              update(animation.to.element);
            } else {
              update(animation.element);
            }

            function update(element) {
              var runner = getRunner(element);
              if (runner) runner.setHost(newRunner);
            }
          }

          function handleDestroyedElement() {
            var runner = getRunner(element);
            if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
              runner.end();
            }
          }

          function close(rejected) {
            element.off('$destroy', handleDestroyedElement);
            removeRunner(element);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            if (tempClasses) {
              $$jqLite.removeClass(element, tempClasses);
            }
            element.removeClass(NG_ANIMATE_CLASSNAME);
            runner.complete(!rejected);
          }
        };
      }
    ];
  }];
  var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
    return {
      restrict: 'A',
      transclude: 'element',
      terminal: true,
      priority: 600,
      link: function(scope, $element, attrs, ctrl, $transclude) {
        var previousElement, previousScope;
        scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
          if (previousElement) {
            $animate.leave(previousElement);
          }
          if (previousScope) {
            previousScope.$destroy();
            previousScope = null;
          }
          if (value || value === 0) {
            previousScope = scope.$new();
            $transclude(previousScope, function(element) {
              previousElement = element;
              $animate.enter(element, null, $element);
            });
          }
        });
      }
    };
  }];
  var copy;
  var extend;
  var forEach;
  var isArray;
  var isDefined;
  var isElement;
  var isFunction;
  var isObject;
  var isString;
  var isUndefined;
  var jqLite;
  var noop;
  angular.module('ngAnimate', [], function initAngularHelpers() {
      noop = angular.noop;
      copy = angular.copy;
      extend = angular.extend;
      jqLite = angular.element;
      forEach = angular.forEach;
      isArray = angular.isArray;
      isString = angular.isString;
      isObject = angular.isObject;
      isUndefined = angular.isUndefined;
      isDefined = angular.isDefined;
      isFunction = angular.isFunction;
      isElement = angular.isElement;
    })
    .directive('ngAnimateSwap', ngAnimateSwapDirective)
    .directive('ngAnimateChildren', $$AnimateChildrenDirective)
    .factory('$$rAFScheduler', $$rAFSchedulerFactory)
    .provider('$$animateQueue', $$AnimateQueueProvider)
    .provider('$$animation', $$AnimationProvider)
    .provider('$animateCss', $AnimateCssProvider)
    .provider('$$animateCssDriver', $$AnimateCssDriverProvider)
    .provider('$$animateJs', $$AnimateJsProvider)
    .provider('$$animateJsDriver', $$AnimateJsDriverProvider);
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-resource.js */
(function(window, angular) {
  'use strict';
  var $resourceMinErr = angular.$$minErr('$resource');
  var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;

  function isValidDottedPath(path) {
    return (path != null && path !== '' && path !== 'hasOwnProperty' &&
      MEMBER_NAME_REGEX.test('.' + path));
  }

  function lookupDottedPath(obj, path) {
    if (!isValidDottedPath(path)) {
      throw $resourceMinErr('badmember', 'Dotted member path "@{0}" is invalid.', path);
    }
    var keys = path.split('.');
    for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {
      var key = keys[i];
      obj = (obj !== null) ? obj[key] : undefined;
    }
    return obj;
  }

  function shallowClearAndCopy(src, dst) {
    dst = dst || {};
    angular.forEach(dst, function(value, key) {
      delete dst[key];
    });
    for (var key in src) {
      if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  angular.module('ngResource', ['ng']).
  provider('$resource', function() {
    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\/\/[^\/]*/;
    var provider = this;
    this.defaults = {
      stripTrailingSlashes: true,
      cancellable: false,
      actions: {
        'get': {
          method: 'GET'
        },
        'save': {
          method: 'POST'
        },
        'query': {
          method: 'GET',
          isArray: true
        },
        'remove': {
          method: 'DELETE'
        },
        'delete': {
          method: 'DELETE'
        }
      }
    };
    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {
      var noop = angular.noop,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        isFunction = angular.isFunction;

      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).
        replace(/%26/gi, '&').
        replace(/%3D/gi, '=').
        replace(/%2B/gi, '+');
      }

      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }

      function Route(template, defaults) {
        this.template = template;
        this.defaults = extend({}, provider.defaults, defaults);
        this.urlParams = {};
      }
      Route.prototype = {
        setUrlParams: function(config, params, actionUrl) {
          var self = this,
            url = actionUrl || self.template,
            val,
            encodedVal,
            protocolAndDomain = '';
          var urlParams = self.urlParams = {};
          forEach(url.split(/\W/), function(param) {
            if (param === 'hasOwnProperty') {
              throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
            }
            if (!(new RegExp("^\\d+$").test(param)) && param &&
              (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
              urlParams[param] = {
                isQueryParamValue: (new RegExp("\\?.*=:" + param + "(?:\\W|$)")).test(url)
              };
            }
          });
          url = url.replace(/\\:/g, ':');
          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {
            protocolAndDomain = match;
            return '';
          });
          params = params || {};
          forEach(self.urlParams, function(paramInfo, urlParam) {
            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
            if (angular.isDefined(val) && val !== null) {
              if (paramInfo.isQueryParamValue) {
                encodedVal = encodeUriQuery(val, true);
              } else {
                encodedVal = encodeUriSegment(val);
              }
              url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                return encodedVal + p1;
              });
            } else {
              url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match,
                leadingSlashes, tail) {
                if (tail.charAt(0) == '/') {
                  return tail;
                } else {
                  return leadingSlashes + tail;
                }
              });
            }
          });
          if (self.defaults.stripTrailingSlashes) {
            url = url.replace(/\/+$/, '') || '/';
          }
          url = url.replace(/\/\.(?=\w+($|\?))/, '.');
          config.url = protocolAndDomain + url.replace(/\/\\\./, '/.');
          forEach(params, function(value, key) {
            if (!self.urlParams[key]) {
              config.params = config.params || {};
              config.params[key] = value;
            }
          });
        }
      };

      function resourceFactory(url, paramDefaults, actions, options) {
        var route = new Route(url, options);
        actions = extend({}, provider.defaults.actions, actions);

        function extractParams(data, actionParams) {
          var ids = {};
          actionParams = extend({}, paramDefaults, actionParams);
          forEach(actionParams, function(value, key) {
            if (isFunction(value)) {
              value = value(data);
            }
            ids[key] = value && value.charAt && value.charAt(0) == '@' ?
              lookupDottedPath(data, value.substr(1)) : value;
          });
          return ids;
        }

        function defaultResponseInterceptor(response) {
          return response.resource;
        }

        function Resource(value) {
          shallowClearAndCopy(value || {}, this);
        }
        Resource.prototype.toJSON = function() {
          var data = extend({}, this);
          delete data.$promise;
          delete data.$resolved;
          return data;
        };
        forEach(actions, function(action, name) {
          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
          var numericTimeout = action.timeout;
          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :
            (options && angular.isDefined(options.cancellable)) ? options.cancellable :
            provider.defaults.cancellable;
          if (numericTimeout && !angular.isNumber(numericTimeout)) {
            $log.debug('ngResource:\n' +
              '  Only numeric values are allowed as `timeout`.\n' +
              '  Promises are not supported in $resource, because the same value would ' +
              'be used for multiple requests. If you are looking for a way to cancel ' +
              'requests, you should use the `cancellable` option.');
            delete action.timeout;
            numericTimeout = null;
          }
          Resource[name] = function(a1, a2, a3, a4) {
            var params = {},
              data, success, error;
            switch (arguments.length) {
              case 4:
                error = a4;
                success = a3;
              case 3:
              case 2:
                if (isFunction(a2)) {
                  if (isFunction(a1)) {
                    success = a1;
                    error = a2;
                    break;
                  }
                  success = a2;
                  error = a3;
                } else {
                  params = a1;
                  data = a2;
                  success = a3;
                  break;
                }
              case 1:
                if (isFunction(a1)) success = a1;
                else if (hasBody) data = a1;
                else params = a1;
                break;
              case 0:
                break;
              default:
                throw $resourceMinErr('badargs',
                  "Expected up to 4 arguments [params, data, success, error], got {0} arguments",
                  arguments.length);
            }
            var isInstanceCall = this instanceof Resource;
            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));
            var httpConfig = {};
            var responseInterceptor = action.interceptor && action.interceptor.response ||
              defaultResponseInterceptor;
            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||
              undefined;
            var timeoutDeferred;
            var numericTimeoutPromise;
            forEach(action, function(value, key) {
              switch (key) {
                default: httpConfig[key] = copy(value);
                break;
                case 'params':
                    case 'isArray':
                    case 'interceptor':
                    case 'cancellable':
                    break;
              }
            });
            if (!isInstanceCall && cancellable) {
              timeoutDeferred = $q.defer();
              httpConfig.timeout = timeoutDeferred.promise;
              if (numericTimeout) {
                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);
              }
            }
            if (hasBody) httpConfig.data = data;
            route.setUrlParams(httpConfig,
              extend({}, extractParams(data, action.params || {}), params),
              action.url);
            var promise = $http(httpConfig).then(function(response) {
              var data = response.data;
              if (data) {
                if (angular.isArray(data) !== (!!action.isArray)) {
                  throw $resourceMinErr('badcfg',
                    'Error in resource configuration for action `{0}`. Expected response to ' +
                    'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',
                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);
                }
                if (action.isArray) {
                  value.length = 0;
                  forEach(data, function(item) {
                    if (typeof item === "object") {
                      value.push(new Resource(item));
                    } else {
                      value.push(item);
                    }
                  });
                } else {
                  var promise = value.$promise;
                  shallowClearAndCopy(data, value);
                  value.$promise = promise;
                }
              }
              response.resource = value;
              return response;
            }, function(response) {
              (error || noop)(response);
              return $q.reject(response);
            });
            promise['finally'](function() {
              value.$resolved = true;
              if (!isInstanceCall && cancellable) {
                value.$cancelRequest = angular.noop;
                $timeout.cancel(numericTimeoutPromise);
                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;
              }
            });
            promise = promise.then(
              function(response) {
                var value = responseInterceptor(response);
                (success || noop)(value, response.headers);
                return value;
              },
              responseErrorInterceptor);
            if (!isInstanceCall) {
              value.$promise = promise;
              value.$resolved = false;
              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;
              return value;
            }
            return promise;
          };
          Resource.prototype['$' + name] = function(params, success, error) {
            if (isFunction(params)) {
              error = success;
              success = params;
              params = {};
            }
            var result = Resource[name].call(this, params, this, success, error);
            return result.$promise || result;
          };
        });
        Resource.bind = function(additionalParamDefaults) {
          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
        };
        return Resource;
      }
      return resourceFactory;
    }];
  });
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-route.js */
(function(window, angular) {
  'use strict';

  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }
  var isArray;
  var isObject;
  var ngRouteModule = angular.module('ngRoute', ['ng']).
  provider('$route', $RouteProvider),
    $routeMinErr = angular.$$minErr('ngRoute');

  function $RouteProvider() {
    isArray = angular.isArray;
    isObject = angular.isObject;

    function inherit(parent, extra) {
      return angular.extend(Object.create(parent), extra);
    }
    var routes = {};
    this.when = function(path, route) {
      var routeCopy = shallowCopy(route);
      if (angular.isUndefined(routeCopy.reloadOnSearch)) {
        routeCopy.reloadOnSearch = true;
      }
      if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
        routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
      }
      routes[path] = angular.extend(
        routeCopy,
        path && pathRegExp(path, routeCopy)
      );
      if (path) {
        var redirectPath = (path[path.length - 1] == '/') ?
          path.substr(0, path.length - 1) :
          path + '/';
        routes[redirectPath] = angular.extend({
            redirectTo: path
          },
          pathRegExp(redirectPath, routeCopy)
        );
      }
      return this;
    };
    this.caseInsensitiveMatch = false;

    function pathRegExp(path, opts) {
      var insensitive = opts.caseInsensitiveMatch,
        ret = {
          originalPath: path,
          regexp: path
        },
        keys = ret.keys = [];
      path = path
        .replace(/([().])/g, '\\$1')
        .replace(/(\/)?:(\w+)(\*\?|[\?\*])?/g, function(_, slash, key, option) {
          var optional = (option === '?' || option === '*?') ? '?' : null;
          var star = (option === '*' || option === '*?') ? '*' : null;
          keys.push({
            name: key,
            optional: !!optional
          });
          slash = slash || '';
          return '' +
            (optional ? '' : slash) +
            '(?:' +
            (optional ? slash : '') +
            (star && '(.+?)' || '([^/]+)') +
            (optional || '') +
            ')' +
            (optional || '');
        })
        .replace(/([\/$\*])/g, '\\$1');
      ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
      return ret;
    }
    this.otherwise = function(params) {
      if (typeof params === 'string') {
        params = {
          redirectTo: params
        };
      }
      this.when(null, params);
      return this;
    };
    this.$get = ['$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$templateRequest',
      '$sce',
      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
        var forceReload = false,
          preparedRoute,
          preparedRouteIsUpdateOnly,
          $route = {
            routes: routes,
            reload: function() {
              forceReload = true;
              var fakeLocationEvent = {
                defaultPrevented: false,
                preventDefault: function fakePreventDefault() {
                  this.defaultPrevented = true;
                  forceReload = false;
                }
              };
              $rootScope.$evalAsync(function() {
                prepareRoute(fakeLocationEvent);
                if (!fakeLocationEvent.defaultPrevented) commitRoute();
              });
            },
            updateParams: function(newParams) {
              if (this.current && this.current.$$route) {
                newParams = angular.extend({}, this.current.params, newParams);
                $location.path(interpolate(this.current.$$route.originalPath, newParams));
                $location.search(newParams);
              } else {
                throw $routeMinErr('norout', 'Tried updating route when with no current route');
              }
            }
          };
        $rootScope.$on('$locationChangeStart', prepareRoute);
        $rootScope.$on('$locationChangeSuccess', commitRoute);
        return $route;

        function switchRouteMatcher(on, route) {
          var keys = route.keys,
            params = {};
          if (!route.regexp) return null;
          var m = route.regexp.exec(on);
          if (!m) return null;
          for (var i = 1, len = m.length; i < len; ++i) {
            var key = keys[i - 1];
            var val = m[i];
            if (key && val) {
              params[key.name] = val;
            }
          }
          return params;
        }

        function prepareRoute($locationEvent) {
          var lastRoute = $route.current;
          preparedRoute = parseRoute();
          preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route &&
            angular.equals(preparedRoute.pathParams, lastRoute.pathParams) &&
            !preparedRoute.reloadOnSearch && !forceReload;
          if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
            if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
              if ($locationEvent) {
                $locationEvent.preventDefault();
              }
            }
          }
        }

        function commitRoute() {
          var lastRoute = $route.current;
          var nextRoute = preparedRoute;
          if (preparedRouteIsUpdateOnly) {
            lastRoute.params = nextRoute.params;
            angular.copy(lastRoute.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', lastRoute);
          } else if (nextRoute || lastRoute) {
            forceReload = false;
            $route.current = nextRoute;
            if (nextRoute) {
              if (nextRoute.redirectTo) {
                if (angular.isString(nextRoute.redirectTo)) {
                  $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)
                    .replace();
                } else {
                  $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))
                    .replace();
                }
              }
            }
            $q.when(nextRoute).
            then(resolveLocals).
            then(function(locals) {
              if (nextRoute == $route.current) {
                if (nextRoute) {
                  nextRoute.locals = locals;
                  angular.copy(nextRoute.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
              }
            }, function(error) {
              if (nextRoute == $route.current) {
                $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
              }
            });
          }
        }

        function resolveLocals(route) {
          if (route) {
            var locals = angular.extend({}, route.resolve);
            angular.forEach(locals, function(value, key) {
              locals[key] = angular.isString(value) ?
                $injector.get(value) :
                $injector.invoke(value, null, null, key);
            });
            var template = getTemplateFor(route);
            if (angular.isDefined(template)) {
              locals['$template'] = template;
            }
            return $q.all(locals);
          }
        }

        function getTemplateFor(route) {
          var template, templateUrl;
          if (angular.isDefined(template = route.template)) {
            if (angular.isFunction(template)) {
              template = template(route.params);
            }
          } else if (angular.isDefined(templateUrl = route.templateUrl)) {
            if (angular.isFunction(templateUrl)) {
              templateUrl = templateUrl(route.params);
            }
            if (angular.isDefined(templateUrl)) {
              route.loadedTemplateUrl = $sce.valueOf(templateUrl);
              template = $templateRequest(templateUrl);
            }
          }
          return template;
        }

        function parseRoute() {
          var params, match;
          angular.forEach(routes, function(route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), route))) {
              match = inherit(route, {
                params: angular.extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }

        function interpolate(string, params) {
          var result = [];
          angular.forEach((string || '').split(':'), function(segment, i) {
            if (i === 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  ngRouteModule.provider('$routeParams', $RouteParamsProvider);

  function $RouteParamsProvider() {
    this.$get = function() {
      return {};
    };
  }
  ngRouteModule.directive('ngView', ngViewFactory);
  ngRouteModule.directive('ngView', ngViewFillContentFactory);
  ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];

  function ngViewFactory($route, $anchorScroll, $animate) {
    return {
      restrict: 'ECA',
      terminal: true,
      priority: 400,
      transclude: 'element',
      link: function(scope, $element, attr, ctrl, $transclude) {
        var currentScope,
          currentElement,
          previousLeaveAnimation,
          autoScrollExp = attr.autoscroll,
          onloadExp = attr.onload || '';
        scope.$on('$routeChangeSuccess', update);
        update();

        function cleanupLastView() {
          if (previousLeaveAnimation) {
            $animate.cancel(previousLeaveAnimation);
            previousLeaveAnimation = null;
          }
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            previousLeaveAnimation = $animate.leave(currentElement);
            previousLeaveAnimation.then(function() {
              previousLeaveAnimation = null;
            });
            currentElement = null;
          }
        }

        function update() {
          var locals = $route.current && $route.current.locals,
            template = locals && locals.$template;
          if (angular.isDefined(template)) {
            var newScope = scope.$new();
            var current = $route.current;
            var clone = $transclude(newScope, function(clone) {
              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
                if (angular.isDefined(autoScrollExp) &&
                  (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              });
              cleanupLastView();
            });
            currentElement = clone;
            currentScope = current.scope = newScope;
            currentScope.$emit('$viewContentLoaded');
            currentScope.$eval(onloadExp);
          } else {
            cleanupLastView();
          }
        }
      }
    };
  }
  ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];

  function ngViewFillContentFactory($compile, $controller, $route) {
    return {
      restrict: 'ECA',
      priority: -400,
      link: function(scope, $element) {
        var current = $route.current,
          locals = current.locals;
        $element.html(locals.$template);
        var link = $compile($element.contents());
        if (current.controller) {
          locals.$scope = scope;
          var controller = $controller(current.controller, locals);
          if (current.controllerAs) {
            scope[current.controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }
        scope[current.resolveAs || '$resolve'] = locals;
        link(scope);
      }
    };
  }
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-touch.js */
(function(window, angular) {
  'use strict';
  var ngTouch = angular.module('ngTouch', []);
  ngTouch.provider('$touch', $TouchProvider);

  function nodeName_(element) {
    return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));
  }
  $TouchProvider.$inject = ['$provide', '$compileProvider'];

  function $TouchProvider($provide, $compileProvider) {
    var ngClickOverrideEnabled = false;
    var ngClickDirectiveAdded = false;
    this.ngClickOverrideEnabled = function(enabled) {
      if (angular.isDefined(enabled)) {
        if (enabled && !ngClickDirectiveAdded) {
          ngClickDirectiveAdded = true;
          ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';
          $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);
          $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
            if (ngClickOverrideEnabled) {
              $delegate.shift();
            } else {
              var i = $delegate.length - 1;
              while (i >= 0) {
                if ($delegate[i].$$moduleName === 'ngTouch') {
                  $delegate.splice(i, 1);
                  break;
                }
                i--;
              }
            }
            return $delegate;
          }]);
        }
        ngClickOverrideEnabled = enabled;
        return this;
      }
      return ngClickOverrideEnabled;
    };
    this.$get = function() {
      return {
        ngClickOverrideEnabled: function() {
          return ngClickOverrideEnabled;
        }
      };
    };
  }
  ngTouch.factory('$swipe', [function() {
    var MOVE_BUFFER_RADIUS = 10;
    var POINTER_EVENTS = {
      'mouse': {
        start: 'mousedown',
        move: 'mousemove',
        end: 'mouseup'
      },
      'touch': {
        start: 'touchstart',
        move: 'touchmove',
        end: 'touchend',
        cancel: 'touchcancel'
      },
      'pointer': {
        start: 'pointerdown',
        move: 'pointermove',
        end: 'pointerup',
        cancel: 'pointercancel'
      }
    };

    function getCoordinates(event) {
      var originalEvent = event.originalEvent || event;
      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];
      var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];
      return {
        x: e.clientX,
        y: e.clientY
      };
    }

    function getEvents(pointerTypes, eventType) {
      var res = [];
      angular.forEach(pointerTypes, function(pointerType) {
        var eventName = POINTER_EVENTS[pointerType][eventType];
        if (eventName) {
          res.push(eventName);
        }
      });
      return res.join(' ');
    }
    return {
      bind: function(element, eventHandlers, pointerTypes) {
        var totalX, totalY;
        var startCoords;
        var lastPos;
        var active = false;
        pointerTypes = pointerTypes || ['mouse', 'touch', 'pointer'];
        element.on(getEvents(pointerTypes, 'start'), function(event) {
          startCoords = getCoordinates(event);
          active = true;
          totalX = 0;
          totalY = 0;
          lastPos = startCoords;
          eventHandlers['start'] && eventHandlers['start'](startCoords, event);
        });
        var events = getEvents(pointerTypes, 'cancel');
        if (events) {
          element.on(events, function(event) {
            active = false;
            eventHandlers['cancel'] && eventHandlers['cancel'](event);
          });
        }
        element.on(getEvents(pointerTypes, 'move'), function(event) {
          if (!active) return;
          if (!startCoords) return;
          var coords = getCoordinates(event);
          totalX += Math.abs(coords.x - lastPos.x);
          totalY += Math.abs(coords.y - lastPos.y);
          lastPos = coords;
          if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
            return;
          }
          if (totalY > totalX) {
            active = false;
            eventHandlers['cancel'] && eventHandlers['cancel'](event);
            return;
          } else {
            event.preventDefault();
            eventHandlers['move'] && eventHandlers['move'](coords, event);
          }
        });
        element.on(getEvents(pointerTypes, 'end'), function(event) {
          if (!active) return;
          active = false;
          eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);
        });
      }
    };
  }]);
  var ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',
    function($parse, $timeout, $rootElement) {
      var TAP_DURATION = 750;
      var MOVE_TOLERANCE = 12;
      var PREVENT_DURATION = 2500;
      var CLICKBUSTER_THRESHOLD = 25;
      var ACTIVE_CLASS_NAME = 'ng-click-active';
      var lastPreventedTime;
      var touchCoordinates;
      var lastLabelClickCoordinates;

      function hit(x1, y1, x2, y2) {
        return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
      }

      function checkAllowableRegions(touchCoordinates, x, y) {
        for (var i = 0; i < touchCoordinates.length; i += 2) {
          if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
            touchCoordinates.splice(i, i + 2);
            return true;
          }
        }
        return false;
      }

      function onClick(event) {
        if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
          return;
        }
        var touches = event.touches && event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (x < 1 && y < 1) {
          return;
        }
        if (lastLabelClickCoordinates &&
          lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
          return;
        }
        if (lastLabelClickCoordinates) {
          lastLabelClickCoordinates = null;
        }
        if (nodeName_(event.target) === 'label') {
          lastLabelClickCoordinates = [x, y];
        }
        if (checkAllowableRegions(touchCoordinates, x, y)) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        event.target && event.target.blur && event.target.blur();
      }

      function onTouchStart(event) {
        var touches = event.touches && event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        touchCoordinates.push(x, y);
        $timeout(function() {
          for (var i = 0; i < touchCoordinates.length; i += 2) {
            if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {
              touchCoordinates.splice(i, i + 2);
              return;
            }
          }
        }, PREVENT_DURATION, false);
      }

      function preventGhostClick(x, y) {
        if (!touchCoordinates) {
          $rootElement[0].addEventListener('click', onClick, true);
          $rootElement[0].addEventListener('touchstart', onTouchStart, true);
          touchCoordinates = [];
        }
        lastPreventedTime = Date.now();
        checkAllowableRegions(touchCoordinates, x, y);
      }
      return function(scope, element, attr) {
        var clickHandler = $parse(attr.ngClick),
          tapping = false,
          tapElement,
          startTime,
          touchStartX,
          touchStartY;

        function resetState() {
          tapping = false;
          element.removeClass(ACTIVE_CLASS_NAME);
        }
        element.on('touchstart', function(event) {
          tapping = true;
          tapElement = event.target ? event.target : event.srcElement;
          if (tapElement.nodeType == 3) {
            tapElement = tapElement.parentNode;
          }
          element.addClass(ACTIVE_CLASS_NAME);
          startTime = Date.now();
          var originalEvent = event.originalEvent || event;
          var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];
          var e = touches[0];
          touchStartX = e.clientX;
          touchStartY = e.clientY;
        });
        element.on('touchcancel', function(event) {
          resetState();
        });
        element.on('touchend', function(event) {
          var diff = Date.now() - startTime;
          var originalEvent = event.originalEvent || event;
          var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?
            originalEvent.changedTouches :
            ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);
          var e = touches[0];
          var x = e.clientX;
          var y = e.clientY;
          var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
          if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
            preventGhostClick(x, y);
            if (tapElement) {
              tapElement.blur();
            }
            if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
              element.triggerHandler('click', [event]);
            }
          }
          resetState();
        });
        element.onclick = function(event) {};
        element.on('click', function(event, touchend) {
          scope.$apply(function() {
            clickHandler(scope, {
              $event: (touchend || event)
            });
          });
        });
        element.on('mousedown', function(event) {
          element.addClass(ACTIVE_CLASS_NAME);
        });
        element.on('mousemove mouseup', function(event) {
          element.removeClass(ACTIVE_CLASS_NAME);
        });
      };
    }
  ];

  function makeSwipeDirective(directiveName, direction, eventName) {
    ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {
      var MAX_VERTICAL_DISTANCE = 75;
      var MAX_VERTICAL_RATIO = 0.3;
      var MIN_HORIZONTAL_DISTANCE = 30;
      return function(scope, element, attr) {
        var swipeHandler = $parse(attr[directiveName]);
        var startCoords, valid;

        function validSwipe(coords) {
          if (!startCoords) return false;
          var deltaY = Math.abs(coords.y - startCoords.y);
          var deltaX = (coords.x - startCoords.x) * direction;
          return valid &&
            deltaY < MAX_VERTICAL_DISTANCE &&
            deltaX > 0 &&
            deltaX > MIN_HORIZONTAL_DISTANCE &&
            deltaY / deltaX < MAX_VERTICAL_RATIO;
        }
        var pointerTypes = ['touch'];
        if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {
          pointerTypes.push('mouse');
        }
        $swipe.bind(element, {
          'start': function(coords, event) {
            startCoords = coords;
            valid = true;
          },
          'cancel': function(event) {
            valid = false;
          },
          'end': function(coords, event) {
            if (validSwipe(coords)) {
              scope.$apply(function() {
                element.triggerHandler(eventName);
                swipeHandler(scope, {
                  $event: event
                });
              });
            }
          }
        }, pointerTypes);
      };
    }]);
  }
  makeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');
  makeSwipeDirective('ngSwipeRight', 1, 'swiperight');
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-cookies.js */
(function(window, angular) {
  'use strict';
  angular.module('ngCookies', ['ng']).
  provider('$cookies', [function $CookiesProvider() {
    var defaults = this.defaults = {};

    function calcOptions(options) {
      return options ? angular.extend({}, defaults, options) : defaults;
    }
    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
      return {
        get: function(key) {
          return $$cookieReader()[key];
        },
        getObject: function(key) {
          var value = this.get(key);
          return value ? angular.fromJson(value) : value;
        },
        getAll: function() {
          return $$cookieReader();
        },
        put: function(key, value, options) {
          $$cookieWriter(key, value, calcOptions(options));
        },
        putObject: function(key, value, options) {
          this.put(key, angular.toJson(value), options);
        },
        remove: function(key, options) {
          $$cookieWriter(key, undefined, calcOptions(options));
        }
      };
    }];
  }]);
  angular.module('ngCookies').
  factory('$cookieStore', ['$cookies', function($cookies) {
    return {
      get: function(key) {
        return $cookies.getObject(key);
      },
      put: function(key, value) {
        $cookies.putObject(key, value);
      },
      remove: function(key) {
        $cookies.remove(key);
      }
    };
  }]);

  function $$CookieWriter($document, $log, $browser) {
    var cookiePath = $browser.baseHref();
    var rawDocument = $document[0];

    function buildCookieString(name, value, options) {
      var path, expires;
      options = options || {};
      expires = options.expires;
      path = angular.isDefined(options.path) ? options.path : cookiePath;
      if (angular.isUndefined(value)) {
        expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
        value = '';
      }
      if (angular.isString(expires)) {
        expires = new Date(expires);
      }
      var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
      str += path ? ';path=' + path : '';
      str += options.domain ? ';domain=' + options.domain : '';
      str += expires ? ';expires=' + expires.toUTCString() : '';
      str += options.secure ? ';secure' : '';
      var cookieLength = str.length + 1;
      if (cookieLength > 4096) {
        $log.warn("Cookie '" + name +
          "' possibly not set or overflowed because it was too large (" +
          cookieLength + " > 4096 bytes)!");
      }
      return str;
    }
    return function(name, value, options) {
      rawDocument.cookie = buildCookieString(name, value, options);
    };
  }
  $$CookieWriter.$inject = ['$document', '$log', '$browser'];
  angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
    this.$get = $$CookieWriter;
  });
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.8/angular-aria.js */
(function(window, angular) {
  'use strict';
  var ngAriaModule = angular.module('ngAria', ['ng']).
  provider('$aria', $AriaProvider);
  var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
  var isNodeOneOf = function(elem, nodeTypeArray) {
    if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
      return true;
    }
  };

  function $AriaProvider() {
    var config = {
      ariaHidden: true,
      ariaChecked: true,
      ariaReadonly: true,
      ariaDisabled: true,
      ariaRequired: true,
      ariaInvalid: true,
      ariaValue: true,
      tabindex: true,
      bindKeypress: true,
      bindRoleForClick: true
    };
    this.config = function(newConfig) {
      config = angular.extend(config, newConfig);
    };

    function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
      return function(scope, elem, attr) {
        var ariaCamelName = attr.$normalize(ariaAttr);
        if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
          scope.$watch(attr[attrName], function(boolVal) {
            boolVal = negate ? !boolVal : !!boolVal;
            elem.attr(ariaAttr, boolVal);
          });
        }
      };
    }
    this.$get = function() {
      return {
        config: function(key) {
          return config[key];
        },
        $$watchExpr: watchExpr
      };
    };
  }
  ngAriaModule.directive('ngShow', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
    }])
    .directive('ngHide', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
    }])
    .directive('ngValue', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
    }])
    .directive('ngChecked', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
    }])
    .directive('ngReadonly', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngReadonly', 'aria-readonly', nodeBlackList, false);
    }])
    .directive('ngRequired', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
    }])
    .directive('ngModel', ['$aria', function($aria) {
      function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
        return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));
      }

      function shouldAttachRole(role, elem) {
        return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');
      }

      function getShape(attr, elem) {
        var type = attr.type,
          role = attr.role;
        return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :
          ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' :
          (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : '';
      }
      return {
        restrict: 'A',
        require: 'ngModel',
        priority: 200,
        compile: function(elem, attr) {
          var shape = getShape(attr, elem);
          return {
            pre: function(scope, elem, attr, ngModel) {
              if (shape === 'checkbox') {
                ngModel.$isEmpty = function(value) {
                  return value === false;
                };
              }
            },
            post: function(scope, elem, attr, ngModel) {
              var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);

              function ngAriaWatchModelValue() {
                return ngModel.$modelValue;
              }

              function getRadioReaction(newVal) {
                var boolVal = (attr.value == ngModel.$viewValue);
                elem.attr('aria-checked', boolVal);
              }

              function getCheckboxReaction() {
                elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
              }
              switch (shape) {
                case 'radio':
                case 'checkbox':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', shape);
                  }
                  if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                    scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?
                      getRadioReaction : getCheckboxReaction);
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
                case 'range':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', 'slider');
                  }
                  if ($aria.config('ariaValue')) {
                    var needsAriaValuemin = !elem.attr('aria-valuemin') &&
                      (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                    var needsAriaValuemax = !elem.attr('aria-valuemax') &&
                      (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                    var needsAriaValuenow = !elem.attr('aria-valuenow');
                    if (needsAriaValuemin) {
                      attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemin', newVal);
                      });
                    }
                    if (needsAriaValuemax) {
                      attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemax', newVal);
                      });
                    }
                    if (needsAriaValuenow) {
                      scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                        elem.attr('aria-valuenow', newVal);
                      });
                    }
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
              }
              if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required &&
                shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
                attr.$observe('required', function() {
                  elem.attr('aria-required', !!attr['required']);
                });
              }
              if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
                scope.$watch(function ngAriaInvalidWatch() {
                  return ngModel.$invalid;
                }, function ngAriaInvalidReaction(newVal) {
                  elem.attr('aria-invalid', !!newVal);
                });
              }
            }
          };
        }
      };
    }])
    .directive('ngDisabled', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
    }])
    .directive('ngMessages', function() {
      return {
        restrict: 'A',
        require: '?ngMessages',
        link: function(scope, elem, attr, ngMessages) {
          if (!elem.attr('aria-live')) {
            elem.attr('aria-live', 'assertive');
          }
        }
      };
    })
    .directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
      return {
        restrict: 'A',
        compile: function(elem, attr) {
          var fn = $parse(attr.ngClick, null, true);
          return function(scope, elem, attr) {
            if (!isNodeOneOf(elem, nodeBlackList)) {
              if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
                elem.attr('role', 'button');
              }
              if ($aria.config('tabindex') && !elem.attr('tabindex')) {
                elem.attr('tabindex', 0);
              }
              if ($aria.config('bindKeypress') && !attr.ngKeypress) {
                elem.on('keypress', function(event) {
                  var keyCode = event.which || event.keyCode;
                  if (keyCode === 32 || keyCode === 13) {
                    scope.$apply(callback);
                  }

                  function callback() {
                    fn(scope, {
                      $event: event
                    });
                  }
                });
              }
            }
          };
        }
      };
    }])
    .directive('ngDblclick', ['$aria', function($aria) {
      return function(scope, elem, attr) {
        if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
          elem.attr('tabindex', 0);
        }
      };
    }]);
})(window, window.angular);;
/*! RESOURCE: /scripts/app/base/_module.js */
angular.module('sn.base', ['sn.common.auth']);
window.countWatchers = window.countWatchers || function(root) {
  var watchers = [];
  var f = function(element) {
    angular.forEach(['$scope', '$isolateScope'], function(scopeProperty) {
      if (element.data() && element.data().hasOwnProperty(scopeProperty)) {
        angular.forEach(element.data()[scopeProperty].$$watchers, function(watcher) {
          watchers.push(watcher);
        });
      }
    });
    angular.forEach(element.children(), function(childElement) {
      f(angular.element(childElement));
    });
  };
  f(root);
  var watchersWithoutDuplicates = [];
  angular.forEach(watchers, function(item) {
    if (watchersWithoutDuplicates.indexOf(item) < 0) {
      watchersWithoutDuplicates.push(item);
    }
  });
  console.log(watchersWithoutDuplicates.length);
};;
/*! RESOURCE: /scripts/sn/common/auth/_module.js */
angular.module('sn.common.auth', []);
angular.module('sn.auth', ['sn.common.auth']);;
/*! RESOURCE: /scripts/sn/common/auth/service.authInterceptor.js */
angular.module('sn.common.auth').config(function($httpProvider) {
  $httpProvider.interceptors.push(function($rootScope, $q, $injector, $window, $log) {
    var LOG_PREFIX = '(authIntercepter) ';

    function error(response) {
      var status = response.status;
      if (status == 401) {
        var newPromise = handle401(response);
        if (newPromise)
          return newPromise;
      }
      return $q.reject(response);
    }

    function handle401(response) {
      if (canResendRequest(response)) {
        var deferredAgain = $q.defer();
        var $http = $injector.get('$http');
        $http(response.config).then(function success(newResponse) {
          deferredAgain.resolve(newResponse);
        }, function error(newResponse) {
          deferredAgain.reject(newResponse);
        });
        return deferredAgain.promise;
      }
      $log.info(LOG_PREFIX + 'User has been logged out');
      $rootScope.$broadcast("@page.login");
      return null;
    }

    function canResendRequest(response) {
      var headers = response.headers();
      var requestToken = response.config.headers['X-UserToken'];
      if (!requestToken) {
        requestToken = headers['x-usertoken-request'];
      }
      if ($window.g_ck && (requestToken !== $window.g_ck)) {
        $log.info(LOG_PREFIX + 'Token refreshed since request -- retrying');
        response.config.headers['X-UserToken'] = $window.g_ck;
        return true;
      }
      if (headers['x-sessionloggedin'] != 'true')
        return false;
      if (headers['x-usertoken-allowresubmit'] == 'false')
        return false;
      var token = headers['x-usertoken-response'];
      if (token) {
        $log.info(LOG_PREFIX + 'Received new token -- retrying');
        response.config.headers['X-UserToken'] = token;
        setToken(token);
        return true;
      }
      return false;
    }

    function setToken(token) {
      $window.g_ck = token;
      if (!token) {
        $httpProvider.defaults.headers.common["X-UserToken"] = 'token_intentionally_left_blank';
      } else {
        $httpProvider.defaults.headers.common["X-UserToken"] = token;
      }
      if ($window.jQuery) {
        jQuery.ajaxSetup({
          headers: {
            'X-UserToken': token
          }
        });
      }
      if ($window.Zepto) {
        if (!Zepto.ajaxSettings.headers)
          Zepto.ajaxSettings.headers = {};
        Zepto.ajaxSettings.headers['X-UserToken'] = token;
      }
    }
    setToken($window.g_ck);
    return {
      responseError: error
    }
  });
});;;
/*! RESOURCE: /scripts/libs/angular-tooltips/angular-tooltips.min.js */
/*
 * angular-tooltips
 * 1.0.7
 *
 * Angular.js tooltips module.
 * http://720kb.github.io/angular-tooltips
 *
 * MIT license
 * Tue Jan 26 2016
 */
! function(t, o) {
  "use strict";
  var e = "tooltips",
    i = function() {
      var t = [],
        e = 0,
        i = function(i) {
          i - e >= 15 ? (t.forEach(function(t) {
            t()
          }), e = i) : o.console.log("Skipped!")
        },
        r = function() {
          o.requestAnimationFrame(i)
        },
        l = function(o) {
          o && t.push(o)
        };
      return {
        add: function(e) {
          t.length || o.addEventListener("resize", r), l(e)
        }
      }
    }(),
    r = function(t) {
      var o = {};
      return t.removeAttr(e), void 0 !== t.attr("tooltip-template") && (o["tooltip-template"] = t.attr("tooltip-template"), t.removeAttr("tooltip-template")), void 0 !== t.attr("tooltip-template-url") && (o["tooltip-template-url"] = t.attr("tooltip-template-url"), t.removeAttr("tooltip-template-url")), void 0 !== t.attr("tooltip-controller") && (o["tooltip-controller"] = t.attr("tooltip-controller"), t.removeAttr("tooltip-controller")), void 0 !== t.attr("tooltip-side") && (o["tooltip-side"] = t.attr("tooltip-side"), t.removeAttr("tooltip-side")), void 0 !== t.attr("tooltip-show-trigger") && (o["tooltip-show-trigger"] = t.attr("tooltip-show-trigger"), t.removeAttr("tooltip-show-trigger")), void 0 !== t.attr("tooltip-hide-trigger") && (o["tooltip-hide-trigger"] = t.attr("tooltip-hide-trigger"), t.removeAttr("tooltip-hide-trigger")), void 0 !== t.attr("tooltip-smart") && (o["tooltip-smart"] = t.attr("tooltip-smart"), t.removeAttr("tooltip-smart")), void 0 !== t.attr("tooltip-class") && (o["tooltip-class"] = t.attr("tooltip-class"), t.removeAttr("tooltip-class")), void 0 !== t.attr("tooltip-close-button") && (o["tooltip-close-button"] = t.attr("tooltip-close-button"), t.removeAttr("tooltip-close-button")), void 0 !== t.attr("tooltip-size") && (o["tooltip-size"] = t.attr("tooltip-size"), t.removeAttr("tooltip-size")), void 0 !== t.attr("tooltip-speed") && (o["tooltip-speed"] = t.attr("tooltip-speed"), t.removeAttr("tooltip-speed")), o
    },
    l = function(t) {
      return o.getComputedStyle ? o.getComputedStyle(t, "") : t.currentStyle ? t.currentStyle : void 0
    },
    a = function(e) {
      for (var i, r, l = o.document.querySelectorAll("._exradicated-tooltip"), a = 0, n = l.length; n > a; a += 1)
        if (i = l.item(a), i && (r = t.element(i), r.data("_tooltip-parent") && r.data("_tooltip-parent") === e)) return r
    },
    n = function(t) {
      var o = a(t);
      o && o.remove()
    },
    s = function(t) {
      if (t) {
        var e = t[0].getBoundingClientRect();
        return e.top < 0 || e.top > o.document.body.offsetHeight || e.left < 0 || e.left > o.document.body.offsetWidth || e.bottom < 0 || e.bottom > o.document.body.offsetHeight || e.right < 0 || e.right > o.document.body.offsetWidth ? (t.css({
          top: "",
          left: "",
          bottom: "",
          right: ""
        }), !0) : !1
      }
      throw new Error("You must provide a position")
    },
    p = function() {
      var t = {
        side: "top",
        showTrigger: "mouseover",
        hideTrigger: "mouseleave",
        "class": "",
        smart: !1,
        closeButton: !1,
        size: "",
        speed: "steady"
      };
      return {
        configure: function(o) {
          var e, i = Object.keys(t),
            r = 0;
          if (o)
            for (; r < i.length; r += 1) e = i[r], e && o[e] && (t[e] = o[e])
        },
        $get: function() {
          return t
        }
      }
    },
    d = ["$log", "$http", "$compile", "$timeout", "$controller", "$injector", "tooltipsConf", function(e, p, d, c, m, u, g) {
      var f = function(e, u, f, v, h) {
        if (f.tooltipTemplate && f.tooltipTemplateUrl) throw new Error("You can not define tooltip-template and tooltip-url together");
        if (!f.tooltipTemplateUrl && !f.tooltipTemplate && f.tooltipController) throw new Error("You can not have a controller without a template or templateUrl defined");
        var C, _ = "_" + g.side,
          b = g.showTrigger,
          y = g.hideTrigger,
          w = g.size,
          S = "_" + g.speed;
        f.tooltipSide = f.tooltipSide || g.side, f.tooltipShowTrigger = f.tooltipShowTrigger || g.showTrigger, f.tooltipHideTrigger = f.tooltipHideTrigger || g.hideTrigger, f.tooltipClass = f.tooltipClass || g["class"], f.tooltipSmart = "true" === f.tooltipSmart || g.smart, f.tooltipCloseButton = f.tooltipCloseButton || g.closeButton.toString(), f.tooltipSize = f.tooltipSize || g.size, f.tooltipSpeed = f.tooltipSpeed || g.speed, f.tooltipAppendToBody = "true" === f.tooltipAppendToBody, h(e, function(e, g) {
          var v = r(e),
            h = t.element(o.document.createElement("tooltip")),
            T = t.element(o.document.createElement("tip-cont")),
            $ = t.element(o.document.createElement("tip")),
            A = t.element(o.document.createElement("tip-tip")),
            B = t.element(o.document.createElement("span")),
            z = t.element(o.document.createElement("tip-arrow")),
            E = function() {
              return T.html()
            },
            k = function(t) {
              void 0 !== t && T[0].getClientRects().length > 1 ? h.addClass("_multiline") : h.removeClass("_multiline")
            },
            P = function(e) {
              if ($.addClass("_hidden"), f.tooltipSmart) switch (f.tooltipSide) {
                case "top":
                  s($) && (h.removeClass("_top"), h.addClass("_left"), s($) && (h.removeClass("_left"), h.addClass("_bottom"), s($) && (h.removeClass("_bottom"), h.addClass("_right"), s($) && (h.removeClass("_right"), h.addClass("_top")))));
                  break;
                case "left":
                  s($) && (h.removeClass("_left"), h.addClass("_bottom"), s($) && (h.removeClass("_bottom"), h.addClass("_right"), s($) && (h.removeClass("_right"), h.addClass("_top"), s($) && (h.removeClass("_top"), h.addClass("_left")))));
                  break;
                case "bottom":
                  s($) && (h.removeClass("_bottom"), h.addClass("_left"), s($) && (h.removeClass("_left"), h.addClass("_top"), s($) && (h.removeClass("_top"), h.addClass("_right"), s($) && (h.removeClass("_right"), h.addClass("_bottom")))));
                  break;
                case "right":
                  s($) && (h.removeClass("_right"), h.addClass("_top"), s($) && (h.removeClass("_top"), h.addClass("_left"), s($) && (h.removeClass("_left"), h.addClass("_bottom"), s($) && (h.removeClass("_bottom"), h.addClass("_right")))));
                  break;
                default:
                  throw new Error("Position not supported")
              }
              if (f.tooltipAppendToBody) {
                var i, r, a, p, d, c = l(A[0]),
                  m = l(z[0]),
                  u = l($[0]),
                  g = $[0].getBoundingClientRect(),
                  v = t.copy($),
                  C = 0,
                  _ = c.length,
                  b = 0,
                  y = m.length,
                  w = 0,
                  S = u.length,
                  T = {},
                  B = {},
                  E = {};
                for ($.removeClass("_hidden"), v.removeClass("_hidden"), v.data("_tooltip-parent", h), n(h); _ > C; C += 1) i = c[C], i && c.getPropertyValue(i) && (T[i] = c.getPropertyValue(i));
                for (; y > b; b += 1) i = m[b], i && m.getPropertyValue(i) && (E[i] = m.getPropertyValue(i));
                for (; S > w; w += 1) i = u[w], i && "position" !== i && "display" !== i && "opacity" !== i && "z-index" !== i && "bottom" !== i && "height" !== i && "left" !== i && "right" !== i && "top" !== i && "width" !== i && u.getPropertyValue(i) && (B[i] = u.getPropertyValue(i));
                r = o.parseInt(u.getPropertyValue("padding-top"), 10), a = o.parseInt(u.getPropertyValue("padding-bottom"), 10), p = o.parseInt(u.getPropertyValue("padding-left"), 10), d = o.parseInt(u.getPropertyValue("padding-right"), 10), B.top = g.top + o.scrollY + "px", B.left = g.left + o.scrollX + "px", B.height = g.height - (r + a) + "px", B.width = g.width - (p + d) + "px", v.css(B), v.children().css(T), v.children().next().css(E), e && "true" !== f.tooltipHidden && (v.addClass("_exradicated-tooltip"), t.element(o.document.body).append(v))
              } else $.removeClass("_hidden"), e && "true" !== f.tooltipHidden && h.addClass("active")
            },
            x = function() {
              f.tooltipAppendToBody ? n(h) : h.removeClass("active")
            },
            H = function it(t) {
              var o, e = t.parent();
              t[0] && (t[0].scrollHeight > t[0].clientHeight || t[0].scrollWidth > t[0].clientWidth) && t.on("scroll", function() {
                var t = this;
                o && c.cancel(o), o = c(function() {
                  var o = a(h),
                    e = h[0].getBoundingClientRect(),
                    i = t.getBoundingClientRect();
                  e.top < i.top || e.bottom > i.bottom || e.left < i.left || e.right > i.right ? n(h) : o && P(!0)
                })
              }), e && e.length && it(e)
            },
            V = function(t) {
              t && (A.empty(), A.append(B), A.append(t), c(function() {
                P()
              }))
            },
            R = function(t) {
              t && p.get(t).then(function(t) {
                t && t.data && (A.empty(), A.append(B), A.append(d(t.data)(g)), c(function() {
                  P()
                }))
              })
            },
            W = function(t) {
              t && (_ && h.removeAttr("_" + _), h.addClass("_" + t), _ = t)
            },
            I = function(t) {
              t && (b && h.off(b), h.on(t, P), b = t)
            },
            U = function(t) {
              t && (y && h.off(y), h.on(t, x), y = t)
            },
            Y = function(t) {
              t && (C && $.removeClass(C), $.addClass(t), C = t)
            },
            j = function() {
              "boolean" != typeof f.tooltipSmart && (f.tooltipSmart = "true" === f.tooltipSmart)
            },
            q = function(t) {
              var o = "true" === t;
              o ? (B.on("click", x), B.css("display", "block")) : (B.off("click"), B.css("display", "none"))
            },
            O = function(o) {
              if (o) {
                var e, i = m(o, {
                    $scope: g
                  }),
                  r = g.$new(!1, g),
                  l = o.indexOf("as");
                l >= 0 ? (e = o.substr(l + 3), r[e] = i) : t.extend(r, i), A.replaceWith(d(A)(r)), Z()
              }
            },
            F = function(t) {
              t && (w && A.removeClass("_" + w), A.addClass("_" + t), w = t)
            },
            L = function(t) {
              t && (S && h.removeClass("_" + S), h.addClass("_" + t), S = t)
            },
            X = f.$observe("tooltipTemplate", V),
            D = f.$observe("tooltipTemplateUrl", R),
            G = f.$observe("tooltipSide", W),
            J = f.$observe("tooltipShowTrigger", I),
            K = f.$observe("tooltipHideTrigger", U),
            M = f.$observe("tooltipClass", Y),
            N = f.$observe("tooltipSmart", j),
            Q = f.$observe("tooltipCloseButton", q),
            Z = f.$observe("tooltipController", O),
            tt = f.$observe("tooltipSize", F),
            ot = f.$observe("tooltipSpeed", L),
            et = g.$watch(E, k);
          B.attr({
            id: "close-button"
          }), B.html("&times;"), $.addClass("_hidden"), A.append(B), A.append(f.tooltipTemplate), $.append(A), $.append(z), T.append(e), h.attr(v), h.addClass("tooltips"), h.append(T), h.append($), u.after(h), f.tooltipAppendToBody && (i.add(function() {
            H(h)
          }), H(h)), i.add(function() {
            k(), P()
          }), c(function() {
            P(), $.removeClass("_hidden"), h.addClass("_ready")
          }), g.$on("$destroy", function() {
            X(), D(), G(), J(), K(), M(), N(), Q(), tt(), ot(), et(), e.off(f.tooltipShowTrigger + " " + f.tooltipHideTrigger)
          })
        })
      };
      return {
        restrict: "A",
        transclude: "element",
        priority: 1,
        terminal: !0,
        link: f
      }
    }];
  t.module("720kb.tooltips", []).provider(e + "Conf", p).directive(e, d)
}(angular, window);
/*! RESOURCE: /scripts/sn/common/js_includes_common.js */
/*! RESOURCE: /scripts/sn/common/_module.js */
angular.module('sn.common', [
  'ngSanitize',
  'ngAnimate',
  'sn.common.avatar',
  'sn.common.controls',
  'sn.common.datetime',
  'sn.common.glide',
  'sn.common.i18n',
  'sn.common.link',
  'sn.common.mention',
  'sn.common.messaging',
  'sn.common.notification',
  'sn.common.presence',
  'sn.common.stream',
  'sn.common.ui',
  'sn.common.user_profile',
  'sn.common.util'
]);
angular.module('ng.common', [
  'sn.common'
]);;
/*! RESOURCE: /scripts/sn/common/dist/templates.js */
angular.module('sn.common.dist.templates', []);;
/*! RESOURCE: /scripts/sn/common/datetime/js_includes_datetime.js */
/*! RESOURCE: /scripts/sn/common/datetime/_module.js */
angular.module('sn.common.datetime', [
  'sn.common.i18n'
]);
angular.module('sn.timeAgo', [
  'sn.common.datetime'
]);;
/*! RESOURCE: /scripts/sn/common/datetime/directive.snTimeAgo.js */
angular.module('sn.common.datetime').constant('DATE_GRANULARITY', {
  DATETIME: 1,
  DATE: 2
});
angular.module('sn.common.datetime').factory('timeAgoTimer', function($interval, $rootScope, DATE_GRANULARITY) {
  "use strict";
  var digestInterval;
  return function(displayGranularityType) {
    displayGranularityType = typeof displayGranularityType !== 'undefined' ? displayGranularityType : DATE_GRANULARITY.DATETIME;
    if (!digestInterval && displayGranularityType == DATE_GRANULARITY.DATETIME)
      digestInterval = $interval(function() {
        $rootScope.$broadcast('sn.TimeAgo.tick');
      }, 30 * 1000);
    return Date.now();
  };
});
angular.module('sn.common.datetime').factory('timeAgo', function(timeAgoSettings, DATE_GRANULARITY) {
  var service = {
    settings: timeAgoSettings.get(),
    allowFuture: function allowFuture(bool) {
      this.settings.allowFuture = bool;
      return this;
    },
    toWords: function toWords(distanceMillis, messageGranularity) {
      messageGranularity = messageGranularity || DATE_GRANULARITY.DATETIME;
      var $l = service.settings.strings;
      var seconds = Math.abs(distanceMillis) / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;
      var prefix = $l.prefixAgo;
      var suffix = $l.suffixAgo;
      if ((seconds < 45 && messageGranularity == DATE_GRANULARITY.DATETIME) || (hours < 24 && messageGranularity == DATE_GRANULARITY.DATE))
        prefix = suffix = '';
      if (service.settings.allowFuture) {
        if (distanceMillis < 0) {
          prefix = suffix = "";
        }
      }
      if (!service.settings.allowFuture && distanceMillis < 0)
        prefix = suffix = "";

      function substitute(stringOrFunction, number) {
        var string = angular.isFunction(stringOrFunction) ?
          stringOrFunction(number, distanceMillis) : stringOrFunction;
        if (!string)
          return "";
        var value = ($l.numbers && $l.numbers[number]) || number;
        return string.replace(/%d/i, value);
      }
      var wantDate = messageGranularity == DATE_GRANULARITY.DATE;
      var wantDateTime = messageGranularity == DATE_GRANULARITY.DATETIME;
      var words = distanceMillis <= 0 && wantDateTime && substitute($l.justNow, 0) ||
        distanceMillis <= 0 && wantDate && substitute($l.today, 0) ||
        seconds < 45 && (distanceMillis >= 0 || !service.settings.allowFuture) && wantDateTime && substitute($l.justNow, Math.round(seconds)) ||
        seconds < 45 && wantDateTime && substitute($l.seconds, Math.round(seconds)) ||
        seconds < 90 && wantDateTime && substitute($l.minute, 1) ||
        minutes < 45 && wantDateTime && substitute($l.minutes, Math.round(minutes)) ||
        minutes < 90 && wantDateTime && substitute($l.hour, 1) ||
        hours < 24 && wantDateTime && substitute($l.hours, Math.round(hours)) ||
        hours < 24 && wantDate && substitute($l.today, 0) ||
        hours < 42 && substitute($l.day, 1) ||
        days < 30 && substitute($l.days, Math.ceil(days)) ||
        days < 45 && substitute($l.month, 1) ||
        days < 365 && substitute($l.months, Math.round(days / 30)) ||
        years < 1.5 && substitute($l.year, 1) ||
        substitute($l.years, Math.round(years));
      var separator = $l.wordSeparator === undefined ? " " : $l.wordSeparator;
      return [prefix, words, suffix].join(separator).trim();
    },
    parse: function(iso8601) {
      if (angular.isNumber(iso8601))
        return new Date(parseInt(iso8601, 10));
      var s = iso8601.trim();
      s = s.replace(/\.\d+/, "");
      s = s.replace(/-/, "/").replace(/-/, "/");
      s = s.replace(/T/, " ").replace(/Z/, " UTC");
      s = s.replace(/([\+\-]\d\d)\:?(\d\d)/, " $1$2");
      return new Date(s);
    }
  };
  return service;
});
angular.module('sn.common.datetime').directive("snTimeAgo", function(timeAgoSettings, $rootScope, timeAgo, timeAgoTimer, DATE_GRANULARITY) {
  "use strict";
  return {
    restrict: "E",
    template: '<time title="{{ ::titleTime }}">{{timeAgo}}</time>',
    scope: {
      timestamp: "=",
      local: "="
    },
    link: function(scope) {
      timeAgoSettings.ready.then(function() {
        timeAgoTimer(DATE_GRANULARITY.DATETIME)
        scope.$on('sn.TimeAgo.tick', setTimeAgo);
        setTimeAgo();
      });

      function setTimeAgo() {
        scope.timeAgo = timeAgoConverter(scope.timestamp, true);
      }

      function timeAgoConverter(input, noFuture) {
        if (!input)
          return;
        var allowFuture = !noFuture;
        var date = timeAgo.parse(input);
        if (scope.local) {
          scope.titleTime = input;
          return timeAgo.allowFuture(allowFuture).toWords(new Date() - date);
        }
        if (Object.prototype.toString.call(date) !== "[object Date]" && Object.prototype.toString.call(date) !== "[object Number]")
          return input;
        else if (Object.prototype.toString.call(date) == "[object Date]" && isNaN(date.getTime()))
          return input;
        setTitleTime(date);
        var currentDate = new Date();
        currentDate = new Date(currentDate.getUTCFullYear(), currentDate.getUTCMonth(), currentDate.getUTCDate(), currentDate.getUTCHours(), currentDate.getUTCMinutes(), currentDate.getUTCSeconds());
        var diff = currentDate - date;
        return timeAgo.allowFuture(allowFuture).toWords(diff);
      }

      function setTitleTime(date) {
        var t = date.getTime();
        var o = date.getTimezoneOffset();
        t -= o * 60 * 1000;
        scope.titleTime = new Date(t).toLocaleString();
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/datetime/directive.snDayAgo.js */
angular.module('sn.common.datetime').directive("snDayAgo", function(timeAgoSettings, $rootScope, timeAgo, timeAgoTimer, DATE_GRANULARITY) {
  "use strict";
  return {
    restrict: "E",
    template: '<time>{{dayAgo}}</time>',
    scope: {
      date: "="
    },
    link: function(scope) {
      timeAgoSettings.ready.then(function() {
        setDayAgo();
      });

      function setDayAgo() {
        scope.dayAgo = dayAgoConverter(scope.date, "noFuture");
      }

      function dayAgoConverter(input, option) {
        if (!input) return;
        var allowFuture = !((option === 'noFuture') || (option === 'no_future'));
        var date = timeAgo.parse(input);
        if (Object.prototype.toString.call(date) !== "[object Date]")
          return input;
        else if (isNaN(date.getTime()))
          return input;
        var diff = timeAgoTimer(DATE_GRANULARITY.DATE) - date;
        return timeAgo.allowFuture(allowFuture).toWords(diff, DATE_GRANULARITY.DATE);
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/datetime/snTimeAgoSettings.js */
angular.module('sn.common.datetime').provider('snTimeAgoSettings', function() {
  "use strict";
  var INIT_NEVER = 'never';
  var INIT_AUTO = 'auto';
  var INIT_MANUAL = 'manual';
  var _initMethod = INIT_AUTO;
  this.setInitializationMethod = function(init) {
    switch (init) {
      default: init = INIT_AUTO;
      case INIT_NEVER:
          case INIT_AUTO:
          case INIT_MANUAL:
          _initMethod = init;
        break;
    }
  };
  this.$get = function(i18n, $q) {
    var settings = {
      allowFuture: true,
      dateOnly: false,
      strings: {}
    };
    var _initialized = false;
    var ready = $q.defer();

    function initialize() {
      if (_initMethod === INIT_NEVER) {
        return $q.reject();
      }
      if (!_initialized) {
        _initialized = true;
        i18n.getMessages(['%d ago', '%d from now', 'just now',
          'less than a minute', 'about a minute', '%d minutes', 'about an hour', 'about %d hours', 'today', 'a day', '%d days',
          'about a month', '%d months', 'about a year', 'about a year', '%d years'
        ], function(msgs) {
          settings.strings = {
            ago: msgs['%d ago'],
            fromNow: msgs['%d from now'],
            justNow: msgs["just now"],
            seconds: msgs["less than a minute"],
            minute: msgs["about a minute"],
            minutes: msgs["%d minutes"],
            hour: msgs["about an hour"],
            hours: msgs["about %d hours"],
            day: msgs["a day"],
            days: msgs["%d days"],
            month: msgs["about a month"],
            months: msgs["%d months"],
            year: msgs["about a year"],
            years: msgs["%d years"],
            today: msgs["today"],
            wordSeparator: msgs["timeago_number_separator"],
            numbers: []
          };
          ready.resolve();
        });
      }
      return ready.promise;
    }
    if (_initMethod === INIT_AUTO) {
      initialize();
    }
    return {
      initialize: initialize,
      ready: ready.promise,
      get: function get() {
        return settings;
      },
      set: function set(translated) {
        settings = angular.extend(settings, translated);
      }
    };
  };
}).factory('timeAgoSettings', function(snTimeAgoSettings) {
  return snTimeAgoSettings;
});;;
/*! RESOURCE: /scripts/sn/common/glide/js_includes_glide.js */
/*! RESOURCE: /scripts/sn/common/glide/_module.js */
angular.module('sn.common.glide', [
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/sn/common/glide/factory.glideUrlBuilder.js */
angular.module('sn.common.glide').factory('glideUrlBuilder', ['$window', function($window) {
  "use strict";

  function GlideUrl(contextPath) {
    var objDef = {
      contextPath: '',
      params: {},
      encodedString: '',
      encode: true,
      setFromCurrent: function() {
        this.setFromString($window.location.href);
      },
      setFromString: function(href) {
        var pos = href.indexOf('?');
        if (pos < 0) {
          this.contextPath = href;
          return;
        }
        this.contextPath = href.slice(0, pos);
        var hashes = href.slice(pos + 1).split('&');
        var i = hashes.length;
        while (i--) {
          var pos = hashes[i].indexOf('=');
          this.params[hashes[i].substring(0, pos)] = hashes[i].substring(++pos);
        }
      },
      setContextPath: function(c) {
        this.contextPath = c;
      },
      getParam: function(p) {
        return this.params[p];
      },
      getParams: function() {
        return this.params;
      },
      addParam: function(name, value) {
        this.params[name] = value;
        return this;
      },
      addToken: function() {
        if (typeof g_ck != 'undefined' && g_ck != "")
          this.addParam('sysparm_ck', g_ck);
        return this;
      },
      deleteParam: function(name) {
        delete this.params[name];
      },
      addEncodedString: function(s) {
        if (!s)
          return;
        if (s.substr(0, 1) != "&")
          this.encodedString += "&";
        this.encodedString += s;
        return this;
      },
      getQueryString: function(additionalParams) {
        var qs = this._getParamsForURL(this.params);
        qs += this._getParamsForURL(additionalParams);
        qs += this.encodedString;
        if (qs.length == 0)
          return "";
        return qs.substring(1);
      },
      _getParamsForURL: function(params) {
        if (!params)
          return '';
        var url = '';
        for (var n in params) {
          var p = params[n] || '';
          url += '&' + n + '=' + (this.encode ? encodeURIComponent(p + '') : p);
        }
        return url;
      },
      getURL: function(additionalParams) {
        var url = this.contextPath;
        var qs = this.getQueryString(additionalParams);
        if (qs)
          url += "?" + qs;
        return url;
      },
      setEncode: function(b) {
        this.encode = b;
      },
      toString: function() {
        return 'GlideURL';
      }
    }
    return objDef;
  }
  return {
    newGlideUrl: function(contextPath) {
      var glideUrl = new GlideUrl();
      glideUrl.setFromString(contextPath ? contextPath : '');
      return glideUrl;
    },
    refresh: function() {
      $window.location.replace($window.location.href);
    },
    getCancelableLink: function(link) {
      if ($window.NOW && $window.NOW.g_cancelPreviousTransaction) {
        var nextChar = link.indexOf('?') > -1 ? '&' : '?';
        link += nextChar + "sysparm_cancelable=true";
      }
      return link;
    }
  };
}]);;
/*! RESOURCE: /scripts/sn/common/glide/service.queryFilter.js */
angular.module('sn.common.glide').factory('queryFilter', function() {
  "use strict";
  return {
    create: function() {
      var that = {};
      that.conditions = [];

      function newCondition(field, operator, value, label, displayValue, type) {
        var condition = {
          field: field,
          operator: operator,
          value: value,
          displayValue: displayValue,
          label: label,
          left: null,
          right: null,
          type: null,
          setValue: function(value, displayValue) {
            this.value = value;
            this.displayValue = displayValue ? displayValue : value;
          }
        };
        if (type)
          condition.type = type;
        return condition;
      }

      function addCondition(condition) {
        that.conditions.push(condition);
        return condition;
      }

      function removeCondition(condition) {
        for (var i = that.conditions.length - 1; i >= 0; i--) {
          if (that.conditions[i] === condition)
            that.conditions.splice(i, 1);
        }
      }

      function getConditionsByField(conditions, field) {
        var conditionsToReturn = [];
        for (var condition in conditions) {
          if (conditions.hasOwnProperty(condition)) {
            if (conditions[condition].field == field)
              conditionsToReturn.push(conditions[condition]);
          }
        }
        return conditionsToReturn;
      }

      function encodeCondition(condition) {
        var output = "";
        if (condition.hasOwnProperty("left") && condition.left) {
          output += encodeCondition(condition.left);
        }
        if (condition.hasOwnProperty("right") && condition.right) {
          var right = encodeCondition(condition.right);
          if (right.length > 0) {
            output += "^" + condition.type + right;
          }
        }
        if (condition.field) {
          output += condition.field;
          output += condition.operator;
          if (condition.value !== null && typeof condition.value !== "undefined")
            output += condition.value;
        }
        return output;
      }

      function createEncodedQuery() {
        var eq = "";
        var ca = that.conditions;
        for (var i = 0; i < ca.length; i++) {
          var condition = ca[i];
          if (eq.length)
            eq += '^';
          eq += encodeCondition(condition);
        }
        eq += "^EQ";
        return eq;
      }
      that.addCondition = addCondition;
      that.newCondition = newCondition;
      that.createEncodedQuery = createEncodedQuery;
      that.getConditionsByField = getConditionsByField;
      that.removeCondition = removeCondition;
      return that;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.filterExpressionParser.js */
angular.module('sn.common.glide').factory('filterExpressionParser', function() {
  'use strict';
  var operatorExpressions = [{
    wildcardExp: '(.*)',
    operator: 'STARTSWITH',
    toExpression: function(filter) {
      return filter;
    }
  }, {
    wildcardExp: '^\\*(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return (filter === '*' ? filter : '*' + filter);
    }
  }, {
    wildcardExp: '^\\.(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return '.' + filter;
    }
  }, {
    wildcardExp: '^%(.*)',
    operator: 'ENDSWITH',
    toExpression: function(filter) {
      return (filter === '%' ? filter : '%' + filter);
    }
  }, {
    wildcardExp: '(.*)%',
    operator: 'LIKE',
    toExpression: function(filter) {
      return filter + '%';
    }
  }, {
    wildcardExp: '^=(.*)',
    operator: '=',
    toExpression: function(filter) {
      return (filter === '=' ? filter : '=' + filter);
    }
  }, {
    wildcardExp: '^!\\*(.*)',
    operator: 'NOT LIKE',
    toExpression: function(filter) {
      return (filter === '!*' || filter === '!' ? filter : '!*' + filter);
    }
  }, {
    wildcardExp: '^!=(.*)',
    operator: '!=',
    toExpression: function(filter) {
      return (filter === '!=' || filter === '!' ? filter : '!=' + filter);
    }
  }];
  return {
    getOperatorExpressionForOperator: function(operator) {
      for (var i = 0; i < operatorExpressions.length; i++) {
        var item = operatorExpressions[i];
        if (item.operator === operator)
          return item;
      }
      throw {
        name: 'OperatorNotSupported',
        message: 'The operator ' + operator + ' is not in the list of operatorExpressions.'
      };
    },
    parse: function(val, defaultOperator) {
      var parsedValue = {
        filterText: val,
        operator: defaultOperator || 'STARTSWITH'
      };
      for (var i = 1; i < operatorExpressions.length; i++) {
        var operatorItem = operatorExpressions[i];
        var match = val.match(operatorItem.wildcardExp);
        if (match && match[1] !== '') {
          parsedValue.operator = operatorItem.operator;
          parsedValue.filterText = match[1];
        }
      }
      return parsedValue;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.userPreferences.js */
angular.module('sn.common.glide').factory("userPreferences", function($http, $q, unwrappedHTTPPromise, urlTools) {
  "use strict";
  var preferencesCache = {};

  function getPreference(preferenceName) {
    if (preferenceName in preferencesCache)
      return preferencesCache[preferenceName];
    var targetURL = urlTools.getURL('user_preference', {
        "sysparm_pref_name": preferenceName,
        "sysparm_action": "get"
      }),
      deferred = $q.defer();
    $http.get(targetURL).success(function(response) {
      deferred.resolve(response.sysparm_pref_value);
    }).error(function(data, status) {
      deferred.reject("Error getting preference " + preferenceName + ": " + status);
    });
    preferencesCache[preferenceName] = deferred.promise;
    return deferred.promise;
  }

  function setPreference(preferenceName, preferenceValue) {
    var targetURL = urlTools.getURL('user_preference', {
      "sysparm_pref_name": preferenceName,
      "sysparm_action": "set",
      "sysparm_pref_value": "" + preferenceValue
    });
    var httpPromise = $http.get(targetURL);
    addToCache(preferenceName, preferenceValue);
    return unwrappedHTTPPromise(httpPromise);
  }

  function addToCache(preferenceName, preferenceValue) {
    preferencesCache[preferenceName] = $q.when(preferenceValue);
  }
  var userPreferences = {
    getPreference: getPreference,
    setPreference: setPreference,
    addToCache: addToCache
  };
  return userPreferences;
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowStream.js */
angular.module('sn.common.glide').constant('nowStreamTimerInterval', 5000);
angular.module('sn.common.glide').factory('nowStream', function($q, $timeout, urlTools, nowStreamTimerInterval, snResource, $log) {
  'use strict';
  var Stream = function() {
    this.initialize.apply(this, arguments);
  };
  Stream.prototype = {
    initialize: function(table, query, sys_id, processor, interval, source, includeAttachments) {
      this.table = table;
      this.query = query;
      this.sysparmQuery = null;
      this.sys_id = sys_id;
      this.processor = processor;
      this.lastTimestamp = 0;
      this.inflightRequest = null;
      this.requestImmediateUpdate = false;
      this.interval = interval;
      this.source = source;
      this.includeAttachments = includeAttachments;
      this.stopped = true;
    },
    setQuery: function(sysparmQuery) {
      this.sysparmQuery = sysparmQuery;
    },
    poll: function(callback, preRequestCallback) {
      this.callback = callback;
      this.preRequestCallback = preRequestCallback;
      this._stopPolling();
      this._startPolling();
    },
    tap: function() {
      if (!this.inflightRequest) {
        this._stopPolling();
        this._startPolling();
      } else
        this.requestImmediateUpdate = true;
    },
    insert: function(field, text) {
      this.insertForEntry(field, text, this.table, this.sys_id);
    },
    insertForEntry: function(field, text, table, sys_id) {
      return this.insertEntries([{
        field: field,
        text: text
      }], table, sys_id);
    },
    expandMentions: function(entryText, mentionIDMap) {
      return entryText.replace(/@\[(.+?)\]/gi, function(mention) {
        var mentionedName = mention.substring(2, mention.length - 1);
        if (mentionIDMap[mentionedName]) {
          return "@[" + mentionIDMap[mentionedName] + ":" + mentionedName + "]";
        } else {
          return mention;
        }
      });
    },
    insertEntries: function(entries, table, sys_id, mentionIDMap) {
      mentionIDMap = mentionIDMap || {};
      var sanitizedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var entryText = entries[i].text;
        if (entryText && entryText.endsWith('\n'))
          entryText = entryText.substring(0, entryText.length - 1);
        if (!entryText)
          continue;
        entries[i].text = this.expandMentions(entryText, mentionIDMap);
        sanitizedEntries.push(entries[i]);
      }
      if (sanitizedEntries.length === 0)
        return;
      this._isInserting = true;
      var url = this._getInsertURL(table, sys_id);
      var that = this;
      return snResource().post(url, {
        entries: sanitizedEntries
      }).then(this._successCallback.bind(this), function() {
        $log.warn('Error submitting entries', sanitizedEntries);
      }).then(function() {
        that._isInserting = false;
      });
    },
    cancel: function() {
      this._stopPolling();
    },
    _startPolling: function() {
      var interval = this._getInterval();
      var that = this;
      var successCallback = this._successCallback.bind(this);
      that.stopped = false;

      function runPoll() {
        if (that._isInserting) {
          establishNextRequest();
          return;
        }
        if (!that.inflightRequest) {
          that.inflightRequest = that._executeRequest();
          that.inflightRequest.then(successCallback);
          that.inflightRequest.finally(function() {
            that.inflightRequest = null;
            if (that.requestImmediateUpdate) {
              that.requestImmediateUpdate = false;
              establishNextRequest(0);
            } else {
              establishNextRequest();
            }
          });
        }
      }

      function establishNextRequest(intervalOverride) {
        if (that.stopped)
          return;
        intervalOverride = (parseFloat(intervalOverride) >= 0) ? intervalOverride : interval;
        $timeout.cancel(that.timer);
        that.timer = $timeout(runPoll, intervalOverride);
      }
      runPoll();
    },
    _stopPolling: function() {
      if (this.timer)
        $timeout.cancel(this.timer);
      this.stopped = true;
    },
    _executeRequest: function() {
      var url = this._getURL();
      if (this.preRequestCallback) {
        this.preRequestCallback();
      }
      return snResource().get(url);
    },
    _getURL: function() {
      var params = {
        table: this.table,
        action: this._getAction(),
        sysparm_silent_request: true,
        sysparm_auto_request: true,
        sysparm_timestamp: this.lastTimestamp,
        include_attachments: this.includeAttachments
      };
      if (this.sys_id) {
        params['sys_id'] = this.sys_id;
      } else if (this.sysparmQuery) {
        params['sysparm_query'] = this.sysparmQuery;
      }
      var url = urlTools.getURL(this.processor, params);
      if (!this.sys_id) {
        url += "&p=" + this.query;
      }
      return url;
    },
    _getInsertURL: function(table, sys_id) {
      return urlTools.getURL(this.processor, {
        action: 'insert',
        table: table,
        sys_id: sys_id,
        sysparm_timestamp: this.timestamp || 0,
        sysparm_source: this.source
      });
    },
    _successCallback: function(response) {
      var response = response.data;
      if (response.entries && response.entries.length) {
        response.entries = this._filterOld(response.entries);
        if (response.entries.length > 0) {
          this.lastEntry = angular.copy(response.entries[0]);
          this.lastTimestamp = response.sys_timestamp || response.entries[0].sys_timestamp;
        }
      }
      this.callback.call(null, response);
    },
    _filterOld: function(entries) {
      for (var i = 0; i < entries.length; i++) {
        if (entries[i].sys_timestamp == this.lastTimestamp) {
          if (!angular.equals(this._makeComparable(entries[i]), this._makeComparable(this.lastEntry)))
            continue;
        }
        if (entries[i].sys_timestamp <= this.lastTimestamp)
          return entries.slice(0, i);
      }
      return entries;
    },
    _makeComparable: function(entry) {
      var copy = angular.copy(entry);
      delete copy.short_description;
      delete copy.display_value;
      return copy;
    },
    _getAction: function() {
      return this.sys_id ? 'get_new_entries' : 'get_set_entries';
    },
    _getInterval: function() {
      if (this.interval)
        return this.interval;
      else if (window.NOW && NOW.stream_poll_interval)
        return NOW.stream_poll_interval * 1000;
      else
        return nowStreamTimerInterval;
    }
  };
  return {
    create: function(table, query, sys_id, processor, interval, source) {
      return new Stream(table, query, sys_id, processor, interval, source);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowServer.js */
angular.module('sn.common.glide').factory('nowServer', function($http, $q, userPreferences, angularProcessorUrl, urlTools) {
  return {
    getBaseURL: function() {
      return angularProcessorUrl;
    },
    getPartial: function(scope, partial, parms, callback) {
      var url = this.getPartialURL(partial, parms);
      if (url === scope.url) {
        callback.call();
        return;
      }
      var fn = scope.$on('$includeContentLoaded', function() {
        fn.call();
        callback.call();
      });
      scope.url = url;
    },
    replaceView: function($location, newView) {
      var p = $location.path();
      var a = p.split("/");
      a[1] = newView;
      p = a.join("/");
      return p;
    },
    getPartialURL: urlTools.getPartialURL,
    getURL: urlTools.getURL,
    urlFor: urlTools.urlFor,
    getPropertyURL: urlTools.getPropertyURL,
    setPreference: userPreferences.setPreference,
    getPreference: userPreferences.getPreference
  }
});;;
/*! RESOURCE: /scripts/sn/common/avatar/js_includes_avatar.js */
/*! RESOURCE: /scripts/sn/common/presence/js_includes_presence.js */
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i < array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j < types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i < _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &&
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length < this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index >= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses && responses.length > 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i < _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length > 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength > _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length > 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i < lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout > 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null && webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel && !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j < messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index >= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length > 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect && _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported && !!org.cometd.WebSocket && _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i < arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep && typeof prop === 'object' && prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort && hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined && afterURI.length > 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions && subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription && !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i < subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '->', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions && subscriptions.length > 0) {
      for (var i = 0; i < subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i > 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined && message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch > 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff < _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length > 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch < 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length > 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() && _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i >= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription && !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i < rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i < subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport && typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' && define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON && JSON.stringify) || (window.jaredJSON && window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON && JSON.parse) || (window.jaredJSON && window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' && define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    if (window.console)
      console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i < _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i < _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i < subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out',
    SESSION_INVALIDATED: 'session.invalidated'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log(">>> connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -> ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected && connected)
      _connectionOpened();
    else if (wasConnected && !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        case 'session.invalidated':
          if (loggedIn)
            _invalidated();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }

  function _invalidated() {
    loggedIn = false;
    LOGGER.debug("INVALIDATED event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_INVALIDATED);
  }
  var modalContent = '<iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"></iframe>';
  var modalTemplate = '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '  <div class="modal-dialog small-modal" style="width:450px">' +
    '     <div class="modal-content">' +
    '        <header class="modal-header">' +
    '           <h4 id="small_modal1_title" class="modal-title">Login</h4>' +
    '        </header>' +
    '        <div class="modal-body">' +
    '        </div>' +
    '     </div>' +
    '  </div>' +
    '</div>';

  function _loginShow() {
    LOGGER.debug("Show login window");
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i < window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event && connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, this._subscribeWhenReady.bind(this));
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription && _initialized)
        this.subscribeToCometD();
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i < listeners.length; i++)
        listeners[i].resubscribe();
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    _handleResponse: function(message) {
      for (var i = 0; i < listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length < 1 && subscription && !_disconnected())
        this.unsubscribeFromCometD();
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    subscribeToCometD: function() {
      subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
      LOGGER.debug('Successfully subscribed to channel: ' + channelName);
    },
    unsubscribeFromCometD: function() {
      cometd.unsubscribe(subscription);
      subscription = null;
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    resubscribeToCometD: function() {
      this.subscribeToCometD();
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_OUT, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_INVALIDATED, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_IN, _resubscribeAll);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i < uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          _resubscribeAll()
          _connectionBrokenEvent = false;
        });
      }
    }

    function _unsubscribeAll() {
      LOGGER.debug("Unsubscribing from all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.unsubscribeFromCometD();
      }
    }

    function _resubscribeAll() {
      LOGGER.debug("Resubscribing to all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.resubscribeToCometD();
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage(">>> connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(window.jQuery || window.Zepto);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext && document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(window.jQuery || window.Zepto);;;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  ambClient = amb.getClient();
  if (_window.g_ambClient) {
    sameScope = true;
  }
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow && loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB && state !== "opened" && state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log(">>> init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log(">>> record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i < len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i < len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '	<div class="modal-dialog small-modal" style="width:450px">' +
    '		<div class="modal-content">' +
    '			<header class="modal-header">' +
    '				<h4 id="small_modal1_title" class="modal-title">{{title || "Login"}}</h4>' +
    '			</header>' +
    '			<div class="modal-body">' +
    '			<iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"></iframe>' +
    '			</div>' +
    '		</div>' +
    '	</div>' +
    '</div>'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/sn/common/presence/_module.js */
angular.module('sn.common.presence', ['ng.amb', 'sn.common.glide']).config(function($provide) {
  "use strict";
  $provide.constant("PRESENCE_DISABLED", "false" === "true");
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snPresence.js */
angular.module("sn.common.presence").factory('snPresence', function($rootScope, $window, $log, amb, $timeout, $http, snRecordPresence, snTabActivity, urlTools, PRESENCE_DISABLED) {
  "use strict";
  var REST = {
    PRESENCE: "/api/now/ui/presence"
  };
  var databaseInterval = ($window.NOW.presence_interval || 15) * 1000;
  var initialized = false;
  var primary = false;
  var presenceArray = [];
  var serverTimeMillis;
  var skew = 0;
  var st = 0;

  function init() {
    var location = urlTools.parseQueryString(window.location.search);
    var table = location['table'] || location['sysparm_table'];
    var sys_id = location['sys_id'] || location['sysparm_sys_id'];
    var query = location['sysparm_query'];
    initPresence(table, sys_id, query);
  }

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!initialized) {
      initialized = true;
      initRootScopes();
      if (!primary) {
        CustomEvent.observe('sn.presence', onPresenceEvent);
        CustomEvent.fireTop('sn.presence.ping');
      } else {
        presenceArray = getLocalPresence();
        if (presenceArray)
          $timeout(schedulePresence, 100);
        else
          updateDatabase();
      }
    }
    snRecordPresence.initPresence(t, id);
  }

  function onPresenceEvent(parms) {
    presenceArray = parms;
    $timeout(broadcastPresence);
  }

  function initRootScopes() {
    if ($window.NOW.presence_scopes) {
      var ps = $window.NOW.presence_scopes;
      if (ps.indexOf($rootScope) == -1)
        ps.push($rootScope);
    } else {
      $window.NOW.presence_scopes = [$rootScope];
      primary = CustomEvent.isTopWindow();
    }
  }

  function updateDatabase() {
    presenceArray = getLocalPresence();
    if (presenceArray) {
      determineStatus();
      $timeout(schedulePresence);
      return;
    }
    if (!amb.isLoggedIn() || !snTabActivity.isPrimary) {
      $timeout(schedulePresence);
      return;
    }
    var p = {
      user_agent: navigator.userAgent,
      ua_time: new Date().toISOString(),
      href: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      path: window.location.pathname + window.location.search
    };
    st = new Date().getTime();
    $http.post(REST.PRESENCE + '?sysparm_auto_request=true&cd=' + st, p).success(function(data) {
      var rt = new Date().getTime() - st;
      if (rt > 500)
        console.log("snPresence response time " + rt + "ms");
      if (data.result && data.result.presenceArray) {
        presenceArray = data.result.presenceArray;
        setLocalPresence(presenceArray);
        serverTimeMillis = data.result.serverTimeMillis;
        skew = new Date().getTime() - serverTimeMillis;
        var t = Math.floor(skew / 1000);
        if (t < -15)
          console.log(">>>>> server ahead " + Math.abs(t) + " seconds");
        else if (t > 15)
          console.log(">>>>> browser time ahead " + t + " seconds");
      }
      schedulePresence();
    }).error(function(response, status) {
      console.log("snPresence " + status);
      if (429 == status)
        $timeout(updateDatabase, databaseInterval);
      else
        schedulePresence();
    })
  }

  function schedulePresence() {
    $timeout(updateDatabase, databaseInterval);
    determineStatus();
    broadcastPresence();
  }

  function broadcastPresence() {
    $rootScope.$broadcast("sn.presence", presenceArray);
    if (!primary)
      return;
    CustomEvent.fireAll('sn.presence', presenceArray);
  }

  function determineStatus() {
    if (!presenceArray || !presenceArray.forEach)
      return;
    var t = new Date().getTime();
    t -= skew;
    presenceArray.forEach(function(p) {
      var x = 0 + p.last_on;
      var y = t - x;
      p.status = "online";
      if (y > (5 * databaseInterval))
        p.status = "offline";
      else if (y > (3 * databaseInterval))
        p.status = "probably offline";
      else if (y > (2.5 * databaseInterval))
        p.status = "maybe offline";
    })
  }

  function setLocalPresence(value) {
    var p = {
      saved: new Date().getTime(),
      presenceArray: value
    }
    $window.localStorage.setItem('snPresence', angular.toJson(p));
  }

  function getLocalPresence() {
    var p = $window.localStorage.getItem('snPresence');
    if (!p)
      return null;
    try {
      p = angular.fromJson(p);
    } catch (e) {
      p = {};
    }
    if (!p.presenceArray)
      return null;
    var now = new Date().getTime();
    if (now - p.saved >= databaseInterval)
      return null;
    return p.presenceArray;
  }
  return {
    init: init,
    initWithDocument: initPresence,
    initPresence: initPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snRecordPresence.js */
angular.module("sn.common.presence").factory('snRecordPresence', function($rootScope, $location, amb, $timeout, $window, PRESENCE_DISABLED, snTabActivity) {
  "use strict";
  var statChannel;
  var interval = ($window.NOW.record_presence_interval || 20) * 1000;
  var sessions = {};
  var primary = false;
  var table;
  var sys_id;

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!t || !id)
      return;
    if (t == table && id == sys_id)
      return;
    initRootScopes();
    if (!primary)
      return;
    termPresence();
    table = t;
    sys_id = id;
    var recordPresence = "/sn/rp/" + table + "/" + sys_id;
    $rootScope.me = NOW.session_id;
    statChannel = amb.getChannel(recordPresence);
    statChannel.subscribe(onStatus);
    amb.connected.then(function() {
      setStatus("entered");
      $rootScope.status = "viewing";
    });
    return statChannel;
  }

  function initRootScopes() {
    if ($window.NOW.record_presence_scopes) {
      var ps = $window.NOW.record_presence_scopes;
      if (ps.indexOf($rootScope) == -1) {
        ps.push($rootScope);
        CustomEvent.observe('sn.sessions', onPresenceEvent);
      }
    } else {
      $window.NOW.record_presence_scopes = [$rootScope];
      primary = true;
    }
  }

  function onPresenceEvent(sessionsToSend) {
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
  }

  function termPresence() {
    if (!statChannel)
      return;
    statChannel.unsubscribe();
    statChannel = table = sys_id = null;
  }

  function setStatus(status) {
    if (status == $rootScope.status)
      return;
    $rootScope.status = status;
    if (Object.keys(sessions).length == 0)
      return;
    if (getStatusPrecedence(status) > 1)
      return;
    publish($rootScope.status);
  }

  function publish(status) {
    if (!statChannel)
      return;
    if (amb.getState() !== "opened")
      return;
    statChannel.publish({
      presences: [{
        status: status,
        session_id: NOW.session_id,
        user_name: NOW.user_name,
        user_id: NOW.user_id,
        user_display_name: NOW.user_display_name,
        user_initials: NOW.user_initials,
        user_avatar: NOW.user_avatar,
        ua: navigator.userAgent,
        table: table,
        sys_id: sys_id,
        time: new Date().toString().substring(0, 24)
      }]
    });
  }

  function onStatus(message) {
    message.data.presences.forEach(function(d) {
      if (!d.session_id || d.session_id == NOW.session_id)
        return;
      var s = sessions[d.session_id];
      if (s)
        angular.extend(s, d);
      else
        s = sessions[d.session_id] = d;
      s.lastUpdated = new Date();
      if (s.status == 'exited')
        delete sessions[d.session_id];
    });
    broadcastSessions();
  }

  function broadcastSessions() {
    var sessionsToSend = getUniqueSessions();
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
    if (primary)
      $timeout(function() {
        CustomEvent.fire('sn.sessions', sessionsToSend);
      })
  }

  function getUniqueSessions() {
    var uniqueSessionsByUser = {};
    var sessionKeys = Object.keys(sessions);
    sessionKeys.forEach(function(key) {
      var session = sessions[key];
      if (session.user_id == NOW.user_id)
        return;
      if (session.user_id in uniqueSessionsByUser) {
        var otherSession = uniqueSessionsByUser[session.user_id];
        var thisPrecedence = getStatusPrecedence(session.status);
        var otherPrecedence = getStatusPrecedence(otherSession.status);
        uniqueSessionsByUser[session.user_id] = thisPrecedence < otherPrecedence ? session : otherSession;
        return
      }
      uniqueSessionsByUser[session.user_id] = session;
    });
    var uniqueSessions = {};
    angular.forEach(uniqueSessionsByUser, function(item) {
      uniqueSessions[item.session_id] = item;
    });
    return uniqueSessions;
  }

  function getStatusPrecedence(status) {
    switch (status) {
      case 'typing':
        return 0;
      case 'viewing':
        return 1;
      case 'entered':
        return 2;
      case 'exited':
      case 'probably left':
        return 4;
      case 'offline':
        return 5;
      default:
        return 3;
    }
  }
  $rootScope.$on("record.typing", function(evt, data) {
    setStatus(data.status);
  });
  var idleTable, idleSysID;
  snTabActivity.onIdle({
    onIdle: function RecordPresenceTabIdle() {
      idleTable = table;
      idleSysID = sys_id;
      sessions = {};
      termPresence();
      broadcastSessions();
    },
    onReturn: function RecordPresenceTabActive() {
      initPresence(idleTable, idleSysID, true);
      idleTable = idleSysID = void(0);
    },
    delay: interval * 4
  });
  return {
    initPresence: initPresence,
    termPresence: termPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snPresence.js */
angular.module('sn.common.presence').directive('snPresence', function(snPresence, $rootScope, $timeout) {
  'use strict';
  $timeout(snPresence.init, 100);
  var presences = {};
  $rootScope.$on('sn.presence', function(event, presenceArray) {
    if (!presenceArray) {
      angular.forEach(presences, function(p) {
        p.status = "offline";
      });
      return;
    }
    presenceArray.forEach(function(presence) {
      presences[presence.user] = presence;
    });
  });
  return {
    restrict: 'EA',
    replace: false,
    scope: {
      snPresence: '=?',
      user: '=?',
      profile: '=?'
    },
    link: function(scope, element) {
      if (scope.profile)
        scope.user = scope.profile.userID;
      if (!element.hasClass('presence'))
        element.addClass('presence');

      function updatePresence() {
        var id = scope.snPresence || scope.user;
        if (presences[id]) {
          var status = presences[id].status;
          if (status === 'maybe offline' || status === 'probably offline') {
            element.removeClass('presence-online presence-offline presence-away');
            element.addClass('presence-away');
          } else if (status == "offline" && !element.hasClass('presence-offline')) {
            element.removeClass('presence-online presence-away');
            element.addClass('presence-offline');
          } else if ((status == "online" || status == "entered" || status == "viewing") && !element.hasClass('presence-online')) {
            element.removeClass('presence-offline presence-away');
            element.addClass('presence-online');
          }
        } else {
          if (!element.hasClass('presence-offline'))
            element.addClass('presence-offline');
        }
      }
      $rootScope.$on('sn.presence', updatePresence);
      updatePresence();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snComposing.js */
angular.module('sn.common.presence').directive('snComposing', function(getTemplateUrl, snComposingPresence) {
  "use strict";
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl("snComposing.xml"),
    replace: true,
    scope: {
      conversation: "="
    },
    controller: function($scope, $element) {
      var child = $element.children();
      if (child && child.tooltip)
        child.tooltip({
          'template': '<div class="tooltip" style="white-space: pre-wrap" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
          'placement': 'top',
          'container': 'body'
        });
      $scope.snComposingPresence = snComposingPresence;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/service.snComposingPresence.js */
angular.module('sn.common.presence').service('snComposingPresence', function(i18n) {
  "use strict";
  var viewing = {};
  var typing = {};
  var allStrings = {};
  var shortStrings = {};
  var typing1 = "{0} is typing",
    typing2 = "{0} and {1} are typing",
    typingMore = "{0}, {1}, and {2} more are typing",
    viewing1 = "{0} is viewing",
    viewing2 = "{0} and {1} are viewing",
    viewingMore = "{0}, {1}, and {2} more are viewing";
  i18n.getMessages(
    [
      typing1,
      typing2,
      typingMore,
      viewing1,
      viewing2,
      viewingMore
    ],
    function(results) {
      typing1 = results[typing1];
      typing2 = results[typing2];
      typingMore = results[typingMore];
      viewing1 = results[viewing1];
      viewing2 = results[viewing2];
      viewingMore = results[viewingMore];
    });

  function set(conversationID, newPresenceValues) {
    if (newPresenceValues.viewing)
      viewing[conversationID] = newPresenceValues.viewing;
    if (newPresenceValues.typing)
      typing[conversationID] = newPresenceValues.typing;
    generateAllString(conversationID, {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    });
    generateShortString(conversationID, {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    });
    return {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    }
  }

  function get(conversationID) {
    return {
      viewing: viewing[conversationID] || [],
      typing: typing[conversationID] || []
    }
  }

  function generateAllString(conversationID, members) {
    var result = "";
    var typingLength = members.typing.length;
    var viewingLength = members.viewing.length;
    if (typingLength < 4 && viewingLength < 4)
      return "";
    switch (typingLength) {
      case 0:
        break;
      case 1:
        result += i18n.format(typing1, members.typing[0].name);
        break;
      case 2:
        result += i18n.format(typing2, members.typing[0].name, members.typing[1].name);
        break;
      default:
        var allButLastTyper = "";
        for (var i = 0; i < typingLength; i++) {
          if (i < typingLength - 2)
            allButLastTyper += members.typing[i].name + ", ";
          else if (i === typingLength - 2)
            allButLastTyper += members.typing[i].name + ",";
          else
            result += i18n.format(typing2, allButLastTyper, members.typing[i].name);
        }
    }
    if (viewingLength > 0 && typingLength > 0)
      result += "\n\n";
    switch (viewingLength) {
      case 0:
        break;
      case 1:
        result += i18n.format(viewing1, members.viewing[0].name);
        break;
      case 2:
        result += i18n.format(viewing2, members.viewing[0].name, members.viewing[1].name);
        break;
      default:
        var allButLastViewer = "";
        for (var i = 0; i < viewingLength; i++) {
          if (i < viewingLength - 2)
            allButLastViewer += members.viewing[i].name + ", ";
          else if (i === viewingLength - 2)
            allButLastViewer += members.viewing[i].name + ",";
          else
            result += i18n.format(viewing2, allButLastViewer, members.viewing[i].name);
        }
    }
    allStrings[conversationID] = result;
  }

  function generateShortString(conversationID, members) {
    var typingLength = members.typing.length;
    var viewingLength = members.viewing.length;
    var typingString = "",
      viewingString = "";
    var inBetween = " ";
    switch (typingLength) {
      case 0:
        break;
      case 1:
        typingString = i18n.format(typing1, members.typing[0].name);
        break;
      case 2:
        typingString = i18n.format(typing2, members.typing[0].name, members.typing[1].name);
        break;
      case 3:
        typingString = i18n.format(typing2, members.typing[0].name + ", " + members.typing[1].name + ",", members.typing[2].name);
        break;
      default:
        typingString = i18n.format(typingMore, members.typing[0].name, members.typing[1].name, (typingLength - 2));
    }
    if (viewingLength > 0 && typingLength > 0)
      inBetween = ". ";
    switch (viewingLength) {
      case 0:
        break;
      case 1:
        viewingString = i18n.format(viewing1, members.viewing[0].name);
        break;
      case 2:
        viewingString = i18n.format(viewing2, members.viewing[0].name, members.viewing[1].name);
        break;
      case 3:
        viewingString = i18n.format(viewing2, members.viewing[0].name + ", " + members.viewing[1].name + ",", members.viewing[2].name);
        break;
      default:
        viewingString = i18n.format(viewingMore, members.viewing[0].name, members.viewing[1].name, (viewingLength - 2));
    }
    shortStrings[conversationID] = typingString + inBetween + viewingString;
  }

  function getAllString(conversationID) {
    if ((viewing[conversationID] && viewing[conversationID].length > 3) ||
      (typing[conversationID] && typing[conversationID].length > 3))
      return allStrings[conversationID];
    return "";
  }

  function getShortString(conversationID) {
    return shortStrings[conversationID];
  }

  function remove(conversationID) {
    delete viewing[conversationID];
  }
  return {
    set: set,
    get: get,
    generateAllString: generateAllString,
    getAllString: getAllString,
    generateShortString: generateShortString,
    getShortString: getShortString,
    remove: remove
  }
});;;
/*! RESOURCE: /scripts/sn/common/user_profile/js_includes_user_profile.js */
/*! RESOURCE: /scripts/sn/common/user_profile/_module.js */
angular.module("sn.common.user_profile", ['sn.common.ui']);;
/*! RESOURCE: /scripts/sn/common/user_profile/directive.snUserProfile.js */
angular.module('sn.common.user_profile').directive('snUserProfile', function(getTemplateUrl, snCustomEvent, $window, avatarProfilePersister, $timeout, $http) {
  "use strict";
  return {
    replace: true,
    restrict: 'E',
    templateUrl: getTemplateUrl('snUserProfile.xml'),
    scope: {
      profile: "=",
      showDirectMessagePrompt: "="
    },
    link: function(scope) {
      scope.showDirectMessagePromptFn = function() {
        if (scope.showDirectMessagePrompt) {
          var activeUserID = $window.NOW.user_id || "";
          return !(!scope.profile ||
            activeUserID === scope.profile.sysID ||
            (scope.profile.document && activeUserID === scope.profile.document));
        } else {
          return false;
        }
      };
    },
    controller: function($scope, snConnectService) {
      if ($scope.profile && $scope.profile.userID && avatarProfilePersister.getAvatar($scope.profile.userID)) {
        $scope.profile = avatarProfilePersister.getAvatar($scope.profile.userID);
        $scope.$emit("sn-user-profile.ready");
      } else {
        $http.get('/api/now/live/profiles/sys_user.' + $scope.profile.userID).then(function(response) {
          angular.merge($scope.profile, response.data.result);
          avatarProfilePersister.setAvatar($scope.profile.userID, $scope.profile);
          $scope.$emit("sn-user-profile.ready");
        })
      }
      $scope.openDirectMessageConversation = function(evt) {
        if (evt.keyCode === 9)
          return;
        $timeout(function() {
          snConnectService.openWithProfile($scope.profile);
        }, 0, false);
        angular.element('.popover').each(function() {
          angular.element('body').off('click.snUserAvatarPopoverClose');
          angular.element(this).popover('hide');
        });
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/avatar/_module.js */
angular.module('sn.common.avatar', ['sn.common.presence', 'sn.common.messaging', 'sn.common.user_profile']).config(function($provide) {
  $provide.value("liveProfileID", '');
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snAvatarPopover.js */
angular.module('sn.common.avatar').directive('snAvatarPopover', function($http, $compile, getTemplateUrl, avatarProfilePersister, $injector) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_avatar_popover.xml'),
    replace: true,
    transclude: true,
    scope: {
      members: '=',
      primary: '=?',
      showPresence: '=?',
      enableContextMenu: '=?',
      enableTooltip: '=?',
      enableBindOnce: '@',
      displayMemberCount: "=?",
      groupAvatar: "@",
      nopopover: "=",
      directconversation: '@',
      conversation: '=',
      primaryNonAssign: '=?'
    },
    compile: function(tElement) {
      var template = tElement.html();
      return function(scope, element, attrs, controller, transcludeFn) {
        if (scope.directconversation) {
          if (scope.directconversation === "true")
            scope.directconversation = true;
          else
            scope.directconversation = false;
          scope.showdirectconversation = !scope.directconversation;
        } else {
          scope.showdirectconversation = true;
        }
        if ($injector.has('inSupportClient') && $injector.get('inSupportClient'))
          scope.showdirectconversation = false;
        if (scope.primaryNonAssign) {
          scope.primary = angular.extend({}, scope.primary, scope.primaryNonAssign);
          if (scope.users && scope.users[0])
            scope.users[0] = scope.primary;
        }

        function recompile() {
          if (scope.primaryNonAssign) {
            scope.primary = angular.extend({}, scope.primary, scope.primaryNonAssign);
            if (scope.users && scope.users[0])
              scope.users[0] = scope.primary;
          }
          var newElement = $compile(template, transcludeFn)(scope);
          element.html(newElement);
          if (scope.enableTooltip) {
            element.tooltip({
              placement: 'auto top',
              container: 'body'
            }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
            if (element.hideFix)
              element.hideFix();
          }
        }
        if (attrs.enableBindOnce === 'false') {
          scope.$watch('primary', recompile);
          scope.$watch('primaryNonAssign', recompile);
          scope.$watch('members', recompile);
        }
        if (scope.enableTooltip && scope.nopopover) {
          var usersWatch = scope.$watch('users', function() {
            if (scope.users && scope.users.length === 1 && scope.users[0] && scope.users[0].name) {
              element.tooltip({
                placement: 'auto top',
                container: 'body'
              }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
              if (element.hideFix)
                element.hideFix();
              usersWatch();
            }
          });
        }
      };
    },
    controller: function($scope, liveProfileID, $timeout, $element, $document, snCustomEvent) {
      $scope.randId = Math.random();
      $scope.loadEvent = 'sn-user-profile.ready';
      $scope.closeEvent = ['chat:open_conversation', 'snAvatar.closePopover', 'body_clicked'];
      $scope.popoverConfig = {
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><div class="popover-content"></div></div>'
      };
      $scope.displayMemberCount = $scope.displayMemberCount || false;
      $scope.liveProfileID = liveProfileID;
      if ($scope.primaryNonAssign) {
        $scope.primary = angular.extend({}, $scope.primary, $scope.primaryNonAssign);
        if ($scope.users && $scope.users[0])
          $scope.users[0] = $scope.primary;
      }
      $scope.$watch('members', function(newVal, oldVal) {
        if (newVal === oldVal)
          return;
        if ($scope.members)
          buildAvatar();
      });
      $scope.noPopover = function() {
        $scope.popoverCursor = ($scope.nopopover || ($scope.members && $scope.members.length > 2)) ? "default" : "pointer";
        return ($scope.nopopover || ($scope.members && $scope.members.length > 2));
      }
      $scope.avatarType = function() {
        var result = [];
        if ($scope.groupAvatar || !$scope.users)
          return result;
        if ($scope.users.length > 1)
          result.push("group")
        if ($scope.users.length === 2)
          result.push("avatar-duo")
        if ($scope.users.length === 3)
          result.push("avatar-trio")
        if ($scope.users.length >= 4)
          result.push("avatar-quad")
        return result;
      }
      $scope.getBackgroundStyle = function(user) {
        var avatar = (user ? user.avatar : '');
        if ($scope.groupAvatar)
          avatar = $scope.groupAvatar;
        if (avatar && avatar !== '')
          return {
            'background-image': 'url(' + avatar + ')'
          };
        if (user && user.name)
          return '';
        return void(0);
      };
      $scope.stopPropCheck = function(evt) {
        $scope.$broadcast("snAvatar.closeOtherPopovers", $scope.randId);
        if (!$scope.nopopover) {
          evt.stopPropagation();
        }
      };
      $scope.$on("snAvatar.closeOtherPopovers", function(id) {
        if (id !== $scope.randId)
          snCustomEvent.fireTop('snAvatar.closePopover');
      });
      $scope.maxStringWidth = function() {
        var paddedWidth = parseInt($scope.avatarWidth * 0.8, 10);
        return $scope.users.length === 1 ? paddedWidth : paddedWidth / 2;
      };

      function buildInitials(name) {
        if (!name)
          return "--";
        var initials = name.split(" ").map(function(word) {
          return word.toUpperCase();
        }).filter(function(word) {
          return word.match(/^[A-Z]/);
        }).map(function(word) {
          return word.substring(0, 1);
        }).join("");
        return (initials.length > 3) ?
          initials.substr(0, 3) :
          initials;
      }
      $scope.avatartooltip = function() {
        if (!$scope.enableTooltip) {
          return '';
        }
        if (!$scope.users) {
          return '';
        }
        var names = [];
        $scope.users.forEach(function(user) {
          if (!user) {
            return;
          }
          names.push(user.name);
        });
        return names.join(', ');
      };

      function buildAvatar() {
        if (typeof $scope.primary === 'string') {
          $http.get('/api/now/live/profiles/sys_user.' + $scope.primary).then(function(response) {
            $scope.users = [{
              userID: $scope.primary,
              name: response.data.result.name,
              initials: buildInitials(response.data.result.name),
              avatar: response.data.result.avatar
            }];
          });
          return;
        }
        if ($scope.primary) {
          if ($scope.primary.userImage)
            $scope.primary.avatar = $scope.primary.userImage;
          if (!$scope.primary.userID && $scope.primary.sys_id)
            $scope.primary.userID = $scope.primary.sys_id;
        }
        $scope.isGroup = $scope.conversation && $scope.conversation.isGroup;
        $scope.users = [$scope.primary];
        if ($scope.primary && (!$scope.members || $scope.members.length <= 0) && ($scope.primary.avatar || $scope.primary.initials) && $scope.isDocument) {
          $scope.users = [$scope.primary];
        } else if ($scope.members && $scope.members.length > 0) {
          $scope.users = buildCompositeAvatar($scope.members);
        }
        $scope.presenceEnabled = $scope.showPresence && !$scope.isGroup && $scope.users.length === 1;
      }

      function buildCompositeAvatar(members) {
        var currentUser = window.NOW.user ? window.NOW.user.userID : window.NOW.user_id;
        var users = angular.isArray(members) ? members.slice() : [members];
        users = users.sort(function(a, b) {
          var aID = a.userID || a.document;
          var bID = b.userID || b.document;
          if (a.table === "chat_queue_entry")
            return 1;
          if (aID === currentUser)
            return 1;
          else if (bID === currentUser)
            return -1;
          return 0;
        });
        if (users.length === 2)
          users = [users[0]];
        if (users.length > 2 && $scope.primary && $scope.primary.name && $scope.primary.table === "sys_user") {
          var index = -1;
          angular.forEach(users, function(user, i) {
            if (user.sys_id === $scope.primary.sys_id) {
              index = i;
            }
          });
          if (index > -1) {
            users.splice(index, 1);
          }
          users.splice(1, 0, $scope.primary);
        }
        return users;
      }
      buildAvatar();
      $scope.loadFullProfile = function() {
        if ($scope.primary && !$scope.primary.sys_id && !avatarProfilePersister.getAvatar($scope.primary.userID)) {
          $http.get('/api/now/live/profiles/' + $scope.primary.userID).then(
            function(response) {
              try {
                angular.extend($scope.primary, response.data.result);
                avatarProfilePersister.setAvatar($scope.primary.userID, $scope.primary);
              } catch (e) {}
            });
        }
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snAvatar.js */
angular.module('sn.common.avatar').directive('snAvatar', function($http, $compile, getTemplateUrl, snCustomEvent, snConnectService) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_avatar.xml'),
    replace: true,
    transclude: true,
    scope: {
      members: '=',
      primary: '=',
      showPresence: '=?',
      enableContextMenu: '=?',
      enableTooltip: '=?',
      enableBindOnce: '@',
      displayMemberCount: "=?",
      groupAvatar: "@"
    },
    compile: function(tElement) {
      var template = tElement.html();
      return function(scope, element, attrs, controller, transcludeFn) {
        function recompile() {
          var newElement = $compile(template, transcludeFn)(scope);
          element.html(newElement);
          if (scope.enableTooltip) {
            element.tooltip({
              placement: 'auto top',
              container: 'body'
            }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
            if (element.hideFix)
              element.hideFix();
          }
        }
        if (attrs.enableBindOnce === 'false') {
          scope.$watch('primary', recompile);
          scope.$watch('members', recompile);
        }
        if (scope.enableTooltip) {
          var usersWatch = scope.$watch('users', function() {
            if (scope.users && scope.users.length === 1 && scope.users[0] && scope.users[0].name) {
              element.tooltip({
                placement: 'auto top',
                container: 'body'
              }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
              if (element.hideFix)
                element.hideFix();
              usersWatch();
            }
          });
        }
        if (scope.enableContextMenu !== false) {
          scope.contextOptions = [];
          var gUser = null;
          try {
            gUser = g_user;
          } catch (err) {}
          if (scope.users && scope.users.length === 1 && scope.users[0] && (scope.users[0].userID || scope.users[0].sys_id)) {
            scope.contextOptions = [
              ["Open user's profile", function() {
                if (scope.users && scope.users.length > 0) {
                  window.open('/nav_to.do?uri=' + encodeURIComponent('sys_user.do?sys_id=' + scope.users[0].userID), '_blank');
                }
              }]
            ];
            if ((gUser && scope.users[0].userID && scope.users[0].userID !== gUser.userID) ||
              (scope.liveProfileID && scope.users[0] && scope.users[0].sysID !== scope.liveProfileID)) {
              scope.contextOptions.push(["Open a new chat", function() {
                snConnectService.openWithProfile(scope.users[0]);
              }]);
            }
          }
        } else {
          scope.contextOptions = [];
        }
      };
    },
    controller: function($scope, liveProfileID) {
      $scope.displayMemberCount = $scope.displayMemberCount || false;
      $scope.liveProfileID = liveProfileID;
      $scope.$watch('primary', function(newValue, oldValue) {
        if ($scope.primary && newValue !== oldValue) {
          buildAvatar();
          if ($scope.contextOptions.length > 0) {
            $scope.contextOptions = [
              ["Open user's profile", function() {
                if ($scope.users && $scope.users.length > 0) {
                  window.location.href = 'sys_user.do?sys_id=' + $scope.users[0].userID || $scope.users[0].userID;
                }
              }]
            ];
            var gUser = null;
            try {
              gUser = g_user;
            } catch (err) {}
            if ((!gUser && !liveProfileID) || ($scope.users && $scope.users.length === 1 && $scope.users[0])) {
              if ((gUser && $scope.users[0].userID && $scope.users[0].userID !== gUser.userID) ||
                ($scope.liveProfileID && $scope.users[0] && $scope.users[0].sysID !== $scope.liveProfileID)) {
                $scope.contextOptions.push(["Open a new chat", function() {
                  snConnectService.openWithProfile($scope.users[0]);
                }]);
              }
            }
          }
        }
      });
      $scope.$watch('members', function() {
        if ($scope.members)
          buildAvatar();
      });
      $scope.avatarType = function() {
        var result = [];
        if ($scope.groupAvatar || !$scope.users)
          return result;
        if ($scope.users.length > 1)
          result.push("group");
        if ($scope.users.length === 2)
          result.push("avatar-duo");
        if ($scope.users.length === 3)
          result.push("avatar-trio");
        if ($scope.users.length >= 4)
          result.push("avatar-quad");
        return result;
      };
      $scope.getBackgroundStyle = function(user) {
        var avatar = (user ? user.avatar : '');
        if ($scope.groupAvatar)
          avatar = $scope.groupAvatar;
        if (avatar && avatar !== '')
          return {
            'background-image': 'url(' + avatar + ')'
          };
        if (user && user.name)
          return '';
        return void(0);
      };
      $scope.maxStringWidth = function() {
        var paddedWidth = parseInt($scope.avatarWidth * 0.8, 10);
        return $scope.users.length === 1 ? paddedWidth : paddedWidth / 2;
      };

      function buildInitials(name) {
        if (!name)
          return "--";
        var initials = name.split(" ").map(function(word) {
          return word.toUpperCase();
        }).filter(function(word) {
          return word.match(/^[A-Z]/);
        }).map(function(word) {
          return word.substring(0, 1);
        }).join("");
        return (initials.length > 3) ?
          initials.substr(0, 3) :
          initials;
      }
      $scope.avatartooltip = function() {
        if (!$scope.enableTooltip) {
          return '';
        }
        if (!$scope.users) {
          return '';
        }
        var names = [];
        $scope.users.forEach(function(user) {
          if (!user) {
            return;
          }
          names.push(user.name);
        });
        return names.join(', ');
      };

      function buildAvatar() {
        if (typeof $scope.primary === 'string') {
          $http.get('/api/now/live/profiles/sys_user.' + $scope.primary).then(function(response) {
            $scope.users = [{
              userID: $scope.primary,
              name: response.data.result.name,
              initials: buildInitials(response.data.result.name),
              avatar: response.data.result.avatar
            }];
            $scope.presenceEnabled = $scope.showPresence && !$scope.isDocument && $scope.users.length === 1;
          });
          return;
        }
        if ($scope.primary) {
          if ($scope.primary.userImage)
            $scope.primary.avatar = $scope.primary.userImage;
          if (!$scope.primary.userID && $scope.primary.sys_id)
            $scope.primary.userID = $scope.primary.sys_id;
        }
        $scope.isDocument = $scope.primary && $scope.primary.table && $scope.primary.table !== "sys_user" && $scope.primary.table !== "chat_queue_entry";
        $scope.users = [$scope.primary];
        if ($scope.primary && (!$scope.members || $scope.members.length <= 0) && ($scope.primary.avatar || $scope.primary.initials) && $scope.isDocument) {
          $scope.users = [$scope.primary];
        } else if ($scope.members && $scope.members.length > 0) {
          $scope.users = buildCompositeAvatar($scope.members);
        }
        $scope.presenceEnabled = $scope.showPresence && !$scope.isDocument && $scope.users.length === 1;
      }

      function buildCompositeAvatar(members) {
        var currentUser = window.NOW.user ? window.NOW.user.userID : window.NOW.user_id;
        var users = angular.isArray(members) ? members.slice() : [members];
        users = users.sort(function(a, b) {
          var aID = a.userID || a.document;
          var bID = b.userID || b.document;
          if (a.table === "chat_queue_entry")
            return 1;
          if (aID === currentUser)
            return 1;
          else if (bID === currentUser)
            return -1;
          return 0;
        });
        if (users.length === 2)
          users = [users[0]];
        if (users.length > 2 && $scope.primary && $scope.primary.name && $scope.primary.table === "sys_user") {
          var index = -1;
          angular.forEach(users, function(user, i) {
            if (user.sys_id === $scope.primary.sys_id) {
              index = i;
            }
          });
          if (index > -1) {
            users.splice(index, 1);
          }
          users.splice(1, 0, $scope.primary);
        }
        return users;
      }
      buildAvatar();
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/service.avatarProfilePersister.js */
angular.module('sn.common.avatar').service('avatarProfilePersister', function() {
  "use strict";
  var avatars = {};

  function setAvatar(id, payload) {
    avatars[id] = payload;
  }

  function getAvatar(id) {
    return avatars[id];
  }
  return {
    setAvatar: setAvatar,
    getAvatar: getAvatar
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snUserAvatar.js */
angular.module('sn.common.avatar').directive('snUserAvatar', function(getTemplateUrl) {
  "use strict";
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_user_avatar.xml'),
    replace: true,
    scope: {
      profile: '=?',
      userId: '=?',
      avatarUrl: '=?',
      initials: '=?',
      enablePresence: '@',
      disablePopover: '=?',
      directConversationButton: '=?'
    },
    link: function(scope, element) {
      scope.evaluatedProfile = undefined;
      scope.backgroundStyle = undefined;
      scope.enablePresence = scope.enablePresence !== 'false';
      if (scope.profile) {
        scope.evaluatedProfile = scope.profile;
        scope.userId = scope.profile.userID || "";
        scope.avatarUrl = scope.profile.avatar || "";
        scope.initials = scope.profile.initials || "";
        scope.backgroundStyle = scope.getBackgroundStyle();
      } else if (scope.userId || scope.avatarUrl || scope.initials) {
        scope.evaluatedProfile = scope.profile = {
          'userID': scope.userId || "",
          'avatar': scope.avatarUrl || "",
          'initials': scope.initials || ""
        }
        scope.backgroundStyle = scope.getBackgroundStyle();
      } else {
        var unwatch = scope.$watch('profile', function(newVal) {
          if (newVal) {
            scope.evaluatedProfile = newVal;
            scope.backgroundStyle = scope.getBackgroundStyle();
            unwatch();
          }
        })
      }
      scope.directConversationButton = scope.directConversationButton !== 'false' && scope.directConversationButton !== false;
      scope.template = '<sn-user-profile profile="evaluatedProfile" show-direct-message-prompt="::directConversationButton" class="avatar-popover avatar-popover-padding"></sn-user-profile>';
    },
    controller: function($scope) {
      $scope.getBackgroundStyle = function() {
        if (($scope.avatarUrl && $scope.avatarUrl !== '') || $scope.evaluatedProfile && $scope.evaluatedProfile.avatar !== '')
          return {
            "background-image": 'url(' + ($scope.avatarUrl || $scope.evaluatedProfile.avatar) + ')'
          };
        return {
          "background-image": ""
        };
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snGroupAvatar.js */
angular.module('sn.common.avatar').directive('snGroupAvatar', function($http, $compile, getTemplateUrl, avatarProfilePersister) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_group_avatar.xml'),
    replace: true,
    transclude: true,
    scope: {
      members: '=',
      primary: '=?',
      groupAvatar: "@"
    },
    controller: function($scope, liveProfileID) {
      $scope.liveProfileID = liveProfileID;
      $scope.$watch('members', function(newVal, oldVal) {
        if (newVal === oldVal)
          return;
        if ($scope.members)
          $scope.users = buildCompositeAvatar($scope.members);
      });
      $scope.avatarType = function() {
        var result = [];
        if ($scope.groupAvatar || !$scope.users)
          return result;
        if ($scope.users.length > 1)
          result.push("group")
        if ($scope.users.length === 2)
          result.push("sn-avatar_duo")
        if ($scope.users.length === 3)
          result.push("sn-avatar_trio")
        if ($scope.users.length >= 4)
          result.push("sn-avatar_quad")
        return result;
      };
      $scope.getBackgroundStyle = function(user) {
        var avatar = (user ? user.avatar : '');
        if ($scope.groupAvatar)
          avatar = $scope.groupAvatar;
        if (avatar && avatar !== '')
          return {
            "background-image": "url(" + avatar + ")"
          };
        return {};
      };
      $scope.users = buildCompositeAvatar($scope.members);

      function buildCompositeAvatar(members) {
        var currentUser = window.NOW.user ? window.NOW.user.userID : window.NOW.user_id;
        var users = angular.isArray(members) ? members.slice() : [members];
        users = users.sort(function(a, b) {
          var aID = a.userID || a.document;
          var bID = b.userID || b.document;
          if (a.table === "chat_queue_entry")
            return 1;
          if (aID === currentUser)
            return 1;
          else if (bID === currentUser)
            return -1;
          return 0;
        });
        if (users.length === 2)
          users = [users[0]];
        if (users.length > 2 && $scope.primary && $scope.primary.name && $scope.primary.table === "sys_user") {
          var index = -1;
          angular.forEach(users, function(user, i) {
            if (user.sys_id === $scope.primary.sys_id) {
              index = i;
            }
          });
          if (index > -1) {
            users.splice(index, 1);
          }
          users.splice(1, 0, $scope.primary);
        }
        return users;
      }
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/controls/js_includes_controls.js */
/*! RESOURCE: /scripts/sn/common/controls/_module.js */
angular.module('sn.common.controls', []);;
/*! RESOURCE: /scripts/sn/common/controls/directive.snChoiceList.js */
angular.module('sn.common.controls').directive('snChoiceList', function($timeout) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      snModel: "=",
      snTextField: "@",
      snValueField: "@",
      snOptions: "=?",
      snItems: "=?",
      snOnChange: "&",
      snDisabled: "=",
      snDialogName: "=",
    },
    template: '<select ng-disabled="snDisabled" ng-model="model" ng-options="item[snValueField] as item[snTextField] for item in snItems"><option value="" ng-show="snOptions.placeholder">{{snOptions.placeholder}}</option></select>',
    link: function(scope, element, attrs) {
      if (scope.snDialogName)
        scope.$on("dialog." + scope.snDialogName + ".close", function() {
          $timeout(function() {
            $(element).select2("destroy");
          })
        });
      $(element).css("opacity", 0);
      var config = {
        width: "100%"
      };
      if (scope.snOptions) {
        if (scope.snOptions.placeholder) {
          config.placeholderOption = "first";
        }
        if (scope.snOptions.hideSearch && scope.snOptions.hideSearch === true) {
          config.minimumResultsForSearch = -1;
        }
      }

      function init() {
        scope.model = scope.snModel;
        render();
      }

      function render() {
        if (!attrs) {
          $timeout(function() {
            render();
          });
          return;
        }
        $timeout(function() {
          $(element).css("opacity", 1);
          $(element).select2("destroy");
          $(element).select2(config);
        });
      }
      init();
      scope.$watch("snItems", function(newValue, oldValue) {
        if (newValue !== oldValue) {
          init();
        }
      }, true);
      scope.$watch("snModel", function(newValue) {
        if (newValue !== undefined && newValue !== scope.model) {
          init();
        }
      });
      scope.$watch("model", function(newValue, oldValue) {
        if (newValue !== oldValue) {
          scope.snModel = newValue;
          if (scope.snOnChange)
            scope.snOnChange({
              selectedValue: newValue
            });
        }
      });
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snReferencePicker.js */
angular.module('sn.common.controls').directive('snReferencePicker', function($timeout, $http, urlTools, filterExpressionParser, $sanitize, i18n) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      ed: "=?",
      field: "=",
      refTable: "=?",
      refId: "=?",
      snOptions: "=?",
      snOnChange: "&",
      snOnBlur: "&",
      snOnClose: "&",
      snOnOpen: '&',
      minimumInputLength: "@",
      snDisabled: "=",
      snPageSize: "@",
      dropdownCssClass: "@",
      formatResultCssClass: "&",
      overlay: "=",
      additionalDisplayColumns: "@",
      displayColumn: "@",
      recordValues: '&',
      getGlideForm: '&glideForm',
      domain: "@",
      snSelectWidth: '@',
    },
    template: '<input type="text" name="{{field.name}}" ng-disabled="snDisabled" style="min-width: 150px;" ng-model="field.displayValue" />',
    link: function(scope, element, attrs, ctrl) {
      scope.ed = scope.ed || scope.field.ed;
      scope.selectWidth = scope.snSelectWidth || '100%';
      element.css("opacity", 0);
      var fireReadyEvent = true;
      var g_form;
      if (angular.isDefined(scope.getGlideForm))
        g_form = scope.getGlideForm();
      var fieldAttributes = {};
      if (angular.isDefined(scope.field) && angular.isDefined(scope.field.attributes) && typeof scope.ed.attributes == 'undefined')
        if (Array.isArray(scope.field.attributes))
          fieldAttributes = scope.field.attributes;
        else
          fieldAttributes = parseAttributes(scope.field.attributes);
      else
        fieldAttributes = parseAttributes(scope.ed.attributes);
      if (!angular.isDefined(scope.additionalDisplayColumns) && angular.isDefined(fieldAttributes['ref_ac_columns']))
        scope.additionalDisplayColumns = fieldAttributes['ref_ac_columns'];
      var select2AjaxHelpers = {
        formatSelection: function(item) {
          return $sanitize(getDisplayValue(item));
        },
        formatResult: function(item) {
          var displayValues = getDisplayValues(item);
          if (displayValues.length == 1)
            return $sanitize(displayValues[0]);
          if (displayValues.length > 1) {
            var width = 100 / displayValues.length;
            var markup = "";
            for (var i = 0; i < displayValues.length; i++)
              markup += "<div style='width: " + width + "%;' class='select2-result-cell'>" + $sanitize(displayValues[i]) + "</div>";
            return markup;
          }
          return "";
        },
        search: function(queryParams) {
          if ('sysparm_include_variables' in queryParams.data) {
            var url = urlTools.getURL('ref_list_data', queryParams.data);
            return $http.get(url).then(queryParams.success);
          } else {
            var url = urlTools.getURL('ref_list_data');
            return $http.post(url, queryParams.data).then(queryParams.success);
          }
        },
        initSelection: function(elem, callback) {
          if (scope.field.displayValue)
            callback({
              sys_id: scope.field.value,
              name: scope.field.displayValue
            });
        }
      };
      var config = {
        width: scope.selectWidth,
        minimumInputLength: scope.minimumInputLength ? parseInt(scope.minimumInputLength, 10) : 0,
        overlay: scope.overlay,
        containerCssClass: 'select2-reference ng-form-element',
        placeholder: '   ',
        formatSearching: '',
        allowClear: attrs.allowClear !== 'false',
        id: function(item) {
          return item.sys_id;
        },
        sortResults: (scope.snOptions && scope.snOptions.sortResults) ? scope.snOptions.sortResults : undefined,
        ajax: {
          quietMillis: NOW.ac_wait_time,
          data: function(filterText, page) {
            var filterExpression = filterExpressionParser.parse(filterText, scope.ed.defaultOperator);
            var colToSearch = getReferenceColumnToSearch();
            var q = colToSearch + filterExpression.operator + filterExpression.filterText +
              '^' + colToSearch + 'ISNOTEMPTY' + getExcludedValues() + "^EQ";
            var params = {
              start: (scope.pageSize * (page - 1)),
              count: scope.pageSize,
              sysparm_target_table: scope.refTable,
              sysparm_target_sys_id: scope.refId,
              sysparm_target_field: scope.ed.dependent_field || scope.ed.name,
              table: scope.ed.reference,
              qualifier: scope.ed.qualifier,
              data_adapter: scope.ed.data_adapter,
              attributes: scope.ed.attributes,
              dependent_field: scope.ed.dependent_field,
              dependent_table: scope.ed.dependent_table,
              dependent_value: scope.ed.dependent_value,
              p: scope.ed.reference + ';q:' + q + ';r:' + scope.ed.qualifier
            };
            if (scope.domain) {
              params.sysparm_domain = scope.domain;
            }
            if (angular.isDefined(scope.field) && scope.field['_cat_variable'] === true) {
              delete params['sysparm_target_table'];
              params['sysparm_include_variables'] = true;
              params['variable_ids'] = scope.field.sys_id;
              var getFieldSequence = g_form.$private.options('getFieldSequence');
              if (getFieldSequence) {
                params['variable_sequence1'] = getFieldSequence();
              }
              var itemSysId = g_form.$private.options('itemSysId');
              params['sysparm_id'] = itemSysId;
              var getFieldParams = g_form.$private.options('getFieldParams');
              if (getFieldParams) {
                angular.extend(params, getFieldParams());
              }
            }
            if (scope.recordValues)
              params.sysparm_record_values = scope.recordValues();
            return params;
          },
          results: function(data, page) {
            return ctrl.filterResults(data, page, scope.pageSize);
          },
          transport: select2AjaxHelpers.search
        },
        formatSelection: select2AjaxHelpers.formatSelection,
        formatResult: select2AjaxHelpers.formatResult,
        initSelection: select2AjaxHelpers.initSelection,
        dropdownCssClass: attrs.dropdownCssClass,
        formatResultCssClass: scope.formatResultCssClass || null
      };
      if (scope.snOptions) {
        if (scope.snOptions.placeholder) {
          config.placeholder = scope.snOptions.placeholder;
        }
        if (scope.snOptions.width) {
          config.width = scope.snOptions.width;
        }
      }

      function getReferenceColumnToSearch() {
        var colName = 'name';
        if (scope.ed.searchField)
          colName = scope.ed.searchField;
        else if (fieldAttributes['ref_ac_columns_search'] == 'true' && 'ref_ac_columns' in fieldAttributes && fieldAttributes['ref_ac_columns'] != '') {
          var refAcColumns = fieldAttributes['ref_ac_columns'].split(';');
          colName = refAcColumns[0];
        } else if (fieldAttributes['ref_ac_order_by'])
          colName = fieldAttributes['ref_ac_order_by'];
        return colName;
      }

      function getExcludedValues() {
        if (scope.ed.excludeValues && scope.ed.excludeValues != '') {
          return '^sys_idNOT IN' + scope.ed.excludeValues;
        }
        return '';
      }

      function parseAttributes(strAttributes) {
        var attributeArray = (strAttributes && strAttributes.length ? strAttributes.split(',') : []);
        var attributeObj = {};
        for (var i = 0; i < attributeArray.length; i++) {
          if (attributeArray[i].length > 0) {
            var attribute = attributeArray[i].split('=');
            attributeObj[attribute[0]] = attribute.length > 1 ? attribute[1] : '';
          }
        }
        return attributeObj;
      }

      function init() {
        scope.model = scope.snModel;
        render();
      }

      function render() {
        $timeout(function() {
          i18n.getMessage('Searching...', function(searchingMsg) {
            config.formatSearching = function() {
              return searchingMsg;
            };
          });
          element.css("opacity", 1);
          element.select2("destroy");
          var select2 = element.select2(config);
          select2.bind("change", select2Change);
          select2.bind("select2-removed", select2Change);
          select2.bind("select2-blur", function() {
            scope.$apply(function() {
              scope.snOnBlur();
            });
          });
          select2.bind("select2-close", function() {
            scope.$apply(function() {
              scope.snOnClose();
            });
          });
          select2.bind("select2-open", function() {
            scope.$apply(function() {
              if (scope.snOnOpen)
                scope.snOnOpen();
            });
          });
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      }

      function select2Change(e) {
        e.stopImmediatePropagation();
        if (e.added) {
          if (scope.$$phase || scope.$root.$$phase)
            return;
          var selectedItem = e.added;
          var value = selectedItem.sys_id;
          var displayValue = value ? getDisplayValue(selectedItem) : '';
          if (scope.snOptions && scope.snOptions.useGlideForm === true) {
            g_form.setValue(scope.field.name, value, displayValue);
            scope.rowSelected();
          } else {
            scope.$apply(function() {
              scope.field.value = value;
              scope.field.displayValue = displayValue;
              scope.rowSelected();
            });
          }
          if (scope.snOnChange) {
            e.displayValue = displayValue;
            scope.snOnChange(e);
          }
        } else if (e.removed) {
          if (scope.snOptions && scope.snOptions.useGlideForm === true) {
            g_form.clearValue(scope.field.name);
            if (scope.snOnChange)
              scope.snOnChange(e);
          } else {
            scope.$apply(function() {
              scope.field.displayValue = '';
              scope.field.value = '';
              if (scope.snOnChange)
                scope.snOnChange(e);
            });
          }
        }
      }

      function getDisplayValue(selectedItem) {
        var displayValue = '';
        if (selectedItem && selectedItem.sys_id) {
          if (scope.displayColumn && typeof selectedItem[scope.displayColumn] != "undefined")
            displayValue = selectedItem[scope.displayColumn];
          else if (selectedItem.$$displayValue)
            displayValue = selectedItem.$$displayValue;
          else if (selectedItem.name)
            displayValue = selectedItem.name;
          else if (selectedItem.title)
            displayValue = selectedItem.title;
        }
        return displayValue;
      }

      function getDisplayValues(selectedItem) {
        var displayValues = [];
        if (selectedItem && selectedItem.sys_id) {
          var current = "";
          if (scope.displayColumn && typeof selectedItem[scope.displayColumn] != "undefined")
            current = selectedItem[scope.displayColumn];
          else if (selectedItem.$$displayValue)
            current = selectedItem.$$displayValue;
          else if (selectedItem.name)
            current = selectedItem.name;
          else if (selectedItem.title)
            current = selectedItem.title;
          displayValues.push(current);
        }
        if (scope.additionalDisplayColumns) {
          var columns = scope.additionalDisplayColumns.split(",");
          for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            if (selectedItem[column])
              displayValues.push(selectedItem[column]);
          }
        }
        return displayValues;
      }
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue != oldValue && newValue !== scope.model) {
          init();
        }
      });
      scope.$on("snReferencePicker.activate", function(evt, parms) {
        $timeout(function() {
          element.select2("open");
        })
      });
      init();
    },
    controller: function($scope, $rootScope) {
      $scope.pageSize = 20;
      if ($scope.snPageSize)
        $scope.pageSize = parseInt($scope.snPageSize);
      $scope.rowSelected = function() {
        $rootScope.$broadcast("@page.reference.selected", {
          field: $scope.field,
          ed: $scope.ed
        });
      };
      this.filterResults = function(data, page) {
        return {
          results: data.data.items,
          more: (page * $scope.pageSize < data.data.total)
        };
      };
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snRecordPicker.js */
angular.module('sn.common.controls').directive('snRecordPicker', function($timeout, $http, urlTools, filterExpressionParser, $sanitize, i18n) {
  "use strict";
  var cache = {};

  function cleanLabel(val) {
    if (typeof val == "object")
      return "";
    return typeof val == "string" ? val.trim() : val;
  }
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: '=',
      table: '=',
      defaultQuery: '=?',
      searchFields: '=?',
      valueField: '=?',
      displayField: '=?',
      displayFields: '=?',
      pageSize: '=?',
      onChange: '&',
      snDisabled: '=',
      multiple: '=?',
      options: '=?',
      placeholder: '@'
    },
    template: '<input type="text" ng-disabled="snDisabled" style="min-width: 150px;" name="{{field.name}}" ng-model="field.value" />',
    controller: function($scope) {
      if (!angular.isNumber($scope.pageSize))
        $scope.pageSize = 20;
      if (!angular.isDefined($scope.valueField))
        $scope.valueField = 'sys_id';
      this.filterResults = function(data, page) {
        return {
          results: data.data.result,
          more: (page * $scope.pageSize < parseInt(data.headers('x-total-count'), 10))
        };
      };
    },
    link: function(scope, element, attrs, ctrl) {
      var isExecuting = false;
      var select2Helpers = {
        formatSelection: function(item) {
          return $sanitize(getDisplayValue(item));
        },
        formatResult: function(item) {
          var displayFields = getdisplayFields(item);
          if (displayFields.length == 1)
            return $sanitize(cleanLabel(displayFields[0]));
          if (displayFields.length > 1) {
            var markup = $sanitize(displayFields[0]);
            var width = 100 / (displayFields.length - 1);
            markup += "<div>";
            for (var i = 1; i < displayFields.length; i++)
              markup += "<div style='width: " + width + "%;' class='select2-additional-display-field'>" + $sanitize(cleanLabel(displayFields[i])) + "</div>";
            markup += "</div>";
            return markup;
          }
          return "";
        },
        search: function(queryParams) {
          var url = '/api/now/table/' + scope.table + '?' + urlTools.encodeURIParameters(queryParams.data);
          if (scope.options && scope.options.cache && cache[url])
            return queryParams.success(cache[url]);
          return $http.get(url).then(function(response) {
            if (scope.options && scope.options.cache) {
              cache[url] = response;
            }
            return queryParams.success(response)
          });
        },
        initSelection: function(elem, callback) {
          if (scope.field.displayValue) {
            if (scope.multiple) {
              var items = [],
                sel;
              var values = scope.field.value.split(',');
              var displayValues = scope.field.displayValue.split(',');
              for (var i = 0; i < values.length; i++) {
                sel = {};
                sel[scope.valueField] = values[i];
                sel[scope.displayField] = displayValues[i];
                items.push(sel);
              }
              callback(items);
            } else {
              var sel = {};
              sel[scope.valueField] = scope.field.value;
              sel[scope.displayField] = scope.field.displayValue;
              callback(sel);
            }
          } else
            callback([]);
        }
      };
      var config = {
        width: '100%',
        containerCssClass: 'select2-reference ng-form-element',
        placeholder: scope.placeholder || '    ',
        formatSearching: '',
        allowClear: (scope.options && typeof scope.options.allowClear !== "undefined") ? scope.options.allowClear : true,
        id: function(item) {
          return item[scope.valueField];
        },
        ajax: {
          quietMillis: NOW.ac_wait_time,
          data: function(filterText, page) {
            var params = {
              sysparm_offset: (scope.pageSize * (page - 1)),
              sysparm_limit: scope.pageSize,
              sysparm_query: buildQuery(filterText, scope.searchFields, scope.defaultQuery)
            };
            return params;
          },
          results: function(data, page) {
            return ctrl.filterResults(data, page, scope.pageSize);
          },
          transport: select2Helpers.search
        },
        formatSelection: select2Helpers.formatSelection,
        formatResult: select2Helpers.formatResult,
        formatResultCssClass: function() {
          return '';
        },
        initSelection: select2Helpers.initSelection,
        multiple: scope.multiple
      };

      function buildQuery(filterText, searchFields, defaultQuery) {
        var queryParts = [];
        var operator = "CONTAINS";
        if (filterText.startsWith("*"))
          filterText = filterText.substring(1);
        if (defaultQuery)
          queryParts.push(defaultQuery);
        var filterExpression = filterExpressionParser.parse(filterText, operator);
        if (searchFields != null) {
          var fields = searchFields.split(',');
          if (filterExpression.filterText != '') {
            var OR = "";
            for (var i = 0; i < fields.length; i++) {
              queryParts.push(OR + fields[i] + filterExpression.operator + filterExpression.filterText);
              OR = "OR";
            }
          }
          for (var i = 0; i < fields.length; i++)
            queryParts.push('ORDERBY' + fields[i]);
          queryParts.push('EQ');
        }
        return queryParts.join('^');
      }
      scope.field = scope.field || {};
      var initTimeout = null;
      var value = scope.field.value;
      var oldValue = scope.field.value;
      var $select;

      function init() {
        element.css("opacity", 0);
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          i18n.getMessage('Searching...', function(searchingMsg) {
            config.formatSearching = function() {
              return searchingMsg;
            };
          });
          element.css("opacity", 1);
          element.select2("destroy");
          $select = element.select2(config);
          $select.bind("change", onChanged);
          $select.bind("select2-removed", onChanged);
          $select.bind("select2-selecting", onSelecting);
          $select.bind("select2-removing", onRemoving);
          scope.$emit('select2.ready', element);
        });
      }

      function onSelecting(e) {
        isExecuting = true;
        oldValue = scope.field.value;
        var selectedItem = e.choice;
        if (scope.multiple && selectedItem[scope.valueField] != '') {
          var values = scope.field.value == '' ? [] : scope.field.value.split(',');
          var displayValues = scope.field.displayValue == '' ? [] : scope.field.displayValue.split(',');
          values.push(selectedItem[scope.valueField]);
          displayValues.push(getDisplayValue(selectedItem));
          scope.field.value = values.join(',');
          scope.field.displayValue = displayValues.join(',');
          e.preventDefault();
          $select.select2('val', values).select2('close');
          scope.$apply(function() {
            callChange(oldValue, e);
          });
        }
      }

      function onRemoving(e) {
        isExecuting = true;
        oldValue = scope.field.value;
        var removed = e.choice;
        if (scope.multiple) {
          var values = scope.field.value.split(',');
          var displayValues = scope.field.displayValue.split(',');
          for (var i = values.length - 1; i >= 0; i--) {
            if (removed[scope.valueField] == values[i]) {
              values.splice(i, 1);
              displayValues.splice(i, 1);
              break;
            }
          }
          scope.field.value = values.join(',');
          scope.field.displayValue = displayValues.join(',');
          e.preventDefault();
          $select.select2('val', scope.field.value.split(','));
          scope.$apply(function() {
            callChange(oldValue, e);
          });
        }
      }

      function callChange(oldValue, e) {
        var f = scope.field;
        var p = {
          field: f,
          newValue: f.value,
          oldValue: oldValue,
          displayValue: f.displayValue
        }
        scope.$emit("field.change", p);
        scope.$emit("field.change." + f.name, p);
        if (scope.onChange)
          try {
            scope.onChange(e);
          } catch (ex) {
            console.log("directive.snRecordPicker error in onChange")
            console.log(ex)
          }
        isExecuting = false;
      }

      function onChanged(e) {
        e.stopImmediatePropagation();
        if (scope.$$phase || scope.$root.$$phase) {
          console.warn('in digest, returning early');
          return;
        }
        if (e.added) {
          var selectedItem = e.added;
          if (!scope.multiple) {
            scope.field.value = selectedItem[scope.valueField];
            if (scope.field.value) {
              scope.field.displayValue = getDisplayValue(selectedItem);
            } else
              scope.field.displayValue = '';
          }
        } else if (e.removed) {
          if (!scope.multiple) {
            scope.field.displayValue = '';
            scope.field.value = '';
          }
        }
        scope.$apply(function() {
          callChange(oldValue, e);
        });
      }

      function getDisplayValue(selectedItem) {
        var displayValue = selectedItem[scope.valueField];
        if (selectedItem) {
          if (scope.displayField && angular.isDefined(selectedItem[scope.displayField]))
            displayValue = selectedItem[scope.displayField];
          else if (selectedItem.name)
            displayValue = selectedItem.name;
          else if (selectedItem.title)
            displayValue = selectedItem.title;
        }
        return cleanLabel(displayValue);
      }

      function getdisplayFields(selectedItem) {
        var displayFields = [];
        if (selectedItem && selectedItem[scope.valueField]) {
          var current = "";
          if (scope.displayField && angular.isDefined(selectedItem[scope.displayField]))
            current = selectedItem[scope.displayField];
          else if (selectedItem.name)
            current = selectedItem.name;
          else if (selectedItem.title)
            current = selectedItem.title;
          displayFields.push(current);
        }
        if (scope.displayFields) {
          var columns = scope.displayFields.split(",");
          for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            if (selectedItem[column])
              displayFields.push(selectedItem[column]);
          }
        }
        return displayFields;
      }
      scope.$watch("field.value", function(newValue) {
        if (isExecuting) return;
        if (angular.isDefined(newValue) && $select) {
          if (scope.multiple)
            $select.select2('val', newValue.split(',')).select2('close');
          else
            $select.select2('val', newValue).select2('close');
        }
      });
      if (attrs.displayValue) {
        attrs.$observe('displayValue', function(value) {
          scope.field.value = value;
        });
      }
      init();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snSelectBasic.js */
angular.module('sn.common.controls').directive('snSelectBasic', function($timeout) {
  return {
    restrict: 'C',
    priority: 1,
    require: '?ngModel',
    scope: {
      'snAllowClear': '@',
      'snSelectWidth': '@',
      'snChoices': '=?'
    },
    link: function(scope, element, attrs, ngModel) {
      if (angular.isFunction(element.select2)) {
        element.css("opacity", 0);
        scope.selectWidth = scope.snSelectWidth || '100%';
        scope.selectAllowClear = scope.snAllowClear === "true";
        $timeout(function() {
          element.css("opacity", 1);
          element.select2({
            allowClear: scope.selectAllowClear,
            width: scope.selectWidth
          });
          ngModel.$render = function() {
            element.select2('val', ngModel.$viewValue);
            element.val(ngModel.$viewValue);
          };
        });
        element.on('change', function() {
          scope.$evalAsync(setModelValue);
        });
        scope.$watch('snChoices', function(newValue, oldValue) {
          if (angular.isDefined(newValue) && newValue != oldValue) {
            $timeout(function() {
              setModelValue();
            });
          }
        }, true);

        function setModelValue() {
          ngModel.$setViewValue(element.val());
        };
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snTableReference.js */
angular.module('sn.common.controls').directive('snTableReference', function($timeout) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: "=",
      snChange: "&",
      snDisabled: "="
    },
    template: '<select ng-disabled="snDisabled" style="min-width: 150px;" name="{{field.name}}" ng-model="fieldValue" ng-model-options="{getterSetter: true}" ng-options="choice.value as choice.label for choice in field.choices"></select>',
    controller: function($scope) {
      $scope.fieldValue = function(selected) {
        if (angular.isDefined(selected)) {
          $scope.snChange({
            newValue: selected
          });
        }
        return $scope.field.value;
      }
    },
    link: function(scope, element) {
      var initTimeout = null;
      var fireReadyEvent = true;
      element.css("opacity", 0);

      function render() {
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          element.css("opacity", 1);
          element.select2("destroy");
          element.select2();
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      }
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue !== undefined && newValue != oldValue) {
          render();
        }
      });
      render();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snFieldReference.js */
angular.module('sn.common.controls').directive('snFieldReference', function($timeout, $http, nowServer) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: "=",
      snChange: "&",
      snDisabled: "=",
      getGlideForm: '&glideForm'
    },
    template: '<select ng-disabled="snDisabled" name="{{field.name}}" style="min-width: 150px;" ng-model="fieldValue" ng-model-options="{getterSetter: true}" ng-options="choice.name as choice.label for choice in field.choices"></select>',
    controller: function($scope) {
      $scope.fieldValue = function(selected) {
        if (angular.isDefined(selected))
          $scope.snChange({
            newValue: selected
          });
        return $scope.field.value;
      }
      $scope.$watch('field.dependentValue', function(newVal, oldVal) {
        if (!angular.isDefined(newVal))
          return;
        var src = nowServer.getURL('table_fields', 'exclude_formatters=true&fd_table=' + newVal);
        $http.post(src).success(function(response) {
          $scope.field.choices = response;
          $scope.render();
        });
      });
    },
    link: function(scope, element) {
      var initTimeout = null;
      var fireReadyEvent = true;
      scope.render = function() {
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          element.select2("destroy");
          element.select2();
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      };
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue !== undefined && newValue != oldValue) {
          scope.render();
        }
      });
      scope.render();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snSyncWith.js */
angular.module("sn.common.controls").directive('snSyncWith', function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: false,
    link: function(scope, elem, attr) {
      scope.journalField = scope.$eval(attr.snSyncWith);
      scope.value = scope.$eval(attr.ngModel);
      if (attr.snSyncWithValueInFn)
        scope.$eval(attr.ngModel + "=" + attr.snSyncWithValueInFn, {
          text: scope.value
        });
      scope.$watch(function() {
        return scope.$eval(attr.snSyncWith);
      }, function(nv, ov) {
        if (nv !== ov)
          scope.journalField = nv;
      });
      scope.$watch(function() {
        return scope.$eval(attr.ngModel);
      }, function(nv, ov) {
        if (nv !== ov)
          scope.value = nv;
      });
      if (!window.g_form)
        return;
      scope.$watch('value', function(n, o) {
        if (n !== o)
          setFieldValue();
      });

      function setFieldValue() {
        setValue(scope.journalField, scope.value);
      }

      function setValue(field, value) {
        value = !!value ? value : '';
        var control = g_form.getControl(field);
        if (attr.snSyncWithValueOutFn)
          value = scope.$eval(attr.snSyncWithValueOutFn, {
            text: value
          })
        control.value = value;
        onChange(control.id);
      }
      scope.$watch('journalField', function(newValue, oldValue) {
        if (newValue !== oldValue) {
          if (oldValue)
            setValue(oldValue, '');
          if (newValue)
            setFieldValue();
        }
      }, true);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.contenteditable.js */
angular.module('sn.common.controls').directive('contenteditable', function($timeout, $sanitize) {
  return {
    require: 'ngModel',
    link: function(scope, elem, attrs, ctrl) {
      var changehandler = scope.changehandler;
      scope.usenewline = scope.usenewline + "" != "false";
      var newLine = "\n";
      var nodeBR = "BR";
      var nodeDIV = "DIV";
      var nodeText = "#text";
      var nbspRegExp = new RegExp(String.fromCharCode(160), "g");
      if (!scope.usenewline)
        elem.keypress(function(event) {
          if (event.which == "13") {
            if (scope.entercallback)
              scope.entercallback(elem);
            event.preventDefault();
          }
        });

      function processNodes(nodes) {
        var val = "";
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var follow = true;
          switch (node.nodeName) {
            case nodeText:
              val += node.nodeValue.replace(nbspRegExp, " ");
              break;
            case nodeDIV:
              val += newLine;
              if (node.childNodes.length == 1 && node.childNodes[0].nodeName == nodeBR)
                follow = false;
              break;
            case nodeBR:
              val += scope.usenewline ? newLine : "";
          }
          if (follow)
            val += processNodes(node.childNodes)
        }
        return val;
      }

      function readHtml() {
        var val = processNodes(elem[0].childNodes);
        ctrl.$setViewValue(val);
      }

      function writeHtml() {
        var val = ctrl.$viewValue;
        if (!val || val === null)
          val = "";
        val = val.replace(/\n/gi, scope.usenewline ? "<br/>" : "");
        val = val.replace(/  /gi, " &nbsp;");
        try {
          if (attrs.contenteditableEscapeHtml == "true")
            val = $sanitize(val);
        } catch (err) {
          var replacement = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '/': '&#x2F;'
          };
          val = val.replace(/[&<>"'\/]/g, function(pattern) {
            return replacement[pattern]
          });
        };
        elem.html(val);
      }

      function processPlaceholder() {
        if (elem[0].dataset) {
          if (elem[0].textContent)
            elem[0].dataset.divPlaceholderContent = 'true';
          else if (elem[0].dataset.divPlaceholderContent)
            delete(elem[0].dataset.divPlaceholderContent);
        }
      }
      elem.bind('keyup', function() {
        scope.$apply(function() {
          readHtml();
          processPlaceholder();
        });
      });

      function selectText(elem) {
        var range;
        var selection;
        if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(elem);
          range.select();
        } else if (window.getSelection) {
          selection = window.getSelection();
          range = document.createRange();
          range.selectNodeContents(elem);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
      elem.bind('focus', function() {
        if (scope[attrs.tracker] && scope[attrs.tracker]['isDefault_' + attrs.trackeratt])
          $timeout(function() {
            selectText(elem[0]);
          });
        elem.original = ctrl.$viewValue;
      });
      elem.bind('blur', function() {
        scope.$apply(function() {
          readHtml();
          processPlaceholder();
          if (elem.original != ctrl.$viewValue && changehandler) {
            if (scope[attrs.tracker] && typeof scope[attrs.tracker]['isDefault_' + attrs.trackeratt] != "undefined")
              scope[attrs.tracker]['isDefault_' + attrs.trackeratt] = false;
            changehandler(scope[attrs.tracker], attrs.trackeratt);
          }
        });
      });
      elem.bind('paste', function() {
        scope.$apply(function() {
          setTimeout(function() {
            readHtml();
            writeHtml();
          }, 0);
          return false;
        });
      });
      ctrl.$render = function() {
        writeHtml();
      };
      scope.$watch('field.readonly', function() {
        elem[0].contentEditable = !scope.$eval('field.readonly');
      });
      scope.$watch(
        function() {
          return {
            val: elem[0].textContent
          };
        },
        function(newValue, oldValue) {
          if (newValue.val != oldValue.val)
            processPlaceholder();
        },
        true);
      writeHtml();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snGlyph.js */
angular.module("sn.common.controls").directive("snGlyph", function() {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      char: "@",
    },
    template: '<span class="glyphicon glyphicon-{{char}}" />',
    link: function(scope) {}
  }
});
angular.module("sn.common.controls").directive('fa', function() {
    return {
      restrict: 'E',
      template: '<span class="fa" aria-hidden="true"></span>',
      replace: true,
      link: function(scope, element, attrs) {
        'use strict';
        var currentClasses = {};

        function _observeStringAttr(attr, baseClass) {
          var className;
          attrs.$observe(attr, function() {
            baseClass = baseClass || 'fa-' + attr;
            element.removeClass(currentClasses[attr]);
            if (attrs[attr]) {
              className = [baseClass, attrs[attr]].join('-');
              element.addClass(className);
              currentClasses[attr] = className;
            }
          });
        }
        _observeStringAttr('name', 'fa');
        _observeStringAttr('rotate');
        _observeStringAttr('flip');
        _observeStringAttr('stack');
        attrs.$observe('size', function() {
          var className;
          element.removeClass(currentClasses.size);
          if (attrs.size === 'large') {
            className = 'fa-lg';
          } else if (!isNaN(parseInt(attrs.size, 10))) {
            className = 'fa-' + attrs.size + 'x';
          }
          element.addClass(className);
          currentClasses.size = className;
        });
        attrs.$observe('stack', function() {
          var className;
          element.removeClass(currentClasses.stack);
          if (attrs.stack === 'large') {
            className = 'fa-stack-lg';
          } else if (!isNaN(parseInt(attrs.stack, 10))) {
            className = 'fa-stack-' + attrs.stack + 'x';
          }
          element.addClass(className);
          currentClasses.stack = className;
        });

        function _observeBooleanAttr(attr, className) {
          var value;
          attrs.$observe(attr, function() {
            className = className || 'fa-' + attr;
            value = attr in attrs && attrs[attr] !== 'false' && attrs[attr] !== false;
            element.toggleClass(className, value);
          });
        }
        _observeBooleanAttr('border');
        _observeBooleanAttr('fw');
        _observeBooleanAttr('inverse');
        _observeBooleanAttr('spin');
        element.toggleClass('fa-li',
          element.parent() &&
          element.parent().prop('tagName') === 'LI' &&
          element.parent().parent() &&
          element.parent().parent().hasClass('fa-ul') &&
          element.parent().children()[0] === element[0] &&
          attrs.list !== 'false' &&
          attrs.list !== false
        );
        attrs.$observe('alt', function() {
          var altText = attrs.alt,
            altElem = element.next(),
            altElemClass = 'fa-alt-text';
          if (altText) {
            element.removeAttr('alt');
            if (!altElem || !altElem.hasClass(altElemClass)) {
              element.after('<span class="sr-only fa-alt-text"></span>');
              altElem = element.next();
            }
            altElem.text(altText);
          } else if (altElem && altElem.hasClass(altElemClass)) {
            altElem.remove();
          }
        });
      }
    };
  })
  .directive('faStack', function() {
    return {
      restrict: 'E',
      transclude: true,
      template: '<span ng-transclude class="fa-stack fa-lg"></span>',
      replace: true,
      link: function(scope, element, attrs) {
        var currentClasses = {};

        function _observeStringAttr(attr, baseClass) {
          var className;
          attrs.$observe(attr, function() {
            baseClass = baseClass || 'fa-' + attr;
            element.removeClass(currentClasses[attr]);
            if (attrs[attr]) {
              className = [baseClass, attrs[attr]].join('-');
              element.addClass(className);
              currentClasses[attr] = className;
            }
          });
        }
        _observeStringAttr('size');
        attrs.$observe('size', function() {
          var className;
          element.removeClass(currentClasses.size);
          if (attrs.size === 'large') {
            className = 'fa-lg';
          } else if (!isNaN(parseInt(attrs.size, 10))) {
            className = 'fa-' + attrs.size + 'x';
          }
          element.addClass(className);
          currentClasses.size = className;
        });
      }
    };
  });;
/*! RESOURCE: /scripts/sn/common/controls/directive.snImageUploader.js */
angular.module('sn.common.controls').directive('snImageUploader', function($window, $rootScope, $timeout, getTemplateUrl, i18n, snAttachmentHandler) {
  var DRAG_IMAGE_SELECT = i18n.getMessage('Drag image or click to select');
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('directive.snImageUploader'),
    transclude: true,
    scope: {
      readOnly: '@',
      tableName: '@',
      sysId: '@',
      fieldName: '@',
      onUpload: '&',
      onDelete: '&',
      uploadMessage: '@',
      src: '='
    },
    controller: function($scope) {
      $scope.uploading = false;
      $scope.getTitle = function() {
        if ($scope.readOnly !== 'true')
          return DRAG_IMAGE_SELECT;
        return '';
      }
    },
    link: function(scope, element) {
      function isValidImage(file) {
        if (file.type.indexOf('image') != 0) {
          $alert(i18n.getMessage('Please select an image'));
          return false;
        }
        if (file.type.indexOf('tiff') > 0) {
          $alert(i18n.getMessage('Please select a common image format such as gif, jpeg or png'));
          return false;
        }
        return true;
      }

      function $alert(message) {
        alert(message);
      }
      scope.onFileSelect = function($files) {
        if (scope.readOnly === 'true')
          return;
        if ($files.length == 0)
          return;
        var file = $files[0];
        if (!isValidImage(file))
          return;
        var uploadParams = {
          sysparm_fieldname: scope.fieldName
        };
        scope.uploading = true;
        snAttachmentHandler.create(scope.tableName, scope.sysId).uploadAttachment(file, uploadParams).then(function(response) {
          $timeout(function() {
            scope.uploading = false;
          });
          if (scope.onUpload)
            scope.onUpload({
              thumbnail: response.thumbnail
            });
          $rootScope.$broadcast("snImageUploader:complete", scope.sysId, response);
        });
      }
      scope.openFileSelector = function($event) {
        $event.stopPropagation();
        var input = element.find('input[type=file]');
        input.click();
      }
      scope.activateUpload = function($event) {
        if (scope.readOnly !== 'true')
          scope.openFileSelector($event);
        else
          scope.showUpload = !scope.showUpload;
      }
      scope.deleteAttachment = function() {
        var sys_id = scope.src.split(".")[0];
        snAttachmentHandler.deleteAttachment(sys_id).then(function() {
          scope.src = null;
          if (scope.onDelete)
            scope.onDelete();
          $rootScope.$broadcast("snImageUploader:delete", scope.sysId, sys_id);
        });
      }
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/i18n/js_includes_i18n.js */
/*! RESOURCE: /scripts/sn/common/i18n/_module.js */
angular.module('sn.common.i18n', ['sn.common.glide']);
angular.module('sn.i18n', ['sn.common.i18n']);;
/*! RESOURCE: /scripts/sn/common/i18n/directive.snBindI18n.js */
angular.module('sn.common.i18n').directive('snBindI18n', function(i18n, $sanitize) {
  return {
    restrict: 'A',
    link: function(scope, iElem, iAttrs) {
      i18n.getMessage(iAttrs.snBindI18n, function(translatedValue) {
        var sanitizedValue = $sanitize(translatedValue);
        iElem.append(sanitizedValue);
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/i18n/directive.message.js */
angular.module('sn.common.i18n').directive('nowMessage', function(i18n) {
  return {
    restrict: 'E',
    priority: 0,
    template: '',
    replace: true,
    compile: function(element, attrs, transclude) {
      var value = element.attr('value');
      if (!attrs.key || !value)
        return;
      i18n.loadMessage(attrs.key, value);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/i18n/service.i18n.js */
angular.module('sn.common.i18n').provider('i18n', function() {
  var messageMap = {};

  function loadMessage(msgKey, msgValue) {
    messageMap[msgKey] = msgValue;
  }
  this.preloadMessages = function(messages) {
    angular.forEach(messages, function(key, val) {
      loadMessage(key, val);
    });
  };

  function interpolate(param) {
    return this.replace(/{([^{}]*)}/g,
      function(a, b) {
        var r = param[b];
        return typeof r === 'string' || typeof r === 'number' ? r : a;
      }
    );
  }
  if (!String.prototype.withValues)
    String.prototype.withValues = interpolate;
  this.$get = function(nowServer, $http, $window, $log) {
    var isDebug = $window.NOW ? $window.NOW.i18n_debug : true;

    function debug(msg) {
      if (!isDebug)
        return;
      $log.log('i18n: ' + msg);
    }

    function getMessageFromServer(msgKey, callback) {
      getMessagesFromServer([msgKey], function() {
        if (callback)
          callback(messageMap[msgKey]);
      });
    }

    function getMessagesFromServer(msgArray, callback, msgArrayFull) {
      var url = nowServer.getURL('message');
      $http.post(url, {
        messages: msgArray
      }).success(function(response) {
        var messages = response.messages;
        for (var i in messages) {
          loadMessage(i, messages[i]);
        }
        var returnMessages = {},
          allMessages = msgArrayFull || msgArray;
        for (var j = 0; j < allMessages.length; j++) {
          var key = allMessages[j];
          returnMessages[key] = messageMap[key];
        }
        if (callback)
          callback(returnMessages);
      });
    }
    return {
      getMessage: function(msgKey, callback) {
        debug('getMessage: Checking for ' + msgKey);
        if (messageMap.hasOwnProperty(msgKey)) {
          var message = messageMap[msgKey];
          if (typeof(callback) == 'function')
            callback(message);
          debug('getMessage: Found: ' + msgKey + ', message: ' + message);
          return message;
        }
        debug('getMessage: Not found: ' + msgKey + ', querying server');
        getMessageFromServer(msgKey, callback);
        msgKey.withValues = interpolate;
        if (typeof(callback) != 'function')
          $log.warn('getMessage (key="' + msgKey + '"): synchronous use not supported in Mobile or Service Portal unless message is already cached');
        return msgKey;
      },
      format: function(message) {
        if (arguments.length == 1)
          return message;
        if (arguments.length == 2 && (typeof arguments[1] === 'object'))
          return interpolate.call(message, arguments[1]);
        return interpolate.call(message, [].slice.call(arguments, 1));
      },
      getMessages: function(msgArray, callback) {
        debug('getMessages: Checking for ' + msgArray.join(','));
        var results = {},
          needMessage = [],
          needServerRequest = false;
        for (var i = 0; i < msgArray.length; i++) {
          var key = msgArray[i];
          if (!messageMap.hasOwnProperty(key)) {
            debug('getMessages: Did not find ' + key);
            needMessage.push(key);
            needServerRequest = true;
            results[key] = key;
            continue;
          }
          results[key] = messageMap[key];
          debug('getMessages: Found ' + key + ', message: ' + results[key]);
        }
        if (needServerRequest) {
          debug('getMessages: Querying server for ' + needMessage.join(','));
          getMessagesFromServer(needMessage, callback, msgArray);
        } else if (typeof(callback) == 'function') {
          debug('getMessages: Found all messages');
          callback(results);
        }
        return results;
      },
      clearMessages: function() {
        debug('clearMessages: clearing messages');
        messageMap = {};
      },
      loadMessage: function(msgKey, msgValue) {
        loadMessage(msgKey, msgValue);
        debug('loadMessage: loaded key: ' + msgKey + ', value: ' + msgValue);
      },
      preloadMessages: function() {
        var that = this
        angular.element('now-message').each(function() {
          var elem = angular.element(this);
          that.loadMessage(elem.attr('key'), elem.attr('value'));
        })
      }
    };
  };
});;;
/*! RESOURCE: /scripts/sn/common/link/js_includes_link.js */
/*! RESOURCE: /scripts/sn/common/link/_module.js */
angular.module("sn.common.link", []);;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContent.js */
angular.module('sn.common.link').directive('snLinkContent', function($compile, linkContentTypes) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    template: "<span />",
    scope: {
      link: "="
    },
    link: function(scope, elem) {
      scope.isShowing = function() {
        return (scope.link.isActive || scope.link.isUnauthorized) && !scope.link.isPending;
      };
      var linkDirective = linkContentTypes.forType(scope.link);
      elem.attr(linkDirective, "");
      elem.attr('ng-if', 'isShowing()');
      $compile(elem)(scope);
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentYoutube.js */
angular.module('sn.common.link').directive('snLinkContentYoutube', function(getTemplateUrl, $sce, inFrameSet) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentYoutube.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.playerActive = false;
      $scope.width = (inFrameSet) ? '248px' : '500px';
      $scope.height = (inFrameSet) ? '139px' : '281px';
      $scope.showPlayer = function() {
        $scope.playerActive = true;
      };
      $scope.getVideoEmbedLink = function() {
        if ($scope.link.embedLink) {
          var videoLink = $scope.link.embedLink + "?autoplay=1";
          return $sce.trustAsHtml("<iframe width='" + $scope.width + "' height='" + $scope.height + "' autoplay='1' frameborder='0' allowfullscreen='' src='" + videoLink + "'></iframe>");
        }
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentSoundcloud.js */
angular.module('sn.common.link').directive('snLinkContentSoundcloud', function(getTemplateUrl, $sce, inFrameSet) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentSoundcloud.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.playerActive = false;
      $scope.width = (inFrameSet) ? '248px' : '500px';
      $scope.height = (inFrameSet) ? '139px' : '281px';
      $scope.showPlayer = function() {
        $scope.playerActive = true;
      };
      $scope.getVideoEmbedLink = function() {
        if ($scope.link.embedLink) {
          var videoLink = $scope.link.embedLink + "&amp;auto_play=true";
          var width = (inFrameSet) ? 248 : 500;
          return $sce.trustAsHtml("<iframe width='" + $scope.width + "' height='" + $scope.height + "' autoplay='1' frameborder='0' allowfullscreen='' src='" + videoLink + "'></iframe>");
        }
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentArticle.js */
angular.module('sn.common.link').directive('snLinkContentArticle', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentArticle.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.backgroundImageStyle = $scope.link.imageLink ?
        {
          "background-image": 'url(' + $scope.link.imageLink + ')'
        } :
        {};
      $scope.isVisible = function() {
        var link = $scope.link;
        return !!link.shortDescription || !!link.imageLink;
      };
      $scope.hasDescription = function() {
        var link = $scope.link;
        return link.shortDescription && (link.shortDescription !== link.title);
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentError.js */
angular.module('sn.common.link').directive('snLinkContentError', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentError.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentImage.js */
angular.module('sn.common.link').directive('snLinkContentImage', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentImage.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentAttachment.js */
angular.module('sn.common.link').directive('snLinkContentAttachment', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentAttachment.xml'),
    scope: {
      attachment: '=',
      link: '='
    },
    controller: function($scope, $element, snCustomEvent) {
      $scope.attachment = $scope.attachment || $scope.link.attachment;
      $scope.calcImageSize = function() {
        var imageWidth = $scope.width;
        var imageHeight = $scope.height;
        var MAX_IMAGE_SIZE = $element.width() < 298 ? $element.width() : 298;
        if (imageHeight < 0 || imageWidth < 0)
          return "";
        if (imageHeight > imageWidth) {
          if (imageHeight >= MAX_IMAGE_SIZE) {
            imageWidth *= MAX_IMAGE_SIZE / imageHeight;
            imageHeight = MAX_IMAGE_SIZE;
          }
        } else {
          if (imageWidth >= MAX_IMAGE_SIZE) {
            imageHeight *= MAX_IMAGE_SIZE / imageWidth;
            imageWidth = MAX_IMAGE_SIZE
          }
        }
        return "height: " + imageHeight + "px; width: " + imageWidth + "px;";
      };
      $scope.aspectRatioClass = function() {
        return ($scope.height > $scope.width) ? 'limit-height' : 'limit-width';
      };
      $scope.showImage = function(event) {
        if (event.keyCode === 9)
          return;
        snCustomEvent.fire('sn.attachment.preview', event, $scope.attachment.rawData);
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentRecord.js */
angular.module('sn.common.link').directive('snLinkContentRecord', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentRecord.xml'),
    scope: {
      link: '='
    },
    controller: function($scope) {
      $scope.isTitleVisible = function() {
        return !$scope.isDescriptionVisible() && $scope.link.title;
      };
      $scope.isDescriptionVisible = function() {
        return $scope.link.shortDescription;
      };
      $scope.hasNoHeader = function() {
        return !$scope.isTitleVisible() && !$scope.isDescriptionVisible();
      };
      $scope.isUnassigned = function() {
        return $scope.link.isTask && !$scope.link.avatarID;
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/provider.linkContentTypes.js */
angular.module('sn.common.link').provider('linkContentTypes', function linkContentTypesProvider() {
  "use strict";
  var linkDirectiveMap = {
    'record': "sn-link-content-record",
    'attachment': "sn-link-content-attachment",
    'video': "sn-link-content-youtube",
    'music.song': "sn-link-content-soundcloud",
    'link': 'sn-link-content-article',
    'article': 'sn-link-content-article',
    'website': 'sn-link-content-article',
    'image': 'sn-link-content-image'
  };
  this.$get = function linkContentTypesFactory() {
    return {
      forType: function(link) {
        if (link.isUnauthorized)
          return "sn-link-content-error";
        return linkDirectiveMap[link.type] || "no-card";
      }
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/mention/js_includes_mention.js */
/*! RESOURCE: /scripts/sn/common/mention/_module.js */
angular.module("sn.common.mention", []);;
/*! RESOURCE: /scripts/sn/common/mention/directive.snMentionPopover.js */
angular.module('sn.common.mention').directive("snMentionPopover", function(getTemplateUrl, $timeout) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('snMentionPopover.xml'),
    link: function(scope, elem, $attrs) {
      elem.detach().appendTo(document.body);
      scope.dontPositionManually = scope.$eval($attrs.dontpositionmanually) || false;
      scope.onClick = function(event) {
        if (!angular.element(event.target).closest("#mention-popover").length ||
          angular.element(event.target).closest("#direct-message-popover-trigger").length) {
          scope.$evalAsync(function() {
            scope.$parent.showPopover = false;
            scope.$emit("snMentionPopover.showPopoverIsFalse");
            if (scope.dontPositionManually && !(scope.$eval($attrs.snavatarpopover))) {
              elem.remove();
            } else {
              scope.$broadcast("sn-avatar-popover-destroy");
            }
            angular.element('.popover').each(function() {
              var object = angular.element(this);
              if (object.popover) {
                object.popover('hide');
              }
            })
          });
        }
      };
      scope.clickListener = $timeout(function() {
        angular.element('html').on('click.mentionPopover', scope.onClick);
      }, 0, false);
      scope.$on('sn-bootstrap-popover.close-other-popovers', scope.onClick);

      function setPopoverPosition(clickX, clickY) {
        var topPosition;
        var leftPosition;
        var windowHeight = window.innerHeight;
        var windowWidth = window.innerWidth;
        if (((clickY - (elem.height() / 2))) < 10)
          topPosition = 10;
        else
          topPosition = ((clickY + (elem.height() / 2)) > windowHeight) ? windowHeight - elem.height() - 15 : clickY - (elem.height() / 2);
        leftPosition = ((clickX + 20 + (elem.width())) > windowWidth) ? windowWidth - elem.width() - 15 : clickX + 20;
        elem.css("top", topPosition + "px").css("left", leftPosition + "px");
      }
      if (!scope.dontPositionManually) {
        $timeout(function() {
          var clickX = (scope.$parent && scope.$parent.clickEvent && scope.$parent.clickEvent.pageX) ? scope.$parent.clickEvent.pageX : clickX || 300;
          var clickY = (scope.$parent && scope.$parent.clickEvent && scope.$parent.clickEvent.pageY) ? scope.$parent.clickEvent.pageY : clickY || 300;
          setPopoverPosition(clickX, clickY);
          elem.velocity({
            opacity: 1
          }, {
            duration: 100,
            easing: "cubic"
          });
        });
      }
    },
    controller: function($scope, $element, $attrs) {
      $scope.profile = $scope.$eval($attrs.profile);
      $scope.$on("$destroy", function() {
        angular.element('html').off('click.mentionPopover', $scope.onClick);
        $element.remove();
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/mention/service.snMention.js */
angular.module("sn.common.mention").factory("snMention", function(liveProfileID, $q, $http) {
  "use strict";
  var MENTION_PATH = "/api/now/form/mention/record";
  var USER_PATH = '/api/now/ui/user/';
  var avatarCache = {};

  function retrieveMembers(table, document, term) {
    if (!term || !document || !table) {
      var deferred = $q.defer();
      deferred.resolve([]);
      return deferred.promise;
    }
    return $http({
      url: MENTION_PATH + "/" + table + "/" + document,
      method: "GET",
      params: {
        term: term
      }
    }).then(function(response) {
      var members = response.data.result;
      var promises = [];
      angular.forEach(members, function(user) {
        if (avatarCache[user.sys_id]) {
          user.initials = avatarCache[user.sys_id].initials;
          user.avatar = avatarCache[user.sys_id].avatar;
        } else {
          var promise = $http.get(USER_PATH + user.sys_id).success(function(response) {
            user.initials = response.result.user_initials;
            user.avatar = response.result.user_avatar;
            avatarCache[user.sys_id] = {
              initials: user.initials,
              avatar: user.avatar
            };
          });
          promises.push(promise);
        }
      });
      return $q.all(promises).then(function() {
        return members;
      });
    })
  }
  return {
    retrieveMembers: retrieveMembers
  }
});;;
/*! RESOURCE: /scripts/sn/common/messaging/js_includes_messaging.js */
/*! RESOURCE: /scripts/doctype/CustomEventManager.js */
var NOW = NOW || {};
var CustomEventManager = (function(existingCustomEvent) {
  "use strict";
  var events = (existingCustomEvent && existingCustomEvent.events) || {};
  var isFiringFlag = false;
  var trace = false;
  var suppressEvents = false;
  var NOW_MSG = 'NOW.PostMessage';

  function observe(eventName, fn) {
    if (trace)
      jslog("$CustomEventManager observing: " + eventName);
    on(eventName, fn);
  }

  function on(name, func) {
    if (!func || typeof func !== 'function')
      return;
    if (typeof name === 'undefined')
      return;
    if (!events[name])
      events[name] = [];
    events[name].push(func);
  }

  function un(name, func) {
    if (!events[name])
      return;
    var idx = -1;
    for (var i = 0; i < events[name].length; i++) {
      if (events[name][i] === func) {
        idx = i;
        break;
      }
    }
    if (idx >= 0)
      events[name].splice(idx, 1)
  }

  function unAll(name) {
    if (events[name])
      delete events[name];
  }

  function fire(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    return fireEvent.apply(null, arguments);
  }

  function fireUp(eventName, args) {
    var win = window;
    while (win) {
      try {
        if (win.CustomEvent.fireEvent.apply(null, arguments) === false)
          return;
        win = win.parent === win ? null : win.parent;
      } catch (e) {
        return;
      }
    }
  }

  function fireEvent() {
    if (suppressEvents)
      return true;
    var args = Array.prototype.slice.apply(arguments);
    var name = args.shift();
    var eventList = events[name];
    if (!eventList)
      return true;
    var event = eventList.slice();
    isFiringFlag = true;
    for (var i = 0, l = event.length; i < l; i++) {
      var ev = event[i];
      if (!ev)
        continue;
      if (ev.apply(null, args) === false) {
        isFiringFlag = false;
        return false;
      }
    }
    isFiringFlag = false;
    return true;
  }

  function isFiring() {
    return isFiringFlag;
  }

  function forward(name, element, func) {
    on(name, func);
    element.addEventListener(name, function(e) {
      fireEvent(e.type, this, e);
    }.bind(api));
  }

  function registerPostMessageEvent() {
    if (NOW.registeredPostMessageEvent) {
      return;
    }
    if (!window.postMessage) {
      return;
    }
    window.addEventListener('message', function(event) {
      var nowMessageJSON = event.data;
      var nowMessage;
      try {
        nowMessage = JSON.parse(nowMessageJSON.toString());
      } catch (e) {
        return;
      }
      if (!nowMessage.type == NOW_MSG) {
        return;
      }
      fire(nowMessage.eventName, nowMessage.args);
    }, false);
    NOW.registeredPostMessageEvent = true;
  }

  function doPostMessage(win, event, msg, targetOrigin) {
    var nowMessage = {
      type: NOW_MSG,
      eventName: event,
      args: msg
    };
    var nowMessageJSON;
    if (!win || !win.postMessage) {
      return
    }
    nowMessageJSON = JSON.stringify(nowMessage);
    win.postMessage(nowMessageJSON, targetOrigin);
  }

  function fireTop(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    fireEvent.apply(null, arguments);
    var t = getTopWindow();
    if (t !== null && window !== t)
      t.CustomEvent.fire(eventName, args);
  }

  function fireAll(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    var topWindow = getTopWindow();
    notifyAllFrom(topWindow);

    function notifyAllFrom(rootFrame) {
      var childFrame;
      rootFrame.CustomEvent.fireEvent(eventName, args);
      for (var i = 0; i < rootFrame.length; i++) {
        try {
          childFrame = rootFrame[i];
          if (!childFrame)
            continue;
          if (childFrame.CustomEvent && typeof childFrame.CustomEvent.fireEvent === "function") {
            notifyAllFrom(childFrame);
          }
        } catch (e) {}
      }
    }
  }

  function fireToWindow(targetWindow, eventName, args, usePostMessage, targetOrigin) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + args.length);
    if (usePostMessage) {
      doPostMessage(targetWindow, eventName, args, targetOrigin);
    } else {
      targetWindow.CustomEvent.fireEvent(eventName, args);
    }
  }

  function getTopWindow() {
    var topWindow = window.self;
    try {
      while (topWindow.CustomEvent.fireEvent && topWindow !== topWindow.parent && topWindow.parent.CustomEvent.fireEvent) {
        topWindow = topWindow.parent;
      }
    } catch (e) {}
    return topWindow;
  }

  function isTopWindow() {
    return getTopWindow() == window.self;
  }

  function jslog(msg, src, dateTime) {
    try {
      if (!src) {
        var path = window.self.location.pathname;
        src = path.substring(path.lastIndexOf('/') + 1);
      }
      if (window.self.opener && window != window.self.opener) {
        if (window.self.opener.jslog) {
          window.self.opener.jslog(msg, src, dateTime);
        }
      } else if (parent && parent.jslog && jslog != parent.jslog) {
        parent.jslog(msg, src, dateTime);
      } else {
        if (window.console && window.console.log)
          console.log(msg);
      }
    } catch (e) {}
  }
  var api = {
    set trace(value) {
      trace = !!value;
    },
    get trace() {
      return trace;
    },
    set suppressEvents(value) {
      suppressEvents = !!value;
    },
    get suppressEvents() {
      return suppressEvents;
    },
    get events() {
      return events;
    },
    on: on,
    un: un,
    unAll: unAll,
    forward: forward,
    isFiring: isFiring,
    fireEvent: fireEvent,
    observe: observe,
    fire: fire,
    fireTop: fireTop,
    fireAll: fireAll,
    fireToWindow: fireToWindow,
    isTopWindow: isTopWindow,
    fireUp: fireUp,
    toString: function() {
      return 'CustomEventManager';
    }
  };
  registerPostMessageEvent();
  return api;
})(NOW.CustomEvent);
NOW.CustomEvent = CustomEventManager;
if (typeof CustomEvent !== "undefined") {
  CustomEvent.observe = NOW.CustomEvent.observe.bind(NOW.CustomEvent);
  CustomEvent.fire = NOW.CustomEvent.fire.bind(NOW.CustomEvent);
  CustomEvent.fireUp = NOW.CustomEvent.fireUp.bind(NOW.CustomEvent);
  CustomEvent.fireTop = NOW.CustomEvent.fireTop.bind(NOW.CustomEvent);
  CustomEvent.fireAll = NOW.CustomEvent.fireAll.bind(NOW.CustomEvent);
  CustomEvent.fireToWindow = NOW.CustomEvent.fireToWindow.bind(NOW.CustomEvent);
  CustomEvent.on = NOW.CustomEvent.on.bind(NOW.CustomEvent);
  CustomEvent.un = NOW.CustomEvent.un.bind(NOW.CustomEvent);
  CustomEvent.unAll = NOW.CustomEvent.unAll.bind(NOW.CustomEvent);
  CustomEvent.forward = NOW.CustomEvent.forward.bind(NOW.CustomEvent);
  CustomEvent.isFiring = NOW.CustomEvent.isFiring.bind(NOW.CustomEvent);
  CustomEvent.fireEvent = NOW.CustomEvent.fireEvent.bind(NOW.CustomEvent);
  CustomEvent.events = NOW.CustomEvent.events;
  CustomEvent.isTopWindow = NOW.CustomEvent.isTopWindow.bind(NOW.CustomEvent);
} else {
  window.CustomEvent = NOW.CustomEvent;
};
/*! RESOURCE: /scripts/sn/common/messaging/_module.js */
angular.module('sn.common.messaging', []);
angular.module('sn.messaging', ['sn.common.messaging']);;
/*! RESOURCE: /scripts/sn/common/messaging/service.snCustomEvent.js */
angular.module('sn.common.messaging').factory('snCustomEvent', function() {
  "use strict";
  if (typeof NOW.CustomEvent === 'undefined')
    throw "CustomEvent not found in NOW global";
  return NOW.CustomEvent;
});;;
/*! RESOURCE: /scripts/sn/common/notification/js_includes_notification.js */
/*! RESOURCE: /scripts/sn/common/notification/_module.js */
angular.module('sn.common.notification', ['sn.common.util', 'ngSanitize']);;
/*! RESOURCE: /scripts/sn/common/notification/factory.notificationWrapper.js */
angular.module("sn.common.notification").factory("snNotificationWrapper", function($window, $timeout) {
  "use strict";

  function assignHandler(notification, handlerName, options) {
    if (typeof options[handlerName] === "function")
      notification[handlerName.toLowerCase()] = options[handlerName];
  }
  return function NotificationWrapper(title, options) {
    var defaults = {
      dir: 'auto',
      lang: 'en_US',
      decay: true,
      lifespan: 4000,
      body: "",
      tag: "",
      icon: '/native_notification_icon.png'
    };
    var optionsOnClick = options.onClick;
    options.onClick = function() {
      if (angular.isFunction($window.focus))
        $window.focus();
      if (typeof optionsOnClick === "function")
        optionsOnClick();
    }
    var result = {};
    options = angular.extend(defaults, options);
    var previousOnClose = options.onClose;
    options.onClose = function() {
      if (angular.isFunction(result.onclose))
        result.onclose();
      if (angular.isFunction(previousOnClose))
        previousOnClose();
    }
    var notification = new $window.Notification(title, options);
    assignHandler(notification, "onShow", options);
    assignHandler(notification, "onClick", options);
    assignHandler(notification, "onError", options);
    assignHandler(notification, "onClose", options);
    if (options.decay && options.lifespan > 0)
      $timeout(function() {
        notification.close();
      }, options.lifespan)
    result.close = function() {
      notification.close();
    }
    return result;
  }
});
/*! RESOURCE: /scripts/sn/common/notification/service.snNotifier.js */
angular.module("sn.common.notification").factory("snNotifier", function($window, snNotificationWrapper) {
  "use strict";
  return function(settings) {
    function requestNotificationPermission() {
      if ($window.Notification && $window.Notification.permission === "default")
        $window.Notification.requestPermission();
    }

    function canUseNativeNotifications() {
      return ($window.Notification && $window.Notification.permission === "granted");
    }
    var currentNotifications = [];
    settings = angular.extend({
      notifyMethods: ["native", "glide"]
    }, settings);
    var methods = {
      'native': nativeNotify,
      'glide': glideNotify
    };

    function nativeNotify(title, options) {
      if (canUseNativeNotifications()) {
        var newNotification = snNotificationWrapper(title, options);
        newNotification.onclose = function() {
          stopTrackingNotification(newNotification)
        };
        currentNotifications.push(newNotification);
        return true;
      }
      return false;
    }

    function glideNotify(title, options) {
      return false;
    }

    function stopTrackingNotification(newNotification) {
      var index = currentNotifications.indexOf(newNotification);
      if (index > -1)
        currentNotifications.splice(index, 1);
    }

    function notify(title, options) {
      if (typeof options === "string")
        options = {
          body: options
        };
      options = options || {};
      for (var i = 0, len = settings.notifyMethods.length; i < len; i++)
        if (typeof settings.notifyMethods[i] == "string") {
          if (methods[settings.notifyMethods[i]](title, options))
            break;
        } else {
          if (settings.notifyMethods[i](title, options))
            break;
        }
    }

    function clearAllNotifications() {
      while (currentNotifications.length > 0)
        currentNotifications.pop().close();
    }
    return {
      notify: notify,
      canUseNativeNotifications: canUseNativeNotifications,
      clearAllNotifications: clearAllNotifications,
      requestNotificationPermission: requestNotificationPermission
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/notification/directive.snNotification.js */
angular.module('sn.common.notification').directive('snNotification', function($timeout, $rootScope) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    template: '<div class="notification-container"></div>',
    link: function(scope, element) {
      scope.addNotification = function(payload) {
          if (!payload)
            payload = {};
          if (!payload.text)
            payload.text = '';
          if (!payload.classes)
            payload.classes = '';
          if (!payload.duration)
            payload.duration = 5000;
          angular.element('<div/>').qtip({
            content: {
              text: payload.text,
              title: {
                button: false
              }
            },
            position: {
              target: [0, 0],
              container: angular.element('.notification-container')
            },
            show: {
              event: false,
              ready: true,
              effect: function() {
                angular.element(this).stop(0, 1).animate({
                  height: 'toggle'
                }, 400, 'swing');
              },
              delay: 0,
              persistent: false
            },
            hide: {
              event: false,
              effect: function(api) {
                angular.element(this).stop(0, 1).animate({
                  height: 'toggle'
                }, 400, 'swing');
              }
            },
            style: {
              classes: 'jgrowl' + ' ' + payload.classes,
              tip: false
            },
            events: {
              render: function(event, api) {
                if (!api.options.show.persistent) {
                  angular.element(this).bind('mouseover mouseout', function(e) {
                      clearTimeout(api.timer);
                      if (e.type !== 'mouseover') {
                        api.timer = setTimeout(function() {
                          api.hide(e);
                        }, payload.duration);
                      }
                    })
                    .triggerHandler('mouseout');
                }
              }
            }
          });
        },
        scope.$on('notification.notify', function(event, payload) {
          scope.addNotification(payload);
        });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/notification/service.snNotification.js */
angular.module('sn.common.notification').factory('snNotification', function($document, $templateCache, $compile, $rootScope,
  $timeout, $q, getTemplateUrl, $http) {
  'use strict';
  var openNotifications = [],
    timeouts = {},
    options = {
      top: 20,
      gap: 10,
      duration: 5000
    };
  return {
    show: function(type, message, duration, onClick) {
      return createNotificationElement(type, message).then(function(element) {
        displayNotification(element);
        checkAndSetDestroyDuration(element, duration);
        return element;
      });
    },
    hide: hide,
    setOptions: function(opts) {
      if (angular.isObject(opts))
        angular.extend(options, opts);
    }
  };

  function getTemplate() {
    var templateName = 'sn_notification.xml',
      template = $templateCache.get(templateName),
      deferred = $q.defer();
    if (!template) {
      var url = getTemplateUrl(templateName);
      $http.get(url).then(function(result) {
          $templateCache.put(templateName, result.data);
          deferred.resolve(result.data);
        },
        function(reason) {
          return $q.reject(reason);
        });
    } else
      deferred.resolve(template);
    return deferred.promise;
  }

  function createNotificationElement(type, message) {
    var thisScope, thisElement;
    return getTemplate().then(function(template) {
      thisScope = $rootScope.$new();
      thisScope.type = type;
      thisScope.message = message;
      thisElement = $compile(template)(thisScope);
      return angular.element(thisElement[0]);
    });
  }

  function displayNotification(element) {
    var body = $document.find('body'),
      id = 'elm' + Date.now(),
      pos;
    body.append(element);
    pos = options.top + openNotifications.length * getElementHeight(element);
    positionElement(element, pos);
    element.addClass('visible');
    element.attr('id', id);
    element.find('button').bind('click', function(e) {
      hideElement(element);
    });
    openNotifications.push(element);
    if (options.duration > 0)
      timeouts[id] = $timeout(function() {
        hideNext();
      }, options.duration);
  }

  function hide(element) {
    $timeout.cancel(timeouts[element.attr('id')]);
    element.removeClass('visible');
    element.addClass('hidden');
    element.find('button').eq(0).unbind();
    element.scope().$destroy();
    element.remove();
    repositionAll();
  }

  function hideElement(element) {
    var index = openNotifications.indexOf(element);
    openNotifications.splice(index, 1);
    hide(element);
  }

  function hideNext() {
    var element = openNotifications.shift();
    if (element)
      hide(element);
  }

  function getElementHeight(element) {
    return element[0].offsetHeight + options.gap;
  }

  function positionElement(element, pos) {
    element[0].style.top = pos + 'px';
  }

  function repositionAll() {
    var pos = options.top;
    openNotifications.forEach(function(element) {
      positionElement(element, pos);
      pos += getElementHeight(element);
    });
  }

  function checkAndSetDestroyDuration(element, duration) {
    if (duration) {
      timeouts[element.attr('id')] = $timeout(function() {
        hideElement(element);
      }, duration);
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/presence/js_includes_presence.js */
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i < array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j < types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i < _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &&
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length < this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index >= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses && responses.length > 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i < _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length > 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength > _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length > 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i < lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout > 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null && webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel && !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j < messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index >= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length > 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect && _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported && !!org.cometd.WebSocket && _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i < arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep && typeof prop === 'object' && prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort && hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined && afterURI.length > 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions && subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription && !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i < subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '->', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions && subscriptions.length > 0) {
      for (var i = 0; i < subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i > 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined && message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch > 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff < _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length > 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch < 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length > 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() && _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i >= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription && !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i < rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i < subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport && typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' && define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON && JSON.stringify) || (window.jaredJSON && window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON && JSON.parse) || (window.jaredJSON && window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' && define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    if (window.console)
      console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i < _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i < _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i < subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out',
    SESSION_INVALIDATED: 'session.invalidated'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log(">>> connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -> ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected && connected)
      _connectionOpened();
    else if (wasConnected && !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        case 'session.invalidated':
          if (loggedIn)
            _invalidated();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }

  function _invalidated() {
    loggedIn = false;
    LOGGER.debug("INVALIDATED event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_INVALIDATED);
  }
  var modalContent = '<iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"></iframe>';
  var modalTemplate = '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '  <div class="modal-dialog small-modal" style="width:450px">' +
    '     <div class="modal-content">' +
    '        <header class="modal-header">' +
    '           <h4 id="small_modal1_title" class="modal-title">Login</h4>' +
    '        </header>' +
    '        <div class="modal-body">' +
    '        </div>' +
    '     </div>' +
    '  </div>' +
    '</div>';

  function _loginShow() {
    LOGGER.debug("Show login window");
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i < window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event && connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, this._subscribeWhenReady.bind(this));
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription && _initialized)
        this.subscribeToCometD();
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i < listeners.length; i++)
        listeners[i].resubscribe();
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    _handleResponse: function(message) {
      for (var i = 0; i < listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length < 1 && subscription && !_disconnected())
        this.unsubscribeFromCometD();
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    subscribeToCometD: function() {
      subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
      LOGGER.debug('Successfully subscribed to channel: ' + channelName);
    },
    unsubscribeFromCometD: function() {
      cometd.unsubscribe(subscription);
      subscription = null;
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    resubscribeToCometD: function() {
      this.subscribeToCometD();
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_OUT, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_INVALIDATED, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_IN, _resubscribeAll);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i < uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          _resubscribeAll()
          _connectionBrokenEvent = false;
        });
      }
    }

    function _unsubscribeAll() {
      LOGGER.debug("Unsubscribing from all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.unsubscribeFromCometD();
      }
    }

    function _resubscribeAll() {
      LOGGER.debug("Resubscribing to all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.resubscribeToCometD();
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage(">>> connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(window.jQuery || window.Zepto);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext && document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(window.jQuery || window.Zepto);;;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  ambClient = amb.getClient();
  if (_window.g_ambClient) {
    sameScope = true;
  }
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow && loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB && state !== "opened" && state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log(">>> init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log(">>> record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i < len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i < len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '	<div class="modal-dialog small-modal" style="width:450px">' +
    '		<div class="modal-content">' +
    '			<header class="modal-header">' +
    '				<h4 id="small_modal1_title" class="modal-title">{{title || "Login"}}</h4>' +
    '			</header>' +
    '			<div class="modal-body">' +
    '			<iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"></iframe>' +
    '			</div>' +
    '		</div>' +
    '	</div>' +
    '</div>'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/sn/common/presence/_module.js */
angular.module('sn.common.presence', ['ng.amb', 'sn.common.glide']).config(function($provide) {
  "use strict";
  $provide.constant("PRESENCE_DISABLED", "false" === "true");
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snPresence.js */
angular.module("sn.common.presence").factory('snPresence', function($rootScope, $window, $log, amb, $timeout, $http, snRecordPresence, snTabActivity, urlTools, PRESENCE_DISABLED) {
  "use strict";
  var REST = {
    PRESENCE: "/api/now/ui/presence"
  };
  var databaseInterval = ($window.NOW.presence_interval || 15) * 1000;
  var initialized = false;
  var primary = false;
  var presenceArray = [];
  var serverTimeMillis;
  var skew = 0;
  var st = 0;

  function init() {
    var location = urlTools.parseQueryString(window.location.search);
    var table = location['table'] || location['sysparm_table'];
    var sys_id = location['sys_id'] || location['sysparm_sys_id'];
    var query = location['sysparm_query'];
    initPresence(table, sys_id, query);
  }

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!initialized) {
      initialized = true;
      initRootScopes();
      if (!primary) {
        CustomEvent.observe('sn.presence', onPresenceEvent);
        CustomEvent.fireTop('sn.presence.ping');
      } else {
        presenceArray = getLocalPresence();
        if (presenceArray)
          $timeout(schedulePresence, 100);
        else
          updateDatabase();
      }
    }
    snRecordPresence.initPresence(t, id);
  }

  function onPresenceEvent(parms) {
    presenceArray = parms;
    $timeout(broadcastPresence);
  }

  function initRootScopes() {
    if ($window.NOW.presence_scopes) {
      var ps = $window.NOW.presence_scopes;
      if (ps.indexOf($rootScope) == -1)
        ps.push($rootScope);
    } else {
      $window.NOW.presence_scopes = [$rootScope];
      primary = CustomEvent.isTopWindow();
    }
  }

  function updateDatabase() {
    presenceArray = getLocalPresence();
    if (presenceArray) {
      determineStatus();
      $timeout(schedulePresence);
      return;
    }
    if (!amb.isLoggedIn() || !snTabActivity.isPrimary) {
      $timeout(schedulePresence);
      return;
    }
    var p = {
      user_agent: navigator.userAgent,
      ua_time: new Date().toISOString(),
      href: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      path: window.location.pathname + window.location.search
    };
    st = new Date().getTime();
    $http.post(REST.PRESENCE + '?sysparm_auto_request=true&cd=' + st, p).success(function(data) {
      var rt = new Date().getTime() - st;
      if (rt > 500)
        console.log("snPresence response time " + rt + "ms");
      if (data.result && data.result.presenceArray) {
        presenceArray = data.result.presenceArray;
        setLocalPresence(presenceArray);
        serverTimeMillis = data.result.serverTimeMillis;
        skew = new Date().getTime() - serverTimeMillis;
        var t = Math.floor(skew / 1000);
        if (t < -15)
          console.log(">>>>> server ahead " + Math.abs(t) + " seconds");
        else if (t > 15)
          console.log(">>>>> browser time ahead " + t + " seconds");
      }
      schedulePresence();
    }).error(function(response, status) {
      console.log("snPresence " + status);
      if (429 == status)
        $timeout(updateDatabase, databaseInterval);
      else
        schedulePresence();
    })
  }

  function schedulePresence() {
    $timeout(updateDatabase, databaseInterval);
    determineStatus();
    broadcastPresence();
  }

  function broadcastPresence() {
    $rootScope.$broadcast("sn.presence", presenceArray);
    if (!primary)
      return;
    CustomEvent.fireAll('sn.presence', presenceArray);
  }

  function determineStatus() {
    if (!presenceArray || !presenceArray.forEach)
      return;
    var t = new Date().getTime();
    t -= skew;
    presenceArray.forEach(function(p) {
      var x = 0 + p.last_on;
      var y = t - x;
      p.status = "online";
      if (y > (5 * databaseInterval))
        p.status = "offline";
      else if (y > (3 * databaseInterval))
        p.status = "probably offline";
      else if (y > (2.5 * databaseInterval))
        p.status = "maybe offline";
    })
  }

  function setLocalPresence(value) {
    var p = {
      saved: new Date().getTime(),
      presenceArray: value
    }
    $window.localStorage.setItem('snPresence', angular.toJson(p));
  }

  function getLocalPresence() {
    var p = $window.localStorage.getItem('snPresence');
    if (!p)
      return null;
    try {
      p = angular.fromJson(p);
    } catch (e) {
      p = {};
    }
    if (!p.presenceArray)
      return null;
    var now = new Date().getTime();
    if (now - p.saved >= databaseInterval)
      return null;
    return p.presenceArray;
  }
  return {
    init: init,
    initWithDocument: initPresence,
    initPresence: initPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snRecordPresence.js */
angular.module("sn.common.presence").factory('snRecordPresence', function($rootScope, $location, amb, $timeout, $window, PRESENCE_DISABLED, snTabActivity) {
  "use strict";
  var statChannel;
  var interval = ($window.NOW.record_presence_interval || 20) * 1000;
  var sessions = {};
  var primary = false;
  var table;
  var sys_id;

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!t || !id)
      return;
    if (t == table && id == sys_id)
      return;
    initRootScopes();
    if (!primary)
      return;
    termPresence();
    table = t;
    sys_id = id;
    var recordPresence = "/sn/rp/" + table + "/" + sys_id;
    $rootScope.me = NOW.session_id;
    statChannel = amb.getChannel(recordPresence);
    statChannel.subscribe(onStatus);
    amb.connected.then(function() {
      setStatus("entered");
      $rootScope.status = "viewing";
    });
    return statChannel;
  }

  function initRootScopes() {
    if ($window.NOW.record_presence_scopes) {
      var ps = $window.NOW.record_presence_scopes;
      if (ps.indexOf($rootScope) == -1) {
        ps.push($rootScope);
        CustomEvent.observe('sn.sessions', onPresenceEvent);
      }
    } else {
      $window.NOW.record_presence_scopes = [$rootScope];
      primary = true;
    }
  }

  function onPresenceEvent(sessionsToSend) {
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
  }

  function termPresence() {
    if (!statChannel)
      return;
    statChannel.unsubscribe();
    statChannel = table = sys_id = null;
  }

  function setStatus(status) {
    if (status == $rootScope.status)
      return;
    $rootScope.status = status;
    if (Object.keys(sessions).length == 0)
      return;
    if (getStatusPrecedence(status) > 1)
      return;
    publish($rootScope.status);
  }

  function publish(status) {
    if (!statChannel)
      return;
    if (amb.getState() !== "opened")
      return;
    statChannel.publish({
      presences: [{
        status: status,
        session_id: NOW.session_id,
        user_name: NOW.user_name,
        user_id: NOW.user_id,
        user_display_name: NOW.user_display_name,
        user_initials: NOW.user_initials,
        user_avatar: NOW.user_avatar,
        ua: navigator.userAgent,
        table: table,
        sys_id: sys_id,
        time: new Date().toString().substring(0, 24)
      }]
    });
  }

  function onStatus(message) {
    message.data.presences.forEach(function(d) {
      if (!d.session_id || d.session_id == NOW.session_id)
        return;
      var s = sessions[d.session_id];
      if (s)
        angular.extend(s, d);
      else
        s = sessions[d.session_id] = d;
      s.lastUpdated = new Date();
      if (s.status == 'exited')
        delete sessions[d.session_id];
    });
    broadcastSessions();
  }

  function broadcastSessions() {
    var sessionsToSend = getUniqueSessions();
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
    if (primary)
      $timeout(function() {
        CustomEvent.fire('sn.sessions', sessionsToSend);
      })
  }

  function getUniqueSessions() {
    var uniqueSessionsByUser = {};
    var sessionKeys = Object.keys(sessions);
    sessionKeys.forEach(function(key) {
      var session = sessions[key];
      if (session.user_id == NOW.user_id)
        return;
      if (session.user_id in uniqueSessionsByUser) {
        var otherSession = uniqueSessionsByUser[session.user_id];
        var thisPrecedence = getStatusPrecedence(session.status);
        var otherPrecedence = getStatusPrecedence(otherSession.status);
        uniqueSessionsByUser[session.user_id] = thisPrecedence < otherPrecedence ? session : otherSession;
        return
      }
      uniqueSessionsByUser[session.user_id] = session;
    });
    var uniqueSessions = {};
    angular.forEach(uniqueSessionsByUser, function(item) {
      uniqueSessions[item.session_id] = item;
    });
    return uniqueSessions;
  }

  function getStatusPrecedence(status) {
    switch (status) {
      case 'typing':
        return 0;
      case 'viewing':
        return 1;
      case 'entered':
        return 2;
      case 'exited':
      case 'probably left':
        return 4;
      case 'offline':
        return 5;
      default:
        return 3;
    }
  }
  $rootScope.$on("record.typing", function(evt, data) {
    setStatus(data.status);
  });
  var idleTable, idleSysID;
  snTabActivity.onIdle({
    onIdle: function RecordPresenceTabIdle() {
      idleTable = table;
      idleSysID = sys_id;
      sessions = {};
      termPresence();
      broadcastSessions();
    },
    onReturn: function RecordPresenceTabActive() {
      initPresence(idleTable, idleSysID, true);
      idleTable = idleSysID = void(0);
    },
    delay: interval * 4
  });
  return {
    initPresence: initPresence,
    termPresence: termPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snPresence.js */
angular.module('sn.common.presence').directive('snPresence', function(snPresence, $rootScope, $timeout) {
  'use strict';
  $timeout(snPresence.init, 100);
  var presences = {};
  $rootScope.$on('sn.presence', function(event, presenceArray) {
    if (!presenceArray) {
      angular.forEach(presences, function(p) {
        p.status = "offline";
      });
      return;
    }
    presenceArray.forEach(function(presence) {
      presences[presence.user] = presence;
    });
  });
  return {
    restrict: 'EA',
    replace: false,
    scope: {
      snPresence: '=?',
      user: '=?',
      profile: '=?'
    },
    link: function(scope, element) {
      if (scope.profile)
        scope.user = scope.profile.userID;
      if (!element.hasClass('presence'))
        element.addClass('presence');

      function updatePresence() {
        var id = scope.snPresence || scope.user;
        if (presences[id]) {
          var status = presences[id].status;
          if (status === 'maybe offline' || status === 'probably offline') {
            element.removeClass('presence-online presence-offline presence-away');
            element.addClass('presence-away');
          } else if (status == "offline" && !element.hasClass('presence-offline')) {
            element.removeClass('presence-online presence-away');
            element.addClass('presence-offline');
          } else if ((status == "online" || status == "entered" || status == "viewing") && !element.hasClass('presence-online')) {
            element.removeClass('presence-offline presence-away');
            element.addClass('presence-online');
          }
        } else {
          if (!element.hasClass('presence-offline'))
            element.addClass('presence-offline');
        }
      }
      $rootScope.$on('sn.presence', updatePresence);
      updatePresence();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snComposing.js */
angular.module('sn.common.presence').directive('snComposing', function(getTemplateUrl, snComposingPresence) {
  "use strict";
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl("snComposing.xml"),
    replace: true,
    scope: {
      conversation: "="
    },
    controller: function($scope, $element) {
      var child = $element.children();
      if (child && child.tooltip)
        child.tooltip({
          'template': '<div class="tooltip" style="white-space: pre-wrap" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
          'placement': 'top',
          'container': 'body'
        });
      $scope.snComposingPresence = snComposingPresence;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/service.snComposingPresence.js */
angular.module('sn.common.presence').service('snComposingPresence', function(i18n) {
  "use strict";
  var viewing = {};
  var typing = {};
  var allStrings = {};
  var shortStrings = {};
  var typing1 = "{0} is typing",
    typing2 = "{0} and {1} are typing",
    typingMore = "{0}, {1}, and {2} more are typing",
    viewing1 = "{0} is viewing",
    viewing2 = "{0} and {1} are viewing",
    viewingMore = "{0}, {1}, and {2} more are viewing";
  i18n.getMessages(
    [
      typing1,
      typing2,
      typingMore,
      viewing1,
      viewing2,
      viewingMore
    ],
    function(results) {
      typing1 = results[typing1];
      typing2 = results[typing2];
      typingMore = results[typingMore];
      viewing1 = results[viewing1];
      viewing2 = results[viewing2];
      viewingMore = results[viewingMore];
    });

  function set(conversationID, newPresenceValues) {
    if (newPresenceValues.viewing)
      viewing[conversationID] = newPresenceValues.viewing;
    if (newPresenceValues.typing)
      typing[conversationID] = newPresenceValues.typing;
    generateAllString(conversationID, {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    });
    generateShortString(conversationID, {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    });
    return {
      viewing: viewing[conversationID],
      typing: typing[conversationID]
    }
  }

  function get(conversationID) {
    return {
      viewing: viewing[conversationID] || [],
      typing: typing[conversationID] || []
    }
  }

  function generateAllString(conversationID, members) {
    var result = "";
    var typingLength = members.typing.length;
    var viewingLength = members.viewing.length;
    if (typingLength < 4 && viewingLength < 4)
      return "";
    switch (typingLength) {
      case 0:
        break;
      case 1:
        result += i18n.format(typing1, members.typing[0].name);
        break;
      case 2:
        result += i18n.format(typing2, members.typing[0].name, members.typing[1].name);
        break;
      default:
        var allButLastTyper = "";
        for (var i = 0; i < typingLength; i++) {
          if (i < typingLength - 2)
            allButLastTyper += members.typing[i].name + ", ";
          else if (i === typingLength - 2)
            allButLastTyper += members.typing[i].name + ",";
          else
            result += i18n.format(typing2, allButLastTyper, members.typing[i].name);
        }
    }
    if (viewingLength > 0 && typingLength > 0)
      result += "\n\n";
    switch (viewingLength) {
      case 0:
        break;
      case 1:
        result += i18n.format(viewing1, members.viewing[0].name);
        break;
      case 2:
        result += i18n.format(viewing2, members.viewing[0].name, members.viewing[1].name);
        break;
      default:
        var allButLastViewer = "";
        for (var i = 0; i < viewingLength; i++) {
          if (i < viewingLength - 2)
            allButLastViewer += members.viewing[i].name + ", ";
          else if (i === viewingLength - 2)
            allButLastViewer += members.viewing[i].name + ",";
          else
            result += i18n.format(viewing2, allButLastViewer, members.viewing[i].name);
        }
    }
    allStrings[conversationID] = result;
  }

  function generateShortString(conversationID, members) {
    var typingLength = members.typing.length;
    var viewingLength = members.viewing.length;
    var typingString = "",
      viewingString = "";
    var inBetween = " ";
    switch (typingLength) {
      case 0:
        break;
      case 1:
        typingString = i18n.format(typing1, members.typing[0].name);
        break;
      case 2:
        typingString = i18n.format(typing2, members.typing[0].name, members.typing[1].name);
        break;
      case 3:
        typingString = i18n.format(typing2, members.typing[0].name + ", " + members.typing[1].name + ",", members.typing[2].name);
        break;
      default:
        typingString = i18n.format(typingMore, members.typing[0].name, members.typing[1].name, (typingLength - 2));
    }
    if (viewingLength > 0 && typingLength > 0)
      inBetween = ". ";
    switch (viewingLength) {
      case 0:
        break;
      case 1:
        viewingString = i18n.format(viewing1, members.viewing[0].name);
        break;
      case 2:
        viewingString = i18n.format(viewing2, members.viewing[0].name, members.viewing[1].name);
        break;
      case 3:
        viewingString = i18n.format(viewing2, members.viewing[0].name + ", " + members.viewing[1].name + ",", members.viewing[2].name);
        break;
      default:
        viewingString = i18n.format(viewingMore, members.viewing[0].name, members.viewing[1].name, (viewingLength - 2));
    }
    shortStrings[conversationID] = typingString + inBetween + viewingString;
  }

  function getAllString(conversationID) {
    if ((viewing[conversationID] && viewing[conversationID].length > 3) ||
      (typing[conversationID] && typing[conversationID].length > 3))
      return allStrings[conversationID];
    return "";
  }

  function getShortString(conversationID) {
    return shortStrings[conversationID];
  }

  function remove(conversationID) {
    delete viewing[conversationID];
  }
  return {
    set: set,
    get: get,
    generateAllString: generateAllString,
    getAllString: getAllString,
    generateShortString: generateShortString,
    getShortString: getShortString,
    remove: remove
  }
});;;
/*! RESOURCE: /scripts/sn/common/user_profile/js_includes_user_profile.js */
/*! RESOURCE: /scripts/sn/common/user_profile/_module.js */
angular.module("sn.common.user_profile", ['sn.common.ui']);;
/*! RESOURCE: /scripts/sn/common/user_profile/directive.snUserProfile.js */
angular.module('sn.common.user_profile').directive('snUserProfile', function(getTemplateUrl, snCustomEvent, $window, avatarProfilePersister, $timeout, $http) {
  "use strict";
  return {
    replace: true,
    restrict: 'E',
    templateUrl: getTemplateUrl('snUserProfile.xml'),
    scope: {
      profile: "=",
      showDirectMessagePrompt: "="
    },
    link: function(scope) {
      scope.showDirectMessagePromptFn = function() {
        if (scope.showDirectMessagePrompt) {
          var activeUserID = $window.NOW.user_id || "";
          return !(!scope.profile ||
            activeUserID === scope.profile.sysID ||
            (scope.profile.document && activeUserID === scope.profile.document));
        } else {
          return false;
        }
      };
    },
    controller: function($scope, snConnectService) {
      if ($scope.profile && $scope.profile.userID && avatarProfilePersister.getAvatar($scope.profile.userID)) {
        $scope.profile = avatarProfilePersister.getAvatar($scope.profile.userID);
        $scope.$emit("sn-user-profile.ready");
      } else {
        $http.get('/api/now/live/profiles/sys_user.' + $scope.profile.userID).then(function(response) {
          angular.merge($scope.profile, response.data.result);
          avatarProfilePersister.setAvatar($scope.profile.userID, $scope.profile);
          $scope.$emit("sn-user-profile.ready");
        })
      }
      $scope.openDirectMessageConversation = function(evt) {
        if (evt.keyCode === 9)
          return;
        $timeout(function() {
          snConnectService.openWithProfile($scope.profile);
        }, 0, false);
        angular.element('.popover').each(function() {
          angular.element('body').off('click.snUserAvatarPopoverClose');
          angular.element(this).popover('hide');
        });
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/util/js_includes_util.js */
/*! RESOURCE: /scripts/sn/common/util/_module.js */
angular.module('sn.common.util', ['sn.common.auth']);
angular.module('sn.util', ['sn.common.util']);;
/*! RESOURCE: /scripts/sn/common/util/service.dateUtils.js */
angular.module('sn.common.util').factory('dateUtils', function() {
  var dateUtils = {
    SYS_DATE_FORMAT: "yyyy-MM-dd",
    SYS_TIME_FORMAT: "HH:mm:ss",
    SYS_DATE_TIME_FORMAT: "yyyy-MM-dd HH:mm:ss",
    MONTH_NAMES: new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'),
    DAY_NAMES: new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
    LZ: function(x) {
      return (x < 0 || x > 9 ? "" : "0") + x
    },
    isDate: function(val, format) {
      var date = this.getDateFromFormat(val, format);
      if (date == 0) {
        return false;
      }
      return true;
    },
    compareDates: function(date1, dateformat1, date2, dateformat2) {
      var d1 = this.getDateFromFormat(date1, dateformat1);
      var d2 = this.getDateFromFormat(date2, dateformat2);
      if (d1 == 0 || d2 == 0) {
        return -1;
      } else if (d1 > d2) {
        return 1;
      }
      return 0;
    },
    formatDateServer: function(date, format) {
      var ga = new GlideAjax("DateTimeUtils");
      ga.addParam("sysparm_name", "formatCalendarDate");
      var browserOffset = date.getTimezoneOffset() * 60000;
      var utcTime = date.getTime() - browserOffset;
      var userDateTime = utcTime - g_tz_offset;
      ga.addParam("sysparm_value", userDateTime);
      ga.getXMLWait();
      return ga.getAnswer();
    },
    formatDate: function(date, format) {
      if (format.indexOf("z") > 0)
        return this.formatDateServer(date, format);
      format = format + "";
      var result = "";
      var i_format = 0;
      var c = "";
      var token = "";
      var y = date.getYear() + "";
      var M = date.getMonth() + 1;
      var d = date.getDate();
      var E = date.getDay();
      var H = date.getHours();
      var m = date.getMinutes();
      var s = date.getSeconds();
      var yyyy, yy, MMM, MM, dd, hh, h, mm, ss, ampm, HH, H, KK, K, kk, k;
      var value = new Object();
      value["M"] = M;
      value["MM"] = this.LZ(M);
      value["MMM"] = this.MONTH_NAMES[M + 11];
      value["NNN"] = this.MONTH_NAMES[M + 11];
      value["MMMM"] = this.MONTH_NAMES[M - 1];
      value["d"] = d;
      value["dd"] = this.LZ(d);
      value["E"] = this.DAY_NAMES[E + 7];
      value["EE"] = this.DAY_NAMES[E];
      value["H"] = H;
      value["HH"] = this.LZ(H);
      if (format.indexOf('w') != -1) {
        var wk = date.getWeek();
        if (wk >= 52 && M == 1) {
          y = date.getYear();
          y--;
          y = y + "";
        }
        if (wk == 1 && M == 12) {
          y = date.getYear();
          y++;
          y = y + "";
        }
        value["w"] = wk;
        value["ww"] = this.LZ(wk);
      }
      var dayOfWeek = (7 + (E + 1) - (g_first_day_of_week - 1)) % 7;
      if (dayOfWeek == 0)
        dayOfWeek = 7;
      value["D"] = dayOfWeek;
      if (y.length < 4) {
        y = "" + (y - 0 + 1900);
      }
      value["y"] = "" + y;
      value["yyyy"] = y;
      value["yy"] = y.substring(2, 4);
      if (H == 0) {
        value["h"] = 12;
      } else if (H > 12) {
        value["h"] = H - 12;
      } else {
        value["h"] = H;
      }
      value["hh"] = this.LZ(value["h"]);
      if (H > 11) {
        value["K"] = H - 12;
      } else {
        value["K"] = H;
      }
      value["k"] = H + 1;
      value["KK"] = this.LZ(value["K"]);
      value["kk"] = this.LZ(value["k"]);
      if (H > 11) {
        value["a"] = "PM";
      } else {
        value["a"] = "AM";
      }
      value["m"] = m;
      value["mm"] = this.LZ(m);
      value["s"] = s;
      value["ss"] = this.LZ(s);
      while (i_format < format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) && (i_format < format.length)) {
          token += format.charAt(i_format++);
        }
        if (value[token] != null) {
          result = result + value[token];
        } else {
          result = result + token;
        }
      }
      return result;
    },
    _isInteger: function(val) {
      var digits = "1234567890";
      for (var i = 0; i < val.length; i++) {
        if (digits.indexOf(val.charAt(i)) == -1) {
          return false;
        }
      }
      return true;
    },
    _getInt: function(str, i, minlength, maxlength) {
      for (var x = maxlength; x >= minlength; x--) {
        var token = str.substring(i, i + x);
        if (token.length < minlength) {
          return null;
        }
        if (this._isInteger(token)) {
          return token;
        }
      }
      return null;
    },
    getDateFromFormat: function(val, format) {
      val = val + "";
      format = format + "";
      var i_val = 0;
      var i_format = 0;
      var c = "";
      var token = "";
      var token2 = "";
      var x, y;
      var now = new Date();
      var year = now.getYear();
      var month = now.getMonth() + 1;
      var date = 0;
      var hh = now.getHours();
      var mm = now.getMinutes();
      var ss = now.getSeconds();
      var ampm = "";
      var week = false;
      while (i_format < format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) && (i_format < format.length)) {
          token += format.charAt(i_format++);
        }
        if (token == "yyyy" || token == "yy" || token == "y") {
          if (token == "yyyy") {
            x = 4;
            y = 4;
          }
          if (token == "yy") {
            x = 2;
            y = 2;
          }
          if (token == "y") {
            x = 2;
            y = 4;
          }
          year = this._getInt(val, i_val, x, y);
          if (year == null) {
            return 0;
          }
          i_val += year.length;
          if (year.length == 2) {
            if (year > 70) {
              year = 1900 + (year - 0);
            } else {
              year = 2000 + (year - 0);
            }
          }
        } else if (token == "MMM" || token == "NNN") {
          month = 0;
          for (var i = 0; i < this.MONTH_NAMES.length; i++) {
            var month_name = this.MONTH_NAMES[i];
            if (val.substring(i_val, i_val + month_name.length).toLowerCase() == month_name.toLowerCase()) {
              if (token == "MMM" || (token == "NNN" && i > 11)) {
                month = i + 1;
                if (month > 12) {
                  month -= 12;
                }
                i_val += month_name.length;
                break;
              }
            }
          }
          if ((month < 1) || (month > 12)) {
            return 0;
          }
        } else if (token == "EE" || token == "E") {
          for (var i = 0; i < this.DAY_NAMES.length; i++) {
            var day_name = this.DAY_NAMES[i];
            if (val.substring(i_val, i_val + day_name.length).toLowerCase() == day_name.toLowerCase()) {
              if (week) {
                if (i == 0 || i == 7)
                  date += 6;
                else if (i == 2 || i == 9)
                  date += 1;
                else if (i == 3 || i == 10)
                  date += 2;
                else if (i == 4 || i == 11)
                  date += 3;
                else if (i == 5 || i == 12)
                  date += 4;
                else if (i == 6 || i == 13)
                  date += 5;
              }
              i_val += day_name.length;
              break;
            }
          }
        } else if (token == "MM" || token == "M") {
          month = this._getInt(val, i_val, token.length, 2);
          if (month == null || (month < 1) || (month > 12)) {
            return 0;
          }
          i_val += month.length;
        } else if (token == "dd" || token == "d") {
          date = this._getInt(val, i_val, token.length, 2);
          if (date == null || (date < 1) || (date > 31)) {
            return 0;
          }
          i_val += date.length;
        } else if (token == "hh" || token == "h") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 1) || (hh > 12)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "HH" || token == "H") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 0) || (hh > 23)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "KK" || token == "K") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 0) || (hh > 11)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "kk" || token == "k") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 1) || (hh > 24)) {
            return 0;
          }
          i_val += hh.length;
          hh--;
        } else if (token == "mm" || token == "m") {
          mm = this._getInt(val, i_val, token.length, 2);
          if (mm == null || (mm < 0) || (mm > 59)) {
            return 0;
          }
          i_val += mm.length;
        } else if (token == "ss" || token == "s") {
          ss = this._getInt(val, i_val, token.length, 2);
          if (ss == null || (ss < 0) || (ss > 59)) {
            return 0;
          }
          i_val += ss.length;
        } else if (token == "a") {
          if (val.substring(i_val, i_val + 2).toLowerCase() == "am") {
            ampm = "AM";
          } else if (val.substring(i_val, i_val + 2).toLowerCase() == "pm") {
            ampm = "PM";
          } else {
            return 0;
          }
          i_val += 2;
        } else if (token == "w" || token == "ww") {
          var weekNum = this._getInt(val, i_val, token.length, 2);
          week = true;
          if (weekNum != null) {
            var temp = new Date(year, 0, 1, 0, 0, 0);
            temp.setWeek(parseInt(weekNum, 10));
            year = temp.getFullYear();
            month = temp.getMonth() + 1;
            date = temp.getDate();
          }
          weekNum += "";
          i_val += weekNum.length;
        } else if (token == "D") {
          if (week) {
            var day = this._getInt(val, i_val, token.length, 1);
            if ((day == null) || (day <= 0) || (day > 7))
              return 0;
            var temp = new Date(year, month - 1, date, hh, mm, ss);
            var dayOfWeek = temp.getDay();
            day = parseInt(day, 10);
            day = (day + g_first_day_of_week - 1) % 7;
            if (day == 0)
              day = 7;
            day--;
            if (day < dayOfWeek)
              day = 7 - (dayOfWeek - day);
            else
              day -= dayOfWeek;
            if (day > 0) {
              temp.setDate(temp.getDate() + day);
              year = temp.getFullYear();
              month = temp.getMonth() + 1;
              date = temp.getDate();
            }
            i_val++;
          }
        } else if (token == "z")
          i_val += 3;
        else {
          if (val.substring(i_val, i_val + token.length) != token) {
            return 0;
          } else {
            i_val += token.length;
          }
        }
      }
      if (i_val != val.length) {
        return 0;
      }
      if (month == 2) {
        if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
          if (date > 29) {
            return 0;
          }
        } else {
          if (date > 28) {
            return 0;
          }
        }
      }
      if ((month == 4) || (month == 6) || (month == 9) || (month == 11)) {
        if (date > 30) {
          return 0;
        }
      }
      if (hh < 12 && ampm == "PM") {
        hh = hh - 0 + 12;
      } else if (hh > 11 && ampm == "AM") {
        hh -= 12;
      }
      var newdate = new Date(year, month - 1, date, hh, mm, ss);
      return newdate.getTime();
    },
    parseDate: function(val) {
      var preferEuro = (arguments.length == 2) ? arguments[1] : false;
      generalFormats = new Array('y-M-d', 'MMM d, y', 'MMM d,y', 'y-MMM-d', 'd-MMM-y', 'MMM d');
      monthFirst = new Array('M/d/y', 'M-d-y', 'M.d.y', 'MMM-d', 'M/d', 'M-d');
      dateFirst = new Array('d/M/y', 'd-M-y', 'd.M.y', 'd-MMM', 'd/M', 'd-M');
      yearFirst = new Array('yyyyw.F', 'yyw.F');
      var checkList = new Array('generalFormats', preferEuro ? 'dateFirst' : 'monthFirst', preferEuro ? 'monthFirst' : 'dateFirst', 'yearFirst');
      var d = null;
      for (var i = 0; i < checkList.length; i++) {
        var l = window[checkList[i]];
        for (var j = 0; j < l.length; j++) {
          d = this.getDateFromFormat(val, l[j]);
          if (d != 0) {
            return new Date(d);
          }
        }
      }
      return null;
    }
  };
  Date.prototype.getWeek = function() {
    var newYear = new Date(this.getFullYear(), 0, 1);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    day = (day >= 0 ? day : day + 7);
    var dayNum = Math.floor((this.getTime() - newYear.getTime() - (this.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    var weekNum;
    if (day < 4) {
      weekNum = Math.floor((dayNum + day - 1) / 7) + 1;
      if (weekNum > 52)
        weekNum = this._checkNextYear(weekNum);
      return weekNum;
    }
    weekNum = Math.floor((dayNum + day - 1) / 7);
    if (weekNum < 1)
      weekNum = this._lastWeekOfYear();
    else if (weekNum > 52)
      weekNum = this._checkNextYear(weekNum);
    return weekNum;
  };
  Date.prototype._lastWeekOfYear = function() {
    var newYear = new Date(this.getFullYear() - 1, 0, 1);
    var endOfYear = new Date(this.getFullYear() - 1, 11, 31);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    var dayNum = Math.floor((endOfYear.getTime() - newYear.getTime() - (endOfYear.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    return day < 4 ? Math.floor((dayNum + day - 1) / 7) + 1 : Math.floor((dayNum + day - 1) / 7);
  };
  Date.prototype._checkNextYear = function() {
    var nYear = new Date(this.getFullYear() + 1, 0, 1);
    var nDay = nYear.getDay() - (g_first_day_of_week - 1);
    nDay = nDay >= 0 ? nDay : nDay + 7;
    return nDay < 4 ? 1 : 53;
  };
  Date.prototype.setWeek = function(weekNum) {
    weekNum--;
    var startOfYear = new Date(this.getFullYear(), 0, 1);
    var day = startOfYear.getDay() - (g_first_day_of_week - 1);
    if (day > 0 && day < 4) {
      this.setFullYear(startOfYear.getFullYear() - 1);
      this.setDate(31 - day + 1);
      this.setMonth(11);
    } else if (day > 3)
      this.setDate(startOfYear.getDate() + (7 - day));
    this.setDate(this.getDate() + (7 * weekNum));
  };
  return dateUtils;
});
/*! RESOURCE: /scripts/sn/common/util/service.debounceFn.js */
angular.module("sn.common.util").service("debounceFn", function() {
  "use strict";

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
  return {
    debounce: debounce
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.unwrappedHTTPPromise.js */
angular.module('sn.common.util').factory("unwrappedHTTPPromise", function($q) {
  "use strict";

  function isGenericPromise(promise) {
    return (typeof promise.then === "function" &&
      promise.success === undefined &&
      promise.error === undefined);
  }
  return function(httpPromise) {
    if (isGenericPromise(httpPromise))
      return httpPromise;
    var deferred = $q.defer();
    httpPromise.success(function(data) {
      deferred.resolve(data);
    }).error(function(data, status) {
      deferred.reject({
        data: data,
        status: status
      })
    });
    return deferred.promise;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.urlTools.js */
angular.module('sn.common.util').constant('angularProcessorUrl', 'angular.do?sysparm_type=');
angular.module('sn.common.util').factory("urlTools", function(getTemplateUrl, angularProcessorUrl) {
  "use strict";

  function getPartialURL(name, parameters) {
    var url = getTemplateUrl(name);
    if (parameters) {
      if (typeof parameters !== 'string') {
        parameters = encodeURIParameters(parameters);
      }
      if (parameters.length) {
        url += "&" + parameters;
      }
    }
    if (window.NOW && window.NOW.ng_cache_defeat)
      url += "&t=" + new Date().getTime();
    return url;
  }

  function getURL(name, parameters) {
    if (parameters && typeof parameters === 'object')
      return urlFor(name, parameters);
    var url = angularProcessorUrl;
    url += name;
    if (parameters)
      url += "&" + parameters;
    return url;
  }

  function urlFor(route, parameters) {
    var p = encodeURIParameters(parameters);
    return angularProcessorUrl + route + (p.length ? '&' + p : '');
  }

  function getPropertyURL(name) {
    var url = angularProcessorUrl + "get_property&name=" + name;
    url += "&t=" + new Date().getTime();
    return url;
  }

  function encodeURIParameters(parameters) {
    var s = [];
    for (var parameter in parameters) {
      if (parameters.hasOwnProperty(parameter)) {
        var key = encodeURIComponent(parameter);
        var value = parameters[parameter] ? encodeURIComponent(parameters[parameter]) : '';
        s.push(key + "=" + value);
      }
    }
    return s.join('&');
  }

  function parseQueryString(qs) {
    qs = qs || '';
    if (qs.charAt(0) === '?') {
      qs = qs.substr(1);
    }
    var a = qs.split('&');
    if (a === "") {
      return {};
    }
    if (a && a[0].indexOf('http') != -1)
      a[0] = a[0].split("?")[1];
    var b = {};
    for (var i = 0; i < a.length; i++) {
      var p = a[i].split('=', 2);
      if (p.length == 1) {
        b[p[0]] = "";
      } else {
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
    }
    return b;
  }
  return {
    getPartialURL: getPartialURL,
    getURL: getURL,
    urlFor: urlFor,
    getPropertyURL: getPropertyURL,
    encodeURIParameters: encodeURIParameters,
    parseQueryString: parseQueryString
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.getTemplateUrl.js */
angular.module('sn.common.util').provider('getTemplateUrl', function(angularProcessorUrl) {
  'use strict';
  var _handlerId = 0;
  var _handlers = {};
  this.registerHandler = function(handler) {
    var registeredId = _handlerId;
    _handlers[_handlerId] = handler;
    _handlerId++;
    return function() {
      delete _handlers[registeredId];
    };
  };
  this.$get = function() {
    return getTemplateUrl;
  };

  function getTemplateUrl(templatePath) {
    if (_handlerId > 0) {
      var path;
      var handled = false;
      angular.forEach(_handlers, function(handler) {
        if (!handled) {
          var handlerPath = handler(templatePath);
          if (typeof handlerPath !== 'undefined') {
            path = handlerPath;
            handled = true;
          }
        }
      });
      if (handled) {
        return path;
      }
    }
    return angularProcessorUrl + 'get_partial&name=' + templatePath;
  }
});;
/*! RESOURCE: /scripts/sn/common/util/service.snTabActivity.js */
angular.module("sn.common.util").service("snTabActivity", function($window, $timeout, $rootElement, $document) {
  "use strict";
  var activeEvents = ["keydown", "DOMMouseScroll", "mousewheel", "mousedown", "touchstart", "mousemove", "mouseenter", "input", "focus", "scroll"],
    defaultIdle = 75000,
    isPrimary = true,
    idleTime = 0,
    isVisible = true,
    idleTimeout = void(0),
    pageIdleTimeout = void(0),
    hasActed = false,
    appName = $rootElement.attr('ng-app') || "",
    storageKey = "sn.tabs." + appName + ".activeTab";
  var callbacks = {
    "tab.primary": [],
    "tab.secondary": [],
    "activity.active": [],
    "activity.idle": [{
      delay: defaultIdle,
      cb: function() {}
    }]
  };
  $window.tabGUID = $window.tabGUID || createGUID();

  function getActiveEvents() {
    return activeEvents.join(".snTabActivity ") + ".snTabActivity";
  }

  function setAppName(an) {
    appName = an;
    storageKey = "sn.tabs." + appName + ".activeTab";
    makePrimary(true);
  }

  function createGUID(l) {
    l = l || 32;
    var strResult = '';
    while (strResult.length < l)
      strResult += (((1 + Math.random() + new Date().getTime()) * 0x10000) | 0).toString(16).substring(1);
    return strResult.substr(0, l);
  }

  function ngObjectIndexOf(arr, obj) {
    for (var i = 0, len = arr.length; i < len; i++)
      if (angular.equals(arr[i], obj))
        return i;
    return -1;
  }
  var detectedApi,
    apis = [{
      eventName: 'visibilitychange',
      propertyName: 'hidden'
    }, {
      eventName: 'mozvisibilitychange',
      propertyName: 'mozHidden'
    }, {
      eventName: 'msvisibilitychange',
      propertyName: 'msHidden'
    }, {
      eventName: 'webkitvisibilitychange',
      propertyName: 'webkitHidden'
    }];
  apis.some(function(api) {
    if (angular.isDefined($document[0][api.propertyName])) {
      detectedApi = api;
      return true;
    }
  });
  if (detectedApi)
    $document.on(detectedApi.eventName, function() {
      if (!$document[0][detectedApi.propertyName]) {
        makePrimary();
        isVisible = true;
      } else {
        if (!idleTimeout && !idleTime)
          waitForIdle(0);
        isVisible = false;
      }
    });
  angular.element($window).on({
    "mouseleave": function(e) {
      var destination = angular.isUndefined(e.toElement) ? e.relatedTarget : e.toElement;
      if (destination === null && $document[0].hasFocus()) {
        waitForIdle(0);
      }
    },
    "storage": function(e) {
      if (e.originalEvent.key !== storageKey)
        return;
      if ($window.localStorage.getItem(storageKey) !== $window.tabGUID)
        makeSecondary();
    }
  });

  function waitForIdle(index, delayOffset) {
    var callback = callbacks['activity.idle'][index];
    var numCallbacks = callbacks['activity.idle'].length;
    delayOffset = delayOffset || callback.delay;
    angular.element($window).off(getActiveEvents());
    angular.element($window).one(getActiveEvents(), setActive);
    if (index >= numCallbacks)
      return;
    if (idleTimeout)
      $timeout.cancel(idleTimeout);
    idleTimeout = $timeout(function() {
      idleTime = callback.delay;
      callback.cb();
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
      angular.element($window).off(getActiveEvents());
      angular.element($window).one(getActiveEvents(), setActive);
      for (var i = index + 1; i < numCallbacks; i++) {
        var nextDelay = callbacks['activity.idle'][i].delay;
        if (nextDelay <= callback.delay)
          callbacks['activity.idle'][i].cb();
        else {
          waitForIdle(i, nextDelay - callback.delay);
          break;
        }
      }
    }, delayOffset, false);
  }

  function setActive() {
    angular.element($window).off(getActiveEvents());
    if (idleTimeout) {
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
    }
    var activeCallbacks = callbacks['activity.active'];
    activeCallbacks.some(function(callback) {
      if (callback.delay <= idleTime)
        callback.cb();
      else
        return true;
    });
    idleTime = 0;
    makePrimary();
    if (pageIdleTimeout) {
      $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = void(0);
    }
    var minDelay = callbacks['activity.idle'][0].delay;
    hasActed = false;
    if (!pageIdleTimeout)
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
    listenForActivity();
  }

  function pageIdleHandler() {
    if (idleTimeout)
      return;
    var minDelay = callbacks['activity.idle'][0].delay;
    if (hasActed) {
      hasActed = false;
      if (pageIdleTimeout)
        $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
      listenForActivity();
      return;
    }
    var delayOffset = minDelay;
    if (callbacks['activity.idle'].length > 1)
      delayOffset = callbacks['activity.idle'][1].delay - minDelay;
    idleTime = minDelay;
    callbacks['activity.idle'][0].cb();
    waitForIdle(1, delayOffset);
    pageIdleTimeout = void(0);
  }

  function listenForActivity() {
    angular.element($window).off(getActiveEvents());
    angular.element($window).one(getActiveEvents(), onActivity);
    angular.element("#gsft_main").on("load.snTabActivity", function() {
      var src = angular.element(this).attr('src');
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = this.contentWindow ? this.contentWindow : this.contentDocument.defaultView;
        angular.element(iframeWindow).off(getActiveEvents());
        angular.element(iframeWindow).one(getActiveEvents(), onActivity);
      }
    });
    angular.element('iframe').each(function(idx, iframe) {
      var src = angular.element(iframe).attr('src');
      if (!src)
        return;
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = iframe.contentWindow ? iframe.contentWindow : iframe.contentDocument.defaultView;
        angular.element(iframeWindow).off(getActiveEvents());
        angular.element(iframeWindow).one(getActiveEvents(), onActivity);
      }
    });
  }

  function onActivity() {
    hasActed = true;
    makePrimary();
  }

  function makePrimary(initial) {
    var oldGuid = $window.localStorage.getItem(storageKey);
    isPrimary = true;
    isVisible = true;
    $timeout.cancel(idleTimeout);
    idleTimeout = void(0);
    if (canUseStorage() && oldGuid !== $window.tabGUID && !initial)
      for (var i = 0, len = callbacks["tab.primary"].length; i < len; i++)
        callbacks["tab.primary"][i].cb();
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
    } catch (ignored) {}
    if (idleTime && $document[0].hasFocus())
      setActive();
  }

  function makeSecondary() {
    isPrimary = false;
    isVisible = false;
    for (var i = 0, len = callbacks["tab.secondary"].length; i < len; i++)
      callbacks["tab.secondary"][i].cb();
  }

  function registerCallback(event, callback, scope) {
    var cbObject = angular.isObject(callback) ? callback : {
      delay: defaultIdle,
      cb: callback
    };
    if (callbacks[event]) {
      callbacks[event].push(cbObject);
      callbacks[event].sort(function(a, b) {
        return a.delay - b.delay;
      })
    }

    function destroyCallback() {
      if (callbacks[event]) {
        var pos = ngObjectIndexOf(callbacks[event], cbObject);
        if (pos !== -1)
          callbacks[event].splice(pos, 1);
      }
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyCallback();
      });
    return destroyCallback;
  }

  function registerIdleCallback(options, onIdle, onReturn, scope) {
    var delay = options,
      onIdleDestroy,
      onReturnDestroy;
    if (angular.isObject(options)) {
      delay = options.delay;
      onIdle = options.onIdle || onIdle;
      onReturn = options.onReturn || onReturn;
      scope = options.scope || scope;
    }
    if (angular.isFunction(onIdle))
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: onIdle
      });
    else if (angular.isFunction(onReturn)) {
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: function() {}
      });
    }
    if (angular.isFunction(onReturn))
      onReturnDestroy = registerCallback("activity.active", {
        delay: delay,
        cb: onReturn
      });

    function destroyAll() {
      if (angular.isFunction(onIdleDestroy))
        onIdleDestroy();
      if (angular.isFunction(onReturnDestroy))
        onReturnDestroy();
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyAll();
      });
    return destroyAll;
  }

  function canUseStorage() {
    var canWe = false;
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
      canWe = true;
    } catch (ignored) {}
    return canWe;
  }
  makePrimary(true);
  listenForActivity();
  pageIdleTimeout = $timeout(pageIdleHandler, defaultIdle, false);
  return {
    on: registerCallback,
    onIdle: registerIdleCallback,
    setAppName: setAppName,
    get isPrimary() {
      return isPrimary;
    },
    get isIdle() {
      return idleTime > 0;
    },
    get idleTime() {
      return idleTime;
    },
    get isVisible() {
      return isVisible;
    },
    get appName() {
      return appName;
    },
    get defaultIdleTime() {
      return defaultIdle
    },
    isActive: function() {
      return this.idleTime < this.defaultIdleTime && this.isVisible;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.ArraySynchronizer.js */
angular.module("sn.common.util").factory("ArraySynchronizer", function() {
  'use strict';

  function ArraySynchronizer() {}

  function index(key, arr) {
    var result = {};
    var keys = [];
    result.orderedKeys = keys;
    angular.forEach(arr, function(item) {
      var keyValue = item[key];
      result[keyValue] = item;
      keys.push(keyValue);
    });
    return result;
  }

  function sortByKeyAndModel(arr, key, model) {
    arr.sort(function(a, b) {
      var aIndex = model.indexOf(a[key]);
      var bIndex = model.indexOf(b[key]);
      if (aIndex > bIndex)
        return 1;
      else if (aIndex < bIndex)
        return -1;
      return 0;
    });
  }
  ArraySynchronizer.prototype = {
    add: function(syncField, dest, source, end) {
      end = end || "bottom";
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1) {
          if (end === "bottom") {
            dest.push(sourceIndex[key]);
          } else {
            dest.unshift(sourceIndex[key]);
          }
        }
      });
    },
    synchronize: function(syncField, dest, source, deepKeySyncArray) {
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      deepKeySyncArray = (typeof deepKeySyncArray === "undefined") ? [] : deepKeySyncArray;
      for (var i = destIndex.orderedKeys.length - 1; i >= 0; i--) {
        var key = destIndex.orderedKeys[i];
        if (sourceIndex.orderedKeys.indexOf(key) === -1) {
          destIndex.orderedKeys.splice(i, 1);
          dest.splice(i, 1);
        }
        if (deepKeySyncArray.length > 0) {
          angular.forEach(deepKeySyncArray, function(deepKey) {
            if (sourceIndex[key] && destIndex[key][deepKey] !== sourceIndex[key][deepKey]) {
              destIndex[key][deepKey] = sourceIndex[key][deepKey];
            }
          });
        }
      }
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1)
          dest.push(sourceIndex[key]);
      });
      sortByKeyAndModel(dest, syncField, sourceIndex.orderedKeys);
    }
  };
  return ArraySynchronizer;
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBindOnce.js */
angular.module("sn.common.util").directive("snBindOnce", function($sanitize) {
  "use strict";
  return {
    restrict: "A",
    link: function(scope, element, attrs) {
      var value = scope.$eval(attrs.snBindOnce);
      var sanitizedValue = $sanitize(value);
      element.append(sanitizedValue);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/util/directive.snCloak.js */
angular.module("sn.common.util").directive("snCloak", function() {
  "use strict";
  return {
    restrict: "A",
    compile: function(element, attr) {
      return function() {
        attr.$set('snCloak', undefined);
        element.removeClass('sn-cloak');
      }
    }
  };
});
/*! RESOURCE: /scripts/sn/common/util/service.md5.js */
angular.module('sn.common.util').factory('md5', function() {
  'use strict';
  var md5cycle = function(x, k) {
    var a = x[0],
      b = x[1],
      c = x[2],
      d = x[3];
    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);
    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);
    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);
    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  };
  var cmn = function(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32((a << s) | (a >>> (32 - s)), b);
  };
  var ff = function(a, b, c, d, x, s, t) {
    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
  };
  var gg = function(a, b, c, d, x, s, t) {
    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
  };
  var hh = function(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  };
  var ii = function(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
  };
  var md51 = function(s) {
    var txt = '';
    var n = s.length,
      state = [1732584193, -271733879, -1732584194, 271733878],
      i;
    for (i = 64; i <= s.length; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++)
      tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
    tail[i >> 2] |= 0x80 << ((i % 4) << 3);
    if (i > 55) {
      md5cycle(state, tail);
      for (i = 0; i < 16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  };
  var md5blk = function(s) {
    var md5blks = [],
      i;
    for (i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) +
        (s.charCodeAt(i + 1) << 8) +
        (s.charCodeAt(i + 2) << 16) +
        (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  };
  var hex_chr = '0123456789abcdef'.split('');
  var rhex = function(n) {
    var s = '',
      j = 0;
    for (; j < 4; j++)
      s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] +
      hex_chr[(n >> (j * 8)) & 0x0F];
    return s;
  };
  var hex = function(x) {
    for (var i = 0; i < x.length; i++)
      x[i] = rhex(x[i]);
    return x.join('');
  };
  var add32 = function(a, b) {
    return (a + b) & 0xFFFFFFFF;
  };
  return function(s) {
    return hex(md51(s));
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.priorityQueue.js */
angular.module('sn.common.util').factory('priorityQueue', function() {
  'use strict';
  return function(comparator) {
    var items = [];
    var compare = comparator || function(a, b) {
      return a - b;
    };
    var swap = function(a, b) {
      var temp = items[a];
      items[a] = items[b];
      items[b] = temp;
    };
    var bubbleUp = function(pos) {
      var parent;
      while (pos > 0) {
        parent = (pos - 1) >> 1;
        if (compare(items[pos], items[parent]) >= 0)
          break;
        swap(parent, pos);
        pos = parent;
      }
    };
    var bubbleDown = function(pos) {
      var left, right, min, last = items.length - 1;
      while (true) {
        left = (pos << 1) + 1;
        right = left + 1;
        min = pos;
        if (left <= last && compare(items[left], items[min]) < 0)
          min = left;
        if (right <= last && compare(items[right], items[min]) < 0)
          min = right;
        if (min === pos)
          break;
        swap(min, pos);
        pos = min;
      }
    };
    return {
      add: function(item) {
        items.push(item);
        bubbleUp(items.length - 1);
      },
      poll: function() {
        var first = items[0],
          last = items.pop();
        if (items.length > 0) {
          items[0] = last;
          bubbleDown(0);
        }
        return first;
      },
      peek: function() {
        return items[0];
      },
      clear: function() {
        items = [];
      },
      inspect: function() {
        return angular.toJson(items, true);
      },
      get size() {
        return items.length;
      },
      get all() {
        return items;
      },
      set comparator(fn) {
        compare = fn;
      }
    };
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snResource.js */
angular.module('sn.common.util').factory('snResource', function($http, $q, priorityQueue, md5) {
  'use strict';
  var methods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'jsonp', 'trace'],
    queue = priorityQueue(function(a, b) {
      return a.timestamp - b.timestamp;
    }),
    resource = {},
    pendingRequests = [],
    inFlightRequests = [];
  return function() {
    var requestInterceptors = $http.defaults.transformRequest,
      responseInterceptors = $http.defaults.transformResponse;
    var next = function() {
      var request = queue.peek();
      pendingRequests.shift();
      inFlightRequests.push(request.hash);
      $http(request.config).then(function(response) {
        request.deferred.resolve(response);
      }, function(reason) {
        request.deferred.reject(reason);
      }).finally(function() {
        queue.poll();
        inFlightRequests.shift();
        if (queue.size > 0)
          next();
      });
    };
    angular.forEach(methods, function(method) {
      resource[method] = function(url, data) {
        var deferredRequest = $q.defer(),
          promise = deferredRequest.promise,
          deferredAbort = $q.defer(),
          config = {
            method: method,
            url: url,
            data: data,
            transformRequest: requestInterceptors,
            transformResponse: responseInterceptors,
            timeout: deferredAbort.promise
          },
          hash = md5(JSON.stringify(config));
        pendingRequests.push(hash);
        queue.add({
          config: config,
          deferred: deferredRequest,
          timestamp: Date.now(),
          hash: hash
        });
        if (queue.size === 1)
          next();
        promise.abort = function() {
          deferredAbort.resolve('Request cancelled');
        };
        return promise;
      };
    });
    resource.addRequestInterceptor = function(fn) {
      requestInterceptors = requestInterceptors.concat([fn]);
    };
    resource.addResponseInterceptor = function(fn) {
      responseInterceptors = responseInterceptors.concat([fn]);
    };
    resource.queueSize = function() {
      return queue.size;
    };
    resource.queuedRequests = function() {
      return queue.all;
    };
    return resource;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snConnect.js */
angular.module("sn.common.util").service("snConnectService", function($http, snCustomEvent) {
  "use strict";
  var connectPaths = ["/$c.do", "/$chat.do"];

  function canOpenInFrameset() {
    return window.top.NOW.collaborationFrameset;
  }

  function isInConnect() {
    var parentPath = getParentPath();
    return connectPaths.some(function(path) {
      return parentPath == path;
    });
  }

  function getParentPath() {
    try {
      return window.top.location.pathname;
    } catch (IGNORED) {
      return "";
    }
  }

  function openWithProfile(profile) {
    if (isInConnect() || canOpenInFrameset())
      snCustomEvent.fireTop('chat:open_conversation', profile);
    else
      window.open("$c.do#/with/" + profile.sys_id, "_blank");
  }
  return {
    openWithProfile: openWithProfile
  }
});;
/*! RESOURCE: /scripts/sn/common/util/snPolyfill.js */
(function() {
  "use strict";
  polyfill(String.prototype, 'startsWith', function(prefix) {
    return this.indexOf(prefix) === 0;
  });
  polyfill(String.prototype, 'endsWith', function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  });
  polyfill(Number, 'isNaN', function(value) {
    return value !== value;
  });
  polyfill(window, 'btoa', function(input) {
    var str = String(input);
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    for (
      var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3 / 4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  function polyfill(obj, slot, fn) {
    if (obj[slot] === void(0)) {
      obj[slot] = fn;
    }
  }
  window.console = window.console || {
    log: function() {}
  };
})();;
/*! RESOURCE: /scripts/sn/common/util/directive.snFocus.js */
angular.module('sn.common.util').directive('snFocus', function($timeout) {
  'use strict';
  return function(scope, element, attrs) {
    scope.$watch(attrs.snFocus, function(value) {
      if (value !== true)
        return;
      $timeout(function() {
        element[0].focus();
      });
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snResizeHeight.js */
angular.module('sn.common.util').directive('snResizeHeight', function($timeout) {
  "use strict";
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      var typographyStyles = [
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
      ];
      var maxHeight = parseInt(elem.css('max-height'), 10) || 0;
      var offset = 0;
      if (elem.css('box-sizing') === 'border-box' || elem.css('-moz-box-sizing') === 'border-box' || elem.css('-webkit-box-sizing') === 'border-box')
        offset = elem.outerHeight() - elem.height();
      var styles = {};
      angular.forEach(typographyStyles, function(val) {
        styles[val] = elem.css(val);
      });
      var $clone = angular.element('<textarea rows="1" tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"></textarea>');
      $clone.css(styles);
      $timeout(function() {
        angular.element(document.body).append($clone);
        if (elem[0].value) {
          reSize();
        }
      }, 0, false);

      function reSize() {
        if (!isVisible(elem[0]) || !setWidth())
          return;
        if (!elem[0].value && attrs['placeholder'])
          $clone[0].value = attrs['placeholder'] || '';
        else
          $clone[0].value = elem[0].value;
        $clone[0].scrollTop = 0;
        $clone[0].scrollTop = 9e4;
        var newHeight = $clone[0].scrollTop;
        if (maxHeight && newHeight > maxHeight) {
          newHeight = maxHeight;
          elem[0].style.overflow = "auto";
        } else
          elem[0].style.overflow = "hidden";
        newHeight += offset;
        elem[0].style.height = newHeight + "px";
      }
      var style, bordersAndPadding;

      function setWidth() {
        style = style || window.getComputedStyle(elem[0], null);
        var width = elem[0].getBoundingClientRect().width;
        if (width === 0 || typeof width !== 'number')
          width = parseInt(style.width, 10);
        if (width === 0 || typeof width !== 'number') {
          if (style.width.length && style.width[style.width.length - 1] === '%') {
            $timeout(reSize, 0, false);
            return false;
          }
          width = parseInt(style.width, 10);
        }
        if (!bordersAndPadding) {
          bordersAndPadding = ['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'].reduce(function(acc, val) {
            return acc + parseInt(style[val], 10);
          }, 0);
        }
        $clone[0].style.width = (width - bordersAndPadding) + 'px';
        return true;
      }
      scope.$watch(
        function() {
          return elem[0].value
        },
        function watchBinding(newValue, oldValue) {
          if (newValue === oldValue)
            return;
          reSize();
        }
      );
      elem.on('input.resize', reSize);
      if (attrs['snResizeHeight'] == "trim") {
        elem.on('blur', function() {
          elem.val(elem.val().trim());
          reSize();
        });
      }
      scope.$on('$destroy', function() {
        $clone.remove();
      });

      function isVisible(elem) {
        return !!elem.offsetParent;
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBlurOnEnter.js */
angular.module('sn.common.util').directive('snBlurOnEnter', function() {
  'use strict';
  return function(scope, element) {
    element.bind("keydown keypress", function(event) {
      if (event.which !== 13)
        return;
      element.blur();
      event.preventDefault();
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snStickyHeaders.js */
angular.module('sn.common.util').directive('snStickyHeaders', function() {
  "use strict";
  return {
    restrict: 'A',
    transclude: false,
    replace: false,
    link: function(scope, element, attrs) {
      element.addClass('sticky-headers');
      var containers;
      var scrollContainer = element.find('[sn-sticky-scroll-container]');
      scrollContainer.addClass('sticky-scroll-container');

      function refreshHeaders() {
        if (attrs.snStickyHeaders !== 'false') {
          angular.forEach(containers, function(container) {
            var stickyContainer = angular.element(container);
            var stickyHeader = stickyContainer.find('[sn-sticky-header]');
            var stickyOffset = stickyContainer.position().top + stickyContainer.outerHeight();
            stickyContainer.addClass('sticky-container');
            if (stickyOffset < stickyContainer.outerHeight() && stickyOffset > -stickyHeader.outerHeight()) {
              stickyContainer.css('padding-top', stickyHeader.outerHeight());
              stickyHeader.css('width', stickyHeader.outerWidth());
              stickyHeader.removeClass('sticky-header-disabled').addClass('sticky-header-enabled');
            } else {
              stickyContainer.css('padding-top', '');
              stickyHeader.css('width', '');
              stickyHeader.removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
            }
          });
        } else {
          element.find('[sn-sticky-container]').removeClass('sticky-container');
          element.find('[sn-sticky-container]').css('padding-top', '');
          element.find('[sn-sticky-header]').css('width', '');
          element.find('[sn-sticky-header]').removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
        }
      }
      scope.$watch(function() {
        scrollContainer.find('[sn-sticky-header]').addClass('sticky-header');
        containers = element.find('[sn-sticky-container]');
        return attrs.snStickyHeaders;
      }, refreshHeaders);
      scope.$watch(function() {
        return scrollContainer[0].scrollHeight;
      }, refreshHeaders);
      scrollContainer.on('scroll', refreshHeaders);
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/ui/js_includes_ui.js */
/*! RESOURCE: /scripts/sn/common/ui/_module.js */
angular.module('sn.common.ui', ['sn.common.messaging']);;
/*! RESOURCE: /scripts/sn/common/ui/popover/js_includes_ui_popover.js */
/*! RESOURCE: /scripts/sn/common/ui/popover/_module.js */
angular.module('sn.common.ui.popover', []);;
/*! RESOURCE: /scripts/sn/common/ui/popover/directive.snBindPopoverSelection.js */
angular.module('sn.common.ui.popover').directive('snBindPopoverSelection', function(snCustomEvent) {
  "use strict";
  return {
    restrict: "A",
    controller: function($scope, $element, $attrs, snCustomEvent) {
      snCustomEvent.observe('list.record_select', recordSelectDataHandler);

      function recordSelectDataHandler(data, event) {
        if (!data || !event)
          return;
        event.stopPropagation();
        var ref = ($scope.field) ? $scope.field.ref : $attrs.ref;
        if (data.ref === ref) {
          if (window.g_form) {
            if ($attrs.addOption) {
              addGlideListChoice('select_0' + $attrs.ref, data.value, data.displayValue);
            } else {
              var fieldValue = typeof $attrs.ref === 'undefined' ? data.ref : $attrs.ref;
              window.g_form._setValue(fieldValue, data.value, data.displayValue);
              clearDerivedFields(data.value);
            }
          }
          if ($scope.field) {
            $scope.field.value = data.value;
            $scope.field.displayValue = data.displayValue;
          }
        }
      }

      function clearDerivedFields(value) {
        if (window.DerivedFields) {
          var df = new DerivedFields($scope.field ? $scope.field.ref : $attrs.ref);
          df.clearRelated();
          df.updateRelated(value);
        }
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/popover/directive.snComplexPopover.js */
angular.module('sn.common.ui.popover').directive('snComplexPopover', function(getTemplateUrl, $q, $http, $templateCache, $compile, $timeout) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    templateUrl: function(elem, attrs) {
      return getTemplateUrl(attrs.buttonTemplate);
    },
    controller: function($scope, $element, $attrs, $q, $document, snCustomEvent, snComplexPopoverService) {
      $scope.type = $attrs.complexPopoverType || "complex_popover";
      if ($scope.closeEvent) {
        snCustomEvent.observe($scope.closeEvent, destroyPopover);
        $scope.$on($scope.closeEvent, destroyPopover);
      }
      $scope.$parent.$on('$destroy', destroyPopover);
      var newScope;
      var open;
      var popover;
      var content;
      var popoverDefaults = {
        container: 'body',
        html: true,
        placement: 'auto',
        trigger: 'manual',
        template: '<div class="complex_popover popover" role="tooltip"><div class="arrow"></div><div class="popover-content"></div></div>'
      };
      var popoverConfig = angular.extend(popoverDefaults, $scope.popoverConfig);
      $scope.loading = false;
      $scope.initialized = false;
      $scope.togglePopover = function(event) {
        if (!$scope.initialized) {
          showPopover(event);
        } else {
          destroyPopover();
        }
      };

      function showPopover(e) {
        if ($scope.loading)
          return;
        $scope.$toggleButton = angular.element(e.target);
        $scope.loading = true;
        $scope.$emit('list.toggleLoadingState', true);
        _getTemplate()
          .then(_insertTemplate)
          .then(_createPopover)
          .then(_bindHtml)
          .then(function() {
            $scope.loading = false;
            $scope.initialized = true;
            if (!$scope.loadEvent)
              _openPopover();
          });
      }

      function destroyPopover() {
        if (!newScope)
          return;
        $scope.$toggleButton.on('hidden.bs.popover', function() {
          open = false;
          $scope.$toggleButton.data('bs.popover').$element.removeData('bs.popover').off('.popover');
          $scope.$toggleButton = null;
          snCustomEvent.fire('hidden.complexpopover.' + $scope.ref);
        });
        $scope.$toggleButton.popover('hide');
        snCustomEvent.fire('hide.complexpopover.' + $scope.ref, $scope.$toggleButton);
        newScope.$broadcast('$destroy');
        newScope.$destroy();
        newScope = null;
        $scope.initialized = false;
        angular.element('html').off('click', complexHtmlHandler);
      }

      function _getTemplate() {
        return snComplexPopoverService.getTemplate(getTemplateUrl($attrs.template));
      }

      function _createPopover() {
        $scope.$toggleButton.popover(popoverConfig);
        return $q.when(true);
      }

      function _insertTemplate(response) {
        newScope = $scope.$new();
        if ($scope.loadEvent)
          newScope.$on($scope.loadEvent, _openPopover);
        content = $compile(response.data)(newScope);
        popoverConfig.content = content;
        newScope.open = true;
        snCustomEvent.fire('inserted.complexpopover.' + $scope.ref, $scope.$toggleButton);
        return $q.when(true);
      }

      function _bindHtml() {
        angular.element('html').on('click', complexHtmlHandler);
        return $q.when(true);
      }

      function complexHtmlHandler(e) {
        var parentComplexPopoverScope = angular.element(e.target).parents('.popover-content').children().scope();
        if (parentComplexPopoverScope && (parentComplexPopoverScope.type = "complex_popover") && $scope.type === "complex_popover")
          return;
        if (angular.element(e.target).parents('html').length === 0)
          return;
        if ($scope.initialized && !$scope.loading && !$scope.$toggleButton.is(e.target) && content.parents('.popover').has(angular.element(e.target)).length === 0) {
          e.preventDefault();
          e.stopPropagation();
          destroyPopover(e);
        }
      }

      function _openPopover() {
        if (open)
          return;
        open = true;
        $timeout(function() {
          $scope.$toggleButton.popover('show');
          snCustomEvent.fire('show.complexpopover.' + $scope.ref, $scope.$toggleButton);
          $scope.$toggleButton.on('shown.bs.popover', function() {
            snCustomEvent.fire('shown.complexpopover.' + $scope.ref, $scope.$toggleButton);
          });
        }, 0);
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/popover/service.snComplexPopoverService.js */
angular.module('sn.common.ui.popover').service('snComplexPopoverService', function($http, $q, $templateCache) {
  "use strict";
  return {
    getTemplate: getTemplate
  };

  function getTemplate(template) {
    return $http.get(template, {
      cache: $templateCache
    });
  }
});;;
/*! RESOURCE: /scripts/sn/common/ui/directive.snConfirmModal.js */
angular.module('sn.common.ui').directive('snConfirmModal', function(getTemplateUrl) {
  return {
    templateUrl: getTemplateUrl('sn_confirm_modal.xml'),
    restrict: 'E',
    replace: true,
    transclude: true,
    scope: {
      config: '=?',
      modalName: '@',
      title: '@?',
      message: '@?',
      cancelButton: '@?',
      okButton: '@?',
      alertButton: '@?',
      cancel: '&?',
      ok: '&?',
      alert: '&?'
    },
    link: function(scope, element) {
      element.find('.modal').remove();
    },
    controller: function($scope, $rootScope) {
      $scope.config = $scope.config || {};

      function Button(fn, text) {
        return {
          fn: fn,
          text: text
        }
      }
      var buttons = {
        'cancelButton': new Button('cancel', 'Cancel'),
        'okButton': new Button('ok', 'OK'),
        'alertButton': new Button('alert', 'Close'),
        getText: function(type) {
          var button = this[type];
          if (button && $scope.get(button.fn))
            return button.text;
        }
      };
      $scope.get = function(type) {
        if ($scope.config[type])
          return $scope.config[type];
        if (!$scope[type]) {
          var text = buttons.getText(type);
          if (text)
            return $scope.config[type] = text;
        }
        return $scope.config[type] = $scope[type];
      };
      if (!$scope.get('modalName'))
        $scope.config.modalName = 'confirm-modal';

      function call(type) {
        var action = $scope.get(type);
        if (action) {
          if (angular.isFunction(action))
            action();
          return true;
        }
        return !!buttons.getText(type);
      }
      $scope.cancelPressed = close('cancel');
      $scope.okPressed = close('ok');
      $scope.alertPressed = close('alert');

      function close(type) {
        return function() {
          actionClosed = true;
          $rootScope.$broadcast('dialog.' + $scope.config.modalName + '.close');
          call(type);
        }
      }
      var actionClosed;
      $scope.$on('dialog.' + $scope.get('modalName') + '.opened', function() {
        actionClosed = false;
      });
      $scope.$on('dialog.' + $scope.get('modalName') + '.closed', function() {
        if (actionClosed)
          return;
        if (call('cancel'))
          return;
        if (call('alert'))
          return;
        call('ok');
      });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snContextMenu.js */
angular.module('sn.common.ui').directive('contextMenu', function($document, $window, snCustomEvent) {
  var $contextMenu, $ul;
  var scrollHeight = angular.element("body").get(0).scrollHeight;
  var contextMenuItemHeight = 0;

  function setContextMenuPosition(event, $ul) {
    if (contextMenuItemHeight === 0)
      contextMenuItemHeight = 24;
    var cmWidth = 150;
    var cmHeight = contextMenuItemHeight * $ul.children().length;
    var startX = event.pageX + cmWidth >= $window.innerWidth ? event.pageX - cmWidth : event.pageX;
    var startY = event.pageY + cmHeight >= $window.innerHeight ? event.pageY - cmHeight : event.pageY;
    $ul.css({
      display: 'block',
      position: 'absolute',
      left: startX,
      top: startY
    });
  }

  function renderContextMenuItems($scope, event, options) {
    $ul.empty();
    angular.forEach(options, function(item) {
      var $li = angular.element('<li>');
      if (item === null) {
        $li.addClass('divider');
      } else {
        var $a = angular.element('<a>');
        $a.attr({
          tabindex: '-1'
        });
        $a.text(typeof item[0] == 'string' ? item[0] : item[0].call($scope, $scope));
        $li.append($a);
        $li.on('click', function($event) {
          $event.preventDefault();
          $scope.$apply(function() {
            _clearContextMenus(event);
            item[1].call($scope, $scope);
          });
        });
      }
      $ul.append($li);
    });
    setContextMenuPosition(event, $ul);
  }
  var renderContextMenu = function($scope, event, options) {
    angular.element(event.currentTarget).addClass('context');
    $contextMenu = angular.element('<div>', {
      'class': 'dropdown clearfix context-dropdown open'
    });
    $contextMenu.on('click', function(e) {
      if (angular.element(e.target).hasClass('dropdown')) {
        _clearContextMenus(event);
      }
    });
    $contextMenu.on('contextmenu', function(event) {
      event.preventDefault();
      _clearContextMenus(event);
    });
    $contextMenu.css({
      position: 'absolute',
      top: 0,
      height: scrollHeight,
      left: 0,
      right: 0,
      zIndex: 9999
    });
    $document.find('body').append($contextMenu);
    $ul = angular.element('<ul>', {
      'class': 'dropdown-menu',
      'role': 'menu'
    });
    renderContextMenuItems($scope, event, options);
    $contextMenu.append($ul);
    $contextMenu.data('resizeHandler', function() {
      scrollHeight = angular.element("body").get(0).scrollHeight;
      $contextMenu.css('height', scrollHeight);
    });
    snCustomEvent.observe('partial.page.reload', $contextMenu.data('resizeHandler'));
  };

  function _clearContextMenus(event) {
    if (!event) {
      return;
    }
    angular.element(event.currentTarget).removeClass('context');
    var els = angular.element(".context-dropdown");
    angular.forEach(els, function(el) {
      snCustomEvent.un('partial.page.reload', angular.element(el).data('resizeHandler'));
      angular.element(el).remove();
    });
  }
  return function(scope, element, attrs) {
    element.on('contextmenu', function(event) {
      if (event.ctrlKey)
        return;
      if (angular.element(element).attr('context-type'))
        return;
      scope.$apply(function() {
        applyMenu(event);
        clearWindowSelection();
      });
    });
    element.on('click', function(event) {
      var $el = angular.element(element);
      var $target = angular.element(event.target);
      if (!$el.attr('context-type') && !$target.hasClass('context-menu-click'))
        return;
      scope.$apply(function() {
        applyMenu(event);
        clearWindowSelection();
      });
    });

    function clearWindowSelection() {
      if (window.getSelection)
        if (window.getSelection().empty)
          window.getSelection().empty();
        else if (window.getSelection().removeAllRanges)
        window.getSelection().removeAllRanges();
      else if (document.selection)
        document.selection.empty();
    }

    function applyMenu(event) {
      var tagName = event.target.tagName;
      if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'BUTTON') {
        return;
      }
      var menu = scope.$eval(attrs.contextMenu);
      if (menu instanceof Array) {
        if (menu.length > 0) {
          event.stopPropagation();
          event.preventDefault();
          scope.$watch(function() {
            return menu;
          }, function(newValue, oldValue) {
            if (newValue !== oldValue) renderContextMenuItems(scope, event, menu);
          }, true);
          renderContextMenu(scope, event, menu);
        }
      } else if (typeof menu !== 'undefined' && typeof menu.then === 'function') {
        event.stopPropagation();
        event.preventDefault();
        menu.then(function(response) {
          var contextMenu = response;
          if (contextMenu.length > 0) {
            scope.$watch(function() {
              return contextMenu;
            }, function(newValue, oldValue) {
              if (newValue !== oldValue)
                renderContextMenuItems(scope, event, contextMenu);
            }, true);
            renderContextMenu(scope, event, contextMenu);
          } else {
            throw '"' + attrs.contextMenu + '" is not an array or promise';
          }
        });
      } else {
        throw '"' + attrs.contextMenu + '" is not an array or promise';
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snDialog.js */
angular.module("sn.common.ui").directive("snDialog", function($timeout, $rootScope, $document) {
  "use strict";
  return {
    restrict: "AE",
    transclude: true,
    scope: {
      modal: "=?",
      disableAutoFocus: "=?",
      classCheck: "="
    },
    replace: true,
    template: '<dialog><div ng-click="onClickClose()" class="close-button icon-button icon-cross"></div></dialog>',
    link: function(scope, element, attrs, ctrl, transcludeFn) {
      var transcludeScope = {};
      scope.isOpen = function() {
        return element[0].open;
      };
      transcludeFn(element.scope().$new(), function(a, b) {
        element.append(a);
        transcludeScope = b;
      });
      element.click(function(event) {
        event.stopPropagation();
        if (event.offsetX < 0 || event.offsetX > element[0].offsetWidth || event.offsetY < 0 || event.offsetY > element[0].offsetHeight)
          if (!scope.classCheck)
            scope.onClickClose();
          else {
            var classes = scope.classCheck.split(",");
            var found = false;
            for (var i = 0; i < classes.length; i++)
              if (angular.element(event.srcElement).closest(classes[i]).length > 0)
                found = true;
            if (!found)
              scope.onClickClose();
          }
      });
      scope.show = function() {
        var d = element[0];
        if (!d.showModal || true) {
          dialogPolyfill.registerDialog(d);
          d.setDisableAutoFocus(scope.disableAutoFocus);
        }
        if (scope.modal)
          d.showModal();
        else
          d.show();
        if (!angular.element(d).hasClass('sn-alert')) {
          $timeout(function() {
            if (d.dialogPolyfillInfo && d.dialogPolyfillInfo.backdrop) {
              angular.element(d.dialogPolyfillInfo.backdrop).one('click', function(event) {
                if (!scope.classCheck || angular.element(event.srcElement).closest(scope.classCheck).length == 0)
                  scope.onClickClose();
              })
            } else {
              $document.on('click', function(event) {
                if (!scope.classCheck || angular.element(event.srcElement).closest(scope.classCheck).length == 0)
                  scope.onClickClose();
              })
            }
          });
        }
      };
      scope.setPosition = function(data) {
        var contextData = scope.getContextData(data);
        if (contextData && element && element[0]) {
          if (contextData.position) {
            element[0].style.top = contextData.position.top + "px";
            element[0].style.left = contextData.position.left + "px";
            element[0].style.margin = "0px";
          }
          if (contextData.dimensions) {
            element[0].style.width = contextData.dimensions.width + "px";
            element[0].style.height = contextData.dimensions.height + "px";
          }
        }
      }
      scope.$on("dialog." + attrs.name + ".move", function(event, data) {
        scope.setPosition(data);
      })
      scope.$on("dialog." + attrs.name + ".show", function(event, data) {
        scope.setPosition(data);
        scope.setKeyEvents(data);
        if (scope.isOpen() === true)
          scope.close();
        else
          scope.show();
        angular.element(".sn-dialog-menu").each(function(index, value) {
          var name = angular.element(this).attr('name');
          if (name != attrs.name && !angular.element(this).attr('open')) {
            return true;
          }
          if (name != attrs.name && angular.element(this).attr('open')) {
            $rootScope.$broadcast("dialog." + name + ".close");
          }
        });
      })
      scope.onClickClose = function() {
        if (scope.isOpen())
          $rootScope.$broadcast("dialog." + attrs.name + ".close");
      }
      scope.close = function() {
        var d = element[0];
        d.close();
        scope.removeListeners();
      }
      scope.ok = function(contextData) {
        contextData.ok();
        scope.removeListeners();
      }
      scope.cancel = function(contextData) {
        contextData.cancel();
        scope.removeListeners();
      }
      scope.removeListeners = function() {
        element[0].removeEventListener("ok", scope.handleContextOk, false);
        element[0].removeEventListener("cancel", scope.handleContextCancel, false);
      }
      scope.setKeyEvents = function(data) {
        var contextData = scope.getContextData(data);
        if (contextData && contextData.cancel) {
          scope.handleContextOk = function() {
            scope.ok(contextData);
          }
          scope.handleContextCancel = function() {
            scope.cancel(contextData);
          }
          element[0].addEventListener("ok", scope.handleContextOk, false);
          element[0].addEventListener("cancel", scope.handleContextCancel, false);
        }
      }
      scope.getContextData = function(data) {
        var context = attrs.context;
        var contextData = null;
        if (context && data && context in data) {
          contextData = data[context];
          transcludeScope[context] = contextData;
        }
        return contextData;
      }
      scope.$on("dialog." + attrs.name + ".close", scope.close);
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snFlyout.js */
angular.module('sn.common.ui').directive('snFlyout', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    templateUrl: getTemplateUrl('sn_flyout.xml'),
    scope: true,
    link: function($scope, element, attrs) {
      $scope.open = false;
      $scope.more = false;
      $scope.position = attrs.position || 'left';
      $scope.flyoutControl = attrs.control;
      $scope.register = attrs.register;
      var body = angular.element('.flyout-body', element);
      var header = angular.element('.flyout-header', element);
      var tabs = angular.element('.flyout-tabs', element);
      var distance = 0;
      var position = $scope.position;
      var options = {
        duration: 800,
        easing: 'easeOutBounce'
      }
      var animation = {};
      if ($scope.flyoutControl) {
        $('.flyout-handle', element).hide();
        var controls = angular.element('#' + $scope.flyoutControl);
        controls.click(function() {
          angular.element(this).trigger("snFlyout.open");
        });
        controls.on('snFlyout.open', function() {
          $scope.$apply(function() {
            $scope.open = !$scope.open;
          });
        });
      }
      var animate = function() {
        element.velocity(animation, options);
      }
      var setup = function() {
        animation[position] = -distance;
        if ($scope.open)
          element.css(position, 0);
        else
          element.css(position, -distance);
      }
      var calculatePosition = function() {
        if ($scope.open) {
          animation[position] = 0;
        } else {
          if ($scope.position === 'left' || $scope.position === 'right')
            animation[position] = -body.outerWidth();
          else
            animation[position] = -body.outerHeight();
        }
      }
      $scope.$watch('open', function(newValue, oldValue) {
        if (newValue === oldValue)
          return;
        calculatePosition();
        animate();
      });
      $scope.$watch('more', function(newValue, oldValue) {
        if (newValue === oldValue)
          return;
        var moreAnimation = {};
        if ($scope.more) {
          element.addClass('fly-double');
          moreAnimation = {
            width: body.outerWidth() * 2
          };
        } else {
          element.removeClass('fly-double');
          moreAnimation = {
            width: body.outerWidth() / 2
          };
        }
        body.velocity(moreAnimation, options);
        header.velocity(moreAnimation, options);
      });
      if ($scope.position === 'left' || $scope.position === 'right') {
        $scope.$watch(element[0].offsetWidth, function() {
          element.addClass('fly-from-' + $scope.position);
          distance = body.outerWidth();
          setup();
        });
      } else if ($scope.position === 'top' || $scope.position === 'bottom') {
        $scope.$watch(element[0].offsetWidth, function() {
          element.addClass('fly-from-' + $scope.position);
          distance = body.outerHeight() + header.outerHeight();
          setup();
        });
      }
      $scope.$on($scope.register + ".bounceTabByIndex", function(event, index) {
        $scope.bounceTab(index);
      });
      $scope.$on($scope.register + ".bounceTab", function(event, tab) {
        $scope.bounceTab($scope.tabs.indexOf(tab));
      });
      $scope.$on($scope.register + ".selectTabByIndex", function(event, index) {
        $scope.selectTab($scope.tabs[index]);
      });
      $scope.$on($scope.register + ".selectTab", function(event, tab) {
        $scope.selectTab(tab);
      });
    },
    controller: function($scope, $element) {
      $scope.tabs = [];
      var baseColor, highLightColor;
      $scope.selectTab = function(tab) {
        if ($scope.selectedTab)
          $scope.selectedTab.selected = false;
        tab.selected = true;
        $scope.selectedTab = tab;
        normalizeTab($scope.tabs.indexOf(tab));
      }

      function expandTab(tabElem) {
        tabElem.queue("tabBounce", function(next) {
          tabElem.velocity({
            width: ["2.5rem", "2.125rem"],
            backgroundColorRed: [highLightColor[0], baseColor[0]],
            backgroundColorGreen: [highLightColor[1], baseColor[1]],
            backgroundColorBlue: [highLightColor[2], baseColor[2]]
          }, {
            easing: "easeInExpo",
            duration: 250
          });
          next();
        });
      }

      function contractTab(tabElem) {
        tabElem.queue("tabBounce", function(next) {
          tabElem.velocity({
            width: ["2.125rem", "2.5rem"],
            backgroundColorRed: [baseColor[0], highLightColor[0]],
            backgroundColorGreen: [baseColor[1], highLightColor[1]],
            backgroundColorBlue: [baseColor[2], highLightColor[2]]
          }, {
            easing: "easeInExpo",
            duration: 250
          });
          next();
        });
      }
      $scope.bounceTab = function(index) {
        if (index >= $scope.tabs.length || index < 0)
          return;
        var tabScope = $scope.tabs[index];
        if (!tabScope.selected) {
          var tabElem = $element.find('.flyout-tab').eq(index);
          if (!baseColor) {
            baseColor = tabElem.css('backgroundColor').match(/[0-9]+/g);
            for (var i = 0; i < baseColor.length; i++)
              baseColor[i] = parseInt(baseColor[i], 10);
          }
          if (!highLightColor)
            highLightColor = invertColor(baseColor);
          if (tabScope.highlighted)
            contractTab(tabElem);
          for (var i = 0; i < 2; i++) {
            expandTab(tabElem);
            contractTab(tabElem);
          }
          expandTab(tabElem);
          tabElem.dequeue("tabBounce");
          tabScope.highlighted = true;
        }
      }
      $scope.toggleOpen = function() {
        $scope.open = !$scope.open;
      }
      this.addTab = function(tab) {
        $scope.tabs.push(tab);
        if ($scope.tabs.length === 1)
          $scope.selectTab(tab)
      }

      function normalizeTab(index) {
        if (index < 0 || index >= $scope.tabs.length || !$scope.tabs[index].highlighted)
          return;
        var tabElem = $element.find('.flyout-tab').eq(index);
        tabElem.velocity({
          width: ["2.125rem", "2.5rem"]
        }, {
          easing: "easeInExpo",
          duration: 250
        });
        tabElem.css('backgroundColor', '');
        $scope.tabs[index].highlighted = false;
      }

      function invertColor(rgb) {
        if (typeof rgb === "string")
          var color = rgb.match(/[0-9]+/g);
        else
          var color = rgb.slice(0);
        for (var i = 0; i < color.length; i++)
          color[i] = 255 - parseInt(color[i], 10);
        return color;
      }
    }
  }
}).directive("snFlyoutTab", function() {
  "use strict";
  return {
    restrict: "E",
    require: "^snFlyout",
    replace: true,
    scope: true,
    transclude: true,
    template: "<div ng-show='selected' ng-transclude='' style='height: 100%'></div>",
    link: function(scope, element, attrs, flyoutCtrl) {
      flyoutCtrl.addTab(scope);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/ui/directive.snModal.js */
angular.module("sn.common.ui").directive("snModal", function($timeout, $rootScope) {
  "use strict";
  return {
    restrict: "AE",
    transclude: true,
    scope: {},
    replace: true,
    template: '<div tabindex="-1" aria-hidden="true" class="modal" role="dialog"></div>',
    link: function(scope, element, attrs, ctrl, transcludeFn) {
      var transcludeScope = {};
      transcludeFn(element.scope().$new(), function(a, b) {
        element.append(a);
        transcludeScope = b;
      });
      scope.$on("dialog." + attrs.name + ".show", function(event, data) {
        if (!isOpen())
          show(data);
      });
      scope.$on("dialog." + attrs.name + ".close", function() {
        if (isOpen())
          close();
      });

      function eventFn(eventName) {
        return function(e) {
          $rootScope.$broadcast("dialog." + attrs.name + "." + eventName, e);
        }
      }
      var events = {
        'shown.bs.modal': eventFn("opened"),
        'hide.bs.modal': eventFn("hide"),
        'hidden.bs.modal': eventFn("closed")
      };

      function show(data) {
        var context = attrs.context;
        var contextData = null;
        if (context && data && context in data) {
          contextData = data[context];
          transcludeScope[context] = contextData;
        }
        $timeout(function() {
          angular.element('.sn-popover-basic').each(function() {
            var $this = angular.element(this);
            if (angular.element($this.attr('data-target')).is(':visible')) {
              $this.popover('hide');
            }
          });
        });
        element.modal('show');
        for (var event in events)
          if (events.hasOwnProperty(event))
            element.on(event, events[event]);
        if (attrs.moveBackdrop == 'true')
          moveBackdrop(element);
      }

      function close() {
        element.modal('hide');
        for (var event in events)
          if (events.hasOwnProperty(event))
            element.off(event, events[event]);
      }

      function isOpen() {
        return element.hasClass('in');
      }

      function moveBackdrop(element) {
        element.after(angular.element('.modal-backdrop:visible').remove());
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snModalShow.js */
angular.module('sn.common.ui').directive('snModalShow', function() {
  "use strict";
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      element.click(function() {
        showDialog();
      });
      element.keyup(function(evt) {
        if (evt.which != 13)
          return;
        showDialog();
      });

      function showDialog() {
        scope.$broadcast('dialog.' + attrs.snModalShow + '.show');
      }
      if (window.SingletonKeyboardRegistry) {
        SingletonKeyboardRegistry.getInstance().bind('ctrl + alt + i', function() {
          scope.$broadcast('dialog.impersonate.show');
        }).selector(null, true);
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snTabs.js */
angular.module('sn.common.ui').directive('snTabs', function() {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    scope: {
      tabData: '='
    },
    link: function($scope, element, attrs) {
      $scope.tabClass = attrs.tabClass;
      $scope.register = attrs.register;
      attrs.$observe('register', function(value) {
        $scope.register = value;
        $scope.setupListeners();
      });
      $scope.bounceTab = function() {
        angular.element()
      }
    },
    controller: 'snTabs'
  }
}).controller('snTabs', function($scope, $rootScope) {
  $scope.selectedTabIndex = 0;
  $scope.tabData[$scope.selectedTabIndex].selected = true;
  $scope.setupListeners = function() {
    $scope.$on($scope.register + '.selectTabByIndex', function(event, index) {
      $scope.selectTabByIndex(event, index);
    });
  }
  $scope.selectTabByIndex = function(event, index) {
    if (index === $scope.selectedTabIndex)
      return;
    if (event.stopPropagation)
      event.stopPropagation();
    $scope.tabData[$scope.selectedTabIndex].selected = false;
    $scope.tabData[index].selected = true;
    $scope.selectedTabIndex = index;
    $rootScope.$broadcast($scope.register + '.selectTabByIndex', $scope.selectedTabIndex);
  }
}).directive('snTab', function() {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    scope: {
      tabData: '=',
      index: '='
    },
    template: '',
    controller: 'snTab',
    link: function($scope, element, attrs) {
      $scope.register = attrs.register;
      attrs.$observe('register', function(value) {
        $scope.register = value;
        $scope.setupListeners();
      });
      $scope.bounceTab = function() {
        alert('Bounce Tab at Index: ' + $scope.index);
      }
    }
  }
}).controller('snTab', function($scope) {
  $scope.selectTabByIndex = function(index) {
    $scope.$emit($scope.register + '.selectTabByIndex', index);
  }
  $scope.setupListeners = function() {
    $scope.$on($scope.register + '.showTabActivity', function(event, index, type) {
      $scope.showTabActivity(index, type);
    });
  }
  $scope.showTabActivity = function(index, type) {
    if ($scope.index !== index)
      return;
    switch (type) {
      case 'message':
        break;
      case 'error':
        break;
      default:
        $scope.bounceTab();
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snTextExpander.js */
angular.module('sn.common.ui').directive('snTextExpander', function(getTemplateUrl, $timeout) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('sn_text_expander.xml'),
    scope: {
      maxHeight: '&',
      value: '='
    },
    link: function compile(scope, element, attrs) {
      var container = angular.element(element).find('.textblock-content-container');
      var content = angular.element(element).find('.textblock-content');
      if (scope.maxHeight() === undefined) {
        scope.maxHeight = function() {
          return 100;
        }
      }
      container.css('overflow-y', 'hidden');
      container.css('max-height', scope.maxHeight() + 'px');
    },
    controller: function($scope, $element) {
      var container = $element.find('.textblock-content-container');
      var content = $element.find('.textblock-content');
      $scope.value = $scope.value || '';
      $scope.toggleExpand = function() {
        $scope.showMore = !$scope.showMore;
        if ($scope.showMore) {
          container.css('max-height', content.height());
        } else {
          container.css('max-height', $scope.maxHeight());
        }
      };
      $timeout(function() {
        if (content.height() > $scope.maxHeight()) {
          $scope.showToggle = true;
          $scope.showMore = false;
        }
      });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snAttachmentPreview.js */
angular.module('sn.common.ui').directive('snAttachmentPreview', function(getTemplateUrl, snCustomEvent) {
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_attachment_preview.xml'),
    controller: function($scope) {
      snCustomEvent.observe('sn.attachment.preview', function(evt, attachment) {
        if (evt.stopPropagation)
          evt.stopPropagation();
        if (evt.preventDefault)
          evt.preventDefault();
        $scope.image = attachment;
        $scope.$broadcast('dialog.attachment_preview.show');
        return false;
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/service.progressDialog.js */
angular.module('sn.common.ui').factory('progressDialog', ['$rootScope', '$compile', '$timeout', '$http', '$templateCache', 'nowServer', 'i18n', function($rootScope, $compile, $timeout, $http, $templateCache, nowServer, i18n) {
  'use strict';
  i18n.getMessages(['Close']);
  return {
    STATES: ["Pending", "Running", "Succeeded", "Failed", "Cancelled"],
    STATUS_IMAGES: ["images/workflow_skipped.gif", "images/loading_anim2.gifx",
      "images/progress_success.png", "images/progress_failure.png",
      'images/request_cancelled.gif'
    ],
    EXPAND_IMAGE: "images/icons/filter_hide.gif",
    COLLAPSE_IMAGE: "images/icons/filter_reveal.gif",
    BACK_IMAGE: "images/activity_filter_off.gif",
    TIMEOUT_INTERVAL: 750,
    _findChildMessage: function(statusObject) {
      if (!statusObject.children) return null;
      for (var i = 0; i < statusObject.children.length; i++) {
        var child = statusObject.children[i];
        if (child.state == '1') {
          var msg = child.message;
          var submsg = this._findChildMessage(child);
          if (submsg == null)
            return msg;
          else
            return null;
        } else if (child.state == '0') {
          return null;
        } else {}
      }
      return null;
    },
    create: function(scope, elemid, title, startCallback, endCallback, closeCallback) {
      var namespace = this;
      var progressItem = scope.$new(true);
      progressItem.id = elemid + "_progressDialog";
      progressItem.overlayVisible = true;
      progressItem.state = 0;
      progressItem.message = '';
      progressItem.percentComplete = 0;
      progressItem.enableChildMessages = false;
      if (!title) title = '';
      progressItem.title = title;
      progressItem.button_close = i18n.getMessage('Close');
      var overlayElement;
      overlayElement = $compile(
        '<div id="{{id}}" ng-show="overlayVisible" class="modal modal-mask" role="dialog" tabindex="-1">' +
        '<div class="modal-dialog m_progress_overlay_content">' +
        '<div class="modal-content">' +
        '<header class="modal-header">' +
        '<h4 class="modal-title">{{title}}</h4>' +
        '</header>' +
        '<div class="modal-body">' +
        '<div class="progress" ng-class="{\'progress-danger\': (state == 3)}">' +
        '<div class="progress-bar" ng-class="{\'progress-bar-danger\': (state == 3)}" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="{{percentComplete}}" ng-style="{width: percentComplete + \'%\'}">' +
        '</div>' +
        '</div>' +
        '<div>{{message}}<span style="float: right;" ng-show="state==1 || state == 2">{{percentComplete}}%</span></div>' +
        '</div>' +
        '<footer class="modal-footer">' +
        '<button class="btn btn-default sn-button sn-button-normal" ng-click="close()" ng-show="state > 1">{{button_close}}</button>' +
        '</footer>' +
        '</div>' +
        '</div>' +
        '</div>')(progressItem);
      $("body")[0].appendChild(overlayElement[0]);
      progressItem.setEnableChildMessages = function(enableChildren) {
        progressItem.enableChildMessages = enableChildren;
      }
      progressItem.start = function(src, dataArray) {
        $http.post(src, dataArray).success(function(response) {
            progressItem.trackerId = response;
            try {
              if (startCallback) startCallback(response);
            } catch (e) {}
            $timeout(progressItem.checkProgress.bind(progressItem));
          })
          .error(function(response, status, headers, config) {
            progressItem.state = '3';
            if (endCallback) endCallback(response);
          });
      };
      progressItem.checkProgress = function() {
        var src = nowServer.getURL('progress_status', {
          sysparm_execution_id: this.trackerId
        });
        $http.post(src).success(function(response) {
            if ($.isEmptyObject(response)) {
              progressItem.state = '3';
              if (endCallback) endCallback(response);
              return;
            }
            progressItem.update(response);
            if (response.status == 'error' || response.state == '') {
              progressItem.state = '3';
              if (response.message)
                progressItem.message = response.message;
              else
                progressItem.message = response;
              if (endCallback) endCallback(response);
              return;
            }
            if (response.state == '0' || response.state == '1') {
              $timeout(progressItem.checkProgress.bind(progressItem), namespace.TIMEOUT_INTERVAL);
            } else {
              if (endCallback) endCallback(response);
            }
          })
          .error(function(response, status, headers, config) {
            progressItem.state = '3';
            progressItem.message = response;
            if (endCallback) endCallback(response);
          });
      };
      progressItem.update = function(statusObject) {
        var msg = statusObject.message;
        if (progressItem.enableChildMessages) {
          var childMsg = namespace._findChildMessage(statusObject);
          if (childMsg != null)
            msg = childMsg;
        }
        this.message = msg;
        this.state = statusObject.state;
        this.percentComplete = statusObject.percent_complete;
      };
      progressItem.close = function(ev) {
        try {
          if (closeCallback) closeCallback();
        } catch (e) {}
        $("body")[0].removeChild($("#" + this.id)[0]);
        delete namespace.progressItem;
      };
      return progressItem;
    }
  }
}]);;
/*! RESOURCE: /scripts/sn/common/ui/factory.paneManager.js */
angular.module("sn.common.ui").factory("paneManager", ['$timeout', 'userPreferences', 'snCustomEvent', function($timeout, userPreferences, snCustomEvent) {
  "use strict";
  var paneIndex = {};

  function registerPane(paneName) {
    if (!paneName in paneIndex) {
      paneIndex[paneName] = false;
    }
    userPreferences.getPreference(paneName + '.opened').then(function(value) {
      var isOpen = value !== 'false';
      if (isOpen) {
        togglePane(paneName);
      }
    });
  }

  function togglePane(paneName) {
    for (var currentPane in paneIndex) {
      if (paneName != currentPane && paneIndex[currentPane]) {
        CustomEvent.fireTop(currentPane + '.toggle');
        saveState(currentPane, false);
      }
    }
    snCustomEvent.fireTop(paneName + '.toggle');
    saveState(paneName, !paneIndex[paneName]);
  };

  function saveState(paneName, state) {
    paneIndex[paneName] = state;
    userPreferences.setPreference(paneName + '.opened', state);
  }
  return {
    registerPane: registerPane,
    togglePane: togglePane
  };
}]);;
/*! RESOURCE: /scripts/sn/common/ui/directive.snBootstrapPopover.js */
angular.module('sn.common.ui').directive('snBootstrapPopover', function($timeout, $compile, $rootScope) {
  'use strict';
  return {
    restrict: 'A',
    link: function(scope, element) {
      element.on('click.snBootstrapPopover', function(event) {
        $rootScope.$broadcast('sn-bootstrap-popover.close-other-popovers');
        createPopover(event);
      });
      element.on('keypress.snBootstrapPopover', function(event) {
        if (event.keyCode == 9)
          return;
        scope.$broadcast('sn-bootstrap-popover.close-other-popovers');
        createPopover(event);
      });
      var popoverOpen = false;

      function _hidePopover() {
        popoverOpen = false;
        var api = element.data('bs.popover');
        if (api) {
          api.hide();
          element.off('.popover').removeData('bs.popover');
          element.data('bs.popover', void(0));
        }
      }

      function _openPopover() {
        $timeout(function() {
          popoverOpen = true;
          element.on('hidden.bs.popover', function() {
            _hidePopover();
            popoverOpen = false;
          });
          element.popover('show');
        }, 0, false);
      }

      function createPopover(evt) {
        angular.element('.popover').each(function() {
          var object = angular.element(this);
          if (!object.is(evt.target) && object.has(evt.target).length === 0 && angular.element('.popover').has(evt.target).length === 0) {
            _hidePopover();
            object.popover('hide');
          }
        });
        if (scope.disablePopover || evt.keyCode === 9)
          return;
        if (popoverOpen) {
          _hidePopover();
          return;
        }
        var childScope = scope.$new();
        evt.stopPropagation();
        element.attr('data-toggle', 'popover');
        element.attr('data-trigger', 'focus');
        element.attr('tabindex', 0);
        angular.element(element).popover({
          container: 'body',
          placement: 'auto top',
          html: true,
          trigger: 'manual',
          content: $compile(scope.template)(childScope)
        });
        var wait = element.attr('popover-wait-event');
        if (wait)
          scope.$on(wait, _openPopover);
        else
          _openPopover();
        var bodyClickEvent = angular.element('body').on('click.snBootstrapPopover.body', function(evt) {
          angular.element('.popover').each(function() {
            var object = angular.element(this);
            if (!object.is(evt.target) && object.has(evt.target).length === 0 && angular.element('.popover').has(evt.target).length === 0) {
              bodyClickEvent.off();
              _hidePopover();
              childScope.$destroy();
            }
          })
        });
        element.on('$destroy', function() {
          bodyClickEvent.off();
          _hidePopover();
          childScope.$destroy();
        })
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/stream/js_includes_stream.js */
/*! RESOURCE: /scripts/thirdparty/ment.io/mentio.js */
(function() {
  'use strict';
  angular.module('mentio', [])
    .directive('mentio', ['mentioUtil', '$document', '$compile', '$log', '$timeout',
      function(mentioUtil, $document, $compile, $log, $timeout) {
        return {
          restrict: 'A',
          scope: {
            macros: '=mentioMacros',
            search: '&mentioSearch',
            select: '&mentioSelect',
            items: '=mentioItems',
            typedTerm: '=mentioTypedTerm',
            altId: '=mentioId',
            iframeElement: '=mentioIframeElement',
            requireLeadingSpace: '=mentioRequireLeadingSpace',
            suppressTrailingSpace: '=mentioSuppressTrailingSpace',
            selectNotFound: '=mentioSelectNotFound',
            trimTerm: '=mentioTrimTerm',
            ngModel: '='
          },
          controller: ["$scope", "$timeout", "$attrs", function($scope, $timeout, $attrs) {
            $scope.query = function(triggerChar, triggerText) {
              var remoteScope = $scope.triggerCharMap[triggerChar];
              if ($scope.trimTerm === undefined || $scope.trimTerm) {
                triggerText = triggerText.trim();
              }
              remoteScope.showMenu();
              remoteScope.search({
                term: triggerText
              });
              remoteScope.typedTerm = triggerText;
            };
            $scope.defaultSearch = function(locals) {
              var results = [];
              angular.forEach($scope.items, function(item) {
                if (item.label.toUpperCase().indexOf(locals.term.toUpperCase()) >= 0) {
                  results.push(item);
                }
              });
              $scope.localItems = results;
            };
            $scope.bridgeSearch = function(termString) {
              var searchFn = $attrs.mentioSearch ? $scope.search : $scope.defaultSearch;
              searchFn({
                term: termString
              });
            };
            $scope.defaultSelect = function(locals) {
              return $scope.defaultTriggerChar + locals.item.label;
            };
            $scope.bridgeSelect = function(itemVar) {
              var selectFn = $attrs.mentioSelect ? $scope.select : $scope.defaultSelect;
              return selectFn({
                item: itemVar
              });
            };
            $scope.setTriggerText = function(text) {
              if ($scope.syncTriggerText) {
                $scope.typedTerm = ($scope.trimTerm === undefined || $scope.trimTerm) ? text.trim() : text;
              }
            };
            $scope.context = function() {
              if ($scope.iframeElement) {
                return {
                  iframe: $scope.iframeElement
                };
              }
            };
            $scope.replaceText = function(text, hasTrailingSpace) {
              $scope.hideAll();
              mentioUtil.replaceTriggerText($scope.context(), $scope.targetElement, $scope.targetElementPath,
                $scope.targetElementSelectedOffset, $scope.triggerCharSet, text, $scope.requireLeadingSpace,
                hasTrailingSpace, $scope.suppressTrailingSpace);
              if (!hasTrailingSpace) {
                $scope.setTriggerText('');
                angular.element($scope.targetElement).triggerHandler('change');
                if ($scope.isContentEditable()) {
                  $scope.contentEditableMenuPasted = true;
                  var timer = $timeout(function() {
                    $scope.contentEditableMenuPasted = false;
                  }, 200);
                  $scope.$on('$destroy', function() {
                    $timeout.cancel(timer);
                  });
                }
              }
            };
            $scope.hideAll = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  $scope.triggerCharMap[key].hideMenu();
                }
              }
            };
            $scope.getActiveMenuScope = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    return $scope.triggerCharMap[key];
                  }
                }
              }
              return null;
            };
            $scope.selectActive = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    $scope.triggerCharMap[key].selectActive();
                  }
                }
              }
            };
            $scope.isActive = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    return true;
                  }
                }
              }
              return false;
            };
            $scope.isContentEditable = function() {
              return ($scope.targetElement.nodeName !== 'INPUT' && $scope.targetElement.nodeName !== 'TEXTAREA');
            };
            $scope.replaceMacro = function(macro, hasTrailingSpace) {
              if (!hasTrailingSpace) {
                $scope.replacingMacro = true;
                $scope.timer = $timeout(function() {
                  mentioUtil.replaceMacroText($scope.context(), $scope.targetElement,
                    $scope.targetElementPath, $scope.targetElementSelectedOffset,
                    $scope.macros, $scope.macros[macro]);
                  angular.element($scope.targetElement).triggerHandler('change');
                  $scope.replacingMacro = false;
                }, 300);
                $scope.$on('$destroy', function() {
                  $timeout.cancel($scope.timer);
                });
              } else {
                mentioUtil.replaceMacroText($scope.context(), $scope.targetElement, $scope.targetElementPath,
                  $scope.targetElementSelectedOffset, $scope.macros, $scope.macros[macro]);
              }
            };
            $scope.addMenu = function(menuScope) {
              if (menuScope.parentScope && $scope.triggerCharMap.hasOwnProperty(menuScope.triggerChar)) {
                return;
              }
              $scope.triggerCharMap[menuScope.triggerChar] = menuScope;
              if ($scope.triggerCharSet === undefined) {
                $scope.triggerCharSet = [];
              }
              $scope.triggerCharSet.push(menuScope.triggerChar);
              menuScope.setParent($scope);
            };
            $scope.$on(
              'menuCreated',
              function(event, data) {
                if (
                  $attrs.id !== undefined ||
                  $attrs.mentioId !== undefined
                ) {
                  if (
                    $attrs.id === data.targetElement ||
                    (
                      $attrs.mentioId !== undefined &&
                      $scope.altId === data.targetElement
                    )
                  ) {
                    $scope.addMenu(data.scope);
                  }
                }
              }
            );
            $document.on(
              'click',
              function() {
                if ($scope.isActive()) {
                  $scope.$apply(function() {
                    $scope.hideAll();
                  });
                }
              }
            );
            $document.on(
              'keydown keypress paste',
              function(event) {
                var activeMenuScope = $scope.getActiveMenuScope();
                if (activeMenuScope) {
                  if (event.which === 9 || event.which === 13) {
                    event.preventDefault();
                    activeMenuScope.selectActive();
                  }
                  if (event.which === 27) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.hideMenu();
                    });
                  }
                  if (event.which === 40) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.activateNextItem();
                    });
                    activeMenuScope.adjustScroll(1);
                  }
                  if (event.which === 38) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.activatePreviousItem();
                    });
                    activeMenuScope.adjustScroll(-1);
                  }
                  if (event.which === 37 || event.which === 39) {
                    event.preventDefault();
                  }
                }
              }
            );
          }],
          link: function(scope, element, attrs, $timeout) {
            scope.triggerCharMap = {};
            scope.targetElement = element;
            scope.scrollBarParents = element.parents().filter(function() {
              var overflow = angular.element(this).css("overflow");
              return this.scrollHeight > this.clientHeight && overflow !== "hidden" && overflow !== "visible";
            });
            scope.scrollPosition = null;
            attrs.$set('autocomplete', 'off');
            if (attrs.mentioItems) {
              scope.localItems = [];
              scope.parentScope = scope;
              var itemsRef = attrs.mentioSearch ? ' mentio-items="items"' : ' mentio-items="localItems"';
              scope.defaultTriggerChar = attrs.mentioTriggerChar ? scope.$eval(attrs.mentioTriggerChar) : '@';
              var html = '<mentio-menu' +
                ' mentio-search="bridgeSearch(term)"' +
                ' mentio-select="bridgeSelect(item)"' +
                itemsRef;
              if (attrs.mentioTemplateUrl) {
                html = html + ' mentio-template-url="' + attrs.mentioTemplateUrl + '"';
              }
              html = html + ' mentio-trigger-char="\'' + scope.defaultTriggerChar + '\'"' +
                ' mentio-parent-scope="parentScope"' +
                '/>';
              var linkFn = $compile(html);
              var el = linkFn(scope);
              element.parent().append(el);
              scope.$on('$destroy', function() {
                el.remove();
              });
            }
            if (attrs.mentioTypedTerm) {
              scope.syncTriggerText = true;
            }

            function keyHandler(event) {
              function stopEvent(event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
              }
              var activeMenuScope = scope.getActiveMenuScope();
              if (activeMenuScope) {
                if (event.which === 9 || event.which === 13) {
                  stopEvent(event);
                  activeMenuScope.selectActive();
                  return false;
                }
                if (event.which === 27) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.hideMenu();
                  });
                  return false;
                }
                if (event.which === 40) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.activateNextItem();
                  });
                  activeMenuScope.adjustScroll(1);
                  return false;
                }
                if (event.which === 38) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.activatePreviousItem();
                  });
                  activeMenuScope.adjustScroll(-1);
                  return false;
                }
                if (event.which === 37 || event.which === 39) {
                  stopEvent(event);
                  return false;
                }
              }
            }
            scope.$watch(
              'iframeElement',
              function(newValue) {
                if (newValue) {
                  var iframeDocument = newValue.contentWindow.document;
                  iframeDocument.addEventListener('click',
                    function() {
                      if (scope.isActive()) {
                        scope.$apply(function() {
                          scope.hideAll();
                        });
                      }
                    }
                  );
                  iframeDocument.addEventListener('keydown', keyHandler, true);
                  scope.$on('$destroy', function() {
                    iframeDocument.removeEventListener('keydown', keyHandler);
                  });
                }
              }
            );
            scope.$watch(
              'ngModel',
              function(newValue) {
                if ((!newValue || newValue === '') && !scope.isActive()) {
                  return;
                }
                if (scope.triggerCharSet === undefined) {
                  $log.warn('Error, no mentio-items attribute was provided, ' +
                    'and no separate mentio-menus were specified.  Nothing to do.');
                  return;
                }
                if (scope.contentEditableMenuPasted) {
                  scope.contentEditableMenuPasted = false;
                  return;
                }
                if (scope.replacingMacro) {
                  $timeout.cancel(scope.timer);
                  scope.replacingMacro = false;
                }
                var isActive = scope.isActive();
                var isContentEditable = scope.isContentEditable();
                var mentionInfo = mentioUtil.getTriggerInfo(scope.context(), scope.triggerCharSet,
                  scope.requireLeadingSpace, isActive);
                if (mentionInfo !== undefined &&
                  (!isActive ||
                    (isActive &&
                      (
                        (isContentEditable && mentionInfo.mentionTriggerChar ===
                          scope.currentMentionTriggerChar) ||
                        (!isContentEditable && mentionInfo.mentionPosition ===
                          scope.currentMentionPosition)
                      )
                    )
                  )
                ) {
                  if (mentionInfo.mentionSelectedElement) {
                    scope.targetElement = mentionInfo.mentionSelectedElement;
                    scope.targetElementPath = mentionInfo.mentionSelectedPath;
                    scope.targetElementSelectedOffset = mentionInfo.mentionSelectedOffset;
                  }
                  scope.setTriggerText(mentionInfo.mentionText);
                  scope.currentMentionPosition = mentionInfo.mentionPosition;
                  scope.currentMentionTriggerChar = mentionInfo.mentionTriggerChar;
                  scope.query(mentionInfo.mentionTriggerChar, mentionInfo.mentionText);
                } else {
                  var currentTypedTerm = scope.typedTerm;
                  scope.setTriggerText('');
                  scope.hideAll();
                  var macroMatchInfo = mentioUtil.getMacroMatch(scope.context(), scope.macros);
                  if (macroMatchInfo !== undefined) {
                    scope.targetElement = macroMatchInfo.macroSelectedElement;
                    scope.targetElementPath = macroMatchInfo.macroSelectedPath;
                    scope.targetElementSelectedOffset = macroMatchInfo.macroSelectedOffset;
                    scope.replaceMacro(macroMatchInfo.macroText, macroMatchInfo.macroHasTrailingSpace);
                  } else if (scope.selectNotFound && currentTypedTerm && currentTypedTerm !== '') {
                    var lastScope = scope.triggerCharMap[scope.currentMentionTriggerChar];
                    if (lastScope) {
                      var text = lastScope.select({
                        item: {
                          label: currentTypedTerm
                        }
                      });
                      if (typeof text.then === 'function') {
                        text.then(scope.replaceText);
                      } else {
                        scope.replaceText(text, true);
                      }
                    }
                  }
                }
              }
            );
          }
        };
      }
    ])
    .directive('mentioMenu', ['mentioUtil', '$rootScope', '$log', '$window', '$document', '$timeout',
      function(mentioUtil, $rootScope, $log, $window, $document, $timeout) {
        return {
          restrict: 'E',
          scope: {
            search: '&mentioSearch',
            select: '&mentioSelect',
            items: '=mentioItems',
            triggerChar: '=mentioTriggerChar',
            forElem: '=mentioFor',
            parentScope: '=mentioParentScope'
          },
          templateUrl: function(tElement, tAttrs) {
            return tAttrs.mentioTemplateUrl !== undefined ? tAttrs.mentioTemplateUrl : 'mentio-menu.tpl.html';
          },
          controller: ["$scope", function($scope) {
            $scope.visible = false;
            this.activate = $scope.activate = function(item) {
              $scope.activeItem = item;
            };
            this.isActive = $scope.isActive = function(item) {
              return $scope.activeItem === item;
            };
            this.selectItem = $scope.selectItem = function(item) {
              if (item.termLengthIsZero) {
                item.name = $scope.triggerChar + $scope.typedTerm
              }
              var text = $scope.select({
                item: item
              });
              if (typeof text.then === 'function') {
                text.then($scope.parentMentio.replaceText);
              } else {
                $scope.parentMentio.replaceText(text);
              }
            };
            $scope.activateNextItem = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              this.activate($scope.items[(index + 1) % $scope.items.length]);
            };
            $scope.activatePreviousItem = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              this.activate($scope.items[index === 0 ? $scope.items.length - 1 : index - 1]);
            };
            $scope.isFirstItemActive = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              return index === 0;
            };
            $scope.isLastItemActive = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              return index === ($scope.items.length - 1);
            };
            $scope.selectActive = function() {
              $scope.selectItem($scope.activeItem);
            };
            $scope.isVisible = function() {
              return $scope.visible;
            };
            $scope.showMenu = function() {
              if (!$scope.visible) {
                $scope.menuElement.css("visibility", "visible");
                $scope.requestVisiblePendingSearch = true;
              }
            };
            $scope.setParent = function(scope) {
              $scope.parentMentio = scope;
              $scope.targetElement = scope.targetElement;
            };
            var scopeDuplicate = $scope;
            $rootScope.$on('mentio.closeMenu', function() {
              scopeDuplicate.hideMenu();
            })
          }],
          link: function(scope, element) {
            element[0].parentNode.removeChild(element[0]);
            $document[0].body.appendChild(element[0]);
            scope.menuElement = element;
            scope.menuElement.css("visibility", "hidden");
            if (scope.parentScope) {
              scope.parentScope.addMenu(scope);
            } else {
              if (!scope.forElem) {
                $log.error('mentio-menu requires a target element in tbe mentio-for attribute');
                return;
              }
              if (!scope.triggerChar) {
                $log.error('mentio-menu requires a trigger char');
                return;
              }
              $rootScope.$broadcast('menuCreated', {
                targetElement: scope.forElem,
                scope: scope
              });
            }
            angular.element($window).bind(
              'resize',
              function() {
                if (scope.isVisible()) {
                  var triggerCharSet = [];
                  triggerCharSet.push(scope.triggerChar);
                  mentioUtil.popUnderMention(scope.parentMentio.context(),
                    triggerCharSet, element, scope.requireLeadingSpace);
                }
              }
            );
            scope.$watch('items', function(items) {
              if (items && items.length > 0) {
                scope.activate(items[0]);
                if (!scope.visible && scope.requestVisiblePendingSearch) {
                  scope.visible = true;
                  scope.requestVisiblePendingSearch = false;
                }
                $timeout(function() {
                  var menu = element.find(".dropdown-menu");
                  if (menu.length > 0 && menu.offset().top < 0)
                    menu.addClass("reverse");
                }, 0, false);
              } else {
                scope.activate({
                  termLengthIsZero: true
                });
              }
            });
            scope.$watch('isVisible()', function(visible) {
              if (visible) {
                var triggerCharSet = [];
                triggerCharSet.push(scope.triggerChar);
                mentioUtil.popUnderMention(scope.parentMentio.context(),
                  triggerCharSet, element, scope.requireLeadingSpace);
              } else {
                element.find(".dropdown-menu").removeClass("reverse");
              }
            });
            var prevScroll;
            scope.parentMentio.scrollBarParents.each(function() {
              angular.element(this).on("scroll.mentio", function() {
                if (!prevScroll)
                  prevScroll = this.scrollTop;
                var scrollDiff = prevScroll - this.scrollTop;
                prevScroll = this.scrollTop;
                if (element[0].style["position"] === "absolute") {
                  element[0].style["z-index"] = 9;
                  element[0].style.top = (parseInt(element[0].style.top) + scrollDiff) + "px";
                }
              });
            });
            scope.parentMentio.$on('$destroy', function() {
              element.remove();
            });
            scope.hideMenu = function() {
              scope.visible = false;
              element.css('display', 'none');
            };
            scope.adjustScroll = function(direction) {
              var menuEl = element[0];
              var menuItemsList = menuEl.querySelector('ul');
              var menuItem = menuEl.querySelector('[mentio-menu-item].active');
              if (scope.isFirstItemActive()) {
                return menuItemsList.scrollTop = 0;
              } else if (scope.isLastItemActive()) {
                return menuItemsList.scrollTop = menuItemsList.scrollHeight;
              }
              if (direction === 1) {
                menuItemsList.scrollTop += menuItem.offsetHeight;
              } else {
                menuItemsList.scrollTop -= menuItem.offsetHeight;
              }
            };
          }
        };
      }
    ])
    .directive('mentioMenuItem', function() {
      return {
        restrict: 'A',
        scope: {
          item: '=mentioMenuItem'
        },
        require: '^mentioMenu',
        link: function(scope, element, attrs, controller) {
          scope.$watch(function() {
            return controller.isActive(scope.item);
          }, function(active) {
            if (active) {
              element.addClass('active');
            } else {
              element.removeClass('active');
            }
          });
          element.bind('mouseenter', function() {
            scope.$apply(function() {
              controller.activate(scope.item);
            });
          });
          element.bind('click', function() {
            controller.selectItem(scope.item);
            return false;
          });
        }
      };
    })
    .filter('unsafe', ["$sce", function($sce) {
      return function(val) {
        return $sce.trustAsHtml(val);
      };
    }])
    .filter('mentioHighlight', function() {
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      return function(matchItem, query, hightlightClass) {
        if (query) {
          var replaceText = hightlightClass ?
            '<span class="' + hightlightClass + '">$&</span>' :
            '<strong>$&</strong>';
          return ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), replaceText);
        } else {
          return matchItem;
        }
      };
    });
  'use strict';
  angular.module('mentio')
    .factory('mentioUtil', ["$window", "$location", "$anchorScroll", "$timeout", function($window, $location, $anchorScroll, $timeout) {
      function popUnderMention(ctx, triggerCharSet, selectionEl, requireLeadingSpace) {
        var coordinates;
        var mentionInfo = getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, false);
        if (mentionInfo !== undefined) {
          if (selectedElementIsTextAreaOrInput(ctx)) {
            coordinates = getTextAreaOrInputUnderlinePosition(ctx, getDocument(ctx).activeElement,
              mentionInfo.mentionPosition);
          } else {
            coordinates = getContentEditableCaretPosition(ctx, mentionInfo.mentionPosition);
          }
          selectionEl.css({
            top: coordinates.top + 'px',
            left: coordinates.left + 'px',
            position: 'absolute',
            zIndex: 5000,
            display: 'block'
          });
          $timeout(function() {
            scrollIntoView(ctx, selectionEl);
          }, 0);
        } else {
          selectionEl.css({
            display: 'none'
          });
        }
      }

      function scrollIntoView(ctx, elem) {
        var reasonableBuffer = 20;
        var maxScrollDisplacement = 100;
        var clientRect;
        var e = elem[0];
        while (clientRect === undefined || clientRect.height === 0) {
          clientRect = e.getBoundingClientRect();
          if (clientRect.height === 0) {
            e = e.childNodes[0];
            if (e === undefined || !e.getBoundingClientRect) {
              return;
            }
          }
        }
        var elemTop = clientRect.top;
        var elemBottom = elemTop + clientRect.height;
        if (elemTop < 0) {
          $window.scrollTo(0, $window.pageYOffset + clientRect.top - reasonableBuffer);
        } else if (elemBottom > $window.innerHeight) {
          var maxY = $window.pageYOffset + clientRect.top - reasonableBuffer;
          if (maxY - $window.pageYOffset > maxScrollDisplacement) {
            maxY = $window.pageYOffset + maxScrollDisplacement;
          }
          var targetY = $window.pageYOffset - ($window.innerHeight - elemBottom);
          if (targetY > maxY) {
            targetY = maxY;
          }
          $window.scrollTo(0, targetY);
        }
      }

      function selectedElementIsTextAreaOrInput(ctx) {
        var element = getDocument(ctx).activeElement;
        if (element !== null) {
          var nodeName = element.nodeName;
          var type = element.getAttribute('type');
          return (nodeName === 'INPUT' && type === 'text') || nodeName === 'TEXTAREA';
        }
        return false;
      }

      function selectElement(ctx, targetElement, path, offset) {
        var range;
        var elem = targetElement;
        if (path) {
          for (var i = 0; i < path.length; i++) {
            elem = elem.childNodes[path[i]];
            if (elem === undefined) {
              return;
            }
            while (elem.length < offset) {
              offset -= elem.length;
              elem = elem.nextSibling;
            }
            if (elem.childNodes.length === 0 && !elem.length) {
              elem = elem.previousSibling;
            }
          }
        }
        var sel = getWindowSelection(ctx);
        range = getDocument(ctx).createRange();
        range.setStart(elem, offset);
        range.setEnd(elem, offset);
        range.collapse(true);
        try {
          sel.removeAllRanges();
        } catch (error) {}
        sel.addRange(range);
        targetElement.focus();
      }

      function pasteHtml(ctx, html, startPos, endPos) {
        var range, sel;
        sel = getWindowSelection(ctx);
        range = getDocument(ctx).createRange();
        range.setStart(sel.anchorNode, startPos);
        range.setEnd(sel.anchorNode, endPos);
        range.deleteContents();
        var el = getDocument(ctx).createElement('div');
        el.innerHTML = html;
        var frag = getDocument(ctx).createDocumentFragment(),
          node, lastNode;
        while ((node = el.firstChild)) {
          lastNode = frag.appendChild(node);
        }
        range.insertNode(frag);
        if (lastNode) {
          range = range.cloneRange();
          range.setStartAfter(lastNode);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }

      function resetSelection(ctx, targetElement, path, offset) {
        var nodeName = targetElement.nodeName;
        if (nodeName === 'INPUT' || nodeName === 'TEXTAREA') {
          if (targetElement !== getDocument(ctx).activeElement) {
            targetElement.focus();
          }
        } else {
          selectElement(ctx, targetElement, path, offset);
        }
      }

      function replaceMacroText(ctx, targetElement, path, offset, macros, text) {
        resetSelection(ctx, targetElement, path, offset);
        var macroMatchInfo = getMacroMatch(ctx, macros);
        if (macroMatchInfo.macroHasTrailingSpace) {
          macroMatchInfo.macroText = macroMatchInfo.macroText + '\xA0';
          text = text + '\xA0';
        }
        if (macroMatchInfo !== undefined) {
          var element = getDocument(ctx).activeElement;
          if (selectedElementIsTextAreaOrInput(ctx)) {
            var startPos = macroMatchInfo.macroPosition;
            var endPos = macroMatchInfo.macroPosition + macroMatchInfo.macroText.length;
            element.value = element.value.substring(0, startPos) + text +
              element.value.substring(endPos, element.value.length);
            element.selectionStart = startPos + text.length;
            element.selectionEnd = startPos + text.length;
          } else {
            pasteHtml(ctx, text, macroMatchInfo.macroPosition,
              macroMatchInfo.macroPosition + macroMatchInfo.macroText.length);
          }
        }
      }

      function replaceTriggerText(ctx, targetElement, path, offset, triggerCharSet,
        text, requireLeadingSpace, hasTrailingSpace, suppressTrailingSpace) {
        resetSelection(ctx, targetElement, path, offset);
        var mentionInfo = getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, true, hasTrailingSpace);
        if (mentionInfo !== undefined) {
          if (selectedElementIsTextAreaOrInput()) {
            var myField = getDocument(ctx).activeElement;
            if (!suppressTrailingSpace) {
              text = text + ' ';
            }
            var startPos = mentionInfo.mentionPosition;
            var endPos = mentionInfo.mentionPosition + mentionInfo.mentionText.length + 1;
            myField.value = myField.value.substring(0, startPos) + text +
              myField.value.substring(endPos, myField.value.length);
            myField.selectionStart = startPos + text.length;
            myField.selectionEnd = startPos + text.length;
          } else {
            if (!suppressTrailingSpace) {
              text = text + '\xA0';
            }
            pasteHtml(ctx, text, mentionInfo.mentionPosition,
              mentionInfo.mentionPosition + mentionInfo.mentionText.length + 1);
          }
        }
      }

      function getNodePositionInParent(ctx, elem) {
        if (elem.parentNode === null) {
          return 0;
        }
        for (var i = 0; i < elem.parentNode.childNodes.length; i++) {
          var node = elem.parentNode.childNodes[i];
          if (node === elem) {
            return i;
          }
        }
      }

      function getMacroMatch(ctx, macros) {
        var selected, path = [],
          offset;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          selected = getDocument(ctx).activeElement;
        } else {
          var selectionInfo = getContentEditableSelectedPath(ctx);
          if (selectionInfo) {
            selected = selectionInfo.selected;
            path = selectionInfo.path;
            offset = selectionInfo.offset;
          }
        }
        var effectiveRange = getTextPrecedingCurrentSelection(ctx);
        if (effectiveRange !== undefined && effectiveRange !== null) {
          var matchInfo;
          var hasTrailingSpace = false;
          if (effectiveRange.length > 0 &&
            (effectiveRange.charAt(effectiveRange.length - 1) === '\xA0' ||
              effectiveRange.charAt(effectiveRange.length - 1) === ' ')) {
            hasTrailingSpace = true;
            effectiveRange = effectiveRange.substring(0, effectiveRange.length - 1);
          }
          angular.forEach(macros, function(macro, c) {
            var idx = effectiveRange.toUpperCase().lastIndexOf(c.toUpperCase());
            if (idx >= 0 && c.length + idx === effectiveRange.length) {
              var prevCharPos = idx - 1;
              if (idx === 0 || effectiveRange.charAt(prevCharPos) === '\xA0' ||
                effectiveRange.charAt(prevCharPos) === ' ') {
                matchInfo = {
                  macroPosition: idx,
                  macroText: c,
                  macroSelectedElement: selected,
                  macroSelectedPath: path,
                  macroSelectedOffset: offset,
                  macroHasTrailingSpace: hasTrailingSpace
                };
              }
            }
          });
          if (matchInfo) {
            return matchInfo;
          }
        }
      }

      function getContentEditableSelectedPath(ctx) {
        var sel = getWindowSelection(ctx);
        var selected = sel.anchorNode;
        var path = [];
        var offset;
        if (selected != null) {
          var i;
          var ce = selected.contentEditable;
          while (selected !== null && ce !== 'true') {
            i = getNodePositionInParent(ctx, selected);
            path.push(i);
            selected = selected.parentNode;
            if (selected !== null) {
              ce = selected.contentEditable;
            }
          }
          path.reverse();
          offset = sel.getRangeAt(0).startOffset;
          return {
            selected: selected,
            path: path,
            offset: offset
          };
        }
      }

      function getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, menuAlreadyActive, hasTrailingSpace) {
        var selected, path, offset;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          selected = getDocument(ctx).activeElement;
        } else {
          var selectionInfo = getContentEditableSelectedPath(ctx);
          if (selectionInfo) {
            selected = selectionInfo.selected;
            path = selectionInfo.path;
            offset = selectionInfo.offset;
          }
        }
        var effectiveRange = getTextPrecedingCurrentSelection(ctx);
        if (effectiveRange !== undefined && effectiveRange !== null) {
          var mostRecentTriggerCharPos = -1;
          var triggerChar;
          triggerCharSet.forEach(function(c) {
            var idx = effectiveRange.lastIndexOf(c);
            if (idx > mostRecentTriggerCharPos) {
              mostRecentTriggerCharPos = idx;
              triggerChar = c;
            }
          });
          if (mostRecentTriggerCharPos >= 0 &&
            (
              mostRecentTriggerCharPos === 0 ||
              !requireLeadingSpace ||
              /[\xA0\s]/g.test(
                effectiveRange.substring(
                  mostRecentTriggerCharPos - 1,
                  mostRecentTriggerCharPos)
              )
            )
          ) {
            var currentTriggerSnippet = effectiveRange.substring(mostRecentTriggerCharPos + 1,
              effectiveRange.length);
            triggerChar = effectiveRange.substring(mostRecentTriggerCharPos, mostRecentTriggerCharPos + 1);
            var firstSnippetChar = currentTriggerSnippet.substring(0, 1);
            var leadingSpace = currentTriggerSnippet.length > 0 &&
              (
                firstSnippetChar === ' ' ||
                firstSnippetChar === '\xA0'
              );
            if (hasTrailingSpace) {
              currentTriggerSnippet = currentTriggerSnippet.trim();
            }
            if (!leadingSpace && (menuAlreadyActive || !(/[\xA0\s]/g.test(currentTriggerSnippet)))) {
              return {
                mentionPosition: mostRecentTriggerCharPos,
                mentionText: currentTriggerSnippet,
                mentionSelectedElement: selected,
                mentionSelectedPath: path,
                mentionSelectedOffset: offset,
                mentionTriggerChar: triggerChar
              };
            }
          }
        }
      }

      function getWindowSelection(ctx) {
        if (!ctx) {
          return window.getSelection();
        } else {
          return ctx.iframe.contentWindow.getSelection();
        }
      }

      function getDocument(ctx) {
        if (!ctx) {
          return document;
        } else {
          return ctx.iframe.contentWindow.document;
        }
      }

      function getTextPrecedingCurrentSelection(ctx) {
        var text;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          var textComponent = getDocument(ctx).activeElement;
          var startPos = textComponent.selectionStart;
          text = textComponent.value.substring(0, startPos);
        } else {
          var selectedElem = getWindowSelection(ctx).anchorNode;
          if (selectedElem != null) {
            var workingNodeContent = selectedElem.textContent;
            var selectStartOffset = getWindowSelection(ctx).getRangeAt(0).startOffset;
            if (selectStartOffset >= 0) {
              text = workingNodeContent.substring(0, selectStartOffset);
            }
          }
        }
        return text;
      }

      function getContentEditableCaretPosition(ctx, selectedNodePosition) {
        var markerTextChar = '\ufeff';
        var markerEl, markerId = 'sel_' + new Date().getTime() + '_' + Math.random().toString().substr(2);
        var range;
        var sel = getWindowSelection(ctx);
        var prevRange = sel.getRangeAt(0);
        range = getDocument(ctx).createRange();
        range.setStart(sel.anchorNode, selectedNodePosition);
        range.setEnd(sel.anchorNode, selectedNodePosition);
        range.collapse(false);
        markerEl = getDocument(ctx).createElement('span');
        markerEl.id = markerId;
        markerEl.appendChild(getDocument(ctx).createTextNode(markerTextChar));
        range.insertNode(markerEl);
        sel.removeAllRanges();
        sel.addRange(prevRange);
        var coordinates = {
          left: 0,
          top: markerEl.offsetHeight
        };
        localToGlobalCoordinates(ctx, markerEl, coordinates);
        markerEl.parentNode.removeChild(markerEl);
        return coordinates;
      }

      function localToGlobalCoordinates(ctx, element, coordinates) {
        var obj = element;
        var iframe = ctx ? ctx.iframe : null;
        while (obj) {
          coordinates.left += obj.offsetLeft;
          coordinates.top += obj.offsetTop;
          if (obj !== getDocument().body) {
            coordinates.top -= obj.scrollTop;
            coordinates.left -= obj.scrollLeft;
          }
          obj = obj.offsetParent;
          if (!obj && iframe) {
            obj = iframe;
            iframe = null;
          }
        }
      }

      function getTextAreaOrInputUnderlinePosition(ctx, element, position) {
        var properties = [
          'direction',
          'boxSizing',
          'width',
          'height',
          'overflowX',
          'overflowY',
          'borderTopWidth',
          'borderRightWidth',
          'borderBottomWidth',
          'borderLeftWidth',
          'paddingTop',
          'paddingRight',
          'paddingBottom',
          'paddingLeft',
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'fontStretch',
          'fontSize',
          'fontSizeAdjust',
          'lineHeight',
          'fontFamily',
          'textAlign',
          'textTransform',
          'textIndent',
          'textDecoration',
          'letterSpacing',
          'wordSpacing'
        ];
        var isFirefox = (window.mozInnerScreenX !== null);
        var div = getDocument(ctx).createElement('div');
        div.id = 'input-textarea-caret-position-mirror-div';
        getDocument(ctx).body.appendChild(div);
        var style = div.style;
        var computed = window.getComputedStyle ? getComputedStyle(element) : element.currentStyle;
        style.whiteSpace = 'pre-wrap';
        if (element.nodeName !== 'INPUT') {
          style.wordWrap = 'break-word';
        }
        style.position = 'absolute';
        style.visibility = 'hidden';
        properties.forEach(function(prop) {
          style[prop] = computed[prop];
        });
        if (isFirefox) {
          style.width = (parseInt(computed.width) - 2) + 'px';
          if (element.scrollHeight > parseInt(computed.height))
            style.overflowY = 'scroll';
        } else {
          style.overflow = 'hidden';
        }
        div.textContent = element.value.substring(0, position);
        if (element.nodeName === 'INPUT') {
          div.textContent = div.textContent.replace(/\s/g, '\u00a0');
        }
        var span = getDocument(ctx).createElement('span');
        span.textContent = element.value.substring(position) || '.';
        div.appendChild(span);
        var coordinates = {
          top: span.offsetTop + parseInt(computed.borderTopWidth) + parseInt(computed.fontSize),
          left: span.offsetLeft + parseInt(computed.borderLeftWidth)
        };
        localToGlobalCoordinates(ctx, element, coordinates);
        getDocument(ctx).body.removeChild(div);
        return coordinates;
      }
      return {
        popUnderMention: popUnderMention,
        replaceMacroText: replaceMacroText,
        replaceTriggerText: replaceTriggerText,
        getMacroMatch: getMacroMatch,
        getTriggerInfo: getTriggerInfo,
        selectElement: selectElement,
        getTextAreaOrInputUnderlinePosition: getTextAreaOrInputUnderlinePosition,
        getTextPrecedingCurrentSelection: getTextPrecedingCurrentSelection,
        getContentEditableSelectedPath: getContentEditableSelectedPath,
        getNodePositionInParent: getNodePositionInParent,
        getContentEditableCaretPosition: getContentEditableCaretPosition,
        pasteHtml: pasteHtml,
        resetSelection: resetSelection,
        scrollIntoView: scrollIntoView
      };
    }]);
  angular.module("mentio").run(["$templateCache", function($templateCache) {
    $templateCache.put("mentio-menu.tpl.html", "<style>\n.scrollable-menu {\n    height: auto;\n    max-height: 300px;\n    overflow: auto;\n}\n\n.menu-highlighted {\n    font-weight: bold;\n}\n</style>\n<ul class=\"dropdown-menu scrollable-menu\" style=\"display:block\">\n    <li mentio-menu-item=\"item\" ng-repeat=\"item in items track by $index\">\n        <a class=\"text-primary\" ng-bind-html=\"item.label | mentioHighlight:typedTerm:\'menu-highlighted\' | unsafe\"></a>\n    </li>\n</ul>");
  }]);
})();
/*! RESOURCE: /scripts/sn/common/stream/_module.js */
angular.module("sn.common.stream", ['sn.base', 'ng.amb', 'sn.messaging', 'sn.common.glide', 'ngSanitize',
  'sn.common.avatar', 'sn.common.ui.popover', 'mentio', 'sn.common.controls', 'sn.common.user_profile',
  'sn.common.datetime', 'sn.common.mention', 'sn.common.ui'
]);
angular.module("sn.stream.direct", ['sn.common.stream']);;
/*! RESOURCE: /scripts/sn/common/stream/controller.Stream.js */
angular.module("sn.common.stream").controller("Stream", function($scope, snRecordWatcher, $timeout) {
  var isForm = NOW.sysId.length > 0;
  $scope.showCommentsAndWorkNotes = isForm;
  $scope.sessions = {};
  $scope.recordStreamOpen = false;
  $scope.streamHidden = true;
  $scope.recordSysId = '';
  $scope.recordDisplayValue = '';
  $scope.$on('record.updated', onRecordUpdated);
  $scope.$on('sn.sessions', onSessions);
  $timeout(function() {
    if (isForm)
      snRecordWatcher.initRecord(NOW.targetTable, NOW.sysId);
    else
      snRecordWatcher.initList(NOW.targetTable, NOW.tableQuery);
  }, 100);
  $scope.controls = {
    showRecord: function($event, entry, sysId) {
      if (sysId !== '')
        return;
      if ($event.currentTarget != $event.target && $event.target.tagName == 'A')
        return;
      $scope.recordSysId = entry.document_id;
      $scope.recordDisplayValue = entry.display_value;
      $scope.recordStreamOpen = true;
      $scope.streamHidden = true;
    },
    openRecord: function() {
      var targetFrame = window.self;
      var url = NOW.targetTable + ".do?sys_id=" + $scope.recordSysId;
      if (NOW.linkTarget == 'form_pane') {
        url += "&sysparm_clear_stack=true";
        window.parent.CustomEvent.fireTop(
          "glide:nav_open_url", {
            url: url,
            openInForm: true
          });
        return;
      }
      if (NOW.streamLinkTarget == 'parent' || NOW.concourse == 'true')
        targetFrame = window.parent;
      targetFrame.location = url;
    },
    openAttachment: function(event, sysId) {
      event.stopPropagation();
      var url = "/sys_attachment.do?view=true&sys_id=" + sysId;
      var newTab = window.open(url, '_blank');
      newTab.focus();
    }
  };
  $scope.sessionCount = function() {
    $scope.sessions.length = Object.keys($scope.sessions.data).length;
    return $scope.sessions.length;
  };

  function onSessions(name, sessions) {
    $scope.sessions.data = sessions;
    $scope.sessionCount();
  }

  function onRecordUpdated(name, data) {}
  $scope.showListStream = function() {
    $scope.recordStreamOpen = false;
    $scope.recordHidden = false;
    $scope.streamHidden = false;
    angular.element('div.list-stream-record').velocity('snTransition.streamSlideRight', {
      duration: 400
    });
    angular.element('[streamType="list"]').velocity('snTransition.slideIn', {
      duration: 400,
      complete: function(element) {
        angular.element(element).css({
          display: 'block'
        });
      }
    });
  };
  $scope.$watch(function() {
    return angular.element('div.list-stream-record').length
  }, function(newValue, oldValue) {
    if (newValue == 1) {
      angular.element('div.list-stream-record').delay(100).velocity('snTransition.streamSlideLeft', {
        begin: function(element) {
          angular.element(element).css({
            visibility: 'visible'
          });
          angular.element('.list-stream-record-header').css({
            visibility: 'visible'
          });
        },
        duration: 400,
        complete: function(element) {
          angular.element(element).css({
            transform: "translateX(0)"
          });
          angular.element(element).scrollTop(0);
          angular.element(element).css({
            transform: "initial"
          });
        }
      });
    }
  });
});;
/*! RESOURCE: /scripts/sn/common/stream/directive.snStream.js */
angular.module("sn.common.stream").directive("snStream", function(getTemplateUrl, $http, $sce, $sanitize) {
  "use strict";
  return {
    restrict: "E",
    replace: true,
    scope: {
      table: "=",
      query: "=?",
      sysId: "=?",
      active: "=",
      controls: "=?",
      showCommentsAndWorkNotes: "=?",
      previousActivity: "=?",
      sessions: "=",
      attachments: "=",
      board: "=",
      formJournalFields: "=",
      useMultipleInputs: "=?",
      preferredInput: "=",
      labels: "=",
      subStream: "=",
      expandEntries: "=",
      scaleAnimatedGifs: "=",
      scaleImages: "=",
      pageSize: "=",
      maxEntries: "@"
    },
    templateUrl: getTemplateUrl("ng_activity_stream.xml"),
    controller: function($scope, $attrs, nowStream, snRecordPresence, snCustomEvent, userPreferences, $window, $q, $timeout, snMention, i18n) {
      var stream;
      var processor = $attrs.processor || "list_history";
      var interval;
      var FROM_LIST = 'from_list';
      var FROM_FORM = 'from_form';
      var source = $scope.sysId ? FROM_FORM : FROM_LIST;
      var amb = false;
      var _firstPoll = true;
      var _firstPollTimeout;
      var primaryJournalFieldOrder = ["comments", "work_notes"];
      var primaryJournalField = null;
      $scope.defaultShowCommentsAndWorkNotes = ($scope.sysId != null && !angular.isUndefined($scope.sysId) && $scope.sysId.length > 0);
      $scope.canWriteWorkNotes = false;
      $scope.inputTypeValue = "";
      $scope.entryTemplate = getTemplateUrl($attrs.template || "list_stream_entry");
      $scope.isFormStream = $attrs.template === "record_stream_entry.xml";
      $scope.allFields = null;
      $scope.fields = null;
      $scope.fieldColor = "transparent";
      $scope.multipleInputs = $scope.useMultipleInputs;
      var typing = '{0} is typing',
        viewing = '{0} is viewing',
        entered = '{0} has entered';
      var probablyLeft = '{0} has probably left',
        exited = '{0} has exited',
        offline = '{0} is offline';
      i18n.getMessages(
        [
          typing,
          viewing,
          entered,
          probablyLeft,
          exited,
          offline
        ],
        function(results) {
          typing = results[typing];
          viewing = results[viewing];
          entered = results[entered];
          probablyLeft = results[probablyLeft];
          exited = results[exited];
          offline = results[offline];
        }
      );
      $scope.emailClientOpenPop = function(replyType, replyID) {
        if (!$scope.sysId)
          return;
        var url = new GlideURL("email_client.do");
        url.addParam("sysparm_table", $scope.table);
        url.addParam("sysparm_sys_id", $scope.sysId);
        url.addParam("sysparm_target", $scope.table);
        if (replyType != null) {
          url.addParam("replytype", replyType);
          url.addParam("replyid", replyID);
        }
        if (popupOpenEmailClient) {
          popupOpenEmailClient(url.getURL() + g_form.serializeChangedAll());
        }
      };
      $scope.parsePresence = function(sessionData) {
        var status = sessionData.status;
        var name = sessionData.user_display_name;
        switch (status) {
          case 'typing':
            return i18n.format(typing, name);
          case 'viewing':
            return i18n.format(viewing, name);
          case 'entered':
            return i18n.format(entered, name);
          case 'probably left':
            return i18n.format(probablyLeft, name);
          case 'exited':
            return i18n.format(exited, name);
          case 'offline':
            return i18n.format(offline, name);
          default:
            return '';
        }
      };
      $scope.members = [];
      $scope.members.loading = true;
      var mentionMap = {};
      $scope.selectAtMention = function(item) {
        if (item.termLengthIsZero)
          return (item.name || "") + "\n";
        mentionMap[item.name] = item.sys_id;
        return "@[" + item.name + "]";
      };
      var typingTimer;
      $scope.searchMembersAsync = function(term) {
        $scope.members = [];
        $scope.members.loading = true;
        $timeout.cancel(typingTimer);
        if (term.length === 0) {
          $scope.members = [{
            termLengthIsZero: true
          }];
          $scope.members.loading = false;
        } else {
          typingTimer = $timeout(function() {
            snMention.retrieveMembers($scope.table, $scope.sysId, term).then(function(members) {
              $scope.members = members;
              $scope.members.loading = false;
            }, function() {
              $scope.members = [{
                termLengthIsZero: true
              }];
              $scope.members.loading = false;
            });
          }, 500);
        }
      };
      $scope.expandMentions = function(text) {
        return stream.expandMentions(text, mentionMap)
      }
      $scope.reduceMentions = function(text) {
        if (!text)
          return text;
        var regexMentionParts = /[\w\d\s/\']+/gi;
        text = text.replace(/@\[[\w\d\s]+:[\w\d\s/\']+\]/gi, function(mention) {
          var mentionParts = mention.match(regexMentionParts);
          if (mentionParts.length === 2) {
            var name = mentionParts[1];
            var userID = mentionParts[0];
            mentionMap[name] = userID;
            return "@[" + name + "]";
          }
          return mentionParts;
        });
        return text;
      }
      $scope.parseMentions = function(entry) {
        var regexMentionParts = /[\w\d\s/\']+/gi;
        entry = entry.replace(/@\[[\w\d\s]+:[\w\d\s/\']+\]/gi, function(mention) {
          var mentionParts = mention.match(regexMentionParts);
          if (mentionParts.length === 2) {
            return '<a class="at-mention at-mention-user-' + mentionParts[0] + '">@' + mentionParts[1] + '</a>';
          }
          return mentionParts;
        });
        return entry;
      };
      $scope.parseLinks = function(text) {
        var regexLinks = /@L\[([^|]+?)\|([^\]]*)]/gi;
        return text.replace(regexLinks, "<a href='$1' target='_blank'>$2</a>");
      };
      $scope.parseSpecial = function(text) {
        var parsedText = $scope.parseLinks($sanitize(text));
        parsedText = $scope.parseMentions(parsedText);
        return $sce.trustAsHtml(parsedText);
      };
      $scope.getFullEntryValue = function(entry, event) {
        event.stopPropagation();
        var index = getEntryIndex(entry);
        var journal = $scope.entries[index].entries.journal[0];
        journal.loading = true;
        $http.get('/api/now/ui/stream_entry/full_entry', {
          params: {
            sysparm_sys_id: journal.sys_id
          }
        }).then(function(response) {
          journal.new_value = response.data.result.replace(/\n/g, '<br/>');
          journal.is_truncated = false;
          journal.loading = false;
          journal.showMore = true;
        });
      };

      function getEntryIndex(entry) {
        for (var i = 0, l = $scope.entries.length; i < l; i++) {
          if (entry === $scope.entries[i]) {
            return i;
          }
        }
      }
      $scope.$watch('active', function(n, o) {
        if (n === o)
          return;
        if ($scope.active)
          startPolling();
        else
          cancelStream();
      });
      $scope.defaultControls = {
        getTitle: function(entry) {
          if (entry && entry.short_description) {
            return entry.short_description;
          } else if (entry && entry.shortDescription) {
            return entry.shortDescription;
          }
        },
        showCreatedBy: function() {
          return true;
        },
        hideCommentLabel: function(journal) {
          return false;
        },
        showRecord: function($event, entry) {},
        showRecordLink: function() {
          return true;
        }
      };
      if ($scope.controls) {
        for (var attr in $scope.controls) {
          $scope.defaultControls[attr] = $scope.controls[attr];
        }
      }
      $scope.controls = $scope.defaultControls;
      if ($scope.showCommentsAndWorkNotes === undefined) {
        $scope.showCommentsAndWorkNotes = $scope.defaultShowCommentsAndWorkNotes;
      }
      snCustomEvent.observe('sn.stream.change_input_display', function(table, display) {
        if (table != $scope.table)
          return;
        $scope.showCommentsAndWorkNotes = display;
        $scope.$apply();
      });
      $scope.$on("$destroy", function() {
        cancelStream();
      });
      $scope.$on('sn.stream.interval', function($event, time) {
        interval = time;
        reschedulePoll();
      });
      $scope.$on("sn.stream.tap", function() {
        if (stream)
          stream.tap();
        else
          startPolling();
      });
      $scope.$on('window_visibility_change', function($event, hidden) {
        interval = (hidden) ? 120000 : undefined;
        reschedulePoll();
      });
      $scope.$on("sn.stream.refresh", function(event, data) {
        stream._successCallback(data.response);
      });
      $scope.$on("sn.stream.reload", function() {
        startPolling();
      });
      $scope.$on('sn.stream.input_value', function(otherScope, value) {
        $scope.inputTypeValue = value;
      });
      $scope.$watchCollection('[table, query, sysId]', startPolling);
      $scope.changeInputType = function(field) {
        $scope.inputType = field.checked ? field.name : primaryJournalField;
        userPreferences.setPreference('glide.ui.' + $scope.table + '.stream_input', $scope.inputType);
      };
      $scope.$watch('inputType', function() {
        if (!$scope.inputType || !$scope.preferredInput)
          return;
        $scope.preferredInput = $scope.inputType;
      });
      $scope.submitCheck = function(event) {
        var key = event.keyCode || event.which;
        if (key === 13) {
          $scope.postJournalEntryForCurrent(event);
        }
      };
      $scope.postJournalEntry = function(type, entry, event) {
        type = type || primaryJournalFieldOrder[0];
        event.stopPropagation();
        var requestTable = $scope.table || "board:" + $scope.board.sys_id;
        stream.insertForEntry(type, entry.journalText, requestTable, entry.document_id);
        entry.journalText = "";
        entry.commentBoxVisible = false;
        snRecordPresence.termPresence();
      };
      $scope.postJournalEntryForCurrent = function(event) {
        event.stopPropagation();
        var entries = [];
        if ($scope.multipleInputs) {
          angular.forEach($scope.fields, function(item) {
            if (!item.value)
              return;
            entries.push({
              field: item.name,
              text: item.value
            });
          })
        } else {
          entries.push({
            field: $scope.inputType,
            text: $scope.inputTypeValue
          })
        }
        var request = stream.insertEntries(entries, $scope.table, $scope.sysId, mentionMap);
        if (request) {
          request.then(function() {
            for (var i = 0; i < entries.length; i++) {
              fireInsertEvent(entries[i].field, entries[i].text);
            }
          });
        }
        clearInputs();
        return false;
      };

      function fireInsertEvent(name, value) {
        snCustomEvent.fire('sn.stream.insert', name, value);
      }

      function clearInputs() {
        $scope.inputTypeValue = "";
        angular.forEach($scope.fields, function(item) {
          if (item.value)
            item.filled = true;
          item.value = "";
        });
      }
      $scope.showCommentBox = function(entry, event) {
        event.stopPropagation();
        if (entry !== $scope.selectedEntry)
          $scope.closeEntry();
        $scope.selectedEntry = entry;
        entry.commentBoxVisible = !entry.commentBoxVisible;
        if (entry.commentBoxVisible) {
          snRecordPresence.initPresence($scope.table, entry.document_id);
        }
      };
      $scope.showMore = function(journal, event) {
        event.stopPropagation();
        journal.showMore = true;
      };
      $scope.showLess = function(journal, event) {
        event.stopPropagation();
        journal.showMore = false;
      };
      $scope.closeEntry = function() {
        if ($scope.selectedEntry)
          $scope.selectedEntry.commentBoxVisible = false;
      };
      $scope.previewAttachment = function(evt, attachmentUrl) {
        snCustomEvent.fire('sn.attachment.preview', evt, attachmentUrl);
      }
      $scope.$on('sn.sessions', function(someOtherScope, sessions) {
        if ($scope.selectedEntry && $scope.selectedEntry.commentBoxVisible)
          $scope.selectedEntry.sessions = sessions;
      });
      $scope.$watch("inputTypeValue", function() {
        emitTyping($scope.inputTypeValue);
      });
      $scope.$watch("selectedEntry.journalText", function(newValue) {
        if ($scope.selectedEntry)
          emitTyping(newValue || "");
      });
      $scope.$watch('useMultipleInputs', function() {
        setMultipleInputs();
      });

      function emitTyping(inputValue) {
        var status = inputValue.length ? "typing" : "viewing";
        $scope.$emit("record.typing", {
          status: status,
          value: inputValue,
          table: $scope.table,
          sys_id: $scope.sys_id
        });
      }

      function preloadedData() {
        if (typeof window.NOW.snActivityStreamData === 'object' &&
          window.NOW.snActivityStreamData[$scope.table + '_' + $scope.sysId]) {
          _firstPoll = false;
          var data = window.NOW.snActivityStreamData[$scope.table + '_' + $scope.sysId];
          stream = nowStream.create($scope.table, $scope.query, $scope.sysId,
            processor, interval, source, $scope.attachments);
          stream.callback = onPoll;
          stream.preRequestCallback = beforePoll;
          stream.lastTimestamp = data.sys_timestamp;
          if (data.entries && data.entries.length) {
            stream.lastEntry = angular.copy(data.entries[0]);
          }
          _firstPollTimeout = setTimeout(function() {
            stream.poll(onPoll, beforePoll);
            _firstPollTimeout = false;
          }, 20000);
          beforePoll();
          onPoll(data);
          return true;
        }
        return false;
      }

      function scheduleNewPoll(lastTimestamp) {
        cancelStream();
        stream = nowStream.create($scope.table, $scope.query, $scope.sysId,
          processor, interval, source, $scope.attachments);
        stream.lastTimestamp = lastTimestamp;
        stream.poll(onPoll, beforePoll);
      }

      function reschedulePoll() {
        var lastTimestamp = stream ? stream.lastTimestamp : 0;
        if (cancelStream()) {
          scheduleNewPoll(lastTimestamp);
        }
      }

      function reset() {
        $scope.loaded = false;
        startPolling();
      }

      function startPolling() {
        if ($scope.loading && !$scope.loaded)
          return;
        if (!$scope.active)
          return;
        $scope.entries = [];
        $scope.allEntries = [];
        $scope.showAllEntriesButton = false;
        $scope.loaded = false;
        $scope.loading = true;
        if (_firstPoll && preloadedData()) {
          return;
        }
        scheduleNewPoll();
      }

      function onPoll(response) {
        $scope.loading = false;
        if (response.primary_fields)
          primaryJournalFieldOrder = response.primary_fields;
        if (!$scope.fields)
          processFields(response.fields);
        processEntries(response.entries);
        if (!$scope.loaded) {
          $scope.loaded = true;
          $scope.$emit("sn.stream.loaded", response);
        }
      }

      function beforePoll() {
        $scope.$emit("sn.stream.requested");
      }

      function processFields(fields) {
        if (!fields || !fields.length)
          return;
        $scope.fields = {};
        $scope.allFields = fields;
        setShowAllFields();
        $scope.fieldsVisible = 0;
        var i = 0;
        angular.forEach(fields, function(field) {
          if (!field.isJournal)
            return;
          if (i == 0)
            $scope.firstJournal = field.name;
          i++;
          $scope.fields[field.name] = field;
          $scope.fields[field.name].visible = $scope.formJournalFields ? false : true;
          if ($scope.fields[field.name].visible)
            $scope.fieldsVisible++;
          var fieldColor = field.color;
          if (fieldColor)
            fieldColor = field.color.replace(/background-color: /, '')
          if (!fieldColor || fieldColor == 'transparent')
            fieldColor = null;
          $scope.fields[field.name].color = fieldColor;
        });
        setFieldVisibility();
        setPrimaryJournalField();
        setMultipleInputs();
      }
      $scope.$watch('formJournalFields', function() {
        setFieldVisibility();
        setPrimaryJournalField();
        setMultipleInputs();
      }, true);

      function setFieldVisibility() {
        if (!$scope.formJournalFields || !$scope.fields || !$scope.showCommentsAndWorkNotes)
          return;
        $scope.fieldsVisible = 0;
        angular.forEach($scope.formJournalFields, function(formField) {
          if (!$scope.fields[formField.name])
            return;
          $scope.fields[formField.name].value = formField.value;
          $scope.fields[formField.name].mandatory = formField.mandatory;
          $scope.fields[formField.name].label = formField.label;
          $scope.fields[formField.name].messages = formField.messages;
          $scope.fields[formField.name].visible = formField.visible && !formField.readonly;
          if ($scope.fields[formField.name].visible)
            $scope.fieldsVisible++;
        });
      }

      function setPrimaryJournalField() {
        if (!$scope.fields || !$scope.showCommentsAndWorkNotes)
          return;
        angular.forEach($scope.fields, function(item) {
          item.isPrimary = false;
        });
        var visibleFields = Object.keys($scope.fields).filter(function(item) {
          return $scope.fields[item].visible;
        });
        if (visibleFields.indexOf($scope.preferredInput) != -1) {
          $scope.inputType = $scope.preferredInput;
          $scope.fields[$scope.preferredInput].checked = true;
        }
        for (var i = 0; i < primaryJournalFieldOrder.length; i++) {
          var fieldName = primaryJournalFieldOrder[i];
          if (visibleFields.indexOf(fieldName) != -1) {
            $scope.fields[fieldName].isPrimary = true;
            primaryJournalField = fieldName;
            if (!$scope.inputType)
              $scope.inputType = fieldName;
            break;
          }
        }
        if (!$scope.inputType && visibleFields.length > 0) {
          primaryJournalField = visibleFields[0];
          $scope.inputType = primaryJournalField;
          $scope.fields[primaryJournalField].isPrimary = true;
        }
      }

      function setShowAllFields() {
        $scope.showAllFields = $scope.allFields && !$scope.allFields.some(function(item) {
          return !item.isActive;
        });
        $scope.hideAllFields = !$scope.allFields || !$scope.allFields.some(function(item) {
          return item.isActive;
        });
      }
      $scope.setPrimary = function(entry) {
        angular.forEach($scope.fields, function(item) {
          item.checked = false;
        });
        for (var i = 0; i < primaryJournalFieldOrder.length; i++) {
          var fieldName = primaryJournalFieldOrder[i];
          if (entry.writable_journal_fields.indexOf(fieldName) != -1) {
            entry.primaryJournalField = fieldName;
            entry.inputType = fieldName;
            return;
          }
        }
        if (!entry.inputType) {
          var primaryField = entry.writable_journal_fields[0];
          entry.primaryJournalField = primaryField;
          entry.inputType = primaryField;
        }
      }
      $scope.updateFieldVisibilityAll = function() {
        $scope.showAllFields = !$scope.showAllFields;
        angular.forEach($scope.allFields, function(item) {
          item.isActive = $scope.showAllFields;
        });
        $scope.updateFieldVisibility();
      }
      $scope.updateFieldVisibility = function() {
        var activeFields = $scope.allFields.filter(function(item) {
          return item.isActive;
        }).map(function(item) {
          return item.name + ',' + item.isActive;
        });
        setShowAllFields();
        userPreferences
          .setPreference($scope.table + '.activity.filter', activeFields.join(';'))
          .then(function() {
            reset();
          })
      }
      $scope.configureAvailableFields = function() {
        $window.personalizer($scope.table, 'activity', $scope.sysId);
      }
      $scope.toggleMultipleInputs = function(val) {
        userPreferences.setPreference('glide.ui.activity_stream.multiple_inputs', val ? 'true' : 'false')
          .then(function() {
            $scope.useMultipleInputs = val;
            setMultipleInputs();
          });
      };
      $scope.changeEntryInputType = function(fieldName, entry) {
        var checked = $scope.fields[fieldName].checked;
        entry.inputType = checked ? fieldName : entry.primaryJournalField;
      };

      function processEntries(entries) {
        if (!entries || !entries.length)
          return;
        entries = entries.reverse();
        var newEntries = [];
        angular.forEach(entries, function(entry) {
          var entriesToAdd = [entry];
          if (entry.attachment) {
            entry.type = getAttachmentType(entry.attachment);
            entry.attachment.extension = getAttachmentExt(entry.attachment);
          } else if (entry.is_email === true) {
            entry.email = {};
            var allFields = entry.entries.custom;
            for (var i = 0; i < allFields.length; i++) {
              entry.email[allFields[i].field_name] = {
                label: allFields[i]['field_label'],
                displayValue: allFields[i]['new_value']
              };
            }
            entry['entries'].custom = [];
          } else if ($scope.sysId) {
            entriesToAdd = extractJournalEntries(entry);
          } else {
            entriesToAdd = handleJournalEntriesWithoutExtraction(entry);
          }
          if (entriesToAdd instanceof Array) {
            entriesToAdd.forEach(function(e) {
              $scope.entries.unshift(e);
              newEntries.unshift(e);
            });
          } else {
            $scope.entries.unshift(entriesToAdd);
            newEntries.unshift(entriesToAdd)
          }
          if (source != FROM_FORM)
            $scope.entries = $scope.entries.slice(0, 49);
          if ($scope.maxEntries != undefined) {
            var maxNumEntries = parseInt($scope.maxEntries, 10);
            $scope.entries = $scope.entries.slice(0, maxNumEntries);
          }
        });
        if ($scope.loaded) {
          $scope.$emit("sn.stream.new_entries", newEntries);
          triggerResize();
        } else if ($scope.pageSize && $scope.entries.length > $scope.pageSize)
          setUpPaging();
      }

      function setUpPaging() {
        $scope.showAllEntriesButton = true;
        $scope.allEntries = $scope.entries;
        $scope.entries = [];
        loadEntries(0, $scope.pageSize);
      }
      $scope.loadMore = function() {
        if ($scope.entries.length + $scope.pageSize > $scope.allEntries.length) {
          $scope.loadAll();
          return;
        }
        loadEntries($scope.loadedEntries, $scope.loadedEntries + $scope.pageSize);
      }
      $scope.loadAll = function() {
        $scope.showAllEntriesButton = false;
        loadEntries($scope.loadedEntries, $scope.allEntries.length);
      }

      function loadEntries(start, end) {
        $scope.entries = $scope.entries.concat($scope.allEntries.slice(start, end));
        $scope.loadedEntries = $scope.entries.length;
      }

      function getAttachmentType(attachment) {
        if (attachment.content_type.startsWith('image/') && attachment.size_bytes < 5 * 1024 * 1024 && attachment.path.indexOf(attachment.sys_id) == 0)
          return 'attachment-image';
        return 'attachment';
      }

      function getAttachmentExt(attachment) {
        var filename = attachment.file_name;
        return filename.substring(filename.lastIndexOf('.') + 1);
      }

      function handleJournalEntriesWithoutExtraction(oneLargeEntry) {
        if (oneLargeEntry.entries.journal.length === 0)
          return oneLargeEntry;
        for (var i = 0; i < oneLargeEntry.entries.journal.length; i++) {
          newLinesToBR(oneLargeEntry.entries.journal);
        }
        return oneLargeEntry;
      }

      function extractJournalEntries(oneLargeEntry) {
        var smallerEntries = [];
        if (oneLargeEntry.entries.journal.length === 0)
          return oneLargeEntry;
        for (var i = 0; i < oneLargeEntry.entries.journal.length; i++) {
          var journalEntry = angular.copy(oneLargeEntry);
          journalEntry.entries.journal = journalEntry.entries.journal.slice(i, i + 1);
          newLinesToBR(journalEntry.entries.journal);
          journalEntry.entries.changes = [];
          journalEntry.type = 'journal';
          smallerEntries.unshift(journalEntry);
        }
        oneLargeEntry.entries.journal = [];
        oneLargeEntry.type = 'changes';
        if (oneLargeEntry.entries.changes.length > 0)
          smallerEntries.unshift(oneLargeEntry);
        return smallerEntries;
      }

      function newLinesToBR(entries) {
        angular.forEach(entries, function(item) {
          if (!item.new_value)
            return;
          item.new_value = item.new_value.replace(/\n/g, '<br/>');
        });
      }

      function cancelStream() {
        if (_firstPollTimeout) {
          clearTimeout(_firstPollTimeout);
          _firstPollTimeout = false;
        }
        if (!stream)
          return false;
        stream.cancel();
        stream = null;
        return true;
      }

      function setMultipleInputs() {
        $scope.multipleInputs = $scope.useMultipleInputs;
        if ($scope.useMultipleInputs === true || !$scope.formJournalFields) {
          return;
        }
        var numAffectedFields = 0;
        angular.forEach($scope.formJournalFields, function(item) {
          if (item.mandatory || item.value)
            numAffectedFields++;
        });
        if (numAffectedFields > 0)
          $scope.multipleInputs = true;
      }

      function triggerResize() {
        if (window._frameChanged)
          setTimeout(_frameChanged, 0);
      }
    },
    link: function(scope, element) {
      element.on("click", ".at-mention", function(evt) {
        var userID = angular.element(evt.target).attr('class').substring("at-mention at-mention-user-".length);
        $http({
          url: '/api/now/form/mention/user/' + userID,
          method: "GET"
        }).then(function(response) {
          scope.showPopover = true;
          scope.mentionPopoverProfile = response.data.result;
          scope.clickEvent = evt;
        }, function() {
          $http({
            url: '/api/now/live/profiles/' + userID,
            method: "GET"
          }).then(function(response) {
            scope.showPopover = true;
            var tempProfile = response.data.result;
            tempProfile.userID = tempProfile.sys_id = response.data.result.document;
            scope.mentionPopoverProfile = tempProfile;
            scope.mentionPopoverProfile.sysID = response.data.result["userID"];
            scope.clickEvent = evt;
          })
        });
      });
      scope.toggleEmailIframe = function(email, event) {
        email.expanded = email.expanded ? false : true;
        event.preventDefault();
      };
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/stream/directive.formStreamEntry.js */
angular.module('sn.common.stream').directive('formStreamEntry', function(getTemplateUrl) {
  return {
    restrict: 'A',
    templateUrl: getTemplateUrl('record_stream_entry.xml')
  }
});;
/*! RESOURCE: /scripts/sn/common/stream/directive.snExpandedEmail.js */
angular.module("sn.common.stream").directive("snExpandedEmail", function() {
  "use strict";
  return {
    restrict: "E",
    replace: true,
    scope: {
      email: "="
    },
    template: "<iframe style='width: 100%;' class='card' src='{{::emailBodySrc}}'></iframe>",
    controller: function($scope) {
      $scope.emailBodySrc = "email_display.do?email_id=" + $scope.email.sys_id.displayValue;
    },
    link: function(scope, element) {
      element.load(function() {
        var bodyHeight = $j(this).get(0).contentWindow.document.body.scrollHeight + "px";
        $j(this).height(bodyHeight);
      });
    }
  };
});;
/*! RESOURCE: /scripts/app.form_presence/controller.formStream.js */
(function() {
  var journalModel = {};
  window.journalModel = journalModel;
  CustomEvent.observe('sn.form.journal_field.add', function(name, mandatory, readonly, visible, value, label) {
    journalModel[name] = {
      name: name,
      mandatory: mandatory,
      readonly: readonly,
      visible: visible,
      value: value,
      label: label,
      messages: []
    };
  });
  CustomEvent.observe('sn.form.journal_field.readonly', function(name, readonly) {
    modifyJournalAttribute(name, "readonly", readonly);
  });
  CustomEvent.observe('sn.form.journal_field.value', function(name, value) {
    modifyJournalAttribute(name, "value", value);
  });
  CustomEvent.observe('sn.form.journal_field.mandatory', function(name, mandatory) {
    modifyJournalAttribute(name, "mandatory", mandatory);
  });
  CustomEvent.observe('sn.form.journal_field.visible', function(name, visible) {
    modifyJournalAttribute(name, "visible", visible);
  });
  CustomEvent.observe('sn.form.journal_field.label', function(name, visible) {
    modifyJournalAttribute(name, "label", visible);
  });
  CustomEvent.observe('sn.form.journal_field.show_msg', function(input, message, type) {
    var messages = journalModel[input]['messages'].concat([{
      type: type,
      message: message
    }]);
    modifyJournalAttribute(input, 'messages', messages);
  });
  CustomEvent.observe('sn.form.journal_field.hide_msg', function(input, clearAll) {
    if (journalModel[input]['messages'].length == 0)
      return;
    var desiredValue = [];
    if (!clearAll)
      desiredValue = journalModel[input]['messages'].slice(1);
    modifyJournalAttribute(input, 'messages', desiredValue);
  });
  CustomEvent.observe('sn.form.hide_all_field_msg', function(type) {
    var fields = Object.keys(journalModel);
    for (var i = 0; i < fields.length; i++) {
      var f = fields[i];
      if (journalModel[f].messages.length == 0)
        continue;
      var messages = [];
      if (type) {
        var oldMessages = angular.copy(journalModel[f].messages);
        for (var j = 0; j < oldMessages.length; j++) {
          if (oldMessages[j].type != type)
            messages.push(oldMessages[j]);
        }
      }
      modifyJournalAttribute(f, 'messages', messages);
    }
  });
  CustomEvent.observe('sn.stream.insert', function(field, text) {
    if (typeof window.g_form !== "undefined")
      g_form.getControl(field).value = NOW.STREAM_VALUE_KEY + text;
  });

  function modifyJournalAttribute(field, prop, value) {
    if (journalModel[field][prop] === value)
      return;
    journalModel[field][prop] = value;
    CustomEvent.fire('sn.form.journal_field.changed');
  }
  angular.module('sn.common.stream').controller('formStream', function($scope, snCustomEvent) {
    $scope.formJournalFields = journalModel;
    $scope.formJournalFieldsVisible = false;
    setUp();
    snCustomEvent.observe('sn.form.journal_field.changed', function() {
      setUp();
      if (!$scope.$$phase)
        $scope.$apply();
    });

    function setUp() {
      setInputValue();
    }

    function setInputValue() {
      angular.forEach($scope.formJournalFields, function(item) {
        if (typeof window.g_form === "undefined")
          return;
        item.value = g_form.getValue(item.name);
        if (!item.readonly && item.visible && (item.value !== undefined || item.value !== null)) {
          $scope.$broadcast('sn.stream.input_value', item.value);
          return false;
        }
      });
    }
  })
})();;
/*! RESOURCE: /scripts/app.form_presence/directive.scroll_form.js */
angular.module('sn.common.stream').directive('scrollFrom', function() {
  "use strict";
  var SCROLL_TOP_PAD = 10;
  return {
    restrict: 'A',
    link: function($scope, $element, $attrs) {
      var target = $attrs.scrollFrom;
      $j(target).click(function(evt) {
        if (window.g_form) {
          var tab = g_form._getTabNameForElement($element);
          if (tab)
            g_form.activateTab(tab);
        }
        var $scrollRoot = $element.closest('.form-group');
        if ($scrollRoot.length === 0)
          $scrollRoot = $element;
        var $scrollParent = $scrollRoot.scrollParent();
        var offset = $element.offset().top - $scrollParent.offset().top - SCROLL_TOP_PAD + $scrollParent.scrollTop();
        $scrollParent.animate({
          scrollTop: offset
        }, '500', 'swing');
        evt.stopPropagation();
      })
    }
  }
});;;;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/js_includes_attachments.js */
/*! RESOURCE: /scripts/angularjs-1.4/thirdparty/angular-file-upload/angular-file-upload-all.js */
(function() {
  function patchXHR(fnName, newFn) {
    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
  }
  if (window.XMLHttpRequest && !window.XMLHttpRequest.__isFileAPIShim) {
    patchXHR('setRequestHeader', function(orig) {
      return function(header, value) {
        if (header === '__setXHR_') {
          var val = value(this);
          if (val instanceof Function) {
            val(this);
          }
        } else {
          orig.apply(this, arguments);
        }
      }
    });
  }
  var angularFileUpload = angular.module('angularFileUpload', []);
  angularFileUpload.version = '3.1.2';
  angularFileUpload.service('$upload', ['$http', '$q', '$timeout', function($http, $q, $timeout) {
    function sendHttp(config) {
      config.method = config.method || 'POST';
      config.headers = config.headers || {};
      config.transformRequest = config.transformRequest || function(data, headersGetter) {
        if (window.ArrayBuffer && data instanceof window.ArrayBuffer) {
          return data;
        }
        return $http.defaults.transformRequest[0](data, headersGetter);
      };
      var deferred = $q.defer();
      var promise = deferred.promise;
      config.headers['__setXHR_'] = function() {
        return function(xhr) {
          if (!xhr) return;
          config.__XHR = xhr;
          config.xhrFn && config.xhrFn(xhr);
          xhr.upload.addEventListener('progress', function(e) {
            e.config = config;
            deferred.notify ? deferred.notify(e) : promise.progress_fn && $timeout(function() {
              promise.progress_fn(e)
            });
          }, false);
          xhr.upload.addEventListener('load', function(e) {
            if (e.lengthComputable) {
              e.config = config;
              deferred.notify ? deferred.notify(e) : promise.progress_fn && $timeout(function() {
                promise.progress_fn(e)
              });
            }
          }, false);
        };
      };
      $http(config).then(function(r) {
        deferred.resolve(r)
      }, function(e) {
        deferred.reject(e)
      }, function(n) {
        deferred.notify(n)
      });
      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };
      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };
      promise.progress = function(fn) {
        promise.progress_fn = fn;
        promise.then(null, null, function(update) {
          fn(update);
        });
        return promise;
      };
      promise.abort = function() {
        if (config.__XHR) {
          $timeout(function() {
            config.__XHR.abort();
          });
        }
        return promise;
      };
      promise.xhr = function(fn) {
        config.xhrFn = (function(origXhrFn) {
          return function() {
            origXhrFn && origXhrFn.apply(promise, arguments);
            fn.apply(promise, arguments);
          }
        })(config.xhrFn);
        return promise;
      };
      return promise;
    }
    this.upload = function(config) {
      config.headers = config.headers || {};
      config.headers['Content-Type'] = undefined;
      var origTransformRequest = config.transformRequest;
      config.transformRequest = config.transformRequest ?
        (Object.prototype.toString.call(config.transformRequest) === '[object Array]' ?
          config.transformRequest : [config.transformRequest]) : [];
      config.transformRequest.push(function(data, headerGetter) {
        var formData = new FormData();
        var allFields = {};
        for (var key in config.fields) allFields[key] = config.fields[key];
        if (data) allFields['data'] = data;
        if (config.formDataAppender) {
          for (var key in allFields) {
            config.formDataAppender(formData, key, allFields[key]);
          }
        } else {
          for (var key in allFields) {
            var val = allFields[key];
            if (val !== undefined) {
              if (Object.prototype.toString.call(val) === '[object String]') {
                formData.append(key, val);
              } else {
                if (config.sendObjectsAsJsonBlob && typeof val === 'object') {
                  formData.append(key, new Blob([val], {
                    type: 'application/json'
                  }));
                } else {
                  formData.append(key, JSON.stringify(val));
                }
              }
            }
          }
        }
        if (config.file != null) {
          var fileFormName = config.fileFormDataName || 'file';
          if (Object.prototype.toString.call(config.file) === '[object Array]') {
            var isFileFormNameString = Object.prototype.toString.call(fileFormName) === '[object String]';
            for (var i = 0; i < config.file.length; i++) {
              formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i],
                (config.fileName && config.fileName[i]) || config.file[i].name);
            }
          } else {
            formData.append(fileFormName, config.file, config.fileName || config.file.name);
          }
        }
        return formData;
      });
      return sendHttp(config);
    };
    this.http = function(config) {
      return sendHttp(config);
    };
  }]);
  angularFileUpload.directive('ngFileSelect', ['$parse', '$timeout', '$compile',
    function($parse, $timeout, $compile) {
      return {
        restrict: 'AEC',
        require: '?ngModel',
        link: function(scope, elem, attr, ngModel) {
          handleFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile);
        }
      }
    }
  ]);

  function handleFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile) {
    function isInputTypeFile() {
      return elem[0].tagName.toLowerCase() === 'input' && elem.attr('type') && elem.attr('type').toLowerCase() === 'file';
    }
    var watchers = [];

    function watchForRecompile(attrVal) {
      $timeout(function() {
        if (elem.parent().length) {
          watchers.push(scope.$watch(attrVal, function(val, oldVal) {
            if (val != oldVal) {
              recompileElem();
            }
          }));
        }
      });
    }

    function recompileElem() {
      var clone = elem.clone();
      if (elem.attr('__afu_gen__')) {
        angular.element(document.getElementById(elem.attr('id').substring(1))).remove();
      }
      if (elem.parent().length) {
        for (var i = 0; i < watchers.length; i++) {
          watchers[i]();
        }
        elem.replaceWith(clone);
        $compile(clone)(scope);
      }
      return clone;
    }

    function bindAttr(bindAttr, attrName) {
      if (bindAttr) {
        watchForRecompile(bindAttr);
        var val = $parse(bindAttr)(scope);
        if (val) {
          elem.attr(attrName, val);
          attr[attrName] = val;
        } else {
          elem.attr(attrName, null);
          delete attr[attrName];
        }
      }
    }
    bindAttr(attr.ngMultiple, 'multiple');
    bindAttr(attr.ngAccept, 'ng-accept');
    bindAttr(attr.ngCapture, 'capture');
    if (attr['ngFileSelect'] != '') {
      attr.ngFileChange = attr.ngFileSelect;
    }

    function onChangeFn(evt) {
      var files = [],
        fileList, i;
      fileList = evt.__files_ || (evt.target && evt.target.files);
      updateModel(fileList, attr, ngModel, scope, evt);
    };
    var fileElem = elem;
    if (!isInputTypeFile()) {
      fileElem = angular.element('<input type="file">')
      if (elem.attr('multiple')) fileElem.attr('multiple', elem.attr('multiple'));
      if (elem.attr('accept')) fileElem.attr('accept', elem.attr('accept'));
      if (elem.attr('capture')) fileElem.attr('capture', elem.attr('capture'));
      for (var key in attr) {
        if (key.indexOf('inputFile') == 0) {
          var name = key.substring('inputFile'.length);
          name = name[0].toLowerCase() + name.substring(1);
          fileElem.attr(name, attr[key]);
        }
      }
      fileElem.css('width', '0px').css('height', '0px').css('position', 'absolute').css('padding', 0).css('margin', 0)
        .css('overflow', 'hidden').attr('tabindex', '-1').css('opacity', 0).attr('__afu_gen__', true);
      elem.attr('__refElem__', true);
      fileElem[0].__refElem__ = elem[0];
      elem.parent()[0].insertBefore(fileElem[0], elem[0])
      elem.css('overflow', 'hidden');
      elem.bind('click', function(e) {
        if (!resetAndClick(e)) {
          fileElem[0].click();
        }
      });
    } else {
      elem.bind('click', resetAndClick);
    }

    function resetAndClick(evt) {
      if (fileElem[0].value != null && fileElem[0].value != '') {
        fileElem[0].value = null;
        if (navigator.userAgent.indexOf("Trident/7") === -1) {
          onChangeFn({
            target: {
              files: []
            }
          });
        }
      }
      if (!elem.attr('__afu_clone__')) {
        if (navigator.appVersion.indexOf("MSIE 10") !== -1 || navigator.userAgent.indexOf("Trident/7") !== -1) {
          var clone = recompileElem();
          clone.attr('__afu_clone__', true);
          clone[0].click();
          evt.preventDefault();
          evt.stopPropagation();
          return true;
        }
      } else {
        elem.attr('__afu_clone__', null);
      }
    }
    fileElem.bind('change', onChangeFn);
    elem.on('$destroy', function() {
      for (var i = 0; i < watchers.length; i++) {
        watchers[i]();
      }
      if (elem[0] != fileElem[0]) fileElem.remove();
    });
    watchers.push(scope.$watch(attr.ngModel, function(val, oldVal) {
      if (val != oldVal && (val == null || !val.length)) {
        if (navigator.appVersion.indexOf("MSIE 10") !== -1) {
          recompileElem();
        } else {
          fileElem[0].value = null;
        }
      }
    }));

    function updateModel(fileList, attr, ngModel, scope, evt) {
      var files = [],
        rejFiles = [];
      var accept = $parse(attr.ngAccept)(scope);
      var regexp = angular.isString(accept) && accept ? new RegExp(globStringToRegex(accept), 'gi') : null;
      var acceptFn = regexp ? null : attr.ngAccept;
      for (var i = 0; i < fileList.length; i++) {
        var file = fileList.item(i);
        if ((!regexp || file.type.match(regexp) || (file.name != null && file.name.match(regexp))) &&
          (!acceptFn || $parse(acceptFn)(scope, {
            $file: file,
            $event: evt
          }))) {
          files.push(file);
        } else {
          rejFiles.push(file);
        }
      }
      $timeout(function() {
        if (ngModel) {
          $parse(attr.ngModel).assign(scope, files);
          ngModel && ngModel.$setViewValue(files != null && files.length == 0 ? '' : files);
          if (attr.ngModelRejected) {
            $parse(attr.ngModelRejected).assign(scope, rejFiles);
          }
        }
        if (attr.ngFileChange && attr.ngFileChange != "") {
          $parse(attr.ngFileChange)(scope, {
            $files: files,
            $rejectedFiles: rejFiles,
            $event: evt
          });
        }
      });
    }
  }
  angularFileUpload.directive('ngFileDrop', ['$parse', '$timeout', '$location', function($parse, $timeout, $location) {
    return {
      restrict: 'AEC',
      require: '?ngModel',
      link: function(scope, elem, attr, ngModel) {
        handleDrop(scope, elem, attr, ngModel, $parse, $timeout, $location);
      }
    }
  }]);
  angularFileUpload.directive('ngNoFileDrop', function() {
    return function(scope, elem, attr) {
      if (dropAvailable()) elem.css('display', 'none')
    }
  });
  angularFileUpload.directive('ngFileDropAvailable', ['$parse', '$timeout', function($parse, $timeout) {
    return function(scope, elem, attr) {
      if (dropAvailable()) {
        var fn = $parse(attr['ngFileDropAvailable']);
        $timeout(function() {
          fn(scope);
        });
      }
    }
  }]);

  function handleDrop(scope, elem, attr, ngModel, $parse, $timeout, $location) {
    var available = dropAvailable();
    if (attr['dropAvailable']) {
      $timeout(function() {
        scope.dropAvailable ? scope.dropAvailable.value = available : scope.dropAvailable = available;
      });
    }
    if (!available) {
      if ($parse(attr.hideOnDropNotAvailable)(scope) != false) {
        elem.css('display', 'none');
      }
      return;
    }
    var leaveTimeout = null;
    var stopPropagation = $parse(attr.stopPropagation)(scope);
    var dragOverDelay = 1;
    var accept = $parse(attr.ngAccept)(scope) || attr.accept;
    var regexp = angular.isString(accept) && accept ? new RegExp(globStringToRegex(accept), 'gi') : null;
    var acceptFn = regexp ? null : attr.ngAccept;
    var actualDragOverClass;
    elem[0].addEventListener('dragover', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
      if (navigator.userAgent.indexOf("Chrome") > -1) {
        var b = evt.dataTransfer.effectAllowed;
        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
      }
      $timeout.cancel(leaveTimeout);
      if (!scope.actualDragOverClass) {
        actualDragOverClass = calculateDragOverClass(scope, attr, evt);
      }
      elem.addClass(actualDragOverClass);
    }, false);
    elem[0].addEventListener('dragenter', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
    }, false);
    elem[0].addEventListener('dragleave', function(evt) {
      leaveTimeout = $timeout(function() {
        elem.removeClass(actualDragOverClass);
        actualDragOverClass = null;
      }, dragOverDelay || 1);
    }, false);
    if (attr['ngFileDrop'] != '') {
      attr.ngFileChange = attr['ngFileDrop'];
    }
    elem[0].addEventListener('drop', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
      elem.removeClass(actualDragOverClass);
      actualDragOverClass = null;
      extractFiles(evt, function(files, rejFiles) {
        $timeout(function() {
          if (ngModel) {
            $parse(attr.ngModel).assign(scope, files);
            ngModel && ngModel.$setViewValue(files != null && files.length == 0 ? '' : files);
          }
          if (attr['ngModelRejected']) {
            if (scope[attr.ngModelRejected]) {
              $parse(attr.ngModelRejected).assign(scope, rejFiles);
            }
          }
        });
        $timeout(function() {
          $parse(attr.ngFileChange)(scope, {
            $files: files,
            $rejectedFiles: rejFiles,
            $event: evt
          });
        });
      }, $parse(attr.allowDir)(scope) != false, attr.multiple || $parse(attr.ngMultiple)(scope));
    }, false);

    function calculateDragOverClass(scope, attr, evt) {
      var valid = true;
      if (regexp || acceptFn) {
        var items = evt.dataTransfer.items;
        if (items != null) {
          for (var i = 0; i < items.length && valid; i++) {
            valid = valid && (items[i].kind == 'file' || items[i].kind == '') &&
              ((acceptFn && $parse(acceptFn)(scope, {
                  $file: items[i],
                  $event: evt
                })) ||
                (regexp && (items[i].type != null && items[i].type.match(regexp)) ||
                  (items[i].name != null && items[i].name.match(regexp))));
          }
        }
      }
      var clazz = $parse(attr.dragOverClass)(scope, {
        $event: evt
      });
      if (clazz) {
        if (clazz.delay) dragOverDelay = clazz.delay;
        if (clazz.accept) clazz = valid ? clazz.accept : clazz.reject;
      }
      return clazz || attr['dragOverClass'] || 'dragover';
    }

    function extractFiles(evt, callback, allowDir, multiple) {
      var files = [],
        rejFiles = [],
        items = evt.dataTransfer.items,
        processing = 0;

      function addFile(file) {
        if ((!regexp || file.type.match(regexp) || (file.name != null && file.name.match(regexp))) &&
          (!acceptFn || $parse(acceptFn)(scope, {
            $file: file,
            $event: evt
          }))) {
          files.push(file);
        } else {
          rejFiles.push(file);
        }
      }
      if (items && items.length > 0 && $location.protocol() != 'file') {
        for (var i = 0; i < items.length; i++) {
          if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
            var entry = items[i].webkitGetAsEntry();
            if (entry.isDirectory && !allowDir) {
              continue;
            }
            if (entry != null) {
              traverseFileTree(files, entry);
            }
          } else {
            var f = items[i].getAsFile();
            if (f != null) addFile(f);
          }
          if (!multiple && files.length > 0) break;
        }
      } else {
        var fileList = evt.dataTransfer.files;
        if (fileList != null) {
          for (var i = 0; i < fileList.length; i++) {
            addFile(fileList.item(i));
            if (!multiple && files.length > 0) break;
          }
        }
      }
      var delays = 0;
      (function waitForProcess(delay) {
        $timeout(function() {
          if (!processing) {
            if (!multiple && files.length > 1) {
              var i = 0;
              while (files[i].type == 'directory') i++;
              files = [files[i]];
            }
            callback(files, rejFiles);
          } else {
            if (delays++ * 10 < 20 * 1000) {
              waitForProcess(10);
            }
          }
        }, delay || 0)
      })();

      function traverseFileTree(files, entry, path) {
        if (entry != null) {
          if (entry.isDirectory) {
            var filePath = (path || '') + entry.name;
            addFile({
              name: entry.name,
              type: 'directory',
              path: filePath
            });
            var dirReader = entry.createReader();
            var entries = [];
            processing++;
            var readEntries = function() {
              dirReader.readEntries(function(results) {
                try {
                  if (!results.length) {
                    for (var i = 0; i < entries.length; i++) {
                      traverseFileTree(files, entries[i], (path ? path : '') + entry.name + '/');
                    }
                    processing--;
                  } else {
                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                    readEntries();
                  }
                } catch (e) {
                  processing--;
                  console.error(e);
                }
              }, function() {
                processing--;
              });
            };
            readEntries();
          } else {
            processing++;
            entry.file(function(file) {
              try {
                processing--;
                file.path = (path ? path : '') + file.name;
                addFile(file);
              } catch (e) {
                processing--;
                console.error(e);
              }
            }, function(e) {
              processing--;
            });
          }
        }
      }
    }
  }

  function dropAvailable() {
    var div = document.createElement('div');
    return ('draggable' in div) && ('ondrop' in div);
  }

  function globStringToRegex(str) {
    if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
      return str.substring(1, str.length - 1);
    }
    var split = str.split(','),
      result = '';
    if (split.length > 1) {
      for (var i = 0; i < split.length; i++) {
        result += '(' + globStringToRegex(split[i]) + ')';
        if (i < split.length - 1) {
          result += '|'
        }
      }
    } else {
      if (str.indexOf('.') == 0) {
        str = '*' + str;
      }
      result = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + '-]', 'g'), '\\$&') + '$';
      result = result.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
    }
    return result;
  }
  var ngFileUpload = angular.module('ngFileUpload', []);
  for (var key in angularFileUpload) {
    ngFileUpload[key] = angularFileUpload[key];
  }
})();
(function() {
  var hasFlash = function() {
    try {
      var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
      if (fo) return true;
    } catch (e) {
      if (navigator.mimeTypes['application/x-shockwave-flash'] != undefined) return true;
    }
    return false;
  }

  function patchXHR(fnName, newFn) {
    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
  };
  if ((window.XMLHttpRequest && !window.FormData) || (window.FileAPI && FileAPI.forceLoad)) {
    var initializeUploadListener = function(xhr) {
      if (!xhr.__listeners) {
        if (!xhr.upload) xhr.upload = {};
        xhr.__listeners = [];
        var origAddEventListener = xhr.upload.addEventListener;
        xhr.upload.addEventListener = function(t, fn, b) {
          xhr.__listeners[t] = fn;
          origAddEventListener && origAddEventListener.apply(this, arguments);
        };
      }
    }
    patchXHR('open', function(orig) {
      return function(m, url, b) {
        initializeUploadListener(this);
        this.__url = url;
        try {
          orig.apply(this, [m, url, b]);
        } catch (e) {
          if (e.message.indexOf('Access is denied') > -1) {
            this.__origError = e;
            orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);
          }
        }
      }
    });
    patchXHR('getResponseHeader', function(orig) {
      return function(h) {
        return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));
      };
    });
    patchXHR('getAllResponseHeaders', function(orig) {
      return function() {
        return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));
      }
    });
    patchXHR('abort', function(orig) {
      return function() {
        return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));
      }
    });
    patchXHR('setRequestHeader', function(orig) {
      return function(header, value) {
        if (header === '__setXHR_') {
          initializeUploadListener(this);
          var val = value(this);
          if (val instanceof Function) {
            val(this);
          }
        } else {
          this.__requestHeaders = this.__requestHeaders || {};
          this.__requestHeaders[header] = value;
          orig.apply(this, arguments);
        }
      }
    });

    function redefineProp(xhr, prop, fn) {
      try {
        Object.defineProperty(xhr, prop, {
          get: fn
        });
      } catch (e) {}
    }
    patchXHR('send', function(orig) {
      return function() {
        var xhr = this;
        if (arguments[0] && arguments[0].__isFileAPIShim) {
          var formData = arguments[0];
          var config = {
            url: xhr.__url,
            jsonp: false,
            cache: true,
            complete: function(err, fileApiXHR) {
              xhr.__completed = true;
              if (!err && xhr.__listeners['load'])
                xhr.__listeners['load']({
                  type: 'load',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (!err && xhr.__listeners['loadend'])
                xhr.__listeners['loadend']({
                  type: 'loadend',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (err === 'abort' && xhr.__listeners['abort'])
                xhr.__listeners['abort']({
                  type: 'abort',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function() {
                return (fileApiXHR.status == 0 && err && err !== 'abort') ? 500 : fileApiXHR.status
              });
              if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function() {
                return fileApiXHR.statusText
              });
              redefineProp(xhr, 'readyState', function() {
                return 4
              });
              if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function() {
                return fileApiXHR.response
              });
              var resp = fileApiXHR.responseText || (err && fileApiXHR.status == 0 && err !== 'abort' ? err : undefined);
              redefineProp(xhr, 'responseText', function() {
                return resp
              });
              redefineProp(xhr, 'response', function() {
                return resp
              });
              if (err) redefineProp(xhr, 'err', function() {
                return err
              });
              xhr.__fileApiXHR = fileApiXHR;
              if (xhr.onreadystatechange) xhr.onreadystatechange();
              if (xhr.onload) xhr.onload();
            },
            fileprogress: function(e) {
              e.target = xhr;
              xhr.__listeners['progress'] && xhr.__listeners['progress'](e);
              xhr.__total = e.total;
              xhr.__loaded = e.loaded;
              if (e.total === e.loaded) {
                var _this = this
                setTimeout(function() {
                  if (!xhr.__completed) {
                    xhr.getAllResponseHeaders = function() {};
                    _this.complete(null, {
                      status: 204,
                      statusText: 'No Content'
                    });
                  }
                }, FileAPI.noContentTimeout || 10000);
              }
            },
            headers: xhr.__requestHeaders
          }
          config.data = {};
          config.files = {}
          for (var i = 0; i < formData.data.length; i++) {
            var item = formData.data[i];
            if (item.val != null && item.val.name != null && item.val.size != null && item.val.type != null) {
              config.files[item.key] = item.val;
            } else {
              config.data[item.key] = item.val;
            }
          }
          setTimeout(function() {
            if (!hasFlash()) {
              throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
            }
            xhr.__fileApiXHR = FileAPI.upload(config);
          }, 1);
        } else {
          if (this.__origError) {
            throw this.__origError;
          }
          orig.apply(xhr, arguments);
        }
      }
    });
    window.XMLHttpRequest.__isFileAPIShim = true;
    var addFlash = function(elem) {
      if (!hasFlash()) {
        throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
      }
      var el = angular.element(elem);
      if (!el.attr('disabled')) {
        var hasFileSelect = false;
        for (var i = 0; i < el[0].attributes.length; i++) {
          var attrib = el[0].attributes[i];
          if (attrib.name.indexOf('file-select') !== -1) {
            hasFileSelect = true;
            break;
          }
        }
        if (!el.hasClass('js-fileapi-wrapper') && (hasFileSelect || el.attr('__afu_gen__') != null)) {
          el.addClass('js-fileapi-wrapper');
          if (el.attr('__afu_gen__') != null) {
            var ref = (el[0].__refElem__ && angular.element(el[0].__refElem__)) || el;
            while (ref && !ref.attr('__refElem__')) {
              ref = angular.element(ref[0].nextSibling);
            }
            ref.bind('mouseover', function() {
              if (el.parent().css('position') === '' || el.parent().css('position') === 'static') {
                el.parent().css('position', 'relative');
              }
              el.css('position', 'absolute').css('top', ref[0].offsetTop + 'px').css('left', ref[0].offsetLeft + 'px')
                .css('width', ref[0].offsetWidth + 'px').css('height', ref[0].offsetHeight + 'px')
                .css('padding', ref.css('padding')).css('margin', ref.css('margin')).css('filter', 'alpha(opacity=0)');
              ref.attr('onclick', '');
              el.css('z-index', '1000');
            });
          }
        }
      }
    };
    var changeFnWrapper = function(fn) {
      return function(evt) {
        var files = FileAPI.getFiles(evt);
        for (var i = 0; i < files.length; i++) {
          if (files[i].size === undefined) files[i].size = 0;
          if (files[i].name === undefined) files[i].name = 'file';
          if (files[i].type === undefined) files[i].type = 'undefined';
        }
        if (!evt.target) {
          evt.target = {};
        }
        evt.target.files = files;
        if (evt.target.files != files) {
          evt.__files_ = files;
        }
        (evt.__files_ || evt.target.files).item = function(i) {
          return (evt.__files_ || evt.target.files)[i] || null;
        }
        if (fn) fn.apply(this, [evt]);
      };
    };
    var isFileChange = function(elem, e) {
      return (e.toLowerCase() === 'change' || e.toLowerCase() === 'onchange') && elem.getAttribute('type') == 'file';
    }
    if (HTMLInputElement.prototype.addEventListener) {
      HTMLInputElement.prototype.addEventListener = (function(origAddEventListener) {
        return function(e, fn, b, d) {
          if (isFileChange(this, e)) {
            addFlash(this);
            origAddEventListener.apply(this, [e, changeFnWrapper(fn), b, d]);
          } else {
            origAddEventListener.apply(this, [e, fn, b, d]);
          }
        }
      })(HTMLInputElement.prototype.addEventListener);
    }
    if (HTMLInputElement.prototype.attachEvent) {
      HTMLInputElement.prototype.attachEvent = (function(origAttachEvent) {
        return function(e, fn) {
          if (isFileChange(this, e)) {
            addFlash(this);
            if (window.jQuery) {
              angular.element(this).bind('change', changeFnWrapper(null));
            } else {
              origAttachEvent.apply(this, [e, changeFnWrapper(fn)]);
            }
          } else {
            origAttachEvent.apply(this, [e, fn]);
          }
        }
      })(HTMLInputElement.prototype.attachEvent);
    }
    window.FormData = FormData = function() {
      return {
        append: function(key, val, name) {
          if (val.__isFileAPIBlobShim) {
            val = val.data[0];
          }
          this.data.push({
            key: key,
            val: val,
            name: name
          });
        },
        data: [],
        __isFileAPIShim: true
      };
    };
    window.Blob = Blob = function(b) {
      return {
        data: b,
        __isFileAPIBlobShim: true
      };
    };
    (function() {
      if (!window.FileAPI) {
        window.FileAPI = {};
      }
      if (FileAPI.forceLoad) {
        FileAPI.html5 = false;
      }
      if (!FileAPI.upload) {
        var jsUrl, basePath, script = document.createElement('script'),
          allScripts = document.getElementsByTagName('script'),
          i, index, src;
        if (window.FileAPI.jsUrl) {
          jsUrl = window.FileAPI.jsUrl;
        } else if (window.FileAPI.jsPath) {
          basePath = window.FileAPI.jsPath;
        } else {
          for (i = 0; i < allScripts.length; i++) {
            src = allScripts[i].src;
            index = src.search(/\/angular\-file\-upload[\-a-zA-z0-9\.]*\.js/)
            if (index > -1) {
              basePath = src.substring(0, index + 1);
              break;
            }
          }
        }
        if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;
        script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');
        document.getElementsByTagName('head')[0].appendChild(script);
        FileAPI.hasFlash = hasFlash();
      }
    })();
    FileAPI.disableFileInput = function(elem, disable) {
      if (disable) {
        elem.removeClass('js-fileapi-wrapper')
      } else {
        elem.addClass('js-fileapi-wrapper');
      }
    }
  }
  if (!window.FileReader) {
    window.FileReader = function() {
      var _this = this,
        loadStarted = false;
      this.listeners = {};
      this.addEventListener = function(type, fn) {
        _this.listeners[type] = _this.listeners[type] || [];
        _this.listeners[type].push(fn);
      };
      this.removeEventListener = function(type, fn) {
        _this.listeners[type] && _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);
      };
      this.dispatchEvent = function(evt) {
        var list = _this.listeners[evt.type];
        if (list) {
          for (var i = 0; i < list.length; i++) {
            list[i].call(_this, evt);
          }
        }
      };
      this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;
      var constructEvent = function(type, evt) {
        var e = {
          type: type,
          target: _this,
          loaded: evt.loaded,
          total: evt.total,
          error: evt.error
        };
        if (evt.result != null) e.target.result = evt.result;
        return e;
      };
      var listener = function(evt) {
        if (!loadStarted) {
          loadStarted = true;
          _this.onloadstart && _this.onloadstart(constructEvent('loadstart', evt));
        }
        if (evt.type === 'load') {
          _this.onloadend && _this.onloadend(constructEvent('loadend', evt));
          var e = constructEvent('load', evt);
          _this.onload && _this.onload(e);
          _this.dispatchEvent(e);
        } else if (evt.type === 'progress') {
          var e = constructEvent('progress', evt);
          _this.onprogress && _this.onprogress(e);
          _this.dispatchEvent(e);
        } else {
          var e = constructEvent('error', evt);
          _this.onerror && _this.onerror(e);
          _this.dispatchEvent(e);
        }
      };
      this.readAsArrayBuffer = function(file) {
        FileAPI.readAsBinaryString(file, listener);
      }
      this.readAsBinaryString = function(file) {
        FileAPI.readAsBinaryString(file, listener);
      }
      this.readAsDataURL = function(file) {
        FileAPI.readAsDataURL(file, listener);
      }
      this.readAsText = function(file) {
        FileAPI.readAsText(file, listener);
      }
    }
  }
})();;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/_module.js */
angular.module('sn.common.attachments', [
  'angularFileUpload',
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/factory.nowAttachmentHandler.js */
angular.module("sn.common.attachments").factory("nowAttachmentHandler", function($http, nowServer, $upload, $rootScope, $timeout,
  snNotification) {
  "use strict";
  return function(setAttachments, appendError) {
    var self = this;
    self.cardUploading = '';
    self.setAttachments = setAttachments;
    self.appendError = appendError;
    self.ADDED = 'added';
    self.DELETED = 'deleted';
    self.RENAMED = 'renamed';
    self.getAttachmentList = function(action) {
      var url = nowServer.getURL('ngk_attachments', {
        action: 'list',
        sys_id: self.tableId,
        table: self.tableName
      });
      $http.get(url).then(function(response) {
        var attachments = response.data.files || [];
        self.setAttachments(attachments, action);
        if (self.startedUploadingTimeout || self.errorTimeout) {
          self.stopAllUploading();
          $rootScope.$broadcast('board.uploading.end');
        }
      });
    };
    self.stopAllUploading = function() {
      $timeout.cancel(self.errorTimeout);
      $timeout.cancel(self.startedUploadingTimeout);
      hideProgressBar();
      $rootScope.$broadcast("attachment.upload.stop");
    };
    self.onFileSelect = function($files) {
      if (!$files.length)
        return;
      var url = nowServer.getURL('ngk_attachments', {
        sys_id: self.tableId,
        table: self.tableName,
        action: 'add'
      });
      self.cardUploading = self.tableId;
      self.maxfiles = $files.length;
      self.fileCount = 1;
      self.filesUploaded = self.maxfiles;
      self.startedUploadingTimeout = $timeout(showUploaderDialog, 1500);
      for (var i = 0; i < self.maxfiles; i++) {
        if (parseInt($files[i].size) > parseInt(self.fileUploadSizeLimit)) {
          self.stopAllUploading();
          $rootScope.$broadcast('dialog.upload_too_large.show');
          return;
        }
      }
      for (var i = 0; i < self.maxfiles; i++) {
        $rootScope.$broadcast("attachment.upload.start");
        var file = $files[i];
        self.filesUploaded--;
        self.upload = $upload.upload({
          url: url,
          fields: {
            attachments_modified: 'true',
            sysparm_table: self.tableName,
            sysparm_sys_id: self.tableId,
            sysparm_nostack: 'yes',
            sysparm_encryption_context: '',
            sysparm_ck: window.g_ck
          },
          fileFormDataName: 'attachFile',
          file: file
        }).progress(function(evt) {
          var percent = parseInt(100.0 * evt.loaded / evt.total, 10);
          updateProgress(percent);
        }).success(function(data, status, headers, config) {
          processError(data);
          self.stopAllUploading();
          self.getAttachmentList(self.ADDED);
          if (self.filesUploaded <= 0) {
            self.cardUploading = '';
          }
        });
      }
    };
    self.downloadAttachment = function(attachment) {
      window.location.href = '/sys_attachment.do?sys_id=' + attachment.sys_id;
    };
    self.viewAttachment = function($event, attachment) {
      var url = window.location.protocol + '//' + window.location.host;
      url += '/sys_attachment.do?sysparm_referring_url=tear_off&view=true&sys_id=' + attachment.sys_id;
      window.open(url, attachment.sys_id,
        "toolbar=no,menubar=no,personalbar=no,width=800,height=600,scrollbars=yes,resizable=yes");
    };
    self.editAttachment = function($event, attachment) {
      var parent = $($event.currentTarget).closest('.file-attachment');
      var thumbnail = parent.find('.thumbnail');
      var input = parent.find('input');
      var tools = parent.find('.tools');
      var fileName = attachment.file_name;
      if (attachment.file_name.indexOf('.') !== -1) {
        attachment.ext = fileName.match(/(\.[^\.]+)$/i)[0];
        fileName = attachment.file_name.replace(/(\.[^\.]+)$/i, '');
      }
      input.val(fileName);
      var w = input.prev().width();
      input.width(w);
      input.prev().hide();
      input.css('display', 'block');
      thumbnail.addClass('state-locked');
      tools.find('.delete-edit').hide();
      tools.find('.rename-cancel').css('display', 'inline-block');
      input.focus();
    }
    self.onKeyDown = function($event, attachment) {
      var keyCode = $event.keyCode;
      if (keyCode === 13) {
        $event.stopPropagation();
        $event.preventDefault();
        self.updateAttachment($event, attachment);
      } else if (keyCode === 27) {
        $event.stopPropagation();
        self.updateAttachment($event);
      }
    };
    self.updateAttachment = function($event, attachment) {
      var el = $($event.currentTarget);
      var parent = el.closest('.file-attachment');
      var thumbnail = parent.find('.thumbnail');
      var input = parent.find('input');
      var link = parent.find('a');
      var tools = parent.find('.tools');
      if (attachment) {
        var fileName = input.val();
        if (fileName.length) {
          fileName += attachment.ext;
          if (fileName !== attachment.file_name) {
            link.text(fileName);
            self.renameAttachment(attachment, fileName);
          }
        }
      }
      input.hide();
      input.prev().show();
      tools.find('.rename-cancel').hide();
      thumbnail.removeClass('state-locked');
      tools.find('.delete-edit').css('display', 'inline-block');
    };
    self.dismissMsg = function($event, $index, errorMessages) {
      var msg = $($event.currentTarget);
      msg.addClass('remove');
      setTimeout(function() {
        msg.remove();
        errorMessages.splice($index, 1);
      }, 500);
    };
    $rootScope.$on("dialog.comment_form.close", function() {
      hideProgressBar();
    });
    self.openSelector = function($event) {
      $event.stopPropagation();
      var target = $($event.currentTarget);
      var input = target.parent().find('input[type=file]');
      input.click();
    }
    self.deleteAttachment = function(attachment) {
      if (attachment && attachment.sys_id) {
        $('#' + attachment.sys_id).hide();
        var url = nowServer.getURL('ngk_attachments', {
          action: 'delete',
          sys_id: attachment.sys_id
        });
        $http.get(url).then(function(response) {
          processError(response.data);
          self.getAttachmentList(self.DELETED);
        });
      }
    };
    self.renameAttachment = function(attachment, newName) {
      $http({
        url: nowServer.getURL('ngk_attachments'),
        method: 'POST',
        params: {
          action: 'rename',
          sys_id: attachment.sys_id,
          new_name: newName
        }
      }).then(function(response) {
        processError(response.data);
        self.getAttachmentList(self.RENAMED);
      });
    };

    function showUploaderDialog() {
      $rootScope.$broadcast('board.uploading.start', self.tableId);
    }

    function updateProgress(percent) {
      if (self.prevPercent === percent && self.fileCount <= self.maxfiles)
        return;
      if (self.fileCount <= self.maxfiles) {
        if (percent > 99)
          self.fileCount++;
        if (self.fileCount <= self.maxfiles) {
          $timeout.cancel(self.errorTimeout);
          self.errorTimeout = $timeout(broadcastError, 15000);
          $('.progress-label').text('Uploading file ' + self.fileCount + ' of ' + self.maxfiles);
          $('.upload-progress').val(percent);
          $('.progress-wrapper').show();
        }
      }
      self.prevPercent = percent;
    }

    function hideProgressBar() {
      try {
        $('.progress-wrapper').hide();
      } catch (e) {}
    }
    self.setParams = function(tableName, tableId, fileUploadSizeLimit) {
      self.tableName = tableName;
      self.tableId = tableId;
      self.fileUploadSizeLimit = fileUploadSizeLimit;
    };

    function broadcastError() {
      $rootScope.$broadcast('board.uploading.end');
      snNotification.show('error', 'An error occured when trying to upload your file. Please try again.');
      self.stopAllUploading();
    }

    function processError(data) {
      if (data.error) {
        self.appendError({
          msg: data.error + ' : ',
          fileName: '"' + data.fileName + '"'
        });
      }
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.nowAttachmentsList.js */
angular.module('sn.common.attachments').directive('nowAttachmentsList', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl("attachments_list.xml"),
    link: function(scope, elem, attrs, $parse) {
      scope.icons = {
        preview: attrs.previewIcon,
        edit: attrs.editIcon,
        delete: attrs.deleteIcon,
        ok: attrs.okIcon,
        cancel: attrs.cancelIcon
      };
      scope.listClass = "list-group";
      var inline = scope.$eval(attrs.inline);
      if (inline)
        scope.listClass = "list-inline";
      scope.entryTemplate = getTemplateUrl(attrs.template || "attachment");
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/factory.snAttachmentHandler.js */
angular.module('sn.common.attachments').factory('snAttachmentHandler', function(urlTools, $http, $upload, $window, $q) {
  "use strict";
  return {
    getViewUrl: getViewUrl,
    create: createAttachmentHandler,
    deleteAttachment: deleteAttachmentBySysID,
    renameAttachment: renameAttachmentBySysID
  };

  function getViewUrl(sysId) {
    return '/sys_attachment.do?sys_id=' + sysId;
  }

  function deleteAttachmentBySysID(sysID) {
    var url = urlTools.getURL('ngk_attachments', {
      action: 'delete',
      sys_id: sysID
    });
    return $http.get(url);
  }

  function renameAttachmentBySysID(sysID, newName) {
    var url = urlTools.getURL('ngk_attachments', {
      action: 'rename',
      sys_id: sysID,
      new_name: newName
    });
    return $http.post(url);
  }

  function createAttachmentHandler(tableName, sysID, options) {
    var _tableName = tableName;
    var _sysID = sysID;
    var _files = [];

    function getTableName() {
      return _tableName;
    }

    function getSysID() {
      return _sysID;
    }

    function getAttachments() {
      var url = urlTools.getURL('ngk_attachments', {
        action: 'list',
        sys_id: _sysID,
        table: _tableName
      });
      return $http.get(url).then(function(response) {
        var files = response.data.files;
        if (_files.length == 0) {
          files.forEach(function(file) {
            if (file && file.sys_id) {
              _transformFileResponse(file);
              _files.push(file);
            }
          })
        } else {
          _files = files;
        }
        return _files;
      });
    }

    function addAttachment(attachment) {
      _files.unshift(attachment);
    }

    function deleteAttachment(attachment) {
      var index = _files.indexOf(attachment);
      if (index !== -1) {
        return deleteAttachmentBySysID(attachment.sys_id).then(function() {
          _files.splice(index, 1);
        });
      }
    }

    function uploadAttachments(files, uploadFields) {
      var defer = $q.defer();
      var promises = [];
      var fileData = [];
      angular.forEach(files, function(file) {
        promises.push(uploadAttachment(file, uploadFields).then(function(response) {
          fileData.push(response);
        }));
      });
      $q.all(promises).then(function() {
        defer.resolve(fileData);
      });
      return defer.promise;
    }

    function uploadAttachment(file, uploadFields, uploadMethods) {
      var url = urlTools.getURL('ngk_attachments', {
        action: 'add',
        sys_id: _sysID,
        table: _tableName,
        load_attachment_record: 'true'
      });
      var fields = {
        attachments_modified: 'true',
        sysparm_table: _tableName,
        sysparm_sys_id: _sysID,
        sysparm_nostack: 'yes',
        sysparm_encryption_context: ''
      };
      if (typeof $window.g_ck !== 'undefined') {
        fields['sysparm_ck'] = $window.g_ck;
      }
      if (uploadFields) {
        angular.extend(fields, uploadFields);
      }
      var upload = $upload.upload({
        url: url,
        fields: fields,
        fileFormDataName: 'attachFile',
        file: file
      });
      if (uploadMethods !== undefined) {
        if (uploadMethods.hasOwnProperty('progress')) {
          upload.progress(uploadMethods.progress);
        }
        if (uploadMethods.hasOwnProperty('success')) {
          upload.success(uploadMethods.success);
        }
        if (uploadMethods.hasOwnProperty('error')) {
          upload.error(uploadMethods.error);
        }
      }
      return upload.then(function(response) {
        var sysFile = response.data;
        if (sysFile.error) {
          return $q.reject("Exception when adding attachment: " + sysFile.error);
        }
        if (typeof sysFile === "object" && sysFile.hasOwnProperty('sys_id')) {
          _transformFileResponse(sysFile);
          addAttachment(sysFile);
        }
        if (options && options.onUploadComplete) {
          options.onUploadComplete(sysFile);
        }
        return sysFile;
      });
    }

    function _transformFileResponse(file) {
      file.isImage = false;
      file.canPreview = false;
      if (file.content_type.indexOf('image') !== -1) {
        file.isImage = true;
        if (!file.thumbSrc) {} else if (file.thumbSrc[0] !== '/') {
          file.thumbSrc = '/' + file.thumbSrc;
        }
        file.canPreview = file.content_type.indexOf('tiff') === -1;
      }
      file.viewUrl = getViewUrl(file.sys_id);
    }
    return {
      getSysID: getSysID,
      getTableName: getTableName,
      getAttachments: getAttachments,
      addAttachment: addAttachment,
      deleteAttachment: deleteAttachment,
      uploadAttachment: uploadAttachment,
      uploadAttachments: uploadAttachments
    };
  }
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snFileUploadInput.js */
angular.module('sn.common.attachments').directive('snFileUploadInput', function(cabrillo, $document) {
  'use strict';
  return {
    restrict: 'E',
    scope: {
      attachmentHandler: '=',
      customClassNames: '@classNames'
    },
    template: function() {
      var inputTemplate;
      if (cabrillo.isNative()) {
        inputTemplate = '<button class="{{classNames}}" ng-click="showAttachOptions($event)"><span class="upload-label"><translate key="Add Attachment" /></span></button>';
      } else {
        inputTemplate = '<button class="{{classNames}}" ng-file-select="onFileSelect($files)"><span class="upload-label"><translate key="Add Attachment" /></span></button>';
      }
      return [
        '<div class="file-upload-input">',
        inputTemplate,
        '</div>'
      ].join('');
    },
    controller: function($element, $scope) {
      var classNames = 'btn btn-icon attachment-btn icon-paperclip';
      if ($scope.customClassNames) {
        classNames += ' ' + $scope.customClassNames;
      }
      $scope.classNames = classNames;
      $scope.showAttachOptions = function($event) {
        var handler = $scope.attachmentHandler;
        var target = angular.element($event.currentTarget);
        var elRect = target[0].getBoundingClientRect();
        var body = $document[0].body;
        var rect = {
          x: elRect.left + body.scrollLeft,
          y: elRect.top + body.scrollTop,
          width: elRect.width,
          height: elRect.height
        };
        var options = {
          sourceRect: rect
        };
        cabrillo.attachments.addFile(
          handler.getTableName(),
          handler.getSysID(),
          null,
          options
        ).then(function(data) {
          console.log('Attached new file', data);
          handler.addAttachment(data);
        }, function() {
          console.log('Failed to attach new file');
        });
      };
      $scope.onFileSelect = function($files) {
        $scope.attachmentHandler.uploadAttachments($files);
      };
      $scope.showFileSelector = function($event) {
        $event.stopPropagation();
        var target = angular.element($event.currentTarget);
        var input = target.parent().find('input');
        input.triggerHandler('click');
      };
    }
  }
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snPasteFileHandler.js */
angular.module('sn.common.attachments').directive('snPasteFileHandler', function($parse) {
  'use strict';
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      var snPasteFileHandler = $parse(attrs.snPasteFileHandler);
      element.bind("paste", function(event) {
        event = event.originalEvent || event;
        var item = event.clipboardData.items[0];
        if (!item)
          return;
        var file = item.getAsFile();
        if (!file)
          return;
        snPasteFileHandler(scope, {
          file: file
        });
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snAttachmentList.js */
angular.module('sn.common.attachments').directive('snAttachmentList', function(getTemplateUrl, snAttachmentHandler, $rootScope, $window, $timeout, $q) {
    'use strict';
    return {
      restrict: 'E',
      replace: true,
      templateUrl: getTemplateUrl("sn_attachment_list.xml"),
      scope: {
        tableName: "=?",
        sysID: "=?sysId",
        attachmentList: "=?",
        uploadFileFn: "&",
        deleteFileFn: "=?",
        canEdit: "=?",
        canRemove: "=?",
        canAdd: "=?",
        canDownload: "=?",
        showHeader: "=?",
        clickImageFn: "&?",
        confirmDelete: "=?"
      },
      controller: function($scope) {
        $scope.canEdit = $scope.canEdit || false;
        $scope.canDownload = $scope.canDownload || false;
        $scope.canRemove = $scope.canRemove || false;
        $scope.canAdd = $scope.canAdd || false;
        $scope.showHeader = $scope.showHeader || false;
        $scope.clickImageFn = $scope.clickImageFn || function() {};
        $scope.confirmDelete = $scope.confirmDelete || false;
        $scope.filesInProgress = {};
        $scope.attachmentToDelete = null;

        function refreshResources() {
          var handler = snAttachmentHandler.create($scope.tableName, $scope.sysID);
          handler.getAttachments().then(function(files) {
            $scope.attachmentList = files;
          });
        }
        if (!$scope.attachmentList) {
          $scope.attachmentList = [];
          refreshResources();
        }
        $scope.$on('attachments_list.update', function(e, tableName, sysID) {
          if (tableName === $scope.tableName && sysID === $scope.sysID) {
            refreshResources();
          }
        });

        function removeFromFileProgress(fileName) {
          delete $scope.filesInProgress[fileName];
        }

        function updateFileProgress(file) {
          if (!$scope.filesInProgress[file.name])
            $scope.filesInProgress[file.name] = file;
        }
        $scope.$on('attachments_list.upload.progress', function(e, file) {
          updateFileProgress(file);
        });
        $scope.$on('attachments_list.upload.success', function(e, file) {
          removeFromFileProgress(file.name);
        });
        $scope.attachFiles = function(files) {
          if ($scope.tableName && $scope.sysID) {
            var handler = snAttachmentHandler.create($scope.tableName, $scope.sysID);
            var promises = [];
            files.forEach(function(file) {
              var promise = handler.uploadAttachment(file, null, {
                progress: function(e) {
                  var file = e.config.file;
                  file.progress = 100.0 * event.loaded / event.total;
                  updateFileProgress(file);
                },
                success: function(data) {
                  removeFromFileProgress(data.file_name);
                }
              });
              promises.push(promise);
            });
            $q.all(promises).then(function() {
              refreshResources();
            });
          } else {
            if ($scope.uploadFileFn)
              $scope.uploadFileFn({
                files: files
              });
          }
        };
        $scope.getProgressStyle = function(fileName) {
          return {
            'width': $scope.filesInProgress[fileName].progress + '%'
          };
        };
        $scope.openSelector = function($event) {
          $event.stopPropagation();
          var target = angular.element($event.currentTarget);
          $timeout(function() {
            target.parent().find('input').click();
          });
        };
        $scope.confirmDeleteAttachment = function(attachment) {
          $scope.attachmentToDelete = attachment;
          $scope.$broadcast('dialog.confirm-delete.show');
        };
        $scope.deleteAttachment = function() {
          snAttachmentHandler.deleteAttachment($scope.attachmentToDelete.sys_id).then(function() {
            var index = $scope.attachmentList.indexOf($scope.attachmentToDelete);
            $scope.attachmentList.splice(index, 1);
          });
        };
      }
    };
  })
  .directive('snAttachmentListItem', function(getTemplateUrl, snAttachmentHandler, $rootScope, $window, $timeout, $parse) {
    'use strict';
    return {
      restrict: "E",
      replace: true,
      templateUrl: getTemplateUrl("sn_attachment_list_item.xml"),
      link: function(scope, element, attrs) {
        function translateAttachment(att) {
          return {
            content_type: att.content_type,
            file_name: att.file_name,
            image: (att.thumbSrc !== undefined),
            size_bytes: att.size,
            sys_created_by: "",
            sys_created_on: "",
            sys_id: att.sys_id,
            thumb_src: att.thumbSrc
          };
        }
        scope.attachment = ($parse(attrs.attachment.size_bytes)) ?
          scope.$eval(attrs.attachment) :
          translateAttachment(attrs.attachment);
        var fileNameView = element.find('.sn-widget-list-title_view');
        var fileNameEdit = element.find('.sn-widget-list-title_edit');

        function editFileName() {
          fileNameView.hide();
          fileNameEdit.show();
          element.find('.edit-text-input').focus();
        }

        function viewFileName() {
          fileNameView.show();
          fileNameEdit.hide();
        }
        viewFileName();
        scope.editModeToggle = function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          scope.editMode = !scope.editMode;
          if (scope.editMode)
            editFileName();
          else
            viewFileName();
        };
        scope.updateName = function() {
          scope.editMode = false;
          viewFileName();
          snAttachmentHandler.renameAttachment(scope.attachment.sys_id, scope.attachment.file_name);
        };
      },
      controller: function($scope, snCustomEvent) {
        $scope.editMode = false;
        $scope.removeAttachment = function(attachment, index) {
          if ($scope.deleteFileFn !== undefined && $scope.deleteFileFn instanceof Function) {
            $scope.deleteFileFn.apply(null, arguments);
            return;
          }
          if ($scope.confirmDelete) {
            $scope.confirmDeleteAttachment($scope.attachment);
            return;
          }
          snAttachmentHandler.deleteAttachment($scope.attachment.sys_id).then(function() {
            $scope.attachmentList.splice($scope.$index, 1);
          });
        };
        var contentTypeMap = {
          "application/pdf": "icon-document-pdf",
          "text/plain": "icon-document-txt",
          "application/zip": "icon-document-zip",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "icon-document-doc",
          "application/vnd.openxmlformats-officedocument.presentationml.presentation": "icon-document-ppt",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "icon-document-xls",
          "application/vnd.ms-powerpoint": "icon-document-ppt"
        };
        $scope.getDocumentType = function(contentType) {
          return contentTypeMap[contentType] || "icon-document";
        };
        $scope.handleAttachmentClick = function(event) {
          if (event.keyCode === 9)
            return;
          if ($scope.editMode)
            return;
          if (!$scope.attachment)
            return;
          if ($scope.attachment.image)
            openImageInLightBox(event);
          else
            downloadAttachment();
        };

        function downloadAttachment() {
          if (!$scope.attachment.sys_id)
            return;
          $window.location.href = 'sys_attachment.do?sys_id=' + $scope.attachment.sys_id;
        }

        function openImageInLightBox(event) {
          if (!$scope.attachment.size)
            $scope.attachment.size = $scope.getSize($scope.attachment.size_bytes, 2);
          $scope.clickImageFn({
            file: $scope.attachment
          });
          snCustomEvent.fire('sn.attachment.preview', event, $scope.attachment);
        }
        $scope.getSize = function(bytes, precision) {
          if (typeof bytes === 'string' && bytes.slice(-1) === 'B')
            return bytes;
          var kb = 1024;
          var mb = kb * 1024;
          var gb = mb * 1024;
          if ((bytes >= 0) && (bytes < kb))
            return bytes + ' B';
          else if ((bytes >= kb) && (bytes < mb))
            return (bytes / kb).toFixed(precision) + ' KB';
          else if ((bytes >= mb) && (bytes < gb))
            return (bytes / mb).toFixed(precision) + ' MB';
          else if (bytes >= gb)
            return (bytes / gb).toFixed(precision) + ' GB';
          else
            return bytes + ' B';
        }
      }
    };
  });;;
/*! RESOURCE: /scripts/bootstrap_336.js */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
} +
function($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')
  }
}(jQuery); +
function($) {
  'use strict';

  function transitionEnd() {
    var el = document.createElement('bootstrap')
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    }
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return {
          end: transEndEventNames[name]
        }
      }
    }
    return false
  }
  $.fn.emulateTransitionEnd = function(duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function() {
      called = true
    })
    var callback = function() {
      if (!called) $($el).trigger($.support.transition.end)
    }
    setTimeout(callback, duration)
    return this
  }
  $(function() {
    $.support.transition = transitionEnd()
    if (!$.support.transition) return
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function(e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })
}(jQuery); +
function($) {
  'use strict';
  var dismiss = '[data-dismiss="alert"]'
  var Alert = function(el) {
    $(el).on('click', dismiss, this.close)
  }
  Alert.VERSION = '3.3.6'
  Alert.TRANSITION_DURATION = 150
  Alert.prototype.close = function(e) {
    var $this = $(this)
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    var $parent = $(selector)
    if (e) e.preventDefault()
    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }
    $parent.trigger(e = $.Event('close.bs.alert'))
    if (e.isDefaultPrevented()) return
    $parent.removeClass('in')

    function removeElement() {
      $parent.detach().trigger('closed.bs.alert').remove()
    }
    $.support.transition && $parent.hasClass('fade') ?
      $parent
      .one('bsTransitionEnd', removeElement)
      .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.alert')
      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.alert
  $.fn.alert = Plugin
  $.fn.alert.Constructor = Alert
  $.fn.alert.noConflict = function() {
    $.fn.alert = old
    return this
  }
  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
}(jQuery); +
function($) {
  'use strict';
  var Button = function(element, options) {
    this.$element = $(element)
    this.options = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }
  Button.VERSION = '3.3.6'
  Button.DEFAULTS = {
    loadingText: 'loading...'
  }
  Button.prototype.setState = function(state) {
    var d = 'disabled'
    var $el = this.$element
    var val = $el.is('input') ? 'val' : 'html'
    var data = $el.data()
    state += 'Text'
    if (data.resetText == null) $el.data('resetText', $el[val]())
    setTimeout($.proxy(function() {
      $el[val](data[state] == null ? this.options[state] : data[state])
      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }
  Button.prototype.toggle = function() {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')
    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.button')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.button', (data = new Button(this, options)))
      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }
  var old = $.fn.button
  $.fn.button = Plugin
  $.fn.button.Constructor = Button
  $.fn.button.noConflict = function() {
    $.fn.button = old
    return this
  }
  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })
}(jQuery); +
function($) {
  'use strict';
  var Carousel = function(element, options) {
    this.$element = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options = options
    this.paused = null
    this.sliding = null
    this.interval = null
    this.$active = null
    this.$items = null
    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }
  Carousel.VERSION = '3.3.6'
  Carousel.TRANSITION_DURATION = 600
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }
  Carousel.prototype.keydown = function(e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37:
        this.prev();
        break
      case 39:
        this.next();
        break
      default:
        return
    }
    e.preventDefault()
  }
  Carousel.prototype.cycle = function(e) {
    e || (this.paused = false)
    this.interval && clearInterval(this.interval)
    this.options.interval &&
      !this.paused &&
      (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
    return this
  }
  Carousel.prototype.getItemIndex = function(item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }
  Carousel.prototype.getItemForDirection = function(direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0) ||
      (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }
  Carousel.prototype.to = function(pos) {
    var that = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
    if (pos > (this.$items.length - 1) || pos < 0) return
    if (this.sliding) return this.$element.one('slid.bs.carousel', function() {
      that.to(pos)
    })
    if (activeIndex == pos) return this.pause().cycle()
    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }
  Carousel.prototype.pause = function(e) {
    e || (this.paused = true)
    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }
    this.interval = clearInterval(this.interval)
    return this
  }
  Carousel.prototype.next = function() {
    if (this.sliding) return
    return this.slide('next')
  }
  Carousel.prototype.prev = function() {
    if (this.sliding) return
    return this.slide('prev')
  }
  Carousel.prototype.slide = function(type, next) {
    var $active = this.$element.find('.item.active')
    var $next = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that = this
    if ($next.hasClass('active')) return (this.sliding = false)
    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return
    this.sliding = true
    isCycling && this.pause()
    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }
    var slidEvent = $.Event('slid.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function() {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function() {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }
    isCycling && this.cycle()
    return this
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action = typeof option == 'string' ? option : options.slide
      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }
  var old = $.fn.carousel
  $.fn.carousel = Plugin
  $.fn.carousel.Constructor = Carousel
  $.fn.carousel.noConflict = function() {
    $.fn.carousel = old
    return this
  }
  var clickHandler = function(e) {
    var href
    var $this = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''))
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false
    Plugin.call($target, options)
    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }
    e.preventDefault()
  }
  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
  $(window).on('load', function() {
    $('[data-ride="carousel"]').each(function() {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })
}(jQuery); +
function($) {
  'use strict';
  var Collapse = function(element, options) {
    this.$element = $(element)
    this.options = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
      '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null
    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }
    if (this.options.toggle) this.toggle()
  }
  Collapse.VERSION = '3.3.6'
  Collapse.TRANSITION_DURATION = 350
  Collapse.DEFAULTS = {
    toggle: true
  }
  Collapse.prototype.dimension = function() {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }
  Collapse.prototype.show = function() {
    if (this.transitioning || this.$element.hasClass('in')) return
    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }
    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }
    var dimension = this.dimension()
    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)
    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)
    this.transitioning = 1
    var complete = function() {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    var scrollSize = $.camelCase(['scroll', dimension].join('-'))
    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }
  Collapse.prototype.hide = function() {
    if (this.transitioning || !this.$element.hasClass('in')) return
    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    var dimension = this.dimension()
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight
    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)
    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)
    this.transitioning = 1
    var complete = function() {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    this.$element[dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }
  Collapse.prototype.toggle = function() {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }
  Collapse.prototype.getParent = function() {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function(i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }
  Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
    var isOpen = $element.hasClass('in')
    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target') ||
      (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')
    return $(target)
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.collapse
  $.fn.collapse = Plugin
  $.fn.collapse.Constructor = Collapse
  $.fn.collapse.noConflict = function() {
    $.fn.collapse = old
    return this
  }
  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
    var $this = $(this)
    if (!$this.attr('data-target')) e.preventDefault()
    var $target = getTargetFromTrigger($this)
    var data = $target.data('bs.collapse')
    var option = data ? 'toggle' : $this.data()
    Plugin.call($target, option)
  })
}(jQuery); +
function($) {
  'use strict';
  var backdrop = '.dropdown-backdrop'
  var toggle = '[data-toggle="dropdown"]'
  var Dropdown = function(element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }
  Dropdown.VERSION = '3.3.6'

  function getParent($this) {
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    var $parent = selector && $(selector)
    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function() {
      var $this = $(this)
      var $parent = getParent($this)
      var relatedTarget = {
        relatedTarget: this
      }
      if (!$parent.hasClass('open')) return
      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }
  Dropdown.prototype.toggle = function(e) {
    var $this = $(this)
    if ($this.is('.disabled, :disabled')) return
    var $parent = getParent($this)
    var isActive = $parent.hasClass('open')
    clearMenus()
    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }
      var relatedTarget = {
        relatedTarget: this
      }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')
      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }
    return false
  }
  Dropdown.prototype.keydown = function(e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
    var $this = $(this)
    e.preventDefault()
    e.stopPropagation()
    if ($this.is('.disabled, :disabled')) return
    var $parent = getParent($this)
    var isActive = $parent.hasClass('open')
    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }
    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)
    if (!$items.length) return
    var index = $items.index(e.target)
    if (e.which == 38 && index > 0) index--
      if (e.which == 40 && index < $items.length - 1) index++
        if (!~index) index = 0
    $items.eq(index).trigger('focus')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.dropdown')
      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.dropdown
  $.fn.dropdown = Plugin
  $.fn.dropdown.Constructor = Dropdown
  $.fn.dropdown.noConflict = function() {
    $.fn.dropdown = old
    return this
  }
  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
      e.stopPropagation()
    })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
}(jQuery); +
function($) {
  'use strict';
  var Modal = function(element, options) {
    this.options = options
    this.$body = $(document.body)
    this.$element = $(element)
    this.$dialog = this.$element.find('.modal-dialog')
    this.$backdrop = null
    this.isShown = null
    this.originalBodyPad = null
    this.scrollbarWidth = 0
    this.ignoreBackdropClick = false
    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function() {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }
  Modal.VERSION = '3.3.6'
  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }
  Modal.prototype.toggle = function(_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }
  Modal.prototype.show = function(_relatedTarget) {
    var that = this
    var e = $.Event('show.bs.modal', {
      relatedTarget: _relatedTarget
    })
    this.$element.trigger(e)
    if (this.isShown || e.isDefaultPrevented()) return
    this.isShown = true
    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')
    this.escape()
    this.resize()
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
    this.$dialog.on('mousedown.dismiss.bs.modal', function() {
      that.$element.one('mouseup.dismiss.bs.modal', function(e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })
    this.backdrop(function() {
      var transition = $.support.transition && that.$element.hasClass('fade')
      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body)
      }
      that.$element
        .show()
        .scrollTop(0)
      that.adjustDialog()
      if (transition) {
        that.$element[0].offsetWidth
      }
      that.$element.addClass('in')
      that.enforceFocus()
      var e = $.Event('shown.bs.modal', {
        relatedTarget: _relatedTarget
      })
      transition ?
        that.$dialog
        .one('bsTransitionEnd', function() {
          that.$element.trigger('focus').trigger(e)
        })
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }
  Modal.prototype.hide = function(e) {
    if (e) e.preventDefault()
    e = $.Event('hide.bs.modal')
    this.$element.trigger(e)
    if (!this.isShown || e.isDefaultPrevented()) return
    this.isShown = false
    this.escape()
    this.resize()
    $(document).off('focusin.bs.modal')
    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')
    this.$dialog.off('mousedown.dismiss.bs.modal')
    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
      .one('bsTransitionEnd', $.proxy(this.hideModal, this))
      .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }
  Modal.prototype.enforceFocus = function() {
    $(document)
      .off('focusin.bs.modal')
      .on('focusin.bs.modal', $.proxy(function(e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }
  Modal.prototype.escape = function() {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }
  Modal.prototype.resize = function() {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }
  Modal.prototype.hideModal = function() {
    var that = this
    this.$element.hide()
    this.backdrop(function() {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }
  Modal.prototype.removeBackdrop = function() {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }
  Modal.prototype.backdrop = function(callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''
    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate
      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)
      this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static' ?
          this.$element[0].focus() :
          this.hide()
      }, this))
      if (doAnimate) this.$backdrop[0].offsetWidth
      this.$backdrop.addClass('in')
      if (!callback) return
      doAnimate ?
        this.$backdrop
        .one('bsTransitionEnd', callback)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')
      var callbackRemove = function() {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
        .one('bsTransitionEnd', callbackRemove)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()
    } else if (callback) {
      callback()
    }
  }
  Modal.prototype.handleUpdate = function() {
    this.adjustDialog()
  }
  Modal.prototype.adjustDialog = function() {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }
  Modal.prototype.resetAdjustments = function() {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }
  Modal.prototype.checkScrollbar = function() {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) {
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }
  Modal.prototype.setScrollbar = function() {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }
  Modal.prototype.resetScrollbar = function() {
    this.$body.css('padding-right', this.originalBodyPad)
  }
  Modal.prototype.measureScrollbar = function() {
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }

  function Plugin(option, _relatedTarget) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }
  var old = $.fn.modal
  $.fn.modal = Plugin
  $.fn.modal.Constructor = Modal
  $.fn.modal.noConflict = function() {
    $.fn.modal = old
    return this
  }
  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
    var $this = $(this)
    var href = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, '')))
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({
      remote: !/#/.test(href) && href
    }, $target.data(), $this.data())
    if ($this.is('a')) e.preventDefault()
    $target.one('show.bs.modal', function(showEvent) {
      if (showEvent.isDefaultPrevented()) return
      $target.one('hidden.bs.modal', function() {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })
}(jQuery); +
function($) {
  'use strict';
  var Tooltip = function(element, options) {
    this.type = null
    this.options = null
    this.enabled = null
    this.timeout = null
    this.hoverState = null
    this.$element = null
    this.inState = null
    this.init('tooltip', element, options)
  }
  Tooltip.VERSION = '3.3.6'
  Tooltip.TRANSITION_DURATION = 150
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }
  Tooltip.prototype.init = function(type, element, options) {
    this.enabled = true
    this.type = type
    this.$element = $(element)
    this.options = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState = {
      click: false,
      hover: false,
      focus: false
    }
    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }
    var triggers = this.options.trigger.split(' ')
    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]
      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }
    this.options.selector ?
      (this._options = $.extend({}, this.options, {
        trigger: 'manual',
        selector: ''
      })) :
      this.fixTitle()
  }
  Tooltip.prototype.getDefaults = function() {
    return Tooltip.DEFAULTS
  }
  Tooltip.prototype.getOptions = function(options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }
    return options
  }
  Tooltip.prototype.getDelegateOptions = function() {
    var options = {}
    var defaults = this.getDefaults()
    this._options && $.each(this._options, function(key, value) {
      if (defaults[key] != value) options[key] = value
    })
    return options
  }
  Tooltip.prototype.enter = function(obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }
    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }
    clearTimeout(self.timeout)
    self.hoverState = 'in'
    if (!self.options.delay || !self.options.delay.show) return self.show()
    self.timeout = setTimeout(function() {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }
  Tooltip.prototype.isInStateTrue = function() {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }
    return false
  }
  Tooltip.prototype.leave = function(obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }
    if (self.isInStateTrue()) return
    clearTimeout(self.timeout)
    self.hoverState = 'out'
    if (!self.options.delay || !self.options.delay.hide) return self.hide()
    self.timeout = setTimeout(function() {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }
  Tooltip.prototype.show = function() {
    var e = $.Event('show.bs.' + this.type)
    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)
      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this
      var $tip = this.tip()
      var tipId = this.getUID(this.type)
      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)
      if (this.options.animation) $tip.addClass('fade')
      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement
      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
      $tip
        .detach()
        .css({
          top: 0,
          left: 0,
          display: 'block'
        })
        .addClass(placement)
        .data('bs.' + this.type, this)
      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)
      var pos = this.getPosition()
      var actualWidth = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight
      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)
        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' :
          placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' :
          placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' :
          placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' :
          placement
        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }
      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
      this.applyPlacement(calculatedOffset, placement)
      var complete = function() {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null
        if (prevHoverState == 'out') that.leave(that)
      }
      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }
  Tooltip.prototype.applyPlacement = function(offset, placement) {
    var $tip = this.tip()
    var width = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)
    if (isNaN(marginTop)) marginTop = 0
    if (isNaN(marginLeft)) marginLeft = 0
    offset.top += marginTop
    offset.left += marginLeft
    $.offset.setOffset($tip[0], $.extend({
      using: function(props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)
    $tip.addClass('in')
    var actualWidth = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight
    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }
    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
    if (delta.left) offset.left += delta.left
    else offset.top += delta.top
    var isVertical = /top|bottom/.test(placement)
    var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }
  Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }
  Tooltip.prototype.setContent = function() {
    var $tip = this.tip()
    var title = this.getTitle()
    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }
  Tooltip.prototype.hide = function(callback) {
    var that = this
    var $tip = $(this.$tip)
    var e = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }
    this.$element.trigger(e)
    if (e.isDefaultPrevented()) return
    $tip.removeClass('in')
    $.support.transition && $tip.hasClass('fade') ?
      $tip
      .one('bsTransitionEnd', complete)
      .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()
    this.hoverState = null
    return this
  }
  Tooltip.prototype.fixTitle = function() {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }
  Tooltip.prototype.hasContent = function() {
    return this.getTitle()
  }
  Tooltip.prototype.getPosition = function($element) {
    $element = $element || this.$element
    var el = $element[0]
    var isBody = el.tagName == 'BODY'
    var elRect = el.getBoundingClientRect()
    if (elRect.width == null) {
      elRect = $.extend({}, elRect, {
        width: elRect.right - elRect.left,
        height: elRect.bottom - elRect.top
      })
    }
    var elOffset = isBody ? {
      top: 0,
      left: 0
    } : $element.offset()
    var scroll = {
      scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
    }
    var outerDims = isBody ? {
      width: $(window).width(),
      height: $(window).height()
    } : null
    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }
  Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? {
        top: pos.top + pos.height,
        left: pos.left + pos.width / 2 - actualWidth / 2
      } :
      placement == 'top' ? {
        top: pos.top - actualHeight,
        left: pos.left + pos.width / 2 - actualWidth / 2
      } :
      placement == 'left' ? {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left - actualWidth
      } : {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left + pos.width
      }
  }
  Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
    var delta = {
      top: 0,
      left: 0
    }
    if (!this.$viewport) return delta
    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)
    if (/right|left/.test(placement)) {
      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) {
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) {
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) {
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }
    return delta
  }
  Tooltip.prototype.getTitle = function() {
    var title
    var $e = this.$element
    var o = this.options
    title = $e.attr('data-original-title') ||
      (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)
    return title
  }
  Tooltip.prototype.getUID = function(prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }
  Tooltip.prototype.tip = function() {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }
  Tooltip.prototype.arrow = function() {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }
  Tooltip.prototype.enable = function() {
    this.enabled = true
  }
  Tooltip.prototype.disable = function() {
    this.enabled = false
  }
  Tooltip.prototype.toggleEnabled = function() {
    this.enabled = !this.enabled
  }
  Tooltip.prototype.toggle = function(e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }
    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }
  Tooltip.prototype.destroy = function() {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function() {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option
      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tooltip
  $.fn.tooltip = Plugin
  $.fn.tooltip.Constructor = Tooltip
  $.fn.tooltip.noConflict = function() {
    $.fn.tooltip = old
    return this
  }
}(jQuery); +
function($) {
  'use strict';
  var Popover = function(element, options) {
    this.init('popover', element, options)
  }
  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
  Popover.VERSION = '3.3.6'
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })
  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
  Popover.prototype.constructor = Popover
  Popover.prototype.getDefaults = function() {
    return Popover.DEFAULTS
  }
  Popover.prototype.setContent = function() {
    var $tip = this.tip()
    var title = this.getTitle()
    var content = this.getContent()
    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)
    $tip.removeClass('fade top bottom left right in')
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }
  Popover.prototype.hasContent = function() {
    return this.getTitle() || this.getContent()
  }
  Popover.prototype.getContent = function() {
    var $e = this.$element
    var o = this.options
    return $e.attr('data-content') ||
      (typeof o.content == 'function' ?
        o.content.call($e[0]) :
        o.content)
  }
  Popover.prototype.arrow = function() {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.popover')
      var options = typeof option == 'object' && option
      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.popover
  $.fn.popover = Plugin
  $.fn.popover.Constructor = Popover
  $.fn.popover.noConflict = function() {
    $.fn.popover = old
    return this
  }
}(jQuery); +
function($) {
  'use strict';

  function ScrollSpy(element, options) {
    this.$body = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector = (this.options.target || '') + ' .nav li > a'
    this.offsets = []
    this.targets = []
    this.activeTarget = null
    this.scrollHeight = 0
    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }
  ScrollSpy.VERSION = '3.3.6'
  ScrollSpy.DEFAULTS = {
    offset: 10
  }
  ScrollSpy.prototype.getScrollHeight = function() {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }
  ScrollSpy.prototype.refresh = function() {
    var that = this
    var offsetMethod = 'offset'
    var offsetBase = 0
    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()
    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase = this.$scrollElement.scrollTop()
    }
    this.$body
      .find(this.selector)
      .map(function() {
        var $el = $(this)
        var href = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)
        return ($href &&
          $href.length &&
          $href.is(':visible') &&
          [
            [$href[offsetMethod]().top + offsetBase, href]
          ]) || null
      })
      .sort(function(a, b) {
        return a[0] - b[0]
      })
      .each(function() {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }
  ScrollSpy.prototype.process = function() {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets = this.offsets
    var targets = this.targets
    var activeTarget = this.activeTarget
    var i
    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }
    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }
    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }
    for (i = offsets.length; i--;) {
      activeTarget != targets[i] &&
        scrollTop >= offsets[i] &&
        (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) &&
        this.activate(targets[i])
    }
  }
  ScrollSpy.prototype.activate = function(target) {
    this.activeTarget = target
    this.clear()
    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'
    var active = $(selector)
      .parents('li')
      .addClass('active')
    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }
    active.trigger('activate.bs.scrollspy')
  }
  ScrollSpy.prototype.clear = function() {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.scrollspy
  $.fn.scrollspy = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy
  $.fn.scrollspy.noConflict = function() {
    $.fn.scrollspy = old
    return this
  }
  $(window).on('load.bs.scrollspy.data-api', function() {
    $('[data-spy="scroll"]').each(function() {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })
}(jQuery); +
function($) {
  'use strict';
  var Tab = function(element) {
    this.element = $(element)
  }
  Tab.VERSION = '3.3.6'
  Tab.TRANSITION_DURATION = 150
  Tab.prototype.show = function() {
    var $this = this.element
    var $ul = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    if ($this.parent('li').hasClass('active')) return
    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })
    $previous.trigger(hideEvent)
    $this.trigger(showEvent)
    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
    var $target = $(selector)
    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function() {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }
  Tab.prototype.activate = function(element, container, callback) {
    var $active = container.find('> .active')
    var transition = callback &&
      $.support.transition &&
      ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
        .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
        .attr('aria-expanded', false)
      element
        .addClass('active')
        .find('[data-toggle="tab"]')
        .attr('aria-expanded', true)
      if (transition) {
        element[0].offsetWidth
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }
      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
          .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)
      }
      callback && callback()
    }
    $active.length && transition ?
      $active
      .one('bsTransitionEnd', next)
      .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()
    $active.removeClass('in')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.tab')
      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tab
  $.fn.tab = Plugin
  $.fn.tab.Constructor = Tab
  $.fn.tab.noConflict = function() {
    $.fn.tab = old
    return this
  }
  var clickHandler = function(e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }
  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
}(jQuery); +
function($) {
  'use strict';
  var Affix = function(element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)
    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this))
    this.$element = $(element)
    this.affixed = null
    this.unpin = null
    this.pinnedOffset = null
    this.checkPosition()
  }
  Affix.VERSION = '3.3.6'
  Affix.RESET = 'affix affix-top affix-bottom'
  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }
  Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop = this.$target.scrollTop()
    var position = this.$element.offset()
    var targetHeight = this.$target.height()
    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }
    var initializing = this.affixed == null
    var colliderTop = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height
    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
    return false
  }
  Affix.prototype.getPinnedOffset = function() {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }
  Affix.prototype.checkPositionWithEventLoop = function() {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }
  Affix.prototype.checkPosition = function() {
    if (!this.$element.is(':visible')) return
    var height = this.$element.height()
    var offset = this.options.offset
    var offsetTop = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())
    if (typeof offset != 'object') offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')
      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e = $.Event(affixType + '.bs.affix')
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }
    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.affix')
      var options = typeof option == 'object' && option
      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.affix
  $.fn.affix = Plugin
  $.fn.affix.Constructor = Affix
  $.fn.affix.noConflict = function() {
    $.fn.affix = old
    return this
  }
  $(window).on('load', function() {
    $('[data-spy="affix"]').each(function() {
      var $spy = $(this)
      var data = $spy.data()
      data.offset = data.offset || {}
      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop != null) data.offset.top = data.offsetTop
      Plugin.call($spy, data)
    })
  })
}(jQuery);;
/*! RESOURCE: /scripts/iconset-fontawesome-4.2.0.js */
;
(function($) {
  $.iconset_fontawesome = {
    iconClass: 'fa',
    iconClassFix: 'fa-',
    icons: [
      '',
      'adjust',
      'anchor',
      'archive',
      'area-chart',
      'arrows',
      'arrows-h',
      'arrows-v',
      'automobile',
      'asterisk',
      'at',
      'ban',
      'bank',
      'bar-chart-o',
      'barcode',
      'bars',
      'beer',
      'bell',
      'bell-o',
      'bell-slash',
      'bell-slash-o',
      'bicycle',
      'binoculars',
      'birthday-cake',
      'bolt',
      'bomb',
      'book',
      'bookmark',
      'bookmark-o',
      'briefcase',
      'bug',
      'building',
      'building-o',
      'bullhorn',
      'bullseye',
      'bus',
      'cab',
      'calculator',
      'calendar',
      'calendar-o',
      'camera',
      'camera-retro',
      'car',
      'caret-square-o-down',
      'caret-square-o-left',
      'caret-square-o-right',
      'caret-square-o-up',
      'cc',
      'cc-amex',
      'cc-discover',
      'cc-mastercard',
      'cc-paypal',
      'cc-stripe',
      'cc-visa',
      'certificate',
      'check',
      'check-circle',
      'check-circle-o',
      'check-square',
      'check-square-o',
      'child',
      'circle',
      'circle-o',
      'circle-thin',
      'clock-o',
      'cloud',
      'cloud-download',
      'cloud-upload',
      'code',
      'code-fork',
      'coffee',
      'cog',
      'cogs',
      'comment',
      'comment-o',
      'comments',
      'comments-o',
      'compass',
      'copyright',
      'credit-card',
      'crop',
      'crosshairs',
      'cube',
      'cubes',
      'cutlery',
      'dashboard',
      'desktop',
      'dashboard',
      'database',
      'desktop',
      'dot-circle-o',
      'download',
      'edit',
      'ellipsis-h',
      'ellipsis-v',
      'envelope',
      'envelope-o',
      'envelope-square',
      'eraser',
      'exchange',
      'exclamation',
      'exclamation-circle',
      'exclamation-triangle',
      'external-link',
      'external-link-square',
      'eye',
      'eye-slash',
      'eyedropper',
      'fax',
      'female',
      'fighter-jet',
      'file-archive-o',
      'file-audio-o',
      'file-code-o',
      'file-excel-o',
      'file-image-o',
      'file-movie-o',
      'file-pdf-o',
      'file-photo-o',
      'file-picture-o',
      'file-powerpoint-o',
      'file-sound-o',
      'file-video-o',
      'file-word-o',
      'file-zip-o',
      'film',
      'filter',
      'fire',
      'fire-extinguisher',
      'flag',
      'flag-checkered',
      'flag-o',
      'flash',
      'flask',
      'folder',
      'folder-o',
      'folder-open',
      'folder-open-o',
      'frown-o',
      'futbol-o',
      'gamepad',
      'gavel',
      'gear',
      'gears',
      'gift',
      'glass',
      'globe',
      'graduation-cap',
      'group',
      'hdd-o',
      'headphones',
      'heart',
      'heart-o',
      'history',
      'home',
      'image',
      'inbox',
      'info',
      'info-circle',
      'institution',
      'key',
      'keyboard-o',
      'language',
      'laptop',
      'leaf',
      'legal',
      'lemon-o',
      'level-down',
      'level-up',
      'life-bouy',
      'life-ring',
      'life-saver',
      'lightbulb-o',
      'line-chart',
      'location-arrow',
      'lock',
      'magic',
      'magnet',
      'mail-forward',
      'mail-reply',
      'mail-reply-all',
      'male',
      'map-marker',
      'meh-o',
      'microphone',
      'microphone-slash',
      'minus',
      'minus-circle',
      'minus-square',
      'minus-square-o',
      'mobile',
      'mobile-phone',
      'money',
      'moon-o',
      'mortar-board',
      'music',
      'navicon',
      'newspaper-o',
      'paint-brush',
      'paper-plane',
      'paper-plane-o',
      'paw',
      'pencil',
      'pencil-square',
      'pencil-square-o',
      'phone',
      'phone-square',
      'photo',
      'picture-o',
      'pie-chart',
      'plane',
      'plug',
      'plus',
      'plus-circle',
      'plus-square',
      'plus-square-o',
      'power-off',
      'print',
      'puzzle-piece',
      'qrcode',
      'question',
      'question-circle',
      'quote-left',
      'quote-right',
      'random',
      'refresh',
      'reorder',
      'reply',
      'reply-all',
      'retweet',
      'road',
      'rocket',
      'rss',
      'rss-square',
      'search',
      'search-minus',
      'search-plus',
      'send',
      'send-o',
      'share',
      'share-alt',
      'share-alt-square',
      'share-square',
      'share-square-o',
      'shield',
      'shopping-cart',
      'sign-in',
      'sign-out',
      'signal',
      'sitemap',
      'sliders',
      'smile-o',
      'soccer-ball-o',
      'sort',
      'sort-alpha-asc',
      'sort-alpha-desc',
      'sort-amount-asc',
      'sort-amount-desc',
      'sort-asc',
      'sort-desc',
      'sort-down',
      'sort-numeric-asc',
      'sort-numeric-desc',
      'sort-up',
      'space-shuttle',
      'spinner',
      'spoon',
      'square',
      'square-o',
      'star',
      'star-half',
      'star-half-empty',
      'star-half-full',
      'star-half-o',
      'star-o',
      'suitcase',
      'sun-o',
      'support',
      'tablet',
      'tachometer',
      'tag',
      'tags',
      'tasks',
      'taxi',
      'terminal',
      'thumb-tack',
      'thumbs-down',
      'thumbs-o-down',
      'thumbs-o-up',
      'thumbs-up',
      'ticket',
      'times',
      'times-circle',
      'times-circle-o',
      'tint',
      'toggle-down',
      'toggle-left',
      'toggle-off',
      'toggle-on',
      'toggle-right',
      'toggle-up',
      'trash',
      'trash-o',
      'tree',
      'trophy',
      'truck',
      'tty',
      'umbrella',
      'university',
      'unlock',
      'unlock-alt',
      'unsorted',
      'upload',
      'user',
      'users',
      'video-camera',
      'volume-down',
      'volume-off',
      'volume-up',
      'warning',
      'wheelchair',
      'wifi',
      'wrench',
      'check-square',
      'check-square-o',
      'circle',
      'circle-o',
      'dot-circle-o',
      'minus-square',
      'minus-square-o',
      'plus-square',
      'plus-square-o',
      'square',
      'square-o',
      'bitcoin',
      'btc',
      'cny',
      'dollar',
      'eur',
      'euro',
      'gbp',
      'ils',
      'inr',
      'jpy',
      'krw',
      'money',
      'rmb',
      'rouble',
      'rub',
      'ruble',
      'rupee',
      'shekel',
      'sheqel',
      'try',
      'turkish-lira',
      'usd',
      'won',
      'yen',
      'align-center',
      'align-justify',
      'align-left',
      'align-right',
      'bold',
      'chain',
      'chain-broken',
      'clipboard',
      'columns',
      'copy',
      'cut',
      'dedent',
      'eraser',
      'file',
      'file-o',
      'file-text',
      'file-text-o',
      'files-o',
      'floppy-o',
      'font',
      'header',
      'indent',
      'italic',
      'link',
      'list',
      'list-alt',
      'list-ol',
      'list-ul',
      'outdent',
      'paperclip',
      'paragraph',
      'paste',
      'repeat',
      'rotate-left',
      'rotate-right',
      'save',
      'scissors',
      'strikethrough',
      'subscript',
      'superscript',
      'table',
      'text-height',
      'text-width',
      'th',
      'th-large',
      'th-list',
      'underline',
      'undo',
      'unlink',
      'angle-double-down',
      'angle-double-left',
      'angle-double-right',
      'angle-double-up',
      'angle-down',
      'angle-left',
      'angle-right',
      'angle-up',
      'arrow-circle-down',
      'arrow-circle-left',
      'arrow-circle-o-down',
      'arrow-circle-o-left',
      'arrow-circle-o-right',
      'arrow-circle-o-up',
      'arrow-circle-right',
      'arrow-circle-up',
      'arrow-down',
      'arrow-left',
      'arrow-right',
      'arrow-up',
      'arrows',
      'arrows-alt',
      'arrows-h',
      'arrows-v',
      'caret-down',
      'caret-left',
      'caret-right',
      'caret-square-o-down',
      'caret-square-o-left',
      'caret-square-o-right',
      'caret-square-o-up',
      'caret-up',
      'chevron-circle-down',
      'chevron-circle-left',
      'chevron-circle-right',
      'chevron-circle-up',
      'chevron-down',
      'chevron-left',
      'chevron-right',
      'chevron-up',
      'hand-o-down',
      'hand-o-left',
      'hand-o-right',
      'hand-o-up',
      'long-arrow-down',
      'long-arrow-left',
      'long-arrow-right',
      'long-arrow-up',
      'toggle-down',
      'toggle-left',
      'toggle-right',
      'toggle-up',
      'arrows-alt',
      'backward',
      'compress',
      'eject',
      'expand',
      'fast-backward',
      'fast-forward',
      'forward',
      'pause',
      'play',
      'play-circle',
      'play-circle-o',
      'step-backward',
      'step-forward',
      'stop',
      'youtube-play',
      'adn',
      'android',
      'angellist',
      'apple',
      'behance',
      'behance-square',
      'bitbucket',
      'bitbucket-square',
      'bitcoin',
      'btc',
      'css3',
      'delicious',
      'digg',
      'dribbble',
      'dropbox',
      'drupal',
      'empire',
      'facebook',
      'facebook-square',
      'flickr',
      'foursquare',
      'ge',
      'git',
      'git-square',
      'github',
      'github-alt',
      'github-square',
      'gittip',
      'google',
      'google-plus',
      'google-plus-square',
      'google-wallet',
      'hacker-news',
      'html5',
      'instagram',
      'ioxhost',
      'joomla',
      'jsfiddle',
      'lastfm',
      'lastfm-square',
      'linkedin',
      'linkedin-square',
      'linux',
      'maxcdn',
      'meanpath',
      'openid',
      'pagelines',
      'paypal',
      'pied-piper',
      'pied-piper-alt',
      'pinterest',
      'pinterest-square',
      'qq',
      'ra',
      'rebel',
      'reddit',
      'reddit-square',
      'renren',
      'share-alt',
      'share-alt-square',
      'skype',
      'slack',
      'slideshare',
      'soundcloud',
      'spotify',
      'stack-exchange',
      'stack-overflow',
      'steam',
      'steam-square',
      'stumbleupon',
      'stumbleupon-circle',
      'tencent-weibo',
      'trello',
      'tumblr',
      'tumblr-square',
      'twitch',
      'twitter',
      'twitter-square',
      'vimeo-square',
      'vine',
      'vk',
      'wechat',
      'weibo',
      'weixin',
      'windows',
      'wordpress',
      'xing',
      'xing-square',
      'yahoo',
      'yelp',
      'youtube',
      'youtube-play',
      'youtube-square',
      'ambulance',
      'h-square',
      'hospital-o',
      'medkit',
      'plus-square',
      'stethoscope',
      'user-md',
      'wheelchair'
    ]
  };
})(jQuery);;
/*! RESOURCE: /scripts/bootstrap-iconpicker.js */
;
(function($) {
  "use strict";
  var Iconpicker = function(element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Iconpicker.DEFAULTS, this.$element.data());
    this.options = $.extend({}, this.options, options);
  };
  Iconpicker.ICONSET_EMPTY = {
    iconClass: '',
    iconClassFix: '',
    icons: []
  };
  Iconpicker.ICONSET = {
    _custom: null,
    elusiveicon: $.iconset_elusiveicon || Iconpicker.ICONSET_EMPTY,
    fontawesome: $.iconset_fontawesome || Iconpicker.ICONSET_EMPTY,
    ionicon: $.iconset_ionicon || Iconpicker.ICONSET_EMPTY,
    glyphicon: $.iconset_glyphicon || Iconpicker.ICONSET_EMPTY,
    mapicon: $.iconset_mapicon || Iconpicker.ICONSET_EMPTY,
    materialdesign: $.iconset_materialdesign || Iconpicker.ICONSET_EMPTY,
    octicon: $.iconset_octicon || Iconpicker.ICONSET_EMPTY,
    typicon: $.iconset_typicon || Iconpicker.ICONSET_EMPTY,
    weathericon: $.iconset_weathericon || Iconpicker.ICONSET_EMPTY
  };
  Iconpicker.DEFAULTS = {
    align: 'center',
    arrowClass: 'btn-primary',
    arrowNextIconClass: 'glyphicon glyphicon-arrow-right',
    arrowPrevIconClass: 'glyphicon glyphicon-arrow-left',
    cols: 4,
    icon: '',
    iconset: 'glyphicon',
    header: true,
    labelHeader: '{0} / {1}',
    footer: true,
    labelFooter: '{0} - {1} of {2}',
    placement: 'bottom',
    rows: 4,
    search: true,
    searchText: 'Search icon',
    selectedClass: 'btn-warning',
    unselectedClass: 'btn-default'
  };
  Iconpicker.prototype.bindEvents = function() {
    var op = this.options;
    var el = this;
    op.table.find('.btn-previous, .btn-next').off('click').on('click', function(e) {
      e.preventDefault();
      var inc = parseInt($(this).val(), 10);
      el.changeList(op.page + inc);
    });
    op.table.find('.btn-icon').off('click').on('click', function(e) {
      e.preventDefault();
      el.select($(this).val());
      if (op.inline === false) {
        el.$element.popover('destroy');
      } else {
        op.table.find('i.' + $(this).val()).parent().addClass(op.selectedClass);
      }
    });
    op.table.find('.search-control').off('keyup').on('keyup', function() {
      el.changeList(1);
    });
  };
  Iconpicker.prototype.changeList = function(page) {
    this.filterIcons();
    this.updateLabels(page);
    this.updateIcons(page);
    this.options.page = page;
    this.bindEvents();
  };
  Iconpicker.prototype.filterIcons = function() {
    var op = this.options;
    var search = op.table.find('.search-control').val();
    if (search === "") {
      op.icons = Iconpicker.ICONSET[op.iconset].icons;
    } else {
      var result = [];
      $.each(Iconpicker.ICONSET[op.iconset].icons, function(i, v) {
        if (v.indexOf(search) > -1) {
          result.push(v);
        }
      });
      op.icons = result;
    }
  };
  Iconpicker.prototype.removeAddClass = function(target, remove, add) {
    this.options.table.find(target).removeClass(remove).addClass(add);
    return add;
  };
  Iconpicker.prototype.reset = function() {
    this.updatePicker();
    this.changeList(1);
  };
  Iconpicker.prototype.select = function(icon) {
    var op = this.options;
    var el = this.$element;
    op.selected = $.inArray(icon.replace(op.iconClassFix, ''), op.icons);
    if (op.selected === -1) {
      op.selected = 0;
      icon = op.iconClassFix + op.icons[op.selected];
    }
    if (icon !== '' && op.selected >= 0) {
      op.icon = icon;
      if (op.inline === false) {
        el.find('input').val(icon);
        el.find('i').attr('class', '').addClass(op.iconClass).addClass(icon);
      }
      if (icon === op.iconClassFix) {
        el.trigger({
          type: "change",
          icon: 'empty'
        });
      } else {
        el.trigger({
          type: "change",
          icon: icon
        });
      }
      op.table.find('button.' + op.selectedClass).removeClass(op.selectedClass);
    }
  };
  Iconpicker.prototype.switchPage = function(icon) {
    var op = this.options;
    op.selected = $.inArray(icon.replace(op.iconClassFix, ''), op.icons);
    if (op.selected >= 0) {
      var page = Math.ceil((op.selected + 1) / this.totalIconsPerPage());
      this.changeList(page);
    }
    if (icon === '') {
      op.table.find('i.' + op.iconClassFix).parent().addClass(op.selectedClass);
    } else {
      op.table.find('i.' + icon).parent().addClass(op.selectedClass);
    }
  };
  Iconpicker.prototype.totalPages = function() {
    return Math.ceil(this.totalIcons() / this.totalIconsPerPage());
  };
  Iconpicker.prototype.totalIcons = function() {
    return this.options.icons.length;
  };
  Iconpicker.prototype.totalIconsPerPage = function() {
    if (this.options.rows === 0) {
      return this.options.icons.length;
    } else {
      return this.options.cols * this.options.rows;
    }
  };
  Iconpicker.prototype.updateArrows = function(page) {
    var op = this.options;
    var total_pages = this.totalPages();
    if (page === 1) {
      op.table.find('.btn-previous').addClass('disabled');
    } else {
      op.table.find('.btn-previous').removeClass('disabled');
    }
    if (page === total_pages || total_pages === 0) {
      op.table.find('.btn-next').addClass('disabled');
    } else {
      op.table.find('.btn-next').removeClass('disabled');
    }
  };
  Iconpicker.prototype.updateIcons = function(page) {
    var op = this.options;
    var tbody = op.table.find('tbody').empty();
    var offset = (page - 1) * this.totalIconsPerPage();
    var length = op.rows;
    if (op.rows === 0) {
      length = op.icons.length;
    }
    for (var i = 0; i < length; i++) {
      var tr = $('<tr></tr>');
      for (var j = 0; j < op.cols; j++) {
        var pos = offset + (i * op.cols) + j;
        var btn = $('<button class="btn ' + op.unselectedClass + ' btn-icon"></button>').hide();
        if (pos < op.icons.length) {
          var v = op.iconClassFix + op.icons[pos];
          btn.val(v).attr('title', v).append('<i class="' + op.iconClass + ' ' + v + '"></i>').show();
          if (op.icon === v) {
            btn.addClass(op.selectedClass).addClass('btn-icon-selected');
          }
        }
        tr.append($('<td></td>').append(btn));
      }
      tbody.append(tr);
    }
  };
  Iconpicker.prototype.updateIconsCount = function() {
    var op = this.options;
    if (op.footer === true) {
      var icons_count = [
        '<tr>',
        '   <td colspan="' + op.cols + '" class="text-center">',
        '       <span class="icons-count"></span>',
        '   </td>',
        '</tr>'
      ];
      op.table.find('tfoot').empty().append(icons_count.join(''));
    }
  };
  Iconpicker.prototype.updateLabels = function(page) {
    var op = this.options;
    var total_icons = this.totalIcons();
    var total_pages = this.totalPages();
    op.table.find('.page-count').html(op.labelHeader.replace('{0}', (total_pages === 0) ? 0 : page).replace('{1}', total_pages));
    var offset = (page - 1) * this.totalIconsPerPage();
    var total = page * this.totalIconsPerPage();
    op.table.find('.icons-count').html(op.labelFooter.replace('{0}', total_icons ? offset + 1 : 0).replace('{1}', (total < total_icons) ? total : total_icons).replace('{2}', total_icons));
    this.updateArrows(page);
  };
  Iconpicker.prototype.updatePagesCount = function() {
    var op = this.options;
    if (op.header === true) {
      var tr = $('<tr></tr>');
      for (var i = 0; i < op.cols; i++) {
        var td = $('<td class="text-center"></td>');
        if (i === 0 || i === op.cols - 1) {
          var arrow = [
            '<button class="btn btn-arrow ' + ((i === 0) ? 'btn-previous' : 'btn-next') + ' ' + op.arrowClass + '" value="' + ((i === 0) ? -1 : 1) + '">',
            '<span class="' + ((i === 0) ? op.arrowPrevIconClass : op.arrowNextIconClass) + '"></span>',
            '</button>'
          ];
          td.append(arrow.join(''));
          tr.append(td);
        } else if (tr.find('.page-count').length === 0) {
          td.attr('colspan', op.cols - 2).append('<span class="page-count"></span>');
          tr.append(td);
        }
      }
      op.table.find('thead').empty().append(tr);
    }
  };
  Iconpicker.prototype.updatePicker = function() {
    var op = this.options;
    if (op.cols < 4) {
      throw 'Iconpicker => The number of columns must be greater than or equal to 4. [option.cols = ' + op.cols + ']';
    } else if (op.rows < 0) {
      throw 'Iconpicker => The number of rows must be greater than or equal to 0. [option.rows = ' + op.rows + ']';
    } else {
      this.updatePagesCount();
      this.updateSearch();
      this.updateIconsCount();
    }
  };
  Iconpicker.prototype.updateSearch = function() {
    var op = this.options;
    var search = [
      '<tr style="display: table-row;">',
      '   <td colspan="' + op.cols + '">',
      '       <input type="text" class="form-control search-control" style="width: ' + op.cols * 39 + 'px;" placeholder="' + op.searchText + '">',
      '   </td>',
      '</tr>'
    ];
    search = $(search.join(''));
    if (op.search === true) {
      search.show();
    } else {
      search.hide();
    }
    op.table.find('thead').append(search);
  };
  Iconpicker.prototype.setAlign = function(value) {
    this.$element.removeClass(this.options.align).addClass(value);
    this.options.align = value;
  };
  Iconpicker.prototype.setArrowClass = function(value) {
    this.options.arrowClass = this.removeAddClass('.btn-arrow', this.options.arrowClass, value);
  };
  Iconpicker.prototype.setArrowNextIconClass = function(value) {
    this.options.arrowNextIconClass = this.removeAddClass('.btn-next > span', this.options.arrowNextIconClass, value);
  };
  Iconpicker.prototype.setArrowPrevIconClass = function(value) {
    this.options.arrowPrevIconClass = this.removeAddClass('.btn-previous > span', this.options.arrowPrevIconClass, value);
  };
  Iconpicker.prototype.setCols = function(value) {
    this.options.cols = value;
    this.reset();
  };
  Iconpicker.prototype.setFooter = function(value) {
    var footer = this.options.table.find('tfoot');
    if (value === true) {
      footer.show();
    } else {
      footer.hide();
    }
    this.options.footer = value;
  };
  Iconpicker.prototype.setHeader = function(value) {
    var header = this.options.table.find('thead');
    if (value === true) {
      header.show();
    } else {
      header.hide();
    }
    this.options.header = value;
  };
  Iconpicker.prototype.setIcon = function(value) {
    this.select(value);
  };
  Iconpicker.prototype.setIconset = function(value) {
    var op = this.options;
    if ($.isPlainObject(value)) {
      Iconpicker.ICONSET._custom = $.extend(Iconpicker.ICONSET_EMPTY, value);
      op.iconset = '_custom';
    } else if (!Iconpicker.ICONSET.hasOwnProperty(value)) {
      op.iconset = Iconpicker.DEFAULTS.iconset;
    } else {
      op.iconset = value;
    }
    op = $.extend(op, Iconpicker.ICONSET[op.iconset]);
    this.reset();
    this.select(op.icon);
  };
  Iconpicker.prototype.setLabelHeader = function(value) {
    this.options.labelHeader = value;
    this.updateLabels(this.options.page);
  };
  Iconpicker.prototype.setLabelFooter = function(value) {
    this.options.labelFooter = value;
    this.updateLabels(this.options.page);
  };
  Iconpicker.prototype.setPlacement = function(value) {
    this.options.placement = value;
  };
  Iconpicker.prototype.setRows = function(value) {
    this.options.rows = value;
    this.reset();
  };
  Iconpicker.prototype.setSearch = function(value) {
    var search = this.options.table.find('.search-control');
    if (value === true) {
      search.show();
    } else {
      search.hide();
    }
    search.val('');
    this.changeList(1);
    this.options.search = value;
  };
  Iconpicker.prototype.setSearchText = function(value) {
    this.options.table.find('.search-control').attr('placeholder', value);
    this.options.searchText = value;
  };
  Iconpicker.prototype.setSelectedClass = function(value) {
    this.options.selectedClass = this.removeAddClass('.btn-icon-selected', this.options.selectedClass, value);
  };
  Iconpicker.prototype.setUnselectedClass = function(value) {
    this.options.unselectedClass = this.removeAddClass('.btn-icon', this.options.unselectedClass, value);
  };
  var old = $.fn.iconpicker;
  $.fn.iconpicker = function(option, params) {
    return this.each(function() {
      var $this = $(this);
      var data = $this.data('bs.iconpicker');
      var options = typeof option === 'object' && option;
      if (!data) {
        $this.data('bs.iconpicker', (data = new Iconpicker(this, options)));
      }
      if (typeof option === 'string') {
        if (typeof data[option] === 'undefined') {
          throw 'Iconpicker => The "' + option + '" method does not exists.';
        } else {
          data[option](params);
        }
      } else {
        var op = data.options;
        op = $.extend(op, {
          inline: false,
          page: 1,
          selected: -1,
          table: $('<table class="table-icons"><thead></thead><tbody></tbody><tfoot></tfoot></table>')
        });
        var name = (typeof $this.attr('name') !== 'undefined') ? 'name="' + $this.attr('name') + '"' : '';
        if ($this.prop('tagName') === 'BUTTON') {
          $this.empty()
            .append('<i></i>')
            .append('<input type="hidden" ' + name + '></input>')
            .append('<span class="caret"></span>')
            .addClass('iconpicker');
          data.setIconset(op.iconset);
          $this.on('click', function(e) {
            e.preventDefault();
            $this.popover({
              animation: false,
              trigger: 'manual',
              html: true,
              content: op.table,
              container: 'body',
              placement: op.placement
            }).on('shown.bs.popover', function() {
              data.switchPage(op.icon);
              data.bindEvents();
            });
            $this.data('bs.popover').tip().addClass('iconpicker-popover');
            $this.popover('show');
          });
        } else {
          op.inline = true;
          data.setIconset(op.iconset);
          $this.empty()
            .append('<input type="hidden" ' + name + '></input>')
            .append(op.table)
            .addClass('iconpicker')
            .addClass(op.align);
          data.switchPage(op.icon);
          data.bindEvents();
        }
      }
    });
  };
  $.fn.iconpicker.Constructor = Iconpicker;
  $.fn.iconpicker.noConflict = function() {
    $.fn.iconpicker = old;
    return this;
  };
  $(document).on('click', 'body', function(e) {
    $('.iconpicker').each(function() {
      if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $('.popover').has(e.target).length === 0) {
        $(this).popover('destroy');
      }
    });
  });
  $('button[role="iconpicker"],div[role="iconpicker"]').iconpicker();
})(jQuery);;
/*! RESOURCE: /scripts/angularjs-1.4/thirdparty/angular-ui-bootstrap/ui-bootstrap-tpls-1.1.2.js */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/popup.html", "uib/template/datepicker/year.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])
  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed);
        if (!scope.$eval(attrs.uibCollapse)) {
          element.addClass('in')
            .addClass('collapse')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false)
            .css({
              height: 'auto'
            });
        }

        function expand() {
          if (element.hasClass('collapse') && element.hasClass('in')) {
            return;
          }
          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);
              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  to: {
                    height: element[0].scrollHeight + 'px'
                  }
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  to: {
                    height: element[0].scrollHeight + 'px'
                  }
                }).then(expandDone);
              }
            });
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css({
              height: 'auto'
            });
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }
          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
                .css({
                  height: element[0].scrollHeight + 'px'
                })
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: {
                    height: '0'
                  }
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: {
                    height: '0'
                  }
                }).then(collapseDone);
              }
            });
        }

        function collapseDone() {
          element.css({
            height: '0'
          });
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }
        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);
angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])
  .constant('uibAccordionConfig', {
    closeOthers: true
  })
  .controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
    this.groups = [];
    this.closeOthers = function(openGroup) {
      var closeOthers = angular.isDefined($attrs.closeOthers) ?
        $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
      if (closeOthers) {
        angular.forEach(this.groups, function(group) {
          if (group !== openGroup) {
            group.isOpen = false;
          }
        });
      }
    };
    this.addGroup = function(groupScope) {
      var that = this;
      this.groups.push(groupScope);
      groupScope.$on('$destroy', function(event) {
        that.removeGroup(groupScope);
      });
    };
    this.removeGroup = function(group) {
      var index = this.groups.indexOf(group);
      if (index !== -1) {
        this.groups.splice(index, 1);
      }
    };
  }])
  .directive('uibAccordion', function() {
    return {
      controller: 'UibAccordionController',
      controllerAs: 'accordion',
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion.html';
      }
    };
  })
  .directive('uibAccordionGroup', function() {
    return {
      require: '^uibAccordion',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
      },
      scope: {
        heading: '@',
        isOpen: '=?',
        isDisabled: '=?'
      },
      controller: function() {
        this.setHeading = function(element) {
          this.heading = element;
        };
      },
      link: function(scope, element, attrs, accordionCtrl) {
        accordionCtrl.addGroup(scope);
        scope.openClass = attrs.openClass || 'panel-open';
        scope.panelClass = attrs.panelClass || 'panel-default';
        scope.$watch('isOpen', function(value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });
        scope.toggleOpen = function($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
        var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        scope.headingId = id + '-tab';
        scope.panelId = id + '-panel';
      }
    };
  })
  .directive('uibAccordionHeading', function() {
    return {
      transclude: true,
      template: '',
      replace: true,
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      }
    };
  })
  .directive('uibAccordionTransclude', function() {
    return {
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, controller) {
        scope.$watch(function() {
          return controller[attrs.uibAccordionTransclude];
        }, function(heading) {
          if (heading) {
            element.find('span').html('');
            element.find('span').append(heading);
          }
        });
      }
    };
  });
angular.module('ui.bootstrap.alert', [])
  .controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close;
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
      $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    if (dismissOnTimeout) {
      $timeout(function() {
        $scope.close();
      }, parseInt(dismissOnTimeout, 10));
    }
  }])
  .directive('uibAlert', function() {
    return {
      controller: 'UibAlertController',
      controllerAs: 'alert',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/alert/alert.html';
      },
      transclude: true,
      replace: true,
      scope: {
        type: '@',
        close: '&'
      }
    };
  });
angular.module('ui.bootstrap.buttons', [])
  .constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
  })
  .controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || 'active';
    this.toggleEvent = buttonConfig.toggleEvent || 'click';
  }])
  .directive('uibBtnRadio', ['$parse', function($parse) {
    return {
      require: ['uibBtnRadio', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'buttons',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        var uncheckableExpr = $parse(attrs.uibUncheckable);
        element.find('input').css({
          display: 'none'
        });
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          var isActive = element.hasClass(buttonsCtrl.activeClass);
          if (!isActive || angular.isDefined(attrs.uncheckable)) {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
              ngModelCtrl.$render();
            });
          }
        });
        if (attrs.uibUncheckable) {
          scope.$watch(uncheckableExpr, function(uncheckable) {
            attrs.$set('uncheckable', uncheckable ? '' : null);
          });
        }
      }
    };
  }])
  .directive('uibBtnCheckbox', function() {
    return {
      require: ['uibBtnCheckbox', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'button',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        element.find('input').css({
          display: 'none'
        });

        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }

        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }

        function getCheckboxValue(attribute, defaultValue) {
          return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
        }
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });
      }
    };
  });
angular.module('ui.bootstrap.carousel', [])
  .controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
    var self = this,
      slides = self.slides = $scope.slides = [],
      SLIDE_DIRECTION = 'uib-slideDirection',
      currentIndex = -1,
      currentInterval, isPlaying, bufferedTransitions = [];
    self.currentSlide = null;
    var destroyed = false;
    self.addSlide = function(slide, element) {
      slide.$element = element;
      slides.push(slide);
      if (slides.length === 1 || slide.active) {
        if ($scope.$currentTransition) {
          $scope.$currentTransition = null;
        }
        self.select(slides[slides.length - 1]);
        if (slides.length === 1) {
          $scope.play();
        }
      } else {
        slide.active = false;
      }
    };
    self.getCurrentIndex = function() {
      if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
        return +self.currentSlide.index;
      }
      return currentIndex;
    };
    self.next = $scope.next = function() {
      var newIndex = (self.getCurrentIndex() + 1) % slides.length;
      if (newIndex === 0 && $scope.noWrap()) {
        $scope.pause();
        return;
      }
      return self.select(getSlideByIndex(newIndex), 'next');
    };
    self.prev = $scope.prev = function() {
      var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
      if ($scope.noWrap() && newIndex === slides.length - 1) {
        $scope.pause();
        return;
      }
      return self.select(getSlideByIndex(newIndex), 'prev');
    };
    self.removeSlide = function(slide) {
      if (angular.isDefined(slide.index)) {
        slides.sort(function(a, b) {
          return +a.index > +b.index;
        });
      }
      var bufferedIndex = bufferedTransitions.indexOf(slide);
      if (bufferedIndex !== -1) {
        bufferedTransitions.splice(bufferedIndex, 1);
      }
      var index = slides.indexOf(slide);
      slides.splice(index, 1);
      $timeout(function() {
        if (slides.length > 0 && slide.active) {
          if (index >= slides.length) {
            self.select(slides[index - 1]);
          } else {
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
        }
      });
      if (slides.length === 0) {
        self.currentSlide = null;
        clearBufferedTransitions();
      }
    };
    self.select = $scope.select = function(nextSlide, direction) {
      var nextIndex = $scope.indexOfSlide(nextSlide);
      if (direction === undefined) {
        direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
      }
      if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
        goNext(nextSlide, nextIndex, direction);
      } else if (nextSlide && nextSlide !== self.currentSlide && $scope.$currentTransition) {
        bufferedTransitions.push(nextSlide);
        nextSlide.active = false;
      }
    };
    $scope.indexOfSlide = function(slide) {
      return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
    };
    $scope.isActive = function(slide) {
      return self.currentSlide === slide;
    };
    $scope.pause = function() {
      if (!$scope.noPause) {
        isPlaying = false;
        resetTimer();
      }
    };
    $scope.play = function() {
      if (!isPlaying) {
        isPlaying = true;
        restartTimer();
      }
    };
    $scope.$on('$destroy', function() {
      destroyed = true;
      resetTimer();
    });
    $scope.$watch('noTransition', function(noTransition) {
      $animate.enabled($element, !noTransition);
    });
    $scope.$watch('interval', restartTimer);
    $scope.$watchCollection('slides', resetTransition);

    function clearBufferedTransitions() {
      while (bufferedTransitions.length) {
        bufferedTransitions.shift();
      }
    }

    function getSlideByIndex(index) {
      if (angular.isUndefined(slides[index].index)) {
        return slides[index];
      }
      for (var i = 0, l = slides.length; i < l; ++i) {
        if (slides[i].index === index) {
          return slides[i];
        }
      }
    }

    function goNext(slide, index, direction) {
      if (destroyed) {
        return;
      }
      angular.extend(slide, {
        direction: direction,
        active: true
      });
      angular.extend(self.currentSlide || {}, {
        direction: direction,
        active: false
      });
      if ($animate.enabled($element) && !$scope.$currentTransition &&
        slide.$element && self.slides.length > 1) {
        slide.$element.data(SLIDE_DIRECTION, slide.direction);
        if (self.currentSlide && self.currentSlide.$element) {
          self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
        }
        $scope.$currentTransition = true;
        $animate.on('addClass', slide.$element, function(element, phase) {
          if (phase === 'close') {
            $scope.$currentTransition = null;
            $animate.off('addClass', element);
            if (bufferedTransitions.length) {
              var nextSlide = bufferedTransitions.pop();
              var nextIndex = $scope.indexOfSlide(nextSlide);
              var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
              clearBufferedTransitions();
              goNext(nextSlide, nextIndex, nextDirection);
            }
          }
        });
      }
      self.currentSlide = slide;
      currentIndex = index;
      restartTimer();
    }

    function resetTimer() {
      if (currentInterval) {
        $interval.cancel(currentInterval);
        currentInterval = null;
      }
    }

    function resetTransition(slides) {
      if (!slides.length) {
        $scope.$currentTransition = null;
        clearBufferedTransitions();
      }
    }

    function restartTimer() {
      resetTimer();
      var interval = +$scope.interval;
      if (!isNaN(interval) && interval > 0) {
        currentInterval = $interval(timerFn, interval);
      }
    }

    function timerFn() {
      var interval = +$scope.interval;
      if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
        $scope.next();
      } else {
        $scope.pause();
      }
    }
  }])
  .directive('uibCarousel', function() {
    return {
      transclude: true,
      replace: true,
      controller: 'UibCarouselController',
      controllerAs: 'carousel',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/carousel.html';
      },
      scope: {
        interval: '=',
        noTransition: '=',
        noPause: '=',
        noWrap: '&'
      }
    };
  })
  .directive('uibSlide', function() {
    return {
      require: '^uibCarousel',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/slide.html';
      },
      scope: {
        active: '=?',
        actual: '=?',
        index: '=?'
      },
      link: function(scope, element, attrs, carouselCtrl) {
        carouselCtrl.addSlide(scope, element);
        scope.$on('$destroy', function() {
          carouselCtrl.removeSlide(scope);
        });
        scope.$watch('active', function(active) {
          if (active) {
            carouselCtrl.select(scope);
          }
        });
      }
    };
  })
  .animation('.item', ['$animateCss',
    function($animateCss) {
      var SLIDE_DIRECTION = 'uib-slideDirection';

      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element,
              directionClass + ' ' + direction, done);
            element.addClass(direction);
            $animateCss(element, {
                addClass: directionClass
              })
              .start()
              .done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);
            $animateCss(element, {
                addClass: directionClass
              })
              .start()
              .done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }
  ]);
angular.module('ui.bootstrap.dateparser', [])
  .service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var localeId;
    var formatCodeToRegex;
    this.init = function() {
      localeId = $locale.id;
      this.parsers = {};
      this.formatters = {};
      formatCodeToRegex = [{
          key: 'yyyy',
          regex: '\\d{4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yyyy');
          }
        },
        {
          key: 'yy',
          regex: '\\d{2}',
          apply: function(value) {
            this.year = +value + 2000;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yy');
          }
        },
        {
          key: 'y',
          regex: '\\d{1,4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'y');
          }
        },
        {
          key: 'M!',
          regex: '0?[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, 'MM');
            }
            return dateFilter(date, 'M');
          }
        },
        {
          key: 'MMMM',
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMMM');
          }
        },
        {
          key: 'MMM',
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMM');
          }
        },
        {
          key: 'MM',
          regex: '0[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'MM');
          }
        },
        {
          key: 'M',
          regex: '[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'M');
          }
        },
        {
          key: 'd!',
          regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, 'dd');
            }
            return dateFilter(date, 'd');
          }
        },
        {
          key: 'dd',
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'dd');
          }
        },
        {
          key: 'd',
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'd');
          }
        },
        {
          key: 'EEEE',
          regex: $locale.DATETIME_FORMATS.DAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEEE');
          }
        },
        {
          key: 'EEE',
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEE');
          }
        },
        {
          key: 'HH',
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'HH');
          }
        },
        {
          key: 'hh',
          regex: '0[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'hh');
          }
        },
        {
          key: 'H',
          regex: '1?[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'H');
          }
        },
        {
          key: 'h',
          regex: '[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'h');
          }
        },
        {
          key: 'mm',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'mm');
          }
        },
        {
          key: 'm',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'm');
          }
        },
        {
          key: 'sss',
          regex: '[0-9][0-9][0-9]',
          apply: function(value) {
            this.milliseconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'sss');
          }
        },
        {
          key: 'ss',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'ss');
          }
        },
        {
          key: 's',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 's');
          }
        },
        {
          key: 'a',
          regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
          apply: function(value) {
            if (this.hours === 12) {
              this.hours = 0;
            }
            if (value === 'PM') {
              this.hours += 12;
            }
          },
          formatter: function(date) {
            return dateFilter(date, 'a');
          }
        },
        {
          key: 'Z',
          regex: '[+-]\\d{4}',
          apply: function(value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
              sign = matches[1],
              hours = matches[2],
              minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function(date) {
            return dateFilter(date, 'Z');
          }
        },
        {
          key: 'ww',
          regex: '[0-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'ww');
          }
        },
        {
          key: 'w',
          regex: '[0-9]|[1-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'w');
          }
        },
        {
          key: 'GGGG',
          regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
          formatter: function(date) {
            return dateFilter(date, 'GGGG');
          }
        },
        {
          key: 'GGG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GGG');
          }
        },
        {
          key: 'GG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GG');
          }
        },
        {
          key: 'G',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'G');
          }
        }
      ];
    };
    this.init();

    function createParser(format, func) {
      var map = [],
        regex = format.split('');
      var quoteIndex = format.indexOf('\'');
      if (quoteIndex > -1) {
        var inLiteral = false;
        format = format.split('');
        for (var i = quoteIndex; i < format.length; i++) {
          if (inLiteral) {
            if (format[i] === '\'') {
              if (i + 1 < format.length && format[i + 1] === '\'') {
                format[i + 1] = '$';
                regex[i + 1] = '';
              } else {
                regex[i] = '';
                inLiteral = false;
              }
            }
            format[i] = '$';
          } else {
            if (format[i] === '\'') {
              format[i] = '$';
              regex[i] = '';
              inLiteral = true;
            }
          }
        }
        format = format.join('');
      }
      angular.forEach(formatCodeToRegex, function(data) {
        var index = format.indexOf(data.key);
        if (index > -1) {
          format = format.split('');
          regex[index] = '(' + data.regex + ')';
          format[index] = '$';
          for (var i = index + 1, n = index + data.key.length; i < n; i++) {
            regex[i] = '';
            format[i] = '$';
          }
          format = format.join('');
          map.push({
            index: index,
            key: data.key,
            apply: data[func],
            matcher: data.regex
          });
        }
      });
      return {
        regex: new RegExp('^' + regex.join('') + '$'),
        map: orderByFilter(map, 'index')
      };
    }
    this.filter = function(date, format) {
      if (!angular.isDate(date) || isNaN(date) || !format) {
        return '';
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.formatters[format]) {
        this.formatters[format] = createParser(format, 'formatter');
      }
      var parser = this.formatters[format],
        map = parser.map;
      var _format = format;
      return map.reduce(function(str, mapper, i) {
        var match = _format.match(new RegExp('(.*)' + mapper.key));
        if (match && angular.isString(match[1])) {
          str += match[1];
          _format = _format.replace(match[1] + mapper.key, '');
        }
        if (mapper.apply) {
          return str + mapper.apply.call(null, date);
        }
        return str;
      }, '');
    };
    this.parse = function(input, format, baseDate) {
      if (!angular.isString(input) || !format) {
        return input;
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.parsers[format]) {
        this.parsers[format] = createParser(format, 'apply');
      }
      var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
      if (results && results.length) {
        var fields, dt;
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
          fields = {
            year: baseDate.getFullYear(),
            month: baseDate.getMonth(),
            date: baseDate.getDate(),
            hours: baseDate.getHours(),
            minutes: baseDate.getMinutes(),
            seconds: baseDate.getSeconds(),
            milliseconds: baseDate.getMilliseconds()
          };
        } else {
          if (baseDate) {
            $log.warn('dateparser:', 'baseDate is not a valid date');
          }
          fields = {
            year: 1900,
            month: 0,
            date: 1,
            hours: 0,
            minutes: 0,
            seconds: 0,
            milliseconds: 0
          };
        }
        for (var i = 1, n = results.length; i < n; i++) {
          var mapper = map[i - 1];
          if (mapper.matcher === 'Z') {
            tzOffset = true;
          }
          if (mapper.apply) {
            mapper.apply.call(fields, results[i]);
          }
        }
        var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
          Date.prototype.setFullYear;
        var timesetter = tzOffset ? Date.prototype.setUTCHours :
          Date.prototype.setHours;
        if (isValid(fields.year, fields.month, fields.date)) {
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
            dt = new Date(baseDate);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours, fields.minutes,
              fields.seconds, fields.milliseconds);
          } else {
            dt = new Date(0);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
              fields.seconds || 0, fields.milliseconds || 0);
          }
        }
        return dt;
      }
    };

    function isValid(year, month, date) {
      if (date < 1) {
        return false;
      }
      if (month === 1 && date > 28) {
        return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
      }
      if (month === 3 || month === 5 || month === 8 || month === 10) {
        return date < 31;
      }
      return true;
    }

    function toInt(str) {
      return parseInt(str, 10);
    }
    this.toTimezone = toTimezone;
    this.fromTimezone = fromTimezone;
    this.timezoneToOffset = timezoneToOffset;
    this.addDateMinutes = addDateMinutes;
    this.convertTimezoneToLocal = convertTimezoneToLocal;

    function toTimezone(date, timezone) {
      return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }

    function fromTimezone(date, timezone) {
      return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
    }

    function timezoneToOffset(timezone, fallback) {
      var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
      return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }

    function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }

    function convertTimezoneToLocal(date, timezone, reverse) {
      reverse = reverse ? -1 : 1;
      var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
  }]);
angular.module('ui.bootstrap.isClass', [])
  .directive('uibIsClass', [
    '$animate',
    function($animate) {
      var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
      var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
      var dataPerTracked = {};
      return {
        restrict: 'A',
        compile: function(tElement, tAttrs) {
          var linkedScopes = [];
          var instances = [];
          var expToData = {};
          var lastActivated = null;
          var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
          var onExp = onExpMatches[2];
          var expsStr = onExpMatches[1];
          var exps = expsStr.split(',');
          return linkFn;

          function linkFn(scope, element, attrs) {
            linkedScopes.push(scope);
            instances.push({
              scope: scope,
              element: element
            });
            exps.forEach(function(exp, k) {
              addForExp(exp, scope);
            });
            scope.$on('$destroy', removeScope);
          }

          function addForExp(exp, scope) {
            var matches = exp.match(IS_REGEXP);
            var clazz = scope.$eval(matches[1]);
            var compareWithExp = matches[2];
            var data = expToData[exp];
            if (!data) {
              var watchFn = function(compareWithVal) {
                var newActivated = null;
                instances.some(function(instance) {
                  var thisVal = instance.scope.$eval(onExp);
                  if (thisVal === compareWithVal) {
                    newActivated = instance;
                    return true;
                  }
                });
                if (data.lastActivated !== newActivated) {
                  if (data.lastActivated) {
                    $animate.removeClass(data.lastActivated.element, clazz);
                  }
                  if (newActivated) {
                    $animate.addClass(newActivated.element, clazz);
                  }
                  data.lastActivated = newActivated;
                }
              };
              expToData[exp] = data = {
                lastActivated: null,
                scope: scope,
                watchFn: watchFn,
                compareWithExp: compareWithExp,
                watcher: scope.$watch(compareWithExp, watchFn)
              };
            }
            data.watchFn(scope.$eval(compareWithExp));
          }

          function removeScope(e) {
            var removedScope = e.targetScope;
            var index = linkedScopes.indexOf(removedScope);
            linkedScopes.splice(index, 1);
            instances.splice(index, 1);
            if (linkedScopes.length) {
              var newWatchScope = linkedScopes[0];
              angular.forEach(expToData, function(data) {
                if (data.scope === removedScope) {
                  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                  data.scope = newWatchScope;
                }
              });
            } else {
              expToData = {};
            }
          }
        }
      };
    }
  ]);
angular.module('ui.bootstrap.position', [])
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    var SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    return {
      getRawNode: function(elem) {
        return elem[0] || elem;
      },
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);
        var offsetParent = elem.offsetParent || $document[0].documentElement;

        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }
        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || $document[0].documentElement;
      },
      scrollbarWidth: function() {
        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('<div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"></div>');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }
        return SCROLLBAR_WIDTH;
      },
      scrollParent: function(elem, includeHidden) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;
        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }
        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== 'static') {
            excludeStatic = false;
          }
          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }
        return scrollParent;
      },
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);
        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {
          top: 0,
          left: 0
        };
        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }
        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },
      offset: function(elem) {
        elem = this.getRawNode(elem);
        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;
        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();
        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }
        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }
        placement = placement.split('-');
        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }
        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }
        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }
        return placement;
      },
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
        placement = this.parsePlacement(placement);
        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {
          top: 0,
          left: 0,
          placement: ''
        };
        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem);
          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };
          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
            placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
            placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
            placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
            placement[0];
          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
            placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
            placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
            placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
            placement[1];
          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }
        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }
        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }
        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
        return targetElemPos;
      },
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);
        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }
        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }
        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          angular.element(arrowElem).css({
            top: '',
            bottom: '',
            right: '',
            left: '',
            margin: ''
          });
          return;
        }
        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
        var arrowCss = {
          top: 'auto',
          bottom: 'auto',
          left: 'auto',
          right: 'auto',
          margin: 0
        };
        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }
        arrowCss[placement[1]] = borderRadius;
        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])
  .value('$datepickerSuppressError', false)
  .constant('uibDatepickerConfig', {
    datepickerMode: 'day',
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    maxDate: null,
    maxMode: 'year',
    minDate: null,
    minMode: 'day',
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4
  })
  .controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser',
    function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, dateParser) {
      var self = this,
        ngModelCtrl = {
          $setViewValue: angular.noop
        },
        ngModelOptions = {},
        watchListeners = [];
      this.modes = ['day', 'month', 'year'];
      if ($attrs.datepickerOptions) {
        angular.forEach([
          'formatDay',
          'formatDayHeader',
          'formatDayTitle',
          'formatMonth',
          'formatMonthTitle',
          'formatYear',
          'initDate',
          'maxDate',
          'maxMode',
          'minDate',
          'minMode',
          'showWeeks',
          'shortcutPropagation',
          'startingDay',
          'yearColumns',
          'yearRows'
        ], function(key) {
          switch (key) {
            case 'formatDay':
            case 'formatDayHeader':
            case 'formatDayTitle':
            case 'formatMonth':
            case 'formatMonthTitle':
            case 'formatYear':
              self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
              break;
            case 'showWeeks':
            case 'shortcutPropagation':
            case 'yearColumns':
            case 'yearRows':
              self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                $scope.datepickerOptions[key] : datepickerConfig[key];
              break;
            case 'startingDay':
              if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                self.startingDay = $scope.datepickerOptions.startingDay;
              } else if (angular.isNumber(datepickerConfig.startingDay)) {
                self.startingDay = datepickerConfig.startingDay;
              } else {
                self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
              }
              break;
            case 'maxDate':
            case 'minDate':
              if ($scope.datepickerOptions[key]) {
                $scope.$watch(function() {
                  return $scope.datepickerOptions[key];
                }, function(value) {
                  if (value) {
                    if (angular.isDate(value)) {
                      self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                    } else {
                      self[key] = new Date(dateFilter(value, 'medium'));
                    }
                  } else {
                    self[key] = null;
                  }
                  self.refreshView();
                });
              } else {
                self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
              }
              break;
            case 'maxMode':
            case 'minMode':
              if ($scope.datepickerOptions[key]) {
                $scope.$watch(function() {
                  return $scope.datepickerOptions[key];
                }, function(value) {
                  self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
                  if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||
                    key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {
                    $scope.datepickerMode = self[key];
                  }
                });
              } else {
                self[key] = $scope[key] = datepickerConfig[key] || null;
              }
              break;
            case 'initDate':
              if ($scope.datepickerOptions.initDate) {
                this.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
                $scope.$watch(function() {
                  return $scope.datepickerOptions.initDate;
                }, function(initDate) {
                  if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                    self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
                    self.refreshView();
                  }
                });
              } else {
                this.activeDate = new Date();
              }
          }
        });
      } else {
        angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {
          self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];
        });
        angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {
          self[key] = angular.isDefined($attrs[key]) ?
            $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
        });
        if (angular.isDefined($attrs.startingDay)) {
          self.startingDay = $scope.$parent.$eval($attrs.startingDay);
        } else if (angular.isNumber(datepickerConfig.startingDay)) {
          self.startingDay = datepickerConfig.startingDay;
        } else {
          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
        }
        angular.forEach(['minDate', 'maxDate'], function(key) {
          if ($attrs[key]) {
            watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  self[key] = new Date(dateFilter(value, 'medium'));
                }
              } else {
                self[key] = null;
              }
              self.refreshView();
            }));
          } else {
            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
          }
        });
        angular.forEach(['minMode', 'maxMode'], function(key) {
          if ($attrs[key]) {
            watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
              self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];
              if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||
                key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {
                $scope.datepickerMode = self[key];
              }
            }));
          } else {
            self[key] = $scope[key] = datepickerConfig[key] || null;
          }
        });
        if (angular.isDefined($attrs.initDate)) {
          this.activeDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone) || new Date();
          watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {
            if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
              self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
              self.refreshView();
            }
          }));
        } else {
          this.activeDate = new Date();
        }
      }
      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
          $scope.disabled = disabled;
          self.refreshView();
        }));
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
        if (ngModelCtrl.$modelValue) {
          this.activeDate = ngModelCtrl.$modelValue;
        }
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
            isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity('dateDisabled', !date ||
            this.element && !this.isDisabled(date));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          current: this.compare(date, new Date()) === 0,
          customClass: this.customClass(date) || null
        };
        if (model && this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }
        if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }
        return dt;
      };
      this.isDisabled = function(date) {
        return $scope.disabled ||
          this.minDate && this.compare(date, this.minDate) < 0 ||
          this.maxDate && this.compare(date, this.maxDate) > 0 ||
          $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
          });
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
          month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if ($scope.datepickerMode === self.maxMode && direction === 1 ||
          $scope.datepickerMode === self.minMode && direction === -1) {
          return;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
      $scope.$on("$destroy", function() {
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
    }
  ])
  .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    this.step = {
      months: 1
    };
    this.element = $element;

    function getDaysInMonth(year, month) {
      return month === 1 && year % 4 === 0 &&
        (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
    }
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      scope.showWeeks = ctrl.showWeeks;
      ctrl.refreshView();
    };
    this.getDates = function(startDate, n) {
      var dates = new Array(n),
        current = new Date(startDate),
        i = 0,
        date;
      while (i < n) {
        date = new Date(current);
        dates[i++] = date;
        current.setDate(current.getDate() + 1);
      }
      return dates;
    };
    this._refreshView = function() {
      var year = this.activeDate.getFullYear(),
        month = this.activeDate.getMonth(),
        firstDayOfMonth = new Date(this.activeDate);
      firstDayOfMonth.setFullYear(year, month, 1);
      var difference = this.startingDay - firstDayOfMonth.getDay(),
        numDisplayedFromPreviousMonth = difference > 0 ?
        7 - difference : -difference,
        firstDate = new Date(firstDayOfMonth);
      if (numDisplayedFromPreviousMonth > 0) {
        firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
      }
      var days = this.getDates(firstDate, 42);
      for (var i = 0; i < 42; i++) {
        days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
          secondary: days[i].getMonth() !== month,
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.labels = new Array(7);
      for (var j = 0; j < 7; j++) {
        scope.labels[j] = {
          abbr: dateFilter(days[j].date, this.formatDayHeader),
          full: dateFilter(days[j].date, 'EEEE')
        };
      }
      scope.title = dateFilter(this.activeDate, this.formatDayTitle);
      scope.rows = this.split(days, 7);
      if (scope.showWeeks) {
        scope.weekNumbers = [];
        var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
        for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
          scope.weekNumbers.push(
            getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
      }
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };

    function getISO8601WeekNumber(date) {
      var checkDate = new Date(date);
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      var time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    }
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getDate();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 7;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 7;
      } else if (key === 'pageup' || key === 'pagedown') {
        var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setMonth(month, 1);
        date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
      } else if (key === 'home') {
        date = 1;
      } else if (key === 'end') {
        date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
      }
      this.activeDate.setDate(date);
    };
  }])
  .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    this.step = {
      years: 1
    };
    this.element = $element;
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      ctrl.refreshView();
    };
    this._refreshView = function() {
      var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;
      for (var i = 0; i < 12; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(year, i, 1);
        months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
      scope.rows = this.split(months, 3);
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getMonth();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 3;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 3;
      } else if (key === 'pageup' || key === 'pagedown') {
        var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setFullYear(year);
      } else if (key === 'home') {
        date = 0;
      } else if (key === 'end') {
        date = 11;
      }
      this.activeDate.setMonth(date);
    };
  }])
  .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var columns, range;
    this.element = $element;

    function getStartingYear(year) {
      return parseInt((year - 1) / range, 10) * range + 1;
    }
    this.yearpickerInit = function() {
      columns = this.yearColumns;
      range = this.yearRows * columns;
      this.step = {
        years: range
      };
    };
    this._refreshView = function() {
      var years = new Array(range),
        date;
      for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(start + i, 0, 1);
        years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.title = [years[0].label, years[range - 1].label].join(' - ');
      scope.rows = this.split(years, columns);
      scope.columns = columns;
    };
    this.compare = function(date1, date2) {
      return date1.getFullYear() - date2.getFullYear();
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getFullYear();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - columns;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + columns;
      } else if (key === 'pageup' || key === 'pagedown') {
        date += (key === 'pageup' ? -1 : 1) * range;
      } else if (key === 'home') {
        date = getStartingYear(this.activeDate.getFullYear());
      } else if (key === 'end') {
        date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
      }
      this.activeDate.setFullYear(date);
    };
  }])
  .directive('uibDatepicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
      },
      scope: {
        datepickerMode: '=?',
        datepickerOptions: '=?',
        dateDisabled: '&',
        customClass: '&',
        shortcutPropagation: '&?'
      },
      require: ['uibDatepicker', '^ngModel'],
      controller: 'UibDatepickerController',
      controllerAs: 'datepicker',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        datepickerCtrl.init(ngModelCtrl);
      }
    };
  })
  .directive('uibDaypicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/day.html';
      },
      require: ['^uibDatepicker', 'uibDaypicker'],
      controller: 'UibDaypickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          daypickerCtrl = ctrls[1];
        daypickerCtrl.init(datepickerCtrl);
      }
    };
  })
  .directive('uibMonthpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/month.html';
      },
      require: ['^uibDatepicker', 'uibMonthpicker'],
      controller: 'UibMonthpickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          monthpickerCtrl = ctrls[1];
        monthpickerCtrl.init(datepickerCtrl);
      }
    };
  })
  .directive('uibYearpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/year.html';
      },
      require: ['^uibDatepicker', 'uibYearpicker'],
      controller: 'UibYearpickerController',
      link: function(scope, element, attrs, ctrls) {
        var ctrl = ctrls[0];
        angular.extend(ctrl, ctrls[1]);
        ctrl.yearpickerInit();
        ctrl.refreshView();
      }
    };
  })
  .constant('uibDatepickerPopupConfig', {
    altInputFormats: [],
    appendToBody: false,
    clearText: 'Clear',
    closeOnDateSelection: true,
    closeText: 'Done',
    currentText: 'Today',
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',
    datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
    html5Types: {
      date: 'yyyy-MM-dd',
      'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
      'month': 'yyyy-MM'
    },
    onOpenFocus: true,
    showButtonBar: true
  })
  .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig',
    function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig) {
      var cache = {},
        isHtml5DateInput = false;
      var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
        datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
        ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];
      scope.watchData = {};
      this.init = function(_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;
        closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined(attrs.altInputFormats) ? scope.$parent.$eval(attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }
        if (isHtml5DateInput && attrs.uibDatepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
        scope.ngModelOptions = angular.copy(ngModelOptions);
        scope.ngModelOptions.timezone = null;
        popupEl.attr({
          'ng-model': 'date',
          'ng-model-options': 'ngModelOptions',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);
        if (isHtml5DateInput) {
          if (attrs.type === 'month') {
            datepickerEl.attr('datepicker-mode', '"month"');
            datepickerEl.attr('min-mode', 'month');
          }
        }
        if (scope.datepickerOptions) {
          angular.forEach(scope.datepickerOptions, function(value, option) {
            if (['minDate', 'maxDate', 'minMode', 'maxMode', 'initDate', 'datepickerMode'].indexOf(option) === -1) {
              datepickerEl.attr(cameltoDash(option), value);
            } else {
              datepickerEl.attr(cameltoDash(option), 'datepickerOptions.' + option);
            }
          });
        }
        angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {
          if (attrs[key]) {
            var getAttribute = $parse(attrs[key]);
            var propConfig = {
              get: function() {
                return getAttribute(scope.$parent);
              }
            };
            datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
            if (key === 'datepickerMode') {
              var setAttribute = getAttribute.assign;
              propConfig.set = function(v) {
                setAttribute(scope.$parent, v);
              };
            }
            Object.defineProperty(scope.watchData, key, propConfig);
          }
        });
        angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {
          if (attrs[key]) {
            var getAttribute = $parse(attrs[key]);
            watchListeners.push(scope.$parent.$watch(getAttribute, function(value) {
              if (key === 'minDate' || key === 'maxDate') {
                if (value === null) {
                  cache[key] = null;
                } else if (angular.isDate(value)) {
                  cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  cache[key] = new Date(dateFilter(value, 'medium'));
                }
                scope.watchData[key] = value === null ? null : cache[key];
              } else {
                scope.watchData[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
              }
            }));
            datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
          }
        });
        if (attrs.dateDisabled) {
          datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
        }
        angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {
          if (angular.isDefined(attrs[key])) {
            datepickerEl.attr(cameltoDash(key), attrs[key]);
          }
        });
        if (attrs.customClass) {
          datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
        }
        if (!isHtml5DateInput) {
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function(value) {
            if (ngModel.$isEmpty(value)) {
              scope.date = value;
              return value;
            }
            scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
            if (angular.isNumber(scope.date)) {
              scope.date = new Date(scope.date);
            }
            return dateParser.filter(scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function(value) {
            scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function() {
          scope.date = parseDateString(ngModel.$viewValue);
        });
        element.on('keydown', inputKeydownBind);
        $popup = $compile(popupEl)(scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          element.after($popup);
        }
        scope.$on('$destroy', function() {
          if (scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              scope.$apply(function() {
                scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          element.off('keydown', inputKeydownBind);
          $document.off('click', documentClickBind);
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };
      scope.getText = function(key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };
      scope.isDisabled = function(date) {
        if (date === 'today') {
          date = new Date();
        }
        return scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 ||
          scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;
      };
      scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateParser.filter(scope.date, dateFormat) : null;
        element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.select = function(date) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };
      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };
      scope.disabled = angular.isDefined(attrs.disabled) || false;
      if (attrs.ngDisabled) {
        watchListeners.push(scope.$parent.$watch($parse(attrs.ngDisabled), function(disabled) {
          scope.disabled = disabled;
        }));
      }
      scope.$watch('isOpen', function(value) {
        if (value) {
          if (!scope.disabled) {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top = scope.position.top + element.prop('offsetHeight');
            $timeout(function() {
              if (onOpenFocus) {
                scope.$broadcast('uib:datepicker.focus');
              }
              $document.on('click', documentClickBind);
            }, 0, false);
          } else {
            scope.isOpen = false;
          }
        } else {
          $document.off('click', documentClickBind);
        }
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
          return '-' + $1.toLowerCase();
        });
      }

      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, scope.date);
        if (isNaN(date)) {
          for (var i = 0; i < altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        }
        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        }
        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return dateParser.toTimezone(date, ngModelOptions.timezone);
          }
        }
        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!attrs.ngRequired && !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        }
        if (angular.isDate(value) && !isNaN(value)) {
          return true;
        }
        if (angular.isString(value)) {
          return !isNaN(parseDateString(viewValue));
        }
        return false;
      }

      function documentClickBind(event) {
        if (!scope.isOpen && scope.disabled) {
          return;
        }
        var popup = $popup[0];
        var dpContainsTarget = element[0].contains(event.target);
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      }

      function inputKeydownBind(evt) {
        if (evt.which === 27 && scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = false;
          });
          element[0].focus();
        } else if (evt.which === 40 && !scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = true;
          });
        }
      }
    }
  ])
  .directive('uibDatepickerPopup', function() {
    return {
      require: ['ngModel', 'uibDatepickerPopup'],
      controller: 'UibDatepickerPopupController',
      scope: {
        datepickerOptions: '=?',
        isOpen: '=?',
        currentText: '@',
        clearText: '@',
        closeText: '@',
        dateDisabled: '&',
        customClass: '&'
      },
      link: function(scope, element, attrs, ctrls) {
        var ngModel = ctrls[0],
          ctrl = ctrls[1];
        ctrl.init(ngModel);
      }
    };
  })
  .directive('uibDatepickerPopupWrap', function() {
    return {
      replace: true,
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/popup.html';
      }
    };
  });
angular.module('ui.bootstrap.debounce', [])
  .factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;
      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);
angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])
  .constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
  })
  .service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope) {
      if (!openScope) {
        $document.on('click', closeDropdown);
        $document.on('keydown', keybindFilter);
      }
      if (openScope && openScope !== dropdownScope) {
        openScope.isOpen = false;
      }
      openScope = dropdownScope;
    };
    this.close = function(dropdownScope) {
      if (openScope === dropdownScope) {
        openScope = null;
        $document.off('click', closeDropdown);
        $document.off('keydown', keybindFilter);
      }
    };
    var closeDropdown = function(evt) {
      if (!openScope) {
        return;
      }
      if (evt && openScope.getAutoClose() === 'disabled') {
        return;
      }
      if (evt && evt.which === 3) {
        return;
      }
      var toggleElement = openScope.getToggleElement();
      if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
        return;
      }
      var dropdownElement = openScope.getDropdownElement();
      if (evt && openScope.getAutoClose() === 'outsideClick' &&
        dropdownElement && dropdownElement[0].contains(evt.target)) {
        return;
      }
      openScope.isOpen = false;
      if (!$rootScope.$$phase) {
        openScope.$apply();
      }
    };
    var keybindFilter = function(evt) {
      if (evt.which === 27) {
        openScope.focusToggleElement();
        closeDropdown();
      } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
        evt.preventDefault();
        evt.stopPropagation();
        openScope.focusDropdownEntry(evt.which);
      }
    };
  }])
  .controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var self = this,
      scope = $scope.$new(),
      templateScope,
      appendToOpenClass = dropdownConfig.appendToOpenClass,
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
      appendToBody = false,
      appendTo = null,
      keynavEnabled = false,
      selectedOption = null,
      body = $document.find('body');
    $element.addClass('dropdown');
    this.init = function() {
      if ($attrs.isOpen) {
        getIsOpen = $parse($attrs.isOpen);
        setIsOpen = getIsOpen.assign;
        $scope.$watch(getIsOpen, function(value) {
          scope.isOpen = !!value;
        });
      }
      if (angular.isDefined($attrs.dropdownAppendTo)) {
        var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
        if (appendToEl) {
          appendTo = angular.element(appendToEl);
        }
      }
      appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
      keynavEnabled = angular.isDefined($attrs.keyboardNav);
      if (appendToBody && !appendTo) {
        appendTo = body;
      }
      if (appendTo && self.dropdownMenu) {
        appendTo.append(self.dropdownMenu);
        $element.on('$destroy', function handleDestroyEvent() {
          self.dropdownMenu.remove();
        });
      }
    };
    this.toggle = function(open) {
      return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    };
    this.isOpen = function() {
      return scope.isOpen;
    };
    scope.getToggleElement = function() {
      return self.toggleElement;
    };
    scope.getAutoClose = function() {
      return $attrs.autoClose || 'always';
    };
    scope.getElement = function() {
      return $element;
    };
    scope.isKeynavEnabled = function() {
      return keynavEnabled;
    };
    scope.focusDropdownEntry = function(keyCode) {
      var elems = self.dropdownMenu ?
        angular.element(self.dropdownMenu).find('a') :
        $element.find('ul').eq(0).find('a');
      switch (keyCode) {
        case 40:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = 0;
            } else {
              self.selectedOption = self.selectedOption === elems.length - 1 ?
                self.selectedOption :
                self.selectedOption + 1;
            }
            break;
          }
        case 38:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = elems.length - 1;
            } else {
              self.selectedOption = self.selectedOption === 0 ?
                0 : self.selectedOption - 1;
            }
            break;
          }
      }
      elems[self.selectedOption].focus();
    };
    scope.getDropdownElement = function() {
      return self.dropdownMenu;
    };
    scope.focusToggleElement = function() {
      if (self.toggleElement) {
        self.toggleElement[0].focus();
      }
    };
    scope.$watch('isOpen', function(isOpen, wasOpen) {
      if (appendTo && self.dropdownMenu) {
        var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
          css,
          rightalign;
        css = {
          top: pos.top + 'px',
          display: isOpen ? 'block' : 'none'
        };
        rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
        if (!rightalign) {
          css.left = pos.left + 'px';
          css.right = 'auto';
        } else {
          css.left = 'auto';
          css.right = window.innerWidth -
            (pos.left + $element.prop('offsetWidth')) + 'px';
        }
        if (!appendToBody) {
          var appendOffset = $position.offset(appendTo);
          css.top = pos.top - appendOffset.top + 'px';
          if (!rightalign) {
            css.left = pos.left - appendOffset.left + 'px';
          } else {
            css.right = window.innerWidth -
              (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
          }
        }
        self.dropdownMenu.css(css);
      }
      var openContainer = appendTo ? appendTo : $element;
      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
          toggleInvoker($scope, {
            open: !!isOpen
          });
        }
      });
      if (isOpen) {
        if (self.dropdownMenuTemplateUrl) {
          $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new();
            $compile(tplContent.trim())(templateScope, function(dropdownElement) {
              var newEl = dropdownElement;
              self.dropdownMenu.replaceWith(newEl);
              self.dropdownMenu = newEl;
            });
          });
        }
        scope.focusToggleElement();
        uibDropdownService.open(scope);
      } else {
        if (self.dropdownMenuTemplateUrl) {
          if (templateScope) {
            templateScope.$destroy();
          }
          var newEl = angular.element('<ul class="dropdown-menu"></ul>');
          self.dropdownMenu.replaceWith(newEl);
          self.dropdownMenu = newEl;
        }
        uibDropdownService.close(scope);
        self.selectedOption = null;
      }
      if (angular.isFunction(setIsOpen)) {
        setIsOpen($scope, isOpen);
      }
    });
    $scope.$on('$locationChangeSuccess', function() {
      if (scope.getAutoClose() !== 'disabled') {
        scope.isOpen = false;
      }
    });
  }])
  .directive('uibDropdown', function() {
    return {
      controller: 'UibDropdownController',
      link: function(scope, element, attrs, dropdownCtrl) {
        dropdownCtrl.init();
      }
    };
  })
  .directive('uibDropdownMenu', function() {
    return {
      restrict: 'A',
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
          return;
        }
        element.addClass('dropdown-menu');
        var tplUrl = attrs.templateUrl;
        if (tplUrl) {
          dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
        }
        if (!dropdownCtrl.dropdownMenu) {
          dropdownCtrl.dropdownMenu = element;
        }
      }
    };
  })
  .directive('uibDropdownToggle', function() {
    return {
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl) {
          return;
        }
        element.addClass('dropdown-toggle');
        dropdownCtrl.toggleElement = element;
        var toggleDropdown = function(event) {
          event.preventDefault();
          if (!element.hasClass('disabled') && !attrs.disabled) {
            scope.$apply(function() {
              dropdownCtrl.toggle();
            });
          }
        };
        element.bind('click', toggleDropdown);
        element.attr({
          'aria-haspopup': true,
          'aria-expanded': false
        });
        scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
          element.attr('aria-expanded', !!isOpen);
        });
        scope.$on('$destroy', function() {
          element.unbind('click', toggleDropdown);
        });
      }
    };
  });
angular.module('ui.bootstrap.stackedMap', [])
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];
        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};
        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }
            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];
            if (!values) {
              return;
            }
            var idx = values.indexOf(value);
            if (idx !== -1) {
              values.splice(idx, 1);
            }
            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })
  .provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };
    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {
        resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }
          var promises = [];
          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });
          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });
            return resolveObj;
          });
        }
      };
    }];
  })
  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',
    function($animateCss, $injector, $modalStack) {
      return {
        replace: true,
        templateUrl: 'uib/template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };

      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            } else {
              done();
            }
          });
        }
      }
    }
  ])
  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',
    function($modalStack, $q, $animate, $animateCss, $document) {
      return {
        scope: {
          index: '@'
        },
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'uib/template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop &&
              modal.value.backdrop !== 'static' &&
              evt.target === evt.currentTarget) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value === 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {
                    removeClass: attrs.modalInClass
                  }).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }
            $q.when(animationPromise).then(function() {
              if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }
  ])
  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })
  .directive('uibModalTransclude', function() {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          element.append(clone);
        });
      }
    };
  })
  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
        'iframe, object, embed, *[tabindex], *[contenteditable=true]';

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          $animateCss(domEl, {
            event: 'leave'
          }).start().then(function() {
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }
      $document.on('keydown', keydownListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27:
              {
                if (modal.value.keyboard) {
                  evt.preventDefault();
                  $rootScope.$apply(function() {
                    $modalStack.dismiss(modal.key, 'escape key press');
                  });
                }
                break;
              }
            case 9:
              {
                $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {
                    focusChanged = $modalStack.focusLastFocusableElement();
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt)) {
                    focusChanged = $modalStack.focusFirstFocusableElement();
                  }
                }
                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }
                break;
              }
          }
        }
      }
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo,
          currBackdropIndex = backdropIndex();
        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
        }
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)
          .then(function() {
            $animate.addClass(appendToElement, modalBodyClass);
          });
        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        $modalStack.clearFocusListCache();
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) === focusableElementList[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };
      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };
      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };
      return $modalStack;
    }
  ])
  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true,
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ?
                options.templateUrl() : options.templateUrl);
          }
          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {
                var providedScope = modalOptions.scope || $rootScope;
                var modalScope = providedScope.$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;
                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });
                var ctrlInstance, ctrlLocals = {};
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$uibModalInstance = modalInstance;
                  angular.forEach(tplAndVars[1], function(value, key) {
                    ctrlLocals[key] = value;
                  });
                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                  if (modalOptions.controllerAs) {
                    if (modalOptions.bindToController) {
                      ctrlInstance.$close = modalScope.$close;
                      ctrlInstance.$dismiss = modalScope.$dismiss;
                      angular.extend(ctrlInstance, providedScope);
                    }
                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }
                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  closedDeferred: modalClosedDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass,
                  appendTo: modalOptions.appendTo
                });
                modalOpenedDeferred.resolve(true);
              }, function resolveError(reason) {
                modalOpenedDeferred.reject(reason);
                modalResultDeferred.reject(reason);
              })['finally'](function() {
                if (promiseChain === samePromise) {
                  promiseChain = null;
                }
              });
            return modalInstance;
          };
          return $modal;
        }
      ]
    };
    return $modalProvider;
  });
angular.module('ui.bootstrap.paging', [])
  .factory('uibPaging', ['$parse', function($parse) {
    return {
      create: function(ctrl, $scope, $attrs) {
        ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
        ctrl.ngModelCtrl = {
          $setViewValue: angular.noop
        };
        ctrl._watchers = [];
        ctrl.init = function(ngModelCtrl, config) {
          ctrl.ngModelCtrl = ngModelCtrl;
          ctrl.config = config;
          ngModelCtrl.$render = function() {
            ctrl.render();
          };
          if ($attrs.itemsPerPage) {
            ctrl._watchers.push($scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
              ctrl.itemsPerPage = parseInt(value, 10);
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }));
          } else {
            ctrl.itemsPerPage = config.itemsPerPage;
          }
          $scope.$watch('totalItems', function(newTotal, oldTotal) {
            if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }
          });
        };
        ctrl.calculateTotalPages = function() {
          var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
          return Math.max(totalPages || 0, 1);
        };
        ctrl.render = function() {
          $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
        };
        $scope.selectPage = function(page, evt) {
          if (evt) {
            evt.preventDefault();
          }
          var clickAllowed = !$scope.ngDisabled || !evt;
          if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
            if (evt && evt.target) {
              evt.target.blur();
            }
            ctrl.ngModelCtrl.$setViewValue(page);
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.getText = function(key) {
          return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
        };
        $scope.noPrevious = function() {
          return $scope.page === 1;
        };
        $scope.noNext = function() {
          return $scope.page === $scope.totalPages;
        };
        ctrl.updatePage = function() {
          ctrl.setNumPages($scope.$parent, $scope.totalPages);
          if ($scope.page > $scope.totalPages) {
            $scope.selectPage($scope.totalPages);
          } else {
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.$on('$destroy', function() {
          while (ctrl._watchers.length) {
            ctrl._watchers.shift()();
          }
        });
      }
    };
  }]);
angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])
  .controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
    uibPaging.create(this, $scope, $attrs);
  }])
  .constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: ' Previous',
    nextText: 'Next ',
    align: true
  })
  .directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
    return {
      scope: {
        totalItems: '=',
        previousText: '@',
        nextText: '@',
        ngDisabled: '='
      },
      require: ['uibPager', '?ngModel'],
      controller: 'UibPagerController',
      controllerAs: 'pager',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pager/pager.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPagerConfig);
      }
    };
  }]);
angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])
  .controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    var ctrl = this;
    var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
      rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
      forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
      boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
    uibPaging.create(this, $scope, $attrs);
    if ($attrs.maxSize) {
      ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10);
        ctrl.render();
      }));
    }

    function makePage(number, text, isActive) {
      return {
        number: number,
        text: text,
        active: isActive
      };
    }

    function getPages(currentPage, totalPages) {
      var pages = [];
      var startPage = 1,
        endPage = totalPages;
      var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
      if (isMaxSized) {
        if (rotate) {
          startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
          endPage = startPage + maxSize - 1;
          if (endPage > totalPages) {
            endPage = totalPages;
            startPage = endPage - maxSize + 1;
          }
        } else {
          startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
          endPage = Math.min(startPage + maxSize - 1, totalPages);
        }
      }
      for (var number = startPage; number <= endPage; number++) {
        var page = makePage(number, number, number === currentPage);
        pages.push(page);
      }
      if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
        if (startPage > 1) {
          if (!boundaryLinkNumbers || startPage > 3) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }
          if (boundaryLinkNumbers) {
            if (startPage === 3) {
              var secondPageLink = makePage(2, '2', false);
              pages.unshift(secondPageLink);
            }
            var firstPageLink = makePage(1, '1', false);
            pages.unshift(firstPageLink);
          }
        }
        if (endPage < totalPages) {
          if (!boundaryLinkNumbers || endPage < totalPages - 2) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
          if (boundaryLinkNumbers) {
            if (endPage === totalPages - 2) {
              var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
              pages.push(secondToLastPageLink);
            }
            var lastPageLink = makePage(totalPages, totalPages, false);
            pages.push(lastPageLink);
          }
        }
      }
      return pages;
    }
    var originalRender = this.render;
    this.render = function() {
      originalRender();
      if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
        $scope.pages = getPages($scope.page, $scope.totalPages);
      }
    };
  }])
  .constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
  })
  .directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
    return {
      scope: {
        totalItems: '=',
        firstText: '@',
        previousText: '@',
        nextText: '@',
        lastText: '@',
        ngDisabled: '='
      },
      require: ['uibPagination', '?ngModel'],
      controller: 'UibPaginationController',
      controllerAs: 'pagination',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pagination/pagination.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
      }
    };
  }]);
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])
  .provider('$uibTooltip', function() {
    var defaultOptions = {
      placement: 'top',
      placementClassPrefix: '',
      animation: true,
      popupDelay: 0,
      popupCloseDelay: 0,
      useContentExp: false
    };
    var triggerMap = {
      'mouseenter': 'mouseleave',
      'click': 'click',
      'outsideClick': 'outsideClick',
      'focus': 'blur',
      'none': ''
    };
    var globalOptions = {};
    this.options = function(value) {
      angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
      angular.extend(triggerMap, triggers);
    };

    function snake_case(name) {
      var regexp = /[A-Z]/g;
      var separator = '-';
      return name.replace(regexp, function(letter, pos) {
        return (pos ? separator : '') + letter.toLowerCase();
      });
    }
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
      var openedTooltips = $$stackedMap.createNew();
      $document.on('keypress', keypressListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keypress', keypressListener);
      });

      function keypressListener(e) {
        if (e.which === 27) {
          var last = openedTooltips.top();
          if (last) {
            last.value.close();
            openedTooltips.removeTop();
            last = null;
          }
        }
      }
      return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
        options = angular.extend({}, defaultOptions, globalOptions, options);

        function getTriggers(trigger) {
          var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
          var hide = show.map(function(trigger) {
            return triggerMap[trigger] || trigger;
          });
          return {
            show: show,
            hide: hide
          };
        }
        var directiveName = snake_case(ttType);
        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();
        var template =
          '<div ' + directiveName + '-popup ' +
          'title="' + startSym + 'title' + endSym + '" ' +
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'placement="' + startSym + 'placement' + endSym + '" ' +
          'popup-class="' + startSym + 'popupClass' + endSym + '" ' +
          'animation="animation" ' +
          'is-open="isOpen"' +
          'origin-scope="origScope" ' +
          'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
          '>' +
          '</div>';
        return {
          compile: function(tElem, tAttrs) {
            var tooltipLinker = $compile(template);
            return function link(scope, element, attrs, tooltipCtrl) {
              var tooltip;
              var tooltipLinkedScope;
              var transitionTimeout;
              var showTimeout;
              var hideTimeout;
              var positionTimeout;
              var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
              var triggers = getTriggers(undefined);
              var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
              var ttScope = scope.$new(true);
              var repositionScheduled = false;
              var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
              var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
              var observers = [];
              var positionTooltip = function() {
                if (!tooltip || !tooltip.html()) {
                  return;
                }
                if (!positionTimeout) {
                  positionTimeout = $timeout(function() {
                    tooltip.css({
                      top: 0,
                      left: 0
                    });
                    var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                    tooltip.css({
                      top: ttPosition.top + 'px',
                      left: ttPosition.left + 'px',
                      visibility: 'visible'
                    });
                    if (options.placementClassPrefix) {
                      tooltip.removeClass('top bottom left right');
                    }
                    tooltip.removeClass(
                      options.placementClassPrefix + 'top ' +
                      options.placementClassPrefix + 'top-left ' +
                      options.placementClassPrefix + 'top-right ' +
                      options.placementClassPrefix + 'bottom ' +
                      options.placementClassPrefix + 'bottom-left ' +
                      options.placementClassPrefix + 'bottom-right ' +
                      options.placementClassPrefix + 'left ' +
                      options.placementClassPrefix + 'left-top ' +
                      options.placementClassPrefix + 'left-bottom ' +
                      options.placementClassPrefix + 'right ' +
                      options.placementClassPrefix + 'right-top ' +
                      options.placementClassPrefix + 'right-bottom');
                    var placement = ttPosition.placement.split('-');
                    tooltip.addClass(placement[0] + ' ' + options.placementClassPrefix + ttPosition.placement);
                    $position.positionArrow(tooltip, ttPosition.placement);
                    positionTimeout = null;
                  }, 0, false);
                }
              };
              ttScope.origScope = scope;
              ttScope.isOpen = false;
              openedTooltips.add(ttScope, {
                close: hide
              });

              function toggleTooltipBind() {
                if (!ttScope.isOpen) {
                  showTooltipBind();
                } else {
                  hideTooltipBind();
                }
              }

              function showTooltipBind() {
                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                  return;
                }
                cancelHide();
                prepareTooltip();
                if (ttScope.popupDelay) {
                  if (!showTimeout) {
                    showTimeout = $timeout(show, ttScope.popupDelay, false);
                  }
                } else {
                  show();
                }
              }

              function hideTooltipBind() {
                cancelShow();
                if (ttScope.popupCloseDelay) {
                  if (!hideTimeout) {
                    hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                  }
                } else {
                  hide();
                }
              }

              function show() {
                cancelShow();
                cancelHide();
                if (!ttScope.content) {
                  return angular.noop;
                }
                createTooltip();
                ttScope.$evalAsync(function() {
                  ttScope.isOpen = true;
                  assignIsOpen(true);
                  positionTooltip();
                });
              }

              function cancelShow() {
                if (showTimeout) {
                  $timeout.cancel(showTimeout);
                  showTimeout = null;
                }
                if (positionTimeout) {
                  $timeout.cancel(positionTimeout);
                  positionTimeout = null;
                }
              }

              function hide() {
                if (!ttScope) {
                  return;
                }
                ttScope.$evalAsync(function() {
                  if (ttScope) {
                    ttScope.isOpen = false;
                    assignIsOpen(false);
                    if (ttScope.animation) {
                      if (!transitionTimeout) {
                        transitionTimeout = $timeout(removeTooltip, 150, false);
                      }
                    } else {
                      removeTooltip();
                    }
                  }
                });
              }

              function cancelHide() {
                if (hideTimeout) {
                  $timeout.cancel(hideTimeout);
                  hideTimeout = null;
                }
                if (transitionTimeout) {
                  $timeout.cancel(transitionTimeout);
                  transitionTimeout = null;
                }
              }

              function createTooltip() {
                if (tooltip) {
                  return;
                }
                tooltipLinkedScope = ttScope.$new();
                tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                  if (appendToBody) {
                    $document.find('body').append(tooltip);
                  } else {
                    element.after(tooltip);
                  }
                });
                prepObservers();
              }

              function removeTooltip() {
                cancelShow();
                cancelHide();
                unregisterObservers();
                if (tooltip) {
                  tooltip.remove();
                  tooltip = null;
                }
                if (tooltipLinkedScope) {
                  tooltipLinkedScope.$destroy();
                  tooltipLinkedScope = null;
                }
              }

              function prepareTooltip() {
                ttScope.title = attrs[prefix + 'Title'];
                if (contentParse) {
                  ttScope.content = contentParse(scope);
                } else {
                  ttScope.content = attrs[ttType];
                }
                ttScope.popupClass = attrs[prefix + 'Class'];
                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
              }

              function assignIsOpen(isOpen) {
                if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                  isOpenParse.assign(scope, isOpen);
                }
              }
              ttScope.contentExp = function() {
                return ttScope.content;
              };
              attrs.$observe('disabled', function(val) {
                if (val) {
                  cancelShow();
                }
                if (val && ttScope.isOpen) {
                  hide();
                }
              });
              if (isOpenParse) {
                scope.$watch(isOpenParse, function(val) {
                  if (ttScope && !val === ttScope.isOpen) {
                    toggleTooltipBind();
                  }
                });
              }

              function prepObservers() {
                observers.length = 0;
                if (contentParse) {
                  observers.push(
                    scope.$watch(contentParse, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    })
                  );
                  observers.push(
                    tooltipLinkedScope.$watch(function() {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function() {
                          repositionScheduled = false;
                          if (ttScope && ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    })
                  );
                } else {
                  observers.push(
                    attrs.$observe(ttType, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    })
                  );
                }
                observers.push(
                  attrs.$observe(prefix + 'Title', function(val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  })
                );
                observers.push(
                  attrs.$observe(prefix + 'Placement', function(val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  })
                );
              }

              function unregisterObservers() {
                if (observers.length) {
                  angular.forEach(observers, function(observer) {
                    observer();
                  });
                  observers.length = 0;
                }
              }

              function bodyHideTooltipBind(e) {
                if (!ttScope || !ttScope.isOpen || !tooltip) {
                  return;
                }
                if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                  hideTooltipBind();
                }
              }
              var unregisterTriggers = function() {
                triggers.show.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    element.off('click', toggleTooltipBind);
                  } else {
                    element.off(trigger, showTooltipBind);
                    element.off(trigger, toggleTooltipBind);
                  }
                });
                triggers.hide.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    $document.off('click', bodyHideTooltipBind);
                  } else {
                    element.off(trigger, hideTooltipBind);
                  }
                });
              };

              function prepTriggers() {
                var val = attrs[prefix + 'Trigger'];
                unregisterTriggers();
                triggers = getTriggers(val);
                if (triggers.show !== 'none') {
                  triggers.show.forEach(function(trigger, idx) {
                    if (trigger === 'outsideClick') {
                      element.on('click', toggleTooltipBind);
                      $document.on('click', bodyHideTooltipBind);
                    } else if (trigger === triggers.hide[idx]) {
                      element.on(trigger, toggleTooltipBind);
                    } else if (trigger) {
                      element.on(trigger, showTooltipBind);
                      element.on(triggers.hide[idx], hideTooltipBind);
                    }
                    element.on('keypress', function(e) {
                      if (e.which === 27) {
                        hideTooltipBind();
                      }
                    });
                  });
                }
              }
              prepTriggers();
              var animation = scope.$eval(attrs[prefix + 'Animation']);
              ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
              var appendToBodyVal;
              var appendKey = prefix + 'AppendToBody';
              if (appendKey in attrs && attrs[appendKey] === undefined) {
                appendToBodyVal = true;
              } else {
                appendToBodyVal = scope.$eval(attrs[appendKey]);
              }
              appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
              scope.$on('$destroy', function onDestroyTooltip() {
                unregisterTriggers();
                removeTooltip();
                openedTooltips.remove(ttScope);
                ttScope = null;
              });
            };
          }
        };
      };
    }];
  })
  .directive('uibTooltipTemplateTransclude', [
    '$animate', '$sce', '$compile', '$templateRequest',
    function($animate, $sce, $compile, $templateRequest) {
      return {
        link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }
      };
    }
  ])
  .directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        if (scope.placement) {
          var position = $uibPosition.parsePlacement(scope.placement);
          element.addClass(position[0]);
        } else {
          element.addClass('top');
        }
        if (scope.popupClass) {
          element.addClass(scope.popupClass);
        }
        if (scope.animation()) {
          element.addClass(attrs.tooltipAnimationClass);
        }
      }
    };
  }])
  .directive('uibTooltipPopup', function() {
    return {
      replace: true,
      scope: {
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
  })
  .directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
  }])
  .directive('uibTooltipTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&',
        originScope: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
  })
  .directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
      useContentExp: true
    });
  }])
  .directive('uibTooltipHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
  })
  .directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
      useContentExp: true
    });
  }]);
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
  .directive('uibPopoverTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        title: '@',
        contentExp: '&',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&',
        originScope: '&'
      },
      templateUrl: 'uib/template/popover/popover-template.html'
    };
  })
  .directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
      useContentExp: true
    });
  }])
  .directive('uibPopoverHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&',
        title: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/popover/popover-html.html'
    };
  })
  .directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
      useContentExp: true
    });
  }])
  .directive('uibPopoverPopup', function() {
    return {
      replace: true,
      scope: {
        title: '@',
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&',
        isOpen: '&'
      },
      templateUrl: 'uib/template/popover/popover.html'
    };
  })
  .directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopover', 'popover', 'click');
  }]);
angular.module('ui.bootstrap.progressbar', [])
  .constant('uibProgressConfig', {
    animate: true,
    max: 100
  })
  .controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
    var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
    this.addBar = function(bar, element, attrs) {
      if (!animate) {
        element.css({
          'transition': 'none'
        });
      }
      this.bars.push(bar);
      bar.max = $scope.max;
      bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
      bar.$watch('value', function(value) {
        bar.recalculatePercentage();
      });
      bar.recalculatePercentage = function() {
        var totalPercentage = self.bars.reduce(function(total, bar) {
          bar.percent = +(100 * bar.value / bar.max).toFixed(2);
          return total + bar.percent;
        }, 0);
        if (totalPercentage > 100) {
          bar.percent -= totalPercentage - 100;
        }
      };
      bar.$on('$destroy', function() {
        element = null;
        self.removeBar(bar);
      });
    };
    this.removeBar = function(bar) {
      this.bars.splice(this.bars.indexOf(bar), 1);
      this.bars.forEach(function(bar) {
        bar.recalculatePercentage();
      });
    };
    $scope.$watch('max', function(max) {
      self.bars.forEach(function(bar) {
        bar.max = $scope.max;
        bar.recalculatePercentage();
      });
    });
  }])
  .directive('uibProgress', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      require: 'uibProgress',
      scope: {
        max: '=?'
      },
      templateUrl: 'uib/template/progressbar/progress.html'
    };
  })
  .directive('uibBar', function() {
    return {
      replace: true,
      transclude: true,
      require: '^uibProgress',
      scope: {
        value: '=',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/bar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, element, attrs);
      }
    };
  })
  .directive('uibProgressbar', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      scope: {
        value: '=',
        max: '=?',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/progressbar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, angular.element(element.children()[0]), {
          title: attrs.title
        });
      }
    };
  });
angular.module('ui.bootstrap.rating', [])
  .constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    titles: ['one', 'two', 'three', 'four', 'five']
  })
  .controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
      $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.push(function(value) {
        if (angular.isNumber(value) && value << 0 !== value) {
          value = Math.round(value);
        }
        return value;
      });
      this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
      this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
      var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
      this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
        tmpTitles : ratingConfig.titles;
      var ratingStates = angular.isDefined($attrs.ratingStates) ?
        $scope.$parent.$eval($attrs.ratingStates) :
        new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
      $scope.range = this.buildTemplateObjects(ratingStates);
    };
    this.buildTemplateObjects = function(states) {
      for (var i = 0, n = states.length; i < n; i++) {
        states[i] = angular.extend({
          index: i
        }, {
          stateOn: this.stateOn,
          stateOff: this.stateOff,
          title: this.getTitle(i)
        }, states[i]);
      }
      return states;
    };
    this.getTitle = function(index) {
      if (index >= this.titles.length) {
        return index + 1;
      }
      return this.titles[index];
    };
    $scope.rate = function(value) {
      if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
        ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
        ngModelCtrl.$render();
      }
    };
    $scope.enter = function(value) {
      if (!$scope.readonly) {
        $scope.value = value;
      }
      $scope.onHover({
        value: value
      });
    };
    $scope.reset = function() {
      $scope.value = ngModelCtrl.$viewValue;
      $scope.onLeave();
    };
    $scope.onKeydown = function(evt) {
      if (/(37|38|39|40)/.test(evt.which)) {
        evt.preventDefault();
        evt.stopPropagation();
        $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
      }
    };
    this.render = function() {
      $scope.value = ngModelCtrl.$viewValue;
    };
  }])
  .directive('uibRating', function() {
    return {
      require: ['uibRating', 'ngModel'],
      scope: {
        readonly: '=?',
        onHover: '&',
        onLeave: '&'
      },
      controller: 'UibRatingController',
      templateUrl: 'uib/template/rating/rating.html',
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var ratingCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        ratingCtrl.init(ngModelCtrl);
      }
    };
  });
angular.module('ui.bootstrap.tabs', [])
  .controller('UibTabsetController', ['$scope', function($scope) {
    var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
      angular.forEach(tabs, function(tab) {
        if (tab.active && tab !== selectedTab) {
          tab.active = false;
          tab.onDeselect();
          selectedTab.selectCalled = false;
        }
      });
      selectedTab.active = true;
      if (!selectedTab.selectCalled) {
        selectedTab.onSelect();
        selectedTab.selectCalled = true;
      }
    };
    ctrl.addTab = function addTab(tab) {
      tabs.push(tab);
      if (tabs.length === 1 && tab.active !== false) {
        tab.active = true;
      } else if (tab.active) {
        ctrl.select(tab);
      } else {
        tab.active = false;
      }
    };
    ctrl.removeTab = function removeTab(tab) {
      var index = tabs.indexOf(tab);
      if (tab.active && tabs.length > 1 && !destroyed) {
        var newActiveIndex = index === tabs.length - 1 ? index - 1 : index + 1;
        ctrl.select(tabs[newActiveIndex]);
      }
      tabs.splice(index, 1);
    };
    var destroyed;
    $scope.$on('$destroy', function() {
      destroyed = true;
    });
  }])
  .directive('uibTabset', function() {
    return {
      transclude: true,
      replace: true,
      scope: {
        type: '@'
      },
      controller: 'UibTabsetController',
      templateUrl: 'uib/template/tabs/tabset.html',
      link: function(scope, element, attrs) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
      }
    };
  })
  .directive('uibTab', ['$parse', function($parse) {
    return {
      require: '^uibTabset',
      replace: true,
      templateUrl: 'uib/template/tabs/tab.html',
      transclude: true,
      scope: {
        active: '=?',
        heading: '@',
        onSelect: '&select',
        onDeselect: '&deselect'
      },
      controller: function() {},
      controllerAs: 'tab',
      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });
        scope.disabled = false;
        if (attrs.disable) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !!value;
          });
        }
        scope.select = function() {
          if (!scope.disabled) {
            scope.active = true;
          }
        };
        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });
        scope.$transcludeFn = transclude;
      }
    };
  }])
  .directive('uibTabHeadingTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTab',
      link: function(scope, elm) {
        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  })
  .directive('uibTabContentTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTabset',
      link: function(scope, elm, attrs) {
        var tab = scope.$eval(attrs.uibTabContentTransclude);
        tab.$transcludeFn(tab.$parent, function(contents) {
          angular.forEach(contents, function(node) {
            if (isTabHeading(node)) {
              tab.headingElement = node;
            } else {
              elm.append(node);
            }
          });
        });
      }
    };

    function isTabHeading(node) {
      return node.tagName && (
        node.hasAttribute('uib-tab-heading') ||
        node.hasAttribute('data-uib-tab-heading') ||
        node.hasAttribute('x-uib-tab-heading') ||
        node.tagName.toLowerCase() === 'uib-tab-heading' ||
        node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
        node.tagName.toLowerCase() === 'x-uib-tab-heading'
      );
    }
  });
angular.module('ui.bootstrap.timepicker', [])
  .constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: 'uib/template/timepicker/timepicker.html'
  })
  .controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date(),
      watchers = [],
      ngModelCtrl = {
        $setViewValue: angular.noop
      },
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
    $element.removeAttr('tabindex');
    this.init = function(ngModelCtrl_, inputs) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.unshift(function(modelValue) {
        return modelValue ? new Date(modelValue) : null;
      });
      var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);
      var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
      if (mousewheel) {
        this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
      if (arrowkeys) {
        this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
      this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    if ($attrs.hourStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
      }));
    }
    var minuteStep = timepickerConfig.minuteStep;
    if ($attrs.minuteStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
      }));
    }
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
      var dt = new Date(value);
      min = isNaN(dt) ? undefined : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
      var dt = new Date(value);
      max = isNaN(dt) ? undefined : dt;
    }));
    var disabled = false;
    if ($attrs.ngDisabled) {
      watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
      }));
    }
    $scope.noIncrementHours = function() {
      var incrementedSelected = addMinutes(selected, hourStep * 60);
      return disabled || incrementedSelected > max ||
        incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementHours = function() {
      var decrementedSelected = addMinutes(selected, -hourStep * 60);
      return disabled || decrementedSelected < min ||
        decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noIncrementMinutes = function() {
      var incrementedSelected = addMinutes(selected, minuteStep);
      return disabled || incrementedSelected > max ||
        incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementMinutes = function() {
      var decrementedSelected = addMinutes(selected, -minuteStep);
      return disabled || decrementedSelected < min ||
        decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noIncrementSeconds = function() {
      var incrementedSelected = addSeconds(selected, secondStep);
      return disabled || incrementedSelected > max ||
        incrementedSelected < selected && incrementedSelected < min;
    };
    $scope.noDecrementSeconds = function() {
      var decrementedSelected = addSeconds(selected, -secondStep);
      return disabled || decrementedSelected < min ||
        decrementedSelected > selected && decrementedSelected > max;
    };
    $scope.noToggleMeridian = function() {
      if (selected.getHours() < 12) {
        return disabled || addMinutes(selected, 12 * 60) > max;
      }
      return disabled || addMinutes(selected, -12 * 60) < min;
    };
    var secondStep = timepickerConfig.secondStep;
    if ($attrs.secondStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
      }));
    }
    $scope.showSeconds = timepickerConfig.showSeconds;
    if ($attrs.showSeconds) {
      watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
      }));
    }
    $scope.showMeridian = timepickerConfig.showMeridian;
    if ($attrs.showMeridian) {
      watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        $scope.showMeridian = !!value;
        if (ngModelCtrl.$error.time) {
          var hours = getHoursFromTemplate(),
            minutes = getMinutesFromTemplate();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            refresh();
          }
        } else {
          updateTemplate();
        }
      }));
    }

    function getHoursFromTemplate() {
      var hours = +$scope.hours;
      var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
        hours >= 0 && hours < 24;
      if (!valid) {
        return undefined;
      }
      if ($scope.showMeridian) {
        if (hours === 12) {
          hours = 0;
        }
        if ($scope.meridian === meridians[1]) {
          hours = hours + 12;
        }
      }
      return hours;
    }

    function getMinutesFromTemplate() {
      var minutes = +$scope.minutes;
      return minutes >= 0 && minutes < 60 ? minutes : undefined;
    }

    function getSecondsFromTemplate() {
      var seconds = +$scope.seconds;
      return seconds >= 0 && seconds < 60 ? seconds : undefined;
    }

    function pad(value) {
      if (value === null) {
        return '';
      }
      return angular.isDefined(value) && value.toString().length < 2 ?
        '0' + value : value.toString();
    }
    this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      var isScrollingUp = function(e) {
        if (e.originalEvent) {
          e = e.originalEvent;
        }
        var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
        return e.detail || delta > 0;
      };
      hoursInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
        }
        e.preventDefault();
      });
      minutesInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
        }
        e.preventDefault();
      });
      secondsInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
        }
        e.preventDefault();
      });
    };
    this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      hoursInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementHours();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementHours();
            $scope.$apply();
          }
        }
      });
      minutesInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementMinutes();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementMinutes();
            $scope.$apply();
          }
        }
      });
      secondsInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementSeconds();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementSeconds();
            $scope.$apply();
          }
        }
      });
    };
    this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      if ($scope.readonlyInput) {
        $scope.updateHours = angular.noop;
        $scope.updateMinutes = angular.noop;
        $scope.updateSeconds = angular.noop;
        return;
      }
      var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
        ngModelCtrl.$setViewValue(null);
        ngModelCtrl.$setValidity('time', false);
        if (angular.isDefined(invalidHours)) {
          $scope.invalidHours = invalidHours;
        }
        if (angular.isDefined(invalidMinutes)) {
          $scope.invalidMinutes = invalidMinutes;
        }
        if (angular.isDefined(invalidSeconds)) {
          $scope.invalidSeconds = invalidSeconds;
        }
      };
      $scope.updateHours = function() {
        var hours = getHoursFromTemplate(),
          minutes = getMinutesFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected < min || selected > max) {
            invalidate(true);
          } else {
            refresh('h');
          }
        } else {
          invalidate(true);
        }
      };
      hoursInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if ($scope.hours === null || $scope.hours === '') {
          invalidate(true);
        } else if (!$scope.invalidHours && $scope.hours < 10) {
          $scope.$apply(function() {
            $scope.hours = pad($scope.hours);
          });
        }
      });
      $scope.updateMinutes = function() {
        var minutes = getMinutesFromTemplate(),
          hours = getHoursFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(minutes) && angular.isDefined(hours)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected < min || selected > max) {
            invalidate(undefined, true);
          } else {
            refresh('m');
          }
        } else {
          invalidate(undefined, true);
        }
      };
      minutesInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if ($scope.minutes === null) {
          invalidate(undefined, true);
        } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
          $scope.$apply(function() {
            $scope.minutes = pad($scope.minutes);
          });
        }
      });
      $scope.updateSeconds = function() {
        var seconds = getSecondsFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(seconds)) {
          selected.setSeconds(seconds);
          refresh('s');
        } else {
          invalidate(undefined, undefined, true);
        }
      };
      secondsInputEl.bind('blur', function(e) {
        if (!$scope.invalidSeconds && $scope.seconds < 10) {
          $scope.$apply(function() {
            $scope.seconds = pad($scope.seconds);
          });
        }
      });
    };
    this.render = function() {
      var date = ngModelCtrl.$viewValue;
      if (isNaN(date)) {
        ngModelCtrl.$setValidity('time', false);
        $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      } else {
        if (date) {
          selected = date;
        }
        if (selected < min || selected > max) {
          ngModelCtrl.$setValidity('time', false);
          $scope.invalidHours = true;
          $scope.invalidMinutes = true;
        } else {
          makeValid();
        }
        updateTemplate();
      }
    };

    function refresh(keyboardChange) {
      makeValid();
      ngModelCtrl.$setViewValue(new Date(selected));
      updateTemplate(keyboardChange);
    }

    function makeValid() {
      ngModelCtrl.$setValidity('time', true);
      $scope.invalidHours = false;
      $scope.invalidMinutes = false;
      $scope.invalidSeconds = false;
    }

    function updateTemplate(keyboardChange) {
      if (!ngModelCtrl.$modelValue) {
        $scope.hours = null;
        $scope.minutes = null;
        $scope.seconds = null;
        $scope.meridian = meridians[0];
      } else {
        var hours = selected.getHours(),
          minutes = selected.getMinutes(),
          seconds = selected.getSeconds();
        if ($scope.showMeridian) {
          hours = hours === 0 || hours === 12 ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
        if (keyboardChange !== 'm') {
          $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        if (keyboardChange !== 's') {
          $scope.seconds = pad(seconds);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }
    }

    function addSecondsToSelected(seconds) {
      selected = addSeconds(selected, seconds);
      refresh();
    }

    function addMinutes(selected, minutes) {
      return addSeconds(selected, minutes * 60);
    }

    function addSeconds(date, seconds) {
      var dt = new Date(date.getTime() + seconds * 1000);
      var newDate = new Date(date);
      newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
      return newDate;
    }
    $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
      $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
    $scope.incrementHours = function() {
      if (!$scope.noIncrementHours()) {
        addSecondsToSelected(hourStep * 60 * 60);
      }
    };
    $scope.decrementHours = function() {
      if (!$scope.noDecrementHours()) {
        addSecondsToSelected(-hourStep * 60 * 60);
      }
    };
    $scope.incrementMinutes = function() {
      if (!$scope.noIncrementMinutes()) {
        addSecondsToSelected(minuteStep * 60);
      }
    };
    $scope.decrementMinutes = function() {
      if (!$scope.noDecrementMinutes()) {
        addSecondsToSelected(-minuteStep * 60);
      }
    };
    $scope.incrementSeconds = function() {
      if (!$scope.noIncrementSeconds()) {
        addSecondsToSelected(secondStep);
      }
    };
    $scope.decrementSeconds = function() {
      if (!$scope.noDecrementSeconds()) {
        addSecondsToSelected(-secondStep);
      }
    };
    $scope.toggleMeridian = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();
      if (!$scope.noToggleMeridian()) {
        if (angular.isDefined(minutes) && angular.isDefined(hours)) {
          addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
        } else {
          $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
        }
      }
    };
    $scope.blur = function() {
      ngModelCtrl.$setTouched();
    };
    $scope.$on('$destroy', function() {
      while (watchers.length) {
        watchers.shift()();
      }
    });
  }])
  .directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
    return {
      require: ['uibTimepicker', '?^ngModel'],
      controller: 'UibTimepickerController',
      controllerAs: 'timepicker',
      replace: true,
      scope: {},
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || uibTimepickerConfig.templateUrl;
      },
      link: function(scope, element, attrs, ctrls) {
        var timepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (ngModelCtrl) {
          timepickerCtrl.init(ngModelCtrl, element.find('input'));
        }
      }
    };
  }]);
angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
            ' but got "' + input + '".');
        }
        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])
  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl, ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== false;
      });
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
      var appendTo = attrs.typeaheadAppendTo ?
        originalScope.$eval(attrs.typeaheadAppendTo) : null;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) &&
          ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, {
            $$$p: newValue
          });
        }
        return parsedModel.assign(scope, newValue);
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });
      var inputsContainer, hintInputElem;
      if (showHint) {
        inputsContainer = angular.element('<div></div>');
        inputsContainer.css('position', 'relative');
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr('placeholder', '');
        hintInputElem.val('');
        hintInputElem.css({
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'border-color': 'transparent',
          'box-shadow': 'none',
          'opacity': 1,
          'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
          'color': '#999'
        });
        element.css({
          'position': 'relative',
          'vertical-align': 'top',
          'background-color': 'transparent'
        });
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }
      var popUpEl = angular.element('<div uib-typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx, evt)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position',
        'assign-is-open': 'assignIsOpen(isOpen)',
        debounce: 'debounceUpdate'
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }
      var resetHint = function() {
        if (showHint) {
          hintInputElem.val('');
        }
      };
      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
        resetHint();
      };
      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });
      var inputIsExactMatch = function(inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }
        return false;
      };
      var getMatchesAsync = function(inputValue, evt) {
        var locals = {
          $viewValue: inputValue
        };
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }
              scope.query = inputValue;
              recalculatePosition();
              element.attr('aria-expanded', true);
              if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function() {
                    scope.select(0, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(0, evt);
                }
              }
              if (showHint) {
                var firstLabel = scope.matches[0].label;
                if (angular.isString(inputValue) &&
                  inputValue.length > 0 &&
                  firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                  hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                } else {
                  hintInputElem.val('');
                }
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function() {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };
      if (appendToBody) {
        angular.element($window).on('resize', fireRecalculating);
        $document.find('body').on('scroll', fireRecalculating);
      }
      var debouncedRecalculate = $$debounce(function() {
        if (scope.matches.length) {
          recalculatePosition();
        }
        scope.moveInProgress = false;
      }, eventDebounceTime);
      scope.moveInProgress = false;

      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        debouncedRecalculate();
      }

      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
      };
      scope.select = function(activeIdx, evt) {
        var locals = {};
        var model, item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function() {
            element[0].focus();
          }, 0, false);
        }
      };
      element.on('keydown', function(evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 9:
          case 13:
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(scope.activeIdx, evt);
              }
            });
            break;
          case 27:
            evt.stopPropagation();
            resetMatches();
            scope.$digest();
            break;
          case 38:
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
        }
      });
      element.bind('focus', function(evt) {
        hasFocus = true;
        if (minLength === 0 && !modelCtrl.$viewValue) {
          $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });
      element.bind('blur', function(evt) {
        if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
          selected = true;
          scope.$apply(function() {
            if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
              $$debounce(function() {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable && modelCtrl.$error.editable) {
          modelCtrl.$viewValue = '';
          element.val('');
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function(evt) {
        if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            scope.$digest();
          }
        }
      };
      $document.on('click', dismissClickHandler);
      originalScope.$on('$destroy', function() {
        $document.off('click', dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).off('resize', fireRecalculating);
          $document.find('body').off('scroll', fireRecalculating);
        }
        popUpEl.remove();
        if (showHint) {
          inputsContainer.remove();
        }
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;
          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          }
          if (!inputValue) {
            modelCtrl.$setValidity('editable', true);
            return null;
          }
          modelCtrl.$setValidity('editable', false);
          return undefined;
        });
        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);
          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        });
      };
    }
  ])
  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  })
  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&',
        assignIsOpen: '&',
        debounce: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;
        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length > 0;
          scope.assignIsOpen({
            isOpen: isDropdownOpen
          });
          return isDropdownOpen;
        };
        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };
        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };
        scope.selectMatch = function(activeIdx, evt) {
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({
                activeIdx: activeIdx,
                evt: evt
              });
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({
              activeIdx: activeIdx,
              evt: evt
            });
          }
        };
      }
    };
  }])
  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }])
  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }
    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize');
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem);
      }
      return matchItem;
    };
  }]);
angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
    "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" +
    "  <div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
    "    <h4 class=\"panel-title\">\n" +
    "      <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "    </h4>\n" +
    "  </div>\n" +
    "  <div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
    "    <div class=\"panel-body\" ng-transclude></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
    "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);
angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
    "        <span aria-hidden=\"true\">&times;</span>\n" +
    "        <span class=\"sr-only\">Close</span>\n" +
    "    </button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
    "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
    "    <span class=\"sr-only\">previous</span>\n" +
    "  </a>\n" +
    "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
    "    <span class=\"sr-only\">next</span>\n" +
    "  </a>\n" +
    "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
    "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
    "    </li>\n" +
    "  </ol>\n" +
    "</div>");
}]);
angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': active\n" +
    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
    "");
}]);
angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
    "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
    "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
    "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
    "</div>");
}]);
angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
    "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);
angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
    "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);
angular.module("uib/template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/popup.html",
    "<div>\n" +
    "  <ul class=\"uib-datepicker-popup dropdown-menu\" dropdown-nested ng-if=\"isOpen\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "    <li ng-transclude></li>\n" +
    "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
    "    <span class=\"btn-group pull-left\">\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
    "    </span>\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
    "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);
angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/backdrop.html",
    "<div class=\"modal-backdrop\"\n" +
    "     uib-modal-animation-class=\"fade\"\n" +
    "     modal-in-class=\"in\"\n" +
    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
    "></div>\n" +
    "");
}]);
angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
    "    uib-modal-animation-class=\"fade\"\n" +
    "    modal-in-class=\"in\"\n" +
    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
    "    <div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\"\n" +
    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\"\n" +
    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "");
}]);
angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);
angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\n" +
    "</span>\n" +
    "");
}]);
angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\" class=\"uib-tab\">\n" +
    "  <a href ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);
angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         uib-tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);
angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
    "<table class=\"uib-timepicker\">\n" +
    "  <tbody>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
    "        <input style=\"width:50px;\" type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);
angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
    "<a href\n" +
    "   tabindex=\"-1\"\n" +
    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
    "   ng-attr-title=\"{{match.label}}\"></a>\n" +
    "");
}]);
angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module('ui.bootstrap.carousel').run(function() {
  !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
});
angular.module('ui.bootstrap.datepicker').run(function() {
  !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>');
});
angular.module('ui.bootstrap.timepicker').run(function() {
  !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
});
angular.module('ui.bootstrap.typeahead').run(function() {
  !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');
});;
/*! RESOURCE: /scripts/libs/moment/moment-2.14.1.min.js */
//! moment.js
//! version : 2.14.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
! function(a, b) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.moment = b()
}(this, function() {
  "use strict";

  function a() {
    return md.apply(null, arguments)
  }
  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function b(a) {
    md = a
  }

  function c(a) {
    return a instanceof Array || "[object Array]" === Object.prototype.toString.call(a)
  }

  function d(a) {
    return "[object Object]" === Object.prototype.toString.call(a)
  }

  function e(a) {
    var b;
    for (b in a)
      // even if its not own property I'd still call it non-empty
      return !1;
    return !0
  }

  function f(a) {
    return a instanceof Date || "[object Date]" === Object.prototype.toString.call(a)
  }

  function g(a, b) {
    var c, d = [];
    for (c = 0; c < a.length; ++c) d.push(b(a[c], c));
    return d
  }

  function h(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b)
  }

  function i(a, b) {
    for (var c in b) h(b, c) && (a[c] = b[c]);
    return h(b, "toString") && (a.toString = b.toString), h(b, "valueOf") && (a.valueOf = b.valueOf), a
  }

  function j(a, b, c, d) {
    return qb(a, b, c, d, !0).utc()
  }

  function k() {
    // We need to deep clone this object.
    return {
      empty: !1,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: !1,
      invalidMonth: null,
      invalidFormat: !1,
      userInvalidated: !1,
      iso: !1,
      parsedDateParts: [],
      meridiem: null
    }
  }

  function l(a) {
    return null == a._pf && (a._pf = k()), a._pf
  }

  function m(a) {
    if (null == a._isValid) {
      var b = l(a),
        c = nd.call(b.parsedDateParts, function(a) {
          return null != a
        });
      a._isValid = !isNaN(a._d.getTime()) && b.overflow < 0 && !b.empty && !b.invalidMonth && !b.invalidWeekday && !b.nullInput && !b.invalidFormat && !b.userInvalidated && (!b.meridiem || b.meridiem && c), a._strict && (a._isValid = a._isValid && 0 === b.charsLeftOver && 0 === b.unusedTokens.length && void 0 === b.bigHour)
    }
    return a._isValid
  }

  function n(a) {
    var b = j(NaN);
    return null != a ? i(l(b), a) : l(b).userInvalidated = !0, b
  }

  function o(a) {
    return void 0 === a
  }

  function p(a, b) {
    var c, d, e;
    if (o(b._isAMomentObject) || (a._isAMomentObject = b._isAMomentObject), o(b._i) || (a._i = b._i), o(b._f) || (a._f = b._f), o(b._l) || (a._l = b._l), o(b._strict) || (a._strict = b._strict), o(b._tzm) || (a._tzm = b._tzm), o(b._isUTC) || (a._isUTC = b._isUTC), o(b._offset) || (a._offset = b._offset), o(b._pf) || (a._pf = l(b)), o(b._locale) || (a._locale = b._locale), od.length > 0)
      for (c in od) d = od[c], e = b[d], o(e) || (a[d] = e);
    return a
  }
  // Moment prototype object
  function q(b) {
    p(this, b), this._d = new Date(null != b._d ? b._d.getTime() : NaN), pd === !1 && (pd = !0, a.updateOffset(this), pd = !1)
  }

  function r(a) {
    return a instanceof q || null != a && null != a._isAMomentObject
  }

  function s(a) {
    return 0 > a ? Math.ceil(a) || 0 : Math.floor(a)
  }

  function t(a) {
    var b = +a,
      c = 0;
    return 0 !== b && isFinite(b) && (c = s(b)), c
  }
  // compare two arrays, return the number of differences
  function u(a, b, c) {
    var d, e = Math.min(a.length, b.length),
      f = Math.abs(a.length - b.length),
      g = 0;
    for (d = 0; e > d; d++)(c && a[d] !== b[d] || !c && t(a[d]) !== t(b[d])) && g++;
    return g + f
  }

  function v(b) {
    a.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + b)
  }

  function w(b, c) {
    var d = !0;
    return i(function() {
      return null != a.deprecationHandler && a.deprecationHandler(null, b), d && (v(b + "\nArguments: " + Array.prototype.slice.call(arguments).join(", ") + "\n" + (new Error).stack), d = !1), c.apply(this, arguments)
    }, c)
  }

  function x(b, c) {
    null != a.deprecationHandler && a.deprecationHandler(b, c), qd[b] || (v(c), qd[b] = !0)
  }

  function y(a) {
    return a instanceof Function || "[object Function]" === Object.prototype.toString.call(a)
  }

  function z(a) {
    var b, c;
    for (c in a) b = a[c], y(b) ? this[c] = b : this["_" + c] = b;
    this._config = a,
      // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _ordinalParseLenient.
      this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source)
  }

  function A(a, b) {
    var c, e = i({}, a);
    for (c in b) h(b, c) && (d(a[c]) && d(b[c]) ? (e[c] = {}, i(e[c], a[c]), i(e[c], b[c])) : null != b[c] ? e[c] = b[c] : delete e[c]);
    for (c in a) h(a, c) && !h(b, c) && d(a[c]) && (
      // make sure changes to properties don't modify parent config
      e[c] = i({}, e[c]));
    return e
  }

  function B(a) {
    null != a && this.set(a)
  }

  function C(a, b, c) {
    var d = this._calendar[a] || this._calendar.sameElse;
    return y(d) ? d.call(b, c) : d
  }

  function D(a) {
    var b = this._longDateFormat[a],
      c = this._longDateFormat[a.toUpperCase()];
    return b || !c ? b : (this._longDateFormat[a] = c.replace(/MMMM|MM|DD|dddd/g, function(a) {
      return a.slice(1)
    }), this._longDateFormat[a])
  }

  function E() {
    return this._invalidDate
  }

  function F(a) {
    return this._ordinal.replace("%d", a)
  }

  function G(a, b, c, d) {
    var e = this._relativeTime[c];
    return y(e) ? e(a, b, c, d) : e.replace(/%d/i, a)
  }

  function H(a, b) {
    var c = this._relativeTime[a > 0 ? "future" : "past"];
    return y(c) ? c(b) : c.replace(/%s/i, b)
  }

  function I(a, b) {
    var c = a.toLowerCase();
    zd[c] = zd[c + "s"] = zd[b] = a
  }

  function J(a) {
    return "string" == typeof a ? zd[a] || zd[a.toLowerCase()] : void 0
  }

  function K(a) {
    var b, c, d = {};
    for (c in a) h(a, c) && (b = J(c), b && (d[b] = a[c]));
    return d
  }

  function L(a, b) {
    Ad[a] = b
  }

  function M(a) {
    var b = [];
    for (var c in a) b.push({
      unit: c,
      priority: Ad[c]
    });
    return b.sort(function(a, b) {
      return a.priority - b.priority
    }), b
  }

  function N(b, c) {
    return function(d) {
      return null != d ? (P(this, b, d), a.updateOffset(this, c), this) : O(this, b)
    }
  }

  function O(a, b) {
    return a.isValid() ? a._d["get" + (a._isUTC ? "UTC" : "") + b]() : NaN
  }

  function P(a, b, c) {
    a.isValid() && a._d["set" + (a._isUTC ? "UTC" : "") + b](c)
  }
  // MOMENTS
  function Q(a) {
    return a = J(a), y(this[a]) ? this[a]() : this
  }

  function R(a, b) {
    if ("object" == typeof a) {
      a = K(a);
      for (var c = M(a), d = 0; d < c.length; d++) this[c[d].unit](a[c[d].unit])
    } else if (a = J(a), y(this[a])) return this[a](b);
    return this
  }

  function S(a, b, c) {
    var d = "" + Math.abs(a),
      e = b - d.length,
      f = a >= 0;
    return (f ? c ? "+" : "" : "-") + Math.pow(10, Math.max(0, e)).toString().substr(1) + d
  }
  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function T(a, b, c, d) {
    var e = d;
    "string" == typeof d && (e = function() {
      return this[d]()
    }), a && (Ed[a] = e), b && (Ed[b[0]] = function() {
      return S(e.apply(this, arguments), b[1], b[2])
    }), c && (Ed[c] = function() {
      return this.localeData().ordinal(e.apply(this, arguments), a)
    })
  }

  function U(a) {
    return a.match(/\[[\s\S]/) ? a.replace(/^\[|\]$/g, "") : a.replace(/\\/g, "")
  }

  function V(a) {
    var b, c, d = a.match(Bd);
    for (b = 0, c = d.length; c > b; b++) Ed[d[b]] ? d[b] = Ed[d[b]] : d[b] = U(d[b]);
    return function(b) {
      var e, f = "";
      for (e = 0; c > e; e++) f += d[e] instanceof Function ? d[e].call(b, a) : d[e];
      return f
    }
  }
  // format date using native date object
  function W(a, b) {
    return a.isValid() ? (b = X(b, a.localeData()), Dd[b] = Dd[b] || V(b), Dd[b](a)) : a.localeData().invalidDate()
  }

  function X(a, b) {
    function c(a) {
      return b.longDateFormat(a) || a
    }
    var d = 5;
    for (Cd.lastIndex = 0; d >= 0 && Cd.test(a);) a = a.replace(Cd, c), Cd.lastIndex = 0, d -= 1;
    return a
  }

  function Y(a, b, c) {
    Wd[a] = y(b) ? b : function(a, d) {
      return a && c ? c : b
    }
  }

  function Z(a, b) {
    return h(Wd, a) ? Wd[a](b._strict, b._locale) : new RegExp($(a))
  }
  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function $(a) {
    return _(a.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(a, b, c, d, e) {
      return b || c || d || e
    }))
  }

  function _(a) {
    return a.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
  }

  function aa(a, b) {
    var c, d = b;
    for ("string" == typeof a && (a = [a]), "number" == typeof b && (d = function(a, c) {
        c[b] = t(a)
      }), c = 0; c < a.length; c++) Xd[a[c]] = d
  }

  function ba(a, b) {
    aa(a, function(a, c, d, e) {
      d._w = d._w || {}, b(a, d._w, d, e)
    })
  }

  function ca(a, b, c) {
    null != b && h(Xd, a) && Xd[a](b, c._a, c, a)
  }

  function da(a, b) {
    return new Date(Date.UTC(a, b + 1, 0)).getUTCDate()
  }

  function ea(a, b) {
    return c(this._months) ? this._months[a.month()] : this._months[(this._months.isFormat || fe).test(b) ? "format" : "standalone"][a.month()]
  }

  function fa(a, b) {
    return c(this._monthsShort) ? this._monthsShort[a.month()] : this._monthsShort[fe.test(b) ? "format" : "standalone"][a.month()]
  }

  function ga(a, b, c) {
    var d, e, f, g = a.toLocaleLowerCase();
    if (!this._monthsParse)
      for (
        // this is not used
        this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], d = 0; 12 > d; ++d) f = j([2e3, d]), this._shortMonthsParse[d] = this.monthsShort(f, "").toLocaleLowerCase(), this._longMonthsParse[d] = this.months(f, "").toLocaleLowerCase();
    return c ? "MMM" === b ? (e = sd.call(this._shortMonthsParse, g), -1 !== e ? e : null) : (e = sd.call(this._longMonthsParse, g), -1 !== e ? e : null) : "MMM" === b ? (e = sd.call(this._shortMonthsParse, g), -1 !== e ? e : (e = sd.call(this._longMonthsParse, g), -1 !== e ? e : null)) : (e = sd.call(this._longMonthsParse, g), -1 !== e ? e : (e = sd.call(this._shortMonthsParse, g), -1 !== e ? e : null))
  }

  function ha(a, b, c) {
    var d, e, f;
    if (this._monthsParseExact) return ga.call(this, a, b, c);
    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), d = 0; 12 > d; d++) {
      // test the regex
      if (e = j([2e3, d]), c && !this._longMonthsParse[d] && (this._longMonthsParse[d] = new RegExp("^" + this.months(e, "").replace(".", "") + "$", "i"), this._shortMonthsParse[d] = new RegExp("^" + this.monthsShort(e, "").replace(".", "") + "$", "i")), c || this._monthsParse[d] || (f = "^" + this.months(e, "") + "|^" + this.monthsShort(e, ""), this._monthsParse[d] = new RegExp(f.replace(".", ""), "i")), c && "MMMM" === b && this._longMonthsParse[d].test(a)) return d;
      if (c && "MMM" === b && this._shortMonthsParse[d].test(a)) return d;
      if (!c && this._monthsParse[d].test(a)) return d
    }
  }
  // MOMENTS
  function ia(a, b) {
    var c;
    if (!a.isValid())
      // No op
      return a;
    if ("string" == typeof b)
      if (/^\d+$/.test(b)) b = t(b);
      else
        // TODO: Another silent failure?
        if (b = a.localeData().monthsParse(b), "number" != typeof b) return a;
    return c = Math.min(a.date(), da(a.year(), b)), a._d["set" + (a._isUTC ? "UTC" : "") + "Month"](b, c), a
  }

  function ja(b) {
    return null != b ? (ia(this, b), a.updateOffset(this, !0), this) : O(this, "Month")
  }

  function ka() {
    return da(this.year(), this.month())
  }

  function la(a) {
    return this._monthsParseExact ? (h(this, "_monthsRegex") || na.call(this), a ? this._monthsShortStrictRegex : this._monthsShortRegex) : (h(this, "_monthsShortRegex") || (this._monthsShortRegex = ie), this._monthsShortStrictRegex && a ? this._monthsShortStrictRegex : this._monthsShortRegex)
  }

  function ma(a) {
    return this._monthsParseExact ? (h(this, "_monthsRegex") || na.call(this), a ? this._monthsStrictRegex : this._monthsRegex) : (h(this, "_monthsRegex") || (this._monthsRegex = je), this._monthsStrictRegex && a ? this._monthsStrictRegex : this._monthsRegex)
  }

  function na() {
    function a(a, b) {
      return b.length - a.length
    }
    var b, c, d = [],
      e = [],
      f = [];
    for (b = 0; 12 > b; b++) c = j([2e3, b]), d.push(this.monthsShort(c, "")), e.push(this.months(c, "")), f.push(this.months(c, "")), f.push(this.monthsShort(c, ""));
    for (
      // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.
      d.sort(a), e.sort(a), f.sort(a), b = 0; 12 > b; b++) d[b] = _(d[b]), e[b] = _(e[b]);
    for (b = 0; 24 > b; b++) f[b] = _(f[b]);
    this._monthsRegex = new RegExp("^(" + f.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + d.join("|") + ")", "i")
  }
  // HELPERS
  function oa(a) {
    return pa(a) ? 366 : 365
  }

  function pa(a) {
    return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0
  }

  function qa() {
    return pa(this.year())
  }

  function ra(a, b, c, d, e, f, g) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var h = new Date(a, b, c, d, e, f, g);
    //the date constructor remaps years 0-99 to 1900-1999
    return 100 > a && a >= 0 && isFinite(h.getFullYear()) && h.setFullYear(a), h
  }

  function sa(a) {
    var b = new Date(Date.UTC.apply(null, arguments));
    //the Date.UTC function remaps years 0-99 to 1900-1999
    return 100 > a && a >= 0 && isFinite(b.getUTCFullYear()) && b.setUTCFullYear(a), b
  }
  // start-of-first-week - start-of-year
  function ta(a, b, c) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      d = 7 + b - c,
      // first-week day local weekday -- which local weekday is fwd
      e = (7 + sa(a, 0, d).getUTCDay() - b) % 7;
    return -e + d - 1
  }
  //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function ua(a, b, c, d, e) {
    var f, g, h = (7 + c - d) % 7,
      i = ta(a, d, e),
      j = 1 + 7 * (b - 1) + h + i;
    return 0 >= j ? (f = a - 1, g = oa(f) + j) : j > oa(a) ? (f = a + 1, g = j - oa(a)) : (f = a, g = j), {
      year: f,
      dayOfYear: g
    }
  }

  function va(a, b, c) {
    var d, e, f = ta(a.year(), b, c),
      g = Math.floor((a.dayOfYear() - f - 1) / 7) + 1;
    return 1 > g ? (e = a.year() - 1, d = g + wa(e, b, c)) : g > wa(a.year(), b, c) ? (d = g - wa(a.year(), b, c), e = a.year() + 1) : (e = a.year(), d = g), {
      week: d,
      year: e
    }
  }

  function wa(a, b, c) {
    var d = ta(a, b, c),
      e = ta(a + 1, b, c);
    return (oa(a) - d + e) / 7
  }
  // HELPERS
  // LOCALES
  function xa(a) {
    return va(a, this._week.dow, this._week.doy).week
  }

  function ya() {
    return this._week.dow
  }

  function za() {
    return this._week.doy
  }
  // MOMENTS
  function Aa(a) {
    var b = this.localeData().week(this);
    return null == a ? b : this.add(7 * (a - b), "d")
  }

  function Ba(a) {
    var b = va(this, 1, 4).week;
    return null == a ? b : this.add(7 * (a - b), "d")
  }
  // HELPERS
  function Ca(a, b) {
    return "string" != typeof a ? a : isNaN(a) ? (a = b.weekdaysParse(a), "number" == typeof a ? a : null) : parseInt(a, 10)
  }

  function Da(a, b) {
    return "string" == typeof a ? b.weekdaysParse(a) % 7 || 7 : isNaN(a) ? null : a
  }

  function Ea(a, b) {
    return c(this._weekdays) ? this._weekdays[a.day()] : this._weekdays[this._weekdays.isFormat.test(b) ? "format" : "standalone"][a.day()]
  }

  function Fa(a) {
    return this._weekdaysShort[a.day()]
  }

  function Ga(a) {
    return this._weekdaysMin[a.day()]
  }

  function Ha(a, b, c) {
    var d, e, f, g = a.toLocaleLowerCase();
    if (!this._weekdaysParse)
      for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], d = 0; 7 > d; ++d) f = j([2e3, 1]).day(d), this._minWeekdaysParse[d] = this.weekdaysMin(f, "").toLocaleLowerCase(), this._shortWeekdaysParse[d] = this.weekdaysShort(f, "").toLocaleLowerCase(), this._weekdaysParse[d] = this.weekdays(f, "").toLocaleLowerCase();
    return c ? "dddd" === b ? (e = sd.call(this._weekdaysParse, g), -1 !== e ? e : null) : "ddd" === b ? (e = sd.call(this._shortWeekdaysParse, g), -1 !== e ? e : null) : (e = sd.call(this._minWeekdaysParse, g), -1 !== e ? e : null) : "dddd" === b ? (e = sd.call(this._weekdaysParse, g), -1 !== e ? e : (e = sd.call(this._shortWeekdaysParse, g), -1 !== e ? e : (e = sd.call(this._minWeekdaysParse, g), -1 !== e ? e : null))) : "ddd" === b ? (e = sd.call(this._shortWeekdaysParse, g), -1 !== e ? e : (e = sd.call(this._weekdaysParse, g), -1 !== e ? e : (e = sd.call(this._minWeekdaysParse, g), -1 !== e ? e : null))) : (e = sd.call(this._minWeekdaysParse, g), -1 !== e ? e : (e = sd.call(this._weekdaysParse, g), -1 !== e ? e : (e = sd.call(this._shortWeekdaysParse, g), -1 !== e ? e : null)))
  }

  function Ia(a, b, c) {
    var d, e, f;
    if (this._weekdaysParseExact) return Ha.call(this, a, b, c);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), d = 0; 7 > d; d++) {
      // test the regex
      if (e = j([2e3, 1]).day(d), c && !this._fullWeekdaysParse[d] && (this._fullWeekdaysParse[d] = new RegExp("^" + this.weekdays(e, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[d] = new RegExp("^" + this.weekdaysShort(e, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[d] = new RegExp("^" + this.weekdaysMin(e, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[d] || (f = "^" + this.weekdays(e, "") + "|^" + this.weekdaysShort(e, "") + "|^" + this.weekdaysMin(e, ""), this._weekdaysParse[d] = new RegExp(f.replace(".", ""), "i")), c && "dddd" === b && this._fullWeekdaysParse[d].test(a)) return d;
      if (c && "ddd" === b && this._shortWeekdaysParse[d].test(a)) return d;
      if (c && "dd" === b && this._minWeekdaysParse[d].test(a)) return d;
      if (!c && this._weekdaysParse[d].test(a)) return d
    }
  }
  // MOMENTS
  function Ja(a) {
    if (!this.isValid()) return null != a ? this : NaN;
    var b = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return null != a ? (a = Ca(a, this.localeData()), this.add(a - b, "d")) : b
  }

  function Ka(a) {
    if (!this.isValid()) return null != a ? this : NaN;
    var b = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return null == a ? b : this.add(a - b, "d")
  }

  function La(a) {
    if (!this.isValid()) return null != a ? this : NaN;
    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.
    if (null != a) {
      var b = Da(a, this.localeData());
      return this.day(this.day() % 7 ? b : b - 7)
    }
    return this.day() || 7
  }

  function Ma(a) {
    return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Pa.call(this), a ? this._weekdaysStrictRegex : this._weekdaysRegex) : (h(this, "_weekdaysRegex") || (this._weekdaysRegex = pe), this._weekdaysStrictRegex && a ? this._weekdaysStrictRegex : this._weekdaysRegex)
  }

  function Na(a) {
    return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Pa.call(this), a ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (h(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = qe), this._weekdaysShortStrictRegex && a ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
  }

  function Oa(a) {
    return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Pa.call(this), a ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (h(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = re), this._weekdaysMinStrictRegex && a ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
  }

  function Pa() {
    function a(a, b) {
      return b.length - a.length
    }
    var b, c, d, e, f, g = [],
      h = [],
      i = [],
      k = [];
    for (b = 0; 7 > b; b++) c = j([2e3, 1]).day(b), d = this.weekdaysMin(c, ""), e = this.weekdaysShort(c, ""), f = this.weekdays(c, ""), g.push(d), h.push(e), i.push(f), k.push(d), k.push(e), k.push(f);
    for (
      // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.
      g.sort(a), h.sort(a), i.sort(a), k.sort(a), b = 0; 7 > b; b++) h[b] = _(h[b]), i[b] = _(i[b]), k[b] = _(k[b]);
    this._weekdaysRegex = new RegExp("^(" + k.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + g.join("|") + ")", "i")
  }
  // FORMATTING
  function Qa() {
    return this.hours() % 12 || 12
  }

  function Ra() {
    return this.hours() || 24
  }

  function Sa(a, b) {
    T(a, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), b)
    })
  }
  // PARSING
  function Ta(a, b) {
    return b._meridiemParse
  }
  // LOCALES
  function Ua(a) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return "p" === (a + "").toLowerCase().charAt(0)
  }

  function Va(a, b, c) {
    return a > 11 ? c ? "pm" : "PM" : c ? "am" : "AM"
  }

  function Wa(a) {
    return a ? a.toLowerCase().replace("_", "-") : a
  }
  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function Xa(a) {
    for (var b, c, d, e, f = 0; f < a.length;) {
      for (e = Wa(a[f]).split("-"), b = e.length, c = Wa(a[f + 1]), c = c ? c.split("-") : null; b > 0;) {
        if (d = Ya(e.slice(0, b).join("-"))) return d;
        if (c && c.length >= b && u(e, c, !0) >= b - 1)
          //the next array item is better than a shallower substring of this one
          break;
        b--
      }
      f++
    }
    return null
  }

  function Ya(a) {
    var b = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!we[a] && "undefined" != typeof module && module && module.exports) try {
      b = se._abbr, require("./locale/" + a),
        // because defineLocale currently also sets the global locale, we
        // want to undo that for lazy loaded locales
        Za(b)
    } catch (c) {}
    return we[a]
  }
  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function Za(a, b) {
    var c;
    // moment.duration._locale = moment._locale = data;
    return a && (c = o(b) ? ab(a) : $a(a, b), c && (se = c)), se._abbr
  }

  function $a(a, b) {
    if (null !== b) {
      var c = ve;
      // treat as if there is no base config
      // backwards compat for now: also set the locale
      return b.abbr = a, null != we[a] ? (x("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), c = we[a]._config) : null != b.parentLocale && (null != we[b.parentLocale] ? c = we[b.parentLocale]._config : x("parentLocaleUndefined", "specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/")), we[a] = new B(A(c, b)), Za(a), we[a]
    }
    // useful for testing
    return delete we[a], null
  }

  function _a(a, b) {
    if (null != b) {
      var c, d = ve;
      // MERGE
      null != we[a] && (d = we[a]._config), b = A(d, b), c = new B(b), c.parentLocale = we[a], we[a] = c,
        // backwards compat for now: also set the locale
        Za(a)
    } else
      // pass null for config to unupdate, useful for tests
      null != we[a] && (null != we[a].parentLocale ? we[a] = we[a].parentLocale : null != we[a] && delete we[a]);
    return we[a]
  }
  // returns locale data
  function ab(a) {
    var b;
    if (a && a._locale && a._locale._abbr && (a = a._locale._abbr), !a) return se;
    if (!c(a)) {
      if (b = Ya(a)) return b;
      a = [a]
    }
    return Xa(a)
  }

  function bb() {
    return rd(we)
  }

  function cb(a) {
    var b, c = a._a;
    return c && -2 === l(a).overflow && (b = c[Zd] < 0 || c[Zd] > 11 ? Zd : c[$d] < 1 || c[$d] > da(c[Yd], c[Zd]) ? $d : c[_d] < 0 || c[_d] > 24 || 24 === c[_d] && (0 !== c[ae] || 0 !== c[be] || 0 !== c[ce]) ? _d : c[ae] < 0 || c[ae] > 59 ? ae : c[be] < 0 || c[be] > 59 ? be : c[ce] < 0 || c[ce] > 999 ? ce : -1, l(a)._overflowDayOfYear && (Yd > b || b > $d) && (b = $d), l(a)._overflowWeeks && -1 === b && (b = de), l(a)._overflowWeekday && -1 === b && (b = ee), l(a).overflow = b), a
  }
  // date from iso format
  function db(a) {
    var b, c, d, e, f, g, h = a._i,
      i = xe.exec(h) || ye.exec(h);
    if (i) {
      for (l(a).iso = !0, b = 0, c = Ae.length; c > b; b++)
        if (Ae[b][1].exec(i[1])) {
          e = Ae[b][0], d = Ae[b][2] !== !1;
          break
        }
      if (null == e) return void(a._isValid = !1);
      if (i[3]) {
        for (b = 0, c = Be.length; c > b; b++)
          if (Be[b][1].exec(i[3])) {
            // match[2] should be 'T' or space
            f = (i[2] || " ") + Be[b][0];
            break
          }
        if (null == f) return void(a._isValid = !1)
      }
      if (!d && null != f) return void(a._isValid = !1);
      if (i[4]) {
        if (!ze.exec(i[4])) return void(a._isValid = !1);
        g = "Z"
      }
      a._f = e + (f || "") + (g || ""), jb(a)
    } else a._isValid = !1
  }
  // date from iso format or fallback
  function eb(b) {
    var c = Ce.exec(b._i);
    return null !== c ? void(b._d = new Date(+c[1])) : (db(b), void(b._isValid === !1 && (delete b._isValid, a.createFromInputFallback(b))))
  }
  // Pick the first defined of two or three arguments.
  function fb(a, b, c) {
    return null != a ? a : null != b ? b : c
  }

  function gb(b) {
    // hooks is actually the exported moment object
    var c = new Date(a.now());
    return b._useUTC ? [c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()] : [c.getFullYear(), c.getMonth(), c.getDate()]
  }
  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function hb(a) {
    var b, c, d, e, f = [];
    if (!a._d) {
      // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything
      for (d = gb(a), a._w && null == a._a[$d] && null == a._a[Zd] && ib(a), a._dayOfYear && (e = fb(a._a[Yd], d[Yd]), a._dayOfYear > oa(e) && (l(a)._overflowDayOfYear = !0), c = sa(e, 0, a._dayOfYear), a._a[Zd] = c.getUTCMonth(), a._a[$d] = c.getUTCDate()), b = 0; 3 > b && null == a._a[b]; ++b) a._a[b] = f[b] = d[b];
      // Zero out whatever was not defaulted, including time
      for (; 7 > b; b++) a._a[b] = f[b] = null == a._a[b] ? 2 === b ? 1 : 0 : a._a[b];
      // Check for 24:00:00.000
      24 === a._a[_d] && 0 === a._a[ae] && 0 === a._a[be] && 0 === a._a[ce] && (a._nextDay = !0, a._a[_d] = 0), a._d = (a._useUTC ? sa : ra).apply(null, f),
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        null != a._tzm && a._d.setUTCMinutes(a._d.getUTCMinutes() - a._tzm), a._nextDay && (a._a[_d] = 24)
    }
  }

  function ib(a) {
    var b, c, d, e, f, g, h, i;
    b = a._w, null != b.GG || null != b.W || null != b.E ? (f = 1, g = 4, c = fb(b.GG, a._a[Yd], va(rb(), 1, 4).year), d = fb(b.W, 1), e = fb(b.E, 1), (1 > e || e > 7) && (i = !0)) : (f = a._locale._week.dow, g = a._locale._week.doy, c = fb(b.gg, a._a[Yd], va(rb(), f, g).year), d = fb(b.w, 1), null != b.d ? (e = b.d, (0 > e || e > 6) && (i = !0)) : null != b.e ? (e = b.e + f, (b.e < 0 || b.e > 6) && (i = !0)) : e = f), 1 > d || d > wa(c, f, g) ? l(a)._overflowWeeks = !0 : null != i ? l(a)._overflowWeekday = !0 : (h = ua(c, d, e, f, g), a._a[Yd] = h.year, a._dayOfYear = h.dayOfYear)
  }
  // date from string and format string
  function jb(b) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (b._f === a.ISO_8601) return void db(b);
    b._a = [], l(b).empty = !0;
    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var c, d, e, f, g, h = "" + b._i,
      i = h.length,
      j = 0;
    for (e = X(b._f, b._locale).match(Bd) || [], c = 0; c < e.length; c++) f = e[c], d = (h.match(Z(f, b)) || [])[0], d && (g = h.substr(0, h.indexOf(d)), g.length > 0 && l(b).unusedInput.push(g), h = h.slice(h.indexOf(d) + d.length), j += d.length), Ed[f] ? (d ? l(b).empty = !1 : l(b).unusedTokens.push(f), ca(f, d, b)) : b._strict && !d && l(b).unusedTokens.push(f);
    // add remaining unparsed input length to the string
    l(b).charsLeftOver = i - j, h.length > 0 && l(b).unusedInput.push(h),
      // clear _12h flag if hour is <= 12
      b._a[_d] <= 12 && l(b).bigHour === !0 && b._a[_d] > 0 && (l(b).bigHour = void 0), l(b).parsedDateParts = b._a.slice(0), l(b).meridiem = b._meridiem,
      // handle meridiem
      b._a[_d] = kb(b._locale, b._a[_d], b._meridiem), hb(b), cb(b)
  }

  function kb(a, b, c) {
    var d;
    // Fallback
    return null == c ? b : null != a.meridiemHour ? a.meridiemHour(b, c) : null != a.isPM ? (d = a.isPM(c), d && 12 > b && (b += 12), d || 12 !== b || (b = 0), b) : b
  }
  // date from string and array of format strings
  function lb(a) {
    var b, c, d, e, f;
    if (0 === a._f.length) return l(a).invalidFormat = !0, void(a._d = new Date(NaN));
    for (e = 0; e < a._f.length; e++) f = 0, b = p({}, a), null != a._useUTC && (b._useUTC = a._useUTC), b._f = a._f[e], jb(b), m(b) && (f += l(b).charsLeftOver, f += 10 * l(b).unusedTokens.length, l(b).score = f, (null == d || d > f) && (d = f, c = b));
    i(a, c || b)
  }

  function mb(a) {
    if (!a._d) {
      var b = K(a._i);
      a._a = g([b.year, b.month, b.day || b.date, b.hour, b.minute, b.second, b.millisecond], function(a) {
        return a && parseInt(a, 10)
      }), hb(a)
    }
  }

  function nb(a) {
    var b = new q(cb(ob(a)));
    // Adding is smart enough around DST
    return b._nextDay && (b.add(1, "d"), b._nextDay = void 0), b
  }

  function ob(a) {
    var b = a._i,
      d = a._f;
    return a._locale = a._locale || ab(a._l), null === b || void 0 === d && "" === b ? n({
      nullInput: !0
    }) : ("string" == typeof b && (a._i = b = a._locale.preparse(b)), r(b) ? new q(cb(b)) : (c(d) ? lb(a) : f(b) ? a._d = b : d ? jb(a) : pb(a), m(a) || (a._d = null), a))
  }

  function pb(b) {
    var d = b._i;
    void 0 === d ? b._d = new Date(a.now()) : f(d) ? b._d = new Date(d.valueOf()) : "string" == typeof d ? eb(b) : c(d) ? (b._a = g(d.slice(0), function(a) {
        return parseInt(a, 10)
      }), hb(b)) : "object" == typeof d ? mb(b) : "number" == typeof d ?
      // from milliseconds
      b._d = new Date(d) : a.createFromInputFallback(b)
  }

  function qb(a, b, f, g, h) {
    var i = {};
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    return "boolean" == typeof f && (g = f, f = void 0), (d(a) && e(a) || c(a) && 0 === a.length) && (a = void 0), i._isAMomentObject = !0, i._useUTC = i._isUTC = h, i._l = f, i._i = a, i._f = b, i._strict = g, nb(i)
  }

  function rb(a, b, c, d) {
    return qb(a, b, c, d, !1)
  }
  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function sb(a, b) {
    var d, e;
    if (1 === b.length && c(b[0]) && (b = b[0]), !b.length) return rb();
    for (d = b[0], e = 1; e < b.length; ++e) b[e].isValid() && !b[e][a](d) || (d = b[e]);
    return d
  }
  // TODO: Use [].sort instead?
  function tb() {
    var a = [].slice.call(arguments, 0);
    return sb("isBefore", a)
  }

  function ub() {
    var a = [].slice.call(arguments, 0);
    return sb("isAfter", a)
  }

  function vb(a) {
    var b = K(a),
      c = b.year || 0,
      d = b.quarter || 0,
      e = b.month || 0,
      f = b.week || 0,
      g = b.day || 0,
      h = b.hour || 0,
      i = b.minute || 0,
      j = b.second || 0,
      k = b.millisecond || 0;
    // representation for dateAddRemove
    this._milliseconds = +k + 1e3 * j + // 1000
      6e4 * i + // 1000 * 60
      1e3 * h * 60 * 60, //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately
      this._days = +g + 7 * f,
      // It is impossible translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.
      this._months = +e + 3 * d + 12 * c, this._data = {}, this._locale = ab(), this._bubble()
  }

  function wb(a) {
    return a instanceof vb
  }
  // FORMATTING
  function xb(a, b) {
    T(a, 0, 0, function() {
      var a = this.utcOffset(),
        c = "+";
      return 0 > a && (a = -a, c = "-"), c + S(~~(a / 60), 2) + b + S(~~a % 60, 2)
    })
  }

  function yb(a, b) {
    var c = (b || "").match(a) || [],
      d = c[c.length - 1] || [],
      e = (d + "").match(Ge) || ["-", 0, 0],
      f = +(60 * e[1]) + t(e[2]);
    return "+" === e[0] ? f : -f
  }
  // Return a moment from input, that is local/utc/zone equivalent to model.
  function zb(b, c) {
    var d, e;
    // Use low-level api, because this fn is low-level api.
    return c._isUTC ? (d = c.clone(), e = (r(b) || f(b) ? b.valueOf() : rb(b).valueOf()) - d.valueOf(), d._d.setTime(d._d.valueOf() + e), a.updateOffset(d, !1), d) : rb(b).local()
  }

  function Ab(a) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return 15 * -Math.round(a._d.getTimezoneOffset() / 15)
  }
  // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function Bb(b, c) {
    var d, e = this._offset || 0;
    return this.isValid() ? null != b ? ("string" == typeof b ? b = yb(Td, b) : Math.abs(b) < 16 && (b = 60 * b), !this._isUTC && c && (d = Ab(this)), this._offset = b, this._isUTC = !0, null != d && this.add(d, "m"), e !== b && (!c || this._changeInProgress ? Sb(this, Mb(b - e, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, a.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? e : Ab(this) : null != b ? this : NaN
  }

  function Cb(a, b) {
    return null != a ? ("string" != typeof a && (a = -a), this.utcOffset(a, b), this) : -this.utcOffset()
  }

  function Db(a) {
    return this.utcOffset(0, a)
  }

  function Eb(a) {
    return this._isUTC && (this.utcOffset(0, a), this._isUTC = !1, a && this.subtract(Ab(this), "m")), this
  }

  function Fb() {
    return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(yb(Sd, this._i)), this
  }

  function Gb(a) {
    return this.isValid() ? (a = a ? rb(a).utcOffset() : 0, (this.utcOffset() - a) % 60 === 0) : !1
  }

  function Hb() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
  }

  function Ib() {
    if (!o(this._isDSTShifted)) return this._isDSTShifted;
    var a = {};
    if (p(a, this), a = ob(a), a._a) {
      var b = a._isUTC ? j(a._a) : rb(a._a);
      this._isDSTShifted = this.isValid() && u(a._a, b.toArray()) > 0
    } else this._isDSTShifted = !1;
    return this._isDSTShifted
  }

  function Jb() {
    return this.isValid() ? !this._isUTC : !1
  }

  function Kb() {
    return this.isValid() ? this._isUTC : !1
  }

  function Lb() {
    return this.isValid() ? this._isUTC && 0 === this._offset : !1
  }

  function Mb(a, b) {
    var c, d, e, f = a,
      // matching against regexp is expensive, do it on demand
      g = null; // checks for null or undefined
    return wb(a) ? f = {
      ms: a._milliseconds,
      d: a._days,
      M: a._months
    } : "number" == typeof a ? (f = {}, b ? f[b] = a : f.milliseconds = a) : (g = He.exec(a)) ? (c = "-" === g[1] ? -1 : 1, f = {
      y: 0,
      d: t(g[$d]) * c,
      h: t(g[_d]) * c,
      m: t(g[ae]) * c,
      s: t(g[be]) * c,
      ms: t(g[ce]) * c
    }) : (g = Ie.exec(a)) ? (c = "-" === g[1] ? -1 : 1, f = {
      y: Nb(g[2], c),
      M: Nb(g[3], c),
      w: Nb(g[4], c),
      d: Nb(g[5], c),
      h: Nb(g[6], c),
      m: Nb(g[7], c),
      s: Nb(g[8], c)
    }) : null == f ? f = {} : "object" == typeof f && ("from" in f || "to" in f) && (e = Pb(rb(f.from), rb(f.to)), f = {}, f.ms = e.milliseconds, f.M = e.months), d = new vb(f), wb(a) && h(a, "_locale") && (d._locale = a._locale), d
  }

  function Nb(a, b) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var c = a && parseFloat(a.replace(",", "."));
    // apply sign while we're at it
    return (isNaN(c) ? 0 : c) * b
  }

  function Ob(a, b) {
    var c = {
      milliseconds: 0,
      months: 0
    };
    return c.months = b.month() - a.month() + 12 * (b.year() - a.year()), a.clone().add(c.months, "M").isAfter(b) && --c.months, c.milliseconds = +b - +a.clone().add(c.months, "M"), c
  }

  function Pb(a, b) {
    var c;
    return a.isValid() && b.isValid() ? (b = zb(b, a), a.isBefore(b) ? c = Ob(a, b) : (c = Ob(b, a), c.milliseconds = -c.milliseconds, c.months = -c.months), c) : {
      milliseconds: 0,
      months: 0
    }
  }

  function Qb(a) {
    return 0 > a ? -1 * Math.round(-1 * a) : Math.round(a)
  }
  // TODO: remove 'name' arg after deprecation is removed
  function Rb(a, b) {
    return function(c, d) {
      var e, f;
      //invert the arguments, but complain about it
      return null === d || isNaN(+d) || (x(b, "moment()." + b + "(period, number) is deprecated. Please use moment()." + b + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), f = c, c = d, d = f), c = "string" == typeof c ? +c : c, e = Mb(c, d), Sb(this, e, a), this
    }
  }

  function Sb(b, c, d, e) {
    var f = c._milliseconds,
      g = Qb(c._days),
      h = Qb(c._months);
    b.isValid() && (e = null == e ? !0 : e, f && b._d.setTime(b._d.valueOf() + f * d), g && P(b, "Date", O(b, "Date") + g * d), h && ia(b, O(b, "Month") + h * d), e && a.updateOffset(b, g || h))
  }

  function Tb(a, b) {
    var c = a.diff(b, "days", !0);
    return -6 > c ? "sameElse" : -1 > c ? "lastWeek" : 0 > c ? "lastDay" : 1 > c ? "sameDay" : 2 > c ? "nextDay" : 7 > c ? "nextWeek" : "sameElse"
  }

  function Ub(b, c) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var d = b || rb(),
      e = zb(d, this).startOf("day"),
      f = a.calendarFormat(this, e) || "sameElse",
      g = c && (y(c[f]) ? c[f].call(this, d) : c[f]);
    return this.format(g || this.localeData().calendar(f, this, rb(d)))
  }

  function Vb() {
    return new q(this)
  }

  function Wb(a, b) {
    var c = r(a) ? a : rb(a);
    return this.isValid() && c.isValid() ? (b = J(o(b) ? "millisecond" : b), "millisecond" === b ? this.valueOf() > c.valueOf() : c.valueOf() < this.clone().startOf(b).valueOf()) : !1
  }

  function Xb(a, b) {
    var c = r(a) ? a : rb(a);
    return this.isValid() && c.isValid() ? (b = J(o(b) ? "millisecond" : b), "millisecond" === b ? this.valueOf() < c.valueOf() : this.clone().endOf(b).valueOf() < c.valueOf()) : !1
  }

  function Yb(a, b, c, d) {
    return d = d || "()", ("(" === d[0] ? this.isAfter(a, c) : !this.isBefore(a, c)) && (")" === d[1] ? this.isBefore(b, c) : !this.isAfter(b, c))
  }

  function Zb(a, b) {
    var c, d = r(a) ? a : rb(a);
    return this.isValid() && d.isValid() ? (b = J(b || "millisecond"), "millisecond" === b ? this.valueOf() === d.valueOf() : (c = d.valueOf(), this.clone().startOf(b).valueOf() <= c && c <= this.clone().endOf(b).valueOf())) : !1
  }

  function $b(a, b) {
    return this.isSame(a, b) || this.isAfter(a, b)
  }

  function _b(a, b) {
    return this.isSame(a, b) || this.isBefore(a, b)
  }

  function ac(a, b, c) {
    var d, e, f, g; // 1000
    // 1000 * 60
    // 1000 * 60 * 60
    // 1000 * 60 * 60 * 24, negate dst
    // 1000 * 60 * 60 * 24 * 7, negate dst
    return this.isValid() ? (d = zb(a, this), d.isValid() ? (e = 6e4 * (d.utcOffset() - this.utcOffset()), b = J(b), "year" === b || "month" === b || "quarter" === b ? (g = bc(this, d), "quarter" === b ? g /= 3 : "year" === b && (g /= 12)) : (f = this - d, g = "second" === b ? f / 1e3 : "minute" === b ? f / 6e4 : "hour" === b ? f / 36e5 : "day" === b ? (f - e) / 864e5 : "week" === b ? (f - e) / 6048e5 : f), c ? g : s(g)) : NaN) : NaN
  }

  function bc(a, b) {
    // difference in months
    var c, d, e = 12 * (b.year() - a.year()) + (b.month() - a.month()),
      // b is in (anchor - 1 month, anchor + 1 month)
      f = a.clone().add(e, "months");
    //check for negative zero, return zero if negative zero
    // linear across the month
    // linear across the month
    return 0 > b - f ? (c = a.clone().add(e - 1, "months"), d = (b - f) / (f - c)) : (c = a.clone().add(e + 1, "months"), d = (b - f) / (c - f)), -(e + d) || 0
  }

  function cc() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
  }

  function dc() {
    var a = this.clone().utc();
    return 0 < a.year() && a.year() <= 9999 ? y(Date.prototype.toISOString) ? this.toDate().toISOString() : W(a, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : W(a, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
  }

  function ec(b) {
    b || (b = this.isUtc() ? a.defaultFormatUtc : a.defaultFormat);
    var c = W(this, b);
    return this.localeData().postformat(c)
  }

  function fc(a, b) {
    return this.isValid() && (r(a) && a.isValid() || rb(a).isValid()) ? Mb({
      to: this,
      from: a
    }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate()
  }

  function gc(a) {
    return this.from(rb(), a)
  }

  function hc(a, b) {
    return this.isValid() && (r(a) && a.isValid() || rb(a).isValid()) ? Mb({
      from: this,
      to: a
    }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate()
  }

  function ic(a) {
    return this.to(rb(), a)
  }
  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function jc(a) {
    var b;
    return void 0 === a ? this._locale._abbr : (b = ab(a), null != b && (this._locale = b), this)
  }

  function kc() {
    return this._locale
  }

  function lc(a) {
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (a = J(a)) {
      case "year":
        this.month(0); /* falls through */
      case "quarter":
      case "month":
        this.date(1); /* falls through */
      case "week":
      case "isoWeek":
      case "day":
      case "date":
        this.hours(0); /* falls through */
      case "hour":
        this.minutes(0); /* falls through */
      case "minute":
        this.seconds(0); /* falls through */
      case "second":
        this.milliseconds(0)
    }
    // weeks are a special case
    // quarters are also special
    return "week" === a && this.weekday(0), "isoWeek" === a && this.isoWeekday(1), "quarter" === a && this.month(3 * Math.floor(this.month() / 3)), this
  }

  function mc(a) {
    // 'date' is an alias for 'day', so it should be considered as such.
    return a = J(a), void 0 === a || "millisecond" === a ? this : ("date" === a && (a = "day"), this.startOf(a).add(1, "isoWeek" === a ? "week" : a).subtract(1, "ms"))
  }

  function nc() {
    return this._d.valueOf() - 6e4 * (this._offset || 0)
  }

  function oc() {
    return Math.floor(this.valueOf() / 1e3)
  }

  function pc() {
    return new Date(this.valueOf())
  }

  function qc() {
    var a = this;
    return [a.year(), a.month(), a.date(), a.hour(), a.minute(), a.second(), a.millisecond()]
  }

  function rc() {
    var a = this;
    return {
      years: a.year(),
      months: a.month(),
      date: a.date(),
      hours: a.hours(),
      minutes: a.minutes(),
      seconds: a.seconds(),
      milliseconds: a.milliseconds()
    }
  }

  function sc() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null
  }

  function tc() {
    return m(this)
  }

  function uc() {
    return i({}, l(this))
  }

  function vc() {
    return l(this).overflow
  }

  function wc() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    }
  }

  function xc(a, b) {
    T(0, [a, a.length], 0, b)
  }
  // MOMENTS
  function yc(a) {
    return Cc.call(this, a, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
  }

  function zc(a) {
    return Cc.call(this, a, this.isoWeek(), this.isoWeekday(), 1, 4)
  }

  function Ac() {
    return wa(this.year(), 1, 4)
  }

  function Bc() {
    var a = this.localeData()._week;
    return wa(this.year(), a.dow, a.doy)
  }

  function Cc(a, b, c, d, e) {
    var f;
    return null == a ? va(this, d, e).year : (f = wa(a, d, e), b > f && (b = f), Dc.call(this, a, b, c, d, e))
  }

  function Dc(a, b, c, d, e) {
    var f = ua(a, b, c, d, e),
      g = sa(f.year, 0, f.dayOfYear);
    return this.year(g.getUTCFullYear()), this.month(g.getUTCMonth()), this.date(g.getUTCDate()), this
  }
  // MOMENTS
  function Ec(a) {
    return null == a ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (a - 1) + this.month() % 3)
  }
  // HELPERS
  // MOMENTS
  function Fc(a) {
    var b = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return null == a ? b : this.add(a - b, "d")
  }

  function Gc(a, b) {
    b[ce] = t(1e3 * ("0." + a))
  }
  // MOMENTS
  function Hc() {
    return this._isUTC ? "UTC" : ""
  }

  function Ic() {
    return this._isUTC ? "Coordinated Universal Time" : ""
  }

  function Jc(a) {
    return rb(1e3 * a)
  }

  function Kc() {
    return rb.apply(null, arguments).parseZone()
  }

  function Lc(a) {
    return a
  }

  function Mc(a, b, c, d) {
    var e = ab(),
      f = j().set(d, b);
    return e[c](f, a)
  }

  function Nc(a, b, c) {
    if ("number" == typeof a && (b = a, a = void 0), a = a || "", null != b) return Mc(a, b, c, "month");
    var d, e = [];
    for (d = 0; 12 > d; d++) e[d] = Mc(a, d, c, "month");
    return e
  }
  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function Oc(a, b, c, d) {
    "boolean" == typeof a ? ("number" == typeof b && (c = b, b = void 0), b = b || "") : (b = a, c = b, a = !1, "number" == typeof b && (c = b, b = void 0), b = b || "");
    var e = ab(),
      f = a ? e._week.dow : 0;
    if (null != c) return Mc(b, (c + f) % 7, d, "day");
    var g, h = [];
    for (g = 0; 7 > g; g++) h[g] = Mc(b, (g + f) % 7, d, "day");
    return h
  }

  function Pc(a, b) {
    return Nc(a, b, "months")
  }

  function Qc(a, b) {
    return Nc(a, b, "monthsShort")
  }

  function Rc(a, b, c) {
    return Oc(a, b, c, "weekdays")
  }

  function Sc(a, b, c) {
    return Oc(a, b, c, "weekdaysShort")
  }

  function Tc(a, b, c) {
    return Oc(a, b, c, "weekdaysMin")
  }

  function Uc() {
    var a = this._data;
    return this._milliseconds = Ue(this._milliseconds), this._days = Ue(this._days), this._months = Ue(this._months), a.milliseconds = Ue(a.milliseconds), a.seconds = Ue(a.seconds), a.minutes = Ue(a.minutes), a.hours = Ue(a.hours), a.months = Ue(a.months), a.years = Ue(a.years), this
  }

  function Vc(a, b, c, d) {
    var e = Mb(b, c);
    return a._milliseconds += d * e._milliseconds, a._days += d * e._days, a._months += d * e._months, a._bubble()
  }
  // supports only 2.0-style add(1, 's') or add(duration)
  function Wc(a, b) {
    return Vc(this, a, b, 1)
  }
  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function Xc(a, b) {
    return Vc(this, a, b, -1)
  }

  function Yc(a) {
    return 0 > a ? Math.floor(a) : Math.ceil(a)
  }

  function Zc() {
    var a, b, c, d, e, f = this._milliseconds,
      g = this._days,
      h = this._months,
      i = this._data;
    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    // The following code bubbles up values, see the tests for
    // examples of what that means.
    // convert days to months
    // 12 months -> 1 year
    return f >= 0 && g >= 0 && h >= 0 || 0 >= f && 0 >= g && 0 >= h || (f += 864e5 * Yc(_c(h) + g), g = 0, h = 0), i.milliseconds = f % 1e3, a = s(f / 1e3), i.seconds = a % 60, b = s(a / 60), i.minutes = b % 60, c = s(b / 60), i.hours = c % 24, g += s(c / 24), e = s($c(g)), h += e, g -= Yc(_c(e)), d = s(h / 12), h %= 12, i.days = g, i.months = h, i.years = d, this
  }

  function $c(a) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return 4800 * a / 146097
  }

  function _c(a) {
    // the reverse of daysToMonths
    return 146097 * a / 4800
  }

  function ad(a) {
    var b, c, d = this._milliseconds;
    if (a = J(a), "month" === a || "year" === a) return b = this._days + d / 864e5, c = this._months + $c(b), "month" === a ? c : c / 12;
    switch (b = this._days + Math.round(_c(this._months)), a) {
      case "week":
        return b / 7 + d / 6048e5;
      case "day":
        return b + d / 864e5;
      case "hour":
        return 24 * b + d / 36e5;
      case "minute":
        return 1440 * b + d / 6e4;
      case "second":
        return 86400 * b + d / 1e3;
        // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(864e5 * b) + d;
      default:
        throw new Error("Unknown unit " + a)
    }
  }
  // TODO: Use this.as('ms')?
  function bd() {
    return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * t(this._months / 12)
  }

  function cd(a) {
    return function() {
      return this.as(a)
    }
  }

  function dd(a) {
    return a = J(a), this[a + "s"]()
  }

  function ed(a) {
    return function() {
      return this._data[a]
    }
  }

  function fd() {
    return s(this.days() / 7)
  }
  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function gd(a, b, c, d, e) {
    return e.relativeTime(b || 1, !!c, a, d)
  }

  function hd(a, b, c) {
    var d = Mb(a).abs(),
      e = jf(d.as("s")),
      f = jf(d.as("m")),
      g = jf(d.as("h")),
      h = jf(d.as("d")),
      i = jf(d.as("M")),
      j = jf(d.as("y")),
      k = e < kf.s && ["s", e] || 1 >= f && ["m"] || f < kf.m && ["mm", f] || 1 >= g && ["h"] || g < kf.h && ["hh", g] || 1 >= h && ["d"] || h < kf.d && ["dd", h] || 1 >= i && ["M"] || i < kf.M && ["MM", i] || 1 >= j && ["y"] || ["yy", j];
    return k[2] = b, k[3] = +a > 0, k[4] = c, gd.apply(null, k)
  }
  // This function allows you to set the rounding function for relative time strings
  function id(a) {
    return void 0 === a ? jf : "function" == typeof a ? (jf = a, !0) : !1
  }
  // This function allows you to set a threshold for relative time strings
  function jd(a, b) {
    return void 0 === kf[a] ? !1 : void 0 === b ? kf[a] : (kf[a] = b, !0)
  }

  function kd(a) {
    var b = this.localeData(),
      c = hd(this, !a, b);
    return a && (c = b.pastFuture(+this, c)), b.postformat(c)
  }

  function ld() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    var a, b, c, d = lf(this._milliseconds) / 1e3,
      e = lf(this._days),
      f = lf(this._months);
    a = s(d / 60), b = s(a / 60), d %= 60, a %= 60, c = s(f / 12), f %= 12;
    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var g = c,
      h = f,
      i = e,
      j = b,
      k = a,
      l = d,
      m = this.asSeconds();
    return m ? (0 > m ? "-" : "") + "P" + (g ? g + "Y" : "") + (h ? h + "M" : "") + (i ? i + "D" : "") + (j || k || l ? "T" : "") + (j ? j + "H" : "") + (k ? k + "M" : "") + (l ? l + "S" : "") : "P0D"
  }
  var md, nd;
  nd = Array.prototype.some ? Array.prototype.some : function(a) {
    for (var b = Object(this), c = b.length >>> 0, d = 0; c > d; d++)
      if (d in b && a.call(this, b[d], d, b)) return !0;
    return !1
  };
  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var od = a.momentProperties = [],
    pd = !1,
    qd = {};
  a.suppressDeprecationWarnings = !1, a.deprecationHandler = null;
  var rd;
  rd = Object.keys ? Object.keys : function(a) {
    var b, c = [];
    for (b in a) h(a, b) && c.push(b);
    return c
  };
  var sd, td = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    },
    ud = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    },
    vd = "Invalid date",
    wd = "%d",
    xd = /\d{1,2}/,
    yd = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    },
    zd = {},
    Ad = {},
    Bd = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    Cd = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    Dd = {},
    Ed = {},
    Fd = /\d/,
    Gd = /\d\d/,
    Hd = /\d{3}/,
    Id = /\d{4}/,
    Jd = /[+-]?\d{6}/,
    Kd = /\d\d?/,
    Ld = /\d\d\d\d?/,
    Md = /\d\d\d\d\d\d?/,
    Nd = /\d{1,3}/,
    Od = /\d{1,4}/,
    Pd = /[+-]?\d{1,6}/,
    Qd = /\d+/,
    Rd = /[+-]?\d+/,
    Sd = /Z|[+-]\d\d:?\d\d/gi,
    Td = /Z|[+-]\d\d(?::?\d\d)?/gi,
    Ud = /[+-]?\d+(\.\d{1,3})?/,
    Vd = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
    Wd = {},
    Xd = {},
    Yd = 0,
    Zd = 1,
    $d = 2,
    _d = 3,
    ae = 4,
    be = 5,
    ce = 6,
    de = 7,
    ee = 8;
  sd = Array.prototype.indexOf ? Array.prototype.indexOf : function(a) {
    // I know
    var b;
    for (b = 0; b < this.length; ++b)
      if (this[b] === a) return b;
    return -1
  }, T("M", ["MM", 2], "Mo", function() {
    return this.month() + 1
  }), T("MMM", 0, 0, function(a) {
    return this.localeData().monthsShort(this, a)
  }), T("MMMM", 0, 0, function(a) {
    return this.localeData().months(this, a)
  }), I("month", "M"), L("month", 8), Y("M", Kd), Y("MM", Kd, Gd), Y("MMM", function(a, b) {
    return b.monthsShortRegex(a)
  }), Y("MMMM", function(a, b) {
    return b.monthsRegex(a)
  }), aa(["M", "MM"], function(a, b) {
    b[Zd] = t(a) - 1
  }), aa(["MMM", "MMMM"], function(a, b, c, d) {
    var e = c._locale.monthsParse(a, d, c._strict);
    null != e ? b[Zd] = e : l(c).invalidMonth = a
  });
  // LOCALES
  var fe = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/,
    ge = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    he = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    ie = Vd,
    je = Vd;
  // FORMATTING
  T("Y", 0, 0, function() {
      var a = this.year();
      return 9999 >= a ? "" + a : "+" + a
    }), T(0, ["YY", 2], 0, function() {
      return this.year() % 100
    }), T(0, ["YYYY", 4], 0, "year"), T(0, ["YYYYY", 5], 0, "year"), T(0, ["YYYYYY", 6, !0], 0, "year"),
    // ALIASES
    I("year", "y"),
    // PRIORITIES
    L("year", 1),
    // PARSING
    Y("Y", Rd), Y("YY", Kd, Gd), Y("YYYY", Od, Id), Y("YYYYY", Pd, Jd), Y("YYYYYY", Pd, Jd), aa(["YYYYY", "YYYYYY"], Yd), aa("YYYY", function(b, c) {
      c[Yd] = 2 === b.length ? a.parseTwoDigitYear(b) : t(b)
    }), aa("YY", function(b, c) {
      c[Yd] = a.parseTwoDigitYear(b)
    }), aa("Y", function(a, b) {
      b[Yd] = parseInt(a, 10)
    }),
    // HOOKS
    a.parseTwoDigitYear = function(a) {
      return t(a) + (t(a) > 68 ? 1900 : 2e3)
    };
  // MOMENTS
  var ke = N("FullYear", !0);
  // FORMATTING
  T("w", ["ww", 2], "wo", "week"), T("W", ["WW", 2], "Wo", "isoWeek"),
    // ALIASES
    I("week", "w"), I("isoWeek", "W"),
    // PRIORITIES
    L("week", 5), L("isoWeek", 5),
    // PARSING
    Y("w", Kd), Y("ww", Kd, Gd), Y("W", Kd), Y("WW", Kd, Gd), ba(["w", "ww", "W", "WW"], function(a, b, c, d) {
      b[d.substr(0, 1)] = t(a)
    });
  var le = {
    dow: 0, // Sunday is the first day of the week.
    doy: 6
  };
  // FORMATTING
  T("d", 0, "do", "day"), T("dd", 0, 0, function(a) {
      return this.localeData().weekdaysMin(this, a)
    }), T("ddd", 0, 0, function(a) {
      return this.localeData().weekdaysShort(this, a)
    }), T("dddd", 0, 0, function(a) {
      return this.localeData().weekdays(this, a)
    }), T("e", 0, 0, "weekday"), T("E", 0, 0, "isoWeekday"),
    // ALIASES
    I("day", "d"), I("weekday", "e"), I("isoWeekday", "E"),
    // PRIORITY
    L("day", 11), L("weekday", 11), L("isoWeekday", 11),
    // PARSING
    Y("d", Kd), Y("e", Kd), Y("E", Kd), Y("dd", function(a, b) {
      return b.weekdaysMinRegex(a)
    }), Y("ddd", function(a, b) {
      return b.weekdaysShortRegex(a)
    }), Y("dddd", function(a, b) {
      return b.weekdaysRegex(a)
    }), ba(["dd", "ddd", "dddd"], function(a, b, c, d) {
      var e = c._locale.weekdaysParse(a, d, c._strict);
      // if we didn't get a weekday name, mark the date as invalid
      null != e ? b.d = e : l(c).invalidWeekday = a
    }), ba(["d", "e", "E"], function(a, b, c, d) {
      b[d] = t(a)
    });
  // LOCALES
  var me = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    ne = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    oe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
    pe = Vd,
    qe = Vd,
    re = Vd;
  T("H", ["HH", 2], 0, "hour"), T("h", ["hh", 2], 0, Qa), T("k", ["kk", 2], 0, Ra), T("hmm", 0, 0, function() {
      return "" + Qa.apply(this) + S(this.minutes(), 2)
    }), T("hmmss", 0, 0, function() {
      return "" + Qa.apply(this) + S(this.minutes(), 2) + S(this.seconds(), 2)
    }), T("Hmm", 0, 0, function() {
      return "" + this.hours() + S(this.minutes(), 2)
    }), T("Hmmss", 0, 0, function() {
      return "" + this.hours() + S(this.minutes(), 2) + S(this.seconds(), 2)
    }), Sa("a", !0), Sa("A", !1),
    // ALIASES
    I("hour", "h"),
    // PRIORITY
    L("hour", 13), Y("a", Ta), Y("A", Ta), Y("H", Kd), Y("h", Kd), Y("HH", Kd, Gd), Y("hh", Kd, Gd), Y("hmm", Ld), Y("hmmss", Md), Y("Hmm", Ld), Y("Hmmss", Md), aa(["H", "HH"], _d), aa(["a", "A"], function(a, b, c) {
      c._isPm = c._locale.isPM(a), c._meridiem = a
    }), aa(["h", "hh"], function(a, b, c) {
      b[_d] = t(a), l(c).bigHour = !0
    }), aa("hmm", function(a, b, c) {
      var d = a.length - 2;
      b[_d] = t(a.substr(0, d)), b[ae] = t(a.substr(d)), l(c).bigHour = !0
    }), aa("hmmss", function(a, b, c) {
      var d = a.length - 4,
        e = a.length - 2;
      b[_d] = t(a.substr(0, d)), b[ae] = t(a.substr(d, 2)), b[be] = t(a.substr(e)), l(c).bigHour = !0
    }), aa("Hmm", function(a, b, c) {
      var d = a.length - 2;
      b[_d] = t(a.substr(0, d)), b[ae] = t(a.substr(d))
    }), aa("Hmmss", function(a, b, c) {
      var d = a.length - 4,
        e = a.length - 2;
      b[_d] = t(a.substr(0, d)), b[ae] = t(a.substr(d, 2)), b[be] = t(a.substr(e))
    });
  var se, te = /[ap]\.?m?\.?/i,
    ue = N("Hours", !0),
    ve = {
      calendar: td,
      longDateFormat: ud,
      invalidDate: vd,
      ordinal: wd,
      ordinalParse: xd,
      relativeTime: yd,
      months: ge,
      monthsShort: he,
      week: le,
      weekdays: me,
      weekdaysMin: oe,
      weekdaysShort: ne,
      meridiemParse: te
    },
    we = {},
    xe = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,
    ye = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,
    ze = /Z|[+-]\d\d(?::?\d\d)?/,
    Ae = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, !1],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      // YYYYMM is NOT allowed by the standard
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
      ["YYYYDDD", /\d{7}/]
    ],
    Be = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ],
    Ce = /^\/?Date\((\-?\d+)/i;
  a.createFromInputFallback = w("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(a) {
      a._d = new Date(a._i + (a._useUTC ? " UTC" : ""))
    }),
    // constant that refers to the ISO standard
    a.ISO_8601 = function() {};
  var De = w("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var a = rb.apply(null, arguments);
      return this.isValid() && a.isValid() ? this > a ? this : a : n()
    }),
    Ee = w("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var a = rb.apply(null, arguments);
      return this.isValid() && a.isValid() ? a > this ? this : a : n()
    }),
    Fe = function() {
      return Date.now ? Date.now() : +new Date
    };
  xb("Z", ":"), xb("ZZ", ""),
    // PARSING
    Y("Z", Td), Y("ZZ", Td), aa(["Z", "ZZ"], function(a, b, c) {
      c._useUTC = !0, c._tzm = yb(Td, a)
    });
  // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var Ge = /([\+\-]|\d\d)/gi;
  // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  a.updateOffset = function() {};
  // ASP.NET json date format regex
  var He = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/,
    Ie = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
  Mb.fn = vb.prototype;
  var Je = Rb(1, "add"),
    Ke = Rb(-1, "subtract");
  a.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", a.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  var Le = w("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(a) {
    return void 0 === a ? this.localeData() : this.locale(a)
  });
  // FORMATTING
  T(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100
    }), T(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100
    }), xc("gggg", "weekYear"), xc("ggggg", "weekYear"), xc("GGGG", "isoWeekYear"), xc("GGGGG", "isoWeekYear"),
    // ALIASES
    I("weekYear", "gg"), I("isoWeekYear", "GG"),
    // PRIORITY
    L("weekYear", 1), L("isoWeekYear", 1),
    // PARSING
    Y("G", Rd), Y("g", Rd), Y("GG", Kd, Gd), Y("gg", Kd, Gd), Y("GGGG", Od, Id), Y("gggg", Od, Id), Y("GGGGG", Pd, Jd), Y("ggggg", Pd, Jd), ba(["gggg", "ggggg", "GGGG", "GGGGG"], function(a, b, c, d) {
      b[d.substr(0, 2)] = t(a)
    }), ba(["gg", "GG"], function(b, c, d, e) {
      c[e] = a.parseTwoDigitYear(b)
    }),
    // FORMATTING
    T("Q", 0, "Qo", "quarter"),
    // ALIASES
    I("quarter", "Q"),
    // PRIORITY
    L("quarter", 7),
    // PARSING
    Y("Q", Fd), aa("Q", function(a, b) {
      b[Zd] = 3 * (t(a) - 1)
    }),
    // FORMATTING
    T("D", ["DD", 2], "Do", "date"),
    // ALIASES
    I("date", "D"),
    // PRIOROITY
    L("date", 9),
    // PARSING
    Y("D", Kd), Y("DD", Kd, Gd), Y("Do", function(a, b) {
      return a ? b._ordinalParse : b._ordinalParseLenient
    }), aa(["D", "DD"], $d), aa("Do", function(a, b) {
      b[$d] = t(a.match(Kd)[0], 10)
    });
  // MOMENTS
  var Me = N("Date", !0);
  // FORMATTING
  T("DDD", ["DDDD", 3], "DDDo", "dayOfYear"),
    // ALIASES
    I("dayOfYear", "DDD"),
    // PRIORITY
    L("dayOfYear", 4),
    // PARSING
    Y("DDD", Nd), Y("DDDD", Hd), aa(["DDD", "DDDD"], function(a, b, c) {
      c._dayOfYear = t(a)
    }),
    // FORMATTING
    T("m", ["mm", 2], 0, "minute"),
    // ALIASES
    I("minute", "m"),
    // PRIORITY
    L("minute", 14),
    // PARSING
    Y("m", Kd), Y("mm", Kd, Gd), aa(["m", "mm"], ae);
  // MOMENTS
  var Ne = N("Minutes", !1);
  // FORMATTING
  T("s", ["ss", 2], 0, "second"),
    // ALIASES
    I("second", "s"),
    // PRIORITY
    L("second", 15),
    // PARSING
    Y("s", Kd), Y("ss", Kd, Gd), aa(["s", "ss"], be);
  // MOMENTS
  var Oe = N("Seconds", !1);
  // FORMATTING
  T("S", 0, 0, function() {
      return ~~(this.millisecond() / 100)
    }), T(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10)
    }), T(0, ["SSS", 3], 0, "millisecond"), T(0, ["SSSS", 4], 0, function() {
      return 10 * this.millisecond()
    }), T(0, ["SSSSS", 5], 0, function() {
      return 100 * this.millisecond()
    }), T(0, ["SSSSSS", 6], 0, function() {
      return 1e3 * this.millisecond()
    }), T(0, ["SSSSSSS", 7], 0, function() {
      return 1e4 * this.millisecond()
    }), T(0, ["SSSSSSSS", 8], 0, function() {
      return 1e5 * this.millisecond()
    }), T(0, ["SSSSSSSSS", 9], 0, function() {
      return 1e6 * this.millisecond()
    }),
    // ALIASES
    I("millisecond", "ms"),
    // PRIORITY
    L("millisecond", 16),
    // PARSING
    Y("S", Nd, Fd), Y("SS", Nd, Gd), Y("SSS", Nd, Hd);
  var Pe;
  for (Pe = "SSSS"; Pe.length <= 9; Pe += "S") Y(Pe, Qd);
  for (Pe = "S"; Pe.length <= 9; Pe += "S") aa(Pe, Gc);
  // MOMENTS
  var Qe = N("Milliseconds", !1);
  // FORMATTING
  T("z", 0, 0, "zoneAbbr"), T("zz", 0, 0, "zoneName");
  var Re = q.prototype;
  Re.add = Je, Re.calendar = Ub, Re.clone = Vb, Re.diff = ac, Re.endOf = mc, Re.format = ec, Re.from = fc, Re.fromNow = gc, Re.to = hc, Re.toNow = ic, Re.get = Q, Re.invalidAt = vc, Re.isAfter = Wb, Re.isBefore = Xb, Re.isBetween = Yb, Re.isSame = Zb, Re.isSameOrAfter = $b, Re.isSameOrBefore = _b, Re.isValid = tc, Re.lang = Le, Re.locale = jc, Re.localeData = kc, Re.max = Ee, Re.min = De, Re.parsingFlags = uc, Re.set = R, Re.startOf = lc, Re.subtract = Ke, Re.toArray = qc, Re.toObject = rc, Re.toDate = pc, Re.toISOString = dc, Re.toJSON = sc, Re.toString = cc, Re.unix = oc, Re.valueOf = nc, Re.creationData = wc,
    // Year
    Re.year = ke, Re.isLeapYear = qa,
    // Week Year
    Re.weekYear = yc, Re.isoWeekYear = zc,
    // Quarter
    Re.quarter = Re.quarters = Ec,
    // Month
    Re.month = ja, Re.daysInMonth = ka,
    // Week
    Re.week = Re.weeks = Aa, Re.isoWeek = Re.isoWeeks = Ba, Re.weeksInYear = Bc, Re.isoWeeksInYear = Ac,
    // Day
    Re.date = Me, Re.day = Re.days = Ja, Re.weekday = Ka, Re.isoWeekday = La, Re.dayOfYear = Fc,
    // Hour
    Re.hour = Re.hours = ue,
    // Minute
    Re.minute = Re.minutes = Ne,
    // Second
    Re.second = Re.seconds = Oe,
    // Millisecond
    Re.millisecond = Re.milliseconds = Qe,
    // Offset
    Re.utcOffset = Bb, Re.utc = Db, Re.local = Eb, Re.parseZone = Fb, Re.hasAlignedHourOffset = Gb, Re.isDST = Hb, Re.isLocal = Jb, Re.isUtcOffset = Kb, Re.isUtc = Lb, Re.isUTC = Lb,
    // Timezone
    Re.zoneAbbr = Hc, Re.zoneName = Ic,
    // Deprecations
    Re.dates = w("dates accessor is deprecated. Use date instead.", Me), Re.months = w("months accessor is deprecated. Use month instead", ja), Re.years = w("years accessor is deprecated. Use year instead", ke), Re.zone = w("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", Cb), Re.isDSTShifted = w("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", Ib);
  var Se = Re,
    Te = B.prototype;
  Te.calendar = C, Te.longDateFormat = D, Te.invalidDate = E, Te.ordinal = F, Te.preparse = Lc, Te.postformat = Lc, Te.relativeTime = G, Te.pastFuture = H, Te.set = z,
    // Month
    Te.months = ea, Te.monthsShort = fa, Te.monthsParse = ha, Te.monthsRegex = ma, Te.monthsShortRegex = la,
    // Week
    Te.week = xa, Te.firstDayOfYear = za, Te.firstDayOfWeek = ya,
    // Day of Week
    Te.weekdays = Ea, Te.weekdaysMin = Ga, Te.weekdaysShort = Fa, Te.weekdaysParse = Ia, Te.weekdaysRegex = Ma, Te.weekdaysShortRegex = Na, Te.weekdaysMinRegex = Oa,
    // Hours
    Te.isPM = Ua, Te.meridiem = Va, Za("en", {
      ordinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(a) {
        var b = a % 10,
          c = 1 === t(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
        return a + c
      }
    }),
    // Side effect imports
    a.lang = w("moment.lang is deprecated. Use moment.locale instead.", Za), a.langData = w("moment.langData is deprecated. Use moment.localeData instead.", ab);
  var Ue = Math.abs,
    Ve = cd("ms"),
    We = cd("s"),
    Xe = cd("m"),
    Ye = cd("h"),
    Ze = cd("d"),
    $e = cd("w"),
    _e = cd("M"),
    af = cd("y"),
    bf = ed("milliseconds"),
    cf = ed("seconds"),
    df = ed("minutes"),
    ef = ed("hours"),
    ff = ed("days"),
    gf = ed("months"),
    hf = ed("years"),
    jf = Math.round,
    kf = {
      s: 45, // seconds to minute
      m: 45, // minutes to hour
      h: 22, // hours to day
      d: 26, // days to month
      M: 11
    },
    lf = Math.abs,
    mf = vb.prototype;
  mf.abs = Uc, mf.add = Wc, mf.subtract = Xc, mf.as = ad, mf.asMilliseconds = Ve, mf.asSeconds = We, mf.asMinutes = Xe, mf.asHours = Ye, mf.asDays = Ze, mf.asWeeks = $e, mf.asMonths = _e, mf.asYears = af, mf.valueOf = bd, mf._bubble = Zc, mf.get = dd, mf.milliseconds = bf, mf.seconds = cf, mf.minutes = df, mf.hours = ef, mf.days = ff, mf.weeks = fd, mf.months = gf, mf.years = hf, mf.humanize = kd, mf.toISOString = ld, mf.toString = ld, mf.toJSON = ld, mf.locale = jc, mf.localeData = kc,
    // Deprecations
    mf.toIsoString = w("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", ld), mf.lang = Le,
    // Side effect imports
    // FORMATTING
    T("X", 0, 0, "unix"), T("x", 0, 0, "valueOf"),
    // PARSING
    Y("x", Rd), Y("X", Ud), aa("X", function(a, b, c) {
      c._d = new Date(1e3 * parseFloat(a, 10))
    }), aa("x", function(a, b, c) {
      c._d = new Date(t(a))
    }),
    // Side effect imports
    a.version = "2.14.1", b(rb), a.fn = Se, a.min = tb, a.max = ub, a.now = Fe, a.utc = j, a.unix = Jc, a.months = Pc, a.isDate = f, a.locale = Za, a.invalid = n, a.duration = Mb, a.isMoment = r, a.weekdays = Rc, a.parseZone = Kc, a.localeData = ab, a.isDuration = wb, a.monthsShort = Qc, a.weekdaysMin = Tc, a.defineLocale = $a, a.updateLocale = _a, a.locales = bb, a.weekdaysShort = Sc, a.normalizeUnits = J, a.relativeTimeRounding = id, a.relativeTimeThreshold = jd, a.calendarFormat = Tb, a.prototype = Se;
  var nf = a;
  return nf
});
/*! RESOURCE: /scripts/thirdparty/select2/select2.js */
(function($) {
  if (typeof $.fn.each2 == "undefined") {
    $.extend($.fn, {
      each2: function(c) {
        var j = $([0]),
          i = -1,
          l = this.length;
        while (
          ++i < l &&
          (j.context = j[0] = this[i]) &&
          c.call(j[0], i, j) !== false
        );
        return this;
      }
    });
  }
})(jQuery);
(function($, undefined) {
  "use strict";
  if (window.Select2 !== undefined) {
    return;
  }
  var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
    lastMousePosition = {
      x: 0,
      y: 0
    },
    $document, scrollBarDimensions,
    KEY = {
      TAB: 9,
      ENTER: 13,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      HOME: 36,
      END: 35,
      BACKSPACE: 8,
      DELETE: 46,
      isArrow: function(k) {
        k = k.which ? k.which : k;
        switch (k) {
          case KEY.LEFT:
          case KEY.RIGHT:
          case KEY.UP:
          case KEY.DOWN:
            return true;
        }
        return false;
      },
      isControl: function(e) {
        var k = e.which;
        switch (k) {
          case KEY.SHIFT:
          case KEY.CTRL:
          case KEY.ALT:
            return true;
        }
        if (e.metaKey) return true;
        return false;
      },
      isFunctionKey: function(k) {
        k = k.which ? k.which : k;
        return k >= 112 && k <= 123;
      }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",
    DIACRITICS = {
      "\u24B6": "A",
      "\uFF21": "A",
      "\u00C0": "A",
      "\u00C1": "A",
      "\u00C2": "A",
      "\u1EA6": "A",
      "\u1EA4": "A",
      "\u1EAA": "A",
      "\u1EA8": "A",
      "\u00C3": "A",
      "\u0100": "A",
      "\u0102": "A",
      "\u1EB0": "A",
      "\u1EAE": "A",
      "\u1EB4": "A",
      "\u1EB2": "A",
      "\u0226": "A",
      "\u01E0": "A",
      "\u00C4": "A",
      "\u01DE": "A",
      "\u1EA2": "A",
      "\u00C5": "A",
      "\u01FA": "A",
      "\u01CD": "A",
      "\u0200": "A",
      "\u0202": "A",
      "\u1EA0": "A",
      "\u1EAC": "A",
      "\u1EB6": "A",
      "\u1E00": "A",
      "\u0104": "A",
      "\u023A": "A",
      "\u2C6F": "A",
      "\uA732": "AA",
      "\u00C6": "AE",
      "\u01FC": "AE",
      "\u01E2": "AE",
      "\uA734": "AO",
      "\uA736": "AU",
      "\uA738": "AV",
      "\uA73A": "AV",
      "\uA73C": "AY",
      "\u24B7": "B",
      "\uFF22": "B",
      "\u1E02": "B",
      "\u1E04": "B",
      "\u1E06": "B",
      "\u0243": "B",
      "\u0182": "B",
      "\u0181": "B",
      "\u24B8": "C",
      "\uFF23": "C",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u00C7": "C",
      "\u1E08": "C",
      "\u0187": "C",
      "\u023B": "C",
      "\uA73E": "C",
      "\u24B9": "D",
      "\uFF24": "D",
      "\u1E0A": "D",
      "\u010E": "D",
      "\u1E0C": "D",
      "\u1E10": "D",
      "\u1E12": "D",
      "\u1E0E": "D",
      "\u0110": "D",
      "\u018B": "D",
      "\u018A": "D",
      "\u0189": "D",
      "\uA779": "D",
      "\u01F1": "DZ",
      "\u01C4": "DZ",
      "\u01F2": "Dz",
      "\u01C5": "Dz",
      "\u24BA": "E",
      "\uFF25": "E",
      "\u00C8": "E",
      "\u00C9": "E",
      "\u00CA": "E",
      "\u1EC0": "E",
      "\u1EBE": "E",
      "\u1EC4": "E",
      "\u1EC2": "E",
      "\u1EBC": "E",
      "\u0112": "E",
      "\u1E14": "E",
      "\u1E16": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u00CB": "E",
      "\u1EBA": "E",
      "\u011A": "E",
      "\u0204": "E",
      "\u0206": "E",
      "\u1EB8": "E",
      "\u1EC6": "E",
      "\u0228": "E",
      "\u1E1C": "E",
      "\u0118": "E",
      "\u1E18": "E",
      "\u1E1A": "E",
      "\u0190": "E",
      "\u018E": "E",
      "\u24BB": "F",
      "\uFF26": "F",
      "\u1E1E": "F",
      "\u0191": "F",
      "\uA77B": "F",
      "\u24BC": "G",
      "\uFF27": "G",
      "\u01F4": "G",
      "\u011C": "G",
      "\u1E20": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u01E6": "G",
      "\u0122": "G",
      "\u01E4": "G",
      "\u0193": "G",
      "\uA7A0": "G",
      "\uA77D": "G",
      "\uA77E": "G",
      "\u24BD": "H",
      "\uFF28": "H",
      "\u0124": "H",
      "\u1E22": "H",
      "\u1E26": "H",
      "\u021E": "H",
      "\u1E24": "H",
      "\u1E28": "H",
      "\u1E2A": "H",
      "\u0126": "H",
      "\u2C67": "H",
      "\u2C75": "H",
      "\uA78D": "H",
      "\u24BE": "I",
      "\uFF29": "I",
      "\u00CC": "I",
      "\u00CD": "I",
      "\u00CE": "I",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u0130": "I",
      "\u00CF": "I",
      "\u1E2E": "I",
      "\u1EC8": "I",
      "\u01CF": "I",
      "\u0208": "I",
      "\u020A": "I",
      "\u1ECA": "I",
      "\u012E": "I",
      "\u1E2C": "I",
      "\u0197": "I",
      "\u24BF": "J",
      "\uFF2A": "J",
      "\u0134": "J",
      "\u0248": "J",
      "\u24C0": "K",
      "\uFF2B": "K",
      "\u1E30": "K",
      "\u01E8": "K",
      "\u1E32": "K",
      "\u0136": "K",
      "\u1E34": "K",
      "\u0198": "K",
      "\u2C69": "K",
      "\uA740": "K",
      "\uA742": "K",
      "\uA744": "K",
      "\uA7A2": "K",
      "\u24C1": "L",
      "\uFF2C": "L",
      "\u013F": "L",
      "\u0139": "L",
      "\u013D": "L",
      "\u1E36": "L",
      "\u1E38": "L",
      "\u013B": "L",
      "\u1E3C": "L",
      "\u1E3A": "L",
      "\u0141": "L",
      "\u023D": "L",
      "\u2C62": "L",
      "\u2C60": "L",
      "\uA748": "L",
      "\uA746": "L",
      "\uA780": "L",
      "\u01C7": "LJ",
      "\u01C8": "Lj",
      "\u24C2": "M",
      "\uFF2D": "M",
      "\u1E3E": "M",
      "\u1E40": "M",
      "\u1E42": "M",
      "\u2C6E": "M",
      "\u019C": "M",
      "\u24C3": "N",
      "\uFF2E": "N",
      "\u01F8": "N",
      "\u0143": "N",
      "\u00D1": "N",
      "\u1E44": "N",
      "\u0147": "N",
      "\u1E46": "N",
      "\u0145": "N",
      "\u1E4A": "N",
      "\u1E48": "N",
      "\u0220": "N",
      "\u019D": "N",
      "\uA790": "N",
      "\uA7A4": "N",
      "\u01CA": "NJ",
      "\u01CB": "Nj",
      "\u24C4": "O",
      "\uFF2F": "O",
      "\u00D2": "O",
      "\u00D3": "O",
      "\u00D4": "O",
      "\u1ED2": "O",
      "\u1ED0": "O",
      "\u1ED6": "O",
      "\u1ED4": "O",
      "\u00D5": "O",
      "\u1E4C": "O",
      "\u022C": "O",
      "\u1E4E": "O",
      "\u014C": "O",
      "\u1E50": "O",
      "\u1E52": "O",
      "\u014E": "O",
      "\u022E": "O",
      "\u0230": "O",
      "\u00D6": "O",
      "\u022A": "O",
      "\u1ECE": "O",
      "\u0150": "O",
      "\u01D1": "O",
      "\u020C": "O",
      "\u020E": "O",
      "\u01A0": "O",
      "\u1EDC": "O",
      "\u1EDA": "O",
      "\u1EE0": "O",
      "\u1EDE": "O",
      "\u1EE2": "O",
      "\u1ECC": "O",
      "\u1ED8": "O",
      "\u01EA": "O",
      "\u01EC": "O",
      "\u00D8": "O",
      "\u01FE": "O",
      "\u0186": "O",
      "\u019F": "O",
      "\uA74A": "O",
      "\uA74C": "O",
      "\u01A2": "OI",
      "\uA74E": "OO",
      "\u0222": "OU",
      "\u24C5": "P",
      "\uFF30": "P",
      "\u1E54": "P",
      "\u1E56": "P",
      "\u01A4": "P",
      "\u2C63": "P",
      "\uA750": "P",
      "\uA752": "P",
      "\uA754": "P",
      "\u24C6": "Q",
      "\uFF31": "Q",
      "\uA756": "Q",
      "\uA758": "Q",
      "\u024A": "Q",
      "\u24C7": "R",
      "\uFF32": "R",
      "\u0154": "R",
      "\u1E58": "R",
      "\u0158": "R",
      "\u0210": "R",
      "\u0212": "R",
      "\u1E5A": "R",
      "\u1E5C": "R",
      "\u0156": "R",
      "\u1E5E": "R",
      "\u024C": "R",
      "\u2C64": "R",
      "\uA75A": "R",
      "\uA7A6": "R",
      "\uA782": "R",
      "\u24C8": "S",
      "\uFF33": "S",
      "\u1E9E": "S",
      "\u015A": "S",
      "\u1E64": "S",
      "\u015C": "S",
      "\u1E60": "S",
      "\u0160": "S",
      "\u1E66": "S",
      "\u1E62": "S",
      "\u1E68": "S",
      "\u0218": "S",
      "\u015E": "S",
      "\u2C7E": "S",
      "\uA7A8": "S",
      "\uA784": "S",
      "\u24C9": "T",
      "\uFF34": "T",
      "\u1E6A": "T",
      "\u0164": "T",
      "\u1E6C": "T",
      "\u021A": "T",
      "\u0162": "T",
      "\u1E70": "T",
      "\u1E6E": "T",
      "\u0166": "T",
      "\u01AC": "T",
      "\u01AE": "T",
      "\u023E": "T",
      "\uA786": "T",
      "\uA728": "TZ",
      "\u24CA": "U",
      "\uFF35": "U",
      "\u00D9": "U",
      "\u00DA": "U",
      "\u00DB": "U",
      "\u0168": "U",
      "\u1E78": "U",
      "\u016A": "U",
      "\u1E7A": "U",
      "\u016C": "U",
      "\u00DC": "U",
      "\u01DB": "U",
      "\u01D7": "U",
      "\u01D5": "U",
      "\u01D9": "U",
      "\u1EE6": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u01D3": "U",
      "\u0214": "U",
      "\u0216": "U",
      "\u01AF": "U",
      "\u1EEA": "U",
      "\u1EE8": "U",
      "\u1EEE": "U",
      "\u1EEC": "U",
      "\u1EF0": "U",
      "\u1EE4": "U",
      "\u1E72": "U",
      "\u0172": "U",
      "\u1E76": "U",
      "\u1E74": "U",
      "\u0244": "U",
      "\u24CB": "V",
      "\uFF36": "V",
      "\u1E7C": "V",
      "\u1E7E": "V",
      "\u01B2": "V",
      "\uA75E": "V",
      "\u0245": "V",
      "\uA760": "VY",
      "\u24CC": "W",
      "\uFF37": "W",
      "\u1E80": "W",
      "\u1E82": "W",
      "\u0174": "W",
      "\u1E86": "W",
      "\u1E84": "W",
      "\u1E88": "W",
      "\u2C72": "W",
      "\u24CD": "X",
      "\uFF38": "X",
      "\u1E8A": "X",
      "\u1E8C": "X",
      "\u24CE": "Y",
      "\uFF39": "Y",
      "\u1EF2": "Y",
      "\u00DD": "Y",
      "\u0176": "Y",
      "\u1EF8": "Y",
      "\u0232": "Y",
      "\u1E8E": "Y",
      "\u0178": "Y",
      "\u1EF6": "Y",
      "\u1EF4": "Y",
      "\u01B3": "Y",
      "\u024E": "Y",
      "\u1EFE": "Y",
      "\u24CF": "Z",
      "\uFF3A": "Z",
      "\u0179": "Z",
      "\u1E90": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u1E92": "Z",
      "\u1E94": "Z",
      "\u01B5": "Z",
      "\u0224": "Z",
      "\u2C7F": "Z",
      "\u2C6B": "Z",
      "\uA762": "Z",
      "\u24D0": "a",
      "\uFF41": "a",
      "\u1E9A": "a",
      "\u00E0": "a",
      "\u00E1": "a",
      "\u00E2": "a",
      "\u1EA7": "a",
      "\u1EA5": "a",
      "\u1EAB": "a",
      "\u1EA9": "a",
      "\u00E3": "a",
      "\u0101": "a",
      "\u0103": "a",
      "\u1EB1": "a",
      "\u1EAF": "a",
      "\u1EB5": "a",
      "\u1EB3": "a",
      "\u0227": "a",
      "\u01E1": "a",
      "\u00E4": "a",
      "\u01DF": "a",
      "\u1EA3": "a",
      "\u00E5": "a",
      "\u01FB": "a",
      "\u01CE": "a",
      "\u0201": "a",
      "\u0203": "a",
      "\u1EA1": "a",
      "\u1EAD": "a",
      "\u1EB7": "a",
      "\u1E01": "a",
      "\u0105": "a",
      "\u2C65": "a",
      "\u0250": "a",
      "\uA733": "aa",
      "\u00E6": "ae",
      "\u01FD": "ae",
      "\u01E3": "ae",
      "\uA735": "ao",
      "\uA737": "au",
      "\uA739": "av",
      "\uA73B": "av",
      "\uA73D": "ay",
      "\u24D1": "b",
      "\uFF42": "b",
      "\u1E03": "b",
      "\u1E05": "b",
      "\u1E07": "b",
      "\u0180": "b",
      "\u0183": "b",
      "\u0253": "b",
      "\u24D2": "c",
      "\uFF43": "c",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u00E7": "c",
      "\u1E09": "c",
      "\u0188": "c",
      "\u023C": "c",
      "\uA73F": "c",
      "\u2184": "c",
      "\u24D3": "d",
      "\uFF44": "d",
      "\u1E0B": "d",
      "\u010F": "d",
      "\u1E0D": "d",
      "\u1E11": "d",
      "\u1E13": "d",
      "\u1E0F": "d",
      "\u0111": "d",
      "\u018C": "d",
      "\u0256": "d",
      "\u0257": "d",
      "\uA77A": "d",
      "\u01F3": "dz",
      "\u01C6": "dz",
      "\u24D4": "e",
      "\uFF45": "e",
      "\u00E8": "e",
      "\u00E9": "e",
      "\u00EA": "e",
      "\u1EC1": "e",
      "\u1EBF": "e",
      "\u1EC5": "e",
      "\u1EC3": "e",
      "\u1EBD": "e",
      "\u0113": "e",
      "\u1E15": "e",
      "\u1E17": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u00EB": "e",
      "\u1EBB": "e",
      "\u011B": "e",
      "\u0205": "e",
      "\u0207": "e",
      "\u1EB9": "e",
      "\u1EC7": "e",
      "\u0229": "e",
      "\u1E1D": "e",
      "\u0119": "e",
      "\u1E19": "e",
      "\u1E1B": "e",
      "\u0247": "e",
      "\u025B": "e",
      "\u01DD": "e",
      "\u24D5": "f",
      "\uFF46": "f",
      "\u1E1F": "f",
      "\u0192": "f",
      "\uA77C": "f",
      "\u24D6": "g",
      "\uFF47": "g",
      "\u01F5": "g",
      "\u011D": "g",
      "\u1E21": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u01E7": "g",
      "\u0123": "g",
      "\u01E5": "g",
      "\u0260": "g",
      "\uA7A1": "g",
      "\u1D79": "g",
      "\uA77F": "g",
      "\u24D7": "h",
      "\uFF48": "h",
      "\u0125": "h",
      "\u1E23": "h",
      "\u1E27": "h",
      "\u021F": "h",
      "\u1E25": "h",
      "\u1E29": "h",
      "\u1E2B": "h",
      "\u1E96": "h",
      "\u0127": "h",
      "\u2C68": "h",
      "\u2C76": "h",
      "\u0265": "h",
      "\u0195": "hv",
      "\u24D8": "i",
      "\uFF49": "i",
      "\u00EC": "i",
      "\u00ED": "i",
      "\u00EE": "i",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u00EF": "i",
      "\u1E2F": "i",
      "\u1EC9": "i",
      "\u01D0": "i",
      "\u0209": "i",
      "\u020B": "i",
      "\u1ECB": "i",
      "\u012F": "i",
      "\u1E2D": "i",
      "\u0268": "i",
      "\u0131": "i",
      "\u24D9": "j",
      "\uFF4A": "j",
      "\u0135": "j",
      "\u01F0": "j",
      "\u0249": "j",
      "\u24DA": "k",
      "\uFF4B": "k",
      "\u1E31": "k",
      "\u01E9": "k",
      "\u1E33": "k",
      "\u0137": "k",
      "\u1E35": "k",
      "\u0199": "k",
      "\u2C6A": "k",
      "\uA741": "k",
      "\uA743": "k",
      "\uA745": "k",
      "\uA7A3": "k",
      "\u24DB": "l",
      "\uFF4C": "l",
      "\u0140": "l",
      "\u013A": "l",
      "\u013E": "l",
      "\u1E37": "l",
      "\u1E39": "l",
      "\u013C": "l",
      "\u1E3D": "l",
      "\u1E3B": "l",
      "\u017F": "l",
      "\u0142": "l",
      "\u019A": "l",
      "\u026B": "l",
      "\u2C61": "l",
      "\uA749": "l",
      "\uA781": "l",
      "\uA747": "l",
      "\u01C9": "lj",
      "\u24DC": "m",
      "\uFF4D": "m",
      "\u1E3F": "m",
      "\u1E41": "m",
      "\u1E43": "m",
      "\u0271": "m",
      "\u026F": "m",
      "\u24DD": "n",
      "\uFF4E": "n",
      "\u01F9": "n",
      "\u0144": "n",
      "\u00F1": "n",
      "\u1E45": "n",
      "\u0148": "n",
      "\u1E47": "n",
      "\u0146": "n",
      "\u1E4B": "n",
      "\u1E49": "n",
      "\u019E": "n",
      "\u0272": "n",
      "\u0149": "n",
      "\uA791": "n",
      "\uA7A5": "n",
      "\u01CC": "nj",
      "\u24DE": "o",
      "\uFF4F": "o",
      "\u00F2": "o",
      "\u00F3": "o",
      "\u00F4": "o",
      "\u1ED3": "o",
      "\u1ED1": "o",
      "\u1ED7": "o",
      "\u1ED5": "o",
      "\u00F5": "o",
      "\u1E4D": "o",
      "\u022D": "o",
      "\u1E4F": "o",
      "\u014D": "o",
      "\u1E51": "o",
      "\u1E53": "o",
      "\u014F": "o",
      "\u022F": "o",
      "\u0231": "o",
      "\u00F6": "o",
      "\u022B": "o",
      "\u1ECF": "o",
      "\u0151": "o",
      "\u01D2": "o",
      "\u020D": "o",
      "\u020F": "o",
      "\u01A1": "o",
      "\u1EDD": "o",
      "\u1EDB": "o",
      "\u1EE1": "o",
      "\u1EDF": "o",
      "\u1EE3": "o",
      "\u1ECD": "o",
      "\u1ED9": "o",
      "\u01EB": "o",
      "\u01ED": "o",
      "\u00F8": "o",
      "\u01FF": "o",
      "\u0254": "o",
      "\uA74B": "o",
      "\uA74D": "o",
      "\u0275": "o",
      "\u01A3": "oi",
      "\u0223": "ou",
      "\uA74F": "oo",
      "\u24DF": "p",
      "\uFF50": "p",
      "\u1E55": "p",
      "\u1E57": "p",
      "\u01A5": "p",
      "\u1D7D": "p",
      "\uA751": "p",
      "\uA753": "p",
      "\uA755": "p",
      "\u24E0": "q",
      "\uFF51": "q",
      "\u024B": "q",
      "\uA757": "q",
      "\uA759": "q",
      "\u24E1": "r",
      "\uFF52": "r",
      "\u0155": "r",
      "\u1E59": "r",
      "\u0159": "r",
      "\u0211": "r",
      "\u0213": "r",
      "\u1E5B": "r",
      "\u1E5D": "r",
      "\u0157": "r",
      "\u1E5F": "r",
      "\u024D": "r",
      "\u027D": "r",
      "\uA75B": "r",
      "\uA7A7": "r",
      "\uA783": "r",
      "\u24E2": "s",
      "\uFF53": "s",
      "\u00DF": "s",
      "\u015B": "s",
      "\u1E65": "s",
      "\u015D": "s",
      "\u1E61": "s",
      "\u0161": "s",
      "\u1E67": "s",
      "\u1E63": "s",
      "\u1E69": "s",
      "\u0219": "s",
      "\u015F": "s",
      "\u023F": "s",
      "\uA7A9": "s",
      "\uA785": "s",
      "\u1E9B": "s",
      "\u24E3": "t",
      "\uFF54": "t",
      "\u1E6B": "t",
      "\u1E97": "t",
      "\u0165": "t",
      "\u1E6D": "t",
      "\u021B": "t",
      "\u0163": "t",
      "\u1E71": "t",
      "\u1E6F": "t",
      "\u0167": "t",
      "\u01AD": "t",
      "\u0288": "t",
      "\u2C66": "t",
      "\uA787": "t",
      "\uA729": "tz",
      "\u24E4": "u",
      "\uFF55": "u",
      "\u00F9": "u",
      "\u00FA": "u",
      "\u00FB": "u",
      "\u0169": "u",
      "\u1E79": "u",
      "\u016B": "u",
      "\u1E7B": "u",
      "\u016D": "u",
      "\u00FC": "u",
      "\u01DC": "u",
      "\u01D8": "u",
      "\u01D6": "u",
      "\u01DA": "u",
      "\u1EE7": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u01D4": "u",
      "\u0215": "u",
      "\u0217": "u",
      "\u01B0": "u",
      "\u1EEB": "u",
      "\u1EE9": "u",
      "\u1EEF": "u",
      "\u1EED": "u",
      "\u1EF1": "u",
      "\u1EE5": "u",
      "\u1E73": "u",
      "\u0173": "u",
      "\u1E77": "u",
      "\u1E75": "u",
      "\u0289": "u",
      "\u24E5": "v",
      "\uFF56": "v",
      "\u1E7D": "v",
      "\u1E7F": "v",
      "\u028B": "v",
      "\uA75F": "v",
      "\u028C": "v",
      "\uA761": "vy",
      "\u24E6": "w",
      "\uFF57": "w",
      "\u1E81": "w",
      "\u1E83": "w",
      "\u0175": "w",
      "\u1E87": "w",
      "\u1E85": "w",
      "\u1E98": "w",
      "\u1E89": "w",
      "\u2C73": "w",
      "\u24E7": "x",
      "\uFF58": "x",
      "\u1E8B": "x",
      "\u1E8D": "x",
      "\u24E8": "y",
      "\uFF59": "y",
      "\u1EF3": "y",
      "\u00FD": "y",
      "\u0177": "y",
      "\u1EF9": "y",
      "\u0233": "y",
      "\u1E8F": "y",
      "\u00FF": "y",
      "\u1EF7": "y",
      "\u1E99": "y",
      "\u1EF5": "y",
      "\u01B4": "y",
      "\u024F": "y",
      "\u1EFF": "y",
      "\u24E9": "z",
      "\uFF5A": "z",
      "\u017A": "z",
      "\u1E91": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u1E93": "z",
      "\u1E95": "z",
      "\u01B6": "z",
      "\u0225": "z",
      "\u0240": "z",
      "\u2C6C": "z",
      "\uA763": "z",
      "\u0386": "\u0391",
      "\u0388": "\u0395",
      "\u0389": "\u0397",
      "\u038A": "\u0399",
      "\u03AA": "\u0399",
      "\u038C": "\u039F",
      "\u038E": "\u03A5",
      "\u03AB": "\u03A5",
      "\u038F": "\u03A9",
      "\u03AC": "\u03B1",
      "\u03AD": "\u03B5",
      "\u03AE": "\u03B7",
      "\u03AF": "\u03B9",
      "\u03CA": "\u03B9",
      "\u0390": "\u03B9",
      "\u03CC": "\u03BF",
      "\u03CD": "\u03C5",
      "\u03CB": "\u03C5",
      "\u03B0": "\u03C5",
      "\u03C9": "\u03C9",
      "\u03C2": "\u03C3"
    };
  $document = $(document);
  nextUid = (function() {
    var counter = 1;
    return function() {
      return counter++;
    };
  }());

  function reinsertElement(element) {
    var placeholder = $(document.createTextNode(''));
    element.before(placeholder);
    placeholder.before(element);
    placeholder.remove();
  }

  function stripDiacritics(str) {
    function match(a) {
      return DIACRITICS[a] || a;
    }
    return str.replace(/[^\u0000-\u007E]/g, match);
  }

  function indexOf(value, array) {
    var i = 0,
      l = array.length;
    for (; i < l; i = i + 1) {
      if (equal(value, array[i])) return i;
    }
    return -1;
  }

  function measureScrollbar() {
    var $template = $(MEASURE_SCROLLBAR_TEMPLATE);
    $template.appendTo('body');
    var dim = {
      width: $template.width() - $template[0].clientWidth,
      height: $template.height() - $template[0].clientHeight
    };
    $template.remove();
    return dim;
  }

  function equal(a, b) {
    if (a === b) return true;
    if (a === undefined || b === undefined) return false;
    if (a === null || b === null) return false;
    if (a.constructor === String) return a + '' === b + '';
    if (b.constructor === String) return b + '' === a + '';
    return false;
  }

  function splitVal(string, separator) {
    var val, i, l;
    if (string === null || string.length < 1) return [];
    val = string.split(separator);
    for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
    return val;
  }

  function getSideBorderPadding(element) {
    return element.outerWidth(false) - element.width();
  }

  function installKeyUpChangeEvent(element) {
    var key = "keyup-change-value";
    element.on("keydown", function() {
      if ($.data(element, key) === undefined) {
        $.data(element, key, element.val());
      }
    });
    element.on("keyup", function() {
      var val = $.data(element, key);
      if (val !== undefined && element.val() !== val) {
        $.removeData(element, key);
        element.trigger("keyup-change");
      }
    });
  }

  function installFilteredMouseMove(element) {
    element.on("mousemove", function(e) {
      var lastpos = lastMousePosition;
      if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
        $(e.target).trigger("mousemove-filtered", e);
      }
    });
  }

  function debounce(quietMillis, fn, ctx) {
    ctx = ctx || undefined;
    var timeout;
    return function() {
      var args = arguments;
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function() {
        fn.apply(ctx, args);
      }, quietMillis);
    };
  }

  function installDebouncedScroll(threshold, element) {
    var notify = debounce(threshold, function(e) {
      element.trigger("scroll-debounced", e);
    });
    element.on("scroll", function(e) {
      if (indexOf(e.target, element.get()) >= 0) notify(e);
    });
  }

  function focus($el) {
    if ($el[0] === document.activeElement) return;
    window.setTimeout(function() {
      var el = $el[0],
        pos = $el.val().length,
        range;
      $el.focus();
      var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
      if (isVisible && el === document.activeElement) {
        if (el.setSelectionRange) {
          el.setSelectionRange(pos, pos);
        } else if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }
    }, 0);
  }

  function getCursorInfo(el) {
    el = $(el)[0];
    var offset = 0;
    var length = 0;
    if ('selectionStart' in el) {
      offset = el.selectionStart;
      length = el.selectionEnd - offset;
    } else if ('selection' in document) {
      el.focus();
      var sel = document.selection.createRange();
      length = document.selection.createRange().text.length;
      sel.moveStart('character', -el.value.length);
      offset = sel.text.length - length;
    }
    return {
      offset: offset,
      length: length
    };
  }

  function killEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function killEventImmediately(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  function measureTextWidth(e) {
    if (!sizer) {
      var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
      sizer = $(document.createElement("div")).css({
        position: "absolute",
        left: "-10000px",
        top: "-10000px",
        display: "none",
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        fontStyle: style.fontStyle,
        fontWeight: style.fontWeight,
        letterSpacing: style.letterSpacing,
        textTransform: style.textTransform,
        whiteSpace: "nowrap"
      });
      sizer.attr("class", "select2-sizer");
      $("body").append(sizer);
    }
    sizer.text(e.val());
    return sizer.width();
  }

  function syncCssClasses(dest, src, adapter) {
    var classes, replacements = [],
      adapted;
    classes = $.trim(dest.attr("class"));
    if (classes) {
      classes = '' + classes;
      $(classes.split(/\s+/)).each2(function() {
        if (this.indexOf("select2-") === 0) {
          replacements.push(this);
        }
      });
    }
    classes = $.trim(src.attr("class"));
    if (classes) {
      classes = '' + classes;
      $(classes.split(/\s+/)).each2(function() {
        if (this.indexOf("select2-") !== 0) {
          adapted = adapter(this);
          if (adapted) {
            replacements.push(adapted);
          }
        }
      });
    }
    dest.attr("class", replacements.join(" "));
  }

  function markMatch(text, term, markup, escapeMarkup) {
    var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
      tl = term.length;
    if (match < 0) {
      markup.push(escapeMarkup(text));
      return;
    }
    markup.push(escapeMarkup(text.substring(0, match)));
    markup.push("<span class='select2-match'>");
    markup.push(escapeMarkup(text.substring(match, match + tl)));
    markup.push("</span>");
    markup.push(escapeMarkup(text.substring(match + tl, text.length)));
  }

  function defaultEscapeMarkup(markup) {
    var replace_map = {
      '\\': '&#92;',
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      "/": '&#47;'
    };
    return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
      return replace_map[match];
    });
  }

  function ajax(options) {
    var timeout,
      handler = null,
      quietMillis = options.quietMillis || 100,
      ajaxUrl = options.url,
      self = this;
    return function(query) {
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function() {
        var data = options.data,
          url = ajaxUrl,
          transport = options.transport || $.fn.select2.ajaxDefaults.transport,
          deprecated = {
            type: options.type || 'GET',
            cache: options.cache || false,
            jsonpCallback: options.jsonpCallback || undefined,
            dataType: options.dataType || "json"
          },
          params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);
        data = data ? data.call(self, query.term, query.page, query.context) : null;
        url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;
        if (handler && typeof handler.abort === "function") {
          handler.abort();
        }
        if (options.params) {
          if ($.isFunction(options.params)) {
            $.extend(params, options.params.call(self));
          } else {
            $.extend(params, options.params);
          }
        }
        $.extend(params, {
          url: url,
          dataType: options.dataType,
          data: data,
          success: function(data) {
            var results = options.results(data, query.page, query);
            query.callback(results);
          },
          error: function(jqXHR, textStatus, errorThrown) {
            var results = {
              hasError: true,
              jqXHR: jqXHR,
              textStatus: textStatus,
              errorThrown: errorThrown,
            };
            query.callback(results);
          }
        });
        handler = transport.call(self, params);
      }, quietMillis);
    };
  }

  function local(options) {
    var data = options,
      dataText,
      tmp,
      text = function(item) {
        return "" + item.text;
      };
    if ($.isArray(data)) {
      tmp = data;
      data = {
        results: tmp
      };
    }
    if ($.isFunction(data) === false) {
      tmp = data;
      data = function() {
        return tmp;
      };
    }
    var dataItem = data();
    if (dataItem.text) {
      text = dataItem.text;
      if (!$.isFunction(text)) {
        dataText = dataItem.text;
        text = function(item) {
          return item[dataText];
        };
      }
    }
    return function(query) {
      var t = query.term,
        filtered = {
          results: []
        },
        process;
      if (t === "") {
        query.callback(data());
        return;
      }
      process = function(datum, collection) {
        var group, attr;
        datum = datum[0];
        if (datum.children) {
          group = {};
          for (attr in datum) {
            if (datum.hasOwnProperty(attr)) group[attr] = datum[attr];
          }
          group.children = [];
          $(datum.children).each2(function(i, childDatum) {
            process(childDatum, group.children);
          });
          if (group.children.length || query.matcher(t, text(group), datum)) {
            collection.push(group);
          }
        } else {
          if (query.matcher(t, text(datum), datum)) {
            collection.push(datum);
          }
        }
      };
      $(data().results).each2(function(i, datum) {
        process(datum, filtered.results);
      });
      query.callback(filtered);
    };
  }

  function tags(data) {
    var isFunc = $.isFunction(data);
    return function(query) {
      var t = query.term,
        filtered = {
          results: []
        };
      var result = isFunc ? data(query) : data;
      if ($.isArray(result)) {
        $(result).each(function() {
          var isObject = this.text !== undefined,
            text = isObject ? this.text : this;
          if (t === "" || query.matcher(t, text)) {
            filtered.results.push(isObject ? this : {
              id: this,
              text: this
            });
          }
        });
        query.callback(filtered);
      }
    };
  }

  function checkFormatter(formatter, formatterName) {
    if ($.isFunction(formatter)) return true;
    if (!formatter) return false;
    if (typeof(formatter) === 'string') return true;
    throw new Error(formatterName + " must be a string, function, or falsy value");
  }

  function evaluate(val, context) {
    if ($.isFunction(val)) {
      var args = Array.prototype.slice.call(arguments, 2);
      return val.apply(context, args);
    }
    return val;
  }

  function countResults(results) {
    var count = 0;
    $.each(results, function(i, item) {
      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    });
    return count;
  }

  function defaultTokenizer(input, selection, selectCallback, opts) {
    var original = input,
      dupe = false,
      token,
      index,
      i, l,
      separator;
    if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;
    while (true) {
      index = -1;
      for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
        separator = opts.tokenSeparators[i];
        index = input.indexOf(separator);
        if (index >= 0) break;
      }
      if (index < 0) break;
      token = input.substring(0, index);
      input = input.substring(index + separator.length);
      if (token.length > 0) {
        token = opts.createSearchChoice.call(this, token, selection);
        if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
          dupe = false;
          for (i = 0, l = selection.length; i < l; i++) {
            if (equal(opts.id(token), opts.id(selection[i]))) {
              dupe = true;
              break;
            }
          }
          if (!dupe) selectCallback(token);
        }
      }
    }
    if (original !== input) return input;
  }

  function cleanupJQueryElements() {
    var self = this;
    $.each(arguments, function(i, element) {
      self[element].remove();
      self[element] = null;
    });
  }

  function clazz(SuperClass, methods) {
    var constructor = function() {};
    constructor.prototype = new SuperClass;
    constructor.prototype.constructor = constructor;
    constructor.prototype.parent = SuperClass.prototype;
    constructor.prototype = $.extend(constructor.prototype, methods);
    return constructor;
  }
  AbstractSelect2 = clazz(Object, {
    bind: function(func) {
      var self = this;
      return function() {
        func.apply(self, arguments);
      };
    },
    init: function(opts) {
      var results, search, resultsSelector = ".select2-results";
      this.opts = opts = this.prepareOpts(opts);
      this.id = opts.id;
      if (opts.element.data("select2") !== undefined &&
        opts.element.data("select2") !== null) {
        opts.element.data("select2").destroy();
      }
      this.container = this.createContainer();
      this.liveRegion = $("<span>", {
          role: "status",
          "aria-live": "polite"
        })
        .addClass("select2-hidden-accessible")
        .appendTo(document.body);
      this.containerId = "s2id_" + (opts.element.attr("id") || "autogen" + nextUid());
      this.containerEventName = this.containerId
        .replace(/([.])/g, '_')
        .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
      this.container.attr("id", this.containerId);
      this.container.attr("title", opts.element.attr("title"));
      this.body = $("body");
      syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
      this.container.attr("style", opts.element.attr("style"));
      this.container.css(evaluate(opts.containerCss, this.opts.element));
      this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));
      this.elementTabIndex = this.opts.element.attr("tabindex");
      this.opts.element
        .data("select2", this)
        .attr("tabindex", "-1")
        .before(this.container)
        .on("click.select2", killEvent);
      this.container.data("select2", this);
      this.dropdown = this.container.find(".select2-drop");
      syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
      this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
      this.dropdown.data("select2", this);
      this.dropdown.on("click", killEvent);
      this.results = results = this.container.find(resultsSelector);
      this.search = search = this.container.find("input.select2-input");
      this.queryCount = 0;
      this.resultsPage = 0;
      this.context = null;
      this.initContainer();
      this.container.on("click", killEvent);
      installFilteredMouseMove(this.results);
      this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
      this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function(event) {
        this._touchEvent = true;
        this.highlightUnderEvent(event);
      }));
      this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
      this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));
      this.dropdown.on('click', this.bind(function(event) {
        if (this._touchEvent) {
          this._touchEvent = false;
          this.selectHighlighted();
        }
      }));
      installDebouncedScroll(80, this.results);
      this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));
      $(this.container).on("change", ".select2-input", function(e) {
        e.stopPropagation();
      });
      $(this.dropdown).on("change", ".select2-input", function(e) {
        e.stopPropagation();
      });
      if ($.fn.mousewheel) {
        results.mousewheel(function(e, delta, deltaX, deltaY) {
          var top = results.scrollTop();
          if (deltaY > 0 && top - deltaY <= 0) {
            results.scrollTop(0);
            killEvent(e);
          } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
            results.scrollTop(results.get(0).scrollHeight - results.height());
            killEvent(e);
          }
        });
      }
      installKeyUpChangeEvent(search);
      search.on("keyup-change input paste", this.bind(this.updateResults));
      search.on("focus", function() {
        search.addClass("select2-focused");
      });
      search.on("blur", function() {
        search.removeClass("select2-focused");
      });
      this.dropdown.on("mouseup", resultsSelector, this.bind(function(e) {
        if ($(e.target).closest(".select2-result-selectable").length > 0) {
          this.highlightUnderEvent(e);
          this.selectHighlighted(e);
        }
      }));
      this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function(e) {
        e.stopPropagation();
      });
      this.nextSearchTerm = undefined;
      if ($.isFunction(this.opts.initSelection)) {
        this.initSelection();
        this.monitorSource();
      }
      if (opts.maximumInputLength !== null) {
        this.search.attr("maxlength", opts.maximumInputLength);
      }
      var disabled = opts.element.prop("disabled");
      if (disabled === undefined) disabled = false;
      this.enable(!disabled);
      var readonly = opts.element.prop("readonly");
      if (readonly === undefined) readonly = false;
      this.readonly(readonly);
      scrollBarDimensions = scrollBarDimensions || measureScrollbar();
      this.autofocus = opts.element.prop("autofocus");
      opts.element.prop("autofocus", false);
      if (this.autofocus) this.focus();
      this.search.attr("placeholder", opts.searchInputPlaceholder);
    },
    destroy: function() {
      var element = this.opts.element,
        select2 = element.data("select2"),
        self = this;
      this.close();
      if (element.length && element[0].detachEvent) {
        element.each(function() {
          this.detachEvent("onpropertychange", self._sync);
        });
      }
      if (this.propertyObserver) {
        this.propertyObserver.disconnect();
        this.propertyObserver = null;
      }
      this._sync = null;
      if (select2 !== undefined) {
        select2.container.remove();
        select2.liveRegion.remove();
        select2.dropdown.remove();
        element
          .removeClass("select2-offscreen")
          .removeData("select2")
          .off(".select2")
          .prop("autofocus", this.autofocus || false);
        if (this.elementTabIndex) {
          element.attr({
            tabindex: this.elementTabIndex
          });
        } else {
          element.removeAttr("tabindex");
        }
        element.show();
      }
      cleanupJQueryElements.call(this,
        "container",
        "liveRegion",
        "dropdown",
        "results",
        "search"
      );
    },
    optionToData: function(element) {
      if (element.is("option")) {
        return {
          id: element.prop("value"),
          text: element.text(),
          element: element.get(),
          css: element.attr("class"),
          disabled: element.prop("disabled"),
          locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
        };
      } else if (element.is("optgroup")) {
        return {
          text: element.attr("label"),
          children: [],
          element: element.get(),
          css: element.attr("class")
        };
      }
    },
    prepareOpts: function(opts) {
      var element, select, idKey, ajaxUrl, self = this;
      element = opts.element;
      if (element.get(0).tagName.toLowerCase() === "select") {
        this.select = select = opts.element;
      }
      if (select) {
        $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function() {
          if (this in opts) {
            throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
          }
        });
      }
      opts = $.extend({}, {
        populateResults: function(container, results, query) {
          var populate, id = this.opts.id,
            liveRegion = this.liveRegion;
          populate = function(results, container, depth) {
            var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;
            results = opts.sortResults(results, container, query);
            var nodes = [];
            for (i = 0, l = results.length; i < l; i = i + 1) {
              result = results[i];
              disabled = (result.disabled === true);
              selectable = (!disabled) && (id(result) !== undefined);
              compound = result.children && result.children.length > 0;
              node = $("<li></li>");
              node.addClass("select2-results-dept-" + depth);
              node.addClass("select2-result");
              node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
              if (disabled) {
                node.addClass("select2-disabled");
              }
              if (compound) {
                node.addClass("select2-result-with-children");
              }
              node.addClass(self.opts.formatResultCssClass(result));
              node.attr("role", "presentation");
              label = $(document.createElement("div"));
              label.addClass("select2-result-label");
              label.attr("id", "select2-result-label-" + nextUid());
              label.attr("role", "option");
              formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
              if (formatted !== undefined) {
                label.html(formatted);
                node.append(label);
              }
              if (compound) {
                innerContainer = $("<ul></ul>");
                innerContainer.addClass("select2-result-sub");
                populate(result.children, innerContainer, depth + 1);
                node.append(innerContainer);
              }
              node.data("select2-data", result);
              nodes.push(node[0]);
            }
            container.append(nodes);
            liveRegion.text(opts.formatMatches(results.length));
          };
          populate(results, container, 0);
        }
      }, $.fn.select2.defaults, opts);
      if (typeof(opts.id) !== "function") {
        idKey = opts.id;
        opts.id = function(e) {
          return e[idKey];
        };
      }
      if ($.isArray(opts.element.data("select2Tags"))) {
        if ("tags" in opts) {
          throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
        }
        opts.tags = opts.element.data("select2Tags");
      }
      if (select) {
        opts.query = this.bind(function(query) {
          var data = {
              results: [],
              more: false
            },
            term = query.term,
            children, placeholderOption, process;
          process = function(element, collection) {
            var group;
            if (element.is("option")) {
              if (query.matcher(term, element.text(), element)) {
                collection.push(self.optionToData(element));
              }
            } else if (element.is("optgroup")) {
              group = self.optionToData(element);
              element.children().each2(function(i, elm) {
                process(elm, group.children);
              });
              if (group.children.length > 0) {
                collection.push(group);
              }
            }
          };
          children = element.children();
          if (this.getPlaceholder() !== undefined && children.length > 0) {
            placeholderOption = this.getPlaceholderOption();
            if (placeholderOption) {
              children = children.not(placeholderOption);
            }
          }
          children.each2(function(i, elm) {
            process(elm, data.results);
          });
          query.callback(data);
        });
        opts.id = function(e) {
          return e.id;
        };
      } else {
        if (!("query" in opts)) {
          if ("ajax" in opts) {
            ajaxUrl = opts.element.data("ajax-url");
            if (ajaxUrl && ajaxUrl.length > 0) {
              opts.ajax.url = ajaxUrl;
            }
            opts.query = ajax.call(opts.element, opts.ajax);
          } else if ("data" in opts) {
            opts.query = local(opts.data);
          } else if ("tags" in opts) {
            opts.query = tags(opts.tags);
            if (opts.createSearchChoice === undefined) {
              opts.createSearchChoice = function(term) {
                return {
                  id: $.trim(term),
                  text: $.trim(term)
                };
              };
            }
            if (opts.initSelection === undefined) {
              opts.initSelection = function(element, callback) {
                var data = [];
                $(splitVal(element.val(), opts.separator)).each(function() {
                  var obj = {
                      id: this,
                      text: this
                    },
                    tags = opts.tags;
                  if ($.isFunction(tags)) tags = tags();
                  $(tags).each(function() {
                    if (equal(this.id, obj.id)) {
                      obj = this;
                      return false;
                    }
                  });
                  data.push(obj);
                });
                callback(data);
              };
            }
          }
        }
      }
      if (typeof(opts.query) !== "function") {
        throw "query function not defined for Select2 " + opts.element.attr("id");
      }
      if (opts.createSearchChoicePosition === 'top') {
        opts.createSearchChoicePosition = function(list, item) {
          list.unshift(item);
        };
      } else if (opts.createSearchChoicePosition === 'bottom') {
        opts.createSearchChoicePosition = function(list, item) {
          list.push(item);
        };
      } else if (typeof(opts.createSearchChoicePosition) !== "function") {
        throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
      }
      return opts;
    },
    monitorSource: function() {
      var el = this.opts.element,
        observer, self = this;
      el.on("change.select2", this.bind(function(e) {
        if (this.opts.element.data("select2-change-triggered") !== true) {
          this.initSelection();
        }
      }));
      this._sync = this.bind(function() {
        var disabled = el.prop("disabled");
        if (disabled === undefined) disabled = false;
        this.enable(!disabled);
        var readonly = el.prop("readonly");
        if (readonly === undefined) readonly = false;
        this.readonly(readonly);
        syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
        this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
        syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
        this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
      });
      if (el.length && el[0].attachEvent) {
        el.each(function() {
          this.attachEvent("onpropertychange", self._sync);
        });
      }
      observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
      if (observer !== undefined) {
        if (this.propertyObserver) {
          delete this.propertyObserver;
          this.propertyObserver = null;
        }
        this.propertyObserver = new observer(function(mutations) {
          $.each(mutations, self._sync);
        });
        this.propertyObserver.observe(el.get(0), {
          attributes: true,
          subtree: false
        });
      }
    },
    triggerSelect: function(data) {
      var evt = $.Event("select2-selecting", {
        val: this.id(data),
        object: data,
        choice: data
      });
      this.opts.element.trigger(evt);
      return !evt.isDefaultPrevented();
    },
    triggerChange: function(details) {
      details = details || {};
      details = $.extend({}, details, {
        type: "change",
        val: this.val()
      });
      this.opts.element.data("select2-change-triggered", true);
      this.opts.element.trigger(details);
      this.opts.element.data("select2-change-triggered", false);
      this.opts.element.click();
      if (this.opts.blurOnChange)
        this.opts.element.blur();
    },
    isInterfaceEnabled: function() {
      return this.enabledInterface === true;
    },
    enableInterface: function() {
      var enabled = this._enabled && !this._readonly,
        disabled = !enabled;
      if (enabled === this.enabledInterface) return false;
      this.container.toggleClass("select2-container-disabled", disabled);
      this.close();
      this.enabledInterface = enabled;
      return true;
    },
    enable: function(enabled) {
      if (enabled === undefined) enabled = true;
      if (this._enabled === enabled) return;
      this._enabled = enabled;
      this.opts.element.prop("disabled", !enabled);
      this.enableInterface();
    },
    disable: function() {
      this.enable(false);
    },
    readonly: function(enabled) {
      if (enabled === undefined) enabled = false;
      if (this._readonly === enabled) return;
      this._readonly = enabled;
      this.opts.element.prop("readonly", enabled);
      this.enableInterface();
    },
    opened: function() {
      return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
    },
    positionDropdown: function() {
      var $dropdown = this.dropdown,
        offset = this.container.offset(),
        height = this.container.outerHeight(false),
        width = this.container.outerWidth(false),
        dropHeight = $dropdown.outerHeight(false),
        $window = $(window),
        windowWidth = $window.width(),
        windowHeight = $window.height(),
        viewPortRight = $window.scrollLeft() + windowWidth,
        viewportBottom = $window.scrollTop() + windowHeight,
        dropTop = offset.top + height,
        dropLeft = offset.left,
        enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
        enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
        dropWidth = $dropdown.outerWidth(false),
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
        aboveNow = $dropdown.hasClass("select2-drop-above"),
        bodyOffset,
        above,
        changeDirection,
        css,
        resultsListNode;
      if (aboveNow) {
        above = true;
        if (!enoughRoomAbove && enoughRoomBelow) {
          changeDirection = true;
          above = false;
        }
      } else {
        above = false;
        if (!enoughRoomBelow && enoughRoomAbove) {
          changeDirection = true;
          above = true;
        }
      }
      if (changeDirection) {
        $dropdown.hide();
        offset = this.container.offset();
        height = this.container.outerHeight(false);
        width = this.container.outerWidth(false);
        dropHeight = $dropdown.outerHeight(false);
        viewPortRight = $window.scrollLeft() + windowWidth;
        viewportBottom = $window.scrollTop() + windowHeight;
        dropTop = offset.top + height;
        dropLeft = offset.left;
        dropWidth = $dropdown.outerWidth(false);
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
        $dropdown.show();
        this.focusSearch();
      }
      if (this.opts.dropdownAutoWidth) {
        resultsListNode = $('.select2-results', $dropdown)[0];
        $dropdown.addClass('select2-drop-auto-width');
        $dropdown.css('width', '');
        dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
        dropWidth > width ? width = dropWidth : dropWidth = width;
        dropHeight = $dropdown.outerHeight(false);
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
      } else {
        this.container.removeClass('select2-drop-auto-width');
      }
      if (this.body.css('position') !== 'static') {
        bodyOffset = this.body.offset();
        dropTop -= bodyOffset.top;
        dropLeft -= bodyOffset.left;
      }
      if (!enoughRoomOnRight) {
        dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
      }
      css = {
        left: dropLeft,
        width: width
      };
      if (above) {
        css.top = offset.top - dropHeight;
        css.bottom = 'auto';
        this.container.addClass("select2-drop-above");
        $dropdown.addClass("select2-drop-above");
      } else {
        css.top = dropTop;
        css.bottom = 'auto';
        this.container.removeClass("select2-drop-above");
        $dropdown.removeClass("select2-drop-above");
      }
      css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));
      $dropdown.css(css);
    },
    shouldOpen: function() {
      var event;
      if (this.opened()) return false;
      if (this._enabled === false || this._readonly === true) return false;
      event = $.Event("select2-opening");
      this.opts.element.trigger(event);
      return !event.isDefaultPrevented();
    },
    clearDropdownAlignmentPreference: function() {
      this.container.removeClass("select2-drop-above");
      this.dropdown.removeClass("select2-drop-above");
    },
    open: function() {
      if (!this.shouldOpen()) return false;
      this.opening();
      $document.on("mousemove.select2Event", function(e) {
        lastMousePosition.x = e.pageX;
        lastMousePosition.y = e.pageY;
      });
      return true;
    },
    opening: function() {
      var cid = this.containerEventName,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid,
        mask;
      this.container.addClass("select2-dropdown-open").addClass("select2-container-active");
      this.clearDropdownAlignmentPreference();
      if (this.dropdown[0] !== this.body.children().last()[0]) {
        this.dropdown.detach().appendTo(this.body);
      }
      mask = $("#select2-drop-mask");
      if (mask.length == 0) {
        mask = $(document.createElement("div"));
        mask.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask");
        mask.hide();
        mask.appendTo(this.body);
        mask.on("mousedown touchstart click", function(e) {
          reinsertElement(mask);
          var dropdown = $("#select2-drop"),
            self;
          if (dropdown.length > 0) {
            self = dropdown.data("select2");
            if (self.opts.selectOnBlur) {
              self.selectHighlighted({
                noFocus: true
              });
            }
            self.close();
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }
      if (this.dropdown.prev()[0] !== mask[0]) {
        this.dropdown.before(mask);
      }
      $("#select2-drop").removeAttr("id");
      this.dropdown.attr("id", "select2-drop");
      mask.show();
      this.positionDropdown();
      this.dropdown.show();
      this.positionDropdown();
      this.dropdown.addClass("select2-drop-active");
      var that = this;
      this.container.parents().add(window).each(function() {
        $(this).on(resize + " " + scroll + " " + orient, function(e) {
          if (that.opened()) that.positionDropdown();
        });
      });
    },
    close: function() {
      if (!this.opened()) return;
      var cid = this.containerEventName,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid;
      this.container.parents().add(window).each(function() {
        $(this).off(scroll).off(resize).off(orient);
      });
      this.clearDropdownAlignmentPreference();
      $("#select2-drop-mask").hide();
      this.dropdown.removeAttr("id");
      this.dropdown.hide();
      this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
      this.results.empty();
      $document.off("mousemove.select2Event");
      this.clearSearch();
      this.search.removeClass("select2-active");
      this.opts.element.trigger($.Event("select2-close"));
    },
    externalSearch: function(term) {
      this.open();
      this.search.val(term);
      this.updateResults(false);
    },
    clearSearch: function() {},
    getMaximumSelectionSize: function() {
      return evaluate(this.opts.maximumSelectionSize, this.opts.element);
    },
    ensureHighlightVisible: function() {
      var results = this.results,
        children, index, child, hb, rb, y, more, topOffset;
      index = this.highlight();
      if (index < 0) return;
      if (index == 0) {
        results.scrollTop(0);
        return;
      }
      children = this.findHighlightableChoices().find('.select2-result-label');
      child = $(children[index]);
      topOffset = (child.offset() || {}).top || 0;
      hb = topOffset + child.outerHeight(true);
      if (index === children.length - 1) {
        more = results.find("li.select2-more-results");
        if (more.length > 0) {
          hb = more.offset().top + more.outerHeight(true);
        }
      }
      rb = results.offset().top + results.outerHeight(true);
      if (hb > rb) {
        results.scrollTop(results.scrollTop() + (hb - rb));
      }
      y = topOffset - results.offset().top;
      if (y < 0 && child.css('display') != 'none') {
        results.scrollTop(results.scrollTop() + y);
      }
    },
    findHighlightableChoices: function() {
      return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
    },
    moveHighlight: function(delta) {
      var choices = this.findHighlightableChoices(),
        index = this.highlight();
      while (index > -1 && index < choices.length) {
        index += delta;
        var choice = $(choices[index]);
        if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
          this.highlight(index);
          break;
        }
      }
    },
    highlight: function(index) {
      var choices = this.findHighlightableChoices(),
        choice,
        data;
      if (arguments.length === 0) {
        return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
      }
      if (index >= choices.length) index = choices.length - 1;
      if (index < 0) index = 0;
      this.removeHighlight();
      choice = $(choices[index]);
      choice.addClass("select2-highlighted");
      this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));
      this.ensureHighlightVisible();
      this.liveRegion.text(choice.text());
      data = choice.data("select2-data");
      if (data) {
        this.opts.element.trigger({
          type: "select2-highlight",
          val: this.id(data),
          choice: data
        });
      }
    },
    removeHighlight: function() {
      this.results.find(".select2-highlighted").removeClass("select2-highlighted");
    },
    touchMoved: function() {
      this._touchMoved = true;
    },
    clearTouchMoved: function() {
      this._touchMoved = false;
    },
    countSelectableResults: function() {
      return this.findHighlightableChoices().length;
    },
    highlightUnderEvent: function(event) {
      var el = $(event.target).closest(".select2-result-selectable");
      if (el.length > 0 && !el.is(".select2-highlighted")) {
        var choices = this.findHighlightableChoices();
        this.highlight(choices.index(el));
      } else if (el.length == 0) {
        this.removeHighlight();
      }
    },
    loadMoreIfNeeded: function() {
      var results = this.results,
        more = results.find("li.select2-more-results"),
        below,
        page = this.resultsPage + 1,
        self = this,
        term = this.search.val(),
        context = this.context;
      if (more.length === 0) return;
      below = more.offset().top - results.offset().top - results.height();
      if (below <= this.opts.loadMorePadding) {
        more.addClass("select2-active");
        this.opts.query({
          element: this.opts.element,
          term: term,
          page: page,
          context: context,
          matcher: this.opts.matcher,
          callback: this.bind(function(data) {
            if (!self.opened()) return;
            self.opts.populateResults.call(this, results, data.results, {
              term: term,
              page: page,
              context: context
            });
            self.postprocessResults(data, false, false);
            if (data.more === true) {
              more.detach().appendTo(results).text(evaluate(self.opts.formatLoadMore, self.opts.element, page + 1));
              window.setTimeout(function() {
                self.loadMoreIfNeeded();
              }, 10);
            } else {
              more.remove();
            }
            self.positionDropdown();
            self.resultsPage = page;
            self.context = data.context;
            this.opts.element.trigger({
              type: "select2-loaded",
              items: data
            });
          })
        });
      }
    },
    tokenize: function() {},
    updateResults: function(initial) {
      var search = this.search,
        results = this.results,
        opts = this.opts,
        data,
        self = this,
        input,
        term = search.val(),
        lastTerm = $.data(this.container, "select2-last-term"),
        queryNumber;
      if (initial !== true && lastTerm && equal(term, lastTerm)) return;
      $.data(this.container, "select2-last-term", term);
      if (initial !== true && (this.showSearchInput === false || !this.opened())) {
        return;
      }

      function postRender() {
        search.removeClass("select2-active");
        self.positionDropdown();
        if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
          self.liveRegion.text(results.text());
        } else {
          self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable').length));
        }
      }

      function render(html) {
        results.html(html);
        postRender();
      }
      queryNumber = ++this.queryCount;
      var maxSelSize = this.getMaximumSelectionSize();
      if (maxSelSize >= 1) {
        data = this.data();
        if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
          render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
          return;
        }
      }
      if (search.val().length < opts.minimumInputLength) {
        if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
          render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
        } else {
          render("");
        }
        if (initial && this.showSearch) this.showSearch(true);
        return;
      }
      if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
        if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
          render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
        } else {
          render("");
        }
        return;
      }
      if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
        render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
      }
      search.addClass("select2-active");
      this.removeHighlight();
      input = this.tokenize();
      if (input != undefined && input != null) {
        search.val(input);
      }
      this.resultsPage = 1;
      opts.query({
        element: opts.element,
        term: search.val(),
        page: this.resultsPage,
        context: null,
        matcher: opts.matcher,
        callback: this.bind(function(data) {
          var def;
          if (queryNumber != this.queryCount) {
            return;
          }
          if (!this.opened()) {
            this.search.removeClass("select2-active");
            return;
          }
          if (data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
            render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
            return;
          }
          this.context = (data.context === undefined) ? null : data.context;
          if (this.opts.createSearchChoice && search.val() !== "") {
            def = this.opts.createSearchChoice.call(self, search.val(), data.results);
            if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
              if ($(data.results).filter(
                  function() {
                    return equal(self.id(this), self.id(def));
                  }).length === 0) {
                this.opts.createSearchChoicePosition(data.results, def);
              }
            }
          }
          if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
            render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
            return;
          }
          results.empty();
          self.opts.populateResults.call(this, results, data.results, {
            term: search.val(),
            page: this.resultsPage,
            context: null
          });
          if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
            results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
            window.setTimeout(function() {
              self.loadMoreIfNeeded();
            }, 10);
          }
          this.postprocessResults(data, initial);
          postRender();
          this.opts.element.trigger({
            type: "select2-loaded",
            items: data
          });
        })
      });
    },
    cancel: function() {
      this.close();
    },
    blur: function() {
      if (this.opts.selectOnBlur)
        this.selectHighlighted({
          noFocus: true
        });
      this.close();
      this.container.removeClass("select2-container-active");
      if (this.search[0] === document.activeElement) {
        this.search.blur();
      }
      this.clearSearch();
      this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
    },
    focusSearch: function() {
      focus(this.search);
    },
    selectHighlighted: function(options) {
      if (this._touchMoved) {
        this.clearTouchMoved();
        return;
      }
      var index = this.highlight(),
        highlighted = this.results.find(".select2-highlighted"),
        data = highlighted.closest('.select2-result').data("select2-data");
      if (data) {
        this.highlight(index);
        this.onSelect(data, options);
      } else if (options && options.noFocus) {
        this.close();
      }
    },
    getPlaceholder: function() {
      var placeholderOption;
      return this.opts.element.attr("placeholder") ||
        this.opts.element.attr("data-placeholder") ||
        this.opts.element.data("placeholder") ||
        this.opts.placeholder ||
        ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
    },
    getPlaceholderOption: function() {
      if (this.select) {
        var firstOption = this.select.children('option').first();
        if (this.opts.placeholderOption !== undefined) {
          return (this.opts.placeholderOption === "first" && firstOption) ||
            (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
        } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
          return firstOption;
        }
      }
    },
    initContainerWidth: function() {
      function resolveContainerWidth() {
        var style, attrs, matches, i, l, attr;
        if (this.opts.width === "off") {
          return null;
        } else if (this.opts.width === "element") {
          return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
        } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
          style = this.opts.element.attr('style');
          if (style !== undefined) {
            attrs = style.split(';');
            for (i = 0, l = attrs.length; i < l; i = i + 1) {
              attr = attrs[i].replace(/\s/g, '');
              matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
              if (matches !== null && matches.length >= 1)
                return matches[1];
            }
          }
          if (this.opts.width === "resolve") {
            style = this.opts.element.css('width');
            if (style.indexOf("%") > 0) return style;
            return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
          }
          return null;
        } else if ($.isFunction(this.opts.width)) {
          return this.opts.width();
        } else {
          return this.opts.width;
        }
      };
      var width = resolveContainerWidth.call(this);
      if (width !== null) {
        this.container.css("width", width);
      }
    }
  });
  SingleSelect2 = clazz(AbstractSelect2, {
    createContainer: function() {
      var container = $(document.createElement("div")).attr({
        "class": "select2-container"
      }).html([
        "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
        "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
        "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
        "</a>",
        "<label for='' class='select2-offscreen'></label>",
        "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
        "<div class='select2-drop select2-display-none'>",
        "   <div class='select2-search'>",
        "       <label for='' class='select2-offscreen'></label>",
        "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
        "       aria-autocomplete='list' />",
        "   </div>",
        "   <ul class='select2-results' role='listbox'>",
        "   </ul>",
        "</div>"
      ].join(""));
      return container;
    },
    enableInterface: function() {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.focusser.prop("disabled", !this.isInterfaceEnabled());
      }
    },
    opening: function() {
      var el, range, len;
      if (this.opts.minimumResultsForSearch >= 0) {
        this.showSearch(true);
      }
      this.parent.opening.apply(this, arguments);
      if (this.showSearchInput !== false) {
        this.search.val(this.focusser.val());
      }
      if (this.opts.shouldFocusInput(this)) {
        this.search.focus();
        el = this.search.get(0);
        if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        } else if (el.setSelectionRange) {
          len = this.search.val().length;
          el.setSelectionRange(len, len);
        }
      }
      if (this.search.val() === "") {
        if (this.nextSearchTerm != undefined) {
          this.search.val(this.nextSearchTerm);
          this.search.select();
        }
      }
      this.focusser.prop("disabled", true).val("");
      this.updateResults(true);
      this.opts.element.trigger($.Event("select2-open"));
    },
    close: function() {
      if (!this.opened()) return;
      this.parent.close.apply(this, arguments);
      this.focusser.prop("disabled", false);
      if (this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
    },
    focus: function() {
      if (this.opened()) {
        this.close();
      } else {
        this.focusser.prop("disabled", false);
        if (this.opts.shouldFocusInput(this)) {
          this.focusser.focus();
        }
      }
    },
    isFocused: function() {
      return this.container.hasClass("select2-container-active");
    },
    cancel: function() {
      this.parent.cancel.apply(this, arguments);
      this.focusser.prop("disabled", false);
      if (this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
    },
    destroy: function() {
      $("label[for='" + this.focusser.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
      this.parent.destroy.apply(this, arguments);
      cleanupJQueryElements.call(this,
        "selection",
        "focusser"
      );
    },
    initContainer: function() {
      var selection,
        container = this.container,
        dropdown = this.dropdown,
        idSuffix = nextUid(),
        elementLabel;
      if (this.opts.minimumResultsForSearch < 0) {
        this.showSearch(false);
      } else {
        this.showSearch(true);
      }
      this.selection = selection = container.find(".select2-choice");
      this.focusser = container.find(".select2-focusser");
      selection.find(".select2-chosen").attr("id", "select2-chosen-" + idSuffix);
      this.focusser.attr("aria-labelledby", "select2-chosen-" + idSuffix);
      this.results.attr("id", "select2-results-" + idSuffix);
      this.search.attr("aria-owns", "select2-results-" + idSuffix);
      this.focusser.attr("id", "s2id_autogen" + idSuffix);
      elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
      this.focusser.prev()
        .text(elementLabel.text())
        .attr('for', this.focusser.attr('id'));
      var originalTitle = this.opts.element.attr("title");
      this.opts.element.attr("title", (originalTitle || elementLabel.text()));
      this.focusser.attr("tabindex", this.elementTabIndex);
      this.search.attr("id", this.focusser.attr('id') + '_search');
      this.search.prev()
        .text($("label[for='" + this.focusser.attr('id') + "']").text())
        .attr('for', this.search.attr('id'));
      this.search.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if (229 == e.keyCode) return;
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
          return;
        }
        switch (e.which) {
          case KEY.UP:
          case KEY.DOWN:
            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
            killEvent(e);
            return;
          case KEY.ENTER:
            this.selectHighlighted();
            killEvent(e);
            return;
          case KEY.TAB:
            this.selectHighlighted({
              noFocus: true
            });
            return;
          case KEY.ESC:
            this.cancel(e);
            killEvent(e);
            return;
        }
      }));
      this.search.on("blur", this.bind(function(e) {
        if (document.activeElement === this.body.get(0)) {
          window.setTimeout(this.bind(function() {
            if (this.opened()) {
              this.search.focus();
            }
          }), 0);
        }
      }));
      this.focusser.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
          return;
        }
        if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
          killEvent(e);
          return;
        }
        if (e.which == KEY.DOWN || e.which == KEY.UP ||
          (e.which == KEY.ENTER && this.opts.openOnEnter)) {
          if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;
          this.open();
          killEvent(e);
          return;
        }
        if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
          if (this.opts.allowClear) {
            this.clear();
          }
          killEvent(e);
          return;
        }
      }));
      installKeyUpChangeEvent(this.focusser);
      this.focusser.on("keyup-change input", this.bind(function(e) {
        if (this.opts.minimumResultsForSearch >= 0) {
          e.stopPropagation();
          if (this.opened()) return;
          this.open();
        }
      }));
      selection.on("mousedown touchstart", "abbr", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        this.clear();
        killEventImmediately(e);
        this.close();
        this.selection.focus();
      }));
      selection.on("mousedown touchstart", this.bind(function(e) {
        reinsertElement(selection);
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        if (this.opened()) {
          this.close();
        } else if (this.isInterfaceEnabled()) {
          this.open();
        }
        killEvent(e);
      }));
      dropdown.on("mousedown touchstart", this.bind(function() {
        if (this.opts.shouldFocusInput(this)) {
          this.search.focus();
        }
      }));
      selection.on("focus", this.bind(function(e) {
        killEvent(e);
      }));
      this.focusser.on("focus", this.bind(function() {
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
      })).on("blur", this.bind(function() {
        if (!this.opened()) {
          this.container.removeClass("select2-container-active");
          this.opts.element.trigger($.Event("select2-blur"));
        }
      }));
      this.search.on("focus", this.bind(function() {
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
      }));
      this.initContainerWidth();
      this.opts.element.addClass("select2-offscreen");
      this.setPlaceholder();
    },
    clear: function(triggerChange) {
      var data = this.selection.data("select2-data");
      if (data) {
        var evt = $.Event("select2-clearing");
        this.opts.element.trigger(evt);
        if (evt.isDefaultPrevented()) {
          return;
        }
        var placeholderOption = this.getPlaceholderOption();
        this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
        this.selection.find(".select2-chosen").empty();
        this.selection.removeData("select2-data");
        this.setPlaceholder();
        if (triggerChange !== false) {
          this.opts.element.trigger({
            type: "select2-removed",
            val: this.id(data),
            choice: data
          });
          this.triggerChange({
            removed: data
          });
        }
      }
    },
    initSelection: function() {
      var selected;
      if (this.isPlaceholderOptionSelected()) {
        this.updateSelection(null);
        this.close();
        this.setPlaceholder();
      } else {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function(selected) {
          if (selected !== undefined && selected !== null) {
            self.updateSelection(selected);
            self.close();
            self.setPlaceholder();
            self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
          }
        });
      }
    },
    isPlaceholderOptionSelected: function() {
      var placeholderOption;
      if (this.getPlaceholder() === undefined) return false;
      return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected")) ||
        (this.opts.element.val() === "") ||
        (this.opts.element.val() === undefined) ||
        (this.opts.element.val() === null);
    },
    prepareOpts: function() {
      var opts = this.parent.prepareOpts.apply(this, arguments),
        self = this;
      if (opts.element.get(0).tagName.toLowerCase() === "select") {
        opts.initSelection = function(element, callback) {
          var selected = element.find("option").filter(function() {
            return this.selected && !this.disabled
          });
          callback(self.optionToData(selected));
        };
      } else if ("data" in opts) {
        opts.initSelection = opts.initSelection || function(element, callback) {
          var id = element.val();
          var match = null;
          opts.query({
            matcher: function(term, text, el) {
              var is_match = equal(id, opts.id(el));
              if (is_match) {
                match = el;
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function() {
              callback(match);
            }
          });
        };
      }
      return opts;
    },
    getPlaceholder: function() {
      if (this.select) {
        if (this.getPlaceholderOption() === undefined) {
          return undefined;
        }
      }
      return this.parent.getPlaceholder.apply(this, arguments);
    },
    setPlaceholder: function() {
      var placeholder = this.getPlaceholder();
      if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {
        if (this.select && this.getPlaceholderOption() === undefined) return;
        this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));
        this.selection.addClass("select2-default");
        this.container.removeClass("select2-allowclear");
      }
    },
    postprocessResults: function(data, initial, noHighlightUpdate) {
      var selected = 0,
        self = this,
        showSearchInput = true;
      this.findHighlightableChoices().each2(function(i, elm) {
        if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
          selected = i;
          return false;
        }
      });
      if (noHighlightUpdate !== false) {
        if (initial === true && selected >= 0) {
          this.highlight(selected);
        } else {
          this.highlight(0);
        }
      }
      if (initial === true) {
        var min = this.opts.minimumResultsForSearch;
        if (min >= 0) {
          this.showSearch(countResults(data.results) >= min);
        }
      }
    },
    showSearch: function(showSearchInput) {
      if (this.showSearchInput === showSearchInput) return;
      this.showSearchInput = showSearchInput;
      this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
      this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
      $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
    },
    onSelect: function(data, options) {
      if (!this.triggerSelect(data)) {
        return;
      }
      var old = this.opts.element.val(),
        oldData = this.data();
      this.opts.element.val(this.id(data));
      this.updateSelection(data);
      this.opts.element.trigger({
        type: "select2-selected",
        val: this.id(data),
        choice: data
      });
      this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
      this.close();
      if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
      if (!equal(old, this.id(data))) {
        this.triggerChange({
          added: data,
          removed: oldData
        });
      }
    },
    updateSelection: function(data) {
      var container = this.selection.find(".select2-chosen"),
        formatted, cssClass;
      this.selection.data("select2-data", data);
      container.empty();
      if (data !== null) {
        formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
      }
      if (formatted !== undefined) {
        container.append(formatted);
      }
      cssClass = this.opts.formatSelectionCssClass(data, container);
      if (cssClass !== undefined) {
        container.addClass(cssClass);
      }
      this.selection.removeClass("select2-default");
      if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
        this.container.addClass("select2-allowclear");
      }
    },
    val: function() {
      var val,
        triggerChange = false,
        data = null,
        self = this,
        oldData = this.data();
      if (arguments.length === 0) {
        return this.opts.element.val();
      }
      val = arguments[0];
      if (arguments.length > 1) {
        triggerChange = arguments[1];
      }
      if (this.select) {
        this.select
          .val(val)
          .find("option").filter(function() {
            return this.selected
          }).each2(function(i, elm) {
            data = self.optionToData(elm);
            return false;
          });
        this.updateSelection(data);
        this.setPlaceholder();
        if (triggerChange) {
          this.triggerChange({
            added: data,
            removed: oldData
          });
        }
      } else {
        if (!val && val !== 0) {
          this.clear(triggerChange);
          return;
        }
        if (this.opts.initSelection === undefined) {
          throw new Error("cannot call val() if initSelection() is not defined");
        }
        this.opts.element.val(val);
        this.opts.initSelection(this.opts.element, function(data) {
          self.opts.element.val(!data ? "" : self.id(data));
          self.updateSelection(data);
          self.setPlaceholder();
          if (triggerChange) {
            self.triggerChange({
              added: data,
              removed: oldData
            });
          }
        });
      }
    },
    clearSearch: function() {
      this.search.val("");
      this.focusser.val("");
    },
    data: function(value) {
      var data,
        triggerChange = false;
      if (arguments.length === 0) {
        data = this.selection.data("select2-data");
        if (data == undefined) data = null;
        return data;
      } else {
        if (arguments.length > 1) {
          triggerChange = arguments[1];
        }
        if (!value) {
          this.clear(triggerChange);
        } else {
          data = this.data();
          this.opts.element.val(!value ? "" : this.id(value));
          this.updateSelection(value);
          if (triggerChange) {
            this.triggerChange({
              added: value,
              removed: data
            });
          }
        }
      }
    }
  });
  MultiSelect2 = clazz(AbstractSelect2, {
    createContainer: function() {
      var container = $(document.createElement("div")).attr({
        "class": "select2-container select2-container-multi"
      }).html([
        "<ul class='select2-choices'>",
        "  <li class='select2-search-field'>",
        "    <label for='' class='select2-offscreen'></label>",
        "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
        "  </li>",
        "</ul>",
        "<div class='select2-drop select2-drop-multi select2-display-none'>",
        "   <ul class='select2-results'>",
        "   </ul>",
        "</div>"
      ].join(""));
      return container;
    },
    prepareOpts: function() {
      var opts = this.parent.prepareOpts.apply(this, arguments),
        self = this;
      if (opts.element.get(0).tagName.toLowerCase() === "select") {
        opts.initSelection = function(element, callback) {
          var data = [];
          element.find("option").filter(function() {
            return this.selected && !this.disabled
          }).each2(function(i, elm) {
            data.push(self.optionToData(elm));
          });
          callback(data);
        };
      } else if ("data" in opts) {
        opts.initSelection = opts.initSelection || function(element, callback) {
          var ids = splitVal(element.val(), opts.separator);
          var matches = [];
          opts.query({
            matcher: function(term, text, el) {
              var is_match = $.grep(ids, function(id) {
                return equal(id, opts.id(el));
              }).length;
              if (is_match) {
                matches.push(el);
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function() {
              var ordered = [];
              for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];
                  if (equal(id, opts.id(match))) {
                    ordered.push(match);
                    matches.splice(j, 1);
                    break;
                  }
                }
              }
              callback(ordered);
            }
          });
        };
      }
      return opts;
    },
    selectChoice: function(choice) {
      var selected = this.container.find(".select2-search-choice-focus");
      if (selected.length && choice && choice[0] == selected[0]) {} else {
        if (selected.length) {
          this.opts.element.trigger("choice-deselected", selected);
        }
        selected.removeClass("select2-search-choice-focus");
        if (choice && choice.length) {
          this.close();
          choice.addClass("select2-search-choice-focus");
          this.opts.element.trigger("choice-selected", choice);
        }
      }
    },
    destroy: function() {
      $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
      this.parent.destroy.apply(this, arguments);
      cleanupJQueryElements.call(this,
        "searchContainer",
        "selection"
      );
    },
    initContainer: function() {
      var selector = ".select2-choices",
        selection;
      this.searchContainer = this.container.find(".select2-search-field");
      this.selection = selection = this.container.find(selector);
      var _this = this;
      this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function(e) {
        _this.search[0].focus();
        _this.selectChoice($(this));
      });
      this.search.attr("id", "s2id_autogen" + nextUid());
      this.search.prev()
        .text($("label[for='" + this.opts.element.attr("id") + "']").text())
        .attr('for', this.search.attr('id'));
      this.search.on("input paste", this.bind(function() {
        if (this.search.attr('placeholder') && this.search.val().length == 0) return;
        if (!this.isInterfaceEnabled()) return;
        if (!this.opened()) {
          this.open();
        }
      }));
      this.search.attr("tabindex", this.elementTabIndex);
      this.keydowns = 0;
      this.search.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        ++this.keydowns;
        var selected = selection.find(".select2-search-choice-focus");
        var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
        var next = selected.next(".select2-search-choice:not(.select2-locked)");
        var pos = getCursorInfo(this.search);
        if (selected.length &&
          (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
          var selectedChoice = selected;
          if (e.which == KEY.LEFT && prev.length) {
            selectedChoice = prev;
          } else if (e.which == KEY.RIGHT) {
            selectedChoice = next.length ? next : null;
          } else if (e.which === KEY.BACKSPACE) {
            if (this.unselect(selected.first())) {
              this.search.width(10);
              selectedChoice = prev.length ? prev : next;
            }
          } else if (e.which == KEY.DELETE) {
            if (this.unselect(selected.first())) {
              this.search.width(10);
              selectedChoice = next.length ? next : null;
            }
          } else if (e.which == KEY.ENTER) {
            selectedChoice = null;
          }
          this.selectChoice(selectedChoice);
          killEvent(e);
          if (!selectedChoice || !selectedChoice.length) {
            this.open();
          }
          return;
        } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1) ||
            e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {
          this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
          killEvent(e);
          return;
        } else {
          this.selectChoice(null);
        }
        if (this.opened()) {
          switch (e.which) {
            case KEY.UP:
            case KEY.DOWN:
              this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
              killEvent(e);
              return;
            case KEY.ENTER:
              this.selectHighlighted();
              killEvent(e);
              return;
            case KEY.TAB:
              this.selectHighlighted({
                noFocus: true
              });
              this.close();
              return;
            case KEY.ESC:
              this.cancel(e);
              killEvent(e);
              return;
          }
        }
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) ||
          e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
          return;
        }
        if (e.which === KEY.ENTER) {
          if (this.opts.openOnEnter === false) {
            return;
          } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
            return;
          }
        }
        this.open();
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
        }
        if (e.which === KEY.ENTER) {
          killEvent(e);
        }
      }));
      this.search.on("keyup", this.bind(function(e) {
        this.keydowns = 0;
        this.resizeSearch();
      }));
      this.search.on("blur", this.bind(function(e) {
        this.container.removeClass("select2-container-active");
        this.search.removeClass("select2-focused");
        this.selectChoice(null);
        if (!this.opened()) this.clearSearch();
        e.stopImmediatePropagation();
        this.opts.element.trigger($.Event("select2-blur"));
      }));
      this.container.on("click", selector, this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if ($(e.target).closest(".select2-search-choice").length > 0) {
          return;
        }
        this.selectChoice(null);
        this.clearPlaceholder();
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.open();
        this.focusSearch();
        e.preventDefault();
      }));
      this.container.on("focus", selector, this.bind(function() {
        if (!this.isInterfaceEnabled()) return;
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
        this.dropdown.addClass("select2-drop-active");
        this.clearPlaceholder();
      }));
      this.initContainerWidth();
      this.opts.element.addClass("select2-offscreen");
      this.clearSearch();
    },
    enableInterface: function() {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.search.prop("disabled", !this.isInterfaceEnabled());
      }
    },
    initSelection: function() {
      var data;
      if (this.opts.element.val() === "" && this.opts.element.text() === "") {
        this.updateSelection([]);
        this.close();
        this.clearSearch();
      }
      if (this.select || this.opts.element.val() !== "") {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function(data) {
          if (data !== undefined && data !== null) {
            self.updateSelection(data);
            self.close();
            self.clearSearch();
          }
        });
      }
    },
    clearSearch: function() {
      var placeholder = this.getPlaceholder(),
        maxWidth = this.getMaxSearchWidth();
      if (placeholder !== undefined && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
        this.search.val(placeholder).addClass("select2-default");
        this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
      } else {
        this.search.val("").width(10);
      }
    },
    clearPlaceholder: function() {
      if (this.search.hasClass("select2-default")) {
        this.search.val("").removeClass("select2-default");
      }
    },
    opening: function() {
      this.clearPlaceholder();
      this.resizeSearch();
      this.parent.opening.apply(this, arguments);
      this.focusSearch();
      if (this.search.val() === "") {
        if (this.nextSearchTerm != undefined) {
          this.search.val(this.nextSearchTerm);
          this.search.select();
        }
      }
      this.updateResults(true);
      if (this.opts.shouldFocusInput(this)) {
        this.search.focus();
      }
      this.opts.element.trigger($.Event("select2-open"));
    },
    close: function() {
      if (!this.opened()) return;
      this.parent.close.apply(this, arguments);
    },
    focus: function() {
      this.close();
      this.search.focus();
    },
    isFocused: function() {
      return this.search.hasClass("select2-focused");
    },
    updateSelection: function(data) {
      var ids = [],
        filtered = [],
        self = this;
      $(data).each(function() {
        if (indexOf(self.id(this), ids) < 0) {
          ids.push(self.id(this));
          filtered.push(this);
        }
      });
      data = filtered;
      this.selection.find(".select2-search-choice").remove();
      $(data).each(function() {
        self.addSelectedChoice(this);
      });
      self.postprocessResults();
    },
    tokenize: function() {
      var input = this.search.val();
      input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
      if (input != null && input != undefined) {
        this.search.val(input);
        if (input.length > 0) {
          this.open();
        }
      }
    },
    onSelect: function(data, options) {
      if (!this.triggerSelect(data) || data.text === "") {
        return;
      }
      this.addSelectedChoice(data);
      this.opts.element.trigger({
        type: "selected",
        val: this.id(data),
        choice: data
      });
      this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
      this.clearSearch();
      this.updateResults();
      if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect === true);
      if (this.opts.closeOnSelect) {
        this.close();
        this.search.width(10);
      } else {
        if (this.countSelectableResults() > 0) {
          this.search.width(10);
          this.resizeSearch();
          if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
            this.updateResults(true);
          } else {
            if (this.nextSearchTerm != undefined) {
              this.search.val(this.nextSearchTerm);
              this.updateResults();
              this.search.select();
            }
          }
          this.positionDropdown();
        } else {
          this.close();
          this.search.width(10);
        }
      }
      this.triggerChange({
        added: data
      });
      if (!options || !options.noFocus)
        this.focusSearch();
    },
    cancel: function() {
      this.close();
      this.focusSearch();
    },
    addSelectedChoice: function(data) {
      var enableChoice = !data.locked,
        enabledItem = $(
          "<li class='select2-search-choice'>" +
          "    <div></div>" +
          "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
          "</li>"),
        disabledItem = $(
          "<li class='select2-search-choice select2-locked'>" +
          "<div></div>" +
          "</li>");
      var choice = enableChoice ? enabledItem : disabledItem,
        id = this.id(data),
        val = this.getVal(),
        formatted,
        cssClass;
      formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
      if (formatted != undefined) {
        choice.find("div").replaceWith("<div>" + formatted + "</div>");
      }
      cssClass = this.opts.formatSelectionCssClass(data, choice.find("div"));
      if (cssClass != undefined) {
        choice.addClass(cssClass);
      }
      if (enableChoice) {
        choice.find(".select2-search-choice-close")
          .on("mousedown", killEvent)
          .on("click dblclick", this.bind(function(e) {
            if (!this.isInterfaceEnabled()) return;
            this.unselect($(e.target));
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
            killEvent(e);
            this.close();
            this.focusSearch();
          })).on("focus", this.bind(function() {
            if (!this.isInterfaceEnabled()) return;
            this.container.addClass("select2-container-active");
            this.dropdown.addClass("select2-drop-active");
          }));
      }
      choice.data("select2-data", data);
      choice.insertBefore(this.searchContainer);
      val.push(id);
      this.setVal(val);
    },
    unselect: function(selected) {
      var val = this.getVal(),
        data,
        index;
      selected = selected.closest(".select2-search-choice");
      if (selected.length === 0) {
        throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
      }
      data = selected.data("select2-data");
      if (!data) {
        return;
      }
      var evt = $.Event("select2-removing");
      evt.val = this.id(data);
      evt.choice = data;
      this.opts.element.trigger(evt);
      if (evt.isDefaultPrevented()) {
        return false;
      }
      while ((index = indexOf(this.id(data), val)) >= 0) {
        val.splice(index, 1);
        this.setVal(val);
        if (this.select) this.postprocessResults();
      }
      selected.remove();
      this.opts.element.trigger({
        type: "select2-removed",
        val: this.id(data),
        choice: data
      });
      this.triggerChange({
        removed: data
      });
      return true;
    },
    postprocessResults: function(data, initial, noHighlightUpdate) {
      var val = this.getVal(),
        choices = this.results.find(".select2-result"),
        compound = this.results.find(".select2-result-with-children"),
        self = this;
      choices.each2(function(i, choice) {
        var id = self.id(choice.data("select2-data"));
        if (indexOf(id, val) >= 0) {
          choice.addClass("select2-selected");
          choice.find(".select2-result-selectable").addClass("select2-selected");
        }
      });
      compound.each2(function(i, choice) {
        if (!choice.is('.select2-result-selectable') &&
          choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
          choice.addClass("select2-selected");
        }
      });
      if (this.highlight() == -1 && noHighlightUpdate !== false) {
        self.highlight(0);
      }
      if (!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0) {
        if (!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
          if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
            this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
          }
        }
      }
    },
    getMaxSearchWidth: function() {
      return this.selection.width() - getSideBorderPadding(this.search);
    },
    resizeSearch: function() {
      var minimumWidth, left, maxWidth, containerLeft, searchWidth,
        sideBorderPadding = getSideBorderPadding(this.search);
      minimumWidth = measureTextWidth(this.search) + 10;
      left = this.search.offset().left;
      maxWidth = this.selection.width();
      containerLeft = this.selection.offset().left;
      searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
      if (searchWidth < minimumWidth) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth < 40) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth <= 0) {
        searchWidth = minimumWidth;
      }
      this.search.width(Math.floor(searchWidth));
    },
    getVal: function() {
      var val;
      if (this.select) {
        val = this.select.val();
        return val === null ? [] : val;
      } else {
        val = this.opts.element.val();
        return splitVal(val, this.opts.separator);
      }
    },
    setVal: function(val) {
      var unique;
      if (this.select) {
        this.select.val(val);
      } else {
        unique = [];
        $(val).each(function() {
          if (indexOf(this, unique) < 0) unique.push(this);
        });
        this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
      }
    },
    buildChangeDetails: function(old, current) {
      var current = current.slice(0),
        old = old.slice(0);
      for (var i = 0; i < current.length; i++) {
        for (var j = 0; j < old.length; j++) {
          if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
            current.splice(i, 1);
            if (i > 0) {
              i--;
            }
            old.splice(j, 1);
            j--;
          }
        }
      }
      return {
        added: current,
        removed: old
      };
    },
    val: function(val, triggerChange) {
      var oldData, self = this;
      if (arguments.length === 0) {
        return this.getVal();
      }
      oldData = this.data();
      if (!oldData.length) oldData = [];
      if (!val && val !== 0) {
        this.opts.element.val("");
        this.updateSelection([]);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange({
            added: this.data(),
            removed: oldData
          });
        }
        return;
      }
      this.setVal(val);
      if (this.select) {
        this.opts.initSelection(this.select, this.bind(this.updateSelection));
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(oldData, this.data()));
        }
      } else {
        if (this.opts.initSelection === undefined) {
          throw new Error("val() cannot be called if initSelection() is not defined");
        }
        this.opts.initSelection(this.opts.element, function(data) {
          var ids = $.map(data, self.id);
          self.setVal(ids);
          self.updateSelection(data);
          self.clearSearch();
          if (triggerChange) {
            self.triggerChange(self.buildChangeDetails(oldData, self.data()));
          }
        });
      }
      this.clearSearch();
    },
    onSortStart: function() {
      if (this.select) {
        throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
      }
      this.search.width(0);
      this.searchContainer.hide();
    },
    onSortEnd: function() {
      var val = [],
        self = this;
      this.searchContainer.show();
      this.searchContainer.appendTo(this.searchContainer.parent());
      this.resizeSearch();
      this.selection.find(".select2-search-choice").each(function() {
        val.push(self.opts.id($(this).data("select2-data")));
      });
      this.setVal(val);
      this.triggerChange();
    },
    data: function(values, triggerChange) {
      var self = this,
        ids, old;
      if (arguments.length === 0) {
        return this.selection
          .children(".select2-search-choice")
          .map(function() {
            return $(this).data("select2-data");
          })
          .get();
      } else {
        old = this.data();
        if (!values) {
          values = [];
        }
        ids = $.map(values, function(e) {
          return self.opts.id(e);
        });
        this.setVal(ids);
        this.updateSelection(values);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(old, this.data()));
        }
      }
    }
  });
  $.fn.select2 = function() {
    var args = Array.prototype.slice.call(arguments, 0),
      opts,
      select2,
      method, value, multiple,
      allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
      valueMethods = ["opened", "isFocused", "container", "dropdown"],
      propertyMethods = ["val", "data"],
      methodsMap = {
        search: "externalSearch"
      };
    this.each(function() {
      if (args.length === 0 || typeof(args[0]) === "object") {
        opts = args.length === 0 ? {} : $.extend({}, args[0]);
        opts.element = $(this);
        if (opts.element.get(0).tagName.toLowerCase() === "select") {
          multiple = opts.element.prop("multiple");
        } else {
          multiple = opts.multiple || false;
          if ("tags" in opts) {
            opts.multiple = multiple = true;
          }
        }
        select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
        select2.init(opts);
      } else if (typeof(args[0]) === "string") {
        if (indexOf(args[0], allowedMethods) < 0) {
          throw "Unknown method: " + args[0];
        }
        value = undefined;
        select2 = $(this).data("select2");
        if (select2 === undefined) return;
        method = args[0];
        if (method === "container") {
          value = select2.container;
        } else if (method === "dropdown") {
          value = select2.dropdown;
        } else {
          if (methodsMap[method]) method = methodsMap[method];
          value = select2[method].apply(select2, args.slice(1));
        }
        if (indexOf(args[0], valueMethods) >= 0 ||
          (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
          return false;
        }
      } else {
        throw "Invalid arguments to select2 plugin: " + args;
      }
    });
    return (value === undefined) ? this : value;
  };
  $.fn.select2.defaults = {
    width: "copy",
    loadMorePadding: 0,
    closeOnSelect: true,
    openOnEnter: true,
    containerCss: {},
    dropdownCss: {},
    containerCssClass: "",
    dropdownCssClass: "",
    formatResult: function(result, container, query, escapeMarkup) {
      var markup = [];
      markMatch(result.text, query.term, markup, escapeMarkup);
      return markup.join("");
    },
    formatSelection: function(data, container, escapeMarkup) {
      return data ? escapeMarkup(data.text) : undefined;
    },
    sortResults: function(results, container, query) {
      return results;
    },
    formatResultCssClass: function(data) {
      return data.css;
    },
    formatSelectionCssClass: function(data, container) {
      return undefined;
    },
    minimumResultsForSearch: 0,
    minimumInputLength: 0,
    maximumInputLength: null,
    maximumSelectionSize: 0,
    id: function(e) {
      return e == undefined ? null : e.id;
    },
    matcher: function(term, text) {
      return stripDiacritics('' + text).toUpperCase().indexOf(stripDiacritics('' + term).toUpperCase()) >= 0;
    },
    separator: ",",
    tokenSeparators: [],
    tokenizer: defaultTokenizer,
    escapeMarkup: defaultEscapeMarkup,
    blurOnChange: false,
    selectOnBlur: false,
    adaptContainerCssClass: function(c) {
      return c;
    },
    adaptDropdownCssClass: function(c) {
      return null;
    },
    nextSearchTerm: function(selectedObject, currentSearchTerm) {
      return undefined;
    },
    searchInputPlaceholder: '',
    createSearchChoicePosition: 'top',
    shouldFocusInput: function(instance) {
      var supportsTouchEvents = (('ontouchstart' in window) ||
        (navigator.msMaxTouchPoints > 0));
      if (!supportsTouchEvents) {
        return true;
      }
      if (instance.opts.minimumResultsForSearch < 0) {
        return false;
      }
      return true;
    }
  };
  $.fn.select2.locales = [];
  $.fn.select2.locales['en'] = {
    formatMatches: function(matches) {
      if (matches === 1) {
        return "One result is available, press enter to select it.";
      }
      return matches + " results are available, use up and down arrow keys to navigate.";
    },
    formatNoMatches: function() {
      return "No matches found";
    },
    formatAjaxError: function(jqXHR, textStatus, errorThrown) {
      return "Loading failed";
    },
    formatInputTooShort: function(input, min) {
      var n = min - input.length;
      return "Please enter " + n + " or more character" + (n == 1 ? "" : "s");
    },
    formatInputTooLong: function(input, max) {
      var n = input.length - max;
      return "Please delete " + n + " character" + (n == 1 ? "" : "s");
    },
    formatSelectionTooBig: function(limit) {
      return "You can only select " + limit + " item" + (limit == 1 ? "" : "s");
    },
    formatLoadMore: function(pageNumber) {
      return "Loading more results";
    },
    formatSearching: function() {
      return "Searching";
    },
  };
  $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);
  $.fn.select2.ajaxDefaults = {
    transport: $.ajax,
    params: {
      type: "GET",
      cache: false,
      dataType: "json"
    }
  };
  window.Select2 = {
    query: {
      ajax: ajax,
      local: local,
      tags: tags
    },
    util: {
      debounce: debounce,
      markMatch: markMatch,
      escapeMarkup: defaultEscapeMarkup,
      stripDiacritics: stripDiacritics
    },
    "class": {
      "abstract": AbstractSelect2,
      "single": SingleSelect2,
      "multi": MultiSelect2
    }
  };
}(jQuery));;
/*! RESOURCE: /scripts/sp.geo.js */
function spLoadMaps() {
  if (typeof g_google_maps_api_loaded == "undefined") {
    spLoadScript('https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true&callback=initMap');
    g_google_maps_api_loaded = true;
  } else
    CustomEvent.fireAll('map.initialized');
}

function spLoadScript(url) {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = url;
  document.body.appendChild(script);
}

function initMap() {
  CustomEvent.fireAll('map.initialized');
};
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i < array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i < _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j < types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i < _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i < _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &&
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length < this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index >= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length > 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses && responses.length > 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i < _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length > 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength > _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length > 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i < lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout > 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null && webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel && !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j < messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index >= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length > 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect && _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported && !!org.cometd.WebSocket && _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i < envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i < arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep && typeof prop === 'object' && prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort && hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined && afterURI.length > 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions && subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription && !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i < subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '->', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i < _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions && subscriptions.length > 0) {
      for (var i = 0; i < subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i > 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined && message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch > 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff < _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length > 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch < 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length > 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() && _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i >= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription && !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i < rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i < messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i < subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length < 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length < 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i < _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport && typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' && define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON && JSON.stringify) || (window.jaredJSON && window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON && JSON.parse) || (window.jaredJSON && window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' && define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    if (window.console)
      console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i < _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i < _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i < subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out',
    SESSION_INVALIDATED: 'session.invalidated'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log(">>> connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -> ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected && connected)
      _connectionOpened();
    else if (wasConnected && !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        case 'session.invalidated':
          if (loggedIn)
            _invalidated();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }

  function _invalidated() {
    loggedIn = false;
    LOGGER.debug("INVALIDATED event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_INVALIDATED);
  }
  var modalContent = '<iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"></iframe>';
  var modalTemplate = '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '  <div class="modal-dialog small-modal" style="width:450px">' +
    '     <div class="modal-content">' +
    '        <header class="modal-header">' +
    '           <h4 id="small_modal1_title" class="modal-title">Login</h4>' +
    '        </header>' +
    '        <div class="modal-body">' +
    '        </div>' +
    '     </div>' +
    '  </div>' +
    '</div>';

  function _loginShow() {
    LOGGER.debug("Show login window");
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i < window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event && connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, this._subscribeWhenReady.bind(this));
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription && _initialized)
        this.subscribeToCometD();
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i < listeners.length; i++)
        listeners[i].resubscribe();
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    _handleResponse: function(message) {
      for (var i = 0; i < listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length < 1 && subscription && !_disconnected())
        this.unsubscribeFromCometD();
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    subscribeToCometD: function() {
      subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
      LOGGER.debug('Successfully subscribed to channel: ' + channelName);
    },
    unsubscribeFromCometD: function() {
      cometd.unsubscribe(subscription);
      subscription = null;
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    resubscribeToCometD: function() {
      this.subscribeToCometD();
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_OUT, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_INVALIDATED, _unsubscribeAll);
    serverConnection.subscribeToEvent(serverConnection.getEvents().SESSION_LOGGED_IN, _resubscribeAll);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i < uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          _resubscribeAll()
          _connectionBrokenEvent = false;
        });
      }
    }

    function _unsubscribeAll() {
      LOGGER.debug("Unsubscribing from all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.unsubscribeFromCometD();
      }
    }

    function _resubscribeAll() {
      LOGGER.debug("Resubscribing to all!");
      for (var name in channels) {
        var channel = channels[name];
        channel.resubscribeToCometD();
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage(">>> connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(window.jQuery || window.Zepto);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext && document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(window.jQuery || window.Zepto);;;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  ambClient = amb.getClient();
  if (_window.g_ambClient) {
    sameScope = true;
  }
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow && loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB && state !== "opened" && state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log(">>> init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log(">>> record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i < len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i < len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos >= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '<div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog">' +
    '	<div class="modal-dialog small-modal" style="width:450px">' +
    '		<div class="modal-content">' +
    '			<header class="modal-header">' +
    '				<h4 id="small_modal1_title" class="modal-title">{{title || "Login"}}</h4>' +
    '			</header>' +
    '			<div class="modal-body">' +
    '			<iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"></iframe>' +
    '			</div>' +
    '		</div>' +
    '	</div>' +
    '</div>'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/bootstrap-datetimepicker.js */
;
(function(root, factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['jquery', 'moment'], factory);
  } else if (typeof exports === 'object') {
    factory(require('jquery'), require('moment'));
  } else {
    if (!jQuery) {
      throw new Error('bootstrap-datetimepicker requires jQuery to be loaded first');
    }
    if (!moment) {
      throw new Error('bootstrap-datetimepicker requires moment.js to be loaded first');
    }
    factory(root.jQuery, moment);
  }
}(this, function($, moment) {
  'use strict';
  if (typeof moment === 'undefined') {
    throw new Error('momentjs is required');
  }
  var dpgId = 0,
    DateTimePicker = function(element, options) {
      var defaults = $.fn.datetimepicker.defaults,
        icons = {
          time: 'glyphicon glyphicon-time',
          date: 'glyphicon glyphicon-calendar',
          up: 'glyphicon glyphicon-chevron-up',
          down: 'glyphicon glyphicon-chevron-down'
        },
        picker = this,
        errored = false,
        dDate,
        init = function() {
          var icon = false,
            localeData, rInterval;
          picker.options = $.extend({}, defaults, options);
          picker.options.icons = $.extend({}, icons, picker.options.icons);
          picker.element = $(element);
          dataToOptions();
          if (!(picker.options.pickTime || picker.options.pickDate)) {
            throw new Error('Must choose at least one picker');
          }
          picker.id = dpgId++;
          moment.locale(picker.options.language);
          picker.date = moment();
          picker.unset = false;
          picker.isInput = picker.element.is('input');
          picker.component = false;
          if (picker.element.hasClass('input-group')) {
            if (picker.element.find('.datepickerbutton').size() === 0) {
              picker.component = picker.element.find('[class^="input-group-"]');
            } else {
              picker.component = picker.element.find('.datepickerbutton');
            }
          }
          picker.format = picker.options.format;
          localeData = moment().localeData();
          if (!picker.format) {
            picker.format = (picker.options.pickDate ? localeData.longDateFormat('L') : '');
            if (picker.options.pickDate && picker.options.pickTime) {
              picker.format += ' ';
            }
            picker.format += (picker.options.pickTime ? localeData.longDateFormat('LT') : '');
            if (picker.options.useSeconds) {
              if (localeData.longDateFormat('LT').indexOf(' A') !== -1) {
                picker.format = picker.format.split(' A')[0] + ':ss A';
              } else {
                picker.format += ':ss';
              }
            }
          }
          picker.use24hours = (picker.format.toLowerCase().indexOf('a') < 0 && picker.format.indexOf('h') < 0);
          if (picker.component) {
            icon = picker.component.find('span');
          }
          if (picker.options.pickTime) {
            if (icon) {
              icon.addClass(picker.options.icons.time);
            }
          }
          if (picker.options.pickDate) {
            if (icon) {
              icon.removeClass(picker.options.icons.time);
              icon.addClass(picker.options.icons.date);
            }
          }
          picker.options.widgetParent =
            typeof picker.options.widgetParent === 'string' && picker.options.widgetParent ||
            picker.element.parents().filter(function() {
              return 'scroll' === $(this).css('overflow-y');
            }).get(0) ||
            'body';
          picker.widget = $(getTemplate()).appendTo(picker.options.widgetParent);
          picker.minViewMode = picker.options.minViewMode || 0;
          if (typeof picker.minViewMode === 'string') {
            switch (picker.minViewMode) {
              case 'months':
                picker.minViewMode = 1;
                break;
              case 'years':
                picker.minViewMode = 2;
                break;
              default:
                picker.minViewMode = 0;
                break;
            }
          }
          picker.viewMode = picker.options.viewMode || 0;
          if (typeof picker.viewMode === 'string') {
            switch (picker.viewMode) {
              case 'months':
                picker.viewMode = 1;
                break;
              case 'years':
                picker.viewMode = 2;
                break;
              default:
                picker.viewMode = 0;
                break;
            }
          }
          picker.viewMode = Math.max(picker.viewMode, picker.minViewMode);
          picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
          picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);
          picker.startViewMode = picker.viewMode;
          picker.setMinDate(picker.options.minDate);
          picker.setMaxDate(picker.options.maxDate);
          fillDow();
          fillMonths();
          fillHours();
          fillMinutes();
          fillSeconds();
          update();
          showMode();
          if (!getPickerInput().prop('disabled')) {
            attachDatePickerEvents();
          }
          if (picker.options.defaultDate !== '' && getPickerInput().val() === '') {
            picker.setValue(picker.options.defaultDate);
          }
          if (picker.options.minuteStepping !== 1) {
            rInterval = picker.options.minuteStepping;
            picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
          }
        },
        getPickerInput = function() {
          var input;
          if (picker.isInput) {
            return picker.element;
          }
          input = picker.element.find('.datepickerinput');
          if (input.size() === 0) {
            input = picker.element.find('input');
          } else if (!input.is('input')) {
            throw new Error('CSS class "datepickerinput" cannot be applied to non input element');
          }
          return input;
        },
        dataToOptions = function() {
          var eData;
          if (picker.element.is('input')) {
            eData = picker.element.data();
          } else {
            eData = picker.element.find('input').data();
          }
          if (eData.dateFormat !== undefined) {
            picker.options.format = eData.dateFormat;
          }
          if (eData.datePickdate !== undefined) {
            picker.options.pickDate = eData.datePickdate;
          }
          if (eData.datePicktime !== undefined) {
            picker.options.pickTime = eData.datePicktime;
          }
          if (eData.dateUseminutes !== undefined) {
            picker.options.useMinutes = eData.dateUseminutes;
          }
          if (eData.dateUseseconds !== undefined) {
            picker.options.useSeconds = eData.dateUseseconds;
          }
          if (eData.dateUsecurrent !== undefined) {
            picker.options.useCurrent = eData.dateUsecurrent;
          }
          if (eData.calendarWeeks !== undefined) {
            picker.options.calendarWeeks = eData.calendarWeeks;
          }
          if (eData.dateMinutestepping !== undefined) {
            picker.options.minuteStepping = eData.dateMinutestepping;
          }
          if (eData.dateMindate !== undefined) {
            picker.options.minDate = eData.dateMindate;
          }
          if (eData.dateMaxdate !== undefined) {
            picker.options.maxDate = eData.dateMaxdate;
          }
          if (eData.dateShowtoday !== undefined) {
            picker.options.showToday = eData.dateShowtoday;
          }
          if (eData.dateCollapse !== undefined) {
            picker.options.collapse = eData.dateCollapse;
          }
          if (eData.dateLanguage !== undefined) {
            picker.options.language = eData.dateLanguage;
          }
          if (eData.dateDefaultdate !== undefined) {
            picker.options.defaultDate = eData.dateDefaultdate;
          }
          if (eData.dateDisableddates !== undefined) {
            picker.options.disabledDates = eData.dateDisableddates;
          }
          if (eData.dateEnableddates !== undefined) {
            picker.options.enabledDates = eData.dateEnableddates;
          }
          if (eData.dateIcons !== undefined) {
            picker.options.icons = eData.dateIcons;
          }
          if (eData.dateUsestrict !== undefined) {
            picker.options.useStrict = eData.dateUsestrict;
          }
          if (eData.dateDirection !== undefined) {
            picker.options.direction = eData.dateDirection;
          }
          if (eData.dateSidebyside !== undefined) {
            picker.options.sideBySide = eData.dateSidebyside;
          }
          if (eData.dateDaysofweekdisabled !== undefined) {
            picker.options.daysOfWeekDisabled = eData.dateDaysofweekdisabled;
          }
        },
        place = function() {
          var position = 'absolute',
            offset = picker.component ? picker.component.offset() : picker.element.offset(),
            $window = $(window),
            placePosition;
          picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
          offset.top = offset.top + picker.element.outerHeight();
          if (picker.options.direction === 'up') {
            placePosition = 'top';
          } else if (picker.options.direction === 'bottom') {
            placePosition = 'bottom';
          } else if (picker.options.direction === 'auto') {
            if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
              placePosition = 'top';
            } else {
              placePosition = 'bottom';
            }
          }
          if (placePosition === 'top') {
            offset.top = offset.top - picker.element.outerHeight() - picker.widget.height() - 13;
            picker.widget.addClass('top').removeClass('bottom');
          } else {
            offset.top += 1;
            picker.widget.addClass('bottom').removeClass('top');
          }
          if (picker.options.width !== undefined) {
            picker.widget.width(picker.options.width);
          }
          if (picker.options.orientation === 'left') {
            picker.widget.addClass('left-oriented');
            offset.left = offset.left - picker.widget.width() + 20;
          }
          if (isInFixed()) {
            position = 'fixed';
            offset.top -= $window.scrollTop();
            offset.left -= $window.scrollLeft();
          }
          if ($window.width() < offset.left + picker.widget.outerWidth()) {
            offset.right = $window.width() - offset.left - picker.width;
            offset.left = 'auto';
            picker.widget.addClass('pull-right');
          } else {
            offset.right = 'auto';
            picker.widget.removeClass('pull-right');
          }
          if (placePosition === 'top') {
            picker.widget.css({
              position: position,
              bottom: 'auto',
              top: offset.top,
              left: offset.left,
              right: offset.right
            });
          } else {
            picker.widget.css({
              position: position,
              top: offset.top,
              bottom: 'auto',
              left: offset.left,
              right: offset.right
            });
          }
        },
        notifyChange = function(oldDate, eventType) {
          if (moment(picker.date).isSame(moment(oldDate)) && !errored) {
            return;
          }
          errored = false;
          picker.element.trigger({
            type: 'dp.change',
            date: moment(picker.date),
            oldDate: moment(oldDate)
          });
          if (eventType !== 'change') {
            picker.element.change();
          }
        },
        notifyError = function(date) {
          errored = true;
          picker.element.trigger({
            type: 'dp.error',
            date: moment(date, picker.format, picker.options.useStrict)
          });
        },
        update = function(newDate) {
          moment.locale(picker.options.language);
          var dateStr = newDate;
          if (!dateStr) {
            dateStr = getPickerInput().val();
            if (dateStr) {
              picker.date = moment(dateStr, picker.format, picker.options.useStrict);
            }
            if (!picker.date) {
              picker.date = moment();
            }
          }
          picker.viewDate = moment(picker.date).startOf('month');
          fillDate();
          fillTime();
        },
        fillDow = function() {
          moment.locale(picker.options.language);
          var html = $('<tr>'),
            weekdaysMin = moment.weekdaysMin(),
            i;
          if (picker.options.calendarWeeks === true) {
            html.append('<th class="cw">#</th>');
          }
          if (moment().localeData()._week.dow === 0) {
            for (i = 0; i < 7; i++) {
              html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
            }
          } else {
            for (i = 1; i < 8; i++) {
              if (i === 7) {
                html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
              } else {
                html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
              }
            }
          }
          picker.widget.find('.datepicker-days thead').append(html);
        },
        fillMonths = function() {
          moment.locale(picker.options.language);
          var html = '',
            i, monthsShort = moment.monthsShort();
          for (i = 0; i < 12; i++) {
            html += '<span class="month">' + monthsShort[i] + '</span>';
          }
          picker.widget.find('.datepicker-months td').append(html);
        },
        fillDate = function() {
          if (!picker.options.pickDate) {
            return;
          }
          moment.locale(picker.options.language);
          var year = picker.viewDate.year(),
            month = picker.viewDate.month(),
            startYear = picker.options.minDate.year(),
            startMonth = picker.options.minDate.month(),
            endYear = picker.options.maxDate.year(),
            endMonth = picker.options.maxDate.month(),
            currentDate,
            prevMonth, nextMonth, html = [],
            row, clsName, i, days, yearCont, currentYear, months = moment.months();
          picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-days th:eq(1)').text(
            months[month] + ' ' + year);
          prevMonth = moment(picker.viewDate, picker.format, picker.options.useStrict).subtract(1, 'months');
          days = prevMonth.daysInMonth();
          prevMonth.date(days).startOf('week');
          if ((year === startYear && month <= startMonth) || year < startYear) {
            picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
          }
          if ((year === endYear && month >= endMonth) || year > endYear) {
            picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
          }
          nextMonth = moment(prevMonth).add(42, 'd');
          while (prevMonth.isBefore(nextMonth)) {
            if (prevMonth.weekday() === moment().startOf('week').weekday()) {
              row = $('<tr>');
              html.push(row);
              if (picker.options.calendarWeeks === true) {
                row.append('<td class="cw">' + prevMonth.week() + '</td>');
              }
            }
            clsName = '';
            if (prevMonth.year() < year || (prevMonth.year() === year && prevMonth.month() < month)) {
              clsName += ' old';
            } else if (prevMonth.year() > year || (prevMonth.year() === year && prevMonth.month() > month)) {
              clsName += ' new';
            }
            if (prevMonth.isSame(moment({
                y: picker.date.year(),
                M: picker.date.month(),
                d: picker.date.date()
              }))) {
              clsName += ' active';
            }
            if (isInDisableDates(prevMonth, 'day') || !isInEnableDates(prevMonth)) {
              clsName += ' disabled';
            }
            if (picker.options.showToday === true) {
              if (prevMonth.isSame(moment(), 'day')) {
                clsName += ' today';
              }
            }
            if (picker.options.daysOfWeekDisabled) {
              for (i = 0; i < picker.options.daysOfWeekDisabled.length; i++) {
                if (prevMonth.day() === picker.options.daysOfWeekDisabled[i]) {
                  clsName += ' disabled';
                  break;
                }
              }
            }
            row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');
            currentDate = prevMonth.date();
            prevMonth.add(1, 'd');
            if (currentDate === prevMonth.date()) {
              prevMonth.add(1, 'd');
            }
          }
          picker.widget.find('.datepicker-days tbody').empty().append(html);
          currentYear = picker.date.year();
          months = picker.widget.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');
          if (currentYear === year) {
            months.eq(picker.date.month()).addClass('active');
          }
          if (year - 1 < startYear) {
            picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
          }
          if (year + 1 > endYear) {
            picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
          }
          for (i = 0; i < 12; i++) {
            if ((year === startYear && startMonth > i) || (year < startYear)) {
              $(months[i]).addClass('disabled');
            } else if ((year === endYear && endMonth < i) || (year > endYear)) {
              $(months[i]).addClass('disabled');
            }
          }
          html = '';
          year = parseInt(year / 10, 10) * 10;
          yearCont = picker.widget.find('.datepicker-years').find(
            'th:eq(1)').text(year + '-' + (year + 9)).parents('table').find('td');
          picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
          if (startYear > year) {
            picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
          }
          if (endYear < year + 9) {
            picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
          }
          year -= 1;
          for (i = -1; i < 11; i++) {
            html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
            year += 1;
          }
          yearCont.html(html);
        },
        fillHours = function() {
          moment.locale(picker.options.language);
          var table = picker.widget.find('.timepicker .timepicker-hours table'),
            html = '',
            current, i, j;
          table.parent().hide();
          if (picker.use24hours) {
            current = 0;
            for (i = 0; i < 6; i += 1) {
              html += '<tr>';
              for (j = 0; j < 4; j += 1) {
                html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                current++;
              }
              html += '</tr>';
            }
          } else {
            current = 1;
            for (i = 0; i < 3; i += 1) {
              html += '<tr>';
              for (j = 0; j < 4; j += 1) {
                html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
                current++;
              }
              html += '</tr>';
            }
          }
          table.html(html);
        },
        fillMinutes = function() {
          var table = picker.widget.find('.timepicker .timepicker-minutes table'),
            html = '',
            current = 0,
            i, j, step = picker.options.minuteStepping;
          table.parent().hide();
          if (step === 1) {
            step = 5;
          }
          for (i = 0; i < Math.ceil(60 / step / 4); i++) {
            html += '<tr>';
            for (j = 0; j < 4; j += 1) {
              if (current < 60) {
                html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
                current += step;
              } else {
                html += '<td></td>';
              }
            }
            html += '</tr>';
          }
          table.html(html);
        },
        fillSeconds = function() {
          var table = picker.widget.find('.timepicker .timepicker-seconds table'),
            html = '',
            current = 0,
            i, j;
          table.parent().hide();
          for (i = 0; i < 3; i++) {
            html += '<tr>';
            for (j = 0; j < 4; j += 1) {
              html += '<td class="second">' + padLeft(current.toString()) + '</td>';
              current += 5;
            }
            html += '</tr>';
          }
          table.html(html);
        },
        fillTime = function() {
          if (!picker.date) {
            return;
          }
          var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
            hour = picker.date.hours(),
            period = picker.date.format('A');
          if (!picker.use24hours) {
            if (hour === 0) {
              hour = 12;
            } else if (hour !== 12) {
              hour = hour % 12;
            }
            picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
          }
          timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
          timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
          timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
        },
        click = function(e) {
          e.stopPropagation();
          e.preventDefault();
          picker.unset = false;
          var target = $(e.target).closest('span, td, th'),
            month, year, step, day, oldDate = moment(picker.date);
          if (target.length === 1) {
            if (!target.is('.disabled')) {
              switch (target[0].nodeName.toLowerCase()) {
                case 'th':
                  switch (target[0].className) {
                    case 'picker-switch':
                      showMode(1);
                      break;
                    case 'prev':
                    case 'next':
                      step = dpGlobal.modes[picker.viewMode].navStep;
                      if (target[0].className === 'prev') {
                        step = step * -1;
                      }
                      picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
                      fillDate();
                      break;
                  }
                  break;
                case 'span':
                  if (target.is('.month')) {
                    month = target.parent().find('span').index(target);
                    picker.viewDate.month(month);
                  } else {
                    year = parseInt(target.text(), 10) || 0;
                    picker.viewDate.year(year);
                  }
                  if (picker.viewMode === picker.minViewMode) {
                    picker.date = moment({
                      y: picker.viewDate.year(),
                      M: picker.viewDate.month(),
                      d: picker.viewDate.date(),
                      h: picker.date.hours(),
                      m: picker.date.minutes(),
                      s: picker.date.seconds()
                    });
                    set();
                    notifyChange(oldDate, e.type);
                  }
                  showMode(-1);
                  fillDate();
                  break;
                case 'td':
                  if (target.is('.day')) {
                    day = parseInt(target.text(), 10) || 1;
                    month = picker.viewDate.month();
                    year = picker.viewDate.year();
                    if (target.is('.old')) {
                      if (month === 0) {
                        month = 11;
                        year -= 1;
                      } else {
                        month -= 1;
                      }
                    } else if (target.is('.new')) {
                      if (month === 11) {
                        month = 0;
                        year += 1;
                      } else {
                        month += 1;
                      }
                    }
                    picker.date = moment({
                      y: year,
                      M: month,
                      d: day,
                      h: picker.date.hours(),
                      m: picker.date.minutes(),
                      s: picker.date.seconds()
                    });
                    picker.viewDate = moment({
                      y: year,
                      M: month,
                      d: Math.min(28, day)
                    });
                    fillDate();
                    set();
                    notifyChange(oldDate, e.type);
                  }
                  break;
              }
            }
          }
        },
        actions = {
          incrementHours: function() {
            checkDate('add', 'hours', 1);
          },
          incrementMinutes: function() {
            checkDate('add', 'minutes', picker.options.minuteStepping);
          },
          incrementSeconds: function() {
            checkDate('add', 'seconds', 1);
          },
          decrementHours: function() {
            checkDate('subtract', 'hours', 1);
          },
          decrementMinutes: function() {
            checkDate('subtract', 'minutes', picker.options.minuteStepping);
          },
          decrementSeconds: function() {
            checkDate('subtract', 'seconds', 1);
          },
          togglePeriod: function() {
            var hour = picker.date.hours();
            if (hour >= 12) {
              hour -= 12;
            } else {
              hour += 12;
            }
            picker.date.hours(hour);
          },
          showPicker: function() {
            picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
            picker.widget.find('.timepicker .timepicker-picker').show();
          },
          showHours: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-hours').show();
          },
          showMinutes: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-minutes').show();
          },
          showSeconds: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-seconds').show();
          },
          selectHour: function(e) {
            var hour = parseInt($(e.target).text(), 10);
            if (!picker.use24hours) {
              if (picker.date.hours() >= 12) {
                if (hour !== 12) {
                  hour += 12;
                }
              } else {
                if (hour === 12) {
                  hour = 0;
                }
              }
            }
            picker.date.hours(hour);
            actions.showPicker.call(picker);
          },
          selectMinute: function(e) {
            picker.date.minutes(parseInt($(e.target).text(), 10));
            actions.showPicker.call(picker);
          },
          selectSecond: function(e) {
            picker.date.seconds(parseInt($(e.target).text(), 10));
            actions.showPicker.call(picker);
          }
        },
        doAction = function(e) {
          var oldDate = moment(picker.date),
            action = $(e.currentTarget).data('action'),
            rv = actions[action].apply(picker, arguments);
          stopEvent(e);
          if (!picker.date) {
            picker.date = moment({
              y: 1970
            });
          }
          set();
          fillTime();
          notifyChange(oldDate, e.type);
          return rv;
        },
        stopEvent = function(e) {
          e.stopPropagation();
          e.preventDefault();
        },
        keydown = function(e) {
          if (e.keyCode === 27) {
            picker.hide();
          }
        },
        change = function(e) {
          moment.locale(picker.options.language);
          var input = $(e.target),
            oldDate = moment(picker.date),
            newDate = moment(input.val(), picker.format, picker.options.useStrict);
          if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
            update();
            picker.setValue(newDate);
            notifyChange(oldDate, e.type);
            set();
          } else {
            picker.viewDate = oldDate;
            picker.unset = true;
            notifyChange(oldDate, e.type);
            notifyError(newDate);
          }
        },
        showMode = function(dir) {
          if (dir) {
            picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
          }
          picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
        },
        attachDatePickerEvents = function() {
          var $this, $parent, expanded, closed, collapseData;
          picker.widget.on('click', '.datepicker *', $.proxy(click, this));
          picker.widget.on('click', '[data-action]', $.proxy(doAction, this));
          picker.widget.on('mousedown', $.proxy(stopEvent, this));
          picker.element.on('keydown', $.proxy(keydown, this));
          if (picker.options.pickDate && picker.options.pickTime) {
            picker.widget.on('click.togglePicker', '.accordion-toggle', function(e) {
              e.stopPropagation();
              $this = $(this);
              $parent = $this.closest('ul');
              expanded = $parent.find('.in');
              closed = $parent.find('.collapse:not(.in)');
              if (expanded && expanded.length) {
                collapseData = expanded.data('collapse');
                if (collapseData && collapseData.transitioning) {
                  return;
                }
                expanded.collapse('hide');
                closed.collapse('show');
                $this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                if (picker.component) {
                  picker.component.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                }
              }
            });
          }
          if (picker.isInput) {
            picker.element.on({
              'click': $.proxy(picker.show, this),
              'focus': $.proxy(picker.show, this),
              'change': $.proxy(change, this),
              'blur': $.proxy(picker.hide, this)
            });
          } else {
            picker.element.on({
              'change': $.proxy(change, this)
            }, 'input');
            if (picker.component) {
              picker.component.on('click', $.proxy(picker.show, this));
              picker.component.on('mousedown', $.proxy(stopEvent, this));
            } else {
              picker.element.on('click', $.proxy(picker.show, this));
            }
          }
        },
        attachDatePickerGlobalEvents = function() {
          $(window).on(
            'resize.datetimepicker' + picker.id, $.proxy(place, this));
          if (!picker.isInput) {
            $(document).on(
              'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
          }
        },
        detachDatePickerEvents = function() {
          picker.widget.off('click', '.datepicker *', picker.click);
          picker.widget.off('click', '[data-action]');
          picker.widget.off('mousedown', picker.stopEvent);
          if (picker.options.pickDate && picker.options.pickTime) {
            picker.widget.off('click.togglePicker');
          }
          if (picker.isInput) {
            picker.element.off({
              'focus': picker.show,
              'change': change,
              'click': picker.show,
              'blur': picker.hide
            });
          } else {
            picker.element.off({
              'change': change
            }, 'input');
            if (picker.component) {
              picker.component.off('click', picker.show);
              picker.component.off('mousedown', picker.stopEvent);
            } else {
              picker.element.off('click', picker.show);
            }
          }
        },
        detachDatePickerGlobalEvents = function() {
          $(window).off('resize.datetimepicker' + picker.id);
          if (!picker.isInput) {
            $(document).off('mousedown.datetimepicker' + picker.id);
          }
        },
        isInFixed = function() {
          if (picker.element) {
            var parents = picker.element.parents(),
              inFixed = false,
              i;
            for (i = 0; i < parents.length; i++) {
              if ($(parents[i]).css('position') === 'fixed') {
                inFixed = true;
                break;
              }
            }
            return inFixed;
          } else {
            return false;
          }
        },
        set = function() {
          moment.locale(picker.options.language);
          var formatted = '';
          if (!picker.unset) {
            formatted = moment(picker.date).format(picker.format);
          }
          getPickerInput().val(formatted);
          picker.element.data('date', formatted);
          if (!picker.options.pickTime) {
            picker.hide();
          }
        },
        checkDate = function(direction, unit, amount) {
          moment.locale(picker.options.language);
          var newDate;
          if (direction === 'add') {
            newDate = moment(picker.date);
            if (newDate.hours() === 23) {
              newDate.add(amount, unit);
            }
            newDate.add(amount, unit);
          } else {
            newDate = moment(picker.date).subtract(amount, unit);
          }
          if (isInDisableDates(moment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
            notifyError(newDate.format(picker.format));
            return;
          }
          if (direction === 'add') {
            picker.date.add(amount, unit);
          } else {
            picker.date.subtract(amount, unit);
          }
          picker.unset = false;
        },
        isInDisableDates = function(date, timeUnit) {
          moment.locale(picker.options.language);
          var maxDate = moment(picker.options.maxDate, picker.format, picker.options.useStrict),
            minDate = moment(picker.options.minDate, picker.format, picker.options.useStrict);
          if (timeUnit) {
            maxDate = maxDate.endOf(timeUnit);
            minDate = minDate.startOf(timeUnit);
          }
          if (date.isAfter(maxDate) || date.isBefore(minDate)) {
            return true;
          }
          if (picker.options.disabledDates === false) {
            return false;
          }
          return picker.options.disabledDates[date.format('YYYY-MM-DD')] === true;
        },
        isInEnableDates = function(date) {
          moment.locale(picker.options.language);
          if (picker.options.enabledDates === false) {
            return true;
          }
          return picker.options.enabledDates[date.format('YYYY-MM-DD')] === true;
        },
        indexGivenDates = function(givenDatesArray) {
          var givenDatesIndexed = {},
            givenDatesCount = 0,
            i;
          for (i = 0; i < givenDatesArray.length; i++) {
            if (moment.isMoment(givenDatesArray[i]) || givenDatesArray[i] instanceof Date) {
              dDate = moment(givenDatesArray[i]);
            } else {
              dDate = moment(givenDatesArray[i], picker.format, picker.options.useStrict);
            }
            if (dDate.isValid()) {
              givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
              givenDatesCount++;
            }
          }
          if (givenDatesCount > 0) {
            return givenDatesIndexed;
          }
          return false;
        },
        padLeft = function(string) {
          string = string.toString();
          if (string.length >= 2) {
            return string;
          }
          return '0' + string;
        },
        getTemplate = function() {
          var
            headTemplate =
            '<thead>' +
            '<tr>' +
            '<th class="prev">&lsaquo;</th><th colspan="' + (picker.options.calendarWeeks ? '6' : '5') + '" class="picker-switch"></th><th class="next">&rsaquo;</th>' +
            '</tr>' +
            '</thead>',
            contTemplate =
            '<tbody><tr><td colspan="' + (picker.options.calendarWeeks ? '8' : '7') + '"></td></tr></tbody>',
            template = '<div class="datepicker-days">' +
            '<table class="table-condensed">' + headTemplate + '<tbody></tbody></table>' +
            '</div>' +
            '<div class="datepicker-months">' +
            '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
            '</div>' +
            '<div class="datepicker-years">' +
            '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
            '</div>',
            ret = '';
          if (picker.options.pickDate && picker.options.pickTime) {
            ret = '<div class="bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + (picker.use24hours ? ' usetwentyfour' : '') + ' dropdown-menu" style="z-index:9999 !important;">';
            if (picker.options.sideBySide) {
              ret += '<div class="row">' +
                '<div class="col-sm-6 datepicker">' + template + '</div>' +
                '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
                '</div>';
            } else {
              ret += '<ul class="list-unstyled">' +
                '<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
                '<div class="datepicker">' + template + '</div>' +
                '</li>' +
                '<li class="picker-switch accordion-toggle"><a class="btn" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
                '<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
                '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
                '</li>' +
                '</ul>';
            }
            ret += '</div>';
            return ret;
          }
          if (picker.options.pickTime) {
            return (
              '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
              '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
              '</div>'
            );
          }
          return (
            '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
            '<div class="datepicker">' + template + '</div>' +
            '</div>'
          );
        },
        dpGlobal = {
          modes: [{
              clsName: 'days',
              navFnc: 'month',
              navStep: 1
            },
            {
              clsName: 'months',
              navFnc: 'year',
              navStep: 1
            },
            {
              clsName: 'years',
              navFnc: 'year',
              navStep: 10
            }
          ]
        },
        tpGlobal = {
          hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
          minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
          secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
        };
      tpGlobal.getTemplate = function() {
        return (
          '<div class="timepicker-picker">' +
          '<table class="table-condensed">' +
          '<tr>' +
          '<td><a href="#" class="btn" data-action="incrementHours"><span class="' + picker.options.icons.up + '"></span></a></td>' +
          '<td class="separator"></td>' +
          '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><span class="' + picker.options.icons.up + '"></span></a>' : '') + '</td>' +
          (picker.options.useSeconds ?
            '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><span class="' + picker.options.icons.up + '"></span></a></td>' : '') +
          (picker.use24hours ? '' : '<td class="separator"></td>') +
          '</tr>' +
          '<tr>' +
          '<td>' + tpGlobal.hourTemplate + '</td> ' +
          '<td class="separator">:</td>' +
          '<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
          (picker.options.useSeconds ?
            '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
          (picker.use24hours ? '' : '<td class="separator"></td>' +
            '<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
          '</tr>' +
          '<tr>' +
          '<td><a href="#" class="btn" data-action="decrementHours"><span class="' + picker.options.icons.down + '"></span></a></td>' +
          '<td class="separator"></td>' +
          '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><span class="' + picker.options.icons.down + '"></span></a>' : '') + '</td>' +
          (picker.options.useSeconds ?
            '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><span class="' + picker.options.icons.down + '"></span></a></td>' : '') +
          (picker.use24hours ? '' : '<td class="separator"></td>') +
          '</tr>' +
          '</table>' +
          '</div>' +
          '<div class="timepicker-hours" data-action="selectHour">' +
          '<table class="table-condensed"></table>' +
          '</div>' +
          '<div class="timepicker-minutes" data-action="selectMinute">' +
          '<table class="table-condensed"></table>' +
          '</div>' +
          (picker.options.useSeconds ?
            '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
        );
      };
      picker.destroy = function() {
        detachDatePickerEvents();
        detachDatePickerGlobalEvents();
        picker.widget.remove();
        picker.element.removeData('DateTimePicker');
        if (picker.component) {
          picker.component.removeData('DateTimePicker');
        }
      };
      picker.show = function(e) {
        if (getPickerInput().prop('disabled')) {
          return;
        }
        if (picker.options.useCurrent) {
          if (getPickerInput().val() === '') {
            if (picker.options.minuteStepping !== 1) {
              var mDate = moment(),
                rInterval = picker.options.minuteStepping;
              mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
              picker.setValue(mDate.format(picker.format));
            } else {
              picker.setValue(moment().format(picker.format));
            }
            notifyChange('', e.type);
          }
        }
        if (e && e.type === 'click' && picker.isInput && picker.widget.hasClass('picker-open')) {
          return;
        }
        if (picker.widget.hasClass('picker-open')) {
          picker.widget.hide();
          picker.widget.removeClass('picker-open');
        } else {
          picker.widget.show();
          picker.widget.addClass('picker-open');
        }
        picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
        place();
        picker.element.trigger({
          type: 'dp.show',
          date: moment(picker.date)
        });
        attachDatePickerGlobalEvents();
        if (e) {
          stopEvent(e);
        }
      };
      picker.disable = function() {
        var input = getPickerInput();
        if (input.prop('disabled')) {
          return;
        }
        input.prop('disabled', true);
        detachDatePickerEvents();
      };
      picker.enable = function() {
        var input = getPickerInput();
        if (!input.prop('disabled')) {
          return;
        }
        input.prop('disabled', false);
        attachDatePickerEvents();
      };
      picker.hide = function() {
        var collapse = picker.widget.find('.collapse'),
          i, collapseData;
        for (i = 0; i < collapse.length; i++) {
          collapseData = collapse.eq(i).data('collapse');
          if (collapseData && collapseData.transitioning) {
            return;
          }
        }
        picker.widget.hide();
        picker.widget.removeClass('picker-open');
        picker.viewMode = picker.startViewMode;
        showMode();
        picker.element.trigger({
          type: 'dp.hide',
          date: moment(picker.date)
        });
        detachDatePickerGlobalEvents();
      };
      picker.setValue = function(newDate) {
        moment.locale(picker.options.language);
        if (!newDate) {
          picker.unset = true;
          set();
        } else {
          picker.unset = false;
        }
        if (!moment.isMoment(newDate)) {
          newDate = (newDate instanceof Date) ? moment(newDate) : moment(newDate, picker.format, picker.options.useStrict);
        } else {
          newDate = newDate.locale(picker.options.language);
        }
        if (newDate.isValid()) {
          picker.date = newDate;
          set();
          picker.viewDate = moment({
            y: picker.date.year(),
            M: picker.date.month()
          });
          fillDate();
          fillTime();
        } else {
          notifyError(newDate);
        }
      };
      picker.getDate = function() {
        if (picker.unset) {
          return null;
        }
        return moment(picker.date);
      };
      picker.setDate = function(date) {
        var oldDate = moment(picker.date);
        if (!date) {
          picker.setValue(null);
        } else {
          picker.setValue(date);
        }
        notifyChange(oldDate, 'function');
      };
      picker.setDisabledDates = function(dates) {
        picker.options.disabledDates = indexGivenDates(dates);
        if (picker.viewDate) {
          update();
        }
      };
      picker.setEnabledDates = function(dates) {
        picker.options.enabledDates = indexGivenDates(dates);
        if (picker.viewDate) {
          update();
        }
      };
      picker.setMaxDate = function(date) {
        if (date === undefined) {
          return;
        }
        if (moment.isMoment(date) || date instanceof Date) {
          picker.options.maxDate = moment(date);
        } else {
          picker.options.maxDate = moment(date, picker.format, picker.options.useStrict);
        }
        if (picker.viewDate) {
          update();
        }
      };
      picker.setMinDate = function(date) {
        if (date === undefined) {
          return;
        }
        if (moment.isMoment(date) || date instanceof Date) {
          picker.options.minDate = moment(date);
        } else {
          picker.options.minDate = moment(date, picker.format, picker.options.useStrict);
        }
        if (picker.viewDate) {
          update();
        }
      };
      init();
    };
  $.fn.datetimepicker = function(options) {
    return this.each(function() {
      var $this = $(this),
        data = $this.data('DateTimePicker');
      if (!data) {
        $this.data('DateTimePicker', new DateTimePicker(this, options));
      }
    });
  };
  $.fn.datetimepicker.defaults = {
    format: false,
    pickDate: true,
    pickTime: true,
    useMinutes: true,
    useSeconds: false,
    useCurrent: true,
    calendarWeeks: false,
    minuteStepping: 1,
    minDate: moment({
      y: 1900
    }),
    maxDate: moment().add(100, 'y'),
    showToday: true,
    collapse: true,
    language: moment.locale(),
    defaultDate: '',
    disabledDates: false,
    enabledDates: false,
    icons: {},
    useStrict: false,
    direction: 'auto',
    sideBySide: false,
    daysOfWeekDisabled: [],
    widgetParent: false
  };
}));;
/*! RESOURCE: /scripts/libs/sortable.min.js */
/*! Sortable 1.4.2 - MIT | git://github.com/rubaxa/Sortable.git */
! function(a) {
  "use strict";
  "function" == typeof define && define.amd ? define(a) : "undefined" != typeof module && "undefined" != typeof module.exports ? module.exports = a() : "undefined" != typeof Package ? Sortable = a() : window.Sortable = a()
}(function() {
  "use strict";

  function a(a, b) {
    if (!a || !a.nodeType || 1 !== a.nodeType) throw "Sortable: `el` must be HTMLElement, and not " + {}.toString.call(a);
    this.el = a, this.options = b = r({}, b), a[L] = this;
    var c = {
      group: Math.random(),
      sort: !0,
      disabled: !1,
      store: null,
      handle: null,
      scroll: !0,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      draggable: /[uo]l/i.test(a.nodeName) ? "li" : ">*",
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      ignore: "a, img",
      filter: null,
      animation: 0,
      setData: function(a, b) {
        a.setData("Text", b.textContent)
      },
      dropBubble: !1,
      dragoverBubble: !1,
      dataIdAttr: "data-id",
      delay: 0,
      forceFallback: !1,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: !1
    };
    for (var d in c) !(d in b) && (b[d] = c[d]);
    V(b);
    for (var f in this) "_" === f.charAt(0) && (this[f] = this[f].bind(this));
    this.nativeDraggable = b.forceFallback ? !1 : P, e(a, "mousedown", this._onTapStart), e(a, "touchstart", this._onTapStart), this.nativeDraggable && (e(a, "dragover", this), e(a, "dragenter", this)), T.push(this._onDragOver), b.store && this.sort(b.store.get(this))
  }

  function b(a) {
    v && v.state !== a && (h(v, "display", a ? "none" : ""), !a && v.state && w.insertBefore(v, s), v.state = a)
  }

  function c(a, b, c) {
    if (a) {
      c = c || N, b = b.split(".");
      var d = b.shift().toUpperCase(),
        e = new RegExp("\\s(" + b.join("|") + ")(?=\\s)", "g");
      do
        if (">*" === d && a.parentNode === c || ("" === d || a.nodeName.toUpperCase() == d) && (!b.length || ((" " + a.className + " ").match(e) || []).length == b.length)) return a; while (a !== c && (a = a.parentNode))
    }
    return null
  }

  function d(a) {
    a.dataTransfer && (a.dataTransfer.dropEffect = "move"), a.preventDefault()
  }

  function e(a, b, c) {
    a.addEventListener(b, c, !1)
  }

  function f(a, b, c) {
    a.removeEventListener(b, c, !1)
  }

  function g(a, b, c) {
    if (a)
      if (a.classList) a.classList[c ? "add" : "remove"](b);
      else {
        var d = (" " + a.className + " ").replace(K, " ").replace(" " + b + " ", " ");
        a.className = (d + (c ? " " + b : "")).replace(K, " ")
      }
  }

  function h(a, b, c) {
    var d = a && a.style;
    if (d) {
      if (void 0 === c) return N.defaultView && N.defaultView.getComputedStyle ? c = N.defaultView.getComputedStyle(a, "") : a.currentStyle && (c = a.currentStyle), void 0 === b ? c : c[b];
      b in d || (b = "-webkit-" + b), d[b] = c + ("string" == typeof c ? "" : "px")
    }
  }

  function i(a, b, c) {
    if (a) {
      var d = a.getElementsByTagName(b),
        e = 0,
        f = d.length;
      if (c)
        for (; f > e; e++) c(d[e], e);
      return d
    }
    return []
  }

  function j(a, b, c, d, e, f, g) {
    var h = N.createEvent("Event"),
      i = (a || b[L]).options,
      j = "on" + c.charAt(0).toUpperCase() + c.substr(1);
    h.initEvent(c, !0, !0), h.to = b, h.from = e || b, h.item = d || b, h.clone = v, h.oldIndex = f, h.newIndex = g, b.dispatchEvent(h), i[j] && i[j].call(a, h)
  }

  function k(a, b, c, d, e, f) {
    var g, h, i = a[L],
      j = i.options.onMove;
    return g = N.createEvent("Event"), g.initEvent("move", !0, !0), g.to = b, g.from = a, g.dragged = c, g.draggedRect = d, g.related = e || b, g.relatedRect = f || b.getBoundingClientRect(), a.dispatchEvent(g), j && (h = j.call(i, g)), h
  }

  function l(a) {
    a.draggable = !1
  }

  function m() {
    R = !1
  }

  function n(a, b) {
    var c = a.lastElementChild,
      d = c.getBoundingClientRect();
    return (b.clientY - (d.top + d.height) > 5 || b.clientX - (d.right + d.width) > 5) && c
  }

  function o(a) {
    for (var b = a.tagName + a.className + a.src + a.href + a.textContent, c = b.length, d = 0; c--;) d += b.charCodeAt(c);
    return d.toString(36)
  }

  function p(a) {
    var b = 0;
    if (!a || !a.parentNode) return -1;
    for (; a && (a = a.previousElementSibling);) "TEMPLATE" !== a.nodeName.toUpperCase() && b++;
    return b
  }

  function q(a, b) {
    var c, d;
    return function() {
      void 0 === c && (c = arguments, d = this, setTimeout(function() {
        1 === c.length ? a.call(d, c[0]) : a.apply(d, c), c = void 0
      }, b))
    }
  }

  function r(a, b) {
    if (a && b)
      for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
    return a
  }
  var s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J = {},
    K = /\s+/g,
    L = "Sortable" + (new Date).getTime(),
    M = window,
    N = M.document,
    O = M.parseInt,
    P = !!("draggable" in N.createElement("div")),
    Q = function(a) {
      return a = N.createElement("x"), a.style.cssText = "pointer-events:auto", "auto" === a.style.pointerEvents
    }(),
    R = !1,
    S = Math.abs,
    T = ([].slice, []),
    U = q(function(a, b, c) {
      if (c && b.scroll) {
        var d, e, f, g, h = b.scrollSensitivity,
          i = b.scrollSpeed,
          j = a.clientX,
          k = a.clientY,
          l = window.innerWidth,
          m = window.innerHeight;
        if (z !== c && (y = b.scroll, z = c, y === !0)) {
          y = c;
          do
            if (y.offsetWidth < y.scrollWidth || y.offsetHeight < y.scrollHeight) break; while (y = y.parentNode)
        }
        y && (d = y, e = y.getBoundingClientRect(), f = (S(e.right - j) <= h) - (S(e.left - j) <= h), g = (S(e.bottom - k) <= h) - (S(e.top - k) <= h)), f || g || (f = (h >= l - j) - (h >= j), g = (h >= m - k) - (h >= k), (f || g) && (d = M)), (J.vx !== f || J.vy !== g || J.el !== d) && (J.el = d, J.vx = f, J.vy = g, clearInterval(J.pid), d && (J.pid = setInterval(function() {
          d === M ? M.scrollTo(M.pageXOffset + f * i, M.pageYOffset + g * i) : (g && (d.scrollTop += g * i), f && (d.scrollLeft += f * i))
        }, 24)))
      }
    }, 30),
    V = function(a) {
      var b = a.group;
      b && "object" == typeof b || (b = a.group = {
        name: b
      }), ["pull", "put"].forEach(function(a) {
        a in b || (b[a] = !0)
      }), a.groups = " " + b.name + (b.put.join ? " " + b.put.join(" ") : "") + " "
    };
  return a.prototype = {
    constructor: a,
    _onTapStart: function(a) {
      var b = this,
        d = this.el,
        e = this.options,
        f = a.type,
        g = a.touches && a.touches[0],
        h = (g || a).target,
        i = h,
        k = e.filter;
      if (!("mousedown" === f && 0 !== a.button || e.disabled) && (h = c(h, e.draggable, d))) {
        if (D = p(h), "function" == typeof k) {
          if (k.call(this, a, h, this)) return j(b, i, "filter", h, d, D), void a.preventDefault()
        } else if (k && (k = k.split(",").some(function(a) {
            return a = c(i, a.trim(), d), a ? (j(b, a, "filter", h, d, D), !0) : void 0
          }))) return void a.preventDefault();
        (!e.handle || c(i, e.handle, d)) && this._prepareDragStart(a, g, h)
      }
    },
    _prepareDragStart: function(a, b, c) {
      var d, f = this,
        h = f.el,
        j = f.options,
        k = h.ownerDocument;
      c && !s && c.parentNode === h && (G = a, w = h, s = c, t = s.parentNode, x = s.nextSibling, F = j.group, d = function() {
        f._disableDelayedDrag(), s.draggable = !0, g(s, f.options.chosenClass, !0), f._triggerDragStart(b)
      }, j.ignore.split(",").forEach(function(a) {
        i(s, a.trim(), l)
      }), e(k, "mouseup", f._onDrop), e(k, "touchend", f._onDrop), e(k, "touchcancel", f._onDrop), j.delay ? (e(k, "mouseup", f._disableDelayedDrag), e(k, "touchend", f._disableDelayedDrag), e(k, "touchcancel", f._disableDelayedDrag), e(k, "mousemove", f._disableDelayedDrag), e(k, "touchmove", f._disableDelayedDrag), f._dragStartTimer = setTimeout(d, j.delay)) : d())
    },
    _disableDelayedDrag: function() {
      var a = this.el.ownerDocument;
      clearTimeout(this._dragStartTimer), f(a, "mouseup", this._disableDelayedDrag), f(a, "touchend", this._disableDelayedDrag), f(a, "touchcancel", this._disableDelayedDrag), f(a, "mousemove", this._disableDelayedDrag), f(a, "touchmove", this._disableDelayedDrag)
    },
    _triggerDragStart: function(a) {
      a ? (G = {
        target: s,
        clientX: a.clientX,
        clientY: a.clientY
      }, this._onDragStart(G, "touch")) : this.nativeDraggable ? (e(s, "dragend", this), e(w, "dragstart", this._onDragStart)) : this._onDragStart(G, !0);
      try {
        N.selection ? N.selection.empty() : window.getSelection().removeAllRanges()
      } catch (b) {}
    },
    _dragStarted: function() {
      w && s && (g(s, this.options.ghostClass, !0), a.active = this, j(this, w, "start", s, w, D))
    },
    _emulateDragOver: function() {
      if (H) {
        if (this._lastX === H.clientX && this._lastY === H.clientY) return;
        this._lastX = H.clientX, this._lastY = H.clientY, Q || h(u, "display", "none");
        var a = N.elementFromPoint(H.clientX, H.clientY),
          b = a,
          c = " " + this.options.group.name,
          d = T.length;
        if (b)
          do {
            if (b[L] && b[L].options.groups.indexOf(c) > -1) {
              for (; d--;) T[d]({
                clientX: H.clientX,
                clientY: H.clientY,
                target: a,
                rootEl: b
              });
              break
            }
            a = b
          } while (b = b.parentNode);
        Q || h(u, "display", "")
      }
    },
    _onTouchMove: function(b) {
      if (G) {
        a.active || this._dragStarted(), this._appendGhost();
        var c = b.touches ? b.touches[0] : b,
          d = c.clientX - G.clientX,
          e = c.clientY - G.clientY,
          f = b.touches ? "translate3d(" + d + "px," + e + "px,0)" : "translate(" + d + "px," + e + "px)";
        I = !0, H = c, h(u, "webkitTransform", f), h(u, "mozTransform", f), h(u, "msTransform", f), h(u, "transform", f), b.preventDefault()
      }
    },
    _appendGhost: function() {
      if (!u) {
        var a, b = s.getBoundingClientRect(),
          c = h(s),
          d = this.options;
        u = s.cloneNode(!0), g(u, d.ghostClass, !1), g(u, d.fallbackClass, !0), h(u, "top", b.top - O(c.marginTop, 10)), h(u, "left", b.left - O(c.marginLeft, 10)), h(u, "width", b.width), h(u, "height", b.height), h(u, "opacity", "0.8"), h(u, "position", "fixed"), h(u, "zIndex", "100000"), h(u, "pointerEvents", "none"), d.fallbackOnBody && N.body.appendChild(u) || w.appendChild(u), a = u.getBoundingClientRect(), h(u, "width", 2 * b.width - a.width), h(u, "height", 2 * b.height - a.height)
      }
    },
    _onDragStart: function(a, b) {
      var c = a.dataTransfer,
        d = this.options;
      this._offUpEvents(), "clone" == F.pull && (v = s.cloneNode(!0), h(v, "display", "none"), w.insertBefore(v, s)), b ? ("touch" === b ? (e(N, "touchmove", this._onTouchMove), e(N, "touchend", this._onDrop), e(N, "touchcancel", this._onDrop)) : (e(N, "mousemove", this._onTouchMove), e(N, "mouseup", this._onDrop)), this._loopId = setInterval(this._emulateDragOver, 50)) : (c && (c.effectAllowed = "move", d.setData && d.setData.call(this, c, s)), e(N, "drop", this), setTimeout(this._dragStarted, 0))
    },
    _onDragOver: function(a) {
      var d, e, f, g = this.el,
        i = this.options,
        j = i.group,
        l = j.put,
        o = F === j,
        p = i.sort;
      if (void 0 !== a.preventDefault && (a.preventDefault(), !i.dragoverBubble && a.stopPropagation()), I = !0, F && !i.disabled && (o ? p || (f = !w.contains(s)) : F.pull && l && (F.name === j.name || l.indexOf && ~l.indexOf(F.name))) && (void 0 === a.rootEl || a.rootEl === this.el)) {
        if (U(a, i, this.el), R) return;
        if (d = c(a.target, i.draggable, g), e = s.getBoundingClientRect(), f) return b(!0), void(v || x ? w.insertBefore(s, v || x) : p || w.appendChild(s));
        if (0 === g.children.length || g.children[0] === u || g === a.target && (d = n(g, a))) {
          if (d) {
            if (d.animated) return;
            r = d.getBoundingClientRect()
          }
          b(o), k(w, g, s, e, d, r) !== !1 && (s.contains(g) || (g.appendChild(s), t = g), this._animate(e, s), d && this._animate(r, d))
        } else if (d && !d.animated && d !== s && void 0 !== d.parentNode[L]) {
          A !== d && (A = d, B = h(d), C = h(d.parentNode));
          var q, r = d.getBoundingClientRect(),
            y = r.right - r.left,
            z = r.bottom - r.top,
            D = /left|right|inline/.test(B.cssFloat + B.display) || "flex" == C.display && 0 === C["flex-direction"].indexOf("row"),
            E = d.offsetWidth > s.offsetWidth,
            G = d.offsetHeight > s.offsetHeight,
            H = (D ? (a.clientX - r.left) / y : (a.clientY - r.top) / z) > .5,
            J = d.nextElementSibling,
            K = k(w, g, s, e, d, r);
          if (K !== !1) {
            if (R = !0, setTimeout(m, 30), b(o), 1 === K || -1 === K) q = 1 === K;
            else if (D) {
              var M = s.offsetTop,
                N = d.offsetTop;
              q = M === N ? d.previousElementSibling === s && !E || H && E : N > M
            } else q = J !== s && !G || H && G;
            s.contains(g) || (q && !J ? g.appendChild(s) : d.parentNode.insertBefore(s, q ? J : d)), t = s.parentNode, this._animate(e, s), this._animate(r, d)
          }
        }
      }
    },
    _animate: function(a, b) {
      var c = this.options.animation;
      if (c) {
        var d = b.getBoundingClientRect();
        h(b, "transition", "none"), h(b, "transform", "translate3d(" + (a.left - d.left) + "px," + (a.top - d.top) + "px,0)"), b.offsetWidth, h(b, "transition", "all " + c + "ms"), h(b, "transform", "translate3d(0,0,0)"), clearTimeout(b.animated), b.animated = setTimeout(function() {
          h(b, "transition", ""), h(b, "transform", ""), b.animated = !1
        }, c)
      }
    },
    _offUpEvents: function() {
      var a = this.el.ownerDocument;
      f(N, "touchmove", this._onTouchMove), f(a, "mouseup", this._onDrop), f(a, "touchend", this._onDrop), f(a, "touchcancel", this._onDrop)
    },
    _onDrop: function(b) {
      var c = this.el,
        d = this.options;
      clearInterval(this._loopId), clearInterval(J.pid), clearTimeout(this._dragStartTimer), f(N, "mousemove", this._onTouchMove), this.nativeDraggable && (f(N, "drop", this), f(c, "dragstart", this._onDragStart)), this._offUpEvents(), b && (I && (b.preventDefault(), !d.dropBubble && b.stopPropagation()), u && u.parentNode.removeChild(u), s && (this.nativeDraggable && f(s, "dragend", this), l(s), g(s, this.options.ghostClass, !1), g(s, this.options.chosenClass, !1), w !== t ? (E = p(s), E >= 0 && (j(null, t, "sort", s, w, D, E), j(this, w, "sort", s, w, D, E), j(null, t, "add", s, w, D, E), j(this, w, "remove", s, w, D, E))) : (v && v.parentNode.removeChild(v), s.nextSibling !== x && (E = p(s), E >= 0 && (j(this, w, "update", s, w, D, E), j(this, w, "sort", s, w, D, E)))), a.active && ((null === E || -1 === E) && (E = D), j(this, w, "end", s, w, D, E), this.save())), w = s = t = u = x = v = y = z = G = H = I = E = A = B = F = a.active = null)
    },
    handleEvent: function(a) {
      var b = a.type;
      "dragover" === b || "dragenter" === b ? s && (this._onDragOver(a), d(a)) : ("drop" === b || "dragend" === b) && this._onDrop(a)
    },
    toArray: function() {
      for (var a, b = [], d = this.el.children, e = 0, f = d.length, g = this.options; f > e; e++) a = d[e], c(a, g.draggable, this.el) && b.push(a.getAttribute(g.dataIdAttr) || o(a));
      return b
    },
    sort: function(a) {
      var b = {},
        d = this.el;
      this.toArray().forEach(function(a, e) {
        var f = d.children[e];
        c(f, this.options.draggable, d) && (b[a] = f)
      }, this), a.forEach(function(a) {
        b[a] && (d.removeChild(b[a]), d.appendChild(b[a]))
      })
    },
    save: function() {
      var a = this.options.store;
      a && a.set(this)
    },
    closest: function(a, b) {
      return c(a, b || this.options.draggable, this.el)
    },
    option: function(a, b) {
      var c = this.options;
      return void 0 === b ? c[a] : (c[a] = b, void("group" === a && V(c)))
    },
    destroy: function() {
      var a = this.el;
      a[L] = null, f(a, "mousedown", this._onTapStart), f(a, "touchstart", this._onTapStart), this.nativeDraggable && (f(a, "dragover", this), f(a, "dragenter", this)), Array.prototype.forEach.call(a.querySelectorAll("[draggable]"), function(a) {
        a.removeAttribute("draggable")
      }), T.splice(T.indexOf(this._onDragOver), 1), this._onDrop(), this.el = a = null
    }
  }, a.utils = {
    on: e,
    off: f,
    css: h,
    find: i,
    is: function(a, b) {
      return !!c(a, b, a)
    },
    extend: r,
    throttle: q,
    closest: c,
    toggleClass: g,
    index: p
  }, a.create = function(b, c) {
    return new a(b, c)
  }, a.version = "1.4.2", a
});
/*! RESOURCE: /scripts/libs/lodash.min.js */
/**
 * @license
 * lodash 4.11.0 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash -o ./dist/lodash.js`
 */
;
(function() {
  function t(t, n) {
    return t.set(n[0], n[1]), t
  }

  function n(t, n) {
    return t.add(n), t
  }

  function r(t, n, r) {
    switch (r.length) {
      case 0:
        return t.call(n);
      case 1:
        return t.call(n, r[0]);
      case 2:
        return t.call(n, r[0], r[1]);
      case 3:
        return t.call(n, r[0], r[1], r[2])
    }
    return t.apply(n, r)
  }

  function e(t, n, r, e) {
    for (var u = -1, o = t.length; ++u < o;) {
      var i = t[u];
      n(e, i, r(i), t)
    }
    return e
  }

  function u(t, n) {
    for (var r = -1, e = t.length; ++r < e && false !== n(t[r], r, t););
    return t
  }

  function o(t, n) {
    for (var r = -1, e = t.length; ++r < e;)
      if (!n(t[r], r, t)) return false;
    return true
  }

  function i(t, n) {
    for (var r = -1, e = t.length, u = 0, o = []; ++r < e;) {
      var i = t[r];
      n(i, r, t) && (o[u++] = i)
    }
    return o
  }

  function f(t, n) {
    return !!t.length && -1 < d(t, n, 0)
  }

  function c(t, n, r) {
    for (var e = -1, u = t.length; ++e < u;)
      if (r(n, t[e])) return true;
    return false
  }

  function a(t, n) {
    for (var r = -1, e = t.length, u = Array(e); ++r < e;) u[r] = n(t[r], r, t);
    return u
  }

  function l(t, n) {
    for (var r = -1, e = n.length, u = t.length; ++r < e;) t[u + r] = n[r];
    return t
  }

  function s(t, n, r, e) {
    var u = -1,
      o = t.length;
    for (e && o && (r = t[++u]); ++u < o;) r = n(r, t[u], u, t);
    return r
  }

  function h(t, n, r, e) {
    var u = t.length;
    for (e && u && (r = t[--u]); u--;) r = n(r, t[u], u, t);
    return r
  }

  function p(t, n) {
    for (var r = -1, e = t.length; ++r < e;)
      if (n(t[r], r, t)) return true;
    return false
  }

  function _(t, n, r) {
    for (var e = -1, u = t.length; ++e < u;) {
      var o = t[e],
        i = n(o);
      if (null != i && (f === q ? i === i : r(i, f))) var f = i,
        c = o
    }
    return c
  }

  function v(t, n, r, e) {
    var u;
    return r(t, function(t, r, o) {
      return n(t, r, o) ? (u = e ? r : t, false) : void 0
    }), u
  }

  function g(t, n, r) {
    for (var e = t.length, u = r ? e : -1; r ? u-- : ++u < e;)
      if (n(t[u], u, t)) return u;
    return -1
  }

  function d(t, n, r) {
    if (n !== n) return M(t, r);
    --r;
    for (var e = t.length; ++r < e;)
      if (t[r] === n) return r;
    return -1
  }

  function y(t, n, r, e) {
    --r;
    for (var u = t.length; ++r < u;)
      if (e(t[r], n)) return r;
    return -1
  }

  function b(t, n) {
    var r = t ? t.length : 0;
    return r ? m(t, n) / r : K
  }

  function x(t, n, r, e, u) {
    return u(t, function(t, u, o) {
      r = e ? (e = false, t) : n(r, t, u, o)
    }), r
  }

  function j(t, n) {
    var r = t.length;
    for (t.sort(n); r--;) t[r] = t[r].c;
    return t
  }

  function m(t, n) {
    for (var r, e = -1, u = t.length; ++e < u;) {
      var o = n(t[e]);
      o !== q && (r = r === q ? o : r + o)
    }
    return r
  }

  function w(t, n) {
    for (var r = -1, e = Array(t); ++r < t;) e[r] = n(r);
    return e
  }

  function A(t, n) {
    return a(n, function(n) {
      return [n, t[n]];
    })
  }

  function O(t) {
    return function(n) {
      return t(n)
    }
  }

  function k(t, n) {
    return a(n, function(n) {
      return t[n]
    })
  }

  function E(t, n) {
    for (var r = -1, e = t.length; ++r < e && -1 < d(n, t[r], 0););
    return r
  }

  function I(t, n) {
    for (var r = t.length; r-- && -1 < d(n, t[r], 0););
    return r
  }

  function S(t) {
    return t && t.Object === Object ? t : null
  }

  function R(t, n) {
    if (t !== n) {
      var r = null === t,
        e = t === q,
        u = t === t,
        o = null === n,
        i = n === q,
        f = n === n;
      if (t > n && !o || !u || r && !i && f || e && f) return 1;
      if (n > t && !r || !f || o && !e && u || i && u) return -1
    }
    return 0
  }

  function W(t) {
    return function(n, r) {
      var e;
      return n === q && r === q ? 0 : (n !== q && (e = n), r !== q && (e = e === q ? r : t(e, r)), e)
    }
  }

  function B(t) {
    return Ut[t]
  }

  function L(t) {
    return Dt[t]
  }

  function C(t) {
    return "\\" + Nt[t]
  }

  function M(t, n, r) {
    var e = t.length;
    for (n += r ? 0 : -1; r ? n-- : ++n < e;) {
      var u = t[n];
      if (u !== u) return n
    }
    return -1
  }

  function z(t) {
    var n = false;
    if (null != t && typeof t.toString != "function") try {
      n = !!(t + "")
    } catch (r) {}
    return n
  }

  function U(t, n) {
    return t = typeof t == "number" || jt.test(t) ? +t : -1, t > -1 && 0 == t % 1 && (null == n ? 9007199254740991 : n) > t
  }

  function D(t) {
    for (var n, r = []; !(n = t.next()).done;) r.push(n.value);
    return r
  }

  function $(t) {
    var n = -1,
      r = Array(t.size);
    return t.forEach(function(t, e) {
      r[++n] = [e, t]
    }), r
  }

  function F(t, n) {
    for (var r = -1, e = t.length, u = 0, o = []; ++r < e;) {
      var i = t[r];
      i !== n && "__lodash_placeholder__" !== i || (t[r] = "__lodash_placeholder__", o[u++] = r)
    }
    return o
  }

  function N(t) {
    var n = -1,
      r = Array(t.size);
    return t.forEach(function(t) {
      r[++n] = t
    }), r
  }

  function P(t) {
    if (!t || !Bt.test(t)) return t.length;
    for (var n = Rt.lastIndex = 0; Rt.test(t);) n++;
    return n
  }

  function Z(t) {
    return $t[t]
  }

  function T(S) {
    function jt(t) {
      if (Le(t) && !oi(t) && !(t instanceof Et)) {
        if (t instanceof kt) return t;
        if (xu.call(t, "__wrapped__")) return Xr(t)
      }
      return new kt(t)
    }

    function Ot() {}

    function kt(t, n) {
      this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!n, this.__index__ = 0, this.__values__ = q
    }

    function Et(t) {
      this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = []
    }

    function Ut() {}

    function Dt(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.clear(); ++n < r;) {
        var e = t[n];
        this.set(e[0], e[1])
      }
    }

    function $t(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.__data__ = new Dt; ++n < r;) this.push(t[n])
    }

    function Ft(t, n) {
      var r = t.__data__;
      return qr(n) ? (r = r.__data__, "__lodash_hash_undefined__" === (typeof n == "string" ? r.string : r.hash)[n]) : r.has(n)
    }

    function Nt(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.clear(); ++n < r;) {
        var e = t[n];
        this.set(e[0], e[1])
      }
    }

    function Tt(t, n) {
      var r = Kt(t, n);
      return 0 > r ? false : (r == t.length - 1 ? t.pop() : Uu.call(t, r, 1), true)
    }

    function qt(t, n) {
      var r = Kt(t, n);
      return 0 > r ? q : t[r][1]
    }

    function Kt(t, n) {
      for (var r = t.length; r--;)
        if (we(t[r][0], n)) return r;
      return -1
    }

    function Gt(t, n, r) {
      var e = Kt(t, n);
      0 > e ? t.push([n, r]) : t[e][1] = r
    }

    function Jt(t, n, r, e) {
      return t === q || we(t, du[r]) && !xu.call(e, r) ? n : t
    }

    function Qt(t, n, r) {
      (r === q || we(t[n], r)) && (typeof n != "number" || r !== q || n in t) || (t[n] = r)
    }

    function Xt(t, n, r) {
      var e = t[n];
      xu.call(t, n) && we(e, r) && (r !== q || n in t) || (t[n] = r)
    }

    function tn(t, n, r, e) {
      return _o(t, function(t, u, o) {
        n(e, t, r(t), o)
      }), e
    }

    function nn(t, n) {
      return t && ir(n, He(n), t)
    }

    function rn(t, n) {
      for (var r = -1, e = null == t, u = n.length, o = Array(u); ++r < u;) o[r] = e ? q : Ge(t, n[r]);
      return o
    }

    function en(t, n, r) {
      return t === t && (r !== q && (t = t > r ? r : t),
        n !== q && (t = n > t ? n : t)), t
    }

    function un(t, n, r, e, o, i, f) {
      var c;
      if (e && (c = i ? e(t, o, i, f) : e(t)), c !== q) return c;
      if (!Be(t)) return t;
      if (o = oi(t)) {
        if (c = Ur(t), !n) return or(t, c)
      } else {
        var a = Mr(t),
          l = "[object Function]" == a || "[object GeneratorFunction]" == a;
        if (ii(t)) return nr(t, n);
        if ("[object Object]" == a || "[object Arguments]" == a || l && !i) {
          if (z(t)) return i ? t : {};
          if (c = Dr(l ? {} : t), !n) return fr(t, nn(c, t))
        } else {
          if (!zt[a]) return i ? t : {};
          c = $r(t, a, un, n)
        }
      }
      if (f || (f = new Nt), i = f.get(t)) return i;
      if (f.set(t, c), !o) var s = r ? dn(t, He, Cr) : He(t);
      return u(s || t, function(u, o) {
        s && (o = u, u = t[o]), Xt(c, o, un(u, n, r, e, o, t, f))
      }), c
    }

    function on(t) {
      var n = He(t),
        r = n.length;
      return function(e) {
        if (null == e) return !r;
        for (var u = r; u--;) {
          var o = n[u],
            i = t[o],
            f = e[o];
          if (f === q && !(o in Object(e)) || !i(f)) return false
        }
        return true
      }
    }

    function fn(t) {
      return Be(t) ? Cu(t) : {}
    }

    function cn(t, n, r) {
      if (typeof t != "function") throw new vu("Expected a function");
      return zu(function() {
        t.apply(q, r)
      }, n)
    }

    function an(t, n, r, e) {
      var u = -1,
        o = f,
        i = true,
        l = t.length,
        s = [],
        h = n.length;
      if (!l) return s;
      r && (n = a(n, O(r))), e ? (o = c, i = false) : n.length >= 200 && (o = Ft,
        i = false, n = new $t(n));
      t: for (; ++u < l;) {
        var p = t[u],
          _ = r ? r(p) : p;
        if (i && _ === _) {
          for (var v = h; v--;)
            if (n[v] === _) continue t;
          s.push(p)
        } else o(n, _, e) || s.push(p)
      }
      return s
    }

    function ln(t, n) {
      var r = true;
      return _o(t, function(t, e, u) {
        return r = !!n(t, e, u)
      }), r
    }

    function sn(t, n) {
      var r = [];
      return _o(t, function(t, e, u) {
        n(t, e, u) && r.push(t)
      }), r
    }

    function hn(t, n, r, e, u) {
      var o = -1,
        i = t.length;
      for (r || (r = Nr), u || (u = []); ++o < i;) {
        var f = t[o];
        n > 0 && r(f) ? n > 1 ? hn(f, n - 1, r, e, u) : l(u, f) : e || (u[u.length] = f)
      }
      return u
    }

    function pn(t, n) {
      return t && go(t, n, He)
    }

    function _n(t, n) {
      return t && yo(t, n, He)
    }

    function vn(t, n) {
      return i(n, function(n) {
        return Se(t[n])
      })
    }

    function gn(t, n) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var r = 0, e = n.length; null != t && e > r;) t = t[n[r++]];
      return r && r == e ? t : q
    }

    function dn(t, n, r) {
      return n = n(t), oi(t) ? n : l(n, r(t))
    }

    function yn(t, n) {
      return xu.call(t, n) || typeof t == "object" && n in t && null === Fu(Object(t))
    }

    function bn(t, n) {
      return n in Object(t)
    }

    function xn(t, n, r) {
      for (var e = r ? c : f, u = t[0].length, o = t.length, i = o, l = Array(o), s = 1 / 0, h = []; i--;) {
        var p = t[i];
        i && n && (p = a(p, O(n))), s = qu(p.length, s),
          l[i] = r || !n && (120 > u || 120 > p.length) ? q : new $t(i && p)
      }
      var p = t[0],
        _ = -1,
        v = l[0];
      t: for (; ++_ < u && s > h.length;) {
        var g = p[_],
          d = n ? n(g) : g;
        if (v ? !Ft(v, d) : !e(h, d, r)) {
          for (i = o; --i;) {
            var y = l[i];
            if (y ? !Ft(y, d) : !e(t[i], d, r)) continue t
          }
          v && v.push(d), h.push(g)
        }
      }
      return h
    }

    function jn(t, n, r) {
      var e = {};
      return pn(t, function(t, u, o) {
        n(e, r(t), u, o)
      }), e
    }

    function mn(t, n, e) {
      return Tr(n, t) || (n = Xn(n), t = Yr(t, n), n = ee(n)), n = null == t ? t : t[n], null == n ? q : r(n, t, e)
    }

    function wn(t, n, r, e, u) {
      if (t === n) n = true;
      else if (null == t || null == n || !Be(t) && !Le(n)) n = t !== t && n !== n;
      else t: {
        var o = oi(t),
          i = oi(n),
          f = "[object Array]",
          c = "[object Array]";o || (f = Mr(t), f = "[object Arguments]" == f ? "[object Object]" : f),
        i || (c = Mr(n), c = "[object Arguments]" == c ? "[object Object]" : c);
        var a = "[object Object]" == f && !z(t),
          i = "[object Object]" == c && !z(n);
        if ((c = f == c) && !a) u || (u = new Nt),
        n = o || Fe(t) ? Er(t, n, wn, r, e, u) : Ir(t, n, f, wn, r, e, u);
        else {
          if (!(2 & e) && (o = a && xu.call(t, "__wrapped__"), f = i && xu.call(n, "__wrapped__"), o || f)) {
            t = o ? t.value() : t, n = f ? n.value() : n, u || (u = new Nt), n = wn(t, n, r, e, u);
            break t
          }
          if (c) n: if (u || (u = new Nt), o = 2 & e,
            f = He(t), i = f.length, c = He(n).length, i == c || o) {
            for (a = i; a--;) {
              var l = f[a];
              if (!(o ? l in n : yn(n, l))) {
                n = false;
                break n
              }
            }
            if (c = u.get(t)) n = c == n;
            else {
              c = true, u.set(t, n);
              for (var s = o; ++a < i;) {
                var l = f[a],
                  h = t[l],
                  p = n[l];
                if (r) var _ = o ? r(p, h, l, n, t, u) : r(h, p, l, t, n, u);
                if (_ === q ? h !== p && !wn(h, p, r, e, u) : !_) {
                  c = false;
                  break
                }
                s || (s = "constructor" == l)
              }
              c && !s && (r = t.constructor, e = n.constructor, r != e && "constructor" in t && "constructor" in n && !(typeof r == "function" && r instanceof r && typeof e == "function" && e instanceof e) && (c = false)), u["delete"](t), n = c
            }
          } else n = false;
          else n = false;
        }
      }
      return n
    }

    function An(t, n, r, e) {
      var u = r.length,
        o = u,
        i = !e;
      if (null == t) return !o;
      for (t = Object(t); u--;) {
        var f = r[u];
        if (i && f[2] ? f[1] !== t[f[0]] : !(f[0] in t)) return false
      }
      for (; ++u < o;) {
        var f = r[u],
          c = f[0],
          a = t[c],
          l = f[1];
        if (i && f[2]) {
          if (a === q && !(c in t)) return false
        } else {
          if (f = new Nt, e) var s = e(a, l, c, t, n, f);
          if (s === q ? !wn(l, a, e, 3, f) : !s) return false
        }
      }
      return true
    }

    function On(t) {
      return typeof t == "function" ? t : null == t ? iu : typeof t == "object" ? oi(t) ? Sn(t[0], t[1]) : In(t) : lu(t)
    }

    function kn(t) {
      t = null == t ? t : Object(t);
      var n, r = [];
      for (n in t) r.push(n);
      return r
    }

    function En(t, n) {
      var r = -1,
        e = ke(t) ? Array(t.length) : [];
      return _o(t, function(t, u, o) {
        e[++r] = n(t, u, o)
      }), e
    }

    function In(t) {
      var n = Wr(t);
      return 1 == n.length && n[0][2] ? Gr(n[0][0], n[0][1]) : function(r) {
        return r === t || An(r, t, n)
      }
    }

    function Sn(t, n) {
      return Tr(t) && n === n && !Be(n) ? Gr(t, n) : function(r) {
        var e = Ge(r, t);
        return e === q && e === n ? Ye(r, t) : wn(n, e, q, 3)
      }
    }

    function Rn(t, n, r, e, o) {
      if (t !== n) {
        if (!oi(n) && !Fe(n)) var i = Qe(n);
        u(i || n, function(u, f) {
          if (i && (f = u, u = n[f]), Be(u)) {
            o || (o = new Nt);
            var c = f,
              a = o,
              l = t[c],
              s = n[c],
              h = a.get(s);
            if (h) Qt(t, c, h);
            else {
              var h = e ? e(l, s, c + "", t, n, a) : q,
                p = h === q;
              p && (h = s, oi(s) || Fe(s) ? oi(l) ? h = l : Ee(l) ? h = or(l) : (p = false, h = un(s, true)) : ze(s) || Oe(s) ? Oe(l) ? h = Ve(l) : !Be(l) || r && Se(l) ? (p = false, h = un(s, true)) : h = l : p = false), a.set(s, h), p && Rn(h, s, r, e, a), a["delete"](s), Qt(t, c, h)
            }
          } else c = e ? e(t[f], u, f + "", t, n, o) : q, c === q && (c = u), Qt(t, f, c)
        })
      }
    }

    function Wn(t, n) {
      var r = t.length;
      return r ? (n += 0 > n ? r : 0, U(n, r) ? t[n] : q) : void 0
    }

    function Bn(t, n, r) {
      var e = -1;
      return n = a(n.length ? n : [iu], O(Rr())), t = En(t, function(t) {
        return {
          a: a(n, function(n) {
            return n(t)
          }),
          b: ++e,
          c: t
        }
      }), j(t, function(t, n) {
        var e;
        t: {
          e = -1;
          for (var u = t.a, o = n.a, i = u.length, f = r.length; ++e < i;) {
            var c = R(u[e], o[e]);
            if (c) {
              e = f > e ? c * ("desc" == r[e] ? -1 : 1) : c;
              break t
            }
          }
          e = t.b - n.b
        }
        return e
      })
    }

    function Ln(t, n) {
      return t = Object(t), s(n, function(n, r) {
        return r in t && (n[r] = t[r]), n
      }, {})
    }

    function Cn(t, n) {
      for (var r = -1, e = dn(t, Qe, wo), u = e.length, o = {}; ++r < u;) {
        var i = e[r],
          f = t[i];
        n(f, i) && (o[i] = f)
      }
      return o
    }

    function Mn(t) {
      return function(n) {
        return null == n ? q : n[t]
      }
    }

    function zn(t) {
      return function(n) {
        return gn(n, t)
      }
    }

    function Un(t, n, r, e) {
      var u = e ? y : d,
        o = -1,
        i = n.length,
        f = t;
      for (r && (f = a(t, O(r))); ++o < i;)
        for (var c = 0, l = n[o], l = r ? r(l) : l; - 1 < (c = u(f, l, c, e));) f !== t && Uu.call(f, c, 1), Uu.call(t, c, 1);
      return t
    }

    function Dn(t, n) {
      for (var r = t ? n.length : 0, e = r - 1; r--;) {
        var u = n[r];
        if (e == r || u != o) {
          var o = u;
          if (U(u)) Uu.call(t, u, 1);
          else if (Tr(u, t)) delete t[u];
          else {
            var u = Xn(u),
              i = Yr(t, u);
            null != i && delete i[ee(u)]
          }
        }
      }
    }

    function $n(t, n) {
      return t + $u(Ku() * (n - t + 1))
    }

    function Fn(t, n) {
      var r = "";
      if (!t || 1 > n || n > 9007199254740991) return r;
      do n % 2 && (r += t), (n = $u(n / 2)) && (t += t); while (n);
      return r;
    }

    function Nn(t, n, r, e) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var u = -1, o = n.length, i = o - 1, f = t; null != f && ++u < o;) {
        var c = n[u];
        if (Be(f)) {
          var a = r;
          if (u != i) {
            var l = f[c],
              a = e ? e(l, c, f) : q;
            a === q && (a = null == l ? U(n[u + 1]) ? [] : {} : l)
          }
          Xt(f, c, a)
        }
        f = f[c]
      }
      return t
    }

    function Pn(t, n, r) {
      var e = -1,
        u = t.length;
      for (0 > n && (n = -n > u ? 0 : u + n), r = r > u ? u : r, 0 > r && (r += u), u = n > r ? 0 : r - n >>> 0, n >>>= 0, r = Array(u); ++e < u;) r[e] = t[e + n];
      return r
    }

    function Zn(t, n) {
      var r;
      return _o(t, function(t, e, u) {
        return r = n(t, e, u), !r
      }), !!r
    }

    function Tn(t, n, r) {
      var e = 0,
        u = t ? t.length : e;
      if (typeof n == "number" && n === n && 2147483647 >= u) {
        for (; u > e;) {
          var o = e + u >>> 1,
            i = t[o];
          (r ? n >= i : n > i) && null !== i ? e = o + 1 : u = o
        }
        return u
      }
      return qn(t, n, iu, r)
    }

    function qn(t, n, r, e) {
      n = r(n);
      for (var u = 0, o = t ? t.length : 0, i = n !== n, f = null === n, c = n === q; o > u;) {
        var a = $u((u + o) / 2),
          l = r(t[a]),
          s = l !== q,
          h = l === l;
        (i ? h || e : f ? h && s && (e || null != l) : c ? h && (e || s) : null == l ? 0 : e ? n >= l : n > l) ? u = a + 1: o = a
      }
      return qu(o, 4294967294)
    }

    function Vn(t, n) {
      for (var r = 0, e = t.length, u = t[0], o = n ? n(u) : u, i = o, f = 1, c = [u]; ++r < e;) u = t[r], o = n ? n(u) : u, we(o, i) || (i = o, c[f++] = u);
      return c
    }

    function Kn(t, n, r) {
      var e = -1,
        u = f,
        o = t.length,
        i = true,
        a = [],
        l = a;
      if (r) i = false, u = c;
      else if (o < 200) l = n ? [] : a;
      else {
        if (u = n ? null : xo(t)) return N(u);
        i = false, u = Ft, l = new $t
      }
      t: for (; ++e < o;) {
        var s = t[e],
          h = n ? n(s) : s;
        if (i && h === h) {
          for (var p = l.length; p--;)
            if (l[p] === h) continue t;
          n && l.push(h), a.push(s)
        } else u(l, h, r) || (l !== a && l.push(h), a.push(s))
      }
      return a
    }

    function Gn(t, n, r, e) {
      for (var u = t.length, o = e ? u : -1;
        (e ? o-- : ++o < u) && n(t[o], o, t););
      return r ? Pn(t, e ? 0 : o, e ? o + 1 : u) : Pn(t, e ? o + 1 : 0, e ? u : o)
    }

    function Jn(t, n) {
      var r = t;
      return r instanceof Et && (r = r.value()), s(n, function(t, n) {
        return n.func.apply(n.thisArg, l([t], n.args));
      }, r)
    }

    function Yn(t, n, r) {
      for (var e = -1, u = t.length; ++e < u;) var o = o ? l(an(o, t[e], n, r), an(t[e], o, n, r)) : t[e];
      return o && o.length ? Kn(o, n, r) : []
    }

    function Hn(t, n, r) {
      for (var e = -1, u = t.length, o = n.length, i = {}; ++e < u;) r(i, t[e], o > e ? n[e] : q);
      return i
    }

    function Qn(t) {
      return Ee(t) ? t : []
    }

    function Xn(t) {
      return oi(t) ? t : Oo(t)
    }

    function tr(t, n, r) {
      var e = t.length;
      return r = r === q ? e : r, n || e > r ? Pn(t, n, r) : t
    }

    function nr(t, n) {
      if (n) return t.slice();
      var r = new t.constructor(t.length);
      return t.copy(r), r
    }

    function rr(t) {
      var n = new t.constructor(t.byteLength);
      return new Su(n).set(new Su(t)), n
    }

    function er(t, n, r, e) {
      var u = -1,
        o = t.length,
        i = r.length,
        f = -1,
        c = n.length,
        a = Tu(o - i, 0),
        l = Array(c + a);
      for (e = !e; ++f < c;) l[f] = n[f];
      for (; ++u < i;)(e || o > u) && (l[r[u]] = t[u]);
      for (; a--;) l[f++] = t[u++];
      return l
    }

    function ur(t, n, r, e) {
      var u = -1,
        o = t.length,
        i = -1,
        f = r.length,
        c = -1,
        a = n.length,
        l = Tu(o - f, 0),
        s = Array(l + a);
      for (e = !e; ++u < l;) s[u] = t[u];
      for (l = u; ++c < a;) s[l + c] = n[c];
      for (; ++i < f;)(e || o > u) && (s[l + r[i]] = t[u++]);
      return s
    }

    function or(t, n) {
      var r = -1,
        e = t.length;
      for (n || (n = Array(e)); ++r < e;) n[r] = t[r];
      return n;
    }

    function ir(t, n, r, e) {
      r || (r = {});
      for (var u = -1, o = n.length; ++u < o;) {
        var i = n[u],
          f = e ? e(r[i], t[i], i, r, t) : t[i];
        Xt(r, i, f)
      }
      return r
    }

    function fr(t, n) {
      return ir(t, Cr(t), n)
    }

    function cr(t, n) {
      return function(r, u) {
        var o = oi(r) ? e : tn,
          i = n ? n() : {};
        return o(r, t, Rr(u), i)
      }
    }

    function ar(t) {
      return je(function(n, r) {
        var e = -1,
          u = r.length,
          o = u > 1 ? r[u - 1] : q,
          i = u > 2 ? r[2] : q,
          o = typeof o == "function" ? (u--, o) : q;
        for (i && Zr(r[0], r[1], i) && (o = 3 > u ? q : o, u = 1), n = Object(n); ++e < u;)(i = r[e]) && t(n, i, e, o);
        return n
      })
    }

    function lr(t, n) {
      return function(r, e) {
        if (null == r) return r;
        if (!ke(r)) return t(r, e);
        for (var u = r.length, o = n ? u : -1, i = Object(r);
          (n ? o-- : ++o < u) && false !== e(i[o], o, i););
        return r
      }
    }

    function sr(t) {
      return function(n, r, e) {
        var u = -1,
          o = Object(n);
        e = e(n);
        for (var i = e.length; i--;) {
          var f = e[t ? i : ++u];
          if (false === r(o[f], f, o)) break
        }
        return n
      }
    }

    function hr(t, n, r) {
      function e() {
        return (this && this !== Yt && this instanceof e ? o : t).apply(u ? r : this, arguments)
      }
      var u = 1 & n,
        o = vr(t);
      return e
    }

    function pr(t) {
      return function(n) {
        n = Ke(n);
        var r = Bt.test(n) ? n.match(Rt) : q,
          e = r ? r[0] : n.charAt(0);
        return n = r ? tr(r, 1).join("") : n.slice(1),
          e[t]() + n
      }
    }

    function _r(t) {
      return function(n) {
        return s(uu(eu(n).replace(It, "")), t, "")
      }
    }

    function vr(t) {
      return function() {
        var n = arguments;
        switch (n.length) {
          case 0:
            return new t;
          case 1:
            return new t(n[0]);
          case 2:
            return new t(n[0], n[1]);
          case 3:
            return new t(n[0], n[1], n[2]);
          case 4:
            return new t(n[0], n[1], n[2], n[3]);
          case 5:
            return new t(n[0], n[1], n[2], n[3], n[4]);
          case 6:
            return new t(n[0], n[1], n[2], n[3], n[4], n[5]);
          case 7:
            return new t(n[0], n[1], n[2], n[3], n[4], n[5], n[6])
        }
        var r = fn(t.prototype),
          n = t.apply(r, n);
        return Be(n) ? n : r;
      }
    }

    function gr(t, n, e) {
      function u() {
        for (var i = arguments.length, f = Array(i), c = i, a = Lr(u); c--;) f[c] = arguments[c];
        return c = 3 > i && f[0] !== a && f[i - 1] !== a ? [] : F(f, a), i -= c.length, e > i ? Ar(t, n, yr, u.placeholder, q, f, c, q, q, e - i) : r(this && this !== Yt && this instanceof u ? o : t, this, f)
      }
      var o = vr(t);
      return u
    }

    function dr(t) {
      return je(function(n) {
        n = hn(n, 1);
        var r = n.length,
          e = r,
          u = kt.prototype.thru;
        for (t && n.reverse(); e--;) {
          var o = n[e];
          if (typeof o != "function") throw new vu("Expected a function");
          if (u && !i && "wrapper" == Sr(o)) var i = new kt([], true);
        }
        for (e = i ? e : r; ++e < r;) var o = n[e],
          u = Sr(o),
          f = "wrapper" == u ? jo(o) : q,
          i = f && Vr(f[0]) && 424 == f[1] && !f[4].length && 1 == f[9] ? i[Sr(f[0])].apply(i, f[3]) : 1 == o.length && Vr(o) ? i[u]() : i.thru(o);
        return function() {
          var t = arguments,
            e = t[0];
          if (i && 1 == t.length && oi(e) && e.length >= 200) return i.plant(e).value();
          for (var u = 0, t = r ? n[u].apply(this, t) : e; ++u < r;) t = n[u].call(this, t);
          return t
        }
      })
    }

    function yr(t, n, r, e, u, o, i, f, c, a) {
      function l() {
        for (var d = arguments.length, y = d, b = Array(d); y--;) b[y] = arguments[y];
        if (_) {
          var x, j = Lr(l),
            y = b.length;
          for (x = 0; y--;) b[y] === j && x++;
        }
        if (e && (b = er(b, e, u, _)), o && (b = ur(b, o, i, _)), d -= x, _ && a > d) return j = F(b, j), Ar(t, n, yr, l.placeholder, r, b, j, f, c, a - d);
        if (j = h ? r : this, y = p ? j[t] : t, d = b.length, f) {
          x = b.length;
          for (var m = qu(f.length, x), w = or(b); m--;) {
            var A = f[m];
            b[m] = U(A, x) ? w[A] : q
          }
        } else v && d > 1 && b.reverse();
        return s && d > c && (b.length = c), this && this !== Yt && this instanceof l && (y = g || vr(y)), y.apply(j, b)
      }
      var s = 128 & n,
        h = 1 & n,
        p = 2 & n,
        _ = 24 & n,
        v = 512 & n,
        g = p ? q : vr(t);
      return l
    }

    function br(t, n) {
      return function(r, e) {
        return jn(r, t, n(e))
      }
    }

    function xr(t) {
      return je(function(n) {
        return n = 1 == n.length && oi(n[0]) ? a(n[0], O(Rr())) : a(hn(n, 1, Pr), O(Rr())),
          je(function(e) {
            var u = this;
            return t(n, function(t) {
              return r(t, u, e)
            })
          })
      })
    }

    function jr(t, n) {
      n = n === q ? " " : n + "";
      var r = n.length;
      return 2 > r ? r ? Fn(n, t) : n : (r = Fn(n, Du(t / P(n))), Bt.test(n) ? tr(r.match(Rt), 0, t).join("") : r.slice(0, t))
    }

    function mr(t, n, e, u) {
      function o() {
        for (var n = -1, c = arguments.length, a = -1, l = u.length, s = Array(l + c), h = this && this !== Yt && this instanceof o ? f : t; ++a < l;) s[a] = u[a];
        for (; c--;) s[a++] = arguments[++n];
        return r(h, i ? e : this, s)
      }
      var i = 1 & n,
        f = vr(t);
      return o
    }

    function wr(t) {
      return function(n, r, e) {
        e && typeof e != "number" && Zr(n, r, e) && (r = e = q),
          n = qe(n), n = n === n ? n : 0, r === q ? (r = n, n = 0) : r = qe(r) || 0, e = e === q ? r > n ? 1 : -1 : qe(e) || 0;
        var u = -1;
        r = Tu(Du((r - n) / (e || 1)), 0);
        for (var o = Array(r); r--;) o[t ? r : ++u] = n, n += e;
        return o
      }
    }

    function Ar(t, n, r, e, u, o, i, f, c, a) {
      var l = 8 & n,
        s = l ? i : q;
      i = l ? q : i;
      var h = l ? o : q;
      return o = l ? q : o, n = (n | (l ? 32 : 64)) & ~(l ? 64 : 32), 4 & n || (n &= -4), n = [t, n, u, h, s, o, i, f, c, a], r = r.apply(q, n), Vr(t) && Ao(r, n), r.placeholder = e, r
    }

    function Or(t) {
      var n = pu[t];
      return function(t, r) {
        if (t = qe(t), r = Ze(r)) {
          var e = (Ke(t) + "e").split("e"),
            e = n(e[0] + "e" + (+e[1] + r)),
            e = (Ke(e) + "e").split("e");
          return +(e[0] + "e" + (+e[1] - r))
        }
        return n(t)
      }
    }

    function kr(t, n, r, e, u, o, i, f) {
      var c = 2 & n;
      if (!c && typeof t != "function") throw new vu("Expected a function");
      var a = e ? e.length : 0;
      if (a || (n &= -97, e = u = q), i = i === q ? i : Tu(Ze(i), 0), f = f === q ? f : Ze(f), a -= u ? u.length : 0, 64 & n) {
        var l = e,
          s = u;
        e = u = q
      }
      var h = c ? q : jo(t);
      return o = [t, n, r, e, u, l, s, o, i, f], h && (r = o[1], t = h[1], n = r | t, e = 128 == t && 8 == r || 128 == t && 256 == r && h[8] >= o[7].length || 384 == t && h[8] >= h[7].length && 8 == r, 131 > n || e) && (1 & t && (o[2] = h[2], n |= 1 & r ? 0 : 4), (r = h[3]) && (e = o[3], o[3] = e ? er(e, r, h[4]) : r, o[4] = e ? F(o[3], "__lodash_placeholder__") : h[4]),
        (r = h[5]) && (e = o[5], o[5] = e ? ur(e, r, h[6]) : r, o[6] = e ? F(o[5], "__lodash_placeholder__") : h[6]), (r = h[7]) && (o[7] = r), 128 & t && (o[8] = null == o[8] ? h[8] : qu(o[8], h[8])), null == o[9] && (o[9] = h[9]), o[0] = h[0], o[1] = n), t = o[0], n = o[1], r = o[2], e = o[3], u = o[4], f = o[9] = null == o[9] ? c ? 0 : t.length : Tu(o[9] - a, 0), !f && 24 & n && (n &= -25), (h ? bo : Ao)(n && 1 != n ? 8 == n || 16 == n ? gr(t, n, f) : 32 != n && 33 != n || u.length ? yr.apply(q, o) : mr(t, n, r, e) : hr(t, n, r), o)
    }

    function Er(t, n, r, e, u, o) {
      var i = -1,
        f = 2 & u,
        c = 1 & u,
        a = t.length,
        l = n.length;
      if (!(a == l || f && l > a)) return false;
      if (l = o.get(t)) return l == n;
      for (l = true, o.set(t, n); ++i < a;) {
        var s = t[i],
          h = n[i];
        if (e) var _ = f ? e(h, s, i, n, t, o) : e(s, h, i, t, n, o);
        if (_ !== q) {
          if (_) continue;
          l = false;
          break
        }
        if (c) {
          if (!p(n, function(t) {
              return s === t || r(s, t, e, u, o)
            })) {
            l = false;
            break
          }
        } else if (s !== h && !r(s, h, e, u, o)) {
          l = false;
          break
        }
      }
      return o["delete"](t), l
    }

    function Ir(t, n, r, e, u, o, i) {
      switch (r) {
        case "[object DataView]":
          if (t.byteLength != n.byteLength || t.byteOffset != n.byteOffset) break;
          t = t.buffer, n = n.buffer;
        case "[object ArrayBuffer]":
          if (t.byteLength != n.byteLength || !e(new Su(t), new Su(n))) break;
          return true;
        case "[object Boolean]":
        case "[object Date]":
          return +t == +n;
        case "[object Error]":
          return t.name == n.name && t.message == n.message;
        case "[object Number]":
          return t != +t ? n != +n : t == +n;
        case "[object RegExp]":
        case "[object String]":
          return t == n + "";
        case "[object Map]":
          var f = $;
        case "[object Set]":
          if (f || (f = N), t.size != n.size && !(2 & o)) break;
          return (r = i.get(t)) ? r == n : (o |= 1, i.set(t, n), Er(f(t), f(n), e, u, o, i));
        case "[object Symbol]":
          if (ho) return ho.call(t) == ho.call(n)
      }
      return false
    }

    function Sr(t) {
      for (var n = t.name + "", r = oo[n], e = xu.call(oo, n) ? r.length : 0; e--;) {
        var u = r[e],
          o = u.func;
        if (null == o || o == t) return u.name
      }
      return n
    }

    function Rr() {
      var t = jt.iteratee || fu,
        t = t === fu ? On : t;
      return arguments.length ? t(arguments[0], arguments[1]) : t
    }

    function Wr(t) {
      t = Xe(t);
      for (var n = t.length; n--;) {
        var r = t[n][1];
        t[n][2] = r === r && !Be(r)
      }
      return t
    }

    function Br(t, n) {
      var r = t[n];
      return Ce(r) ? r : q
    }

    function Lr(t) {
      return (xu.call(jt, "placeholder") ? jt : t).placeholder
    }

    function Cr(t) {
      return Bu(Object(t))
    }

    function Mr(t) {
      return wu.call(t)
    }

    function zr(t, n, r) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var e, u = -1, o = n.length; ++u < o;) {
        var i = n[u];
        if (!(e = null != t && r(t, i))) break;
        t = t[i]
      }
      return e ? e : (o = t ? t.length : 0, !!o && We(o) && U(i, o) && (oi(t) || De(t) || Oe(t)))
    }

    function Ur(t) {
      var n = t.length,
        r = t.constructor(n);
      return n && "string" == typeof t[0] && xu.call(t, "index") && (r.index = t.index, r.input = t.input), r
    }

    function Dr(t) {
      return typeof t.constructor != "function" || Kr(t) ? {} : fn(Fu(Object(t)))
    }

    function $r(r, e, u, o) {
      var i = r.constructor;
      switch (e) {
        case "[object ArrayBuffer]":
          return rr(r);
        case "[object Boolean]":
        case "[object Date]":
          return new i(+r);
        case "[object DataView]":
          return e = o ? rr(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.byteLength);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return e = o ? rr(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.length);
        case "[object Map]":
          return e = o ? u($(r), true) : $(r), s(e, t, new r.constructor);
        case "[object Number]":
        case "[object String]":
          return new i(r);
        case "[object RegExp]":
          return e = new r.constructor(r.source, vt.exec(r)), e.lastIndex = r.lastIndex, e;
        case "[object Set]":
          return e = o ? u(N(r), true) : N(r), s(e, n, new r.constructor);
        case "[object Symbol]":
          return ho ? Object(ho.call(r)) : {}
      }
    }

    function Fr(t) {
      var n = t ? t.length : q;
      return We(n) && (oi(t) || De(t) || Oe(t)) ? w(n, String) : null
    }

    function Nr(t) {
      return Ee(t) && (oi(t) || Oe(t))
    }

    function Pr(t) {
      return oi(t) && !(2 == t.length && !Se(t[0]))
    }

    function Zr(t, n, r) {
      if (!Be(r)) return false;
      var e = typeof n;
      return ("number" == e ? ke(r) && U(n, r.length) : "string" == e && n in r) ? we(r[n], t) : false;
    }

    function Tr(t, n) {
      var r = typeof t;
      return "number" == r || "symbol" == r ? true : !oi(t) && ($e(t) || ot.test(t) || !ut.test(t) || null != n && t in Object(n))
    }

    function qr(t) {
      var n = typeof t;
      return "number" == n || "boolean" == n || "string" == n && "__proto__" != t || null == t
    }

    function Vr(t) {
      var n = Sr(t),
        r = jt[n];
      return typeof r == "function" && n in Et.prototype ? t === r ? true : (n = jo(r), !!n && t === n[0]) : false
    }

    function Kr(t) {
      var n = t && t.constructor;
      return t === (typeof n == "function" && n.prototype || du)
    }

    function Gr(t, n) {
      return function(r) {
        return null == r ? false : r[t] === n && (n !== q || t in Object(r));
      }
    }

    function Jr(t, n, r, e, u, o) {
      return Be(t) && Be(n) && Rn(t, n, q, Jr, o.set(n, t)), t
    }

    function Yr(t, n) {
      return 1 == n.length ? t : gn(t, Pn(n, 0, -1))
    }

    function Hr(t) {
      return typeof t == "string" || $e(t) ? t : t + ""
    }

    function Qr(t) {
      if (null != t) {
        try {
          return bu.call(t)
        } catch (n) {}
        return t + ""
      }
      return ""
    }

    function Xr(t) {
      if (t instanceof Et) return t.clone();
      var n = new kt(t.__wrapped__, t.__chain__);
      return n.__actions__ = or(t.__actions__), n.__index__ = t.__index__, n.__values__ = t.__values__, n
    }

    function te(t, n, r) {
      var e = t ? t.length : 0;
      return e ? (n = r || n === q ? 1 : Ze(n),
        Pn(t, 0 > n ? 0 : n, e)) : []
    }

    function ne(t, n, r) {
      var e = t ? t.length : 0;
      return e ? (n = r || n === q ? 1 : Ze(n), n = e - n, Pn(t, 0, 0 > n ? 0 : n)) : []
    }

    function re(t) {
      return t && t.length ? t[0] : q
    }

    function ee(t) {
      var n = t ? t.length : 0;
      return n ? t[n - 1] : q
    }

    function ue(t, n) {
      return t && t.length && n && n.length ? Un(t, n) : t
    }

    function oe(t) {
      return t ? Ju.call(t) : t
    }

    function ie(t) {
      if (!t || !t.length) return [];
      var n = 0;
      return t = i(t, function(t) {
        return Ee(t) ? (n = Tu(t.length, n), true) : void 0
      }), w(n, function(n) {
        return a(t, Mn(n))
      })
    }

    function fe(t, n) {
      if (!t || !t.length) return [];
      var e = ie(t);
      return null == n ? e : a(e, function(t) {
        return r(n, q, t)
      })
    }

    function ce(t) {
      return t = jt(t), t.__chain__ = true, t
    }

    function ae(t, n) {
      return n(t)
    }

    function le() {
      return this
    }

    function se(t, n) {
      return typeof n == "function" && oi(t) ? u(t, n) : _o(t, Rr(n))
    }

    function he(t, n) {
      var r;
      if (typeof n == "function" && oi(t)) {
        for (r = t.length; r-- && false !== n(t[r], r, t););
        r = t
      } else r = vo(t, Rr(n));
      return r
    }

    function pe(t, n) {
      return (oi(t) ? a : En)(t, Rr(n, 3))
    }

    function _e(t, n, r) {
      var e = -1,
        u = Pe(t),
        o = u.length,
        i = o - 1;
      for (n = (r ? Zr(t, n, r) : n === q) ? 1 : en(Ze(n), 0, o); ++e < n;) t = $n(e, i),
        r = u[t], u[t] = u[e], u[e] = r;
      return u.length = n, u
    }

    function ve(t, n, r) {
      return n = r ? q : n, n = t && null == n ? t.length : n, kr(t, 128, q, q, q, q, n)
    }

    function ge(t, n) {
      var r;
      if (typeof n != "function") throw new vu("Expected a function");
      return t = Ze(t),
        function() {
          return 0 < --t && (r = n.apply(this, arguments)), 1 >= t && (n = q), r
        }
    }

    function de(t, n, r) {
      return n = r ? q : n, t = kr(t, 8, q, q, q, q, q, n), t.placeholder = de.placeholder, t
    }

    function ye(t, n, r) {
      return n = r ? q : n, t = kr(t, 16, q, q, q, q, q, n), t.placeholder = ye.placeholder, t
    }

    function be(t, n, r) {
      function e(n) {
        var r = c,
          e = a;
        return c = a = q, p = n, l = t.apply(e, r)
      }

      function u(t) {
        var r = t - h;
        return t -= p, !h || r >= n || 0 > r || false !== v && t >= v
      }

      function o() {
        var t = Yo();
        if (u(t)) return i(t);
        var r;
        r = t - p, t = n - (t - h), r = false === v ? t : qu(t, v - r), s = zu(o, r)
      }

      function i(t) {
        return Ru(s), s = q, g && c ? e(t) : (c = a = q, l)
      }

      function f() {
        var t = Yo(),
          r = u(t);
        return c = arguments, a = this, h = t, r ? s === q ? (p = t = h, s = zu(o, n), _ ? e(t) : l) : (Ru(s), s = zu(o, n), e(h)) : (s === q && (s = zu(o, n)), l)
      }
      var c, a, l, s, h = 0,
        p = 0,
        _ = false,
        v = false,
        g = true;
      if (typeof t != "function") throw new vu("Expected a function");
      return n = qe(n) || 0, Be(r) && (_ = !!r.leading,
        v = "maxWait" in r && Tu(qe(r.maxWait) || 0, n), g = "trailing" in r ? !!r.trailing : g), f.cancel = function() {
        s !== q && Ru(s), h = p = 0, c = a = s = q
      }, f.flush = function() {
        return s === q ? l : i(Yo())
      }, f
    }

    function xe(t, n) {
      function r() {
        var e = arguments,
          u = n ? n.apply(this, e) : e[0],
          o = r.cache;
        return o.has(u) ? o.get(u) : (e = t.apply(this, e), r.cache = o.set(u, e), e)
      }
      if (typeof t != "function" || n && typeof n != "function") throw new vu("Expected a function");
      return r.cache = new(xe.Cache || Dt), r
    }

    function je(t, n) {
      if (typeof t != "function") throw new vu("Expected a function");
      return n = Tu(n === q ? t.length - 1 : Ze(n), 0),
        function() {
          for (var e = arguments, u = -1, o = Tu(e.length - n, 0), i = Array(o); ++u < o;) i[u] = e[n + u];
          switch (n) {
            case 0:
              return t.call(this, i);
            case 1:
              return t.call(this, e[0], i);
            case 2:
              return t.call(this, e[0], e[1], i)
          }
          for (o = Array(n + 1), u = -1; ++u < n;) o[u] = e[u];
          return o[n] = i, r(t, this, o)
        }
    }

    function me() {
      if (!arguments.length) return [];
      var t = arguments[0];
      return oi(t) ? t : [t]
    }

    function we(t, n) {
      return t === n || t !== t && n !== n
    }

    function Ae(t, n) {
      return t > n
    }

    function Oe(t) {
      return Ee(t) && xu.call(t, "callee") && (!Mu.call(t, "callee") || "[object Arguments]" == wu.call(t));
    }

    function ke(t) {
      return null != t && We(mo(t)) && !Se(t)
    }

    function Ee(t) {
      return Le(t) && ke(t)
    }

    function Ie(t) {
      return Le(t) ? "[object Error]" == wu.call(t) || typeof t.message == "string" && typeof t.name == "string" : false
    }

    function Se(t) {
      return t = Be(t) ? wu.call(t) : "", "[object Function]" == t || "[object GeneratorFunction]" == t
    }

    function Re(t) {
      return typeof t == "number" && t == Ze(t)
    }

    function We(t) {
      return typeof t == "number" && t > -1 && 0 == t % 1 && 9007199254740991 >= t
    }

    function Be(t) {
      var n = typeof t;
      return !!t && ("object" == n || "function" == n)
    }

    function Le(t) {
      return !!t && typeof t == "object"
    }

    function Ce(t) {
      return Be(t) ? (Se(t) || z(t) ? Ou : bt).test(Qr(t)) : false
    }

    function Me(t) {
      return typeof t == "number" || Le(t) && "[object Number]" == wu.call(t)
    }

    function ze(t) {
      return !Le(t) || "[object Object]" != wu.call(t) || z(t) ? false : (t = Fu(Object(t)), null === t ? true : (t = xu.call(t, "constructor") && t.constructor, typeof t == "function" && t instanceof t && bu.call(t) == mu))
    }

    function Ue(t) {
      return Be(t) && "[object RegExp]" == wu.call(t)
    }

    function De(t) {
      return typeof t == "string" || !oi(t) && Le(t) && "[object String]" == wu.call(t);
    }

    function $e(t) {
      return typeof t == "symbol" || Le(t) && "[object Symbol]" == wu.call(t)
    }

    function Fe(t) {
      return Le(t) && We(t.length) && !!Mt[wu.call(t)]
    }

    function Ne(t, n) {
      return n > t
    }

    function Pe(t) {
      if (!t) return [];
      if (ke(t)) return De(t) ? t.match(Rt) : or(t);
      if (Lu && t[Lu]) return D(t[Lu]());
      var n = Mr(t);
      return ("[object Map]" == n ? $ : "[object Set]" == n ? N : nu)(t)
    }

    function Ze(t) {
      if (!t) return 0 === t ? t : 0;
      if (t = qe(t), t === V || t === -V) return 1.7976931348623157e308 * (0 > t ? -1 : 1);
      var n = t % 1;
      return t === t ? n ? t - n : t : 0
    }

    function Te(t) {
      return t ? en(Ze(t), 0, 4294967295) : 0;
    }

    function qe(t) {
      if (typeof t == "number") return t;
      if ($e(t)) return K;
      if (Be(t) && (t = Se(t.valueOf) ? t.valueOf() : t, t = Be(t) ? t + "" : t), typeof t != "string") return 0 === t ? t : +t;
      t = t.replace(at, "");
      var n = yt.test(t);
      return n || xt.test(t) ? Zt(t.slice(2), n ? 2 : 8) : dt.test(t) ? K : +t
    }

    function Ve(t) {
      return ir(t, Qe(t))
    }

    function Ke(t) {
      if (typeof t == "string") return t;
      if (null == t) return "";
      if ($e(t)) return po ? po.call(t) : "";
      var n = t + "";
      return "0" == n && 1 / t == -V ? "-0" : n
    }

    function Ge(t, n, r) {
      return t = null == t ? q : gn(t, n), t === q ? r : t
    }

    function Je(t, n) {
      return null != t && zr(t, n, yn);
    }

    function Ye(t, n) {
      return null != t && zr(t, n, bn)
    }

    function He(t) {
      var n = Kr(t);
      if (!n && !ke(t)) return Zu(Object(t));
      var r, e = Fr(t),
        u = !!e,
        e = e || [],
        o = e.length;
      for (r in t) !yn(t, r) || u && ("length" == r || U(r, o)) || n && "constructor" == r || e.push(r);
      return e
    }

    function Qe(t) {
      for (var n = -1, r = Kr(t), e = kn(t), u = e.length, o = Fr(t), i = !!o, o = o || [], f = o.length; ++n < u;) {
        var c = e[n];
        i && ("length" == c || U(c, f)) || "constructor" == c && (r || !xu.call(t, c)) || o.push(c)
      }
      return o
    }

    function Xe(t) {
      return A(t, He(t))
    }

    function tu(t) {
      return A(t, Qe(t))
    }

    function nu(t) {
      return t ? k(t, He(t)) : []
    }

    function ru(t) {
      return Ii(Ke(t).toLowerCase())
    }

    function eu(t) {
      return (t = Ke(t)) && t.replace(mt, B).replace(St, "")
    }

    function uu(t, n, r) {
      return t = Ke(t), n = r ? q : n, n === q && (n = Lt.test(t) ? Wt : ht), t.match(n) || []
    }

    function ou(t) {
      return function() {
        return t
      }
    }

    function iu(t) {
      return t
    }

    function fu(t) {
      return On(typeof t == "function" ? t : un(t, true))
    }

    function cu(t, n, r) {
      var e = He(n),
        o = vn(n, e);
      null != r || Be(n) && (o.length || !e.length) || (r = n, n = t, t = this, o = vn(n, He(n)));
      var i = Be(r) && "chain" in r ? r.chain : true,
        f = Se(t);
      return u(o, function(r) {
        var e = n[r];
        t[r] = e, f && (t.prototype[r] = function() {
          var n = this.__chain__;
          if (i || n) {
            var r = t(this.__wrapped__);
            return (r.__actions__ = or(this.__actions__)).push({
              func: e,
              args: arguments,
              thisArg: t
            }), r.__chain__ = n, r
          }
          return e.apply(t, l([this.value()], arguments))
        })
      }), t
    }

    function au() {}

    function lu(t) {
      return Tr(t) ? Mn(t) : zn(t)
    }
    S = S ? Ht.defaults({}, S, Ht.pick(Yt, Ct)) : Yt;
    var su = S.Date,
      hu = S.Error,
      pu = S.Math,
      _u = S.RegExp,
      vu = S.TypeError,
      gu = S.Array.prototype,
      du = S.Object.prototype,
      yu = S.String.prototype,
      bu = S.Function.prototype.toString,
      xu = du.hasOwnProperty,
      ju = 0,
      mu = bu.call(Object),
      wu = du.toString,
      Au = Yt._,
      Ou = _u("^" + bu.call(xu).replace(ft, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      ku = Vt ? S.Buffer : q,
      Eu = S.Reflect,
      Iu = S.Symbol,
      Su = S.Uint8Array,
      Ru = S.clearTimeout,
      Wu = Eu ? Eu.f : q,
      Bu = Object.getOwnPropertySymbols,
      Lu = typeof(Lu = Iu && Iu.iterator) == "symbol" ? Lu : q,
      Cu = Object.create,
      Mu = du.propertyIsEnumerable,
      zu = S.setTimeout,
      Uu = gu.splice,
      Du = pu.ceil,
      $u = pu.floor,
      Fu = Object.getPrototypeOf,
      Nu = S.isFinite,
      Pu = gu.join,
      Zu = Object.keys,
      Tu = pu.max,
      qu = pu.min,
      Vu = S.parseInt,
      Ku = pu.random,
      Gu = yu.replace,
      Ju = gu.reverse,
      Yu = yu.split,
      Hu = Br(S, "DataView"),
      Qu = Br(S, "Map"),
      Xu = Br(S, "Promise"),
      to = Br(S, "Set"),
      no = Br(S, "WeakMap"),
      ro = Br(Object, "create"),
      eo = no && new no,
      uo = !Mu.call({
        valueOf: 1
      }, "valueOf"),
      oo = {},
      io = Qr(Hu),
      fo = Qr(Qu),
      co = Qr(Xu),
      ao = Qr(to),
      lo = Qr(no),
      so = Iu ? Iu.prototype : q,
      ho = so ? so.valueOf : q,
      po = so ? so.toString : q;
    jt.templateSettings = {
      escape: nt,
      evaluate: rt,
      interpolate: et,
      variable: "",
      imports: {
        _: jt
      }
    }, jt.prototype = Ot.prototype, jt.prototype.constructor = jt, kt.prototype = fn(Ot.prototype), kt.prototype.constructor = kt, Et.prototype = fn(Ot.prototype), Et.prototype.constructor = Et, Ut.prototype = ro ? ro(null) : du, Dt.prototype.clear = function() {
      this.__data__ = {
        hash: new Ut,
        map: Qu ? new Qu : [],
        string: new Ut
      }
    }, Dt.prototype["delete"] = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, t = (ro ? n[t] !== q : xu.call(n, t)) && delete n[t]) : t = Qu ? n.map["delete"](t) : Tt(n.map, t), t
    }, Dt.prototype.get = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, ro ? (t = n[t], t = "__lodash_hash_undefined__" === t ? q : t) : t = xu.call(n, t) ? n[t] : q) : t = Qu ? n.map.get(t) : qt(n.map, t), t
    }, Dt.prototype.has = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, t = ro ? n[t] !== q : xu.call(n, t)) : t = Qu ? n.map.has(t) : -1 < Kt(n.map, t),
        t
    }, Dt.prototype.set = function(t, n) {
      var r = this.__data__;
      return qr(t) ? (typeof t == "string" ? r.string : r.hash)[t] = ro && n === q ? "__lodash_hash_undefined__" : n : Qu ? r.map.set(t, n) : Gt(r.map, t, n), this
    }, $t.prototype.push = function(t) {
      var n = this.__data__;
      qr(t) ? (n = n.__data__, (typeof t == "string" ? n.string : n.hash)[t] = "__lodash_hash_undefined__") : n.set(t, "__lodash_hash_undefined__")
    }, Nt.prototype.clear = function() {
      this.__data__ = {
        array: [],
        map: null
      }
    }, Nt.prototype["delete"] = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? Tt(r, t) : n.map["delete"](t);
    }, Nt.prototype.get = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? qt(r, t) : n.map.get(t)
    }, Nt.prototype.has = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? -1 < Kt(r, t) : n.map.has(t)
    }, Nt.prototype.set = function(t, n) {
      var r = this.__data__,
        e = r.array;
      return e && (199 > e.length ? Gt(e, t, n) : (r.array = null, r.map = new Dt(e))), (r = r.map) && r.set(t, n), this
    };
    var _o = lr(pn),
      vo = lr(_n, true),
      go = sr(),
      yo = sr(true);
    Wu && !Mu.call({
      valueOf: 1
    }, "valueOf") && (kn = function(t) {
      return D(Wu(t))
    });
    var bo = eo ? function(t, n) {
        return eo.set(t, n), t
      } : iu,
      xo = to && 2 === new to([1, 2]).size ? function(t) {
        return new to(t)
      } : au,
      jo = eo ? function(t) {
        return eo.get(t)
      } : au,
      mo = Mn("length");
    Bu || (Cr = function() {
      return []
    });
    var wo = Bu ? function(t) {
      for (var n = []; t;) l(n, Cr(t)), t = Fu(Object(t));
      return n
    } : Cr;
    (Hu && "[object DataView]" != Mr(new Hu(new ArrayBuffer(1))) || Qu && "[object Map]" != Mr(new Qu) || Xu && "[object Promise]" != Mr(Xu.resolve()) || to && "[object Set]" != Mr(new to) || no && "[object WeakMap]" != Mr(new no)) && (Mr = function(t) {
      var n = wu.call(t);
      if (t = (t = "[object Object]" == n ? t.constructor : q) ? Qr(t) : q) switch (t) {
        case io:
          return "[object DataView]";
        case fo:
          return "[object Map]";
        case co:
          return "[object Promise]";
        case ao:
          return "[object Set]";
        case lo:
          return "[object WeakMap]"
      }
      return n
    });
    var Ao = function() {
        var t = 0,
          n = 0;
        return function(r, e) {
          var u = Yo(),
            o = 16 - (u - n);
          if (n = u, o > 0) {
            if (150 <= ++t) return r
          } else t = 0;
          return bo(r, e)
        }
      }(),
      Oo = xe(function(t) {
        var n = [];
        return Ke(t).replace(it, function(t, r, e, u) {
          n.push(e ? u.replace(pt, "$1") : r || t)
        }), n
      }),
      ko = je(function(t, n) {
        return Ee(t) ? an(t, hn(n, 1, Ee, true)) : []
      }),
      Eo = je(function(t, n) {
        var r = ee(n);
        return Ee(r) && (r = q), Ee(t) ? an(t, hn(n, 1, Ee, true), Rr(r)) : [];
      }),
      Io = je(function(t, n) {
        var r = ee(n);
        return Ee(r) && (r = q), Ee(t) ? an(t, hn(n, 1, Ee, true), q, r) : []
      }),
      So = je(function(t) {
        var n = a(t, Qn);
        return n.length && n[0] === t[0] ? xn(n) : []
      }),
      Ro = je(function(t) {
        var n = ee(t),
          r = a(t, Qn);
        return n === ee(r) ? n = q : r.pop(), r.length && r[0] === t[0] ? xn(r, Rr(n)) : []
      }),
      Wo = je(function(t) {
        var n = ee(t),
          r = a(t, Qn);
        return n === ee(r) ? n = q : r.pop(), r.length && r[0] === t[0] ? xn(r, q, n) : []
      }),
      Bo = je(ue),
      Lo = je(function(t, n) {
        n = a(hn(n, 1), String);
        var r = rn(t, n);
        return Dn(t, n.sort(R)), r
      }),
      Co = je(function(t) {
        return Kn(hn(t, 1, Ee, true));
      }),
      Mo = je(function(t) {
        var n = ee(t);
        return Ee(n) && (n = q), Kn(hn(t, 1, Ee, true), Rr(n))
      }),
      zo = je(function(t) {
        var n = ee(t);
        return Ee(n) && (n = q), Kn(hn(t, 1, Ee, true), q, n)
      }),
      Uo = je(function(t, n) {
        return Ee(t) ? an(t, n) : []
      }),
      Do = je(function(t) {
        return Yn(i(t, Ee))
      }),
      $o = je(function(t) {
        var n = ee(t);
        return Ee(n) && (n = q), Yn(i(t, Ee), Rr(n))
      }),
      Fo = je(function(t) {
        var n = ee(t);
        return Ee(n) && (n = q), Yn(i(t, Ee), q, n)
      }),
      No = je(ie),
      Po = je(function(t) {
        var n = t.length,
          n = n > 1 ? t[n - 1] : q,
          n = typeof n == "function" ? (t.pop(), n) : q;
        return fe(t, n)
      }),
      Zo = je(function(t) {
        function n(n) {
          return rn(n, t)
        }
        t = hn(t, 1);
        var r = t.length,
          e = r ? t[0] : 0,
          u = this.__wrapped__;
        return 1 >= r && !this.__actions__.length && u instanceof Et && U(e) ? (u = u.slice(e, +e + (r ? 1 : 0)), u.__actions__.push({
          func: ae,
          args: [n],
          thisArg: q
        }), new kt(u, this.__chain__).thru(function(t) {
          return r && !t.length && t.push(q), t
        })) : this.thru(n)
      }),
      To = cr(function(t, n, r) {
        xu.call(t, r) ? ++t[r] : t[r] = 1
      }),
      qo = cr(function(t, n, r) {
        xu.call(t, r) ? t[r].push(n) : t[r] = [n]
      }),
      Vo = je(function(t, n, e) {
        var u = -1,
          o = typeof n == "function",
          i = Tr(n),
          f = ke(t) ? Array(t.length) : [];
        return _o(t, function(t) {
          var c = o ? n : i && null != t ? t[n] : q;
          f[++u] = c ? r(c, t, e) : mn(t, n, e)
        }), f
      }),
      Ko = cr(function(t, n, r) {
        t[r] = n
      }),
      Go = cr(function(t, n, r) {
        t[r ? 0 : 1].push(n)
      }, function() {
        return [
          [],
          []
        ]
      }),
      Jo = je(function(t, n) {
        if (null == t) return [];
        var r = n.length;
        return r > 1 && Zr(t, n[0], n[1]) ? n = [] : r > 2 && Zr(n[0], n[1], n[2]) && (n = [n[0]]), n = 1 == n.length && oi(n[0]) ? n[0] : hn(n, 1, Pr), Bn(t, n, [])
      }),
      Yo = su.now,
      Ho = je(function(t, n, r) {
        var e = 1;
        if (r.length) var u = F(r, Lr(Ho)),
          e = 32 | e;
        return kr(t, e, n, r, u)
      }),
      Qo = je(function(t, n, r) {
        var e = 3;
        if (r.length) var u = F(r, Lr(Qo)),
          e = 32 | e;
        return kr(n, e, t, r, u)
      }),
      Xo = je(function(t, n) {
        return cn(t, 1, n)
      }),
      ti = je(function(t, n, r) {
        return cn(t, qe(n) || 0, r)
      });
    xe.Cache = Dt;
    var ni = je(function(t, n) {
        n = 1 == n.length && oi(n[0]) ? a(n[0], O(Rr())) : a(hn(n, 1, Pr), O(Rr()));
        var e = n.length;
        return je(function(u) {
          for (var o = -1, i = qu(u.length, e); ++o < i;) u[o] = n[o].call(this, u[o]);
          return r(t, this, u)
        })
      }),
      ri = je(function(t, n) {
        var r = F(n, Lr(ri));
        return kr(t, 32, q, n, r)
      }),
      ei = je(function(t, n) {
        var r = F(n, Lr(ei));
        return kr(t, 64, q, n, r)
      }),
      ui = je(function(t, n) {
        return kr(t, 256, q, q, q, hn(n, 1));
      }),
      oi = Array.isArray,
      ii = ku ? function(t) {
        return t instanceof ku
      } : ou(false),
      fi = ar(function(t, n) {
        if (uo || Kr(n) || ke(n)) ir(n, He(n), t);
        else
          for (var r in n) xu.call(n, r) && Xt(t, r, n[r])
      }),
      ci = ar(function(t, n) {
        if (uo || Kr(n) || ke(n)) ir(n, Qe(n), t);
        else
          for (var r in n) Xt(t, r, n[r])
      }),
      ai = ar(function(t, n, r, e) {
        ir(n, Qe(n), t, e)
      }),
      li = ar(function(t, n, r, e) {
        ir(n, He(n), t, e)
      }),
      si = je(function(t, n) {
        return rn(t, hn(n, 1))
      }),
      hi = je(function(t) {
        return t.push(q, Jt), r(ai, q, t)
      }),
      pi = je(function(t) {
        return t.push(q, Jr), r(yi, q, t)
      }),
      _i = br(function(t, n, r) {
        t[n] = r
      }, ou(iu)),
      vi = br(function(t, n, r) {
        xu.call(t, n) ? t[n].push(r) : t[n] = [r]
      }, Rr),
      gi = je(mn),
      di = ar(function(t, n, r) {
        Rn(t, n, r)
      }),
      yi = ar(function(t, n, r, e) {
        Rn(t, n, r, e)
      }),
      bi = je(function(t, n) {
        return null == t ? {} : (n = a(hn(n, 1), Hr), Ln(t, an(dn(t, Qe, wo), n)))
      }),
      xi = je(function(t, n) {
        return null == t ? {} : Ln(t, hn(n, 1))
      }),
      ji = _r(function(t, n, r) {
        return n = n.toLowerCase(), t + (r ? ru(n) : n)
      }),
      mi = _r(function(t, n, r) {
        return t + (r ? "-" : "") + n.toLowerCase()
      }),
      wi = _r(function(t, n, r) {
        return t + (r ? " " : "") + n.toLowerCase()
      }),
      Ai = pr("toLowerCase"),
      Oi = _r(function(t, n, r) {
        return t + (r ? "_" : "") + n.toLowerCase()
      }),
      ki = _r(function(t, n, r) {
        return t + (r ? " " : "") + Ii(n)
      }),
      Ei = _r(function(t, n, r) {
        return t + (r ? " " : "") + n.toUpperCase()
      }),
      Ii = pr("toUpperCase"),
      Si = je(function(t, n) {
        try {
          return r(t, q, n)
        } catch (e) {
          return Ie(e) ? e : new hu(e)
        }
      }),
      Ri = je(function(t, n) {
        return u(hn(n, 1), function(n) {
          t[n] = Ho(t[n], t)
        }), t
      }),
      Wi = dr(),
      Bi = dr(true),
      Li = je(function(t, n) {
        return function(r) {
          return mn(r, t, n)
        }
      }),
      Ci = je(function(t, n) {
        return function(r) {
          return mn(t, r, n)
        }
      }),
      Mi = xr(a),
      zi = xr(o),
      Ui = xr(p),
      Di = wr(),
      $i = wr(true),
      Fi = W(function(t, n) {
        return t + n
      }),
      Ni = Or("ceil"),
      Pi = W(function(t, n) {
        return t / n
      }),
      Zi = Or("floor"),
      Ti = W(function(t, n) {
        return t * n
      }),
      qi = Or("round"),
      Vi = W(function(t, n) {
        return t - n
      });
    return jt.after = function(t, n) {
        if (typeof n != "function") throw new vu("Expected a function");
        return t = Ze(t),
          function() {
            return 1 > --t ? n.apply(this, arguments) : void 0
          }
      }, jt.ary = ve, jt.assign = fi, jt.assignIn = ci, jt.assignInWith = ai, jt.assignWith = li, jt.at = si, jt.before = ge, jt.bind = Ho, jt.bindAll = Ri, jt.bindKey = Qo, jt.castArray = me, jt.chain = ce, jt.chunk = function(t, n, r) {
        if (n = (r ? Zr(t, n, r) : n === q) ? 1 : Tu(Ze(n), 0), r = t ? t.length : 0, !r || 1 > n) return [];
        for (var e = 0, u = 0, o = Array(Du(r / n)); r > e;) o[u++] = Pn(t, e, e += n);
        return o
      }, jt.compact = function(t) {
        for (var n = -1, r = t ? t.length : 0, e = 0, u = []; ++n < r;) {
          var o = t[n];
          o && (u[e++] = o)
        }
        return u
      }, jt.concat = function() {
        var t = arguments.length,
          n = me(arguments[0]);
        if (2 > t) return t ? or(n) : [];
        for (var r = Array(t - 1); t--;) r[t - 1] = arguments[t];
        for (var t = hn(r, 1), r = -1, e = n.length, u = -1, o = t.length, i = Array(e + o); ++r < e;) i[r] = n[r];
        for (; ++u < o;) i[r++] = t[u];
        return i
      }, jt.cond = function(t) {
        var n = t ? t.length : 0,
          e = Rr();
        return t = n ? a(t, function(t) {
          if ("function" != typeof t[1]) throw new vu("Expected a function");
          return [e(t[0]), t[1]]
        }) : [], je(function(e) {
          for (var u = -1; ++u < n;) {
            var o = t[u];
            if (r(o[0], this, e)) return r(o[1], this, e)
          }
        })
      }, jt.conforms = function(t) {
        return on(un(t, true))
      }, jt.constant = ou, jt.countBy = To, jt.create = function(t, n) {
        var r = fn(t);
        return n ? nn(r, n) : r
      }, jt.curry = de, jt.curryRight = ye, jt.debounce = be, jt.defaults = hi, jt.defaultsDeep = pi, jt.defer = Xo, jt.delay = ti, jt.difference = ko, jt.differenceBy = Eo,
      jt.differenceWith = Io, jt.drop = te, jt.dropRight = ne, jt.dropRightWhile = function(t, n) {
        return t && t.length ? Gn(t, Rr(n, 3), true, true) : []
      }, jt.dropWhile = function(t, n) {
        return t && t.length ? Gn(t, Rr(n, 3), true) : []
      }, jt.fill = function(t, n, r, e) {
        var u = t ? t.length : 0;
        if (!u) return [];
        for (r && typeof r != "number" && Zr(t, n, r) && (r = 0, e = u), u = t.length, r = Ze(r), 0 > r && (r = -r > u ? 0 : u + r), e = e === q || e > u ? u : Ze(e), 0 > e && (e += u), e = r > e ? 0 : Te(e); e > r;) t[r++] = n;
        return t
      }, jt.filter = function(t, n) {
        return (oi(t) ? i : sn)(t, Rr(n, 3))
      }, jt.flatMap = function(t, n) {
        return hn(pe(t, n), 1);
      }, jt.flatMapDeep = function(t, n) {
        return hn(pe(t, n), V)
      }, jt.flatMapDepth = function(t, n, r) {
        return r = r === q ? 1 : Ze(r), hn(pe(t, n), r)
      }, jt.flatten = function(t) {
        return t && t.length ? hn(t, 1) : []
      }, jt.flattenDeep = function(t) {
        return t && t.length ? hn(t, V) : []
      }, jt.flattenDepth = function(t, n) {
        return t && t.length ? (n = n === q ? 1 : Ze(n), hn(t, n)) : []
      }, jt.flip = function(t) {
        return kr(t, 512)
      }, jt.flow = Wi, jt.flowRight = Bi, jt.fromPairs = function(t) {
        for (var n = -1, r = t ? t.length : 0, e = {}; ++n < r;) {
          var u = t[n];
          e[u[0]] = u[1]
        }
        return e
      }, jt.functions = function(t) {
        return null == t ? [] : vn(t, He(t))
      }, jt.functionsIn = function(t) {
        return null == t ? [] : vn(t, Qe(t))
      }, jt.groupBy = qo, jt.initial = function(t) {
        return ne(t, 1)
      }, jt.intersection = So, jt.intersectionBy = Ro, jt.intersectionWith = Wo, jt.invert = _i, jt.invertBy = vi, jt.invokeMap = Vo, jt.iteratee = fu, jt.keyBy = Ko, jt.keys = He, jt.keysIn = Qe, jt.map = pe, jt.mapKeys = function(t, n) {
        var r = {};
        return n = Rr(n, 3), pn(t, function(t, e, u) {
          r[n(t, e, u)] = t
        }), r
      }, jt.mapValues = function(t, n) {
        var r = {};
        return n = Rr(n, 3), pn(t, function(t, e, u) {
          r[e] = n(t, e, u)
        }), r
      }, jt.matches = function(t) {
        return In(un(t, true))
      }, jt.matchesProperty = function(t, n) {
        return Sn(t, un(n, true))
      }, jt.memoize = xe, jt.merge = di, jt.mergeWith = yi, jt.method = Li, jt.methodOf = Ci, jt.mixin = cu, jt.negate = function(t) {
        if (typeof t != "function") throw new vu("Expected a function");
        return function() {
          return !t.apply(this, arguments)
        }
      }, jt.nthArg = function(t) {
        return t = Ze(t), je(function(n) {
          return Wn(n, t)
        })
      }, jt.omit = bi, jt.omitBy = function(t, n) {
        return n = Rr(n), Cn(t, function(t, r) {
          return !n(t, r)
        })
      }, jt.once = function(t) {
        return ge(2, t)
      }, jt.orderBy = function(t, n, r, e) {
        return null == t ? [] : (oi(n) || (n = null == n ? [] : [n]), r = e ? q : r, oi(r) || (r = null == r ? [] : [r]), Bn(t, n, r))
      }, jt.over = Mi, jt.overArgs = ni, jt.overEvery = zi, jt.overSome = Ui, jt.partial = ri, jt.partialRight = ei, jt.partition = Go, jt.pick = xi, jt.pickBy = function(t, n) {
        return null == t ? {} : Cn(t, Rr(n))
      }, jt.property = lu, jt.propertyOf = function(t) {
        return function(n) {
          return null == t ? q : gn(t, n)
        }
      }, jt.pull = Bo, jt.pullAll = ue, jt.pullAllBy = function(t, n, r) {
        return t && t.length && n && n.length ? Un(t, n, Rr(r)) : t
      }, jt.pullAllWith = function(t, n, r) {
        return t && t.length && n && n.length ? Un(t, n, q, r) : t;
      }, jt.pullAt = Lo, jt.range = Di, jt.rangeRight = $i, jt.rearg = ui, jt.reject = function(t, n) {
        var r = oi(t) ? i : sn;
        return n = Rr(n, 3), r(t, function(t, r, e) {
          return !n(t, r, e)
        })
      }, jt.remove = function(t, n) {
        var r = [];
        if (!t || !t.length) return r;
        var e = -1,
          u = [],
          o = t.length;
        for (n = Rr(n, 3); ++e < o;) {
          var i = t[e];
          n(i, e, t) && (r.push(i), u.push(e))
        }
        return Dn(t, u), r
      }, jt.rest = je, jt.reverse = oe, jt.sampleSize = _e, jt.set = function(t, n, r) {
        return null == t ? t : Nn(t, n, r)
      }, jt.setWith = function(t, n, r, e) {
        return e = typeof e == "function" ? e : q, null == t ? t : Nn(t, n, r, e)
      }, jt.shuffle = function(t) {
        return _e(t, 4294967295)
      }, jt.slice = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (r && typeof r != "number" && Zr(t, n, r) ? (n = 0, r = e) : (n = null == n ? 0 : Ze(n), r = r === q ? e : Ze(r)), Pn(t, n, r)) : []
      }, jt.sortBy = Jo, jt.sortedUniq = function(t) {
        return t && t.length ? Vn(t) : []
      }, jt.sortedUniqBy = function(t, n) {
        return t && t.length ? Vn(t, Rr(n)) : []
      }, jt.split = function(t, n, r) {
        return r && typeof r != "number" && Zr(t, n, r) && (n = r = q), r = r === q ? 4294967295 : r >>> 0, r ? (t = Ke(t)) && (typeof n == "string" || null != n && !Ue(n)) && (n += "", "" == n && Bt.test(t)) ? tr(t.match(Rt), 0, r) : Yu.call(t, n, r) : [];
      }, jt.spread = function(t, n) {
        if (typeof t != "function") throw new vu("Expected a function");
        return n = n === q ? 0 : Tu(Ze(n), 0), je(function(e) {
          var u = e[n];
          return e = tr(e, 0, n), u && l(e, u), r(t, this, e)
        })
      }, jt.tail = function(t) {
        return te(t, 1)
      }, jt.take = function(t, n, r) {
        return t && t.length ? (n = r || n === q ? 1 : Ze(n), Pn(t, 0, 0 > n ? 0 : n)) : []
      }, jt.takeRight = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (n = r || n === q ? 1 : Ze(n), n = e - n, Pn(t, 0 > n ? 0 : n, e)) : []
      }, jt.takeRightWhile = function(t, n) {
        return t && t.length ? Gn(t, Rr(n, 3), false, true) : []
      }, jt.takeWhile = function(t, n) {
        return t && t.length ? Gn(t, Rr(n, 3)) : []
      }, jt.tap = function(t, n) {
        return n(t), t
      }, jt.throttle = function(t, n, r) {
        var e = true,
          u = true;
        if (typeof t != "function") throw new vu("Expected a function");
        return Be(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), be(t, n, {
          leading: e,
          maxWait: n,
          trailing: u
        })
      }, jt.thru = ae, jt.toArray = Pe, jt.toPairs = Xe, jt.toPairsIn = tu, jt.toPath = function(t) {
        return oi(t) ? a(t, Hr) : $e(t) ? [t] : or(Oo(t))
      }, jt.toPlainObject = Ve, jt.transform = function(t, n, r) {
        var e = oi(t) || Fe(t);
        if (n = Rr(n, 4), null == r)
          if (e || Be(t)) {
            var o = t.constructor;
            r = e ? oi(t) ? new o : [] : Se(o) ? fn(Fu(Object(t))) : {}
          } else r = {};
        return (e ? u : pn)(t, function(t, e, u) {
          return n(r, t, e, u)
        }), r
      }, jt.unary = function(t) {
        return ve(t, 1)
      }, jt.union = Co, jt.unionBy = Mo, jt.unionWith = zo, jt.uniq = function(t) {
        return t && t.length ? Kn(t) : []
      }, jt.uniqBy = function(t, n) {
        return t && t.length ? Kn(t, Rr(n)) : []
      }, jt.uniqWith = function(t, n) {
        return t && t.length ? Kn(t, q, n) : []
      }, jt.unset = function(t, n) {
        var r;
        if (null == t) r = true;
        else {
          r = t;
          var e = n,
            e = Tr(e, r) ? [e] : Xn(e);
          r = Yr(r, e), e = ee(e), r = null != r && Je(r, e) ? delete r[e] : true;
        }
        return r
      }, jt.unzip = ie, jt.unzipWith = fe, jt.update = function(t, n, r) {
        return null == t ? t : Nn(t, n, (typeof r == "function" ? r : iu)(gn(t, n)), void 0)
      }, jt.updateWith = function(t, n, r, e) {
        return e = typeof e == "function" ? e : q, null != t && (t = Nn(t, n, (typeof r == "function" ? r : iu)(gn(t, n)), e)), t
      }, jt.values = nu, jt.valuesIn = function(t) {
        return null == t ? [] : k(t, Qe(t))
      }, jt.without = Uo, jt.words = uu, jt.wrap = function(t, n) {
        return n = null == n ? iu : n, ri(n, t)
      }, jt.xor = Do, jt.xorBy = $o, jt.xorWith = Fo, jt.zip = No, jt.zipObject = function(t, n) {
        return Hn(t || [], n || [], Xt);
      }, jt.zipObjectDeep = function(t, n) {
        return Hn(t || [], n || [], Nn)
      }, jt.zipWith = Po, jt.entries = Xe, jt.entriesIn = tu, jt.extend = ci, jt.extendWith = ai, cu(jt, jt), jt.add = Fi, jt.attempt = Si, jt.camelCase = ji, jt.capitalize = ru, jt.ceil = Ni, jt.clamp = function(t, n, r) {
        return r === q && (r = n, n = q), r !== q && (r = qe(r), r = r === r ? r : 0), n !== q && (n = qe(n), n = n === n ? n : 0), en(qe(t), n, r)
      }, jt.clone = function(t) {
        return un(t, false, true)
      }, jt.cloneDeep = function(t) {
        return un(t, true, true)
      }, jt.cloneDeepWith = function(t, n) {
        return un(t, true, true, n)
      }, jt.cloneWith = function(t, n) {
        return un(t, false, true, n);
      }, jt.deburr = eu, jt.divide = Pi, jt.endsWith = function(t, n, r) {
        t = Ke(t), n = typeof n == "string" ? n : n + "";
        var e = t.length;
        return r = r === q ? e : en(Ze(r), 0, e), r -= n.length, r >= 0 && t.indexOf(n, r) == r
      }, jt.eq = we, jt.escape = function(t) {
        return (t = Ke(t)) && tt.test(t) ? t.replace(Q, L) : t
      }, jt.escapeRegExp = function(t) {
        return (t = Ke(t)) && ct.test(t) ? t.replace(ft, "\\$&") : t
      }, jt.every = function(t, n, r) {
        var e = oi(t) ? o : ln;
        return r && Zr(t, n, r) && (n = q), e(t, Rr(n, 3))
      }, jt.find = function(t, n) {
        if (n = Rr(n, 3), oi(t)) {
          var r = g(t, n);
          return r > -1 ? t[r] : q
        }
        return v(t, n, _o);
      }, jt.findIndex = function(t, n) {
        return t && t.length ? g(t, Rr(n, 3)) : -1
      }, jt.findKey = function(t, n) {
        return v(t, Rr(n, 3), pn, true)
      }, jt.findLast = function(t, n) {
        if (n = Rr(n, 3), oi(t)) {
          var r = g(t, n, true);
          return r > -1 ? t[r] : q
        }
        return v(t, n, vo)
      }, jt.findLastIndex = function(t, n) {
        return t && t.length ? g(t, Rr(n, 3), true) : -1
      }, jt.findLastKey = function(t, n) {
        return v(t, Rr(n, 3), _n, true)
      }, jt.floor = Zi, jt.forEach = se, jt.forEachRight = he, jt.forIn = function(t, n) {
        return null == t ? t : go(t, Rr(n), Qe)
      }, jt.forInRight = function(t, n) {
        return null == t ? t : yo(t, Rr(n), Qe);
      }, jt.forOwn = function(t, n) {
        return t && pn(t, Rr(n))
      }, jt.forOwnRight = function(t, n) {
        return t && _n(t, Rr(n))
      }, jt.get = Ge, jt.gt = Ae, jt.gte = function(t, n) {
        return t >= n
      }, jt.has = Je, jt.hasIn = Ye, jt.head = re, jt.identity = iu, jt.includes = function(t, n, r, e) {
        return t = ke(t) ? t : nu(t), r = r && !e ? Ze(r) : 0, e = t.length, 0 > r && (r = Tu(e + r, 0)), De(t) ? e >= r && -1 < t.indexOf(n, r) : !!e && -1 < d(t, n, r)
      }, jt.indexOf = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (r = Ze(r), 0 > r && (r = Tu(e + r, 0)), d(t, n, r)) : -1
      }, jt.inRange = function(t, n, r) {
        return n = qe(n) || 0, r === q ? (r = n,
          n = 0) : r = qe(r) || 0, t = qe(t), t >= qu(n, r) && t < Tu(n, r)
      }, jt.invoke = gi, jt.isArguments = Oe, jt.isArray = oi, jt.isArrayBuffer = function(t) {
        return Le(t) && "[object ArrayBuffer]" == wu.call(t)
      }, jt.isArrayLike = ke, jt.isArrayLikeObject = Ee, jt.isBoolean = function(t) {
        return true === t || false === t || Le(t) && "[object Boolean]" == wu.call(t)
      }, jt.isBuffer = ii, jt.isDate = function(t) {
        return Le(t) && "[object Date]" == wu.call(t)
      }, jt.isElement = function(t) {
        return !!t && 1 === t.nodeType && Le(t) && !ze(t)
      }, jt.isEmpty = function(t) {
        if (ke(t) && (oi(t) || De(t) || Se(t.splice) || Oe(t) || ii(t))) return !t.length;
        if (Le(t)) {
          var n = Mr(t);
          if ("[object Map]" == n || "[object Set]" == n) return !t.size
        }
        for (var r in t)
          if (xu.call(t, r)) return false;
        return !(uo && He(t).length)
      }, jt.isEqual = function(t, n) {
        return wn(t, n)
      }, jt.isEqualWith = function(t, n, r) {
        var e = (r = typeof r == "function" ? r : q) ? r(t, n) : q;
        return e === q ? wn(t, n, r) : !!e
      }, jt.isError = Ie, jt.isFinite = function(t) {
        return typeof t == "number" && Nu(t)
      }, jt.isFunction = Se, jt.isInteger = Re, jt.isLength = We, jt.isMap = function(t) {
        return Le(t) && "[object Map]" == Mr(t)
      }, jt.isMatch = function(t, n) {
        return t === n || An(t, n, Wr(n));
      }, jt.isMatchWith = function(t, n, r) {
        return r = typeof r == "function" ? r : q, An(t, n, Wr(n), r)
      }, jt.isNaN = function(t) {
        return Me(t) && t != +t
      }, jt.isNative = Ce, jt.isNil = function(t) {
        return null == t
      }, jt.isNull = function(t) {
        return null === t
      }, jt.isNumber = Me, jt.isObject = Be, jt.isObjectLike = Le, jt.isPlainObject = ze, jt.isRegExp = Ue, jt.isSafeInteger = function(t) {
        return Re(t) && t >= -9007199254740991 && 9007199254740991 >= t
      }, jt.isSet = function(t) {
        return Le(t) && "[object Set]" == Mr(t)
      }, jt.isString = De, jt.isSymbol = $e, jt.isTypedArray = Fe, jt.isUndefined = function(t) {
        return t === q
      }, jt.isWeakMap = function(t) {
        return Le(t) && "[object WeakMap]" == Mr(t)
      }, jt.isWeakSet = function(t) {
        return Le(t) && "[object WeakSet]" == wu.call(t)
      }, jt.join = function(t, n) {
        return t ? Pu.call(t, n) : ""
      }, jt.kebabCase = mi, jt.last = ee, jt.lastIndexOf = function(t, n, r) {
        var e = t ? t.length : 0;
        if (!e) return -1;
        var u = e;
        if (r !== q && (u = Ze(r), u = (0 > u ? Tu(e + u, 0) : qu(u, e - 1)) + 1), n !== n) return M(t, u, true);
        for (; u--;)
          if (t[u] === n) return u;
        return -1
      }, jt.lowerCase = wi, jt.lowerFirst = Ai, jt.lt = Ne, jt.lte = function(t, n) {
        return n >= t
      }, jt.max = function(t) {
        return t && t.length ? _(t, iu, Ae) : q
      }, jt.maxBy = function(t, n) {
        return t && t.length ? _(t, Rr(n), Ae) : q
      }, jt.mean = function(t) {
        return b(t, iu)
      }, jt.meanBy = function(t, n) {
        return b(t, Rr(n))
      }, jt.min = function(t) {
        return t && t.length ? _(t, iu, Ne) : q
      }, jt.minBy = function(t, n) {
        return t && t.length ? _(t, Rr(n), Ne) : q
      }, jt.multiply = Ti, jt.nth = function(t, n) {
        return t && t.length ? Wn(t, Ze(n)) : q
      }, jt.noConflict = function() {
        return Yt._ === this && (Yt._ = Au), this
      }, jt.noop = au, jt.now = Yo, jt.pad = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n && n > e ? (n = (n - e) / 2,
          jr($u(n), r) + t + jr(Du(n), r)) : t
      }, jt.padEnd = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n && n > e ? t + jr(n - e, r) : t
      }, jt.padStart = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n && n > e ? jr(n - e, r) + t : t
      }, jt.parseInt = function(t, n, r) {
        return r || null == n ? n = 0 : n && (n = +n), t = Ke(t).replace(at, ""), Vu(t, n || (gt.test(t) ? 16 : 10))
      }, jt.random = function(t, n, r) {
        if (r && typeof r != "boolean" && Zr(t, n, r) && (n = r = q), r === q && (typeof n == "boolean" ? (r = n, n = q) : typeof t == "boolean" && (r = t, t = q)), t === q && n === q ? (t = 0, n = 1) : (t = qe(t) || 0, n === q ? (n = t,
            t = 0) : n = qe(n) || 0), t > n) {
          var e = t;
          t = n, n = e
        }
        return r || t % 1 || n % 1 ? (r = Ku(), qu(t + r * (n - t + Pt("1e-" + ((r + "").length - 1))), n)) : $n(t, n)
      }, jt.reduce = function(t, n, r) {
        var e = oi(t) ? s : x,
          u = 3 > arguments.length;
        return e(t, Rr(n, 4), r, u, _o)
      }, jt.reduceRight = function(t, n, r) {
        var e = oi(t) ? h : x,
          u = 3 > arguments.length;
        return e(t, Rr(n, 4), r, u, vo)
      }, jt.repeat = function(t, n, r) {
        return n = (r ? Zr(t, n, r) : n === q) ? 1 : Ze(n), Fn(Ke(t), n)
      }, jt.replace = function() {
        var t = arguments,
          n = Ke(t[0]);
        return 3 > t.length ? n : Gu.call(n, t[1], t[2])
      }, jt.result = function(t, n, r) {
        n = Tr(n, t) ? [n] : Xn(n);
        var e = -1,
          u = n.length;
        for (u || (t = q, u = 1); ++e < u;) {
          var o = null == t ? q : t[n[e]];
          o === q && (e = u, o = r), t = Se(o) ? o.call(t) : o
        }
        return t
      }, jt.round = qi, jt.runInContext = T, jt.sample = function(t) {
        t = ke(t) ? t : nu(t);
        var n = t.length;
        return n > 0 ? t[$n(0, n - 1)] : q
      }, jt.size = function(t) {
        if (null == t) return 0;
        if (ke(t)) {
          var n = t.length;
          return n && De(t) ? P(t) : n
        }
        return Le(t) && (n = Mr(t), "[object Map]" == n || "[object Set]" == n) ? t.size : He(t).length
      }, jt.snakeCase = Oi, jt.some = function(t, n, r) {
        var e = oi(t) ? p : Zn;
        return r && Zr(t, n, r) && (n = q), e(t, Rr(n, 3))
      }, jt.sortedIndex = function(t, n) {
        return Tn(t, n)
      }, jt.sortedIndexBy = function(t, n, r) {
        return qn(t, n, Rr(r))
      }, jt.sortedIndexOf = function(t, n) {
        var r = t ? t.length : 0;
        if (r) {
          var e = Tn(t, n);
          if (r > e && we(t[e], n)) return e
        }
        return -1
      }, jt.sortedLastIndex = function(t, n) {
        return Tn(t, n, true)
      }, jt.sortedLastIndexBy = function(t, n, r) {
        return qn(t, n, Rr(r), true)
      }, jt.sortedLastIndexOf = function(t, n) {
        if (t && t.length) {
          var r = Tn(t, n, true) - 1;
          if (we(t[r], n)) return r
        }
        return -1
      }, jt.startCase = ki, jt.startsWith = function(t, n, r) {
        return t = Ke(t), r = en(Ze(r), 0, t.length), t.lastIndexOf(n, r) == r;
      }, jt.subtract = Vi, jt.sum = function(t) {
        return t && t.length ? m(t, iu) : 0
      }, jt.sumBy = function(t, n) {
        return t && t.length ? m(t, Rr(n)) : 0
      }, jt.template = function(t, n, r) {
        var e = jt.templateSettings;
        r && Zr(t, n, r) && (n = q), t = Ke(t), n = ai({}, n, e, Jt), r = ai({}, n.imports, e.imports, Jt);
        var u, o, i = He(r),
          f = k(r, i),
          c = 0;
        r = n.interpolate || wt;
        var a = "__p+='";
        r = _u((n.escape || wt).source + "|" + r.source + "|" + (r === et ? _t : wt).source + "|" + (n.evaluate || wt).source + "|$", "g");
        var l = "sourceURL" in n ? "//# sourceURL=" + n.sourceURL + "\n" : "";
        if (t.replace(r, function(n, r, e, i, f, l) {
            return e || (e = i), a += t.slice(c, l).replace(At, C), r && (u = true, a += "'+__e(" + r + ")+'"), f && (o = true, a += "';" + f + ";\n__p+='"), e && (a += "'+((__t=(" + e + "))==null?'':__t)+'"), c = l + n.length, n
          }), a += "';", (n = n.variable) || (a = "with(obj){" + a + "}"), a = (o ? a.replace(G, "") : a).replace(J, "$1").replace(Y, "$1;"), a = "function(" + (n || "obj") + "){" + (n ? "" : "obj||(obj={});") + "var __t,__p=''" + (u ? ",__e=_.escape" : "") + (o ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" : ";") + a + "return __p}", n = Si(function() {
            return Function(i, l + "return " + a).apply(q, f);
          }), n.source = a, Ie(n)) throw n;
        return n
      }, jt.times = function(t, n) {
        if (t = Ze(t), 1 > t || t > 9007199254740991) return [];
        var r = 4294967295,
          e = qu(t, 4294967295);
        for (n = Rr(n), t -= 4294967295, e = w(e, n); ++r < t;) n(r);
        return e
      }, jt.toInteger = Ze, jt.toLength = Te, jt.toLower = function(t) {
        return Ke(t).toLowerCase()
      }, jt.toNumber = qe, jt.toSafeInteger = function(t) {
        return en(Ze(t), -9007199254740991, 9007199254740991)
      }, jt.toString = Ke, jt.toUpper = function(t) {
        return Ke(t).toUpperCase()
      }, jt.trim = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(at, "") : (n += "") ? (t = t.match(Rt),
          n = n.match(Rt), tr(t, E(t, n), I(t, n) + 1).join("")) : t : t
      }, jt.trimEnd = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(st, "") : (n += "") ? (t = t.match(Rt), n = I(t, n.match(Rt)) + 1, tr(t, 0, n).join("")) : t : t
      }, jt.trimStart = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(lt, "") : (n += "") ? (t = t.match(Rt), n = E(t, n.match(Rt)), tr(t, n).join("")) : t : t
      }, jt.truncate = function(t, n) {
        var r = 30,
          e = "...";
        if (Be(n)) var u = "separator" in n ? n.separator : u,
          r = "length" in n ? Ze(n.length) : r,
          e = "omission" in n ? Ke(n.omission) : e;
        t = Ke(t);
        var o = t.length;
        if (Bt.test(t)) var i = t.match(Rt),
          o = i.length;
        if (r >= o) return t;
        if (o = r - P(e), 1 > o) return e;
        if (r = i ? tr(i, 0, o).join("") : t.slice(0, o), u === q) return r + e;
        if (i && (o += r.length - o), Ue(u)) {
          if (t.slice(o).search(u)) {
            var f = r;
            for (u.global || (u = _u(u.source, Ke(vt.exec(u)) + "g")), u.lastIndex = 0; i = u.exec(f);) var c = i.index;
            r = r.slice(0, c === q ? o : c)
          }
        } else t.indexOf(u, o) != o && (u = r.lastIndexOf(u), u > -1 && (r = r.slice(0, u)));
        return r + e
      }, jt.unescape = function(t) {
        return (t = Ke(t)) && X.test(t) ? t.replace(H, Z) : t
      }, jt.uniqueId = function(t) {
        var n = ++ju;
        return Ke(t) + n
      }, jt.upperCase = Ei, jt.upperFirst = Ii,
      jt.each = se, jt.eachRight = he, jt.first = re, cu(jt, function() {
        var t = {};
        return pn(jt, function(n, r) {
          xu.call(jt.prototype, r) || (t[r] = n)
        }), t
      }(), {
        chain: false
      }), jt.VERSION = "4.11.0", u("bind bindKey curry curryRight partial partialRight".split(" "), function(t) {
        jt[t].placeholder = jt
      }), u(["drop", "take"], function(t, n) {
        Et.prototype[t] = function(r) {
          var e = this.__filtered__;
          if (e && !n) return new Et(this);
          r = r === q ? 1 : Tu(Ze(r), 0);
          var u = this.clone();
          return e ? u.__takeCount__ = qu(r, u.__takeCount__) : u.__views__.push({
            size: qu(r, 4294967295),
            type: t + (0 > u.__dir__ ? "Right" : "")
          }), u
        }, Et.prototype[t + "Right"] = function(n) {
          return this.reverse()[t](n).reverse()
        }
      }), u(["filter", "map", "takeWhile"], function(t, n) {
        var r = n + 1,
          e = 1 == r || 3 == r;
        Et.prototype[t] = function(t) {
          var n = this.clone();
          return n.__iteratees__.push({
            iteratee: Rr(t, 3),
            type: r
          }), n.__filtered__ = n.__filtered__ || e, n
        }
      }), u(["head", "last"], function(t, n) {
        var r = "take" + (n ? "Right" : "");
        Et.prototype[t] = function() {
          return this[r](1).value()[0]
        }
      }), u(["initial", "tail"], function(t, n) {
        var r = "drop" + (n ? "" : "Right");
        Et.prototype[t] = function() {
          return this.__filtered__ ? new Et(this) : this[r](1)
        }
      }), Et.prototype.compact = function() {
        return this.filter(iu)
      }, Et.prototype.find = function(t) {
        return this.filter(t).head()
      }, Et.prototype.findLast = function(t) {
        return this.reverse().find(t)
      }, Et.prototype.invokeMap = je(function(t, n) {
        return typeof t == "function" ? new Et(this) : this.map(function(r) {
          return mn(r, t, n)
        })
      }), Et.prototype.reject = function(t) {
        return t = Rr(t, 3), this.filter(function(n) {
          return !t(n)
        })
      }, Et.prototype.slice = function(t, n) {
        t = Ze(t);
        var r = this;
        return r.__filtered__ && (t > 0 || 0 > n) ? new Et(r) : (0 > t ? r = r.takeRight(-t) : t && (r = r.drop(t)), n !== q && (n = Ze(n), r = 0 > n ? r.dropRight(-n) : r.take(n - t)), r)
      }, Et.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse()
      }, Et.prototype.toArray = function() {
        return this.take(4294967295)
      }, pn(Et.prototype, function(t, n) {
        var r = /^(?:filter|find|map|reject)|While$/.test(n),
          e = /^(?:head|last)$/.test(n),
          u = jt[e ? "take" + ("last" == n ? "Right" : "") : n],
          o = e || /^find/.test(n);
        u && (jt.prototype[n] = function() {
          function n(t) {
            return t = u.apply(jt, l([t], f)), e && h ? t[0] : t
          }
          var i = this.__wrapped__,
            f = e ? [1] : arguments,
            c = i instanceof Et,
            a = f[0],
            s = c || oi(i);
          s && r && typeof a == "function" && 1 != a.length && (c = s = false);
          var h = this.__chain__,
            p = !!this.__actions__.length,
            a = o && !h,
            c = c && !p;
          return !o && s ? (i = c ? i : new Et(this), i = t.apply(i, f), i.__actions__.push({
            func: ae,
            args: [n],
            thisArg: q
          }), new kt(i, h)) : a && c ? t.apply(this, f) : (i = this.thru(n), a ? e ? i.value()[0] : i.value() : i)
        })
      }), u("pop push shift sort splice unshift".split(" "), function(t) {
        var n = gu[t],
          r = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
          e = /^(?:pop|shift)$/.test(t);
        jt.prototype[t] = function() {
          var t = arguments;
          if (e && !this.__chain__) {
            var u = this.value();
            return n.apply(oi(u) ? u : [], t)
          }
          return this[r](function(r) {
            return n.apply(oi(r) ? r : [], t)
          })
        }
      }), pn(Et.prototype, function(t, n) {
        var r = jt[n];
        if (r) {
          var e = r.name + "";
          (oo[e] || (oo[e] = [])).push({
            name: n,
            func: r
          })
        }
      }), oo[yr(q, 2).name] = [{
        name: "wrapper",
        func: q
      }], Et.prototype.clone = function() {
        var t = new Et(this.__wrapped__);
        return t.__actions__ = or(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = or(this.__iteratees__),
          t.__takeCount__ = this.__takeCount__, t.__views__ = or(this.__views__), t
      }, Et.prototype.reverse = function() {
        if (this.__filtered__) {
          var t = new Et(this);
          t.__dir__ = -1, t.__filtered__ = true
        } else t = this.clone(), t.__dir__ *= -1;
        return t
      }, Et.prototype.value = function() {
        var t, n = this.__wrapped__.value(),
          r = this.__dir__,
          e = oi(n),
          u = 0 > r,
          o = e ? n.length : 0;
        t = o;
        for (var i = this.__views__, f = 0, c = -1, a = i.length; ++c < a;) {
          var l = i[c],
            s = l.size;
          switch (l.type) {
            case "drop":
              f += s;
              break;
            case "dropRight":
              t -= s;
              break;
            case "take":
              t = qu(t, f + s);
              break;
            case "takeRight":
              f = Tu(f, t - s)
          }
        }
        if (t = {
            start: f,
            end: t
          }, i = t.start, f = t.end, t = f - i, u = u ? f : i - 1, i = this.__iteratees__, f = i.length, c = 0, a = qu(t, this.__takeCount__), !e || 200 > o || o == t && a == t) return Jn(n, this.__actions__);
        e = [];
        t: for (; t-- && a > c;) {
          for (u += r, o = -1, l = n[u]; ++o < f;) {
            var h = i[o],
              s = h.type,
              h = (0, h.iteratee)(l);
            if (2 == s) l = h;
            else if (!h) {
              if (1 == s) continue t;
              break t
            }
          }
          e[c++] = l
        }
        return e
      }, jt.prototype.at = Zo, jt.prototype.chain = function() {
        return ce(this)
      }, jt.prototype.commit = function() {
        return new kt(this.value(), this.__chain__)
      }, jt.prototype.next = function() {
        this.__values__ === q && (this.__values__ = Pe(this.value()));
        var t = this.__index__ >= this.__values__.length,
          n = t ? q : this.__values__[this.__index__++];
        return {
          done: t,
          value: n
        }
      }, jt.prototype.plant = function(t) {
        for (var n, r = this; r instanceof Ot;) {
          var e = Xr(r);
          e.__index__ = 0, e.__values__ = q, n ? u.__wrapped__ = e : n = e;
          var u = e,
            r = r.__wrapped__
        }
        return u.__wrapped__ = t, n
      }, jt.prototype.reverse = function() {
        var t = this.__wrapped__;
        return t instanceof Et ? (this.__actions__.length && (t = new Et(this)), t = t.reverse(), t.__actions__.push({
          func: ae,
          args: [oe],
          thisArg: q
        }), new kt(t, this.__chain__)) : this.thru(oe)
      }, jt.prototype.toJSON = jt.prototype.valueOf = jt.prototype.value = function() {
        return Jn(this.__wrapped__, this.__actions__)
      }, Lu && (jt.prototype[Lu] = le), jt
  }
  var q, V = 1 / 0,
    K = NaN,
    G = /\b__p\+='';/g,
    J = /\b(__p\+=)''\+/g,
    Y = /(__e\(.*?\)|\b__t\))\+'';/g,
    H = /&(?:amp|lt|gt|quot|#39|#96);/g,
    Q = /[&<>"'`]/g,
    X = RegExp(H.source),
    tt = RegExp(Q.source),
    nt = /<%-([\s\S]+?)%>/g,
    rt = /<%([\s\S]+?)%>/g,
    et = /<%=([\s\S]+?)%>/g,
    ut = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    ot = /^\w*$/,
    it = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g,
    ft = /[\\^$.*+?()[\]{}|]/g,
    ct = RegExp(ft.source),
    at = /^\s+|\s+$/g,
    lt = /^\s+/,
    st = /\s+$/,
    ht = /[a-zA-Z0-9]+/g,
    pt = /\\(\\)?/g,
    _t = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
    vt = /\w*$/,
    gt = /^0x/i,
    dt = /^[-+]0x[0-9a-f]+$/i,
    yt = /^0b[01]+$/i,
    bt = /^\[object .+?Constructor\]$/,
    xt = /^0o[0-7]+$/i,
    jt = /^(?:0|[1-9]\d*)$/,
    mt = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,
    wt = /($^)/,
    At = /['\n\r\u2028\u2029\\]/g,
    Ot = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?)*",
    kt = "(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])" + Ot,
    Et = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]?|[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",
    It = RegExp("['\u2019]", "g"),
    St = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", "g"),
    Rt = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Et + Ot, "g"),
    Wt = RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d+", kt].join("|"), "g"),
    Bt = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),
    Lt = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
    Ct = "Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise Reflect RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),
    Mt = {};
  Mt["[object Float32Array]"] = Mt["[object Float64Array]"] = Mt["[object Int8Array]"] = Mt["[object Int16Array]"] = Mt["[object Int32Array]"] = Mt["[object Uint8Array]"] = Mt["[object Uint8ClampedArray]"] = Mt["[object Uint16Array]"] = Mt["[object Uint32Array]"] = true, Mt["[object Arguments]"] = Mt["[object Array]"] = Mt["[object ArrayBuffer]"] = Mt["[object Boolean]"] = Mt["[object DataView]"] = Mt["[object Date]"] = Mt["[object Error]"] = Mt["[object Function]"] = Mt["[object Map]"] = Mt["[object Number]"] = Mt["[object Object]"] = Mt["[object RegExp]"] = Mt["[object Set]"] = Mt["[object String]"] = Mt["[object WeakMap]"] = false;
  var zt = {};
  zt["[object Arguments]"] = zt["[object Array]"] = zt["[object ArrayBuffer]"] = zt["[object DataView]"] = zt["[object Boolean]"] = zt["[object Date]"] = zt["[object Float32Array]"] = zt["[object Float64Array]"] = zt["[object Int8Array]"] = zt["[object Int16Array]"] = zt["[object Int32Array]"] = zt["[object Map]"] = zt["[object Number]"] = zt["[object Object]"] = zt["[object RegExp]"] = zt["[object Set]"] = zt["[object String]"] = zt["[object Symbol]"] = zt["[object Uint8Array]"] = zt["[object Uint8ClampedArray]"] = zt["[object Uint16Array]"] = zt["[object Uint32Array]"] = true,
    zt["[object Error]"] = zt["[object Function]"] = zt["[object WeakMap]"] = false;
  var Ut = {
      "\xc0": "A",
      "\xc1": "A",
      "\xc2": "A",
      "\xc3": "A",
      "\xc4": "A",
      "\xc5": "A",
      "\xe0": "a",
      "\xe1": "a",
      "\xe2": "a",
      "\xe3": "a",
      "\xe4": "a",
      "\xe5": "a",
      "\xc7": "C",
      "\xe7": "c",
      "\xd0": "D",
      "\xf0": "d",
      "\xc8": "E",
      "\xc9": "E",
      "\xca": "E",
      "\xcb": "E",
      "\xe8": "e",
      "\xe9": "e",
      "\xea": "e",
      "\xeb": "e",
      "\xcc": "I",
      "\xcd": "I",
      "\xce": "I",
      "\xcf": "I",
      "\xec": "i",
      "\xed": "i",
      "\xee": "i",
      "\xef": "i",
      "\xd1": "N",
      "\xf1": "n",
      "\xd2": "O",
      "\xd3": "O",
      "\xd4": "O",
      "\xd5": "O",
      "\xd6": "O",
      "\xd8": "O",
      "\xf2": "o",
      "\xf3": "o",
      "\xf4": "o",
      "\xf5": "o",
      "\xf6": "o",
      "\xf8": "o",
      "\xd9": "U",
      "\xda": "U",
      "\xdb": "U",
      "\xdc": "U",
      "\xf9": "u",
      "\xfa": "u",
      "\xfb": "u",
      "\xfc": "u",
      "\xdd": "Y",
      "\xfd": "y",
      "\xff": "y",
      "\xc6": "Ae",
      "\xe6": "ae",
      "\xde": "Th",
      "\xfe": "th",
      "\xdf": "ss"
    },
    Dt = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#96;"
    },
    $t = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'",
      "&#96;": "`"
    },
    Ft = {
      "function": true,
      object: true
    },
    Nt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    },
    Pt = parseFloat,
    Zt = parseInt,
    Tt = Ft[typeof exports] && exports && !exports.nodeType ? exports : q,
    qt = Ft[typeof module] && module && !module.nodeType ? module : q,
    Vt = qt && qt.exports === Tt ? Tt : q,
    Kt = S(Ft[typeof self] && self),
    Gt = S(Ft[typeof window] && window),
    Jt = S(Ft[typeof this] && this),
    Yt = S(Tt && qt && typeof global == "object" && global) || Gt !== (Jt && Jt.window) && Gt || Kt || Jt || Function("return this")(),
    Ht = T();
  (Gt || Kt || {})._ = Ht, typeof define == "function" && typeof define.amd == "object" && define.amd ? define(function() {
    return Ht
  }) : Tt && qt ? (Vt && ((qt.exports = Ht)._ = Ht),
    Tt._ = Ht) : Yt._ = Ht
}).call(this);
/*! RESOURCE: /scripts/libs/ocLazyLoad.min.js */
/**
 * oclazyload - Load modules on demand (lazy load) with angularJS
 * @version v1.0.9
 * @link https://github.com/ocombe/ocLazyLoad
 * @license MIT
 * @author Olivier Combe <olivier.combe@gmail.com>
 */
! function(e, n) {
  "use strict";
  var r = ["ng", "oc.lazyLoad"],
    o = {},
    t = [],
    i = [],
    a = [],
    s = [],
    u = e.noop,
    c = {},
    l = [],
    d = e.module("oc.lazyLoad", ["ng"]);
  d.provider("$ocLazyLoad", ["$controllerProvider", "$provide", "$compileProvider", "$filterProvider", "$injector", "$animateProvider", function(d, f, p, m, v, y) {
    function L(n, o, t) {
      if (o) {
        var i, s, d, f = [];
        for (i = o.length - 1; i >= 0; i--)
          if (s = o[i], e.isString(s) || (s = E(s)), s && -1 === l.indexOf(s) && (!w[s] || -1 !== a.indexOf(s))) {
            var h = -1 === r.indexOf(s);
            if (d = g(s), h && (r.push(s), L(n, d.requires, t)), d._runBlocks.length > 0)
              for (c[s] = []; d._runBlocks.length > 0;) c[s].push(d._runBlocks.shift());
            e.isDefined(c[s]) && (h || t.rerun) && (f = f.concat(c[s])), j(n, d._invokeQueue, s, t.reconfig), j(n, d._configBlocks, s, t.reconfig), u(h ? "ocLazyLoad.moduleLoaded" : "ocLazyLoad.moduleReloaded", s), o.pop(), l.push(s)
          }
        var p = n.getInstanceInjector();
        e.forEach(f, function(e) {
          p.invoke(e)
        })
      }
    }

    function $(n, r) {
      function t(n, r) {
        var o, t = !0;
        return r.length && (o = i(n), e.forEach(r, function(e) {
          t = t && i(e) !== o
        })), t
      }

      function i(n) {
        return e.isArray(n) ? M(n.toString()) : e.isObject(n) ? M(S(n)) : e.isDefined(n) && null !== n ? M(n.toString()) : n
      }
      var a = n[2][0],
        s = n[1],
        c = !1;
      e.isUndefined(o[r]) && (o[r] = {}), e.isUndefined(o[r][s]) && (o[r][s] = {});
      var l = function(e, n) {
        o[r][s].hasOwnProperty(e) || (o[r][s][e] = []), t(n, o[r][s][e]) && (c = !0, o[r][s][e].push(n), u("ocLazyLoad.componentLoaded", [r, s, e]))
      };
      if (e.isString(a)) l(a, n[2][1]);
      else {
        if (!e.isObject(a)) return !1;
        e.forEach(a, function(n, r) {
          e.isString(n) ? l(n, a[1]) : l(r, n)
        })
      }
      return c
    }

    function j(n, r, o, i) {
      if (r) {
        var a, s, u, c;
        for (a = 0, s = r.length; s > a; a++)
          if (u = r[a], e.isArray(u)) {
            if (null !== n) {
              if (!n.hasOwnProperty(u[0])) throw new Error("unsupported provider " + u[0]);
              c = n[u[0]]
            }
            var l = $(u, o);
            if ("invoke" !== u[1]) l && e.isDefined(c) && c[u[1]].apply(c, u[2]);
            else {
              var d = function(n) {
                var r = t.indexOf(o + "-" + n);
                (-1 === r || i) && (-1 === r && t.push(o + "-" + n), e.isDefined(c) && c[u[1]].apply(c, u[2]))
              };
              if (e.isFunction(u[2][0])) d(u[2][0]);
              else if (e.isArray(u[2][0]))
                for (var f = 0, h = u[2][0].length; h > f; f++) e.isFunction(u[2][0][f]) && d(u[2][0][f])
            }
          }
      }
    }

    function E(n) {
      var r = null;
      return e.isString(n) ? r = n : e.isObject(n) && n.hasOwnProperty("name") && e.isString(n.name) && (r = n.name), r
    }

    function _(n) {
      if (!e.isString(n)) return !1;
      try {
        return g(n)
      } catch (r) {
        if (/No module/.test(r) || r.message.indexOf("$injector:nomod") > -1) return !1
      }
    }
    var w = {},
      O = {
        $controllerProvider: d,
        $compileProvider: p,
        $filterProvider: m,
        $provide: f,
        $injector: v,
        $animateProvider: y
      },
      x = !1,
      b = !1,
      z = [],
      D = {};
    z.push = function(e) {
      -1 === this.indexOf(e) && Array.prototype.push.apply(this, arguments)
    }, this.config = function(n) {
      e.isDefined(n.modules) && (e.isArray(n.modules) ? e.forEach(n.modules, function(e) {
        w[e.name] = e
      }) : w[n.modules.name] = n.modules), e.isDefined(n.debug) && (x = n.debug), e.isDefined(n.events) && (b = n.events)
    }, this._init = function(o) {
      if (0 === i.length) {
        var t = [o],
          a = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"],
          u = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/,
          c = function(e) {
            return e && t.push(e)
          };
        e.forEach(a, function(n) {
          a[n] = !0, c(document.getElementById(n)), n = n.replace(":", "\\:"), "undefined" != typeof o[0] && o[0].querySelectorAll && (e.forEach(o[0].querySelectorAll("." + n), c), e.forEach(o[0].querySelectorAll("." + n + "\\:"), c), e.forEach(o[0].querySelectorAll("[" + n + "]"), c))
        }), e.forEach(t, function(n) {
          if (0 === i.length) {
            var r = " " + o.className + " ",
              t = u.exec(r);
            t ? i.push((t[2] || "").replace(/\s+/g, ",")) : e.forEach(n.attributes, function(e) {
              0 === i.length && a[e.name] && i.push(e.value)
            })
          }
        })
      }
      0 !== i.length || (n.jasmine || n.mocha) && e.isDefined(e.mock) || console.error("No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.");
      var l = function d(n) {
        if (-1 === r.indexOf(n)) {
          r.push(n);
          var o = e.module(n);
          j(null, o._invokeQueue, n), j(null, o._configBlocks, n), e.forEach(o.requires, d)
        }
      };
      e.forEach(i, function(e) {
        l(e)
      }), i = [], s.pop()
    };
    var S = function(n) {
        try {
          return JSON.stringify(n)
        } catch (r) {
          var o = [];
          return JSON.stringify(n, function(n, r) {
            if (e.isObject(r) && null !== r) {
              if (-1 !== o.indexOf(r)) return;
              o.push(r)
            }
            return r
          })
        }
      },
      M = function(e) {
        var n, r, o, t = 0;
        if (0 == e.length) return t;
        for (n = 0, o = e.length; o > n; n++) r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0;
        return t
      };
    this.$get = ["$log", "$rootElement", "$rootScope", "$cacheFactory", "$q", function(n, t, a, c, d) {
      function f(e) {
        var r = d.defer();
        return n.error(e.message), r.reject(e), r.promise
      }
      var p, m = c("ocLazyLoad");
      return x || (n = {}, n.error = e.noop, n.warn = e.noop, n.info = e.noop), O.getInstanceInjector = function() {
        return p ? p : p = t.data("$injector") || e.injector()
      }, u = function(e, r) {
        b && a.$broadcast(e, r), x && n.info(e, r)
      }, {
        _broadcast: u,
        _$log: n,
        _getFilesCache: function() {
          return m
        },
        toggleWatch: function(e) {
          e ? s.push(!0) : s.pop()
        },
        getModuleConfig: function(n) {
          if (!e.isString(n)) throw new Error("You need to give the name of the module to get");
          return w[n] ? e.copy(w[n]) : null
        },
        setModuleConfig: function(n) {
          if (!e.isObject(n)) throw new Error("You need to give the module config object to set");
          return w[n.name] = n, n
        },
        getModules: function() {
          return r
        },
        isLoaded: function(n) {
          var o = function(e) {
            var n = r.indexOf(e) > -1;
            return n || (n = !!_(e)), n
          };
          if (e.isString(n) && (n = [n]), e.isArray(n)) {
            var t, i;
            for (t = 0, i = n.length; i > t; t++)
              if (!o(n[t])) return !1;
            return !0
          }
          throw new Error("You need to define the module(s) name(s)")
        },
        _getModuleName: E,
        _getModule: function(e) {
          try {
            return g(e)
          } catch (n) {
            throw (/No module/.test(n) || n.message.indexOf("$injector:nomod") > -1) && (n.message = 'The module "' + S(e) + '" that you are trying to load does not exist. ' + n.message), n
          }
        },
        moduleExists: _,
        _loadDependencies: function(n, r) {
          var o, t, i, a = [],
            s = this;
          if (n = s._getModuleName(n), null === n) return d.when();
          try {
            o = s._getModule(n)
          } catch (u) {
            return f(u)
          }
          return t = s.getRequires(o), e.forEach(t, function(o) {
            if (e.isString(o)) {
              var t = s.getModuleConfig(o);
              if (null === t) return void z.push(o);
              o = t, t.name = void 0
            }
            if (s.moduleExists(o.name)) return i = o.files.filter(function(e) {
              return s.getModuleConfig(o.name).files.indexOf(e) < 0
            }), 0 !== i.length && s._$log.warn('Module "', n, '" attempted to redefine configuration for dependency. "', o.name, '"\n Additional Files Loaded:', i), e.isDefined(s.filesLoader) ? void a.push(s.filesLoader(o, r).then(function() {
              return s._loadDependencies(o)
            })) : f(new Error("Error: New dependencies need to be loaded from external files (" + o.files + "), but no loader has been defined."));
            if (e.isArray(o)) {
              var u = [];
              e.forEach(o, function(e) {
                var n = s.getModuleConfig(e);
                null === n ? u.push(e) : n.files && (u = u.concat(n.files))
              }), u.length > 0 && (o = {
                files: u
              })
            } else e.isObject(o) && o.hasOwnProperty("name") && o.name && (s.setModuleConfig(o), z.push(o.name));
            if (e.isDefined(o.files) && 0 !== o.files.length) {
              if (!e.isDefined(s.filesLoader)) return f(new Error('Error: the module "' + o.name + '" is defined in external files (' + o.files + "), but no loader has been defined."));
              a.push(s.filesLoader(o, r).then(function() {
                return s._loadDependencies(o)
              }))
            }
          }), d.all(a)
        },
        inject: function(n) {
          var r = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
            o = arguments.length <= 2 || void 0 === arguments[2] ? !1 : arguments[2],
            t = this,
            a = d.defer();
          if (e.isDefined(n) && null !== n) {
            if (e.isArray(n)) {
              var s = [];
              return e.forEach(n, function(e) {
                s.push(t.inject(e, r, o))
              }), d.all(s)
            }
            t._addToLoadList(t._getModuleName(n), !0, o)
          }
          if (i.length > 0) {
            var u = i.slice(),
              c = function f(e) {
                z.push(e), D[e] = a.promise, t._loadDependencies(e, r).then(function() {
                  try {
                    l = [], L(O, z, r)
                  } catch (e) {
                    return t._$log.error(e.message), void a.reject(e)
                  }
                  i.length > 0 ? f(i.shift()) : a.resolve(u)
                }, function(e) {
                  a.reject(e)
                })
              };
            c(i.shift())
          } else {
            if (r && r.name && D[r.name]) return D[r.name];
            a.resolve()
          }
          return a.promise
        },
        getRequires: function(n) {
          var o = [];
          return e.forEach(n.requires, function(e) {
            -1 === r.indexOf(e) && o.push(e)
          }), o
        },
        _invokeQueue: j,
        _registerInvokeList: $,
        _register: L,
        _addToLoadList: h,
        _unregister: function(n) {
          e.isDefined(n) && e.isArray(n) && e.forEach(n, function(e) {
            o[e] = void 0
          })
        }
      }
    }], this._init(e.element(n.document))
  }]);
  var f = e.bootstrap;
  e.bootstrap = function(n, r, o) {
    return e.forEach(r.slice(), function(e) {
      h(e, !0, !0)
    }), f(n, r, o)
  };
  var h = function(n, r, o) {
      (s.length > 0 || r) && e.isString(n) && -1 === i.indexOf(n) && (i.push(n), o && a.push(n))
    },
    g = e.module;
  e.module = function(e, n, r) {
    return h(e, !1, !0), g(e, n, r)
  }, "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "oc.lazyLoad")
}(angular, window),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").directive("ocLazyLoad", ["$ocLazyLoad", "$compile", "$animate", "$parse", "$timeout", function(n, r, o, t, i) {
    return {
      restrict: "A",
      terminal: !0,
      priority: 1e3,
      compile: function(i, a) {
        var s = i[0].innerHTML;
        return i.html(""),
          function(i, a, u) {
            var c = t(u.ocLazyLoad);
            i.$watch(function() {
              return c(i) || u.ocLazyLoad
            }, function(t) {
              e.isDefined(t) && n.load(t).then(function() {
                o.enter(s, a), r(a.contents())(i)
              })
            }, !0)
          }
      }
    }
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", "$window", "$interval", function(n, r, o, t) {
      var i = !1,
        a = !1,
        s = o.document.getElementsByTagName("head")[0] || o.document.getElementsByTagName("body")[0];
      return n.buildElement = function(u, c, l) {
        var d, f, h = r.defer(),
          g = n._getFilesCache(),
          p = function(e) {
            var n = (new Date).getTime();
            return e.indexOf("?") >= 0 ? "&" === e.substring(0, e.length - 1) ? e + "_dc=" + n : e + "&_dc=" + n : e + "?_dc=" + n
          };
        switch (e.isUndefined(g.get(c)) && g.put(c, h.promise), u) {
          case "css":
            d = o.document.createElement("link"), d.type = "text/css", d.rel = "stylesheet", d.href = l.cache === !1 ? p(c) : c;
            break;
          case "js":
            d = o.document.createElement("script"), d.src = l.cache === !1 ? p(c) : c;
            break;
          default:
            g.remove(c), h.reject(new Error('Requested type "' + u + '" is not known. Could not inject "' + c + '"'))
        }
        d.onload = d.onreadystatechange = function(e) {
          d.readyState && !/^c|loade/.test(d.readyState) || f || (d.onload = d.onreadystatechange = null, f = 1, n._broadcast("ocLazyLoad.fileLoaded", c), h.resolve())
        }, d.onerror = function() {
          g.remove(c), h.reject(new Error("Unable to load " + c))
        }, d.async = l.serie ? 0 : 1;
        var m = s.lastChild;
        if (l.insertBefore) {
          var v = e.element(e.isDefined(window.jQuery) ? l.insertBefore : document.querySelector(l.insertBefore));
          v && v.length > 0 && (m = v[0])
        }
        if (m.parentNode.insertBefore(d, m), "css" == u) {
          if (!i) {
            var y = o.navigator.userAgent.toLowerCase();
            if (/iP(hone|od|ad)/.test(o.navigator.platform)) {
              var L = o.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                $ = parseFloat([parseInt(L[1], 10), parseInt(L[2], 10), parseInt(L[3] || 0, 10)].join("."));
              a = 6 > $
            } else if (y.indexOf("android") > -1) {
              var j = parseFloat(y.slice(y.indexOf("android") + 8));
              a = 4.4 > j
            } else if (y.indexOf("safari") > -1) {
              var E = y.match(/version\/([\.\d]+)/i);
              a = E && E[1] && parseFloat(E[1]) < 6
            }
          }
          if (a) var _ = 1e3,
            w = t(function() {
              try {
                d.sheet.cssRules, t.cancel(w), d.onload()
              } catch (e) {
                --_ <= 0 && d.onerror()
              }
            }, 20)
        }
        return h.promise
      }, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.filesLoader = function(o) {
        var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
          i = [],
          a = [],
          s = [],
          u = [],
          c = null,
          l = n._getFilesCache();
        n.toggleWatch(!0), e.extend(t, o);
        var d = function(r) {
          var o, d = null;
          if (e.isObject(r) && (d = r.type, r = r.path), c = l.get(r), e.isUndefined(c) || t.cache === !1) {
            if (null !== (o = /^(css|less|html|htm|js)?(?=!)/.exec(r)) && (d = o[1], r = r.substr(o[1].length + 1, r.length)), !d)
              if (null !== (o = /[.](css|less|html|htm|js)?((\?|#).*)?$/.exec(r))) d = o[1];
              else {
                if (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || !n.jsLoader.hasOwnProperty("requirejs")) return void n._$log.error("File type could not be determined. " + r);
                d = "js"
              }
            "css" !== d && "less" !== d || -1 !== i.indexOf(r) ? "html" !== d && "htm" !== d || -1 !== a.indexOf(r) ? "js" === d || -1 === s.indexOf(r) ? s.push(r) : n._$log.error("File type is not valid. " + r) : a.push(r) : i.push(r)
          } else c && u.push(c)
        };
        if (t.serie ? d(t.files.shift()) : e.forEach(t.files, function(e) {
            d(e)
          }), i.length > 0) {
          var f = r.defer();
          n.cssLoader(i, function(r) {
            e.isDefined(r) && n.cssLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), f.reject(r)) : f.resolve()
          }, t), u.push(f.promise)
        }
        if (a.length > 0) {
          var h = r.defer();
          n.templatesLoader(a, function(r) {
            e.isDefined(r) && n.templatesLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), h.reject(r)) : h.resolve()
          }, t), u.push(h.promise)
        }
        if (s.length > 0) {
          var g = r.defer();
          n.jsLoader(s, function(r) {
            e.isDefined(r) && (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || n.jsLoader.hasOwnProperty("requirejs")) ? (n._$log.error(r), g.reject(r)) : g.resolve()
          }, t), u.push(g.promise)
        }
        if (0 === u.length) {
          var p = r.defer(),
            m = "Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.";
          return n._$log.error(m), p.reject(m), p.promise
        }
        return t.serie && t.files.length > 0 ? r.all(u).then(function() {
          return n.filesLoader(o, t)
        }) : r.all(u)["finally"](function(e) {
          return n.toggleWatch(!1), e
        })
      }, n.load = function(o) {
        var t, i = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
          a = this,
          s = null,
          u = [],
          c = r.defer(),
          l = e.copy(o),
          d = e.copy(i);
        if (e.isArray(l)) return e.forEach(l, function(e) {
          u.push(a.load(e, d))
        }), r.all(u).then(function(e) {
          c.resolve(e)
        }, function(e) {
          c.reject(e)
        }), c.promise;
        if (e.isString(l) ? (s = a.getModuleConfig(l), s || (s = {
            files: [l]
          })) : e.isObject(l) && (s = e.isDefined(l.path) && e.isDefined(l.type) ? {
            files: [l]
          } : a.setModuleConfig(l)), null === s) {
          var f = a._getModuleName(l);
          return t = 'Module "' + (f || "unknown") + '" is not configured, cannot load.', n._$log.error(t), c.reject(new Error(t)), c.promise
        }
        e.isDefined(s.template) && (e.isUndefined(s.files) && (s.files = []), e.isString(s.template) ? s.files.push(s.template) : e.isArray(s.template) && s.files.concat(s.template));
        var h = e.extend({}, d, s);
        return e.isUndefined(s.files) && e.isDefined(s.name) && n.moduleExists(s.name) ? n.inject(s.name, h, !0) : (n.filesLoader(s, h).then(function() {
          n.inject(null, h).then(function(e) {
            c.resolve(e)
          }, function(e) {
            c.reject(e)
          })
        }, function(e) {
          c.reject(e)
        }), c.promise)
      }, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.cssLoader = function(o, t, i) {
        var a = [];
        e.forEach(o, function(e) {
          a.push(n.buildElement("css", e, i))
        }), r.all(a).then(function() {
          t()
        }, function(e) {
          t(e)
        })
      }, n.cssLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.jsLoader = function(o, t, i) {
        var a = [];
        e.forEach(o, function(e) {
          a.push(n.buildElement("js", e, i))
        }), r.all(a).then(function() {
          t()
        }, function(e) {
          t(e)
        })
      }, n.jsLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$templateCache", "$q", "$http", function(n, r, o, t) {
      return n.templatesLoader = function(i, a, s) {
        var u = [],
          c = n._getFilesCache();
        return e.forEach(i, function(n) {
          var i = o.defer();
          u.push(i.promise), t.get(n, s).success(function(o) {
            e.isString(o) && o.length > 0 && e.forEach(e.element(o), function(e) {
              "SCRIPT" === e.nodeName && "text/ng-template" === e.type && r.put(e.id, e.innerHTML)
            }), e.isUndefined(c.get(n)) && c.put(n, !0), i.resolve()
          }).error(function(e) {
            i.reject(new Error('Unable to load template file "' + n + '": ' + e))
          })
        }), o.all(u).then(function() {
          a()
        }, function(e) {
          a(e)
        })
      }, n.templatesLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular), Array.prototype.indexOf || (Array.prototype.indexOf = function(e, n) {
  var r;
  if (null == this) throw new TypeError('"this" is null or not defined');
  var o = Object(this),
    t = o.length >>> 0;
  if (0 === t) return -1;
  var i = +n || 0;
  if (Math.abs(i) === 1 / 0 && (i = 0), i >= t) return -1;
  for (r = Math.max(i >= 0 ? i : t - Math.abs(i), 0); t > r;) {
    if (r in o && o[r] === e) return r;
    r++
  }
  return -1
});
/*! RESOURCE: /scripts/snm/cabrillo/js_includes_cabrillo.js */
/*! RESOURCE: /scripts/snm/cabrillo/core.js */
(function(window, undefined) {
  'use strict';
  var cabrillo = {
    isNative: isNative,
    getPackageUtils: getPackageUtils,
    postMethod: postMethod,
    callMethod: callMethod,
    receiveMethod: receiveMethod,
    EXPORT_NAME: 'snmCabrillo',
    CLIENT_EXPORT_NAME: 'CabrilloClient',
    PACKAGE: 'com.servicenow.cabrillo',
    DEBUG: true,
    extend: extend,
    copyValues: copyValues,
    log: log,
    q: QInterface()
  };
  window[cabrillo.EXPORT_NAME] = cabrillo;
  var CabrilloClient = window[cabrillo.CLIENT_EXPORT_NAME];
  var cabrilloClientConfig = {
    isNative: true,
    acceptObjects: false,
    supportedMethods: null
  };
  if (typeof CabrilloClient === 'undefined') {
    CabrilloClient = _getIOSClient();
    if (!CabrilloClient) {
      CabrilloClient = _getWebClient();
    }
  }
  (function() {
    var clientConfig = CabrilloClient.getConfig();
    if (!clientConfig) {
      return;
    }
    if (typeof clientConfig === 'string') {
      clientConfig = JSON.parse(clientConfig);
    }
    extend(cabrilloClientConfig, clientConfig);
  })();
  var _methods = null;
  if (cabrilloClientConfig.supportedMethods) {
    _methods = {};
    cabrilloClientConfig.supportedMethods.forEach(function(name) {
      _methods[name] = true;
    });
  }

  function _getIOSClient() {
    var webkit = window.webkit;
    var _nativeMethod = webkit && webkit.messageHandlers ? webkit.messageHandlers[cabrillo.PACKAGE + '.camera.getBarcode'] : undefined;
    if (typeof _nativeMethod === 'undefined') {
      return;
    }
    var _client = {
      getConfig: function() {
        return {
          acceptObjects: true,
          supportedMethods: null
        };
      },
      hasMethod: function(name) {
        var method = webkit ? webkit.messageHandlers[name] : undefined;
        return (typeof method !== 'undefined');
      },
      postMethod: function(name, data) {
        if (!_client.hasMethod(name)) {
          log('Missing method: ' + name);
          return;
        }
        var method = webkit.messageHandlers[name];
        method.postMessage(data);
      }
    };
    return _client;
  }

  function _getWebClient() {
    return {
      getConfig: function() {
        return {
          isNative: false,
          acceptObjects: true,
          supportedMethods: []
        };
      },
      hasMethod: function() {
        return false;
      },
      postMethod: function() {}
    };
  }

  function isNative() {
    return cabrilloClientConfig.isNative;
  }

  function getPackageUtils(packageName) {
    if (!packageName) {
      cabrillo.log('Invalid package name');
      return;
    }
    var _packageName = packageName;

    function _isAvailable(methodName) {
      var method = _getPackageMethodName(methodName);
      return isNative() && _hasMethod(method);
    }

    function _getPackageMethodName(methodName) {
      return [
        cabrillo.PACKAGE,
        _packageName,
        methodName
      ].join('.');
    }
    return {
      isAvailable: _isAvailable,
      post: function(methodName, data) {
        var method = _getPackageMethodName(methodName);
        cabrillo.postMethod(method, data);
      },
      call: function(methodName, data) {
        var method = _getPackageMethodName(methodName);
        return cabrillo.callMethod(method, data);
      }
    };
  }

  function _hasMethod(name) {
    if (_methods) {
      return _methods[name];
    }
    if (CabrilloClient.hasMethod) {
      return CabrilloClient.hasMethod(name);
    }
    return false;
  }

  function extend(defaults, options, newObject) {
    var extended = newObject ? {} : defaults;
    var prop;
    for (prop in defaults) {
      if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
        extended[prop] = defaults[prop];
      }
    }
    for (prop in options) {
      if (Object.prototype.hasOwnProperty.call(options, prop)) {
        extended[prop] = options[prop];
      }
    }
    return extended;
  }

  function copyValues(dest, source) {
    for (var prop in source) {
      if (Object.prototype.hasOwnProperty.call(source, prop)) {
        switch (typeof source[prop]) {
          case 'function':
            break;
          default:
            dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }

  function log(msg) {
    if (!cabrillo.DEBUG) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('(Cabrillo)');
    console.log.apply(console, args);
  }

  function postMethod(name, data) {
    if (!_hasMethod(name)) {
      var err = 'Missing method: ' + name;
      log(err);
      return false;
    }
    var requestPayload = {
      options: data
    };
    _postMethod(name, requestPayload);
    return true;
  }

  function _postMethod(name, data) {
    if (!cabrilloClientConfig.acceptObjects) {
      data = JSON.stringify(data);
    }
    CabrilloClient.postMethod(name, data);
  }
  var _callId = 0;
  var _openCalls = {};

  function callMethod(name, data, context) {
    var defer = _getDeferred();
    if (!_hasMethod(name)) {
      var err = 'Missing method: ' + name;
      defer.reject(err);
      return defer.promise;
    }
    var callId = _callId++;
    var callbackContext = extend(context, {
      callId: callId
    }, true);
    var requestPayload = {
      callbackName: cabrillo.EXPORT_NAME + '.receiveMethod',
      callbackContext: callbackContext,
      options: data
    };
    _openCalls[callId] = {
      defer: defer
    };
    _postMethod(name, requestPayload);
    return defer.promise;
  }

  function receiveMethod(data) {
    if (!cabrilloClientConfig.acceptObjects) {
      data = JSON.parse(data);
    }
    var context = data.callbackContext;
    var openCall = _openCalls[context.callId];
    if (!openCall) {
      log('No open call found for request', data);
      return
    }
    delete context.callId;
    openCall.defer.resolve(data);
    delete _openCalls[context.callId];
  }

  function _getDeferred() {
    return cabrillo.q.defer();
  }

  function QInterface() {
    return {
      defer: function() {
        return new QDeferred();
      },
      reject: function() {
        return false;
      }
    };
  };

  function QDeferred() {
    var dones = [];
    var fails = [];
    var state = null;
    var payload = null;
    this.promise = {
      then: function(done, fail) {
        dones.push(done);
        fails.push(fail);
        notify();
        return this;
      }
    };
    this.resolve = function(data) {
      if (state) {
        return;
      }
      state = 'done';
      payload = data;
      notify();
    };
    this.reject = function(reason) {
      if (state) {
        return;
      }
      state = 'fail';
      payload = reason;
      notify();
    };

    function notify() {
      switch (state) {
        case 'done':
          dones.forEach(function(done) {
            if (done) {
              payload = done.call(done, payload);
            }
          });
          dones = [];
          fails = [];
          break;
        case 'fail':
          fails.forEach(function(fail) {
            if (fail) {
              payload = fail.call(fail, payload);
            }
          });
          dones = [];
          fails = [];
          break;
        default:
      }
    }
  }
})(window);;
/*! RESOURCE: /scripts/snm/cabrillo/attachments.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'attachments';
  cabrillo.extend(cabrillo, {
    attachments: {
      addFile: addFile,
      viewFile: viewFile
    }
  });
  var ADD_ATTACHMENTS_URL = '/angular.do?sysparm_type=ngk_attachments&action=add&load_attachment_record=true';

  function addFile(tableName, sysID, params, options) {
    var uploadParams = cabrillo.extend({
      attachments_modified: 'true',
      sysparm_table: tableName,
      sysparm_sys_id: sysID,
      sysparm_nostack: 'yes',
      sysparm_encryption_context: ''
    }, params || {});
    var apiPath = ADD_ATTACHMENTS_URL + '&sys_id=' + sysID + '&table=' + tableName;
    options = options || {};
    return callMethod('addFile', {
      apiPath: apiPath,
      params: uploadParams,
      uploadParamName: 'attachFile',
      sourceRect: options.sourceRect,
      maxWidth: options.maxWidth,
      maxHeight: options.maxHeight,
      jpgQuality: options.jpgQuality
    }).then(function(response) {
      return response.results;
    });
  }

  function viewFile(attachment, sourceRect, sourceBase64) {
    return callMethod('viewFile', {
      attachment: {
        sys_id: attachment.sys_id,
        content_type: attachment.content_type,
        file_name: attachment.file_name,
        sys_updated_on: attachment.sys_updated_on,
        path: attachment.sys_id + '.iix',
        thumbnail_path: attachment.thumbSrc
      },
      sourceRect: sourceRect,
      sourceBase64: sourceBase64
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/auth.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'auth';
  var packageUtils = cabrillo.getPackageUtils(PACKAGE);
  cabrillo.extend(cabrillo, {
    auth: {
      reauthenticate: reauthenticate,
      reauthenticateComplete: reauthenticateComplete
    }
  });

  function reauthenticate(currentUser) {
    return packageUtils.call('reauthenticate', {
      user: {
        sysId: currentUser.userID,
        userName: currentUser.userName,
        firstName: currentUser.firstName,
        lastName: currentUser.lastName
      }
    }).then(function(data) {
      var results = data.results;
      if (results.reauthenticated) {
        return {
          sysId: currentUser.userID,
          userName: currentUser.userName,
          firstName: currentUser.firstName,
          lastName: currentUser.lastName
        };
      }
      return cabrillo.q.reject(data.error);
    }, function(err) {
      cabrillo.log('reauthenticate error: ' + err);
      return cabrillo.q.reject(err);
    });
  }

  function reauthenticateComplete(result) {
    var message = {
      reauthenticated: false
    };
    var error = result.error || null;
    var user = result.user && result.user.userID ? result.user : null;
    if (error) {
      message.error = {
        status: error.status,
        message: error.message
      };
    } else if (user) {
      message.reauthenticated = true;
      message.user = {
        sysId: user.userID,
        userName: user.userName
      };
    }
    packageUtils.post('reauthenticateComplete', message);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/camera.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'camera';
  cabrillo.extend(cabrillo, {
    camera: {
      getBarcode: getBarcode
    }
  });

  function getBarcode() {
    return callMethod('getBarcode').then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('Failed to get barcode value:', err);
      return cabrillo.q.reject(err);
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/debug.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'debug';
  cabrillo.extend(cabrillo, {
    debug: {
      log: log
    }
  });

  function log(message) {
    cabrillo.log(message);
    callMethod('log', {
      message: message
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/form.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'form';
  cabrillo.extend(cabrillo, {
    form: {
      didChangeRecord: didChangeRecord
    }
  });

  function didChangeRecord(isNewRecord, tableName, sysId) {
    if (isNewRecord) {
      didCreateRecord(tableName, sysId);
    } else {
      didUpdateRecord(tableName, sysId);
    }
  }

  function didCreateRecord(tableName, sysId) {
    callMethod('didCreateRecord', {
      table: tableName,
      sysId: sysId
    });
  }

  function didUpdateRecord(tableName, sysId) {
    callMethod('didUpdateRecord', {
      table: tableName,
      sysId: sysId
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/geolocation.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'geolocation';
  cabrillo.extend(cabrillo, {
    geolocation: {
      getCurrentLocation: getCurrentLocation
    }
  });

  function getCurrentLocation() {
    return callMethod('getCurrentLocation').then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('Failed to get geolocation value:', err);
      return cabrillo.q.reject(err);
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/list.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'list';
  cabrillo.extend(cabrillo, {
    list: {
      selectItem: selectItem,
      selectItems: selectItems
    }
  });

  function selectItem(title, tableName, query, selectedItem, params) {
    var _selectedItem;
    if (selectedItem) {
      _selectedItem = {
        value: selectedItem.value,
        displayValue: selectedItem.displayValue
      };
    }
    return callMethod('selectItem', {
      title: title,
      table: tableName,
      query: query,
      selectedItem: _selectedItem,
      params: params
    }).then(function(data) {
      cabrillo.log('selectItem response', arguments);
      return data.results;
    });
  }

  function selectItems(title, tableName, query, selectedItems, params) {
    return callMethod('selectItems', {
      title: title,
      table: tableName,
      query: query,
      selectedItems: selectedItems,
      params: params
    }).then(function(data) {
      cabrillo.log('selectItems response', arguments);
      return data.results;
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/modal.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'modal';
  cabrillo.extend(cabrillo, {
    modal: {
      MODAL_PRESENTATION_STYLE_FULL_SCREEN: 'fullScreen',
      MODAL_PRESENTATION_STYLE_FORM_SHEET: 'formSheet',
      CLOSE_BUTTON_STYLE_CANCEL: 'cancel',
      CLOSE_BUTTON_STYLE_CLOSE: 'close',
      CLOSE_BUTTON_STYLE_DONE: 'done',
      presentModal: presentModal,
      dismissModal: dismissModal
    }
  });

  function presentModal(title, url, closeButtonStyle, modalPresentationStyle) {
    return callMethod('presentModal', {
      title: title,
      url: url,
      closeButtonStyle: closeButtonStyle ? closeButtonStyle : null,
      modalPresentationStyle: modalPresentationStyle ? modalPresentationStyle : null
    }).then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('presentModal error: ' + err);
    });
  }

  function dismissModal(data, redirect) {
    return callMethod('dismissModal', {
      results: {
        results: data,
        redirect: redirect
      }
    });
  }

  function callMethod(methodName, data, context) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data, context);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/navigation.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'navigation';
  var packageUtils = cabrillo.getPackageUtils(PACKAGE);
  cabrillo.extend(cabrillo, {
    navigation: {
      goto: goto,
      goBack: goBack
    }
  });

  function goto(uri, params) {
    if (!packageUtils.isAvailable('goto')) {
      return false;
    }
    params = params || {};
    packageUtils.post('goto', {
      uri: uri,
      table: params.table,
      sysId: params.sysId,
      query: params.query
    });
    return true;
  }

  function goBack() {
    if (!packageUtils.isAvailable('goBack')) {
      return false;
    }
    packageUtils.post('goBack');
    return true;
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/viewLayout.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'viewLayout';
  var packageUtils = cabrillo.getPackageUtils(PACKAGE);
  cabrillo.extend(cabrillo, {
    'viewLayout': {
      MORE_MENU_BUTTON_STYLE: 'moreMenuButtonStyle',
      SUCCESS_SPINNER_STYLE: 'successStyle',
      setTitle: setTitle,
      setNavigationBarButtons: setNavigationBarButtons,
      setBottomButtons: setBottomButtons,
      showSpinner: showSpinner,
      hideSpinner: hideSpinner,
      addMessage: addMessage,
      clearMessages: clearMessages,
      executeCallback: executeCallback
    }
  });
  var _callbackHandlers = {};
  var _callbackHandlerId = 0;

  function setTitle(title) {
    packageUtils.post('setTitle', {
      title: title
    });
  }

  function setNavigationBarButtons(buttons, execute) {
    var externalHandler = _registerCallbackHandler('registerNavigationBarButtons', buttons, execute);
    return packageUtils.call('setNavigationBarButtons', {
      buttons: externalHandler.payloads
    }).then(function() {
      return externalHandler;
    }, function() {
      externalHandler();
    });
  }

  function setBottomButtons(buttons, execute) {
    var externalHandler = _registerCallbackHandler('registerBottomButtons', buttons, execute);
    return packageUtils.call('setBottomButtons', {
      buttons: externalHandler.payloads
    }).then(function() {
      return externalHandler;
    }, function() {
      externalHandler();
    });
  }

  function showSpinner(options) {
    options = options || {};
    var mask = options.mask;
    var maskColor = options.maskColor;
    packageUtils.post('showSpinner', {
      mask: !!mask,
      maskColor: maskColor
    });
  }

  function hideSpinner(spinnerStyle) {
    packageUtils.post('hideSpinner', {
      dismissStyle: spinnerStyle
    });
  }

  function addMessage(type, message) {
    if (!packageUtils.isAvailable('addMessage')) {
      return false;
    }
    packageUtils.post('addMessage', {
      type: type,
      message: message
    });
    return true;
  }

  function clearMessages() {
    if (!packageUtils.isAvailable('clearMessages')) {
      return false;
    }
    packageUtils.post('clearMessages');
    return true;
  }

  function executeCallback(handlerPayload) {
    var callbackContext = handlerPayload.callbackContext;
    var handler = _callbackHandlers[callbackContext.className];
    if (!handler || (handler.id !== callbackContext.id)) {
      cabrillo.log('Handler not found');
      return;
    }
    var activeElement = document.activeElement;
    if (activeElement) {
      activeElement.blur();
    }
    handler.executeCallback(callbackContext.payloadId);
  }

  function _registerCallbackHandler(handlerClass, payloads, executeCallback) {
    if (!handlerClass) {
      throw 'Handler class must be specified';
    }
    if (!payloads) {
      payloads = [];
    }
    _unregisterCallbackHandler(handlerClass);
    var handlerPayloads = [];
    var handlerId = _callbackHandlerId++;
    payloads.forEach(function(payload, payloadIndex) {
      var callbackName = cabrillo.EXPORT_NAME + '.' + PACKAGE + '.executeCallback';
      var handlerPayload = {
        callbackName: callbackName,
        callbackContext: {
          id: handlerId,
          className: handlerClass,
          payloadId: payloadIndex
        }
      };
      handlerPayload = cabrillo.copyValues(handlerPayload, payload);
      handlerPayload.callbackScript = callbackName + '(' + JSON.stringify(handlerPayload) + ')';
      handlerPayloads.push(handlerPayload);
    });
    var handler = function() {
      var handler = _callbackHandlers[handlerClass];
      if (handler && handler === this) {
        handler.payloads = null;
        handler.executeCallback = null;
        delete _callbackHandlers[handlerClass];
      }
    };
    handler.id = handlerId;
    handler.className = handlerClass;
    handler.payloads = handlerPayloads;
    handler.executeCallback = function() {
      var handlerPayload = arguments;
      var d = cabrillo.q.defer();
      d.promise.then(function() {
        executeCallback.apply(this, handlerPayload);
      });
      d.resolve();
    };
    _callbackHandlers[handlerClass] = handler;
    return handler;
  }

  function _unregisterCallbackHandler(handler) {
    var className = typeof handler === 'string' ? handler : handler.className;
    if (_callbackHandlers[className]) {
      _callbackHandlers[className]();
    }
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/angular/cabrillo.factory.js */
if (typeof angular !== 'undefined') {
  'use strict';
  angular.module('snm.cabrillo', []).factory('cabrillo', function($window, $q) {
    var cabrillo = $window['snmCabrillo'];
    cabrillo.q = $q;
    return cabrillo;
  });
};;
/*! RESOURCE: /scripts/sn/common/glide/js_includes_glide.js */
/*! RESOURCE: /scripts/sn/common/glide/_module.js */
angular.module('sn.common.glide', [
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/sn/common/glide/factory.glideUrlBuilder.js */
angular.module('sn.common.glide').factory('glideUrlBuilder', ['$window', function($window) {
  "use strict";

  function GlideUrl(contextPath) {
    var objDef = {
      contextPath: '',
      params: {},
      encodedString: '',
      encode: true,
      setFromCurrent: function() {
        this.setFromString($window.location.href);
      },
      setFromString: function(href) {
        var pos = href.indexOf('?');
        if (pos < 0) {
          this.contextPath = href;
          return;
        }
        this.contextPath = href.slice(0, pos);
        var hashes = href.slice(pos + 1).split('&');
        var i = hashes.length;
        while (i--) {
          var pos = hashes[i].indexOf('=');
          this.params[hashes[i].substring(0, pos)] = hashes[i].substring(++pos);
        }
      },
      setContextPath: function(c) {
        this.contextPath = c;
      },
      getParam: function(p) {
        return this.params[p];
      },
      getParams: function() {
        return this.params;
      },
      addParam: function(name, value) {
        this.params[name] = value;
        return this;
      },
      addToken: function() {
        if (typeof g_ck != 'undefined' && g_ck != "")
          this.addParam('sysparm_ck', g_ck);
        return this;
      },
      deleteParam: function(name) {
        delete this.params[name];
      },
      addEncodedString: function(s) {
        if (!s)
          return;
        if (s.substr(0, 1) != "&")
          this.encodedString += "&";
        this.encodedString += s;
        return this;
      },
      getQueryString: function(additionalParams) {
        var qs = this._getParamsForURL(this.params);
        qs += this._getParamsForURL(additionalParams);
        qs += this.encodedString;
        if (qs.length == 0)
          return "";
        return qs.substring(1);
      },
      _getParamsForURL: function(params) {
        if (!params)
          return '';
        var url = '';
        for (var n in params) {
          var p = params[n] || '';
          url += '&' + n + '=' + (this.encode ? encodeURIComponent(p + '') : p);
        }
        return url;
      },
      getURL: function(additionalParams) {
        var url = this.contextPath;
        var qs = this.getQueryString(additionalParams);
        if (qs)
          url += "?" + qs;
        return url;
      },
      setEncode: function(b) {
        this.encode = b;
      },
      toString: function() {
        return 'GlideURL';
      }
    }
    return objDef;
  }
  return {
    newGlideUrl: function(contextPath) {
      var glideUrl = new GlideUrl();
      glideUrl.setFromString(contextPath ? contextPath : '');
      return glideUrl;
    },
    refresh: function() {
      $window.location.replace($window.location.href);
    },
    getCancelableLink: function(link) {
      if ($window.NOW && $window.NOW.g_cancelPreviousTransaction) {
        var nextChar = link.indexOf('?') > -1 ? '&' : '?';
        link += nextChar + "sysparm_cancelable=true";
      }
      return link;
    }
  };
}]);;
/*! RESOURCE: /scripts/sn/common/glide/service.queryFilter.js */
angular.module('sn.common.glide').factory('queryFilter', function() {
  "use strict";
  return {
    create: function() {
      var that = {};
      that.conditions = [];

      function newCondition(field, operator, value, label, displayValue, type) {
        var condition = {
          field: field,
          operator: operator,
          value: value,
          displayValue: displayValue,
          label: label,
          left: null,
          right: null,
          type: null,
          setValue: function(value, displayValue) {
            this.value = value;
            this.displayValue = displayValue ? displayValue : value;
          }
        };
        if (type)
          condition.type = type;
        return condition;
      }

      function addCondition(condition) {
        that.conditions.push(condition);
        return condition;
      }

      function removeCondition(condition) {
        for (var i = that.conditions.length - 1; i >= 0; i--) {
          if (that.conditions[i] === condition)
            that.conditions.splice(i, 1);
        }
      }

      function getConditionsByField(conditions, field) {
        var conditionsToReturn = [];
        for (var condition in conditions) {
          if (conditions.hasOwnProperty(condition)) {
            if (conditions[condition].field == field)
              conditionsToReturn.push(conditions[condition]);
          }
        }
        return conditionsToReturn;
      }

      function encodeCondition(condition) {
        var output = "";
        if (condition.hasOwnProperty("left") && condition.left) {
          output += encodeCondition(condition.left);
        }
        if (condition.hasOwnProperty("right") && condition.right) {
          var right = encodeCondition(condition.right);
          if (right.length > 0) {
            output += "^" + condition.type + right;
          }
        }
        if (condition.field) {
          output += condition.field;
          output += condition.operator;
          if (condition.value !== null && typeof condition.value !== "undefined")
            output += condition.value;
        }
        return output;
      }

      function createEncodedQuery() {
        var eq = "";
        var ca = that.conditions;
        for (var i = 0; i < ca.length; i++) {
          var condition = ca[i];
          if (eq.length)
            eq += '^';
          eq += encodeCondition(condition);
        }
        eq += "^EQ";
        return eq;
      }
      that.addCondition = addCondition;
      that.newCondition = newCondition;
      that.createEncodedQuery = createEncodedQuery;
      that.getConditionsByField = getConditionsByField;
      that.removeCondition = removeCondition;
      return that;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.filterExpressionParser.js */
angular.module('sn.common.glide').factory('filterExpressionParser', function() {
  'use strict';
  var operatorExpressions = [{
    wildcardExp: '(.*)',
    operator: 'STARTSWITH',
    toExpression: function(filter) {
      return filter;
    }
  }, {
    wildcardExp: '^\\*(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return (filter === '*' ? filter : '*' + filter);
    }
  }, {
    wildcardExp: '^\\.(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return '.' + filter;
    }
  }, {
    wildcardExp: '^%(.*)',
    operator: 'ENDSWITH',
    toExpression: function(filter) {
      return (filter === '%' ? filter : '%' + filter);
    }
  }, {
    wildcardExp: '(.*)%',
    operator: 'LIKE',
    toExpression: function(filter) {
      return filter + '%';
    }
  }, {
    wildcardExp: '^=(.*)',
    operator: '=',
    toExpression: function(filter) {
      return (filter === '=' ? filter : '=' + filter);
    }
  }, {
    wildcardExp: '^!\\*(.*)',
    operator: 'NOT LIKE',
    toExpression: function(filter) {
      return (filter === '!*' || filter === '!' ? filter : '!*' + filter);
    }
  }, {
    wildcardExp: '^!=(.*)',
    operator: '!=',
    toExpression: function(filter) {
      return (filter === '!=' || filter === '!' ? filter : '!=' + filter);
    }
  }];
  return {
    getOperatorExpressionForOperator: function(operator) {
      for (var i = 0; i < operatorExpressions.length; i++) {
        var item = operatorExpressions[i];
        if (item.operator === operator)
          return item;
      }
      throw {
        name: 'OperatorNotSupported',
        message: 'The operator ' + operator + ' is not in the list of operatorExpressions.'
      };
    },
    parse: function(val, defaultOperator) {
      var parsedValue = {
        filterText: val,
        operator: defaultOperator || 'STARTSWITH'
      };
      for (var i = 1; i < operatorExpressions.length; i++) {
        var operatorItem = operatorExpressions[i];
        var match = val.match(operatorItem.wildcardExp);
        if (match && match[1] !== '') {
          parsedValue.operator = operatorItem.operator;
          parsedValue.filterText = match[1];
        }
      }
      return parsedValue;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.userPreferences.js */
angular.module('sn.common.glide').factory("userPreferences", function($http, $q, unwrappedHTTPPromise, urlTools) {
  "use strict";
  var preferencesCache = {};

  function getPreference(preferenceName) {
    if (preferenceName in preferencesCache)
      return preferencesCache[preferenceName];
    var targetURL = urlTools.getURL('user_preference', {
        "sysparm_pref_name": preferenceName,
        "sysparm_action": "get"
      }),
      deferred = $q.defer();
    $http.get(targetURL).success(function(response) {
      deferred.resolve(response.sysparm_pref_value);
    }).error(function(data, status) {
      deferred.reject("Error getting preference " + preferenceName + ": " + status);
    });
    preferencesCache[preferenceName] = deferred.promise;
    return deferred.promise;
  }

  function setPreference(preferenceName, preferenceValue) {
    var targetURL = urlTools.getURL('user_preference', {
      "sysparm_pref_name": preferenceName,
      "sysparm_action": "set",
      "sysparm_pref_value": "" + preferenceValue
    });
    var httpPromise = $http.get(targetURL);
    addToCache(preferenceName, preferenceValue);
    return unwrappedHTTPPromise(httpPromise);
  }

  function addToCache(preferenceName, preferenceValue) {
    preferencesCache[preferenceName] = $q.when(preferenceValue);
  }
  var userPreferences = {
    getPreference: getPreference,
    setPreference: setPreference,
    addToCache: addToCache
  };
  return userPreferences;
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowStream.js */
angular.module('sn.common.glide').constant('nowStreamTimerInterval', 5000);
angular.module('sn.common.glide').factory('nowStream', function($q, $timeout, urlTools, nowStreamTimerInterval, snResource, $log) {
  'use strict';
  var Stream = function() {
    this.initialize.apply(this, arguments);
  };
  Stream.prototype = {
    initialize: function(table, query, sys_id, processor, interval, source, includeAttachments) {
      this.table = table;
      this.query = query;
      this.sysparmQuery = null;
      this.sys_id = sys_id;
      this.processor = processor;
      this.lastTimestamp = 0;
      this.inflightRequest = null;
      this.requestImmediateUpdate = false;
      this.interval = interval;
      this.source = source;
      this.includeAttachments = includeAttachments;
      this.stopped = true;
    },
    setQuery: function(sysparmQuery) {
      this.sysparmQuery = sysparmQuery;
    },
    poll: function(callback, preRequestCallback) {
      this.callback = callback;
      this.preRequestCallback = preRequestCallback;
      this._stopPolling();
      this._startPolling();
    },
    tap: function() {
      if (!this.inflightRequest) {
        this._stopPolling();
        this._startPolling();
      } else
        this.requestImmediateUpdate = true;
    },
    insert: function(field, text) {
      this.insertForEntry(field, text, this.table, this.sys_id);
    },
    insertForEntry: function(field, text, table, sys_id) {
      return this.insertEntries([{
        field: field,
        text: text
      }], table, sys_id);
    },
    expandMentions: function(entryText, mentionIDMap) {
      return entryText.replace(/@\[(.+?)\]/gi, function(mention) {
        var mentionedName = mention.substring(2, mention.length - 1);
        if (mentionIDMap[mentionedName]) {
          return "@[" + mentionIDMap[mentionedName] + ":" + mentionedName + "]";
        } else {
          return mention;
        }
      });
    },
    insertEntries: function(entries, table, sys_id, mentionIDMap) {
      mentionIDMap = mentionIDMap || {};
      var sanitizedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var entryText = entries[i].text;
        if (entryText && entryText.endsWith('\n'))
          entryText = entryText.substring(0, entryText.length - 1);
        if (!entryText)
          continue;
        entries[i].text = this.expandMentions(entryText, mentionIDMap);
        sanitizedEntries.push(entries[i]);
      }
      if (sanitizedEntries.length === 0)
        return;
      this._isInserting = true;
      var url = this._getInsertURL(table, sys_id);
      var that = this;
      return snResource().post(url, {
        entries: sanitizedEntries
      }).then(this._successCallback.bind(this), function() {
        $log.warn('Error submitting entries', sanitizedEntries);
      }).then(function() {
        that._isInserting = false;
      });
    },
    cancel: function() {
      this._stopPolling();
    },
    _startPolling: function() {
      var interval = this._getInterval();
      var that = this;
      var successCallback = this._successCallback.bind(this);
      that.stopped = false;

      function runPoll() {
        if (that._isInserting) {
          establishNextRequest();
          return;
        }
        if (!that.inflightRequest) {
          that.inflightRequest = that._executeRequest();
          that.inflightRequest.then(successCallback);
          that.inflightRequest.finally(function() {
            that.inflightRequest = null;
            if (that.requestImmediateUpdate) {
              that.requestImmediateUpdate = false;
              establishNextRequest(0);
            } else {
              establishNextRequest();
            }
          });
        }
      }

      function establishNextRequest(intervalOverride) {
        if (that.stopped)
          return;
        intervalOverride = (parseFloat(intervalOverride) >= 0) ? intervalOverride : interval;
        $timeout.cancel(that.timer);
        that.timer = $timeout(runPoll, intervalOverride);
      }
      runPoll();
    },
    _stopPolling: function() {
      if (this.timer)
        $timeout.cancel(this.timer);
      this.stopped = true;
    },
    _executeRequest: function() {
      var url = this._getURL();
      if (this.preRequestCallback) {
        this.preRequestCallback();
      }
      return snResource().get(url);
    },
    _getURL: function() {
      var params = {
        table: this.table,
        action: this._getAction(),
        sysparm_silent_request: true,
        sysparm_auto_request: true,
        sysparm_timestamp: this.lastTimestamp,
        include_attachments: this.includeAttachments
      };
      if (this.sys_id) {
        params['sys_id'] = this.sys_id;
      } else if (this.sysparmQuery) {
        params['sysparm_query'] = this.sysparmQuery;
      }
      var url = urlTools.getURL(this.processor, params);
      if (!this.sys_id) {
        url += "&p=" + this.query;
      }
      return url;
    },
    _getInsertURL: function(table, sys_id) {
      return urlTools.getURL(this.processor, {
        action: 'insert',
        table: table,
        sys_id: sys_id,
        sysparm_timestamp: this.timestamp || 0,
        sysparm_source: this.source
      });
    },
    _successCallback: function(response) {
      var response = response.data;
      if (response.entries && response.entries.length) {
        response.entries = this._filterOld(response.entries);
        if (response.entries.length > 0) {
          this.lastEntry = angular.copy(response.entries[0]);
          this.lastTimestamp = response.sys_timestamp || response.entries[0].sys_timestamp;
        }
      }
      this.callback.call(null, response);
    },
    _filterOld: function(entries) {
      for (var i = 0; i < entries.length; i++) {
        if (entries[i].sys_timestamp == this.lastTimestamp) {
          if (!angular.equals(this._makeComparable(entries[i]), this._makeComparable(this.lastEntry)))
            continue;
        }
        if (entries[i].sys_timestamp <= this.lastTimestamp)
          return entries.slice(0, i);
      }
      return entries;
    },
    _makeComparable: function(entry) {
      var copy = angular.copy(entry);
      delete copy.short_description;
      delete copy.display_value;
      return copy;
    },
    _getAction: function() {
      return this.sys_id ? 'get_new_entries' : 'get_set_entries';
    },
    _getInterval: function() {
      if (this.interval)
        return this.interval;
      else if (window.NOW && NOW.stream_poll_interval)
        return NOW.stream_poll_interval * 1000;
      else
        return nowStreamTimerInterval;
    }
  };
  return {
    create: function(table, query, sys_id, processor, interval, source) {
      return new Stream(table, query, sys_id, processor, interval, source);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowServer.js */
angular.module('sn.common.glide').factory('nowServer', function($http, $q, userPreferences, angularProcessorUrl, urlTools) {
  return {
    getBaseURL: function() {
      return angularProcessorUrl;
    },
    getPartial: function(scope, partial, parms, callback) {
      var url = this.getPartialURL(partial, parms);
      if (url === scope.url) {
        callback.call();
        return;
      }
      var fn = scope.$on('$includeContentLoaded', function() {
        fn.call();
        callback.call();
      });
      scope.url = url;
    },
    replaceView: function($location, newView) {
      var p = $location.path();
      var a = p.split("/");
      a[1] = newView;
      p = a.join("/");
      return p;
    },
    getPartialURL: urlTools.getPartialURL,
    getURL: urlTools.getURL,
    urlFor: urlTools.urlFor,
    getPropertyURL: urlTools.getPropertyURL,
    setPreference: userPreferences.setPreference,
    getPreference: userPreferences.getPreference
  }
});;;
/*! RESOURCE: /scripts/sn/common/util/js_includes_util.js */
/*! RESOURCE: /scripts/sn/common/util/_module.js */
angular.module('sn.common.util', ['sn.common.auth']);
angular.module('sn.util', ['sn.common.util']);;
/*! RESOURCE: /scripts/sn/common/util/service.dateUtils.js */
angular.module('sn.common.util').factory('dateUtils', function() {
  var dateUtils = {
    SYS_DATE_FORMAT: "yyyy-MM-dd",
    SYS_TIME_FORMAT: "HH:mm:ss",
    SYS_DATE_TIME_FORMAT: "yyyy-MM-dd HH:mm:ss",
    MONTH_NAMES: new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'),
    DAY_NAMES: new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
    LZ: function(x) {
      return (x < 0 || x > 9 ? "" : "0") + x
    },
    isDate: function(val, format) {
      var date = this.getDateFromFormat(val, format);
      if (date == 0) {
        return false;
      }
      return true;
    },
    compareDates: function(date1, dateformat1, date2, dateformat2) {
      var d1 = this.getDateFromFormat(date1, dateformat1);
      var d2 = this.getDateFromFormat(date2, dateformat2);
      if (d1 == 0 || d2 == 0) {
        return -1;
      } else if (d1 > d2) {
        return 1;
      }
      return 0;
    },
    formatDateServer: function(date, format) {
      var ga = new GlideAjax("DateTimeUtils");
      ga.addParam("sysparm_name", "formatCalendarDate");
      var browserOffset = date.getTimezoneOffset() * 60000;
      var utcTime = date.getTime() - browserOffset;
      var userDateTime = utcTime - g_tz_offset;
      ga.addParam("sysparm_value", userDateTime);
      ga.getXMLWait();
      return ga.getAnswer();
    },
    formatDate: function(date, format) {
      if (format.indexOf("z") > 0)
        return this.formatDateServer(date, format);
      format = format + "";
      var result = "";
      var i_format = 0;
      var c = "";
      var token = "";
      var y = date.getYear() + "";
      var M = date.getMonth() + 1;
      var d = date.getDate();
      var E = date.getDay();
      var H = date.getHours();
      var m = date.getMinutes();
      var s = date.getSeconds();
      var yyyy, yy, MMM, MM, dd, hh, h, mm, ss, ampm, HH, H, KK, K, kk, k;
      var value = new Object();
      value["M"] = M;
      value["MM"] = this.LZ(M);
      value["MMM"] = this.MONTH_NAMES[M + 11];
      value["NNN"] = this.MONTH_NAMES[M + 11];
      value["MMMM"] = this.MONTH_NAMES[M - 1];
      value["d"] = d;
      value["dd"] = this.LZ(d);
      value["E"] = this.DAY_NAMES[E + 7];
      value["EE"] = this.DAY_NAMES[E];
      value["H"] = H;
      value["HH"] = this.LZ(H);
      if (format.indexOf('w') != -1) {
        var wk = date.getWeek();
        if (wk >= 52 && M == 1) {
          y = date.getYear();
          y--;
          y = y + "";
        }
        if (wk == 1 && M == 12) {
          y = date.getYear();
          y++;
          y = y + "";
        }
        value["w"] = wk;
        value["ww"] = this.LZ(wk);
      }
      var dayOfWeek = (7 + (E + 1) - (g_first_day_of_week - 1)) % 7;
      if (dayOfWeek == 0)
        dayOfWeek = 7;
      value["D"] = dayOfWeek;
      if (y.length < 4) {
        y = "" + (y - 0 + 1900);
      }
      value["y"] = "" + y;
      value["yyyy"] = y;
      value["yy"] = y.substring(2, 4);
      if (H == 0) {
        value["h"] = 12;
      } else if (H > 12) {
        value["h"] = H - 12;
      } else {
        value["h"] = H;
      }
      value["hh"] = this.LZ(value["h"]);
      if (H > 11) {
        value["K"] = H - 12;
      } else {
        value["K"] = H;
      }
      value["k"] = H + 1;
      value["KK"] = this.LZ(value["K"]);
      value["kk"] = this.LZ(value["k"]);
      if (H > 11) {
        value["a"] = "PM";
      } else {
        value["a"] = "AM";
      }
      value["m"] = m;
      value["mm"] = this.LZ(m);
      value["s"] = s;
      value["ss"] = this.LZ(s);
      while (i_format < format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) && (i_format < format.length)) {
          token += format.charAt(i_format++);
        }
        if (value[token] != null) {
          result = result + value[token];
        } else {
          result = result + token;
        }
      }
      return result;
    },
    _isInteger: function(val) {
      var digits = "1234567890";
      for (var i = 0; i < val.length; i++) {
        if (digits.indexOf(val.charAt(i)) == -1) {
          return false;
        }
      }
      return true;
    },
    _getInt: function(str, i, minlength, maxlength) {
      for (var x = maxlength; x >= minlength; x--) {
        var token = str.substring(i, i + x);
        if (token.length < minlength) {
          return null;
        }
        if (this._isInteger(token)) {
          return token;
        }
      }
      return null;
    },
    getDateFromFormat: function(val, format) {
      val = val + "";
      format = format + "";
      var i_val = 0;
      var i_format = 0;
      var c = "";
      var token = "";
      var token2 = "";
      var x, y;
      var now = new Date();
      var year = now.getYear();
      var month = now.getMonth() + 1;
      var date = 0;
      var hh = now.getHours();
      var mm = now.getMinutes();
      var ss = now.getSeconds();
      var ampm = "";
      var week = false;
      while (i_format < format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) && (i_format < format.length)) {
          token += format.charAt(i_format++);
        }
        if (token == "yyyy" || token == "yy" || token == "y") {
          if (token == "yyyy") {
            x = 4;
            y = 4;
          }
          if (token == "yy") {
            x = 2;
            y = 2;
          }
          if (token == "y") {
            x = 2;
            y = 4;
          }
          year = this._getInt(val, i_val, x, y);
          if (year == null) {
            return 0;
          }
          i_val += year.length;
          if (year.length == 2) {
            if (year > 70) {
              year = 1900 + (year - 0);
            } else {
              year = 2000 + (year - 0);
            }
          }
        } else if (token == "MMM" || token == "NNN") {
          month = 0;
          for (var i = 0; i < this.MONTH_NAMES.length; i++) {
            var month_name = this.MONTH_NAMES[i];
            if (val.substring(i_val, i_val + month_name.length).toLowerCase() == month_name.toLowerCase()) {
              if (token == "MMM" || (token == "NNN" && i > 11)) {
                month = i + 1;
                if (month > 12) {
                  month -= 12;
                }
                i_val += month_name.length;
                break;
              }
            }
          }
          if ((month < 1) || (month > 12)) {
            return 0;
          }
        } else if (token == "EE" || token == "E") {
          for (var i = 0; i < this.DAY_NAMES.length; i++) {
            var day_name = this.DAY_NAMES[i];
            if (val.substring(i_val, i_val + day_name.length).toLowerCase() == day_name.toLowerCase()) {
              if (week) {
                if (i == 0 || i == 7)
                  date += 6;
                else if (i == 2 || i == 9)
                  date += 1;
                else if (i == 3 || i == 10)
                  date += 2;
                else if (i == 4 || i == 11)
                  date += 3;
                else if (i == 5 || i == 12)
                  date += 4;
                else if (i == 6 || i == 13)
                  date += 5;
              }
              i_val += day_name.length;
              break;
            }
          }
        } else if (token == "MM" || token == "M") {
          month = this._getInt(val, i_val, token.length, 2);
          if (month == null || (month < 1) || (month > 12)) {
            return 0;
          }
          i_val += month.length;
        } else if (token == "dd" || token == "d") {
          date = this._getInt(val, i_val, token.length, 2);
          if (date == null || (date < 1) || (date > 31)) {
            return 0;
          }
          i_val += date.length;
        } else if (token == "hh" || token == "h") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 1) || (hh > 12)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "HH" || token == "H") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 0) || (hh > 23)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "KK" || token == "K") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 0) || (hh > 11)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "kk" || token == "k") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh < 1) || (hh > 24)) {
            return 0;
          }
          i_val += hh.length;
          hh--;
        } else if (token == "mm" || token == "m") {
          mm = this._getInt(val, i_val, token.length, 2);
          if (mm == null || (mm < 0) || (mm > 59)) {
            return 0;
          }
          i_val += mm.length;
        } else if (token == "ss" || token == "s") {
          ss = this._getInt(val, i_val, token.length, 2);
          if (ss == null || (ss < 0) || (ss > 59)) {
            return 0;
          }
          i_val += ss.length;
        } else if (token == "a") {
          if (val.substring(i_val, i_val + 2).toLowerCase() == "am") {
            ampm = "AM";
          } else if (val.substring(i_val, i_val + 2).toLowerCase() == "pm") {
            ampm = "PM";
          } else {
            return 0;
          }
          i_val += 2;
        } else if (token == "w" || token == "ww") {
          var weekNum = this._getInt(val, i_val, token.length, 2);
          week = true;
          if (weekNum != null) {
            var temp = new Date(year, 0, 1, 0, 0, 0);
            temp.setWeek(parseInt(weekNum, 10));
            year = temp.getFullYear();
            month = temp.getMonth() + 1;
            date = temp.getDate();
          }
          weekNum += "";
          i_val += weekNum.length;
        } else if (token == "D") {
          if (week) {
            var day = this._getInt(val, i_val, token.length, 1);
            if ((day == null) || (day <= 0) || (day > 7))
              return 0;
            var temp = new Date(year, month - 1, date, hh, mm, ss);
            var dayOfWeek = temp.getDay();
            day = parseInt(day, 10);
            day = (day + g_first_day_of_week - 1) % 7;
            if (day == 0)
              day = 7;
            day--;
            if (day < dayOfWeek)
              day = 7 - (dayOfWeek - day);
            else
              day -= dayOfWeek;
            if (day > 0) {
              temp.setDate(temp.getDate() + day);
              year = temp.getFullYear();
              month = temp.getMonth() + 1;
              date = temp.getDate();
            }
            i_val++;
          }
        } else if (token == "z")
          i_val += 3;
        else {
          if (val.substring(i_val, i_val + token.length) != token) {
            return 0;
          } else {
            i_val += token.length;
          }
        }
      }
      if (i_val != val.length) {
        return 0;
      }
      if (month == 2) {
        if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
          if (date > 29) {
            return 0;
          }
        } else {
          if (date > 28) {
            return 0;
          }
        }
      }
      if ((month == 4) || (month == 6) || (month == 9) || (month == 11)) {
        if (date > 30) {
          return 0;
        }
      }
      if (hh < 12 && ampm == "PM") {
        hh = hh - 0 + 12;
      } else if (hh > 11 && ampm == "AM") {
        hh -= 12;
      }
      var newdate = new Date(year, month - 1, date, hh, mm, ss);
      return newdate.getTime();
    },
    parseDate: function(val) {
      var preferEuro = (arguments.length == 2) ? arguments[1] : false;
      generalFormats = new Array('y-M-d', 'MMM d, y', 'MMM d,y', 'y-MMM-d', 'd-MMM-y', 'MMM d');
      monthFirst = new Array('M/d/y', 'M-d-y', 'M.d.y', 'MMM-d', 'M/d', 'M-d');
      dateFirst = new Array('d/M/y', 'd-M-y', 'd.M.y', 'd-MMM', 'd/M', 'd-M');
      yearFirst = new Array('yyyyw.F', 'yyw.F');
      var checkList = new Array('generalFormats', preferEuro ? 'dateFirst' : 'monthFirst', preferEuro ? 'monthFirst' : 'dateFirst', 'yearFirst');
      var d = null;
      for (var i = 0; i < checkList.length; i++) {
        var l = window[checkList[i]];
        for (var j = 0; j < l.length; j++) {
          d = this.getDateFromFormat(val, l[j]);
          if (d != 0) {
            return new Date(d);
          }
        }
      }
      return null;
    }
  };
  Date.prototype.getWeek = function() {
    var newYear = new Date(this.getFullYear(), 0, 1);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    day = (day >= 0 ? day : day + 7);
    var dayNum = Math.floor((this.getTime() - newYear.getTime() - (this.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    var weekNum;
    if (day < 4) {
      weekNum = Math.floor((dayNum + day - 1) / 7) + 1;
      if (weekNum > 52)
        weekNum = this._checkNextYear(weekNum);
      return weekNum;
    }
    weekNum = Math.floor((dayNum + day - 1) / 7);
    if (weekNum < 1)
      weekNum = this._lastWeekOfYear();
    else if (weekNum > 52)
      weekNum = this._checkNextYear(weekNum);
    return weekNum;
  };
  Date.prototype._lastWeekOfYear = function() {
    var newYear = new Date(this.getFullYear() - 1, 0, 1);
    var endOfYear = new Date(this.getFullYear() - 1, 11, 31);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    var dayNum = Math.floor((endOfYear.getTime() - newYear.getTime() - (endOfYear.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    return day < 4 ? Math.floor((dayNum + day - 1) / 7) + 1 : Math.floor((dayNum + day - 1) / 7);
  };
  Date.prototype._checkNextYear = function() {
    var nYear = new Date(this.getFullYear() + 1, 0, 1);
    var nDay = nYear.getDay() - (g_first_day_of_week - 1);
    nDay = nDay >= 0 ? nDay : nDay + 7;
    return nDay < 4 ? 1 : 53;
  };
  Date.prototype.setWeek = function(weekNum) {
    weekNum--;
    var startOfYear = new Date(this.getFullYear(), 0, 1);
    var day = startOfYear.getDay() - (g_first_day_of_week - 1);
    if (day > 0 && day < 4) {
      this.setFullYear(startOfYear.getFullYear() - 1);
      this.setDate(31 - day + 1);
      this.setMonth(11);
    } else if (day > 3)
      this.setDate(startOfYear.getDate() + (7 - day));
    this.setDate(this.getDate() + (7 * weekNum));
  };
  return dateUtils;
});
/*! RESOURCE: /scripts/sn/common/util/service.debounceFn.js */
angular.module("sn.common.util").service("debounceFn", function() {
  "use strict";

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
  return {
    debounce: debounce
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.unwrappedHTTPPromise.js */
angular.module('sn.common.util').factory("unwrappedHTTPPromise", function($q) {
  "use strict";

  function isGenericPromise(promise) {
    return (typeof promise.then === "function" &&
      promise.success === undefined &&
      promise.error === undefined);
  }
  return function(httpPromise) {
    if (isGenericPromise(httpPromise))
      return httpPromise;
    var deferred = $q.defer();
    httpPromise.success(function(data) {
      deferred.resolve(data);
    }).error(function(data, status) {
      deferred.reject({
        data: data,
        status: status
      })
    });
    return deferred.promise;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.urlTools.js */
angular.module('sn.common.util').constant('angularProcessorUrl', 'angular.do?sysparm_type=');
angular.module('sn.common.util').factory("urlTools", function(getTemplateUrl, angularProcessorUrl) {
  "use strict";

  function getPartialURL(name, parameters) {
    var url = getTemplateUrl(name);
    if (parameters) {
      if (typeof parameters !== 'string') {
        parameters = encodeURIParameters(parameters);
      }
      if (parameters.length) {
        url += "&" + parameters;
      }
    }
    if (window.NOW && window.NOW.ng_cache_defeat)
      url += "&t=" + new Date().getTime();
    return url;
  }

  function getURL(name, parameters) {
    if (parameters && typeof parameters === 'object')
      return urlFor(name, parameters);
    var url = angularProcessorUrl;
    url += name;
    if (parameters)
      url += "&" + parameters;
    return url;
  }

  function urlFor(route, parameters) {
    var p = encodeURIParameters(parameters);
    return angularProcessorUrl + route + (p.length ? '&' + p : '');
  }

  function getPropertyURL(name) {
    var url = angularProcessorUrl + "get_property&name=" + name;
    url += "&t=" + new Date().getTime();
    return url;
  }

  function encodeURIParameters(parameters) {
    var s = [];
    for (var parameter in parameters) {
      if (parameters.hasOwnProperty(parameter)) {
        var key = encodeURIComponent(parameter);
        var value = parameters[parameter] ? encodeURIComponent(parameters[parameter]) : '';
        s.push(key + "=" + value);
      }
    }
    return s.join('&');
  }

  function parseQueryString(qs) {
    qs = qs || '';
    if (qs.charAt(0) === '?') {
      qs = qs.substr(1);
    }
    var a = qs.split('&');
    if (a === "") {
      return {};
    }
    if (a && a[0].indexOf('http') != -1)
      a[0] = a[0].split("?")[1];
    var b = {};
    for (var i = 0; i < a.length; i++) {
      var p = a[i].split('=', 2);
      if (p.length == 1) {
        b[p[0]] = "";
      } else {
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
    }
    return b;
  }
  return {
    getPartialURL: getPartialURL,
    getURL: getURL,
    urlFor: urlFor,
    getPropertyURL: getPropertyURL,
    encodeURIParameters: encodeURIParameters,
    parseQueryString: parseQueryString
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.getTemplateUrl.js */
angular.module('sn.common.util').provider('getTemplateUrl', function(angularProcessorUrl) {
  'use strict';
  var _handlerId = 0;
  var _handlers = {};
  this.registerHandler = function(handler) {
    var registeredId = _handlerId;
    _handlers[_handlerId] = handler;
    _handlerId++;
    return function() {
      delete _handlers[registeredId];
    };
  };
  this.$get = function() {
    return getTemplateUrl;
  };

  function getTemplateUrl(templatePath) {
    if (_handlerId > 0) {
      var path;
      var handled = false;
      angular.forEach(_handlers, function(handler) {
        if (!handled) {
          var handlerPath = handler(templatePath);
          if (typeof handlerPath !== 'undefined') {
            path = handlerPath;
            handled = true;
          }
        }
      });
      if (handled) {
        return path;
      }
    }
    return angularProcessorUrl + 'get_partial&name=' + templatePath;
  }
});;
/*! RESOURCE: /scripts/sn/common/util/service.snTabActivity.js */
angular.module("sn.common.util").service("snTabActivity", function($window, $timeout, $rootElement, $document) {
  "use strict";
  var activeEvents = ["keydown", "DOMMouseScroll", "mousewheel", "mousedown", "touchstart", "mousemove", "mouseenter", "input", "focus", "scroll"],
    defaultIdle = 75000,
    isPrimary = true,
    idleTime = 0,
    isVisible = true,
    idleTimeout = void(0),
    pageIdleTimeout = void(0),
    hasActed = false,
    appName = $rootElement.attr('ng-app') || "",
    storageKey = "sn.tabs." + appName + ".activeTab";
  var callbacks = {
    "tab.primary": [],
    "tab.secondary": [],
    "activity.active": [],
    "activity.idle": [{
      delay: defaultIdle,
      cb: function() {}
    }]
  };
  $window.tabGUID = $window.tabGUID || createGUID();

  function getActiveEvents() {
    return activeEvents.join(".snTabActivity ") + ".snTabActivity";
  }

  function setAppName(an) {
    appName = an;
    storageKey = "sn.tabs." + appName + ".activeTab";
    makePrimary(true);
  }

  function createGUID(l) {
    l = l || 32;
    var strResult = '';
    while (strResult.length < l)
      strResult += (((1 + Math.random() + new Date().getTime()) * 0x10000) | 0).toString(16).substring(1);
    return strResult.substr(0, l);
  }

  function ngObjectIndexOf(arr, obj) {
    for (var i = 0, len = arr.length; i < len; i++)
      if (angular.equals(arr[i], obj))
        return i;
    return -1;
  }
  var detectedApi,
    apis = [{
      eventName: 'visibilitychange',
      propertyName: 'hidden'
    }, {
      eventName: 'mozvisibilitychange',
      propertyName: 'mozHidden'
    }, {
      eventName: 'msvisibilitychange',
      propertyName: 'msHidden'
    }, {
      eventName: 'webkitvisibilitychange',
      propertyName: 'webkitHidden'
    }];
  apis.some(function(api) {
    if (angular.isDefined($document[0][api.propertyName])) {
      detectedApi = api;
      return true;
    }
  });
  if (detectedApi)
    $document.on(detectedApi.eventName, function() {
      if (!$document[0][detectedApi.propertyName]) {
        makePrimary();
        isVisible = true;
      } else {
        if (!idleTimeout && !idleTime)
          waitForIdle(0);
        isVisible = false;
      }
    });
  angular.element($window).on({
    "mouseleave": function(e) {
      var destination = angular.isUndefined(e.toElement) ? e.relatedTarget : e.toElement;
      if (destination === null && $document[0].hasFocus()) {
        waitForIdle(0);
      }
    },
    "storage": function(e) {
      if (e.originalEvent.key !== storageKey)
        return;
      if ($window.localStorage.getItem(storageKey) !== $window.tabGUID)
        makeSecondary();
    }
  });

  function waitForIdle(index, delayOffset) {
    var callback = callbacks['activity.idle'][index];
    var numCallbacks = callbacks['activity.idle'].length;
    delayOffset = delayOffset || callback.delay;
    angular.element($window).off(getActiveEvents());
    angular.element($window).one(getActiveEvents(), setActive);
    if (index >= numCallbacks)
      return;
    if (idleTimeout)
      $timeout.cancel(idleTimeout);
    idleTimeout = $timeout(function() {
      idleTime = callback.delay;
      callback.cb();
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
      angular.element($window).off(getActiveEvents());
      angular.element($window).one(getActiveEvents(), setActive);
      for (var i = index + 1; i < numCallbacks; i++) {
        var nextDelay = callbacks['activity.idle'][i].delay;
        if (nextDelay <= callback.delay)
          callbacks['activity.idle'][i].cb();
        else {
          waitForIdle(i, nextDelay - callback.delay);
          break;
        }
      }
    }, delayOffset, false);
  }

  function setActive() {
    angular.element($window).off(getActiveEvents());
    if (idleTimeout) {
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
    }
    var activeCallbacks = callbacks['activity.active'];
    activeCallbacks.some(function(callback) {
      if (callback.delay <= idleTime)
        callback.cb();
      else
        return true;
    });
    idleTime = 0;
    makePrimary();
    if (pageIdleTimeout) {
      $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = void(0);
    }
    var minDelay = callbacks['activity.idle'][0].delay;
    hasActed = false;
    if (!pageIdleTimeout)
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
    listenForActivity();
  }

  function pageIdleHandler() {
    if (idleTimeout)
      return;
    var minDelay = callbacks['activity.idle'][0].delay;
    if (hasActed) {
      hasActed = false;
      if (pageIdleTimeout)
        $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
      listenForActivity();
      return;
    }
    var delayOffset = minDelay;
    if (callbacks['activity.idle'].length > 1)
      delayOffset = callbacks['activity.idle'][1].delay - minDelay;
    idleTime = minDelay;
    callbacks['activity.idle'][0].cb();
    waitForIdle(1, delayOffset);
    pageIdleTimeout = void(0);
  }

  function listenForActivity() {
    angular.element($window).off(getActiveEvents());
    angular.element($window).one(getActiveEvents(), onActivity);
    angular.element("#gsft_main").on("load.snTabActivity", function() {
      var src = angular.element(this).attr('src');
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = this.contentWindow ? this.contentWindow : this.contentDocument.defaultView;
        angular.element(iframeWindow).off(getActiveEvents());
        angular.element(iframeWindow).one(getActiveEvents(), onActivity);
      }
    });
    angular.element('iframe').each(function(idx, iframe) {
      var src = angular.element(iframe).attr('src');
      if (!src)
        return;
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = iframe.contentWindow ? iframe.contentWindow : iframe.contentDocument.defaultView;
        angular.element(iframeWindow).off(getActiveEvents());
        angular.element(iframeWindow).one(getActiveEvents(), onActivity);
      }
    });
  }

  function onActivity() {
    hasActed = true;
    makePrimary();
  }

  function makePrimary(initial) {
    var oldGuid = $window.localStorage.getItem(storageKey);
    isPrimary = true;
    isVisible = true;
    $timeout.cancel(idleTimeout);
    idleTimeout = void(0);
    if (canUseStorage() && oldGuid !== $window.tabGUID && !initial)
      for (var i = 0, len = callbacks["tab.primary"].length; i < len; i++)
        callbacks["tab.primary"][i].cb();
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
    } catch (ignored) {}
    if (idleTime && $document[0].hasFocus())
      setActive();
  }

  function makeSecondary() {
    isPrimary = false;
    isVisible = false;
    for (var i = 0, len = callbacks["tab.secondary"].length; i < len; i++)
      callbacks["tab.secondary"][i].cb();
  }

  function registerCallback(event, callback, scope) {
    var cbObject = angular.isObject(callback) ? callback : {
      delay: defaultIdle,
      cb: callback
    };
    if (callbacks[event]) {
      callbacks[event].push(cbObject);
      callbacks[event].sort(function(a, b) {
        return a.delay - b.delay;
      })
    }

    function destroyCallback() {
      if (callbacks[event]) {
        var pos = ngObjectIndexOf(callbacks[event], cbObject);
        if (pos !== -1)
          callbacks[event].splice(pos, 1);
      }
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyCallback();
      });
    return destroyCallback;
  }

  function registerIdleCallback(options, onIdle, onReturn, scope) {
    var delay = options,
      onIdleDestroy,
      onReturnDestroy;
    if (angular.isObject(options)) {
      delay = options.delay;
      onIdle = options.onIdle || onIdle;
      onReturn = options.onReturn || onReturn;
      scope = options.scope || scope;
    }
    if (angular.isFunction(onIdle))
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: onIdle
      });
    else if (angular.isFunction(onReturn)) {
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: function() {}
      });
    }
    if (angular.isFunction(onReturn))
      onReturnDestroy = registerCallback("activity.active", {
        delay: delay,
        cb: onReturn
      });

    function destroyAll() {
      if (angular.isFunction(onIdleDestroy))
        onIdleDestroy();
      if (angular.isFunction(onReturnDestroy))
        onReturnDestroy();
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyAll();
      });
    return destroyAll;
  }

  function canUseStorage() {
    var canWe = false;
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
      canWe = true;
    } catch (ignored) {}
    return canWe;
  }
  makePrimary(true);
  listenForActivity();
  pageIdleTimeout = $timeout(pageIdleHandler, defaultIdle, false);
  return {
    on: registerCallback,
    onIdle: registerIdleCallback,
    setAppName: setAppName,
    get isPrimary() {
      return isPrimary;
    },
    get isIdle() {
      return idleTime > 0;
    },
    get idleTime() {
      return idleTime;
    },
    get isVisible() {
      return isVisible;
    },
    get appName() {
      return appName;
    },
    get defaultIdleTime() {
      return defaultIdle
    },
    isActive: function() {
      return this.idleTime < this.defaultIdleTime && this.isVisible;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.ArraySynchronizer.js */
angular.module("sn.common.util").factory("ArraySynchronizer", function() {
  'use strict';

  function ArraySynchronizer() {}

  function index(key, arr) {
    var result = {};
    var keys = [];
    result.orderedKeys = keys;
    angular.forEach(arr, function(item) {
      var keyValue = item[key];
      result[keyValue] = item;
      keys.push(keyValue);
    });
    return result;
  }

  function sortByKeyAndModel(arr, key, model) {
    arr.sort(function(a, b) {
      var aIndex = model.indexOf(a[key]);
      var bIndex = model.indexOf(b[key]);
      if (aIndex > bIndex)
        return 1;
      else if (aIndex < bIndex)
        return -1;
      return 0;
    });
  }
  ArraySynchronizer.prototype = {
    add: function(syncField, dest, source, end) {
      end = end || "bottom";
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1) {
          if (end === "bottom") {
            dest.push(sourceIndex[key]);
          } else {
            dest.unshift(sourceIndex[key]);
          }
        }
      });
    },
    synchronize: function(syncField, dest, source, deepKeySyncArray) {
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      deepKeySyncArray = (typeof deepKeySyncArray === "undefined") ? [] : deepKeySyncArray;
      for (var i = destIndex.orderedKeys.length - 1; i >= 0; i--) {
        var key = destIndex.orderedKeys[i];
        if (sourceIndex.orderedKeys.indexOf(key) === -1) {
          destIndex.orderedKeys.splice(i, 1);
          dest.splice(i, 1);
        }
        if (deepKeySyncArray.length > 0) {
          angular.forEach(deepKeySyncArray, function(deepKey) {
            if (sourceIndex[key] && destIndex[key][deepKey] !== sourceIndex[key][deepKey]) {
              destIndex[key][deepKey] = sourceIndex[key][deepKey];
            }
          });
        }
      }
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1)
          dest.push(sourceIndex[key]);
      });
      sortByKeyAndModel(dest, syncField, sourceIndex.orderedKeys);
    }
  };
  return ArraySynchronizer;
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBindOnce.js */
angular.module("sn.common.util").directive("snBindOnce", function($sanitize) {
  "use strict";
  return {
    restrict: "A",
    link: function(scope, element, attrs) {
      var value = scope.$eval(attrs.snBindOnce);
      var sanitizedValue = $sanitize(value);
      element.append(sanitizedValue);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/util/directive.snCloak.js */
angular.module("sn.common.util").directive("snCloak", function() {
  "use strict";
  return {
    restrict: "A",
    compile: function(element, attr) {
      return function() {
        attr.$set('snCloak', undefined);
        element.removeClass('sn-cloak');
      }
    }
  };
});
/*! RESOURCE: /scripts/sn/common/util/service.md5.js */
angular.module('sn.common.util').factory('md5', function() {
      'use strict';
      var md5cycle = function(x, k) {
          var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];
          a = ff(a, b, c, d, k[0], 7, -680876936);
          d = ff(d, a, b, c, k[1], 12, -389564586);
          c = ff(c, d, a, b, k[2], 17, 606105819);
          b = ff(b, c, d, a, k[3], 22, -1044525330);
          a = ff(a, b, c, d, k[4], 7, -176418897);
          d = ff(d, a, b, c, k[5], 12, 1200080426);
          c = ff(c, d, a, b, k[6], 17, -1473231341);
          b = ff(b, c, d, a, k[7], 22, -45705983);
          a = ff(a, b, c, d, k[8], 7, 1770035416);
          d = ff(d, a, b, c, k[9], 12, -1958414417);
          c = ff(c, d, a, b, k[10], 17, -42063);
          b = ff(b, c, d, a, k[11], 22, -1990404162);
          a = ff(a, b, c, d, k[12], 7, 1804603682);
          d = ff(d, a, b, c, k[13], 12, -40341101);
          c = ff(c, d, a, b, k[14], 17, -1502002290);
          b = ff(b, c, d, a, k[15], 22, 1236535329);
          a = gg(a, b, c, d, k[1], 5, -165796510);
          d = gg(d, a, b, c, k[6], 9, -1069501632);
          c = gg(c, d, a, b, k[11], 14, 643717713);
          b = gg(b, c, d, a, k[0], 20, -373897302);
          a = gg(a, b, c, d, k[5], 5, -701558691);
          d = gg(d, a, b, c, k[10], 9, 38016083);
          c = gg(c, d, a, b, k[15], 14, -660478335);
          b = gg(b, c, d, a, k[4], 20, -405537848);
          a = gg(a, b, c, d, k[9], 5, 568446438);
          d = gg(d, a, b, c, k[14], 9, -1019803690);
          c = gg(c, d, a, b, k[3], 14, -187363961);
          b = gg(b, c, d, a, k[8], 20, 1163531501);
          a = gg(a, b, c, d, k[13], 5, -1444681467);
          d = gg(d, a, b, c, k[2], 9, -51403784);
          c = gg(c, d, a, b, k[7], 14, 1735328473);
          b = gg(b, c, d, a, k[12], 20, -1926607734);
          a = hh