/*! RESOURCE: /scripts/GlideV2ChartingIncludes.js */
/*! RESOURCE: /scripts/lib/jquery2_includes.js */
/*! RESOURCE: /scripts/lib/jquery/jquery_clean.js */
(function() {
  if (!window.jQuery)
    return;
  if (!window.$j_glide)
    window.$j = jQuery.noConflict();
  if (window.$j_glide && jQuery != window.$j_glide) {
    if (window.$j_glide)
      jQuery.noConflict(true);
    window.$j = window.$j_glide;
  }
})();;
/*! RESOURCE: /scripts/lib/jquery/jquery-2.2.3.min.js */
/*! jQuery v2.2.3 | (c) jQuery Foundation | jquery.org/license */
! function(a, b) {
  "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = a.document,
    e = c.slice,
    f = c.concat,
    g = c.push,
    h = c.indexOf,
    i = {},
    j = i.toString,
    k = i.hasOwnProperty,
    l = {},
    m = "2.2.3",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return e.call(this)
    },
    get: function(a) {
      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a) {
      return n.each(this, a)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(e.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 > a ? b : 0);
      return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor()
    },
    push: g,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
      if (null != (a = arguments[h]))
        for (b in a) c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray,
    isWindow: function(a) {
      return null != a && a === a.window
    },
    isNumeric: function(a) {
      var b = a && a.toString();
      return !n.isArray(a) && b - parseFloat(b) + 1 >= 0
    },
    isPlainObject: function(a) {
      var b;
      if ("object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;
      if (a.constructor && !k.call(a, "constructor") && !k.call(a.constructor.prototype || {}, "isPrototypeOf")) return !1;
      for (b in a);
      return void 0 === b || k.call(a, b)
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? i[j.call(a)] || "object" : typeof a
    },
    globalEval: function(a) {
      var b, c = eval;
      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = d.createElement("script"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a))
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b) {
      var c, d = 0;
      if (s(a)) {
        for (c = a.length; c > d; d++)
          if (b.call(a[d], d, a[d]) === !1) break
      } else
        for (d in a)
          if (b.call(a[d], d, a[d]) === !1) break;
      return a
    },
    trim: function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : g.call(c, a)), c
    },
    inArray: function(a, b, c) {
      return null == b ? -1 : h.call(b, a, c)
    },
    merge: function(a, b) {
      for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, e, g = 0,
        h = [];
      if (s(a))
        for (d = a.length; d > g; g++) e = b(a[g], g, c), null != e && h.push(e);
      else
        for (g in a) e = b(a[g], g, c), null != e && h.push(e);
      return f.apply([], h)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, d, f;
      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function() {
        return a.apply(b || this, d.concat(e.call(arguments)))
      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0
    },
    now: Date.now,
    support: l
  }), "function" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
    i["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = !!a && "length" in a && a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date,
      v = a.document,
      w = 0,
      x = 0,
      y = ga(),
      z = ga(),
      A = ga(),
      B = function(a, b) {
        return a === b && (l = !0), 0
      },
      C = 1 << 31,
      D = {}.hasOwnProperty,
      E = [],
      F = E.pop,
      G = E.push,
      H = E.push,
      I = E.slice,
      J = function(a, b) {
        for (var c = 0, d = a.length; d > c; c++)
          if (a[c] === b) return c;
        return -1
      },
      K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      L = "[\\x20\\t\\r\\n\\f]",
      M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      N = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + M + "))|)" + L + "*\\]",
      O = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + N + ")*)|.*)\\)|)",
      P = new RegExp(L + "+", "g"),
      Q = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
      R = new RegExp("^" + L + "*," + L + "*"),
      S = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
      T = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
      U = new RegExp(O),
      V = new RegExp("^" + M + "$"),
      W = {
        ID: new RegExp("^#(" + M + ")"),
        CLASS: new RegExp("^\\.(" + M + ")"),
        TAG: new RegExp("^(" + M + "|[*])"),
        ATTR: new RegExp("^" + N),
        PSEUDO: new RegExp("^" + O),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + K + ")$", "i"),
        needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
      },
      X = /^(?:input|select|textarea|button)$/i,
      Y = /^h\d$/i,
      Z = /^[^{]+\{\s*\[native \w/,
      $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      _ = /[+~]/,
      aa = /'|\\/g,
      ba = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
      ca = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
      },
      da = function() {
        m()
      };
    try {
      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType
    } catch (ea) {
      H = {
        apply: E.length ? function(a, b) {
          G.apply(a, I.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function fa(a, b, d, e) {
      var f, h, j, k, l, o, r, s, w = b && b.ownerDocument,
        x = b ? b.nodeType : 9;
      if (d = d || [], "string" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;
      if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {
        if (11 !== x && (o = $.exec(a)))
          if (f = o[1]) {
            if (9 === x) {
              if (!(j = b.getElementById(f))) return d;
              if (j.id === f) return d.push(j), d
            } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d
          } else {
            if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;
            if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d
          } if (c.qsa && !A[a + " "] && (!q || !q.test(a))) {
          if (1 !== x) w = b, s = a;
          else if ("object" !== b.nodeName.toLowerCase()) {
            (k = b.getAttribute("id")) ? k = k.replace(aa, "\\$&"): b.setAttribute("id", k = u), r = g(a), h = r.length, l = V.test(k) ? "#" + k : "[id='" + k + "']";
            while (h--) r[h] = l + " " + qa(r[h]);
            s = r.join(","), w = _.test(a) && oa(b.parentNode) || b
          }
          if (s) try {
            return H.apply(d, w.querySelectorAll(s)), d
          } catch (y) {} finally {
            k === u && b.removeAttribute("id")
          }
        }
      }
      return i(a.replace(Q, "$1"), b, d, e)
    }

    function ga() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function ha(a) {
      return a[u] = !0, a
    }

    function ia(a) {
      var b = n.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode && b.parentNode.removeChild(b), b = null
      }
    }

    function ja(a, b) {
      var c = a.split("|"),
        e = c.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function ka(a, b) {
      var c = b && a,
        d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function la(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c && b.type === a
      }
    }

    function ma(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) && b.type === a
      }
    }

    function na(a) {
      return ha(function(b) {
        return b = +b, ha(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function oa(a) {
      return a && "undefined" != typeof a.getElementsByTagName && a
    }
    c = fa.support = {}, f = fa.isXML = function(a) {
      var b = a && (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, m = fa.setDocument = function(a) {
      var b, e, g = a ? a.ownerDocument || a : v;
      return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ia(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = ia(function(a) {
        return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function(a) {
        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if ("undefined" != typeof b.getElementById && p) {
          var c = b.getElementById(a);
          return c ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(ba, ca);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(ba, ca);
        return function(a) {
          var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
          return c && c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType && d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
        return "undefined" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0
      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function(a) {
        o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
      }), ia(function(a) {
        var b = n.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function(a) {
        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", O)
      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b && b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, B = b ? function(a, b) {
        if (a === b) return l = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return l = !0, 0;
        var c, d = 0,
          e = a.parentNode,
          f = b.parentNode,
          g = [a],
          h = [b];
        if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
        if (e === f) return ka(a, b);
        c = a;
        while (c = c.parentNode) g.unshift(c);
        c = b;
        while (c = c.parentNode) h.unshift(c);
        while (g[d] === h[d]) d++;
        return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0
      }, n) : n
    }, fa.matches = function(a, b) {
      return fa(a, null, null, b)
    }, fa.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try {
        var d = s.call(a, b);
        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
      } catch (e) {}
      return fa(b, n, null, [a]).length > 0
    }, fa.contains = function(a, b) {
      return (a.ownerDocument || a) !== n && m(a), t(a, b)
    }, fa.attr = function(a, b) {
      (a.ownerDocument || a) !== n && m(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
      return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
    }, fa.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, fa.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
        while (b = a[f++]) b === a[f] && (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return k = null, a
    }, e = fa.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = fa.selectors = {
      cacheLength: 50,
      createPseudo: ha,
      match: W,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || "").replace(ba, ca), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fa.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[6] && a[2];
          return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(ba, ca).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName && a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = y[a + " "];
          return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = fa.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(P, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d && 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h && b.nodeName.toLowerCase(),
              s = !i && !h,
              t = !1;
            if (q) {
              if (f) {
                while (p) {
                  m = b;
                  while (m = m[p])
                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
                  o = p = "only" === a && !o && "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g && s) {
                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];
                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                  if (1 === m.nodeType && ++t && m === b) {
                    k[a] = [w, n, t];
                    break
                  }
              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1)
                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                  if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;
              return t -= e, t === d || t % d === 0 && t / d >= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error("unsupported pseudo: " + a);
          return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: ha(function(a) {
          var b = [],
            c = [],
            d = h(a.replace(Q, "$1"));
          return d[u] ? ha(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
          }
        }),
        has: ha(function(a) {
          return function(b) {
            return fa(a, b).length > 0
          }
        }),
        contains: ha(function(a) {
          return a = a.replace(ba, ca),
            function(b) {
              return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
            }
        }),
        lang: ha(function(a) {
          return V.test(a || "") || fa.error("unsupported lang: " + a), a = a.replace(ba, ca).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location && a.location.hash;
          return c && c.slice(1) === b.id
        },
        root: function(a) {
          return a === o
        },
        focus: function(a) {
          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && !!a.checked || "option" === b && !!a.selected
        },
        selected: function(a) {
          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType < 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return Y.test(a.nodeName)
        },
        input: function(a) {
          return X.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: na(function() {
          return [0]
        }),
        last: na(function(a, b) {
          return [b - 1]
        }),
        eq: na(function(a, b, c) {
          return [0 > c ? c + b : c]
        }),
        even: na(function(a, b) {
          for (var c = 0; b > c; c += 2) a.push(c);
          return a
        }),
        odd: na(function(a, b) {
          for (var c = 1; b > c; c += 2) a.push(c);
          return a
        }),
        lt: na(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);
          return a
        }),
        gt: na(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = la(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = ma(b);

    function pa() {}
    pa.prototype = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function(a, b) {
      var c, e, f, g, h, i, j, k = z[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(Q, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? fa.error(a) : z(a, i).slice(0)
    };

    function qa(a) {
      for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
      return d
    }

    function ra(a, b, c) {
      var d = b.dir,
        e = c && "parentNode" === d,
        f = x++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j, k = [w, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) && a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];
              if (i[d] = k, k[2] = a(b, c, g)) return !0
            }
      }
    }

    function sa(a) {
      return a.length > 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function ta(a, b, c) {
      for (var d = 0, e = b.length; e > d; d++) fa(a, b[d], c);
      return c
    }

    function ua(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
      return g
    }

    function va(a, b, c, d, e, f) {
      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || ta(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f && b ? p : ua(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c && c(q, r, h, i), d) {
          j = ua(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) && j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
          }
        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r)
      })
    }

    function wa(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ra(function(a) {
          return a === b
        }, h, !0), l = ra(function(a) {
          return J(b, a) > -1
        }, h, !0), m = [function(a, c, d) {
          var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
          return b = null, e
        }]; f > i; i++)
        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];
        else {
          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
            for (e = ++i; f > e; e++)
              if (d.relative[a[e].type]) break;
            return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({
              value: " " === a[i - 2].type ? "*" : ""
            })).replace(Q, "$1"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a))
          }
          m.push(c)
        } return sa(m)
    }

    function xa(a, b) {
      var c = b.length > 0,
        e = a.length > 0,
        f = function(f, g, h, i, k) {
          var l, o, q, r = 0,
            s = "0",
            t = f && [],
            u = [],
            v = j,
            x = f || e && d.find.TAG("*", k),
            y = w += null == v ? 1 : Math.random() || .1,
            z = x.length;
          for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {
            if (e && l) {
              o = 0, g || l.ownerDocument === n || (m(l), h = !p);
              while (q = a[o++])
                if (q(l, g || n, h)) {
                  i.push(l);
                  break
                } k && (w = y)
            }
            c && ((l = !q && l) && r--, f && t.push(l))
          }
          if (r += s, c && s !== r) {
            o = 0;
            while (q = b[o++]) q(t, u, g, h);
            if (f) {
              if (r > 0)
                while (s--) t[s] || u[s] || (u[s] = F.call(i));
              u = ua(u)
            }
            H.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i)
          }
          return k && (w = y, j = v), t
        };
      return c ? ha(f) : f
    }
    return h = fa.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = A[a + " "];
      if (!f) {
        b || (b = g(a)), c = b.length;
        while (c--) f = wa(b[c]), f[u] ? d.push(f) : e.push(f);
        f = A(a, xa(e, d)), f.selector = a
      }
      return f
    }, i = fa.select = function(a, b, e, f) {
      var i, j, k, l, m, n = "function" == typeof a && a,
        o = !f && g(a = n.selector || a);
      if (e = e || [], 1 === o.length) {
        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;
          n && (b = b.parentNode), a = a.slice(j.shift().value.length)
        }
        i = W.needsContext.test(a) ? 0 : j.length;
        while (i--) {
          if (k = j[i], d.relative[l = k.type]) break;
          if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {
            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;
            break
          }
        }
      }
      return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e
    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function(a) {
      return 1 & a.compareDocumentPosition(n.createElement("div"))
    }), ia(function(a) {
      return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
    }) || ja("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes && ia(function(a) {
      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || ja("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), ia(function(a) {
      return null == a.getAttribute("disabled")
    }) || ja(K, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
    }), fa
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = function(a, b, c) {
      var d = [],
        e = void 0 !== c;
      while ((a = a[b]) && 9 !== a.nodeType)
        if (1 === a.nodeType) {
          if (e && n(a).is(c)) break;
          d.push(a)
        } return d
    },
    v = function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
      return c
    },
    w = n.expr.match.needsContext,
    x = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
    y = /^.[^:#\[\.,]*$/;

  function z(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (y.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return h.call(b, a) > -1 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = this.length,
        d = [],
        e = this;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; c > b; b++)
          if (n.contains(e[b], this)) return !0
      }));
      for (b = 0; c > b; b++) n.find(a, e[b], d);
      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d
    },
    filter: function(a) {
      return this.pushStack(z(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(z(this, a || [], !0))
    },
    is: function(a) {
      return !!z(this, "string" == typeof a && w.test(a) ? n(a) : a || [], !1).length
    }
  });
  var A, B = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    C = n.fn.init = function(a, b, c) {
      var e, f;
      if (!a) return this;
      if (c = c || A, "string" == typeof a) {
        if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
        if (e[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b))
            for (e in b) n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);
          return this
        }
        return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  C.prototype = n.fn, A = n(d);
  var D = /^(?:parents|prev(?:Until|All))/,
    E = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.fn.extend({
    has: function(a) {
      var b = n(a, this),
        c = b.length;
      return this.filter(function() {
        for (var a = 0; c > a; a++)
          if (n.contains(this, b[a])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)
        for (c = this[d]; c && c !== b; c = c.parentNode)
          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          } return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function F(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b && 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return u(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return u(a, "parentNode", c)
    },
    next: function(a) {
      return F(a, "nextSibling")
    },
    prev: function(a) {
      return F(a, "previousSibling")
    },
    nextAll: function(a) {
      return u(a, "nextSibling")
    },
    prevAll: function(a) {
      return u(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return u(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return u(a, "previousSibling", c)
    },
    siblings: function(a) {
      return v((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return v(a.firstChild)
    },
    contents: function(a) {
      return a.contentDocument || n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e)
    }
  });
  var G = /\S+/g;

  function H(a) {
    var b = {};
    return n.each(a.match(G) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? H(a) : n.extend({}, a);
    var b, c, d, e, f = [],
      g = [],
      h = -1,
      i = function() {
        for (e = a.once, d = b = !0; g.length; h = -1) {
          c = g.shift();
          while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1)
        }
        a.memory || (c = !1), b = !1, e && (f = c ? [] : "")
      },
      j = {
        add: function() {
          return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {
            n.each(b, function(b, c) {
              n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== n.type(c) && d(c)
            })
          }(arguments), c && !b && i()), this
        },
        remove: function() {
          return n.each(arguments, function(a, b) {
            var c;
            while ((c = n.inArray(b, f, c)) > -1) f.splice(c, 1), h >= c && h--
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, f) > -1 : f.length > 0
        },
        empty: function() {
          return f && (f = []), this
        },
        disable: function() {
          return e = g = [], f = c = "", this
        },
        disabled: function() {
          return !f
        },
        lock: function() {
          return e = g = [], c || (f = c = ""), this
        },
        locked: function() {
          return !!e
        },
        fireWith: function(a, c) {
          return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this
        },
        fire: function() {
          return j.fireWith(this, arguments), this
        },
        fired: function() {
          return !!d
        }
      };
    return j
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) && a[b];
                e[f[1]](function() {
                  var a = g && g.apply(this, arguments);
                  a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h && g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a && a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = e.call(arguments),
        d = c.length,
        f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(d) {
            b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (d > 1)
        for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var I;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler("ready"), n(d).off("ready"))))
    }
  });

  function J() {
    d.removeEventListener("DOMContentLoaded", J), a.removeEventListener("load", J), n.ready()
  }
  n.ready.promise = function(b) {
    return I || (I = n.Deferred(), "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener("DOMContentLoaded", J), a.addEventListener("load", J))), I.promise(b)
  }, n.ready.promise();
  var K = function(a, b, c, d, e, f, g) {
      var h = 0,
        i = a.length,
        j = null == c;
      if ("object" === n.type(c)) {
        e = !0;
        for (h in c) K(a, b, h, c[h], !0, f, g)
      } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
          return j.call(n(a), c)
        })), b))
        for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
      return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
    },
    L = function(a) {
      return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
    };

  function M() {
    this.expando = n.expando + M.uid++
  }
  M.uid = 1, M.prototype = {
    register: function(a, b) {
      var c = b || {};
      return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, {
        value: c,
        writable: !0,
        configurable: !0
      }), a[this.expando]
    },
    cache: function(a) {
      if (!L(a)) return {};
      var b = a[this.expando];
      return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
        value: b,
        configurable: !0
      }))), b
    },
    set: function(a, b, c) {
      var d, e = this.cache(a);
      if ("string" == typeof b) e[b] = c;
      else
        for (d in b) e[d] = b[d];
      return e
    },
    get: function(a, b) {
      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b]
    },
    access: function(a, b, c) {
      var d;
      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)
    },
    remove: function(a, b) {
      var c, d, e, f = a[this.expando];
      if (void 0 !== f) {
        if (void 0 === b) this.register(a);
        else {
          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;
          while (c--) delete f[d[c]]
        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
      }
    },
    hasData: function(a) {
      var b = a[this.expando];
      return void 0 !== b && !n.isEmptyObject(b)
    }
  };
  var N = new M,
    O = new M,
    P = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    Q = /[A-Z]/g;

  function R(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType)
      if (d = "data-" + b.replace(Q, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : P.test(c) ? n.parseJSON(c) : c;
        } catch (e) {}
        O.set(a, b, c)
      } else c = void 0;
    return c
  }
  n.extend({
    hasData: function(a) {
      return O.hasData(a) || N.hasData(a)
    },
    data: function(a, b, c) {
      return O.access(a, b, c)
    },
    removeData: function(a, b) {
      O.remove(a, b)
    },
    _data: function(a, b, c) {
      return N.access(a, b, c)
    },
    _removeData: function(a, b) {
      N.remove(a, b)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f && f.attributes;
      if (void 0 === a) {
        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, "hasDataAttrs"))) {
          c = g.length;
          while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));
          N.set(f, "hasDataAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        O.set(this, a)
      }) : K(this, function(b) {
        var c, d;
        if (f && void 0 === b) {
          if (c = O.get(f, a) || O.get(f, a.replace(Q, "-$&").toLowerCase()), void 0 !== c) return c;
          if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;
          if (c = R(f, d, void 0), void 0 !== c) return c
        } else d = n.camelCase(a), this.each(function() {
          var c = O.get(this, d);
          O.set(this, d, b), a.indexOf("-") > -1 && void 0 !== c && O.set(this, a, b)
        })
      }, null, b, arguments.length > 1, null, !0)
    },
    removeData: function(a) {
      return this.each(function() {
        O.remove(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return N.get(a, c) || N.access(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          N.remove(a, [b + "queue", c])
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a && (b = a, a = void 0), a = a || "fx";
      while (g--) c = N.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    T = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"),
    U = ["Top", "Right", "Bottom", "Left"],
    V = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    };

  function W(a, b, c, d) {
    var e, f = 1,
      g = 20,
      h = d ? function() {
        return d.cur()
      } : function() {
        return n.css(a, b, "")
      },
      i = h(),
      j = c && c[3] || (n.cssNumber[b] ? "" : "px"),
      k = (n.cssNumber[b] || "px" !== j && +i) && T.exec(n.css(a, b));
    if (k && k[3] !== j) {
      j = j || k[3], c = c || [], k = +i || 1;
      do f = f || ".5", k /= f, n.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
    }
    return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
  }
  var X = /^(?:checkbox|radio)$/i,
    Y = /<([\w:-]+)/,
    Z = /^$|\/(?:java|ecma)script/i,
    $ = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
  $.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;

  function _(a, b) {
    var c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c
  }

  function aa(a, b) {
    for (var c = 0, d = a.length; d > c; c++) N.set(a[c], "globalEval", !b || N.get(b[c], "globalEval"))
  }
  var ba = /<|&#?\w+;/;

  function ca(a, b, c, d, e) {
    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++)
      if (f = a[o], f || 0 === f)
        if ("object" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);
        else if (ba.test(f)) {
      g = g || l.appendChild(b.createElement("div")), h = (Y.exec(f) || ["", ""])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];
      while (k--) g = g.lastChild;
      n.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
    } else m.push(b.createTextNode(f));
    l.textContent = "", o = 0;
    while (f = m[o++])
      if (d && n.inArray(f, d) > -1) e && e.push(f);
      else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), "script"), j && aa(g), c) {
      k = 0;
      while (f = g[k++]) Z.test(f.type || "") && c.push(f)
    }
    return l
  }! function() {
    var a = d.createDocumentFragment(),
      b = a.appendChild(d.createElement("div")),
      c = d.createElement("input");
    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
  }();
  var da = /^key/,
    ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    fa = /^([^.]*)(?:\.(.+)|)/;

  function ga() {
    return !0
  }

  function ha() {
    return !1
  }

  function ia() {
    try {
      return d.activeElement
    } catch (a) {}
  }

  function ja(a, b, c, d, e, f) {
    var g, h;
    if ("object" == typeof b) {
      "string" != typeof c && (d = d || c, c = void 0);
      for (h in b) ja(a, h, c, d, b[h], f);
      return a
    }
    if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;
    else if (!e) return a;
    return 1 === f && (g = e, e = function(a) {
      return n().off(a), g.apply(this, arguments)
    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function() {
      n.event.add(this, b, e, d, c)
    })
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = N.get(a);
      if (r) {
        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {
          return "undefined" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0
        }), b = (b || "").match(G) || [""], j = b.length;
        while (j--) h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e && n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0)
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = N.hasData(a) && N.get(a);
      if (r && (i = r.events)) {
        b = (b || "").match(G) || [""], j = b.length;
        while (j--)
          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
            while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o])
          } else
            for (o in i) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(i) && N.remove(a, "handle events")
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, d, f, g, h = [],
        i = e.call(arguments),
        j = (N.get(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) && !a.isPropagationStopped()) {
          a.currentTarget = f.elem, c = 0;
          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch && k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1))
        for (; i !== this; i = i.parentNode || this)
          if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
            for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);
            d.length && g.push({
              elem: i,
              handlers: d
            })
          } return h < b.length && g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, e, f, g = b.button;
        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a
      }
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, e, f = a.type,
        g = a,
        h = this.fixHooks[f];
      h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;
      while (b--) c = e[b], a[c] = g[c];
      return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          return this !== ia() && this.focus ? (this.focus(), !1) : void 0
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === ia() && this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
        }
      }
    }
  }, n.removeEvent = function(a, b, c) {
    a.removeEventListener && a.removeEventListener(b, c)
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    constructor: n.Event,
    isDefaultPrevented: ha,
    isPropagationStopped: ha,
    isImmediatePropagationStopped: ha,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = ga, a && a.preventDefault()
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = ga, a && a.stopPropagation()
    },
    stopImmediatePropagation: function() {
      var a = this.originalEvent;
      this.isImmediatePropagationStopped = ga, a && a.stopImmediatePropagation(), this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d) {
      return ja(this, a, b, c, d)
    },
    one: function(a, b, c, d) {
      return ja(this, a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    }
  });
  var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    la = /<script|<style|<link/i,
    ma = /checked\s*(?:[^=]|=\s*.checked.)/i,
    na = /^true\/(.*)/,
    oa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function pa(a, b) {
    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function qa(a) {
    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
  }

  function ra(a) {
    var b = na.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function sa(a, b) {
    var c, d, e, f, g, h, i, j;
    if (1 === b.nodeType) {
      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {
        delete g.handle, g.events = {};
        for (e in j)
          for (c = 0, d = j[e].length; d > c; c++) n.event.add(b, e, j[e][c])
      }
      O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i))
    }
  }

  function ta(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && X.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
  }

  function ua(a, b, c, d) {
    b = f.apply([], b);
    var e, g, h, i, j, k, m = 0,
      o = a.length,
      p = o - 1,
      q = b[0],
      r = n.isFunction(q);
    if (r || o > 1 && "string" == typeof q && !l.checkClone && ma.test(q)) return a.each(function(e) {
      var f = a.eq(e);
      r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d)
    });
    if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {
      for (h = n.map(_(e, "script"), qa), i = h.length; o > m; m++) j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, "script"))), c.call(a[m], j, m);
      if (i)
        for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) j = h[m], Z.test(j.type || "") && !N.access(j, "globalEval") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, "")))
    }
    return a
  }

  function va(a, b, c) {
    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, "script")), d.parentNode.removeChild(d));
    return a
  }
  n.extend({
    htmlPrefilter: function(a) {
      return a.replace(ka, "<$1></$2>")
    },
    clone: function(a, b, c) {
      var d, e, f, g, h = a.cloneNode(!0),
        i = n.contains(a.ownerDocument, a);
      if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))
        for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) ta(f[d], g[d]);
      if (b)
        if (c)
          for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) sa(f[d], g[d]);
        else sa(a, h);
      return g = _(h, "script"), g.length > 0 && aa(g, !i && _(a, "script")), h
    },
    cleanData: function(a) {
      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++)
        if (L(c)) {
          if (b = c[N.expando]) {
            if (b.events)
              for (d in b.events) e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
            c[N.expando] = void 0
          }
          c[O.expando] && (c[O.expando] = void 0)
        }
    }
  }), n.fn.extend({
    domManip: ua,
    detach: function(a) {
      return va(this, a, !0)
    },
    remove: function(a) {
      return va(this, a)
    },
    text: function(a) {
      return K(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().each(function() {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
        })
      }, null, a, arguments.length)
    },
    append: function() {
      return ua(this, arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = pa(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return ua(this, arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = pa(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return ua(this, arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return ua(this, arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = "");
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return K(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
        if ("string" == typeof a && !la.test(a) && !$[(Y.exec(a) || ["", ""])[1].toLowerCase()]) {
          a = n.htmlPrefilter(a);
          try {
            for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b && this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = [];
      return ua(this, arguments, function(b) {
        var c = this.parentNode;
        n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this))
      }, a)
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());
      return this.pushStack(d)
    }
  });
  var wa, xa = {
    HTML: "block",
    BODY: "block"
  };

  function ya(a, b) {
    var c = n(b.createElement(a)).appendTo(b.body),
      d = n.css(c[0], "display");
    return c.detach(), d
  }

  function za(a) {
    var b = d,
      c = xa[a];
    return c || (c = ya(a, b), "none" !== c && c || (wa = (wa || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c
  }
  var Aa = /^margin/,
    Ba = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"),
    Ca = function(b) {
      var c = b.ownerDocument.defaultView;
      return c && c.opener || (c = a), c.getComputedStyle(b)
    },
    Da = function(a, b, c, d) {
      var e, f, g = {};
      for (f in b) g[f] = a.style[f], a.style[f] = b[f];
      e = c.apply(a, d || []);
      for (f in b) a.style[f] = g[f];
      return e
    },
    Ea = d.documentElement;
  ! function() {
    var b, c, e, f, g = d.createElement("div"),
      h = d.createElement("div");
    if (h.style) {
      h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h);

      function i() {
        h.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Ea.appendChild(g);
        var d = a.getComputedStyle(h);
        b = "1%" !== d.top, f = "2px" === d.marginLeft, c = "4px" === d.width, h.style.marginRight = "50%", e = "4px" === d.marginRight, Ea.removeChild(g)
      }
      n.extend(l, {
        pixelPosition: function() {
          return i(), b
        },
        boxSizingReliable: function() {
          return null == c && i(), c
        },
        pixelMarginRight: function() {
          return null == c && i(), e
        },
        reliableMarginLeft: function() {
          return null == c && i(), f
        },
        reliableMarginRight: function() {
          var b, c = h.appendChild(d.createElement("div"));
          return c.style.cssText = h.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", h.style.width = "1px", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b
        }
      })
    }
  }();

  function Fa(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + "" : g
  }

  function Ga(a, b) {
    return {
      get: function() {
        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }
  var Ha = /^(none|table(?!-c[ea]).+)/,
    Ia = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Ja = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    Ka = ["Webkit", "O", "Moz", "ms"],
    La = d.createElement("div").style;

  function Ma(a) {
    if (a in La) return a;
    var b = a[0].toUpperCase() + a.slice(1),
      c = Ka.length;
    while (c--)
      if (a = Ka[c] + b, a in La) return a
  }

  function Na(a, b, c) {
    var d = T.exec(b);
    return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
  }

  function Oa(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g
  }

  function Pa(b, c, e) {
    var f = !0,
      g = "width" === c ? b.offsetWidth : b.offsetHeight,
      h = Ca(b),
      i = "border-box" === n.css(b, "boxSizing", !1, h);
    if (d.msFullscreenElement && a.top !== a && b.getClientRects().length && (g = Math.round(100 * b.getBoundingClientRect()[c])), 0 >= g || null == g) {
      if (g = Fa(b, c, h), (0 > g || null == g) && (g = b.style[c]), Ba.test(g)) return g;
      f = i && (l.boxSizingReliable() || g === b.style[c]), g = parseFloat(g) || 0
    }
    return g + Oa(b, c, e || (i ? "border" : "content"), f, h) + "px"
  }

  function Qa(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = N.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && V(d) && (f[g] = N.access(d, "olddisplay", za(d.nodeName)))) : (e = V(d), "none" === c && e || N.set(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = Fa(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function(a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (n.cssNumber[h] ? "" : "px")), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0)
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), "normal" === e && b in Ja && (e = Ja[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? Ha.test(n.css(a, "display")) && 0 === a.offsetWidth ? Da(a, Ia, function() {
          return Pa(a, b, d)
        }) : Pa(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e, f = d && Ca(a),
          g = d && Oa(a, b, d, "border-box" === n.css(a, "boxSizing", !1, f), f);
        return g && (e = T.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g)
      }
    }
  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function(a, b) {
    return b ? (parseFloat(Fa(a, "marginLeft")) || a.getBoundingClientRect().left - Da(a, {
      marginLeft: 0
    }, function() {
      return a.getBoundingClientRect().left
    })) + "px" : void 0
  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function(a, b) {
    return b ? Da(a, {
      display: "inline-block"
    }, Fa, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, Aa.test(a) || (n.cssHooks[a + b].set = Na)
  }), n.fn.extend({
    css: function(a, b) {
      return K(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = Ca(a), e = b.length; e > g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length > 1)
    },
    show: function() {
      return Qa(this, !0)
    },
    hide: function() {
      return Qa(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function Ra(a, b, c, d, e) {
    return new Ra.prototype.init(a, b, c, d, e)
  }
  n.Tween = Ra, Ra.prototype = {
    constructor: Ra,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = Ra.propHooks[this.prop];
      return a && a.get ? a.get(this) : Ra.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = Ra.propHooks[this.prop];
      return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this
    }
  }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit)
      }
    }
  }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    },
    _default: "swing"
  }, n.fx = Ra.prototype.init, n.fx.step = {};
  var Sa, Ta, Ua = /^(?:toggle|show|hide)$/,
    Va = /queueHooks$/;

  function Wa() {
    return a.setTimeout(function() {
      Sa = void 0
    }), Sa = n.now()
  }

  function Xa(a, b) {
    var c, d = 0,
      e = {
        height: a
      };
    for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = U[d], e["margin" + c] = e["padding" + c] = a;
    return b && (e.opacity = e.width = a), e
  }

  function Ya(a, b, c) {
    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners["*"]), f = 0, g = e.length; g > f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function Za(a, b, c) {
    var d, e, f, g, h, i, j, k, l = this,
      m = {},
      o = a.style,
      p = a.nodeType && V(a),
      q = N.get(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, l.always(function() {
      l.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? N.get(a, "olddisplay") || za(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function() {
      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], Ua.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
          if ("show" !== e || !q || void 0 === q[d]) continue;
          p = !0
        }
        m[d] = q && q[d] || n.style(a, d)
      } else j = void 0;
    if (n.isEmptyObject(m)) "inline" === ("none" === j ? za(a.nodeName) : j) && (o.display = j);
    else {
      q ? "hidden" in q && (p = q.hidden) : q = N.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function() {
        n(a).hide()
      }), l.done(function() {
        var b;
        N.remove(a, "fxshow");
        for (b in m) n.style(a, b, m[b])
      });
      for (d in m) g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function $a(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function _a(a, b, c) {
    var d, e, f = 0,
      g = _a.prefilters.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {},
          easing: n.easing._default
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: Sa || Wa(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d > c; c++) j.tweens[c].run(1);
          return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for ($a(k, j.opts.specialEasing); g > f; f++)
      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;
    return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(_a, {
      tweeners: {
        "*": [function(a, b) {
          var c = this.createTween(a, b);
          return W(c.elem, a, T.exec(b), c), c
        }]
      },
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(G);
        for (var c, d = 0, e = a.length; e > d; d++) c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b)
      },
      prefilters: [Za],
      prefilter: function(a, b) {
        b ? _a.prefilters.unshift(a) : _a.prefilters.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a && "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c && b || n.isFunction(a) && a,
        duration: a,
        easing: c && b || b && !n.isFunction(b) && b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(V).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = _a(this, n.extend({}, a), f);
            (e || N.get(this, "finish")) && b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a && a + "queueHooks",
            f = n.timers,
            g = N.get(this);
          if (e) g[e] && g[e].stop && d(g[e]);
          else
            for (e in g) g[e] && g[e].stop && Va.test(e) && d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          !b && c || n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 && (a = a || "fx"), this.each(function() {
          var b, c = N.get(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: Xa("show"),
      slideUp: Xa("hide"),
      slideToggle: Xa("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = 0,
        c = n.timers;
      for (Sa = n.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
      c.length || n.fx.stop(), Sa = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      a.clearInterval(Ta), Ta = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(b, c) {
      return b = n.fx ? n.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
        var e = a.setTimeout(c, b);
        d.stop = function() {
          a.clearTimeout(e)
        }
      })
    },
    function() {
      var a = d.createElement("input"),
        b = d.createElement("select"),
        c = b.appendChild(d.createElement("option"));
      a.type = "checkbox", l.checkOn = "" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement("input"), a.value = "t", a.type = "radio", l.radioValue = "t" === a.value
    }();
  var ab, bb = n.expr.attrHandle;
  n.fn.extend({
    attr: function(a, b) {
      return K(this, n.attr, a, b, arguments.length > 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d))
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c && (a.value = c), b
          }
        }
      }
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b && b.match(G);
      if (f && 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)
    }
  }), ab = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = bb[b] || n.find.attr;
    bb[b] = function(a, b, d) {
      var e, f;
      return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e
    }
  });
  var cb = /^(?:input|select|textarea|button)$/i,
    db = /^(?:a|area)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return K(this, n.prop, a, b, arguments.length > 1)
    },
    removeProp: function(a) {
      return this.each(function() {
        delete this[n.propFix[a] || a]
      })
    }
  }), n.extend({
    prop: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b,
        e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          var b = n.find.attr(a, "tabindex");
          return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }), l.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b && b.parentNode && b.parentNode.selectedIndex, null
    },
    set: function(a) {
      var b = a.parentNode;
      b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  });
  var eb = /[\t\r\n\f]/g;

  function fb(a) {
    return a.getAttribute && a.getAttribute("class") || ""
  }
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h, i = 0;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, fb(this)))
      });
      if ("string" == typeof a && a) {
        b = a.match(G) || [];
        while (c = this[i++])
          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {
            g = 0;
            while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
            h = n.trim(d), e !== h && c.setAttribute("class", h)
          }
      }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h, i = 0;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, fb(this)))
      });
      if (!arguments.length) return this.attr("class", "");
      if ("string" == typeof a && a) {
        b = a.match(G) || [];
        while (c = this[i++])
          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {
            g = 0;
            while (f = b[g++])
              while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " ");
            h = n.trim(d), e !== h && c.setAttribute("class", h)
          }
      }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function(c) {
        n(this).toggleClass(a.call(this, c, fb(this), b), b)
      }) : this.each(function() {
        var b, d, e, f;
        if ("string" === c) {
          d = 0, e = n(this), f = a.match(G) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else void 0 !== a && "boolean" !== c || (b = fb(this), b && N.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : N.get(this, "__className__") || ""))
      })
    },
    hasClass: function(a) {
      var b, c, d = 0;
      b = " " + a + " ";
      while (c = this[d++])
        if (1 === c.nodeType && (" " + fb(c) + " ").replace(eb, " ").indexOf(b) > -1) return !0;
      return !1
    }
  });
  var gb = /\r/g,
    hb = /[\x20\t\r\n\f]+/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(gb, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.trim(n.text(a)).replace(hb, " ")
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            } return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--) d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);
          return c || (a.selectedIndex = -1), f
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0
      }
    }, l.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  });
  var ib = /^(?:focusinfocus|focusoutblur)$/;
  n.extend(n.event, {
    trigger: function(b, c, e, f) {
      var g, h, i, j, l, m, o, p = [e || d],
        q = k.call(b, "type") ? b.type : b,
        r = k.call(b, "namespace") ? b.namespace.split(".") : [];
      if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(".") > -1 && (r = q.split("."), q = r.shift(), r.sort()), l = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {
        if (!f && !o.noBubble && !n.isWindow(e)) {
          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) p.push(h), i = h;
          i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a)
        }
        g = 0;
        while ((h = p[g++]) && !b.isPropagationStopped()) b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, "events") || {})[b.type] && N.get(h, "handle"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());
        return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result
      }
    },
    simulate: function(a, b, c) {
      var d = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0
      });
      n.event.trigger(d, null, b), d.isDefaultPrevented() && c.preventDefault()
    }
  }), n.fn.extend({
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    }
  }), l.focusin = "onfocusin" in a, l.focusin || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a))
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = N.access(d, b);
        e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = N.access(d, b) - 1;
        e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b))
      }
    }
  });
  var jb = a.location,
    kb = n.now(),
    lb = /\?/;
  n.parseJSON = function(a) {
    return JSON.parse(a + "")
  }, n.parseXML = function(b) {
    var c;
    if (!b || "string" != typeof b) return null;
    try {
      c = (new a.DOMParser).parseFromString(b, "text/xml")
    } catch (d) {
      c = void 0
    }
    return c && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c
  };
  var mb = /#.*$/,
    nb = /([?&])_=[^&]*/,
    ob = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    qb = /^(?:GET|HEAD)$/,
    rb = /^\/\//,
    sb = {},
    tb = {},
    ub = "*/".concat("*"),
    vb = d.createElement("a");
  vb.href = jb.href;

  function wb(a) {
    return function(b, c) {
      "string" != typeof b && (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(G) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function xb(a, b, c, d) {
    var e = {},
      f = a === tb;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] && g("*")
  }

  function yb(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
    return d && n.extend(!0, a, d), a
  }

  function zb(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
    if (d)
      for (e in h)
        if (h[e] && h[e].test(d)) {
          i.unshift(e);
          break
        } if (i[0] in c) f = i[0];
    else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break
        }
        g || (g = e)
      }
      f = f || g
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
  }

  function Ab(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i && i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
            break
          } if (g !== !0)
        if (g && a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: jb.href,
      type: "GET",
      isLocal: pb.test(jb.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": ub,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a)
    },
    ajaxPrefilter: wb(sb),
    ajaxTransport: wb(tb),
    ajax: function(b, c) {
      "object" == typeof b && (c = b, b = void 0), c = c || {};
      var e, f, g, h, i, j, k, l, m = n.ajaxSetup({}, c),
        o = m.context || m,
        p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,
        q = n.Deferred(),
        r = n.Callbacks("once memory"),
        s = m.statusCode || {},
        t = {},
        u = {},
        v = 0,
        w = "canceled",
        x = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === v) {
              if (!h) {
                h = {};
                while (b = ob.exec(g)) h[b[1].toLowerCase()] = b[2]
              }
              b = h[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === v ? g : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return v || (a = u[c] = u[c] || a, t[a] = b), this
          },
          overrideMimeType: function(a) {
            return v || (m.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 > v)
                for (b in a) s[b] = [s[b], a[b]];
              else x.always(a[x.status]);
            return this
          },
          abort: function(a) {
            var b = a || w;
            return e && e.abort(b), z(0, b), this
          }
        };
      if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + "").replace(mb, "").replace(rb, jb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || "*").toLowerCase().match(G) || [""], null == m.crossDomain) {
        j = d.createElement("a");
        try {
          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + "//" + vb.host != j.protocol + "//" + j.host
        } catch (y) {
          m.crossDomain = !0
        }
      }
      if (m.data && m.processData && "string" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;
      k = n.event && m.global, k && 0 === n.active++ && n.event.trigger("ajaxStart"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? "&" : "?") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, "$1_=" + kb++) : f + (lb.test(f) ? "&" : "?") + "_=" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader("If-Modified-Since", n.lastModified[f]), n.etag[f] && x.setRequestHeader("If-None-Match", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader("Content-Type", m.contentType), x.setRequestHeader("Accept", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + ("*" !== m.dataTypes[0] ? ", " + ub + "; q=0.01" : "") : m.accepts["*"]);
      for (l in m.headers) x.setRequestHeader(l, m.headers[l]);
      if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();
      w = "abort";
      for (l in {
          success: 1,
          error: 1,
          complete: 1
        }) x[l](m[l]);
      if (e = xb(tb, m, c, x)) {
        if (x.readyState = 1, k && p.trigger("ajaxSend", [x, m]), 2 === v) return x;
        m.async && m.timeout > 0 && (i = a.setTimeout(function() {
          x.abort("timeout")
        }, m.timeout));
        try {
          v = 1, e.send(t, z)
        } catch (y) {
          if (!(2 > v)) throw y;
          z(-1, y)
        }
      } else z(-1, "No Transport");

      function z(b, c, d, h) {
        var j, l, t, u, w, y = c;
        2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader("Last-Modified"), w && (n.lastModified[f] = w), w = x.getResponseHeader("etag"), w && (n.etag[f] = w)), 204 === b || "HEAD" === m.type ? y = "nocontent" : 304 === b ? y = "notmodified" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = "error", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + "", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? "ajaxSuccess" : "ajaxError", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger("ajaxComplete", [x, m]), --n.active || n.event.trigger("ajaxStop")))
      }
      return x
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      }, n.isPlainObject(a) && a))
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      var b;
      return n.isFunction(a) ? this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
        var a = this;
        while (a.firstElementChild) a = a.firstElementChild;
        return a
      }).append(this)), this)
    },
    wrapInner: function(a) {
      return n.isFunction(a) ? this.each(function(b) {
        n(this).wrapInner(a.call(this, b))
      }) : this.each(function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return !n.expr.filters.visible(a)
  }, n.expr.filters.visible = function(a) {
    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0
  };
  var Bb = /%20/g,
    Cb = /\[\]$/,
    Db = /\r?\n/g,
    Eb = /^(?:submit|button|image|reset|file)$/i,
    Fb = /^(?:input|select|textarea|keygen)/i;

  function Gb(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || Cb.test(a) ? d(a, e) : Gb(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Gb(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Gb(c, a[c], b, e);
    return d.join("&").replace(Bb, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name && !n(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Db, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(Db, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = function() {
    try {
      return new a.XMLHttpRequest
    } catch (b) {}
  };
  var Hb = {
      0: 200,
      1223: 204
    },
    Ib = n.ajaxSettings.xhr();
  l.cors = !!Ib && "withCredentials" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function(b) {
    var c, d;
    return l.cors || Ib && !b.crossDomain ? {
      send: function(e, f) {
        var g, h = b.xhr();
        if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
          for (g in b.xhrFields) h[g] = b.xhrFields[g];
        b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
        for (g in e) h.setRequestHeader(g, e[g]);
        c = function(a) {
          return function() {
            c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
              binary: h.response
            } : {
              text: h.responseText
            }, h.getAllResponseHeaders()))
          }
        }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
          4 === h.readyState && a.setTimeout(function() {
            c && d()
          })
        }, c = c("abort");
        try {
          h.send(b.hasContent && b.data || null)
        } catch (i) {
          if (c) throw i
        }
      },
      abort: function() {
        c && c()
      }
    } : void 0
  }), n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c;
      return {
        send: function(e, f) {
          b = n("<script>").prop({
            charset: a.scriptCharset,
            src: a.url
          }).on("load error", c = function(a) {
            b.remove(), c = null, a && f("error" === a.type ? 404 : 200, a.type)
          }), d.head.appendChild(b[0])
        },
        abort: function() {
          c && c()
        }
      }
    }
  });
  var Jb = [],
    Kb = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = Jb.pop() || n.expando + "_" + kb++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 && (Kb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Kb.test(b.data) && "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, "$1" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b && (c = b, b = !1), b = b || d;
    var e = x.exec(a),
      f = !c && [];
    return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes))
  };
  var Lb = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a && Lb) return Lb.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
      url: a,
      type: e || "GET",
      dataType: "html",
      data: b
    }).done(function(a) {
      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a)
    }).always(c && function(a, b) {
      g.each(function() {
        c.apply(this, f || [a.responseText, b, a])
      })
    }), this
  }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };

  function Mb(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = this[0],
        e = {
          top: 0,
          left: 0
        },
        f = d && d.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), {
        top: e.top + c.pageYOffset - b.clientTop,
        left: e.left + c.pageXOffset - b.clientLeft
      }) : e
    },
    position: function() {
      if (this[0]) {
        var a, b, c = this[0],
          d = {
            top: 0,
            left: 0
          };
        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - d.top - n.css(c, "marginTop", !0),
          left: b.left - d.left - n.css(c, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent;
        while (a && "static" === n.css(a, "position")) a = a.offsetParent;
        return a || Ea
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(a, b) {
    var c = "pageYOffset" === b;
    n.fn[a] = function(d) {
      return K(this, function(a, d, e) {
        var f = Mb(a);
        return void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
      }, a, d, arguments.length)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = Ga(l.pixelPosition, function(a, c) {
      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length && (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return K(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.extend({
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    },
    size: function() {
      return this.length
    }
  }), n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
    return n
  });
  var Nb = a.jQuery,
    Ob = a.$;
  return n.noConflict = function(b) {
    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n
  }, b || (a.jQuery = a.$ = n), n
});
/*! RESOURCE: /scripts/lib/jquery/jquery_no_conflict.js */
(function() {
  if (window.$j_glide) {
    jQuery.noConflict(true);
    window.jQuery = $j_glide;
  }
  window.$j = window.$j_glide = jQuery.noConflict();
})();;;
/*! RESOURCE: /scripts/reportlibs/json2.js */
if (typeof JSON !== 'object') {
  JSON = {};
}
(function() {
  'use strict';

  function f(n) {
    return n < 10 ? '0' + n : n;
  }
  if (typeof Date.prototype.toJSON !== 'function') {
    Date.prototype.toJSON = function(key) {
      return isFinite(this.valueOf()) ?
        this.getUTCFullYear() + '-' +
        f(this.getUTCMonth() + 1) + '-' +
        f(this.getUTCDate()) + 'T' +
        f(this.getUTCHours()) + ':' +
        f(this.getUTCMinutes()) + ':' +
        f(this.getUTCSeconds()) + 'Z' :
        null;
    };
    String.prototype.toJSON =
      Number.prototype.toJSON =
      Boolean.prototype.toJSON = function(key) {
        return this.valueOf();
      };
  }
  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '\\': '\\\\'
    },
    rep;

  function quote(string) {
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
      var c = meta[a];
      return typeof c === 'string' ?
        c :
        '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
  }

  function str(key, holder) {
    var i,
      k,
      v,
      length,
      mind = gap,
      partial,
      value = holder[key];
    if (value && typeof value === 'object' &&
      typeof value.toJSON === 'function') {
      value = value.toJSON(key);
    }
    if (typeof rep === 'function') {
      value = rep.call(holder, key, value);
    }
    switch (typeof value) {
      case 'string':
        return quote(value);
      case 'number':
        return isFinite(value) ? String(value) : 'null';
      case 'boolean':
      case 'null':
        return String(value);
      case 'object':
        if (!value) {
          return 'null';
        }
        gap += indent;
        partial = [];
        if (Object.prototype.toString.apply(value) === '[object Array]') {
          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || 'null';
          }
          v = partial.length === 0 ?
            '[]' :
            gap ?
            '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
            '[' + partial.join(',') + ']';
          gap = mind;
          return v;
        }
        if (rep && typeof rep === 'object') {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === 'string') {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        } else {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        }
        v = partial.length === 0 ?
          '{}' :
          gap ?
          '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
          '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
  }
  if (typeof JSON.stringify !== 'function') {
    JSON.stringify = function(value, replacer, space) {
      var i;
      gap = '';
      indent = '';
      if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
          indent += ' ';
        }
      } else if (typeof space === 'string') {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
        (typeof replacer !== 'object' ||
          typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
      }
      return str('', {
        '': value
      });
    };
  }
  if (typeof JSON.parse !== 'function') {
    JSON.parse = function(text, reviver) {
      var j;

      function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = walk(value, k);
              if (v !== undefined) {
                value[k] = v;
              } else {
                delete value[k];
              }
            }
          }
        }
        return reviver.call(holder, key, value);
      }
      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
        text = text.replace(cx, function(a) {
          return '\\u' +
            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        });
      }
      if (/^[\],:{}\s]*$/
        .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
          .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
          .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        j = eval('(' + text + ')');
        return typeof reviver === 'function' ?
          walk({
            '': j
          }, '') :
          j;
      }
      throw new SyntaxError('JSON.parse');
    };
  }
}());;
/*! RESOURCE: /scripts/reportlibs/moment.min.js */
! function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.moment = t()
}(this, function() {
  "use strict";

  function e() {
    return Qe.apply(null, arguments)
  }

  function t(e) {
    return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
  }

  function n(e) {
    return null != e && "[object Object]" === Object.prototype.toString.call(e)
  }

  function s(e) {
    return void 0 === e
  }

  function i(e) {
    return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
  }

  function r(e) {
    return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
  }

  function a(e, t) {
    var n, s = [];
    for (n = 0; n < e.length; ++n) s.push(t(e[n], n));
    return s
  }

  function o(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
  }

  function u(e, t) {
    for (var n in t) o(t, n) && (e[n] = t[n]);
    return o(t, "toString") && (e.toString = t.toString), o(t, "valueOf") && (e.valueOf = t.valueOf), e
  }

  function l(e, t, n, s) {
    return ge(e, t, n, s, !0).utc()
  }

  function d(e) {
    return null == e._pf && (e._pf = {
      empty: !1,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: !1,
      invalidMonth: null,
      invalidFormat: !1,
      userInvalidated: !1,
      iso: !1,
      parsedDateParts: [],
      meridiem: null,
      rfc2822: !1,
      weekdayMismatch: !1
    }), e._pf
  }

  function h(e) {
    if (null == e._isValid) {
      var t = d(e),
        n = Xe.call(t.parsedDateParts, function(e) {
          return null != e
        }),
        s = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n);
      if (e._strict && (s = s && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return s;
      e._isValid = s
    }
    return e._isValid
  }

  function c(e) {
    var t = l(NaN);
    return null != e ? u(d(t), e) : d(t).userInvalidated = !0, t
  }

  function f(e, t) {
    var n, i, r;
    if (s(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), s(t._i) || (e._i = t._i), s(t._f) || (e._f = t._f), s(t._l) || (e._l = t._l), s(t._strict) || (e._strict = t._strict), s(t._tzm) || (e._tzm = t._tzm), s(t._isUTC) || (e._isUTC = t._isUTC), s(t._offset) || (e._offset = t._offset), s(t._pf) || (e._pf = d(t)), s(t._locale) || (e._locale = t._locale), Ke.length > 0)
      for (n = 0; n < Ke.length; n++) s(r = t[i = Ke[n]]) || (e[i] = r);
    return e
  }

  function m(t) {
    f(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === et && (et = !0, e.updateOffset(this), et = !1)
  }

  function _(e) {
    return e instanceof m || null != e && null != e._isAMomentObject
  }

  function y(e) {
    return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
  }

  function g(e) {
    var t = +e,
      n = 0;
    return 0 !== t && isFinite(t) && (n = y(t)), n
  }

  function p(e, t, n) {
    var s, i = Math.min(e.length, t.length),
      r = Math.abs(e.length - t.length),
      a = 0;
    for (s = 0; s < i; s++)(n && e[s] !== t[s] || !n && g(e[s]) !== g(t[s])) && a++;
    return a + r
  }

  function w(t) {
    !1 === e.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
  }

  function v(t, n) {
    var s = !0;
    return u(function() {
      if (null != e.deprecationHandler && e.deprecationHandler(null, t), s) {
        for (var i, r = [], a = 0; a < arguments.length; a++) {
          if (i = "", "object" == typeof arguments[a]) {
            i += "\n[" + a + "] ";
            for (var o in arguments[0]) i += o + ": " + arguments[0][o] + ", ";
            i = i.slice(0, -2)
          } else i = arguments[a];
          r.push(i)
        }
        w(t + "\nArguments: " + Array.prototype.slice.call(r).join("") + "\n" + (new Error).stack), s = !1
      }
      return n.apply(this, arguments)
    }, n)
  }

  function M(t, n) {
    null != e.deprecationHandler && e.deprecationHandler(t, n), tt[t] || (w(n), tt[t] = !0)
  }

  function S(e) {
    return e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
  }

  function D(e, t) {
    var s, i = u({}, e);
    for (s in t) o(t, s) && (n(e[s]) && n(t[s]) ? (i[s] = {}, u(i[s], e[s]), u(i[s], t[s])) : null != t[s] ? i[s] = t[s] : delete i[s]);
    for (s in e) o(e, s) && !o(t, s) && n(e[s]) && (i[s] = u({}, i[s]));
    return i
  }

  function k(e) {
    null != e && this.set(e)
  }

  function Y(e, t) {
    var n = e.toLowerCase();
    st[n] = st[n + "s"] = st[t] = e
  }

  function O(e) {
    return "string" == typeof e ? st[e] || st[e.toLowerCase()] : void 0
  }

  function T(e) {
    var t, n, s = {};
    for (n in e) o(e, n) && (t = O(n)) && (s[t] = e[n]);
    return s
  }

  function x(e, t) {
    it[e] = t
  }

  function b(e, t, n) {
    var s = "" + Math.abs(e),
      i = t - s.length;
    return (e >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + s
  }

  function P(e, t, n, s) {
    var i = s;
    "string" == typeof s && (i = function() {
      return this[s]()
    }), e && (ut[e] = i), t && (ut[t[0]] = function() {
      return b(i.apply(this, arguments), t[1], t[2])
    }), n && (ut[n] = function() {
      return this.localeData().ordinal(i.apply(this, arguments), e)
    })
  }

  function W(e) {
    return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "")
  }

  function H(e, t) {
    return e.isValid() ? (t = R(t, e.localeData()), ot[t] = ot[t] || function(e) {
      var t, n, s = e.match(rt);
      for (t = 0, n = s.length; t < n; t++) ut[s[t]] ? s[t] = ut[s[t]] : s[t] = W(s[t]);
      return function(t) {
        var i, r = "";
        for (i = 0; i < n; i++) r += S(s[i]) ? s[i].call(t, e) : s[i];
        return r
      }
    }(t), ot[t](e)) : e.localeData().invalidDate()
  }

  function R(e, t) {
    function n(e) {
      return t.longDateFormat(e) || e
    }
    var s = 5;
    for (at.lastIndex = 0; s >= 0 && at.test(e);) e = e.replace(at, n), at.lastIndex = 0, s -= 1;
    return e
  }

  function C(e, t, n) {
    Yt[e] = S(t) ? t : function(e, s) {
      return e && n ? n : t
    }
  }

  function F(e, t) {
    return o(Yt, e) ? Yt[e](t._strict, t._locale) : new RegExp(function(e) {
      return U(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e, t, n, s, i) {
        return t || n || s || i
      }))
    }(e))
  }

  function U(e) {
    return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
  }

  function L(e, t) {
    var n, s = t;
    for ("string" == typeof e && (e = [e]), i(t) && (s = function(e, n) {
        n[t] = g(e)
      }), n = 0; n < e.length; n++) Ot[e[n]] = s
  }

  function N(e, t) {
    L(e, function(e, n, s, i) {
      s._w = s._w || {}, t(e, s._w, s, i)
    })
  }

  function G(e, t, n) {
    null != t && o(Ot, e) && Ot[e](t, n._a, n, e)
  }

  function V(e) {
    return E(e) ? 366 : 365
  }

  function E(e) {
    return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
  }

  function I(t, n) {
    return function(s) {
      return null != s ? (j(this, t, s), e.updateOffset(this, n), this) : A(this, t)
    }
  }

  function A(e, t) {
    return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
  }

  function j(e, t, n) {
    e.isValid() && !isNaN(n) && ("FullYear" === t && E(e.year()) && 1 === e.month() && 29 === e.date() ? e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), Z(n, e.month())) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
  }

  function Z(e, t) {
    if (isNaN(e) || isNaN(t)) return NaN;
    var n = function(e, t) {
      return (e % t + t) % t
    }(t, 12);
    return e += (t - n) / 12, 1 === n ? E(e) ? 29 : 28 : 31 - n % 7 % 2
  }

  function z(e, t) {
    var n;
    if (!e.isValid()) return e;
    if ("string" == typeof t)
      if (/^\d+$/.test(t)) t = g(t);
      else if (t = e.localeData().monthsParse(t), !i(t)) return e;
    return n = Math.min(e.date(), Z(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
  }

  function $(t) {
    return null != t ? (z(this, t), e.updateOffset(this, !0), this) : A(this, "Month")
  }

  function q() {
    function e(e, t) {
      return t.length - e.length
    }
    var t, n, s = [],
      i = [],
      r = [];
    for (t = 0; t < 12; t++) n = l([2e3, t]), s.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
    for (s.sort(e), i.sort(e), r.sort(e), t = 0; t < 12; t++) s[t] = U(s[t]), i[t] = U(i[t]);
    for (t = 0; t < 24; t++) r[t] = U(r[t]);
    this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i")
  }

  function J(e) {
    var t = new Date(Date.UTC.apply(null, arguments));
    return e < 100 && e >= 0 && isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e), t
  }

  function B(e, t, n) {
    var s = 7 + t - n;
    return -((7 + J(e, 0, s).getUTCDay() - t) % 7) + s - 1
  }

  function Q(e, t, n, s, i) {
    var r, a, o = 1 + 7 * (t - 1) + (7 + n - s) % 7 + B(e, s, i);
    return o <= 0 ? a = V(r = e - 1) + o : o > V(e) ? (r = e + 1, a = o - V(e)) : (r = e, a = o), {
      year: r,
      dayOfYear: a
    }
  }

  function X(e, t, n) {
    var s, i, r = B(e.year(), t, n),
      a = Math.floor((e.dayOfYear() - r - 1) / 7) + 1;
    return a < 1 ? s = a + K(i = e.year() - 1, t, n) : a > K(e.year(), t, n) ? (s = a - K(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = a), {
      week: s,
      year: i
    }
  }

  function K(e, t, n) {
    var s = B(e, t, n),
      i = B(e + 1, t, n);
    return (V(e) - s + i) / 7
  }

  function ee() {
    function e(e, t) {
      return t.length - e.length
    }
    var t, n, s, i, r, a = [],
      o = [],
      u = [],
      d = [];
    for (t = 0; t < 7; t++) n = l([2e3, 1]).day(t), s = this.weekdaysMin(n, ""), i = this.weekdaysShort(n, ""), r = this.weekdays(n, ""), a.push(s), o.push(i), u.push(r), d.push(s), d.push(i), d.push(r);
    for (a.sort(e), o.sort(e), u.sort(e), d.sort(e), t = 0; t < 7; t++) o[t] = U(o[t]), u[t] = U(u[t]), d[t] = U(d[t]);
    this._weekdaysRegex = new RegExp("^(" + d.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
  }

  function te() {
    return this.hours() % 12 || 12
  }

  function ne(e, t) {
    P(e, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), t)
    })
  }

  function se(e, t) {
    return t._meridiemParse
  }

  function ie(e) {
    return e ? e.toLowerCase().replace("_", "-") : e
  }

  function re(e) {
    var t = null;
    if (!Xt[e] && "undefined" != typeof module && module && module.exports) try {
      t = Jt._abbr;
      require("./locale/" + e), ae(t)
    } catch (e) {}
    return Xt[e]
  }

  function ae(e, t) {
    var n;
    return e && (n = s(t) ? ue(e) : oe(e, t)) && (Jt = n), Jt._abbr
  }

  function oe(e, t) {
    if (null !== t) {
      var n = Qt;
      if (t.abbr = e, null != Xt[e]) M("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = Xt[e]._config;
      else if (null != t.parentLocale) {
        if (null == Xt[t.parentLocale]) return Kt[t.parentLocale] || (Kt[t.parentLocale] = []), Kt[t.parentLocale].push({
          name: e,
          config: t
        }), null;
        n = Xt[t.parentLocale]._config
      }
      return Xt[e] = new k(D(n, t)), Kt[e] && Kt[e].forEach(function(e) {
        oe(e.name, e.config)
      }), ae(e), Xt[e]
    }
    return delete Xt[e], null
  }

  function ue(e) {
    var n;
    if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return Jt;
    if (!t(e)) {
      if (n = re(e)) return n;
      e = [e]
    }
    return function(e) {
      for (var t, n, s, i, r = 0; r < e.length;) {
        for (t = (i = ie(e[r]).split("-")).length, n = (n = ie(e[r + 1])) ? n.split("-") : null; t > 0;) {
          if (s = re(i.slice(0, t).join("-"))) return s;
          if (n && n.length >= t && p(i, n, !0) >= t - 1) break;
          t--
        }
        r++
      }
      return null
    }(e)
  }

  function le(e) {
    var t, n = e._a;
    return n && -2 === d(e).overflow && (t = n[xt] < 0 || n[xt] > 11 ? xt : n[bt] < 1 || n[bt] > Z(n[Tt], n[xt]) ? bt : n[Pt] < 0 || n[Pt] > 24 || 24 === n[Pt] && (0 !== n[Wt] || 0 !== n[Ht] || 0 !== n[Rt]) ? Pt : n[Wt] < 0 || n[Wt] > 59 ? Wt : n[Ht] < 0 || n[Ht] > 59 ? Ht : n[Rt] < 0 || n[Rt] > 999 ? Rt : -1, d(e)._overflowDayOfYear && (t < Tt || t > bt) && (t = bt), d(e)._overflowWeeks && -1 === t && (t = Ct), d(e)._overflowWeekday && -1 === t && (t = Ft), d(e).overflow = t), e
  }

  function de(e, t, n) {
    return null != e ? e : null != t ? t : n
  }

  function he(t) {
    var n, s, i, r, a, o = [];
    if (!t._d) {
      for (i = function(t) {
          var n = new Date(e.now());
          return t._useUTC ? [n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate()] : [n.getFullYear(), n.getMonth(), n.getDate()]
        }(t), t._w && null == t._a[bt] && null == t._a[xt] && function(e) {
          var t, n, s, i, r, a, o, u;
          if (null != (t = e._w).GG || null != t.W || null != t.E) r = 1, a = 4, n = de(t.GG, e._a[Tt], X(pe(), 1, 4).year), s = de(t.W, 1), ((i = de(t.E, 1)) < 1 || i > 7) && (u = !0);
          else {
            r = e._locale._week.dow, a = e._locale._week.doy;
            var l = X(pe(), r, a);
            n = de(t.gg, e._a[Tt], l.year), s = de(t.w, l.week), null != t.d ? ((i = t.d) < 0 || i > 6) && (u = !0) : null != t.e ? (i = t.e + r, (t.e < 0 || t.e > 6) && (u = !0)) : i = r
          }
          s < 1 || s > K(n, r, a) ? d(e)._overflowWeeks = !0 : null != u ? d(e)._overflowWeekday = !0 : (o = Q(n, s, i, r, a), e._a[Tt] = o.year, e._dayOfYear = o.dayOfYear)
        }(t), null != t._dayOfYear && (a = de(t._a[Tt], i[Tt]), (t._dayOfYear > V(a) || 0 === t._dayOfYear) && (d(t)._overflowDayOfYear = !0), s = J(a, 0, t._dayOfYear), t._a[xt] = s.getUTCMonth(), t._a[bt] = s.getUTCDate()), n = 0; n < 3 && null == t._a[n]; ++n) t._a[n] = o[n] = i[n];
      for (; n < 7; n++) t._a[n] = o[n] = null == t._a[n] ? 2 === n ? 1 : 0 : t._a[n];
      24 === t._a[Pt] && 0 === t._a[Wt] && 0 === t._a[Ht] && 0 === t._a[Rt] && (t._nextDay = !0, t._a[Pt] = 0), t._d = (t._useUTC ? J : function(e, t, n, s, i, r, a) {
        var o = new Date(e, t, n, s, i, r, a);
        return e < 100 && e >= 0 && isFinite(o.getFullYear()) && o.setFullYear(e), o
      }).apply(null, o), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[Pt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (d(t).weekdayMismatch = !0)
    }
  }

  function ce(e) {
    var t, n, s, i, r, a, o = e._i,
      u = en.exec(o) || tn.exec(o);
    if (u) {
      for (d(e).iso = !0, t = 0, n = sn.length; t < n; t++)
        if (sn[t][1].exec(u[1])) {
          i = sn[t][0], s = !1 !== sn[t][2];
          break
        } if (null == i) return void(e._isValid = !1);
      if (u[3]) {
        for (t = 0, n = rn.length; t < n; t++)
          if (rn[t][1].exec(u[3])) {
            r = (u[2] || " ") + rn[t][0];
            break
          } if (null == r) return void(e._isValid = !1)
      }
      if (!s && null != r) return void(e._isValid = !1);
      if (u[4]) {
        if (!nn.exec(u[4])) return void(e._isValid = !1);
        a = "Z"
      }
      e._f = i + (r || "") + (a || ""), _e(e)
    } else e._isValid = !1
  }

  function fe(e, t, n, s, i, r) {
    var a = [function(e) {
      var t = parseInt(e, 10); {
        if (t <= 49) return 2e3 + t;
        if (t <= 999) return 1900 + t
      }
      return t
    }(e), Vt.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)];
    return r && a.push(parseInt(r, 10)), a
  }

  function me(e) {
    var t = on.exec(function(e) {
      return e.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
    }(e._i));
    if (t) {
      var n = fe(t[4], t[3], t[2], t[5], t[6], t[7]);
      if (! function(e, t, n) {
          if (e && jt.indexOf(e) !== new Date(t[0], t[1], t[2]).getDay()) return d(n).weekdayMismatch = !0, n._isValid = !1, !1;
          return !0
        }(t[1], n, e)) return;
      e._a = n, e._tzm = function(e, t, n) {
        if (e) return un[e];
        if (t) return 0;
        var s = parseInt(n, 10),
          i = s % 100;
        return (s - i) / 100 * 60 + i
      }(t[8], t[9], t[10]), e._d = J.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), d(e).rfc2822 = !0
    } else e._isValid = !1
  }

  function _e(t) {
    if (t._f !== e.ISO_8601)
      if (t._f !== e.RFC_2822) {
        t._a = [], d(t).empty = !0;
        var n, s, i, r, a, o = "" + t._i,
          u = o.length,
          l = 0;
        for (i = R(t._f, t._locale).match(rt) || [], n = 0; n < i.length; n++) r = i[n], (s = (o.match(F(r, t)) || [])[0]) && ((a = o.substr(0, o.indexOf(s))).length > 0 && d(t).unusedInput.push(a), o = o.slice(o.indexOf(s) + s.length), l += s.length), ut[r] ? (s ? d(t).empty = !1 : d(t).unusedTokens.push(r), G(r, s, t)) : t._strict && !s && d(t).unusedTokens.push(r);
        d(t).charsLeftOver = u - l, o.length > 0 && d(t).unusedInput.push(o), t._a[Pt] <= 12 && !0 === d(t).bigHour && t._a[Pt] > 0 && (d(t).bigHour = void 0), d(t).parsedDateParts = t._a.slice(0), d(t).meridiem = t._meridiem, t._a[Pt] = function(e, t, n) {
          var s;
          if (null == n) return t;
          return null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((s = e.isPM(n)) && t < 12 && (t += 12), s || 12 !== t || (t = 0), t) : t
        }(t._locale, t._a[Pt], t._meridiem), he(t), le(t)
      } else me(t);
    else ce(t)
  }

  function ye(o) {
    var l = o._i,
      y = o._f;
    return o._locale = o._locale || ue(o._l), null === l || void 0 === y && "" === l ? c({
      nullInput: !0
    }) : ("string" == typeof l && (o._i = l = o._locale.preparse(l)), _(l) ? new m(le(l)) : (r(l) ? o._d = l : t(y) ? function(e) {
      var t, n, s, i, r;
      if (0 === e._f.length) return d(e).invalidFormat = !0, void(e._d = new Date(NaN));
      for (i = 0; i < e._f.length; i++) r = 0, t = f({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], _e(t), h(t) && (r += d(t).charsLeftOver, r += 10 * d(t).unusedTokens.length, d(t).score = r, (null == s || r < s) && (s = r, n = t));
      u(e, n || t)
    }(o) : y ? _e(o) : function(o) {
      var u = o._i;
      s(u) ? o._d = new Date(e.now()) : r(u) ? o._d = new Date(u.valueOf()) : "string" == typeof u ? function(t) {
        var n = an.exec(t._i);
        null === n ? (ce(t), !1 === t._isValid && (delete t._isValid, me(t), !1 === t._isValid && (delete t._isValid, e.createFromInputFallback(t)))) : t._d = new Date(+n[1])
      }(o) : t(u) ? (o._a = a(u.slice(0), function(e) {
        return parseInt(e, 10)
      }), he(o)) : n(u) ? function(e) {
        if (!e._d) {
          var t = T(e._i);
          e._a = a([t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], function(e) {
            return e && parseInt(e, 10)
          }), he(e)
        }
      }(o) : i(u) ? o._d = new Date(u) : e.createFromInputFallback(o)
    }(o), h(o) || (o._d = null), o))
  }

  function ge(e, s, i, r, a) {
    var o = {};
    return !0 !== i && !1 !== i || (r = i, i = void 0), (n(e) && function(e) {
        if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
        var t;
        for (t in e)
          if (e.hasOwnProperty(t)) return !1;
        return !0
      }(e) || t(e) && 0 === e.length) && (e = void 0), o._isAMomentObject = !0, o._useUTC = o._isUTC = a, o._l = i, o._i = e, o._f = s, o._strict = r,
      function(e) {
        var t = new m(le(ye(e)));
        return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t
      }(o)
  }

  function pe(e, t, n, s) {
    return ge(e, t, n, s, !1)
  }

  function we(e, n) {
    var s, i;
    if (1 === n.length && t(n[0]) && (n = n[0]), !n.length) return pe();
    for (s = n[0], i = 1; i < n.length; ++i) n[i].isValid() && !n[i][e](s) || (s = n[i]);
    return s
  }

  function ve(e) {
    var t = T(e),
      n = t.year || 0,
      s = t.quarter || 0,
      i = t.month || 0,
      r = t.week || 0,
      a = t.day || 0,
      o = t.hour || 0,
      u = t.minute || 0,
      l = t.second || 0,
      d = t.millisecond || 0;
    this._isValid = function(e) {
      for (var t in e)
        if (-1 === Ut.call(hn, t) || null != e[t] && isNaN(e[t])) return !1;
      for (var n = !1, s = 0; s < hn.length; ++s)
        if (e[hn[s]]) {
          if (n) return !1;
          parseFloat(e[hn[s]]) !== g(e[hn[s]]) && (n = !0)
        } return !0
    }(t), this._milliseconds = +d + 1e3 * l + 6e4 * u + 1e3 * o * 60 * 60, this._days = +a + 7 * r, this._months = +i + 3 * s + 12 * n, this._data = {}, this._locale = ue(), this._bubble()
  }

  function Me(e) {
    return e instanceof ve
  }

  function Se(e) {
    return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
  }

  function De(e, t) {
    P(e, 0, 0, function() {
      var e = this.utcOffset(),
        n = "+";
      return e < 0 && (e = -e, n = "-"), n + b(~~(e / 60), 2) + t + b(~~e % 60, 2)
    })
  }

  function ke(e, t) {
    var n = (t || "").match(e);
    if (null === n) return null;
    var s = ((n[n.length - 1] || []) + "").match(cn) || ["-", 0, 0],
      i = 60 * s[1] + g(s[2]);
    return 0 === i ? 0 : "+" === s[0] ? i : -i
  }

  function Ye(t, n) {
    var s, i;
    return n._isUTC ? (s = n.clone(), i = (_(t) || r(t) ? t.valueOf() : pe(t).valueOf()) - s.valueOf(), s._d.setTime(s._d.valueOf() + i), e.updateOffset(s, !1), s) : pe(t).local()
  }

  function Oe(e) {
    return 15 * -Math.round(e._d.getTimezoneOffset() / 15)
  }

  function Te() {
    return !!this.isValid() && (this._isUTC && 0 === this._offset)
  }

  function xe(e, t) {
    var n, s, r, a = e,
      u = null;
    return Me(e) ? a = {
      ms: e._milliseconds,
      d: e._days,
      M: e._months
    } : i(e) ? (a = {}, t ? a[t] = e : a.milliseconds = e) : (u = fn.exec(e)) ? (n = "-" === u[1] ? -1 : 1, a = {
      y: 0,
      d: g(u[bt]) * n,
      h: g(u[Pt]) * n,
      m: g(u[Wt]) * n,
      s: g(u[Ht]) * n,
      ms: g(Se(1e3 * u[Rt])) * n
    }) : (u = mn.exec(e)) ? (n = "-" === u[1] ? -1 : (u[1], 1), a = {
      y: be(u[2], n),
      M: be(u[3], n),
      w: be(u[4], n),
      d: be(u[5], n),
      h: be(u[6], n),
      m: be(u[7], n),
      s: be(u[8], n)
    }) : null == a ? a = {} : "object" == typeof a && ("from" in a || "to" in a) && (r = function(e, t) {
      var n;
      if (!e.isValid() || !t.isValid()) return {
        milliseconds: 0,
        months: 0
      };
      t = Ye(t, e), e.isBefore(t) ? n = Pe(e, t) : ((n = Pe(t, e)).milliseconds = -n.milliseconds, n.months = -n.months);
      return n
    }(pe(a.from), pe(a.to)), (a = {}).ms = r.milliseconds, a.M = r.months), s = new ve(a), Me(e) && o(e, "_locale") && (s._locale = e._locale), s
  }

  function be(e, t) {
    var n = e && parseFloat(e.replace(",", "."));
    return (isNaN(n) ? 0 : n) * t
  }

  function Pe(e, t) {
    var n = {
      milliseconds: 0,
      months: 0
    };
    return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
  }

  function We(e, t) {
    return function(n, s) {
      var i, r;
      return null === s || isNaN(+s) || (M(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = s, s = r), n = "string" == typeof n ? +n : n, i = xe(n, s), He(this, i, e), this
    }
  }

  function He(t, n, s, i) {
    var r = n._milliseconds,
      a = Se(n._days),
      o = Se(n._months);
    t.isValid() && (i = null == i || i, o && z(t, A(t, "Month") + o * s), a && j(t, "Date", A(t, "Date") + a * s), r && t._d.setTime(t._d.valueOf() + r * s), i && e.updateOffset(t, a || o))
  }

  function Re(e, t) {
    var n, s = 12 * (t.year() - e.year()) + (t.month() - e.month()),
      i = e.clone().add(s, "months");
    return n = t - i < 0 ? (t - i) / (i - e.clone().add(s - 1, "months")) : (t - i) / (e.clone().add(s + 1, "months") - i), -(s + n) || 0
  }

  function Ce(e) {
    var t;
    return void 0 === e ? this._locale._abbr : (null != (t = ue(e)) && (this._locale = t), this)
  }

  function Fe() {
    return this._locale
  }

  function Ue(e, t) {
    P(0, [e, e.length], 0, t)
  }

  function Le(e, t, n, s, i) {
    var r;
    return null == e ? X(this, s, i).year : (r = K(e, s, i), t > r && (t = r), function(e, t, n, s, i) {
      var r = Q(e, t, n, s, i),
        a = J(r.year, 0, r.dayOfYear);
      return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
    }.call(this, e, t, n, s, i))
  }

  function Ne(e, t) {
    t[Rt] = g(1e3 * ("0." + e))
  }

  function Ge(e) {
    return e
  }

  function Ve(e, t, n, s) {
    var i = ue(),
      r = l().set(s, t);
    return i[n](r, e)
  }

  function Ee(e, t, n) {
    if (i(e) && (t = e, e = void 0), e = e || "", null != t) return Ve(e, t, n, "month");
    var s, r = [];
    for (s = 0; s < 12; s++) r[s] = Ve(e, s, n, "month");
    return r
  }

  function Ie(e, t, n, s) {
    "boolean" == typeof e ? (i(t) && (n = t, t = void 0), t = t || "") : (n = t = e, e = !1, i(t) && (n = t, t = void 0), t = t || "");
    var r = ue(),
      a = e ? r._week.dow : 0;
    if (null != n) return Ve(t, (n + a) % 7, s, "day");
    var o, u = [];
    for (o = 0; o < 7; o++) u[o] = Ve(t, (o + a) % 7, s, "day");
    return u
  }

  function Ae(e, t, n, s) {
    var i = xe(t, n);
    return e._milliseconds += s * i._milliseconds, e._days += s * i._days, e._months += s * i._months, e._bubble()
  }

  function je(e) {
    return e < 0 ? Math.floor(e) : Math.ceil(e)
  }

  function Ze(e) {
    return 4800 * e / 146097
  }

  function ze(e) {
    return 146097 * e / 4800
  }

  function $e(e) {
    return function() {
      return this.as(e)
    }
  }

  function qe(e) {
    return function() {
      return this.isValid() ? this._data[e] : NaN
    }
  }

  function Je(e) {
    return (e > 0) - (e < 0) || +e
  }

  function Be() {
    if (!this.isValid()) return this.localeData().invalidDate();
    var e, t, n = An(this._milliseconds) / 1e3,
      s = An(this._days),
      i = An(this._months);
    t = y((e = y(n / 60)) / 60), n %= 60, e %= 60;
    var r = y(i / 12),
      a = i %= 12,
      o = s,
      u = t,
      l = e,
      d = n ? n.toFixed(3).replace(/\.?0+$/, "") : "",
      h = this.asSeconds();
    if (!h) return "P0D";
    var c = h < 0 ? "-" : "",
      f = Je(this._months) !== Je(h) ? "-" : "",
      m = Je(this._days) !== Je(h) ? "-" : "",
      _ = Je(this._milliseconds) !== Je(h) ? "-" : "";
    return c + "P" + (r ? f + r + "Y" : "") + (a ? f + a + "M" : "") + (o ? m + o + "D" : "") + (u || l || d ? "T" : "") + (u ? _ + u + "H" : "") + (l ? _ + l + "M" : "") + (d ? _ + d + "S" : "")
  }
  var Qe, Xe;
  Xe = Array.prototype.some ? Array.prototype.some : function(e) {
    for (var t = Object(this), n = t.length >>> 0, s = 0; s < n; s++)
      if (s in t && e.call(this, t[s], s, t)) return !0;
    return !1
  };
  var Ke = e.momentProperties = [],
    et = !1,
    tt = {};
  e.suppressDeprecationWarnings = !1, e.deprecationHandler = null;
  var nt;
  nt = Object.keys ? Object.keys : function(e) {
    var t, n = [];
    for (t in e) o(e, t) && n.push(t);
    return n
  };
  var st = {},
    it = {},
    rt = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    at = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    ot = {},
    ut = {},
    lt = /\d/,
    dt = /\d\d/,
    ht = /\d{3}/,
    ct = /\d{4}/,
    ft = /[+-]?\d{6}/,
    mt = /\d\d?/,
    _t = /\d\d\d\d?/,
    yt = /\d\d\d\d\d\d?/,
    gt = /\d{1,3}/,
    pt = /\d{1,4}/,
    wt = /[+-]?\d{1,6}/,
    vt = /\d+/,
    Mt = /[+-]?\d+/,
    St = /Z|[+-]\d\d:?\d\d/gi,
    Dt = /Z|[+-]\d\d(?::?\d\d)?/gi,
    kt = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
    Yt = {},
    Ot = {},
    Tt = 0,
    xt = 1,
    bt = 2,
    Pt = 3,
    Wt = 4,
    Ht = 5,
    Rt = 6,
    Ct = 7,
    Ft = 8;
  P("Y", 0, 0, function() {
    var e = this.year();
    return e <= 9999 ? "" + e : "+" + e
  }), P(0, ["YY", 2], 0, function() {
    return this.year() % 100
  }), P(0, ["YYYY", 4], 0, "year"), P(0, ["YYYYY", 5], 0, "year"), P(0, ["YYYYYY", 6, !0], 0, "year"), Y("year", "y"), x("year", 1), C("Y", Mt), C("YY", mt, dt), C("YYYY", pt, ct), C("YYYYY", wt, ft), C("YYYYYY", wt, ft), L(["YYYYY", "YYYYYY"], Tt), L("YYYY", function(t, n) {
    n[Tt] = 2 === t.length ? e.parseTwoDigitYear(t) : g(t)
  }), L("YY", function(t, n) {
    n[Tt] = e.parseTwoDigitYear(t)
  }), L("Y", function(e, t) {
    t[Tt] = parseInt(e, 10)
  }), e.parseTwoDigitYear = function(e) {
    return g(e) + (g(e) > 68 ? 1900 : 2e3)
  };
  var Ut, Lt = I("FullYear", !0);
  Ut = Array.prototype.indexOf ? Array.prototype.indexOf : function(e) {
    var t;
    for (t = 0; t < this.length; ++t)
      if (this[t] === e) return t;
    return -1
  }, P("M", ["MM", 2], "Mo", function() {
    return this.month() + 1
  }), P("MMM", 0, 0, function(e) {
    return this.localeData().monthsShort(this, e)
  }), P("MMMM", 0, 0, function(e) {
    return this.localeData().months(this, e)
  }), Y("month", "M"), x("month", 8), C("M", mt), C("MM", mt, dt), C("MMM", function(e, t) {
    return t.monthsShortRegex(e)
  }), C("MMMM", function(e, t) {
    return t.monthsRegex(e)
  }), L(["M", "MM"], function(e, t) {
    t[xt] = g(e) - 1
  }), L(["MMM", "MMMM"], function(e, t, n, s) {
    var i = n._locale.monthsParse(e, s, n._strict);
    null != i ? t[xt] = i : d(n).invalidMonth = e
  });
  var Nt = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
    Gt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    Vt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    Et = kt,
    It = kt;
  P("w", ["ww", 2], "wo", "week"), P("W", ["WW", 2], "Wo", "isoWeek"), Y("week", "w"), Y("isoWeek", "W"), x("week", 5), x("isoWeek", 5), C("w", mt), C("ww", mt, dt), C("W", mt), C("WW", mt, dt), N(["w", "ww", "W", "WW"], function(e, t, n, s) {
    t[s.substr(0, 1)] = g(e)
  });
  P("d", 0, "do", "day"), P("dd", 0, 0, function(e) {
    return this.localeData().weekdaysMin(this, e)
  }), P("ddd", 0, 0, function(e) {
    return this.localeData().weekdaysShort(this, e)
  }), P("dddd", 0, 0, function(e) {
    return this.localeData().weekdays(this, e)
  }), P("e", 0, 0, "weekday"), P("E", 0, 0, "isoWeekday"), Y("day", "d"), Y("weekday", "e"), Y("isoWeekday", "E"), x("day", 11), x("weekday", 11), x("isoWeekday", 11), C("d", mt), C("e", mt), C("E", mt), C("dd", function(e, t) {
    return t.weekdaysMinRegex(e)
  }), C("ddd", function(e, t) {
    return t.weekdaysShortRegex(e)
  }), C("dddd", function(e, t) {
    return t.weekdaysRegex(e)
  }), N(["dd", "ddd", "dddd"], function(e, t, n, s) {
    var i = n._locale.weekdaysParse(e, s, n._strict);
    null != i ? t.d = i : d(n).invalidWeekday = e
  }), N(["d", "e", "E"], function(e, t, n, s) {
    t[s] = g(e)
  });
  var At = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    jt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    Zt = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
    zt = kt,
    $t = kt,
    qt = kt;
  P("H", ["HH", 2], 0, "hour"), P("h", ["hh", 2], 0, te), P("k", ["kk", 2], 0, function() {
    return this.hours() || 24
  }), P("hmm", 0, 0, function() {
    return "" + te.apply(this) + b(this.minutes(), 2)
  }), P("hmmss", 0, 0, function() {
    return "" + te.apply(this) + b(this.minutes(), 2) + b(this.seconds(), 2)
  }), P("Hmm", 0, 0, function() {
    return "" + this.hours() + b(this.minutes(), 2)
  }), P("Hmmss", 0, 0, function() {
    return "" + this.hours() + b(this.minutes(), 2) + b(this.seconds(), 2)
  }), ne("a", !0), ne("A", !1), Y("hour", "h"), x("hour", 13), C("a", se), C("A", se), C("H", mt), C("h", mt), C("k", mt), C("HH", mt, dt), C("hh", mt, dt), C("kk", mt, dt), C("hmm", _t), C("hmmss", yt), C("Hmm", _t), C("Hmmss", yt), L(["H", "HH"], Pt), L(["k", "kk"], function(e, t, n) {
    var s = g(e);
    t[Pt] = 24 === s ? 0 : s
  }), L(["a", "A"], function(e, t, n) {
    n._isPm = n._locale.isPM(e), n._meridiem = e
  }), L(["h", "hh"], function(e, t, n) {
    t[Pt] = g(e), d(n).bigHour = !0
  }), L("hmm", function(e, t, n) {
    var s = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s)), d(n).bigHour = !0
  }), L("hmmss", function(e, t, n) {
    var s = e.length - 4,
      i = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Ht] = g(e.substr(i)), d(n).bigHour = !0
  }), L("Hmm", function(e, t, n) {
    var s = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s))
  }), L("Hmmss", function(e, t, n) {
    var s = e.length - 4,
      i = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Ht] = g(e.substr(i))
  });
  var Jt, Bt = I("Hours", !0),
    Qt = {
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      longDateFormat: {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      invalidDate: "Invalid date",
      ordinal: "%d",
      dayOfMonthOrdinalParse: /\d{1,2}/,
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      months: Gt,
      monthsShort: Vt,
      week: {
        dow: 0,
        doy: 6
      },
      weekdays: At,
      weekdaysMin: Zt,
      weekdaysShort: jt,
      meridiemParse: /[ap]\.?m?\.?/i
    },
    Xt = {},
    Kt = {},
    en = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    tn = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    nn = /Z|[+-]\d\d(?::?\d\d)?/,
    sn = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, !1],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
      ["YYYYDDD", /\d{7}/]
    ],
    rn = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ],
    an = /^\/?Date\((\-?\d+)/i,
    on = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
    un = {
      UT: 0,
      GMT: 0,
      EDT: -240,
      EST: -300,
      CDT: -300,
      CST: -360,
      MDT: -360,
      MST: -420,
      PDT: -420,
      PST: -480
    };
  e.createFromInputFallback = v("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e) {
    e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
  }), e.ISO_8601 = function() {}, e.RFC_2822 = function() {};
  var ln = v("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e = pe.apply(null, arguments);
      return this.isValid() && e.isValid() ? e < this ? this : e : c()
    }),
    dn = v("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e = pe.apply(null, arguments);
      return this.isValid() && e.isValid() ? e > this ? this : e : c()
    }),
    hn = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
  De("Z", ":"), De("ZZ", ""), C("Z", Dt), C("ZZ", Dt), L(["Z", "ZZ"], function(e, t, n) {
    n._useUTC = !0, n._tzm = ke(Dt, e)
  });
  var cn = /([\+\-]|\d\d)/gi;
  e.updateOffset = function() {};
  var fn = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
    mn = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  xe.fn = ve.prototype, xe.invalid = function() {
    return xe(NaN)
  };
  var _n = We(1, "add"),
    yn = We(-1, "subtract");
  e.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", e.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  var gn = v("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e) {
    return void 0 === e ? this.localeData() : this.locale(e)
  });
  P(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100
  }), P(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100
  }), Ue("gggg", "weekYear"), Ue("ggggg", "weekYear"), Ue("GGGG", "isoWeekYear"), Ue("GGGGG", "isoWeekYear"), Y("weekYear", "gg"), Y("isoWeekYear", "GG"), x("weekYear", 1), x("isoWeekYear", 1), C("G", Mt), C("g", Mt), C("GG", mt, dt), C("gg", mt, dt), C("GGGG", pt, ct), C("gggg", pt, ct), C("GGGGG", wt, ft), C("ggggg", wt, ft), N(["gggg", "ggggg", "GGGG", "GGGGG"], function(e, t, n, s) {
    t[s.substr(0, 2)] = g(e)
  }), N(["gg", "GG"], function(t, n, s, i) {
    n[i] = e.parseTwoDigitYear(t)
  }), P("Q", 0, "Qo", "quarter"), Y("quarter", "Q"), x("quarter", 7), C("Q", lt), L("Q", function(e, t) {
    t[xt] = 3 * (g(e) - 1)
  }), P("D", ["DD", 2], "Do", "date"), Y("date", "D"), x("date", 9), C("D", mt), C("DD", mt, dt), C("Do", function(e, t) {
    return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
  }), L(["D", "DD"], bt), L("Do", function(e, t) {
    t[bt] = g(e.match(mt)[0])
  });
  var pn = I("Date", !0);
  P("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), Y("dayOfYear", "DDD"), x("dayOfYear", 4), C("DDD", gt), C("DDDD", ht), L(["DDD", "DDDD"], function(e, t, n) {
    n._dayOfYear = g(e)
  }), P("m", ["mm", 2], 0, "minute"), Y("minute", "m"), x("minute", 14), C("m", mt), C("mm", mt, dt), L(["m", "mm"], Wt);
  var wn = I("Minutes", !1);
  P("s", ["ss", 2], 0, "second"), Y("second", "s"), x("second", 15), C("s", mt), C("ss", mt, dt), L(["s", "ss"], Ht);
  var vn = I("Seconds", !1);
  P("S", 0, 0, function() {
    return ~~(this.millisecond() / 100)
  }), P(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10)
  }), P(0, ["SSS", 3], 0, "millisecond"), P(0, ["SSSS", 4], 0, function() {
    return 10 * this.millisecond()
  }), P(0, ["SSSSS", 5], 0, function() {
    return 100 * this.millisecond()
  }), P(0, ["SSSSSS", 6], 0, function() {
    return 1e3 * this.millisecond()
  }), P(0, ["SSSSSSS", 7], 0, function() {
    return 1e4 * this.millisecond()
  }), P(0, ["SSSSSSSS", 8], 0, function() {
    return 1e5 * this.millisecond()
  }), P(0, ["SSSSSSSSS", 9], 0, function() {
    return 1e6 * this.millisecond()
  }), Y("millisecond", "ms"), x("millisecond", 16), C("S", gt, lt), C("SS", gt, dt), C("SSS", gt, ht);
  var Mn;
  for (Mn = "SSSS"; Mn.length <= 9; Mn += "S") C(Mn, vt);
  for (Mn = "S"; Mn.length <= 9; Mn += "S") L(Mn, Ne);
  var Sn = I("Milliseconds", !1);
  P("z", 0, 0, "zoneAbbr"), P("zz", 0, 0, "zoneName");
  var Dn = m.prototype;
  Dn.add = _n, Dn.calendar = function(t, n) {
    var s = t || pe(),
      i = Ye(s, this).startOf("day"),
      r = e.calendarFormat(this, i) || "sameElse",
      a = n && (S(n[r]) ? n[r].call(this, s) : n[r]);
    return this.format(a || this.localeData().calendar(r, this, pe(s)))
  }, Dn.clone = function() {
    return new m(this)
  }, Dn.diff = function(e, t, n) {
    var s, i, r;
    if (!this.isValid()) return NaN;
    if (!(s = Ye(e, this)).isValid()) return NaN;
    switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = O(t)) {
      case "year":
        r = Re(this, s) / 12;
        break;
      case "month":
        r = Re(this, s);
        break;
      case "quarter":
        r = Re(this, s) / 3;
        break;
      case "second":
        r = (this - s) / 1e3;
        break;
      case "minute":
        r = (this - s) / 6e4;
        break;
      case "hour":
        r = (this - s) / 36e5;
        break;
      case "day":
        r = (this - s - i) / 864e5;
        break;
      case "week":
        r = (this - s - i) / 6048e5;
        break;
      default:
        r = this - s
    }
    return n ? r : y(r)
  }, Dn.endOf = function(e) {
    return void 0 === (e = O(e)) || "millisecond" === e ? this : ("date" === e && (e = "day"), this.startOf(e).add(1, "isoWeek" === e ? "week" : e).subtract(1, "ms"))
  }, Dn.format = function(t) {
    t || (t = this.isUtc() ? e.defaultFormatUtc : e.defaultFormat);
    var n = H(this, t);
    return this.localeData().postformat(n)
  }, Dn.from = function(e, t) {
    return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? xe({
      to: this,
      from: e
    }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
  }, Dn.fromNow = function(e) {
    return this.from(pe(), e)
  }, Dn.to = function(e, t) {
    return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? xe({
      from: this,
      to: e
    }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
  }, Dn.toNow = function(e) {
    return this.to(pe(), e)
  }, Dn.get = function(e) {
    return e = O(e), S(this[e]) ? this[e]() : this
  }, Dn.invalidAt = function() {
    return d(this).overflow
  }, Dn.isAfter = function(e, t) {
    var n = _(e) ? e : pe(e);
    return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
  }, Dn.isBefore = function(e, t) {
    var n = _(e) ? e : pe(e);
    return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
  }, Dn.isBetween = function(e, t, n, s) {
    return ("(" === (s = s || "()")[0] ? this.isAfter(e, n) : !this.isBefore(e, n)) && (")" === s[1] ? this.isBefore(t, n) : !this.isAfter(t, n))
  }, Dn.isSame = function(e, t) {
    var n, s = _(e) ? e : pe(e);
    return !(!this.isValid() || !s.isValid()) && ("millisecond" === (t = O(t || "millisecond")) ? this.valueOf() === s.valueOf() : (n = s.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
  }, Dn.isSameOrAfter = function(e, t) {
    return this.isSame(e, t) || this.isAfter(e, t)
  }, Dn.isSameOrBefore = function(e, t) {
    return this.isSame(e, t) || this.isBefore(e, t)
  }, Dn.isValid = function() {
    return h(this)
  }, Dn.lang = gn, Dn.locale = Ce, Dn.localeData = Fe, Dn.max = dn, Dn.min = ln, Dn.parsingFlags = function() {
    return u({}, d(this))
  }, Dn.set = function(e, t) {
    if ("object" == typeof e)
      for (var n = function(e) {
          var t = [];
          for (var n in e) t.push({
            unit: n,
            priority: it[n]
          });
          return t.sort(function(e, t) {
            return e.priority - t.priority
          }), t
        }(e = T(e)), s = 0; s < n.length; s++) this[n[s].unit](e[n[s].unit]);
    else if (e = O(e), S(this[e])) return this[e](t);
    return this
  }, Dn.startOf = function(e) {
    switch (e = O(e)) {
      case "year":
        this.month(0);
      case "quarter":
      case "month":
        this.date(1);
      case "week":
      case "isoWeek":
      case "day":
      case "date":
        this.hours(0);
      case "hour":
        this.minutes(0);
      case "minute":
        this.seconds(0);
      case "second":
        this.milliseconds(0)
    }
    return "week" === e && this.weekday(0), "isoWeek" === e && this.isoWeekday(1), "quarter" === e && this.month(3 * Math.floor(this.month() / 3)), this
  }, Dn.subtract = yn, Dn.toArray = function() {
    return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]
  }, Dn.toObject = function() {
    return {
      years: this.year(),
      months: this.month(),
      date: this.date(),
      hours: this.hours(),
      minutes: this.minutes(),
      seconds: this.seconds(),
      milliseconds: this.milliseconds()
    }
  }, Dn.toDate = function() {
    return new Date(this.valueOf())
  }, Dn.toISOString = function(e) {
    if (!this.isValid()) return null;
    var t = !0 !== e,
      n = t ? this.clone().utc() : this;
    return n.year() < 0 || n.year() > 9999 ? H(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : S(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this._d.valueOf()).toISOString().replace("Z", H(n, "Z")) : H(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
  }, Dn.inspect = function() {
    if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
    var e = "moment",
      t = "";
    this.isLocal() || (e = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t = "Z");
    var n = "[" + e + '("]',
      s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
      i = t + '[")]';
    return this.format(n + s + "-MM-DD[T]HH:mm:ss.SSS" + i)
  }, Dn.toJSON = function() {
    return this.isValid() ? this.toISOString() : null
  }, Dn.toString = function() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
  }, Dn.unix = function() {
    return Math.floor(this.valueOf() / 1e3)
  }, Dn.valueOf = function() {
    return this._d.valueOf() - 6e4 * (this._offset || 0)
  }, Dn.creationData = function() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    }
  }, Dn.year = Lt, Dn.isLeapYear = function() {
    return E(this.year())
  }, Dn.weekYear = function(e) {
    return Le.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
  }, Dn.isoWeekYear = function(e) {
    return Le.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
  }, Dn.quarter = Dn.quarters = function(e) {
    return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
  }, Dn.month = $, Dn.daysInMonth = function() {
    return Z(this.year(), this.month())
  }, Dn.week = Dn.weeks = function(e) {
    var t = this.localeData().week(this);
    return null == e ? t : this.add(7 * (e - t), "d")
  }, Dn.isoWeek = Dn.isoWeeks = function(e) {
    var t = X(this, 1, 4).week;
    return null == e ? t : this.add(7 * (e - t), "d")
  }, Dn.weeksInYear = function() {
    var e = this.localeData()._week;
    return K(this.year(), e.dow, e.doy)
  }, Dn.isoWeeksInYear = function() {
    return K(this.year(), 1, 4)
  }, Dn.date = pn, Dn.day = Dn.days = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return null != e ? (e = function(e, t) {
      return "string" != typeof e ? e : isNaN(e) ? "number" == typeof(e = t.weekdaysParse(e)) ? e : null : parseInt(e, 10)
    }(e, this.localeData()), this.add(e - t, "d")) : t
  }, Dn.weekday = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return null == e ? t : this.add(e - t, "d")
  }, Dn.isoWeekday = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    if (null != e) {
      var t = function(e, t) {
        return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
      }(e, this.localeData());
      return this.day(this.day() % 7 ? t : t - 7)
    }
    return this.day() || 7
  }, Dn.dayOfYear = function(e) {
    var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return null == e ? t : this.add(e - t, "d")
  }, Dn.hour = Dn.hours = Bt, Dn.minute = Dn.minutes = wn, Dn.second = Dn.seconds = vn, Dn.millisecond = Dn.milliseconds = Sn, Dn.utcOffset = function(t, n, s) {
    var i, r = this._offset || 0;
    if (!this.isValid()) return null != t ? this : NaN;
    if (null != t) {
      if ("string" == typeof t) {
        if (null === (t = ke(Dt, t))) return this
      } else Math.abs(t) < 16 && !s && (t *= 60);
      return !this._isUTC && n && (i = Oe(this)), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), r !== t && (!n || this._changeInProgress ? He(this, xe(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, e.updateOffset(this, !0), this._changeInProgress = null)), this
    }
    return this._isUTC ? r : Oe(this)
  }, Dn.utc = function(e) {
    return this.utcOffset(0, e)
  }, Dn.local = function(e) {
    return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Oe(this), "m")), this
  }, Dn.parseZone = function() {
    if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
    else if ("string" == typeof this._i) {
      var e = ke(St, this._i);
      null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
    }
    return this
  }, Dn.hasAlignedHourOffset = function(e) {
    return !!this.isValid() && (e = e ? pe(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
  }, Dn.isDST = function() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
  }, Dn.isLocal = function() {
    return !!this.isValid() && !this._isUTC
  }, Dn.isUtcOffset = function() {
    return !!this.isValid() && this._isUTC
  }, Dn.isUtc = Te, Dn.isUTC = Te, Dn.zoneAbbr = function() {
    return this._isUTC ? "UTC" : ""
  }, Dn.zoneName = function() {
    return this._isUTC ? "Coordinated Universal Time" : ""
  }, Dn.dates = v("dates accessor is deprecated. Use date instead.", pn), Dn.months = v("months accessor is deprecated. Use month instead", $), Dn.years = v("years accessor is deprecated. Use year instead", Lt), Dn.zone = v("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(e, t) {
    return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
  }), Dn.isDSTShifted = v("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
    if (!s(this._isDSTShifted)) return this._isDSTShifted;
    var e = {};
    if (f(e, this), (e = ye(e))._a) {
      var t = e._isUTC ? l(e._a) : pe(e._a);
      this._isDSTShifted = this.isValid() && p(e._a, t.toArray()) > 0
    } else this._isDSTShifted = !1;
    return this._isDSTShifted
  });
  var kn = k.prototype;
  kn.calendar = function(e, t, n) {
    var s = this._calendar[e] || this._calendar.sameElse;
    return S(s) ? s.call(t, n) : s
  }, kn.longDateFormat = function(e) {
    var t = this._longDateFormat[e],
      n = this._longDateFormat[e.toUpperCase()];
    return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, function(e) {
      return e.slice(1)
    }), this._longDateFormat[e])
  }, kn.invalidDate = function() {
    return this._invalidDate
  }, kn.ordinal = function(e) {
    return this._ordinal.replace("%d", e)
  }, kn.preparse = Ge, kn.postformat = Ge, kn.relativeTime = function(e, t, n, s) {
    var i = this._relativeTime[n];
    return S(i) ? i(e, t, n, s) : i.replace(/%d/i, e)
  }, kn.pastFuture = function(e, t) {
    var n = this._relativeTime[e > 0 ? "future" : "past"];
    return S(n) ? n(t) : n.replace(/%s/i, t)
  }, kn.set = function(e) {
    var t, n;
    for (n in e) S(t = e[n]) ? this[n] = t : this["_" + n] = t;
    this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
  }, kn.months = function(e, n) {
    return e ? t(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || Nt).test(n) ? "format" : "standalone"][e.month()] : t(this._months) ? this._months : this._months.standalone
  }, kn.monthsShort = function(e, n) {
    return e ? t(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[Nt.test(n) ? "format" : "standalone"][e.month()] : t(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
  }, kn.monthsParse = function(e, t, n) {
    var s, i, r;
    if (this._monthsParseExact) return function(e, t, n) {
      var s, i, r, a = e.toLocaleLowerCase();
      if (!this._monthsParse)
        for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s) r = l([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase();
      return n ? "MMM" === t ? -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : null : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : null : "MMM" === t ? -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : null : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : null
    }.call(this, e, t, n);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
      if (i = l([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s;
      if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s;
      if (!n && this._monthsParse[s].test(e)) return s
    }
  }, kn.monthsRegex = function(e) {
    return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (o(this, "_monthsRegex") || (this._monthsRegex = It), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
  }, kn.monthsShortRegex = function(e) {
    return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (o(this, "_monthsShortRegex") || (this._monthsShortRegex = Et), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
  }, kn.week = function(e) {
    return X(e, this._week.dow, this._week.doy).week
  }, kn.firstDayOfYear = function() {
    return this._week.doy
  }, kn.firstDayOfWeek = function() {
    return this._week.dow
  }, kn.weekdays = function(e, n) {
    return e ? t(this._weekdays) ? this._weekdays[e.day()] : this._weekdays[this._weekdays.isFormat.test(n) ? "format" : "standalone"][e.day()] : t(this._weekdays) ? this._weekdays : this._weekdays.standalone
  }, kn.weekdaysMin = function(e) {
    return e ? this._weekdaysMin[e.day()] : this._weekdaysMin
  }, kn.weekdaysShort = function(e) {
    return e ? this._weekdaysShort[e.day()] : this._weekdaysShort
  }, kn.weekdaysParse = function(e, t, n) {
    var s, i, r;
    if (this._weekdaysParseExact) return function(e, t, n) {
      var s, i, r, a = e.toLocaleLowerCase();
      if (!this._weekdaysParse)
        for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s) r = l([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase();
      return n ? "dddd" === t ? -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : null : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : "dddd" === t ? -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : null
    }.call(this, e, t, n);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
      if (i = l([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[s] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s;
      if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s;
      if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s;
      if (!n && this._weekdaysParse[s].test(e)) return s
    }
  }, kn.weekdaysRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (o(this, "_weekdaysRegex") || (this._weekdaysRegex = zt), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
  }, kn.weekdaysShortRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (o(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = $t), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
  }, kn.weekdaysMinRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (o(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = qt), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
  }, kn.isPM = function(e) {
    return "p" === (e + "").toLowerCase().charAt(0)
  }, kn.meridiem = function(e, t, n) {
    return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
  }, ae("en", {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(e) {
      var t = e % 10;
      return e + (1 === g(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
    }
  }), e.lang = v("moment.lang is deprecated. Use moment.locale instead.", ae), e.langData = v("moment.langData is deprecated. Use moment.localeData instead.", ue);
  var Yn = Math.abs,
    On = $e("ms"),
    Tn = $e("s"),
    xn = $e("m"),
    bn = $e("h"),
    Pn = $e("d"),
    Wn = $e("w"),
    Hn = $e("M"),
    Rn = $e("y"),
    Cn = qe("milliseconds"),
    Fn = qe("seconds"),
    Un = qe("minutes"),
    Ln = qe("hours"),
    Nn = qe("days"),
    Gn = qe("months"),
    Vn = qe("years"),
    En = Math.round,
    In = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    },
    An = Math.abs,
    jn = ve.prototype;
  return jn.isValid = function() {
      return this._isValid
    }, jn.abs = function() {
      var e = this._data;
      return this._milliseconds = Yn(this._milliseconds), this._days = Yn(this._days), this._months = Yn(this._months), e.milliseconds = Yn(e.milliseconds), e.seconds = Yn(e.seconds), e.minutes = Yn(e.minutes), e.hours = Yn(e.hours), e.months = Yn(e.months), e.years = Yn(e.years), this
    }, jn.add = function(e, t) {
      return Ae(this, e, t, 1)
    }, jn.subtract = function(e, t) {
      return Ae(this, e, t, -1)
    }, jn.as = function(e) {
      if (!this.isValid()) return NaN;
      var t, n, s = this._milliseconds;
      if ("month" === (e = O(e)) || "year" === e) return t = this._days + s / 864e5, n = this._months + Ze(t), "month" === e ? n : n / 12;
      switch (t = this._days + Math.round(ze(this._months)), e) {
        case "week":
          return t / 7 + s / 6048e5;
        case "day":
          return t + s / 864e5;
        case "hour":
          return 24 * t + s / 36e5;
        case "minute":
          return 1440 * t + s / 6e4;
        case "second":
          return 86400 * t + s / 1e3;
        case "millisecond":
          return Math.floor(864e5 * t) + s;
        default:
          throw new Error("Unknown unit " + e)
      }
    }, jn.asMilliseconds = On, jn.asSeconds = Tn, jn.asMinutes = xn, jn.asHours = bn, jn.asDays = Pn, jn.asWeeks = Wn, jn.asMonths = Hn, jn.asYears = Rn, jn.valueOf = function() {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN
    }, jn._bubble = function() {
      var e, t, n, s, i, r = this._milliseconds,
        a = this._days,
        o = this._months,
        u = this._data;
      return r >= 0 && a >= 0 && o >= 0 || r <= 0 && a <= 0 && o <= 0 || (r += 864e5 * je(ze(o) + a), a = 0, o = 0), u.milliseconds = r % 1e3, e = y(r / 1e3), u.seconds = e % 60, t = y(e / 60), u.minutes = t % 60, n = y(t / 60), u.hours = n % 24, a += y(n / 24), i = y(Ze(a)), o += i, a -= je(ze(i)), s = y(o / 12), o %= 12, u.days = a, u.months = o, u.years = s, this
    }, jn.clone = function() {
      return xe(this)
    }, jn.get = function(e) {
      return e = O(e), this.isValid() ? this[e + "s"]() : NaN
    }, jn.milliseconds = Cn, jn.seconds = Fn, jn.minutes = Un, jn.hours = Ln, jn.days = Nn, jn.weeks = function() {
      return y(this.days() / 7)
    }, jn.months = Gn, jn.years = Vn, jn.humanize = function(e) {
      if (!this.isValid()) return this.localeData().invalidDate();
      var t = this.localeData(),
        n = function(e, t, n) {
          var s = xe(e).abs(),
            i = En(s.as("s")),
            r = En(s.as("m")),
            a = En(s.as("h")),
            o = En(s.as("d")),
            u = En(s.as("M")),
            l = En(s.as("y")),
            d = i <= In.ss && ["s", i] || i < In.s && ["ss", i] || r <= 1 && ["m"] || r < In.m && ["mm", r] || a <= 1 && ["h"] || a < In.h && ["hh", a] || o <= 1 && ["d"] || o < In.d && ["dd", o] || u <= 1 && ["M"] || u < In.M && ["MM", u] || l <= 1 && ["y"] || ["yy", l];
          return d[2] = t, d[3] = +e > 0, d[4] = n,
            function(e, t, n, s, i) {
              return i.relativeTime(t || 1, !!n, e, s)
            }.apply(null, d)
        }(this, !e, t);
      return e && (n = t.pastFuture(+this, n)), t.postformat(n)
    }, jn.toISOString = Be, jn.toString = Be, jn.toJSON = Be, jn.locale = Ce, jn.localeData = Fe, jn.toIsoString = v("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Be), jn.lang = gn, P("X", 0, 0, "unix"), P("x", 0, 0, "valueOf"), C("x", Mt), C("X", /[+-]?\d+(\.\d{1,3})?/), L("X", function(e, t, n) {
      n._d = new Date(1e3 * parseFloat(e, 10))
    }), L("x", function(e, t, n) {
      n._d = new Date(g(e))
    }), e.version = "2.20.1",
    function(e) {
      Qe = e
    }(pe), e.fn = Dn, e.min = function() {
      return we("isBefore", [].slice.call(arguments, 0))
    }, e.max = function() {
      return we("isAfter", [].slice.call(arguments, 0))
    }, e.now = function() {
      return Date.now ? Date.now() : +new Date
    }, e.utc = l, e.unix = function(e) {
      return pe(1e3 * e)
    }, e.months = function(e, t) {
      return Ee(e, t, "months")
    }, e.isDate = r, e.locale = ae, e.invalid = c, e.duration = xe, e.isMoment = _, e.weekdays = function(e, t, n) {
      return Ie(e, t, n, "weekdays")
    }, e.parseZone = function() {
      return pe.apply(null, arguments).parseZone()
    }, e.localeData = ue, e.isDuration = Me, e.monthsShort = function(e, t) {
      return Ee(e, t, "monthsShort")
    }, e.weekdaysMin = function(e, t, n) {
      return Ie(e, t, n, "weekdaysMin")
    }, e.defineLocale = oe, e.updateLocale = function(e, t) {
      if (null != t) {
        var n, s, i = Qt;
        null != (s = re(e)) && (i = s._config), (n = new k(t = D(i, t))).parentLocale = Xt[e], Xt[e] = n, ae(e)
      } else null != Xt[e] && (null != Xt[e].parentLocale ? Xt[e] = Xt[e].parentLocale : null != Xt[e] && delete Xt[e]);
      return Xt[e]
    }, e.locales = function() {
      return nt(Xt)
    }, e.weekdaysShort = function(e, t, n) {
      return Ie(e, t, n, "weekdaysShort")
    }, e.normalizeUnits = O, e.relativeTimeRounding = function(e) {
      return void 0 === e ? En : "function" == typeof e && (En = e, !0)
    }, e.relativeTimeThreshold = function(e, t) {
      return void 0 !== In[e] && (void 0 === t ? In[e] : (In[e] = t, "s" === e && (In.ss = t - 1), !0))
    }, e.calendarFormat = function(e, t) {
      var n = e.diff(t, "days", !0);
      return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
    }, e.prototype = Dn, e.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "YYYY-[W]WW",
      MONTH: "YYYY-MM"
    }, e
});
/*! RESOURCE: /scripts/reportlibs/fullcalendar.min.js */
/*!
 * FullCalendar v2.2.7
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2013 Adam Shaw
 * (c) 2015 Tanguy Pruvot
 * The minimized version which we use is based on this customized version
 */
! function(t) {
  "function" == typeof define && define.amd ? define(["jquery", "moment"], t) : t(jQuery, moment)
}(function(t, e) {
  function n(t) {
    i(St, t)
  }

  function i(e) {
    function n(n, s) {
      t.isPlainObject(s) && t.isPlainObject(e[n]) && !r(n) ? e[n] = i({}, e[n], s) : void 0 !== s && (e[n] = s)
    }
    for (var s = 1; s < arguments.length; s++) t.each(arguments[s], n);
    return e
  }

  function r(t) {
    return /(Time|Duration)$/.test(t)
  }

  function s(t) {
    var n = e.localeData || e.langData;
    return n.call(e, t) || n.call(e, "en")
  }

  function o(t, e) {
    e.left && t.css({
      "border-left-width": 1,
      "margin-left": e.left - 1
    }), e.right && t.css({
      "border-right-width": 1,
      "margin-right": e.right - 1
    })
  }

  function a(t) {
    t.css({
      "margin-left": "",
      "margin-right": "",
      "border-left-width": "",
      "border-right-width": ""
    })
  }

  function l() {
    t("body").addClass("fc-not-allowed")
  }

  function d() {
    t("body").removeClass("fc-not-allowed")
  }

  function u(e, n, i) {
    var r = Math.floor(n / e.length),
      s = Math.floor(n - r * (e.length - 1)),
      o = [],
      a = [],
      l = [],
      d = 0;
    c(e), e.each(function(n, i) {
      var u = n === e.length - 1 ? s : r,
        c = t(i).outerHeight(!0);
      u > c ? (o.push(i), a.push(c), l.push(t(i).height())) : d += c
    }), i && (n -= d, r = Math.floor(n / o.length), s = Math.floor(n - r * (o.length - 1))), t(o).each(function(e, n) {
      var i = e === o.length - 1 ? s : r,
        d = a[e],
        u = l[e],
        c = i - (d - u);
      i > d && t(n).height(c)
    })
  }

  function c(t) {
    t.height("")
  }

  function h(e) {
    var n = 0;
    return e.find("> *").each(function(e, i) {
      var r = t(i).outerWidth();
      r > n && (n = r)
    }), n++, e.width(n), n
  }

  function f(t, e) {
    return t.height(e).addClass("fc-scroller"), t[0].scrollHeight - 1 > t[0].clientHeight ? !0 : (g(t), !1)
  }

  function g(t) {
    t.height("").removeClass("fc-scroller")
  }

  function p(e) {
    var n = e.css("position"),
      i = e.parents().filter(function() {
        var e = t(this);
        return /(auto|scroll)/.test(e.css("overflow") + e.css("overflow-y") + e.css("overflow-x"))
      }).eq(0);
    return "fixed" !== n && i.length ? i : t(e[0].ownerDocument || document)
  }

  function m(t) {
    var e = t.offset().left,
      n = e + t.width(),
      i = t.children(),
      r = i.offset().left,
      s = r + i.outerWidth();
    return {
      left: r - e,
      right: n - s
    }
  }

  function v(t) {
    return 1 == t.which && !t.ctrlKey
  }

  function y(t, e) {
    var n, i, r, s, o = t.start,
      a = t.end,
      l = e.start,
      d = e.end;
    return a > l && d > o ? (o >= l ? (n = o.clone(), r = !0) : (n = l.clone(), r = !1), d >= a ? (i = a.clone(), s = !0) : (i = d.clone(), s = !1), {
      start: n,
      end: i,
      isStart: r,
      isEnd: s
    }) : void 0
  }

  function w(t, e) {
    if (t = t || {}, void 0 !== t[e]) return t[e];
    for (var n, i = e.split(/(?=[A-Z])/), r = i.length - 1; r >= 0; r--)
      if (n = t[i[r].toLowerCase()], void 0 !== n) return n;
    return t["default"]
  }

  function b(t, n) {
    return e.duration({
      days: t.clone().stripTime().diff(n.clone().stripTime(), "days"),
      ms: t.time() - n.time()
    })
  }

  function S(t, n) {
    return e.duration({
      days: t.clone().stripTime().diff(n.clone().stripTime(), "days")
    })
  }

  function E(t, e) {
    var n, i, r;
    for (n = 0; n < Nt.length && (i = Nt[n], r = C(i, t, e), !(r >= 1 && L(r))); n++);
    return i
  }

  function C(t, n, i) {
    return null != i ? i.diff(n, t, !0) : e.isDuration(n) ? n.as(t) : n.end.diff(n.start, t, !0)
  }

  function D(t) {
    return "[object Date]" === Object.prototype.toString.call(t) || t instanceof Date
  }

  function T(t) {
    return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(t)
  }

  function k(t) {
    var e = function() {};
    return e.prototype = t, new e
  }

  function H(t, e) {
    for (var n in t) R(t, n) && (e[n] = t[n])
  }

  function x(t, e) {
    var n, i, r = ["constructor", "toString", "valueOf"];
    for (n = 0; n < r.length; n++) i = r[n], t[i] !== Object.prototype[i] && (e[i] = t[i])
  }

  function R(t, e) {
    return Vt.call(t, e)
  }

  function M(e) {
    return /undefined|null|boolean|number|string/.test(t.type(e))
  }

  function F(e, n, i) {
    if (t.isFunction(e) && (e = [e]), e) {
      var r, s;
      for (r = 0; r < e.length; r++) s = e[r].apply(n, i) || s;
      return s
    }
  }

  function G() {
    for (var t = 0; t < arguments.length; t++)
      if (void 0 !== arguments[t]) return arguments[t]
  }

  function N(t) {
    return (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#039;").replace(/"/g, "&quot;").replace(/\n/g, "<br />")
  }

  function V(t) {
    return t.replace(/&.*?;/g, "")
  }

  function Y(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
  }

  function z(t, e) {
    return t - e
  }

  function L(t) {
    return t % 1 === 0
  }

  function _(t, e) {
    var n, i, r, s, o = function() {
      var a = +new Date - s;
      e > a && a > 0 ? n = setTimeout(o, e - a) : (n = null, t.apply(r, i), n || (r = i = null))
    };
    return function() {
      r = this, i = arguments, s = +new Date, n || (n = setTimeout(o, e))
    }
  }

  function P(n, i, r) {
    var s, o, a, l, d = n[0],
      u = 1 == n.length && "string" == typeof d;
    return e.isMoment(d) ? (l = e.apply(null, n), O(d, l)) : D(d) || void 0 === d ? l = e.apply(null, n) : (s = !1, o = !1, u ? Yt.test(d) ? (d += "-01", n = [d], s = !0, o = !0) : (a = zt.exec(d)) && (s = !a[5], o = !0) : t.isArray(d) && (o = !0), l = i || s ? e.utc.apply(e, n) : e.apply(null, n), s ? (l._ambigTime = !0, l._ambigZone = !0) : r && (o ? l._ambigZone = !0 : u && l.zone(d))), l._fullCalendar = !0, l
  }

  function A(t, n) {
    var i, r, s = !1,
      o = !1,
      a = t.length,
      l = [];
    for (i = 0; a > i; i++) r = t[i], e.isMoment(r) || (r = Dt.moment.parseZone(r)), s = s || r._ambigTime, o = o || r._ambigZone, l.push(r);
    for (i = 0; a > i; i++) r = l[i], n || !s || r._ambigTime ? o && !r._ambigZone && (l[i] = r.clone().stripZone()) : l[i] = r.clone().stripTime();
    return l
  }

  function O(t, e) {
    t._ambigTime ? e._ambigTime = !0 : e._ambigTime && (e._ambigTime = !1), t._ambigZone ? e._ambigZone = !0 : e._ambigZone && (e._ambigZone = !1)
  }

  function B(t, e) {
    t.year(e[0] || 0).month(e[1] || 0).date(e[2] || 0).hours(e[3] || 0).minutes(e[4] || 0).seconds(e[5] || 0).milliseconds(e[6] || 0)
  }

  function W(t, e) {
    return _t.format.call(t, e)
  }

  function I(t, e) {
    return Z(t, q(e))
  }

  function Z(t, e) {
    var n, i = "";
    for (n = 0; n < e.length; n++) i += j(t, e[n]);
    return i
  }

  function j(t, e) {
    var n, i;
    return "string" == typeof e ? e : (n = e.token) ? Pt[n] ? Pt[n](t) : W(t, n) : e.maybe && (i = Z(t, e.maybe), i.match(/[1-9]/)) ? i : ""
  }

  function X(t, e, n, i, r) {
    var s;
    return t = Dt.moment.parseZone(t), e = Dt.moment.parseZone(e), s = (t.localeData || t.lang).call(t), n = s.longDateFormat(n) || n, i = i || " - ", U(t, e, q(n), i, r)
  }

  function U(t, e, n, i, r) {
    var s, o, a, l, d = "",
      u = "",
      c = "",
      h = "",
      f = "";
    for (o = 0; o < n.length && (s = $(t, e, n[o]), s !== !1); o++) d += s;
    for (a = n.length - 1; a > o && (s = $(t, e, n[a]), s !== !1); a--) u = s + u;
    for (l = o; a >= l; l++) c += j(t, n[l]), h += j(e, n[l]);
    return (c || h) && (f = r ? h + i + c : c + i + h), d + f + u
  }

  function $(t, e, n) {
    var i, r;
    return "string" == typeof n ? n : (i = n.token) && (r = At[i.charAt(0)], r && t.isSame(e, r)) ? W(t, i) : !1
  }

  function q(t) {
    return t in Ot ? Ot[t] : Ot[t] = K(t)
  }

  function K(t) {
    for (var e, n = [], i = /\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g; e = i.exec(t);) e[1] ? n.push(e[1]) : e[2] ? n.push({
      maybe: K(e[2])
    }) : e[3] ? n.push({
      token: e[3]
    }) : e[5] && n.push(e[5]);
    return n
  }

  function Q() {}

  function J(t, e) {
    return t || e ? t && e ? t.grid === e.grid && t.row === e.row && t.col === e.col : !1 : !0
  }

  function tt(t) {
    var e = nt(t);
    return "background" === e || "inverse-background" === e
  }

  function et(t) {
    return "inverse-background" === nt(t)
  }

  function nt(t) {
    return G((t.source || {}).rendering, t.rendering)
  }

  function it(t) {
    var e, n, i = {};
    for (e = 0; e < t.length; e++) n = t[e], (i[n._id] || (i[n._id] = [])).push(n);
    return i
  }

  function rt(t, e) {
    return t.eventStartMS - e.eventStartMS
  }

  function st(t, e) {
    return t.eventStartMS - e.eventStartMS || e.eventDurationMS - t.eventDurationMS || e.event.allDay - t.event.allDay || (t.event.title || "").localeCompare(e.event.title)
  }

  function ot(n) {
    var i, r, s, o, a = Dt.dataAttrPrefix;
    return a && (a += "-"), i = n.data(a + "event") || null, i && (i = "object" == typeof i ? t.extend({}, i) : {}, r = i.start, null == r && (r = i.time), s = i.duration, o = i.stick, delete i.start, delete i.time, delete i.duration, delete i.stick), null == r && (r = n.data(a + "start")), null == r && (r = n.data(a + "time")), null == s && (s = n.data(a + "duration")), null == o && (o = n.data(a + "stick")), r = null != r ? e.duration(r) : null, s = null != s ? e.duration(s) : null, o = Boolean(o), {
      eventProps: i,
      startTime: r,
      duration: s,
      stick: o
    }
  }

  function at(t, e) {
    var n, i;
    for (n = 0; n < e.length; n++)
      if (i = e[n], i.leftCol <= t.rightCol && i.rightCol >= t.leftCol) return !0;
    return !1
  }

  function lt(t, e) {
    return t.leftCol - e.leftCol
  }

  function dt(t) {
    var e, n, i;
    if (t.sort(st), e = ut(t), ct(e), n = e[0]) {
      for (i = 0; i < n.length; i++) ht(n[i]);
      for (i = 0; i < n.length; i++) ft(n[i], 0, 0)
    }
  }

  function ut(t) {
    var e, n, i, r = [];
    for (e = 0; e < t.length; e++) {
      for (n = t[e], i = 0; i < r.length && gt(n, r[i]).length; i++);
      n.level = i, (r[i] || (r[i] = [])).push(n)
    }
    return r
  }

  function ct(t) {
    var e, n, i, r, s;
    for (e = 0; e < t.length; e++)
      for (n = t[e], i = 0; i < n.length; i++)
        for (r = n[i], r.forwardSegs = [], s = e + 1; s < t.length; s++) gt(r, t[s], r.forwardSegs)
  }

  function ht(t) {
    var e, n, i = t.forwardSegs,
      r = 0;
    if (void 0 === t.forwardPressure) {
      for (e = 0; e < i.length; e++) n = i[e], ht(n), r = Math.max(r, 1 + n.forwardPressure);
      t.forwardPressure = r
    }
  }

  function ft(t, e, n) {
    var i, r = t.forwardSegs;
    if (void 0 === t.forwardCoord)
      for (r.length ? (r.sort(mt), ft(r[0], e + 1, n), t.forwardCoord = r[0].backwardCoord) : t.forwardCoord = 1, t.backwardCoord = t.forwardCoord - (t.forwardCoord - n) / (e + 1), i = 0; i < r.length; i++) ft(r[i], 0, t.forwardCoord)
  }

  function gt(t, e, n) {
    n = n || [];
    for (var i = 0; i < e.length; i++) pt(t, e[i]) && n.push(e[i]);
    return n
  }

  function pt(t, e) {
    return t.bottom > e.top && t.top < e.bottom
  }

  function mt(t, e) {
    return e.forwardPressure - t.forwardPressure || (t.backwardCoord || 0) - (e.backwardCoord || 0) || st(t, e)
  }

  function vt(n, r) {
    function o(t) {
      return (t.locale || t.lang).call(t, Q.lang).humanize()
    }

    function a(t) {
      it ? u() && (v(), c(t)) : l()
    }

    function l() {
      rt = Q.theme ? "ui" : "fc", n.addClass("fc"), Q.isRTL ? n.addClass("fc-rtl") : n.addClass("fc-ltr"), Q.theme ? n.addClass("ui-widget") : n.addClass("fc-unthemed"), it = t("<div class='fc-view-container'/>").prependTo(n), et = new yt(q, Q), nt = et.render(), nt && n.prepend(nt), c(Q.defaultView), Q.handleWindowResize && (at = _(w, Q.windowResizeDelay), t(window).resize(at))
    }

    function d() {
      st && st.destroyView(), et.destroy(), it.remove(), n.removeClass("fc fc-ltr fc-rtl fc-unthemed ui-widget"), t(window).unbind("resize", at)
    }

    function u() {
      return n.is(":visible")
    }

    function c(e) {
      ft++, st && e && st.type !== e && (et.deactivateButton(st.type), I(), st.start && st.destroyView(), st.el.remove(), st = null), !st && e && (st = h(e), st.el = t("<div class='fc-view fc-" + e + "-view' />").appendTo(it), et.activateButton(e)), st && (lt = st.massageCurrentDate(lt), st.start && lt.isWithin(st.intervalStart, st.intervalEnd) || u() && (I(), st.start && st.destroyView(), st.setDate(lt), st.renderView(), Z(), R(), M(), D())), Z(), ft--
    }

    function h(t) {
      var e = f(t);
      return new e["class"](q, e.options, t)
    }

    function f(n) {
      function i(e) {
        "function" == typeof e ? s = e : "object" == typeof e && t.extend(r, e)
      }
      var r, s, a, l, d, u = Q.defaultButtonText || {},
        c = Q.buttonText || {},
        h = Q.views || {},
        f = n,
        g = [],
        p = !1;
      if (ht[n]) return ht[n];
      for (; f && !s;) r = {}, i(Tt[f]), i(h[f]), g.unshift(r), f = r.type;
      return g.unshift({}), r = t.extend.apply(t, g), s ? (a = r.duration || s.duration, a && (a = e.duration(a), l = E(a), p = 1 === a.as(l)), p && h[l] && (r = t.extend({}, h[l], r)), d = c[n] || (p ? c[l] : null) || u[n] || (p ? u[l] : null) || r.buttonText || s.buttonText || (a ? o(a) : null) || n, ht[n] = {
        "class": s,
        options: r,
        buttonText: d
      }) : void 0
    }

    function g(t) {
      return Boolean(f(t))
    }

    function p(t) {
      var e = f(t);
      return e ? e.buttonText : void 0
    }

    function m(t) {
      return u() ? (t && y(), ft++, st.updateSize(!0), ft--, !0) : void 0
    }

    function v() {
      u() && y()
    }

    function y() {
      ot = "number" == typeof Q.contentHeight ? Q.contentHeight : "number" == typeof Q.height ? Q.height - (nt ? nt.outerHeight(!0) : 0) : Math.round(it.width() / Math.max(Q.aspectRatio, .5))
    }

    function w(t) {
      !ft && t.target === window && st.start && m(!0) && st.trigger("windowResize", ct)
    }

    function b() {
      C(), T()
    }

    function S() {
      u() && (I(), st.destroyViewEvents(), st.renderViewEvents(gt), Z())
    }

    function C() {
      I(), st.destroyViewEvents(), Z()
    }

    function D() {
      !Q.lazyFetching || dt(st.start, st.end) ? T() : S()
    }

    function T() {
      ut(st.start, st.end)
    }

    function H(t) {
      gt = t, S()
    }

    function x() {
      S()
    }

    function R() {
      et.updateTitle(st.title)
    }

    function M() {
      var t = q.getNow();
      t.isWithin(st.intervalStart, st.intervalEnd) ? et.disableButton("today") : et.enableButton("today")
    }

    function F(t, e) {
      t = q.moment(t), e = e ? q.moment(e) : t.hasTime() ? t.clone().add(q.defaultTimedEventDuration) : t.clone().add(q.defaultAllDayEventDuration), st.select({
        start: t,
        end: e
      })
    }

    function G() {
      st && st.unselect()
    }

    function N() {
      lt = st.computePrevDate(lt), c()
    }

    function V() {
      lt = st.computeNextDate(lt), c()
    }

    function z() {
      lt.add(-1, "years"), c()
    }

    function L() {
      lt.add(1, "years"), c()
    }

    function P() {
      lt = q.getNow(), c()
    }

    function A(t) {
      lt = q.moment(t), c()
    }

    function O(t) {
      lt.add(e.duration(t)), c()
    }

    function B(t, e) {
      var n, i;
      e && g(e) || (e = e || "day", n = et.getViewsWithButtons().join(" "), i = n.match(new RegExp("\\w+" + Y(e))), i || (i = n.match(/\w+Day/)), e = i ? i[0] : "agendaDay"), lt = t, c(e)
    }

    function W() {
      return lt.clone()
    }

    function I() {
      it.css({
        width: "100%",
        height: it.height(),
        overflow: "hidden"
      })
    }

    function Z() {
      it.css({
        width: "",
        height: "",
        overflow: ""
      })
    }

    function j() {
      return q
    }

    function X() {
      return st
    }

    function U(t, e) {
      return void 0 === e ? Q[t] : void(("height" == t || "contentHeight" == t || "aspectRatio" == t) && (Q[t] = e, m(!0)))
    }

    function $(t, e) {
      return Q[t] ? Q[t].apply(e || ct, Array.prototype.slice.call(arguments, 2)) : void 0
    }
    var q = this;
    r = r || {};
    var K, Q = i({}, St, r);
    K = Q.lang in kt ? kt[Q.lang] : kt[St.lang], K && (Q = i({}, St, K, r)), Q.isRTL && (Q = i({}, St, Ct, K || {}, r)), q.options = Q, q.render = a, q.destroy = d, q.refetchEvents = b, q.reportEvents = H, q.reportEventChange = x, q.rerenderEvents = S, q.changeView = c, q.select = F, q.unselect = G, q.prev = N, q.next = V, q.prevYear = z, q.nextYear = L, q.today = P, q.gotoDate = A, q.incrementDate = O, q.zoomTo = B, q.getDate = W, q.getCalendar = j, q.getView = X, q.option = U, q.trigger = $, q.isValidViewType = g, q.getViewButtonText = p;
    var J = k(s(Q.lang));
    if (Q.monthNames && (J._months = Q.monthNames), Q.monthNamesShort && (J._monthsShort = Q.monthNamesShort), Q.dayNames && (J._weekdays = Q.dayNames), Q.dayNamesShort && (J._weekdaysShort = Q.dayNamesShort), null != Q.firstDay) {
      var tt = k(J._week);
      tt.dow = Q.firstDay, J._week = tt
    }
    q.defaultAllDayEventDuration = e.duration(Q.defaultAllDayEventDuration), q.defaultTimedEventDuration = e.duration(Q.defaultTimedEventDuration), q.moment = function() {
      var t;
      return "local" === Q.timezone ? (t = Dt.moment.apply(null, arguments), t.hasTime() && t.local()) : t = "UTC" === Q.timezone ? Dt.moment.utc.apply(null, arguments) : Dt.moment.parseZone.apply(null, arguments), "_locale" in t ? t._locale = J : t._lang = J, t
    }, q.getIsAmbigTimezone = function() {
      return "local" !== Q.timezone && "UTC" !== Q.timezone
    }, q.rezoneDate = function(t) {
      return q.moment(t.toArray())
    }, q.getNow = function() {
      var t = Q.now;
      return "function" == typeof t && (t = t()), q.moment(t)
    }, q.calculateWeekNumber = function(t) {
      var e = Q.weekNumberCalculation;
      return "function" == typeof e ? e(t) : "local" === e ? t.week() : "ISO" === e.toUpperCase() ? t.isoWeek() : void 0
    }, q.getEventEnd = function(t) {
      return t.end ? t.end.clone() : q.getDefaultEventEnd(t.allDay, t.start)
    }, q.getDefaultEventEnd = function(t, e) {
      var n = e.clone();
      return t ? n.stripTime().add(q.defaultAllDayEventDuration) : n.add(q.defaultTimedEventDuration), q.getIsAmbigTimezone() && n.stripZone(), n
    }, wt.call(q, Q);
    var et, nt, it, rt, st, ot, at, lt, dt = q.isFetchNeeded,
      ut = q.fetchEvents,
      ct = n[0],
      ht = {},
      ft = 0,
      gt = [];
    lt = null != Q.defaultDate ? q.moment(Q.defaultDate) : q.getNow(), q.getSuggestedViewHeight = function() {
      return void 0 === ot && v(), ot
    }, q.isHeightAuto = function() {
      return "auto" === Q.contentHeight || "auto" === Q.height
    }
  }

  function yt(e, n) {
    function i() {
      var e = n.header;
      return f = n.theme ? "ui" : "fc", e ? g = t("<div class='fc-toolbar'/>").append(s("left")).append(s("right")).append(s("center")).append('<div class="fc-clear"/>') : void 0
    }

    function r() {
      g.remove()
    }

    function s(i) {
      var r = t('<div class="fc-' + i + '"/>'),
        s = n.header[i];
      return s && t.each(s.split(" "), function(i) {
        var s, o = t(),
          a = !0;
        t.each(this.split(","), function(i, r) {
          var s, l, d, u, c, h, g, m, v;
          "title" == r ? (o = o.add(t("<h2>&nbsp;</h2>")), a = !1) : (e[r] ? s = function() {
            e[r]()
          } : e.isValidViewType(r) && (s = function() {
            e.changeView(r)
          }, p.push(r), c = e.getViewButtonText(r)), s && (l = w(n.themeButtonIcons, r), d = w(n.buttonIcons, r), u = w(n.defaultButtonText, r), h = w(n.buttonText, r), g = c || h ? N(c || h) : l && n.theme ? "<span class='ui-icon ui-icon-" + l + "'></span>" : d && !n.theme ? "<span class='fc-icon fc-icon-" + d + "'></span>" : N(u || r), m = ["fc-" + r + "-button", f + "-button", f + "-state-default"], v = t('<button type="button" class="' + m.join(" ") + '">' + g + "</button>").click(function() {
            v.hasClass(f + "-state-disabled") || (s(), (v.hasClass(f + "-state-active") || v.hasClass(f + "-state-disabled")) && v.removeClass(f + "-state-hover"))
          }).mousedown(function() {
            v.not("." + f + "-state-active").not("." + f + "-state-disabled").addClass(f + "-state-down")
          }).mouseup(function() {
            v.removeClass(f + "-state-down")
          }).hover(function() {
            v.not("." + f + "-state-active").not("." + f + "-state-disabled").addClass(f + "-state-hover")
          }, function() {
            v.removeClass(f + "-state-hover").removeClass(f + "-state-down")
          }), o = o.add(v)))
        }), a && o.first().addClass(f + "-corner-left").end().last().addClass(f + "-corner-right").end(), o.length > 1 ? (s = t("<div/>"), a && s.addClass("fc-button-group"), s.append(o), r.append(s)) : r.append(o)
      }), r
    }

    function o(t) {
      g.find("h2").text(t)
    }

    function a(t) {
      g.find(".fc-" + t + "-button").addClass(f + "-state-active")
    }

    function l(t) {
      g.find(".fc-" + t + "-button").removeClass(f + "-state-active")
    }

    function d(t) {
      g.find(".fc-" + t + "-button").attr("disabled", "disabled").addClass(f + "-state-disabled")
    }

    function u(t) {
      g.find(".fc-" + t + "-button").removeAttr("disabled").removeClass(f + "-state-disabled")
    }

    function c() {
      return p
    }
    var h = this;
    h.render = i, h.destroy = r, h.updateTitle = o, h.activateButton = a, h.deactivateButton = l, h.disableButton = d, h.enableButton = u, h.getViewsWithButtons = c;
    var f, g = t(),
      p = []
  }

  function wt(n) {
    function i(t, e) {
      return !B || t.clone().stripZone() < B.clone().stripZone() || e.clone().stripZone() > W.clone().stripZone()
    }

    function r(t, e) {
      B = t, W = e, Q = [];
      var n = ++$,
        i = U.length;
      q = i;
      for (var r = 0; i > r; r++) s(U[r], n)
    }

    function s(e, n) {
      o(e, function(i) {
        var r, s, o, a = t.isArray(e.events);
        if (n == $) {
          if (i)
            for (r = 0; r < i.length; r++) s = i[r], o = a ? s : E(s, e), o && Q.push.apply(Q, H(o));
          q--, q || j(Q)
        }
      })
    }

    function o(e, i) {
      var r, s, a = Dt.sourceFetchers;
      for (r = 0; r < a.length; r++) {
        if (s = a[r].call(O, e, B.clone(), W.clone(), n.timezone, i), s === !0) return;
        if ("object" == typeof s) return void o(s, i)
      }
      var l = e.events;
      if (l) t.isFunction(l) ? (y(), l.call(O, B.clone(), W.clone(), n.timezone, function(t) {
        i(t), w()
      })) : t.isArray(l) ? i(l) : i();
      else {
        var d = e.url;
        if (d) {
          var u, c = e.success,
            h = e.error,
            f = e.complete;
          u = t.isFunction(e.data) ? e.data() : e.data;
          var g = t.extend({}, u || {}),
            p = G(e.startParam, n.startParam),
            m = G(e.endParam, n.endParam),
            v = G(e.timezoneParam, n.timezoneParam);
          p && (g[p] = B.format()), m && (g[m] = W.format()), n.timezone && "local" != n.timezone && (g[v] = n.timezone), y(), t.ajax(t.extend({}, Qt, e, {
            data: g,
            success: function(e) {
              e = e || [];
              var n = F(c, this, arguments);
              t.isArray(n) && (e = n), i(e)
            },
            error: function() {
              F(h, this, arguments), i()
            },
            complete: function() {
              F(f, this, arguments), w()
            }
          }))
        } else i()
      }
    }

    function a(t) {
      var e = l(t);
      e && (U.push(e), q++, s(e, $))
    }

    function l(e) {
      var n, i, r = Dt.sourceNormalizers;
      if (t.isFunction(e) || t.isArray(e) ? n = {
          events: e
        } : "string" == typeof e ? n = {
          url: e
        } : "object" == typeof e && (n = t.extend({}, e)), n) {
        for (n.className ? "string" == typeof n.className && (n.className = n.className.split(/\s+/)) : n.className = [], t.isArray(n.events) && (n.origArray = n.events, n.events = t.map(n.events, function(t) {
            return E(t, n)
          })), i = 0; i < r.length; i++) r[i].call(O, n);
        return n
      }
    }

    function d(e) {
      U = t.grep(U, function(t) {
        return !u(t, e)
      }), Q = t.grep(Q, function(t) {
        return !u(t.source, e)
      }), j(Q)
    }

    function u(t, e) {
      return t && e && c(t) == c(e)
    }

    function c(t) {
      return ("object" == typeof t ? t.origArray || t.googleCalendarId || t.url || t.events : null) || t
    }

    function h(t) {
      t.start = O.moment(t.start), t.end ? t.end = O.moment(t.end) : t.end = null, x(t, f(t)), j(Q)
    }

    function f(e) {
      var n = {};
      return t.each(e, function(t, e) {
        g(t) && void 0 !== e && M(e) && (n[t] = e)
      }), n
    }

    function g(t) {
      return !/^_|^(id|allDay|start|end)$/.test(t)
    }

    function p(t, e) {
      var n, i, r, s = E(t);
      if (s) {
        for (n = H(s), i = 0; i < n.length; i++) r = n[i], r.source || (e && (X.events.push(r), r.source = X), Q.push(r));
        return j(Q), n
      }
      return []
    }

    function m(e) {
      var n, i;
      for (null == e ? e = function() {
          return !0
        } : t.isFunction(e) || (n = e + "", e = function(t) {
          return t._id == n
        }), Q = t.grep(Q, e, !0), i = 0; i < U.length; i++) t.isArray(U[i].events) && (U[i].events = t.grep(U[i].events, e, !0));
      j(Q)
    }

    function v(e) {
      return t.isFunction(e) ? t.grep(Q, e) : null != e ? (e += "", t.grep(Q, function(t) {
        return t._id == e
      })) : Q
    }

    function y() {
      K++ || I("loading", null, !0, Z())
    }

    function w() {
      --K || I("loading", null, !1, Z())
    }

    function E(i, r) {
      var s, o, a, l = {};
      if (n.eventDataTransform && (i = n.eventDataTransform(i)), r && r.eventDataTransform && (i = r.eventDataTransform(i)), t.extend(l, i), r && (l.source = r), l._id = i._id || (void 0 === i.id ? "_fc" + Jt++ : i.id + ""), i.className ? "string" == typeof i.className ? l.className = i.className.split(/\s+/) : l.className = i.className : l.className = [], s = i.start || i.date, o = i.end, T(s) && (s = e.duration(s)), T(o) && (o = e.duration(o)), i.dow || e.isDuration(s) || e.isDuration(o)) l.start = s ? e.duration(s) : null, l.end = o ? e.duration(o) : null, l._recurring = !0;
      else {
        if (s && (s = O.moment(s), !s.isValid())) return !1;
        o && (o = O.moment(o), o.isValid() || (o = null)), a = i.allDay, void 0 === a && (a = G(r ? r.allDayDefault : void 0, n.allDayDefault)), C(s, o, a, l)
      }
      return l
    }

    function C(t, e, n, i) {
      i.start = t, i.end = e, i.allDay = n, D(i), bt(i)
    }

    function D(t) {
      null == t.allDay && (t.allDay = !(t.start.hasTime() || t.end && t.end.hasTime())), t.allDay ? (t.start.stripTime(), t.end && t.end.stripTime()) : (t.start.hasTime() || (t.start = O.rezoneDate(t.start)), t.end && !t.end.hasTime() && (t.end = O.rezoneDate(t.end))), t.end && !t.end.isAfter(t.start) && (t.end = null), t.end || (n.forceEventDuration ? t.end = O.getDefaultEventEnd(t.allDay, t.start) : t.end = null)
    }

    function k(t) {
      var e;
      return t.end || (e = t.allDay, null == e && (e = !t.start.hasTime()), t = {
        start: t.start,
        end: O.getDefaultEventEnd(e, t.start)
      }), t
    }

    function H(e, n, i) {
      var r, s, o, a, l, d, u, c, h, f = [];
      if (n = n || B, i = i || W, e)
        if (e._recurring) {
          if (s = e.dow)
            for (r = {}, o = 0; o < s.length; o++) r[s[o]] = !0;
          for (a = n.clone().stripTime(); a.isBefore(i);)(!r || r[a.day()]) && (l = e.start, d = e.end, u = a.clone(), c = null, l && (u = u.time(l)), d && (c = a.clone().time(d)), h = t.extend({}, e), C(u, c, !l && !d, h), f.push(h)), a.add(1, "days")
        } else f.push(e);
      return f
    }

    function x(e, n) {
      var i, r, s, o, a = {};
      return n = n || {}, n.start || (n.start = e.start.clone()), void 0 === n.end && (n.end = e.end ? e.end.clone() : null), null == n.allDay && (n.allDay = e.allDay), D(n), i = null !== e._end && null === n.end, r = n.allDay ? S(n.start, e._start) : b(n.start, e._start), !i && n.end && (s = b(n.end, n.start).subtract(b(e._end || O.getDefaultEventEnd(e._allDay, e._start), e._start))), t.each(n, function(t, e) {
        g(t) && void 0 !== e && (a[t] = e)
      }), o = R(v(e._id), i, n.allDay, r, s, a), {
        dateDelta: r,
        durationDelta: s,
        undo: o
      }
    }

    function R(e, n, i, r, s, o) {
      var a = O.getIsAmbigTimezone(),
        l = [];
      return r && !r.valueOf() && (r = null), s && !s.valueOf() && (s = null), t.each(e, function(e, d) {
          var u, c;
          u = {
            start: d.start.clone(),
            end: d.end ? d.end.clone() : null,
            allDay: d.allDay
          }, t.each(o, function(t) {
            u[t] = d[t]
          }), c = {
            start: d._start,
            end: d._end,
            allDay: d._allDay
          }, n && (c.end = null), c.allDay = i, D(c), r && (c.start.add(r), c.end && c.end.add(r)), s && (c.end || (c.end = O.getDefaultEventEnd(c.allDay, c.start)), c.end.add(s)), a && !c.allDay && (r || s) && (c.start.stripZone(), c.end && c.end.stripZone()), t.extend(d, o, c), bt(d), l.push(function() {
            t.extend(d, u), bt(d)
          })
        }),
        function() {
          for (var t = 0; t < l.length; t++) l[t]()
        }
    }

    function N() {
      var e, i = n.businessHours,
        r = {
          className: "fc-nonbusiness",
          start: "09:00",
          end: "17:00",
          dow: [1, 2, 3, 4, 5],
          rendering: "inverse-background"
        },
        s = O.getView();
      return i && (e = "object" == typeof i ? t.extend({}, r, i) : r), e ? H(E(e), s.start, s.end) : []
    }

    function V(t, e) {
      var i = e.source || {},
        r = G(e.constraint, i.constraint, n.eventConstraint),
        s = G(e.overlap, i.overlap, n.eventOverlap);
      return t = k(t), L(t, r, s, e)
    }

    function Y(t) {
      return L(t, n.selectConstraint, n.selectOverlap)
    }

    function z(e, n) {
      var i, r;
      return n && (i = t.extend({}, n, e), r = H(E(i))[0]), r ? V(e, r) : (e = k(e), Y(e))
    }

    function L(t, e, n, i) {
      var r, s, o, a, l;
      if (t = {
          start: t.start.clone().stripZone(),
          end: t.end.clone().stripZone()
        }, null != e) {
        for (r = _(e), s = !1, o = 0; o < r.length; o++)
          if (P(r[o], t)) {
            s = !0;
            break
          } if (!s) return !1
      }
      for (o = 0; o < Q.length; o++)
        if (a = Q[o], (!i || i._id !== a._id) && A(a, t)) {
          if (n === !1) return !1;
          if ("function" == typeof n && !n(a, i)) return !1;
          if (i) {
            if (l = G(a.overlap, (a.source || {}).overlap), l === !1) return !1;
            if ("function" == typeof l && !l(i, a)) return !1
          }
        } return !0
    }

    function _(t) {
      return "businessHours" === t ? N() : "object" == typeof t ? H(E(t)) : v(t)
    }

    function P(t, e) {
      var n = t.start.clone().stripZone(),
        i = O.getEventEnd(t).stripZone();
      return e.start >= n && e.end <= i
    }

    function A(t, e) {
      var n = t.start.clone().stripZone(),
        i = O.getEventEnd(t).stripZone();
      return e.start < i && e.end > n
    }
    var O = this;
    O.isFetchNeeded = i, O.fetchEvents = r, O.addEventSource = a, O.removeEventSource = d, O.updateEvent = h, O.renderEvent = p, O.removeEvents = m, O.clientEvents = v, O.mutateEvent = x, O.normalizeEventDateProps = D, O.ensureVisibleEventRange = k;
    var B, W, I = O.trigger,
      Z = O.getView,
      j = O.reportEvents,
      X = {
        events: []
      },
      U = [X],
      $ = 0,
      q = 0,
      K = 0,
      Q = [];
    t.each((n.events ? [n.events] : []).concat(n.eventSources || []), function(t, e) {
      var n = l(e);
      n && U.push(n)
    }), O.getBusinessHoursEvents = N, O.isEventRangeAllowed = V, O.isSelectionRangeAllowed = Y, O.isExternalDropRangeAllowed = z
  }

  function bt(t) {
    t._allDay = t.allDay, t._start = t.start.clone(), t._end = t.end ? t.end.clone() : null
  }
  var St = {
      titleRangeSeparator: "  ",
      monthYearFormat: "MMMM YYYY",
      defaultTimedEventDuration: "02:00:00",
      defaultAllDayEventDuration: {
        days: 1
      },
      forceEventDuration: !1,
      nextDayThreshold: "09:00:00",
      defaultView: "month",
      aspectRatio: 1.35,
      header: {
        left: "title",
        center: "",
        right: "today prev,next"
      },
      weekends: !0,
      weekNumbers: !1,
      weekNumberTitle: "W",
      weekNumberCalculation: "local",
      lazyFetching: !0,
      startParam: "start",
      endParam: "end",
      timezoneParam: "timezone",
      timezone: !1,
      minDate: null,
      maxDate: null,
      firstDay: 0,
      yearTitleFormat: "YYYY",
      yearFormat: "YYYY",
      isRTL: !1,
      defaultButtonText: {
        prev: "prev",
        next: "next",
        prevYear: "prev year",
        nextYear: "next year",
        today: "today",
        year: "year",
        month: "month",
        week: "week",
        day: "day"
      },
      buttonIcons: {
        prev: "left-single-arrow",
        next: "right-single-arrow",
        prevYear: "left-double-arrow",
        nextYear: "right-double-arrow"
      },
      theme: !1,
      themeButtonIcons: {
        prev: "circle-triangle-w",
        next: "circle-triangle-e",
        prevYear: "seek-prev",
        nextYear: "seek-next"
      },
      dragOpacity: .75,
      dragRevertDuration: 500,
      dragScroll: !0,
      unselectAuto: !0,
      dropAccept: "*",
      eventLimit: !1,
      eventLimitText: "more",
      eventLimitClick: "popover",
      dayPopoverFormat: "LL",
      handleWindowResize: !0,
      windowResizeDelay: 200
    },
    Et = {
      dayPopoverFormat: "dddd, MMMM D"
    },
    Ct = {
      header: {
        left: "next,prev today",
        center: "",
        right: "title"
      },
      buttonIcons: {
        prev: "right-single-arrow",
        next: "left-single-arrow",
        prevYear: "right-double-arrow",
        nextYear: "left-double-arrow"
      },
      themeButtonIcons: {
        prev: "circle-triangle-e",
        next: "circle-triangle-w",
        nextYear: "seek-prev",
        prevYear: "seek-next"
      }
    },
    Dt = t.fullCalendar = {
      version: "2.2.7"
    },
    Tt = Dt.views = {};
  t.fn.fullCalendar = function(e) {
    var n = Array.prototype.slice.call(arguments, 1),
      i = this;
    return this.each(function(r, s) {
      var o, a = t(s),
        l = a.data("fullCalendar");
      "string" == typeof e ? l && t.isFunction(l[e]) && (o = l[e].apply(l, n), r || (i = o), "destroy" === e && a.removeData("fullCalendar")) : l || (l = new vt(a, e), a.data("fullCalendar", l), l.render())
    }), i
  };
  var kt = Dt.langs = {};
  Dt.datepickerLang = function(e, n, i) {
    var r = kt[e] || (kt[e] = {});
    r.isRTL = i.isRTL, r.weekNumberTitle = i.weekHeader, t.each(Ht, function(t, e) {
      r[t] = e(i)
    }), t.datepicker && (t.datepicker.regional[n] = t.datepicker.regional[e] = i, t.datepicker.regional.en = t.datepicker.regional[""], t.datepicker.setDefaults(i))
  }, Dt.lang = function(e, n) {
    var r, o;
    r = kt[e] || (kt[e] = {}), n && i(r, n), o = s(e), t.each(xt, function(t, e) {
      void 0 === r[t] && (r[t] = e(o, r))
    }), St.lang = e
  };
  var Ht = {
      defaultButtonText: function(t) {
        return {
          prev: V(t.prevText),
          next: V(t.nextText),
          today: V(t.currentText)
        }
      },
      monthYearFormat: function(t) {
        return t.showMonthAfterYear ? "YYYY[" + t.yearSuffix + "] MMMM" : "MMMM YYYY[" + t.yearSuffix + "]"
      }
    },
    xt = {
      dayOfMonthFormat: function(t, e) {
        var n = t.longDateFormat("l");
        return n = n.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, ""), e.isRTL ? n += " ddd" : n = "ddd " + n, n
      },
      smallTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "a")
      },
      extraSmallTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "t")
      },
      noMeridiemTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(/\s*a$/i, "")
      }
    };
  Dt.lang("en", Et), Dt.intersectionToSeg = y, Dt.applyAll = F, Dt.debounce = _;
  var Rt, Mt, Ft, Gt = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"],
    Nt = ["year", "month", "week", "day", "hour", "minute", "second", "millisecond"],
    Vt = {}.hasOwnProperty,
    Yt = /^\s*\d{4}-\d\d$/,
    zt = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/,
    Lt = e.fn,
    _t = t.extend({}, Lt);
  Dt.moment = function() {
    return P(arguments)
  }, Dt.moment.utc = function() {
    var t = P(arguments, !0);
    return t.hasTime() && t.utc(), t
  }, Dt.moment.parseZone = function() {
    return P(arguments, !0, !0)
  }, Lt.clone = function() {
    var t = _t.clone.apply(this, arguments);
    return O(this, t), this._fullCalendar && (t._fullCalendar = !0), t
  }, Lt.time = function(t) {
    if (!this._fullCalendar) return _t.time.apply(this, arguments);
    if (null == t) return e.duration({
      hours: this.hours(),
      minutes: this.minutes(),
      seconds: this.seconds(),
      milliseconds: this.milliseconds()
    });
    this._ambigTime = !1, e.isDuration(t) || e.isMoment(t) || (t = e.duration(t));
    var n = 0;
    return e.isDuration(t) && (n = 24 * Math.floor(t.asDays())), this.hours(n + t.hours()).minutes(t.minutes()).seconds(t.seconds()).milliseconds(t.milliseconds())
  }, Lt.stripTime = function() {
    var t;
    return this._ambigTime || (t = this.toArray(), this.utc(), Mt(this, t.slice(0, 3)), this._ambigTime = !0, this._ambigZone = !0), this
  }, Lt.hasTime = function() {
    return !this._ambigTime
  }, Lt.stripZone = function() {
    var t, e;
    return this._ambigZone || (t = this.toArray(), e = this._ambigTime, this.utc(), Mt(this, t), this._ambigTime = e || !1, this._ambigZone = !0), this
  }, Lt.hasZone = function() {
    return !this._ambigZone
  }, Lt.local = function() {
    var t = this.toArray(),
      e = this._ambigZone;
    return _t.local.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, e && Ft(this, t), this
  }, Lt.utc = function() {
    return _t.utc.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, this
  }, t.each(["zone", "utcOffset"], function(t, e) {
    _t[e] && (Lt[e] = function(t) {
      return null != t && (this._ambigTime = !1, this._ambigZone = !1), _t[e].apply(this, arguments)
    })
  }), Lt.format = function() {
    return this._fullCalendar && arguments[0] ? I(this, arguments[0]) : this._ambigTime ? W(this, "YYYY-MM-DD") : this._ambigZone ? W(this, "YYYY-MM-DD[T]HH:mm:ss") : _t.format.apply(this, arguments)
  }, Lt.toISOString = function() {
    return this._ambigTime ? W(this, "YYYY-MM-DD") : this._ambigZone ? W(this, "YYYY-MM-DD[T]HH:mm:ss") : _t.toISOString.apply(this, arguments)
  }, Lt.isWithin = function(t, e) {
    var n = A([this, t, e]);
    return n[0] >= n[1] && n[0] < n[2]
  }, Lt.isSame = function(t, e) {
    var n;
    return this._fullCalendar ? e ? (n = A([this, t], !0), _t.isSame.call(n[0], n[1], e)) : (t = Dt.moment.parseZone(t), _t.isSame.call(this, t) && Boolean(this._ambigTime) === Boolean(t._ambigTime) && Boolean(this._ambigZone) === Boolean(t._ambigZone)) : _t.isSame.apply(this, arguments)
  }, t.each(["isBefore", "isAfter"], function(t, e) {
    Lt[e] = function(t, n) {
      var i;
      return this._fullCalendar ? (i = A([this, t]), _t[e].call(i[0], i[1], n)) : _t[e].apply(this, arguments)
    }
  }), Rt = "_d" in e() && "updateOffset" in e, Mt = Rt ? function(t, n) {
    t._d.setTime(Date.UTC.apply(Date, n)), e.updateOffset(t, !1)
  } : B, Ft = Rt ? function(t, n) {
    t._d.setTime(+new Date(n[0] || 0, n[1] || 0, n[2] || 0, n[3] || 0, n[4] || 0, n[5] || 0, n[6] || 0)), e.updateOffset(t, !1)
  } : B;
  var Pt = {
    t: function(t) {
      return W(t, "a").charAt(0)
    },
    T: function(t) {
      return W(t, "A").charAt(0)
    }
  };
  Dt.formatRange = X;
  var At = {
      Y: "year",
      M: "month",
      D: "day",
      d: "day",
      A: "second",
      a: "second",
      T: "second",
      t: "second",
      H: "second",
      h: "second",
      m: "second",
      s: "second"
    },
    Ot = {};
  Dt.Class = Q, Q.extend = function(t) {
    var e, n = this;
    return t = t || {}, R(t, "constructor") && (e = t.constructor), "function" != typeof e && (e = t.constructor = function() {
      n.apply(this, arguments)
    }), e.prototype = k(n.prototype), H(t, e.prototype), x(t, e.prototype), H(n, e), e
  }, Q.mixin = function(t) {
    H(t.prototype || t, this.prototype)
  };
  var Bt = Q.extend({
      isHidden: !0,
      options: null,
      el: null,
      documentMousedownProxy: null,
      margin: 10,
      constructor: function(t) {
        this.options = t || {}
      },
      show: function() {
        this.isHidden && (this.el || this.render(), this.el.show(), this.position(), this.isHidden = !1, this.trigger("show"))
      },
      hide: function() {
        this.isHidden || (this.el.hide(), this.isHidden = !0, this.trigger("hide"))
      },
      render: function() {
        var e = this,
          n = this.options;
        this.el = t('<div class="fc-popover"/>').addClass(n.className || "").css({
          top: 0,
          left: 0
        }).append(n.content).appendTo(n.parentEl), this.el.on("click", ".fc-close", function() {
          e.hide()
        }), n.autoHide && t(document).on("mousedown", this.documentMousedownProxy = t.proxy(this, "documentMousedown"))
      },
      documentMousedown: function(e) {
        this.el && !t(e.target).closest(this.el).length && this.hide()
      },
      destroy: function() {
        this.hide(), this.el && (this.el.remove(), this.el = null), t(document).off("mousedown", this.documentMousedownProxy)
      },
      position: function() {
        var e, n, i, r, s, o = this.options,
          a = this.el.offsetParent().offset(),
          l = this.el.outerWidth(),
          d = (this.el.outerHeight(), t(window)),
          u = p(this.el);
        r = o.top || 0, s = void 0 !== o.left ? o.left : void 0 !== o.right ? o.right - l : 0, u.is(window) || u.is(document) ? (u = d, e = 0, n = 0) : (i = u.offset(), e = i.top, n = i.left), e += d.scrollTop(), n += d.scrollLeft(), o.viewportConstrain !== !1 && (s = Math.min(s, n + u.outerWidth() - l - this.margin), s = Math.max(s, n + this.margin)), this.el.css({
          top: r - a.top,
          left: s - a.left
        })
      },
      trigger: function(t) {
        this.options[t] && this.options[t].apply(this, Array.prototype.slice.call(arguments, 1))
      }
    }),
    Wt = Q.extend({
      grid: null,
      rowCoords: null,
      colCoords: null,
      containerEl: null,
      minX: null,
      maxX: null,
      minY: null,
      maxY: null,
      constructor: function(t) {
        this.grid = t
      },
      build: function() {
        this.rowCoords = this.grid.computeRowCoords(), this.colCoords = this.grid.computeColCoords(), this.computeBounds()
      },
      clear: function() {
        this.rowCoords = null, this.colCoords = null
      },
      getCell: function(e, n) {
        var i, r, s = this.rowCoords,
          o = this.colCoords,
          a = null,
          l = null,
          d = null,
          u = this.inBounds(e, n);
        if (!u && "year" == this.grid.view.name) return t.each(this.grid.view.dayGrids, function(t, i) {
          var r = i.coordMap;
          return r.computeBounds(), r.inBounds(e, n) ? (r.build(), d = r.getCell(e, n), !1) : void 0
        }), d;
        for (i = 0; i < s.length; i++)
          if (r = s[i], n >= r.top && n < r.bottom) {
            a = i;
            break
          } for (i = 0; i < o.length; i++)
          if (r = o[i], e >= r.left && e < r.right) {
            l = i;
            break
          } return null !== a && null !== l ? (d = this.grid.getCell(a, l), d.grid = this.grid, d) : null
      },
      computeBounds: function() {
        var t;
        this.containerEl && (t = this.containerEl.offset(), this.minX = t.left, this.maxX = t.left + this.containerEl.outerWidth(), this.minY = t.top, this.maxY = t.top + this.containerEl.outerHeight())
      },
      inBounds: function(t, e) {
        return this.containerEl ? t >= this.minX && t < this.maxX && e >= this.minY && e < this.maxY : !0
      }
    }),
    It = Q.extend({
      coordMaps: null,
      constructor: function(t) {
        this.coordMaps = t
      },
      build: function() {
        var t, e = this.coordMaps;
        for (t = 0; t < e.length; t++) e[t].build()
      },
      getCell: function(t, e) {
        var n, i = this.coordMaps,
          r = null;
        for (n = 0; n < i.length && !r; n++) r = i[n].getCell(t, e);
        return r
      },
      clear: function() {
        var t, e = this.coordMaps;
        for (t = 0; t < e.length; t++) e[t].clear()
      }
    }),
    Zt = Q.extend({
      coordMap: null,
      options: null,
      isListening: !1,
      isDragging: !1,
      origCell: null,
      cell: null,
      mouseX0: null,
      mouseY0: null,
      mousemoveProxy: null,
      mouseupProxy: null,
      scrollEl: null,
      scrollBounds: null,
      scrollTopVel: null,
      scrollLeftVel: null,
      scrollIntervalId: null,
      scrollHandlerProxy: null,
      scrollSensitivity: 30,
      scrollSpeed: 200,
      scrollIntervalMs: 50,
      constructor: function(t, e) {
        this.coordMap = t, this.options = e || {}
      },
      mousedown: function(t) {
        v(t) && (t.preventDefault(), this.startListening(t), this.options.distance || this.startDrag(t))
      },
      startListening: function(e) {
        var n, i;
        this.isListening || (e && this.options.scroll && (n = p(t(e.target)), n.is(window) || n.is(document) || (this.scrollEl = n, this.scrollHandlerProxy = _(t.proxy(this, "scrollHandler"), 100), this.scrollEl.on("scroll", this.scrollHandlerProxy))), this.computeCoords(), e && (i = this.getCell(e), this.origCell = i, this.mouseX0 = e.pageX, this.mouseY0 = e.pageY), t(document).on("mousemove", this.mousemoveProxy = t.proxy(this, "mousemove")).on("mouseup", this.mouseupProxy = t.proxy(this, "mouseup")).on("selectstart", this.preventDefault), this.isListening = !0, this.trigger("listenStart", e))
      },
      computeCoords: function() {
        this.coordMap.build(), this.computeScrollBounds()
      },
      mousemove: function(t) {
        var e, n;
        this.isDragging || (e = this.options.distance || 1, n = Math.pow(t.pageX - this.mouseX0, 2) + Math.pow(t.pageY - this.mouseY0, 2), n >= e * e && this.startDrag(t)), this.isDragging && this.drag(t)
      },
      startDrag: function(t) {
        var e;
        this.isListening || this.startListening(), this.isDragging || (this.isDragging = !0, this.trigger("dragStart", t), e = this.getCell(t), e && this.cellOver(e))
      },
      drag: function(t) {
        var e;
        this.isDragging && (e = this.getCell(t), J(e, this.cell) || (this.cell && this.cellOut(), e && this.cellOver(e)), this.dragScroll(t))
      },
      cellOver: function(t) {
        this.cell = t, this.trigger("cellOver", t, J(t, this.origCell))
      },
      cellOut: function() {
        this.cell && (this.trigger("cellOut", this.cell), this.cell = null)
      },
      mouseup: function(t) {
        this.stopDrag(t), this.stopListening(t)
      },
      stopDrag: function(t) {
        this.isDragging && (this.stopScrolling(), this.trigger("dragStop", t), this.isDragging = !1)
      },
      stopListening: function(e) {
        this.isListening && (this.scrollEl && (this.scrollEl.off("scroll", this.scrollHandlerProxy), this.scrollHandlerProxy = null), t(document).off("mousemove", this.mousemoveProxy).off("mouseup", this.mouseupProxy).off("selectstart", this.preventDefault), this.mousemoveProxy = null, this.mouseupProxy = null, this.isListening = !1, this.trigger("listenStop", e), this.origCell = this.cell = null, this.coordMap.clear())
      },
      getCell: function(t) {
        return this.coordMap.getCell(t.pageX, t.pageY)
      },
      trigger: function(t) {
        this.options[t] && this.options[t].apply(this, Array.prototype.slice.call(arguments, 1))
      },
      preventDefault: function(t) {
        t.preventDefault()
      },
      computeScrollBounds: function() {
        var t, e = this.scrollEl;
        e && (t = e.offset(), this.scrollBounds = {
          top: t.top,
          left: t.left,
          bottom: t.top + e.outerHeight(),
          right: t.left + e.outerWidth()
        })
      },
      dragScroll: function(t) {
        var e, n, i, r, s = this.scrollSensitivity,
          o = this.scrollBounds,
          a = 0,
          l = 0;
        o && (e = (s - (t.pageY - o.top)) / s, n = (s - (o.bottom - t.pageY)) / s, i = (s - (t.pageX - o.left)) / s, r = (s - (o.right - t.pageX)) / s, e >= 0 && 1 >= e ? a = e * this.scrollSpeed * -1 : n >= 0 && 1 >= n && (a = n * this.scrollSpeed), i >= 0 && 1 >= i ? l = i * this.scrollSpeed * -1 : r >= 0 && 1 >= r && (l = r * this.scrollSpeed)), this.setScrollVel(a, l)
      },
      setScrollVel: function(e, n) {
        this.scrollTopVel = e, this.scrollLeftVel = n, this.constrainScrollVel(), !this.scrollTopVel && !this.scrollLeftVel || this.scrollIntervalId || (this.scrollIntervalId = setInterval(t.proxy(this, "scrollIntervalFunc"), this.scrollIntervalMs))
      },
      constrainScrollVel: function() {
        var t = this.scrollEl;
        this.scrollTopVel < 0 ? t.scrollTop() <= 0 && (this.scrollTopVel = 0) : this.scrollTopVel > 0 && t.scrollTop() + t[0].clientHeight >= t[0].scrollHeight && (this.scrollTopVel = 0), this.scrollLeftVel < 0 ? t.scrollLeft() <= 0 && (this.scrollLeftVel = 0) : this.scrollLeftVel > 0 && t.scrollLeft() + t[0].clientWidth >= t[0].scrollWidth && (this.scrollLeftVel = 0)
      },
      scrollIntervalFunc: function() {
        var t = this.scrollEl,
          e = this.scrollIntervalMs / 1e3;
        this.scrollTopVel && t.scrollTop(t.scrollTop() + this.scrollTopVel * e), this.scrollLeftVel && t.scrollLeft(t.scrollLeft() + this.scrollLeftVel * e), this.constrainScrollVel(), this.scrollTopVel || this.scrollLeftVel || this.stopScrolling()
      },
      stopScrolling: function() {
        this.scrollIntervalId && (clearInterval(this.scrollIntervalId), this.scrollIntervalId = null, this.computeCoords())
      },
      scrollHandler: function() {
        this.scrollIntervalId || this.computeCoords()
      }
    }),
    jt = Q.extend({
      options: null,
      sourceEl: null,
      el: null,
      parentEl: null,
      top0: null,
      left0: null,
      mouseY0: null,
      mouseX0: null,
      topDelta: null,
      leftDelta: null,
      mousemoveProxy: null,
      isFollowing: !1,
      isHidden: !1,
      isAnimating: !1,
      constructor: function(e, n) {
        this.options = n = n || {}, this.sourceEl = e, this.parentEl = n.parentEl ? t(n.parentEl) : e.parent()
      },
      start: function(e) {
        this.isFollowing || (this.isFollowing = !0, this.mouseY0 = e.pageY, this.mouseX0 = e.pageX, this.topDelta = 0, this.leftDelta = 0, this.isHidden || this.updatePosition(), t(document).on("mousemove", this.mousemoveProxy = t.proxy(this, "mousemove")))
      },
      stop: function(e, n) {
        function i() {
          this.isAnimating = !1, r.destroyEl(), this.top0 = this.left0 = null, n && n()
        }
        var r = this,
          s = this.options.revertDuration;
        this.isFollowing && !this.isAnimating && (this.isFollowing = !1, t(document).off("mousemove", this.mousemoveProxy), e && s && !this.isHidden ? (this.isAnimating = !0, this.el.animate({
          top: this.top0,
          left: this.left0
        }, {
          duration: s,
          complete: i
        })) : i())
      },
      getEl: function() {
        var t = this.el;
        return t || (this.sourceEl.width(), t = this.el = this.sourceEl.clone().css({
          position: "absolute",
          visibility: "",
          display: this.isHidden ? "none" : "",
          margin: 0,
          right: "auto",
          bottom: "auto",
          width: this.sourceEl.width(),
          height: this.sourceEl.height(),
          opacity: this.options.opacity || "",
          zIndex: this.options.zIndex
        }).appendTo(this.parentEl)), t
      },
      destroyEl: function() {
        this.el && (this.el.remove(), this.el = null)
      },
      updatePosition: function() {
        var t, e;
        this.getEl(), null === this.top0 && (this.sourceEl.width(), t = this.sourceEl.offset(), e = this.el.offsetParent().offset(), this.top0 = t.top - e.top, this.left0 = t.left - e.left), this.el.css({
          top: this.top0 + this.topDelta,
          left: this.left0 + this.leftDelta
        })
      },
      mousemove: function(t) {
        this.topDelta = t.pageY - this.mouseY0, this.leftDelta = t.pageX - this.mouseX0, this.isHidden || this.updatePosition()
      },
      hide: function() {
        this.isHidden || (this.isHidden = !0, this.el && this.el.hide())
      },
      show: function() {
        this.isHidden && (this.isHidden = !1, this.updatePosition(), this.getEl().show())
      }
    }),
    Xt = Q.extend({
      view: null,
      isRTL: null,
      cellHtml: "<td/>",
      constructor: function(t) {
        this.view = t, this.isRTL = t.opt("isRTL")
      },
      rowHtml: function(t, e) {
        var n, i, r = this.getHtmlRenderer("cell", t),
          s = "";
        for (e = e || 0, n = 0; n < this.colCnt; n++) i = this.getCell(e, n), s += r(i);
        return s = this.bookendCells(s, t, e), "<tr>" + s + "</tr>"
      },
      bookendCells: function(t, e, n) {
        var i = this.getHtmlRenderer("intro", e)(n || 0, this),
          r = this.getHtmlRenderer("outro", e)(n || 0, this),
          s = this.isRTL ? r : i,
          o = this.isRTL ? i : r;
        return "string" == typeof t ? s + t + o : t.prepend(s).append(o)
      },
      getHtmlRenderer: function(t, e) {
        var n, i, r, s, o = this.view;
        return n = t + "Html", e && (i = e + Y(t) + "Html"), i && (s = o[i]) ? r = o : i && (s = this[i]) ? r = this : (s = o[n]) ? r = o : (s = this[n]) && (r = this), "function" == typeof s ? function() {
          return s.apply(r, arguments) || ""
        } : function() {
          return s || ""
        }
      }
    }),
    Ut = Dt.Grid = Xt.extend({
      start: null,
      end: null,
      rowCnt: 0,
      colCnt: 0,
      rowData: null,
      colData: null,
      el: null,
      coordMap: null,
      elsByFill: null,
      documentDragStartProxy: null,
      colHeadFormat: null,
      eventTimeFormat: null,
      displayEventEnd: null,
      constructor: function() {
        Xt.apply(this, arguments), this.coordMap = new Wt(this), this.elsByFill = {}, this.documentDragStartProxy = t.proxy(this, "documentDragStart")
      },
      render: function() {
        this.bindHandlers()
      },
      destroy: function() {
        this.unbindHandlers()
      },
      computeColHeadFormat: function() {},
      computeEventTimeFormat: function() {
        return this.view.opt("smallTimeFormat")
      },
      computeDisplayEventEnd: function() {
        return !1
      },
      setRange: function(t) {
        var e = this.view;
        this.start = t.start.clone(), this.end = t.end.clone(), this.rowData = [], this.colData = [], this.updateCells(), this.colHeadFormat = e.opt("columnFormat") || this.computeColHeadFormat(), this.eventTimeFormat = e.opt("timeFormat") || this.computeEventTimeFormat(), this.displayEventEnd = e.opt("displayEventEnd"), null == this.displayEventEnd && (this.displayEventEnd = this.computeDisplayEventEnd())
      },
      updateCells: function() {},
      rangeToSegs: function(t) {},
      getCell: function(e, n) {
        var i;
        return null == n && ("number" == typeof e ? (n = e % this.colCnt, e = Math.floor(e / this.colCnt)) : (n = e.col, e = e.row)), i = {
          row: e,
          col: n
        }, t.extend(i, this.getRowData(e), this.getColData(n)), t.extend(i, this.computeCellRange(i)), i
      },
      computeCellRange: function(t) {},
      getRowData: function(t) {
        return this.rowData[t] || {}
      },
      getColData: function(t) {
        return this.colData[t] || {}
      },
      getRowEl: function(t) {},
      getColEl: function(t) {},
      getCellDayEl: function(t) {
        return this.getColEl(t.col) || this.getRowEl(t.row)
      },
      computeRowCoords: function() {
        var t, e, n, i = [];
        for (t = 0; t < this.rowCnt; t++) e = this.getRowEl(t), n = {
          top: e.offset().top
        }, t > 0 && (i[t - 1].bottom = n.top), i.push(n);
        return n.bottom = n.top + e.outerHeight(), i
      },
      computeColCoords: function() {
        var t, e, n, i = [];
        for (t = 0; t < this.colCnt; t++) e = this.getColEl(t), n = {
          left: e.offset().left
        }, t > 0 && (i[t - 1].right = n.left), i.push(n);
        return n.right = n.left + e.outerWidth(), i
      },
      bindHandlers: function() {
        var e = this;
        this.el.on("mousedown", function(n) {
          t(n.target).is(".fc-event-container *, .fc-more") || t(n.target).closest(".fc-popover").length || e.dayMousedown(n)
        }), this.bindSegHandlers(), t(document).on("dragstart", this.documentDragStartProxy)
      },
      unbindHandlers: function() {
        t(document).off("dragstart", this.documentDragStartProxy)
      },
      dayMousedown: function(t) {
        var e, n, i = this,
          r = this.view,
          s = r.opt("selectable"),
          o = new Zt(this.coordMap, {
            scroll: r.opt("dragScroll"),
            dragStart: function() {
              r.unselect()
            },
            cellOver: function(t, r) {
              var a = o.origCell;
              a && (e = r ? t : null, s && (n = i.computeSelection(a, t), n ? i.renderSelection(n) : l()))
            },
            cellOut: function(t) {
              e = null, n = null, i.destroySelection(), d()
            },
            listenStop: function(t) {
              e && r.trigger("dayClick", i.getCellDayEl(e), e.start, t), n && r.reportSelection(n, t), d()
            }
          });
        o.mousedown(t)
      },
      renderRangeHelper: function(t, e) {
        var n;
        n = e ? k(e.event) : {}, n.start = t.start.clone(), n.end = t.end ? t.end.clone() : null, n.allDay = null, this.view.calendar.normalizeEventDateProps(n), n.className = (n.className || []).concat("fc-helper"), e || (n.editable = !1), this.renderHelper(n, e)
      },
      renderHelper: function(t, e) {},
      destroyHelper: function() {},
      renderSelection: function(t) {
        "year" != this.view.name || t.rendered || (this.view.destroySelection(), t.rendered = !0, this.view.renderSelection(t, this)), this.renderHighlight(t)
      },
      destroySelection: function() {
        this.destroyHighlight()
      },
      computeSelection: function(t, e) {
        var n, i = [t.start, t.end, e.start, e.end];
        return i.sort(z), n = {
          start: i[0].clone(),
          end: i[3].clone()
        }, this.view.calendar.isSelectionRangeAllowed(n) ? n : null
      },
      renderHighlight: function(t) {
        this.renderFill("highlight", this.rangeToSegs(t))
      },
      destroyHighlight: function() {
        this.destroyFill("highlight")
      },
      highlightSegClasses: function() {
        return ["fc-highlight"]
      },
      renderFill: function(t, e) {},
      destroyFill: function(t) {
        var e = this.elsByFill[t];
        e && (e.remove(), delete this.elsByFill[t])
      },
      renderFillSegEls: function(e, n) {
        var i, r = this,
          s = this[e + "SegEl"],
          o = "",
          a = [];
        if (n.length) {
          for (i = 0; i < n.length; i++) o += this.fillSegHtml(e, n[i]);
          t(o).each(function(e, i) {
            var o = n[e],
              l = t(i);
            s && (l = s.call(r, o, l)), l && (l = t(l), l.is(r.fillSegTag) && (o.el = l, a.push(o)))
          })
        }
        return a
      },
      fillSegTag: "div",
      fillSegHtml: function(t, e) {
        var n = this[t + "SegClasses"],
          i = this[t + "SegStyles"],
          r = n ? n.call(this, e) : [],
          s = i ? i.call(this, e) : "";
        return "<" + this.fillSegTag + (r.length ? ' class="' + r.join(" ") + '"' : "") + (s ? ' style="' + s + '"' : "") + " />"
      },
      headHtml: function() {
        return '<div class="fc-row ' + this.view.widgetHeaderClass + '"><table><thead>' + this.rowHtml("head") + "</thead></table></div>"
      },
      headCellHtml: function(t) {
        var e = this.view,
          n = t.start;
        return '<th class="fc-day-header ' + e.widgetHeaderClass + " fc-" + Gt[n.day()] + '">' + N(n.format(this.colHeadFormat)) + "</th>"
      },
      bgCellHtml: function(t) {
        var e = this.view,
          n = t.start,
          i = this.getDayClasses(n);
        return i.unshift("fc-day", e.widgetContentClass), '<td class="' + i.join(" ") + '" data-date="' + n.format("YYYY-MM-DD") + '"></td>'
      },
      getDayClasses: function(t) {
        var e = this.view,
          n = e.calendar.getNow().stripTime(),
          i = ["fc-" + Gt[t.day()]];
        return "month" === e.name && t.month() != e.intervalStart.month() && i.push("fc-other-month"), t.isSame(n, "day") ? i.push("fc-today", e.highlightStateClass) : n > t ? i.push("fc-past") : i.push("fc-future"), i
      }
    });
  Ut.mixin({
    mousedOverSeg: null,
    isDraggingSeg: !1,
    isResizingSeg: !1,
    segs: null,
    renderEvents: function(t) {
      var e, n, i = this.eventsToSegs(t),
        r = [],
        s = [];
      for (e = 0; e < i.length; e++) n = i[e], tt(n.event) ? r.push(n) : s.push(n);
      r = this.renderBgSegs(r) || r, s = this.renderFgSegs(s) || s, this.segs = r.concat(s)
    },
    destroyEvents: function() {
      this.triggerSegMouseout(), this.destroyFgSegs(), this.destroyBgSegs(), this.segs = null
    },
    getEventSegs: function() {
      return this.segs || []
    },
    renderFgSegs: function(t) {},
    destroyFgSegs: function() {},
    renderFgSegEls: function(e, n) {
      var i, r = this.view,
        s = "",
        o = [];
      if (e.length) {
        for (i = 0; i < e.length; i++) s += this.fgSegHtml(e[i], n);
        t(s).each(function(n, i) {
          var s = e[n],
            a = r.resolveEventEl(s.event, t(i));
          a && (a.data("fc-seg", s), s.el = a, o.push(s))
        })
      }
      return o
    },
    fgSegHtml: function(t, e) {},
    renderBgSegs: function(t) {
      return this.renderFill("bgEvent", t)
    },
    destroyBgSegs: function() {
      this.destroyFill("bgEvent")
    },
    bgEventSegEl: function(t, e) {
      return this.view.resolveEventEl(t.event, e)
    },
    bgEventSegClasses: function(t) {
      var e = t.event,
        n = e.source || {};
      return ["fc-bgevent"].concat(e.className, n.className || [])
    },
    bgEventSegStyles: function(t) {
      var e = this.view,
        n = t.event,
        i = n.source || {},
        r = n.color,
        s = i.color,
        o = e.opt("eventColor"),
        a = n.backgroundColor || r || i.backgroundColor || s || e.opt("eventBackgroundColor") || o;
      return a ? "background-color:" + a : ""
    },
    businessHoursSegClasses: function(t) {
      return ["fc-nonbusiness", "fc-bgevent"]
    },
    bindSegHandlers: function() {
      var e = this,
        n = this.view;
      t.each({
        mouseenter: function(t, n) {
          e.triggerSegMouseover(t, n)
        },
        mouseleave: function(t, n) {
          e.triggerSegMouseout(t, n)
        },
        click: function(t, e) {
          return n.trigger("eventClick", this, t.event, e)
        },
        mousedown: function(i, r) {
          t(r.target).is(".fc-resizer") && n.isEventResizable(i.event) ? e.segResizeMousedown(i, r) : n.isEventDraggable(i.event) && e.segDragMousedown(i, r)
        }
      }, function(n, i) {
        e.el.on(n, ".fc-event-container > *", function(n) {
          var r = t(this).data("fc-seg");
          return !r || e.isDraggingSeg || e.isResizingSeg ? void 0 : i.call(this, r, n)
        })
      })
    },
    triggerSegMouseover: function(t, e) {
      this.mousedOverSeg || (this.mousedOverSeg = t, this.view.trigger("eventMouseover", t.el[0], t.event, e))
    },
    triggerSegMouseout: function(t, e) {
      e = e || {}, this.mousedOverSeg && (t = t || this.mousedOverSeg, this.mousedOverSeg = null, this.view.trigger("eventMouseout", t.el[0], t.event, e))
    },
    segDragMousedown: function(e, n) {
      var i, r = this,
        s = this.view,
        o = e.el,
        a = e.event;
      if ("year" == s.name) {
        var u = t(o).closest("td.fc-year-monthly-td"),
          c = u.closest("table").find(".fc-year-monthly-td"),
          h = c.index(u);
        s.dayGrid = s.dayGrids[h]
      }
      var f = new jt(e.el, {
          parentEl: s.el,
          opacity: s.opt("dragOpacity"),
          revertDuration: s.opt("dragRevertDuration"),
          zIndex: 2
        }),
        g = new Zt(s.coordMap, {
          distance: 5,
          scroll: s.opt("dragScroll"),
          listenStart: function(t) {
            f.hide(), f.start(t)
          },
          dragStart: function(t) {
            r.triggerSegMouseout(e, t), r.isDraggingSeg = !0, s.hideEvent(a), s.trigger("eventDragStart", o[0], a, t, {})
          },
          cellOver: function(t, n) {
            var o = e.cell || g.origCell;
            i = r.computeEventDrop(o, t, a), i ? (s.renderDrag(i, e) ? f.hide() : f.show(), n && (i = null)) : (f.show(), l())
          },
          cellOut: function() {
            i = null, s.destroyDrag(), f.show(), d()
          },
          dragStop: function(t) {
            f.stop(!i, function() {
              r.isDraggingSeg = !1, s.destroyDrag(), s.showEvent(a), s.trigger("eventDragStop", o[0], a, t, {}), i && s.reportEventDrop(a, i, o, t)
            }), d()
          },
          listenStop: function() {
            f.stop()
          }
        });
      g.mousedown(n)
    },
    computeEventDrop: function(t, e, n) {
      var i, r, s, o, a, l = t.start,
        d = e.start;
      return l.hasTime() === d.hasTime() ? (i = b(d, l), r = n.start.clone().add(i), s = null === n.end ? null : n.end.clone().add(i), o = n.allDay) : (r = d.clone(), s = null, o = !d.hasTime()), a = {
        start: r,
        end: s,
        allDay: o
      }, this.view.calendar.isEventRangeAllowed(a, n) ? a : null
    },
    documentDragStart: function(e, n) {
      var i, r, s = this.view;
      s.opt("droppable") && (i = t(e.target), r = s.opt("dropAccept"), (t.isFunction(r) ? r.call(i[0], i) : i.is(r)) && this.startExternalDrag(i, e, n))
    },
    startExternalDrag: function(e, n, i) {
      var r, s, o = this,
        a = ot(e);
      r = new Zt(this.coordMap, {
        cellOver: function(t) {
          s = o.computeExternalDrop(t, a), s ? o.renderDrag(s) : l()
        },
        cellOut: function() {
          s = null, o.destroyDrag(), d()
        }
      }), t(document).one("dragstop", function(t, n) {
        o.destroyDrag(), d(), s && o.view.reportExternalDrop(a, s, e, t, n)
      }), r.startDrag(n)
    },
    computeExternalDrop: function(t, e) {
      var n = {
        start: t.start.clone(),
        end: null
      };
      return e.startTime && !n.start.hasTime() && n.start.time(e.startTime), e.duration && (n.end = n.start.clone().add(e.duration)), this.view.calendar.isExternalDropRangeAllowed(n, e.eventProps) ? n : null
    },
    renderDrag: function(t, e) {},
    destroyDrag: function() {},
    segResizeMousedown: function(e, n) {
      function i() {
        o.destroyEventResize(), a.showEvent(h), d()
      }
      var r, s, o = this,
        a = this.view,
        u = a.calendar,
        c = e.el,
        h = e.event,
        f = h.start,
        g = u.getEventEnd(h);
      s = new Zt(this.coordMap, {
        distance: 5,
        scroll: a.opt("dragScroll"),
        dragStart: function(t) {
          o.triggerSegMouseout(e, t), o.isResizingSeg = !0, a.trigger("eventResizeStart", c[0], h, t, {})
        },
        cellOver: function(n) {
          r = n.end, r.isAfter(f) || (r = f.clone().add(b(n.end, n.start))), r.isSame(g) ? r = null : u.isEventRangeAllowed({
            start: f,
            end: r
          }, h) ? (o.renderEventResize({
            start: f,
            end: r
          }, e), "year" == a.name && t.each(a.dayGrids, function(t, n) {
            n !== o && (n.destroyEventResize(), n.renderEventResize({
              start: f,
              end: r
            }, e))
          }), a.hideEvent(h)) : (r = null, l())
        },
        cellOut: function() {
          r = null, i()
        },
        dragStop: function(t) {
          o.isResizingSeg = !1, i(), a.trigger("eventResizeStop", c[0], h, t, {}), r && a.reportEventResize(h, r, c, t)
        }
      }), s.mousedown(n)
    },
    renderEventResize: function(t, e) {},
    destroyEventResize: function() {},
    getEventTimeText: function(t, e) {
      return e = e || this.eventTimeFormat, t.end && this.displayEventEnd ? this.view.formatRange(t, e) : t.start.format(e)
    },
    getSegClasses: function(t, e, n) {
      var i = t.event,
        r = ["fc-event", t.isStart ? "fc-start" : "fc-not-start", t.isEnd ? "fc-end" : "fc-not-end"].concat(i.className, i.source ? i.source.className : []);
      return e && r.push("fc-draggable"), n && r.push("fc-resizable"), r
    },
    getEventSkinCss: function(t) {
      var e = this.view,
        n = t.source || {},
        i = t.color,
        r = n.color,
        s = e.opt("eventColor"),
        o = t.backgroundColor || i || n.backgroundColor || r || e.opt("eventBackgroundColor") || s,
        a = t.borderColor || i || n.borderColor || r || e.opt("eventBorderColor") || s,
        l = t.textColor || n.textColor || e.opt("eventTextColor"),
        d = [];
      return o && d.push("background-color:" + o), a && d.push("border-color:" + a), l && d.push("color:" + l), d.join(";")
    },
    eventsToSegs: function(t, e) {
      var n, i = this.eventsToRanges(t),
        r = [];
      for (n = 0; n < i.length; n++) r.push.apply(r, this.eventRangeToSegs(i[n], e));
      return r
    },
    eventsToRanges: function(e) {
      var n = this,
        i = it(e),
        r = [];
      return t.each(i, function(t, e) {
        e.length && r.push.apply(r, et(e[0]) ? n.eventsToInverseRanges(e) : n.eventsToNormalRanges(e))
      }), r
    },
    eventsToNormalRanges: function(t) {
      var e, n, i, r, s = this.view.calendar,
        o = [];
      for (e = 0; e < t.length; e++) n = t[e], i = n.start.clone().stripZone(), r = s.getEventEnd(n).stripZone(), o.push({
        event: n,
        start: i,
        end: r,
        eventStartMS: +i,
        eventDurationMS: r - i
      });
      return o
    },
    eventsToInverseRanges: function(t) {
      var e, n, i = this.view,
        r = i.start.clone().stripZone(),
        s = i.end.clone().stripZone(),
        o = this.eventsToNormalRanges(t),
        a = [],
        l = t[0],
        d = r;
      for (o.sort(rt), e = 0; e < o.length; e++) n = o[e], n.start > d && a.push({
        event: l,
        start: d,
        end: n.start
      }), d = n.end;
      return s > d && a.push({
        event: l,
        start: d,
        end: s
      }), a
    },
    eventRangeToSegs: function(t, e) {
      var n, i, r;
      for (n = e ? e(t) : this.rangeToSegs(t), i = 0; i < n.length; i++) r = n[i], r.event = t.event, r.eventStartMS = t.eventStartMS, r.eventDurationMS = t.eventDurationMS;
      return n
    }
  }), Dt.compareSegs = st, Dt.dataAttrPrefix = "";
  var $t = Ut.extend({
    numbersVisible: !1,
    bottomCoordPadding: 0,
    breakOnWeeks: null,
    cellDates: null,
    dayToCellOffsets: null,
    rowEls: null,
    dayEls: null,
    helperEls: null,
    render: function(t) {
      var e, n, i, r = this.view,
        s = this.rowCnt,
        o = this.colCnt,
        a = s * o,
        l = "";
      for (e = 0; s > e; e++) l += this.dayRowHtml(e, t);
      for (this.el.html(l), this.rowEls = this.el.find(".fc-row"), this.dayEls = this.el.find(".fc-day"), n = 0; a > n; n++) i = this.getCell(n), r.trigger("dayRender", null, i.start, this.dayEls.eq(n));
      Ut.prototype.render.call(this)
    },
    destroy: function() {
      this.destroySegPopover(), Ut.prototype.destroy.call(this)
    },
    dayRowHtml: function(t, e) {
      var n = this.view,
        i = ["fc-row", "fc-week", n.widgetContentClass];
      return e && i.push("fc-rigid"), '<div class="' + i.join(" ") + '"><div class="fc-bg"><table>' + this.rowHtml("day", t) + '</table></div><div class="fc-content-skeleton"><table>' + (this.numbersVisible ? "<thead>" + this.rowHtml("number", t) + "</thead>" : "") + "</table></div></div>"
    },
    dayCellHtml: function(t) {
      return this.bgCellHtml(t)
    },
    computeColHeadFormat: function() {
      return this.rowCnt > 1 ? "ddd" : this.colCnt > 1 ? this.view.opt("dayOfMonthFormat") : "dddd"
    },
    computeEventTimeFormat: function() {
      return this.view.opt("extraSmallTimeFormat")
    },
    computeDisplayEventEnd: function() {
      return 1 == this.colCnt
    },
    updateCells: function() {
      var t, e, n, i;
      if (this.updateCellDates(), t = this.cellDates, this.breakOnWeeks) {
        for (e = t[0].day(), i = 1; i < t.length && t[i].day() != e; i++);
        n = Math.ceil(t.length / i)
      } else n = 1, i = t.length;
      this.rowCnt = n, this.colCnt = i
    },
    updateCellDates: function() {
      for (var t = this.view, e = this.start.clone(), n = [], i = -1, r = []; e.isBefore(this.end);) t.isHiddenDay(e) ? r.push(i + .5) : (i++, r.push(i), n.push(e.clone())), e.add(1, "days");
      this.cellDates = n, this.dayToCellOffsets = r
    },
    computeCellRange: function(t) {
      var e = this.colCnt,
        n = t.row * e + (this.isRTL ? e - t.col - 1 : t.col),
        i = this.cellDates[n].clone(),
        r = i.clone().add(1, "day");
      return {
        start: i,
        end: r
      }
    },
    getRowEl: function(t) {
      return this.rowEls.eq(t)
    },
    getColEl: function(t) {
      return this.dayEls.eq(t)
    },
    getCellDayEl: function(t) {
      return this.dayEls.eq(t.row * this.colCnt + t.col)
    },
    computeRowCoords: function() {
      var t = Ut.prototype.computeRowCoords.call(this);
      return t[t.length - 1].bottom += this.bottomCoordPadding, t
    },
    rangeToSegs: function(t) {
      var e, n, i, r, s, o, a, l, d, u, c = this.isRTL,
        h = this.rowCnt,
        f = this.colCnt,
        g = [];
      for (t = this.view.computeDayRange(t), e = this.dateToCellOffset(t.start), n = this.dateToCellOffset(t.end.subtract(1, "days")), i = 0; h > i; i++) r = i * f, s = r + f - 1, l = Math.max(r, e), d = Math.min(s, n), l = Math.ceil(l), d = Math.floor(d), d >= l && (o = l === e, a = d === n, l -= r, d -= r, u = {
        row: i,
        isStart: o,
        isEnd: a
      }, c ? (u.leftCol = f - d - 1, u.rightCol = f - l - 1) : (u.leftCol = l, u.rightCol = d), g.push(u));
      return g
    },
    dateToCellOffset: function(t) {
      var e = this.dayToCellOffsets,
        n = t.diff(this.start, "days");
      return 0 > n ? e[0] - 1 : n >= e.length ? e[e.length - 1] + 1 : e[n]
    },
    renderDrag: function(t, e) {
      var n;
      return this.renderHighlight(this.view.calendar.ensureVisibleEventRange(t)), e && !e.el.closest(this.view.el).length ? (this.renderRangeHelper(t, e), n = this.view.opt("dragOpacity"), void 0 !== n && this.helperEls.css("opacity", n), !0) : void 0
    },
    destroyDrag: function() {
      this.destroyHighlight(), this.destroyHelper()
    },
    renderEventResize: function(t, e) {
      this.renderHighlight(t), this.renderRangeHelper(t, e)
    },
    destroyEventResize: function() {
      this.destroyHighlight(), this.destroyHelper()
    },
    renderHelper: function(e, n) {
      var i, r = [],
        s = this.eventsToSegs([e]);
      s = this.renderFgSegEls(s), i = this.renderSegRows(s), this.rowEls.each(function(e, s) {
        var o, a = t(s),
          l = t('<div class="fc-helper-skeleton"><table/></div>');
        o = n && n.row === e ? n.el.position().top : a.find(".fc-content-skeleton tbody").position().top, l.css("top", o).find("table").append(i[e].tbodyEl), a.append(l), r.push(l[0])
      }), this.helperEls = t(r)
    },
    destroyHelper: function() {
      this.helperEls && (this.helperEls.remove(), this.helperEls = null)
    },
    fillSegTag: "td",
    renderFill: function(e, n) {
      var i, r, s, o = [];
      for (n = this.renderFillSegEls(e, n), i = 0; i < n.length; i++) r = n[i], s = this.renderFillRow(e, r), this.rowEls.eq(r.row).append(s), o.push(s[0]);
      return this.elsByFill[e] = t(o), n
    },
    renderFillRow: function(e, n) {
      var i, r, s = this.colCnt,
        o = n.leftCol,
        a = n.rightCol + 1;
      return i = t('<div class="fc-' + e.toLowerCase() + '-skeleton"><table><tr/></table></div>'), r = i.find("tr"), o > 0 && r.append('<td colspan="' + o + '"/>'), r.append(n.el.attr("colspan", a - o)), s > a && r.append('<td colspan="' + (s - a) + '"/>'), this.bookendCells(r, e), i
    }
  });
  $t.mixin({
    rowStructs: null,
    destroyEvents: function() {
      this.destroySegPopover(), Ut.prototype.destroyEvents.apply(this, arguments)
    },
    getEventSegs: function() {
      return Ut.prototype.getEventSegs.call(this).concat(this.popoverSegs || [])
    },
    renderBgSegs: function(e) {
      var n = t.grep(e, function(t) {
        return t.event.allDay
      });
      return Ut.prototype.renderBgSegs.call(this, n)
    },
    renderFgSegs: function(e) {
      var n;
      return e = this.renderFgSegEls(e), n = this.rowStructs = this.renderSegRows(e), this.rowEls.each(function(e, i) {
        e < n.length && t(i).find(".fc-content-skeleton > table").append(n[e].tbodyEl)
      }), e
    },
    destroyFgSegs: function() {
      for (var t, e = this.rowStructs || []; t = e.pop();) t.tbodyEl.remove();
      this.rowStructs = null
    },
    renderSegRows: function(t) {
      var e, n, i = [];
      for (e = this.groupSegRows(t), n = 0; n < e.length; n++) i.push(this.renderSegRow(n, e[n]));
      return i
    },
    fgSegHtml: function(t, e) {
      var n, i = this.view,
        r = t.event,
        s = i.isEventDraggable(r),
        o = !e && r.allDay && t.isEnd && i.isEventResizable(r),
        a = this.getSegClasses(t, s, o),
        l = this.getEventSkinCss(r),
        d = "";
      return a.unshift("fc-day-grid-event"), !r.allDay && t.isStart && (d = '<span class="fc-time">' + N(this.getEventTimeText(r)) + "</span>"), n = '<span class="fc-title">' + (N(r.title || "") || "&nbsp;") + "</span>", '<a class="' + a.join(" ") + '"' + (r.url ? ' href="' + N(r.url) + '"' : "") + (l ? ' style="' + l + '"' : "") + '><div class="fc-content">' + (this.isRTL ? n + " " + d : d + " " + n) + "</div>" + (o ? '<div class="fc-resizer"/>' : "") + "</a>"
    },
    renderSegRow: function(e, n) {
      function i(e) {
        for (; e > o;) u = (v[r - 1] || [])[o], u ? u.attr("rowspan", parseInt(u.attr("rowspan") || 1, 10) + 1) : (u = t("<td/>"), a.append(u)), m[r][o] = u, v[r][o] = u, o++
      }
      var r, s, o, a, l, d, u, c = this.colCnt,
        h = this.buildSegLevels(n),
        f = Math.max(1, h.length),
        g = t("<tbody/>"),
        p = [],
        m = [],
        v = [];
      for (r = 0; f > r; r++) {
        if (s = h[r], o = 0, a = t("<tr/>"), p.push([]), m.push([]), v.push([]), s)
          for (l = 0; l < s.length; l++) {
            for (d = s[l], i(d.leftCol), u = t('<td class="fc-event-container"/>').append(d.el), d.leftCol != d.rightCol ? u.attr("colspan", d.rightCol - d.leftCol + 1) : v[r][o] = u; o <= d.rightCol;) m[r][o] = u, p[r][o] = d, o++;
            a.append(u)
          }
        i(c), this.bookendCells(a, "eventSkeleton"), g.append(a)
      }
      return {
        row: e,
        tbodyEl: g,
        cellMatrix: m,
        segMatrix: p,
        segLevels: h,
        segs: n
      }
    },
    buildSegLevels: function(t) {
      var e, n, i, r = [];
      for (t.sort(st), e = 0; e < t.length; e++) {
        for (n = t[e], i = 0; i < r.length && at(n, r[i]); i++);
        n.level = i, (r[i] || (r[i] = [])).push(n)
      }
      for (i = 0; i < r.length; i++) r[i].sort(lt);
      return r
    },
    groupSegRows: function(t) {
      var e, n = [];
      for (e = 0; e < this.rowCnt; e++) n.push([]);
      for (e = 0; e < t.length; e++) n[t[e].row].push(t[e]);
      return n
    }
  }), $t.mixin({
    segPopover: null,
    popoverSegs: null,
    destroySegPopover: function() {
      this.segPopover && this.segPopover.hide()
    },
    limitRows: function(t) {
      var e, n, i = this.rowStructs || [];
      for (e = 0; e < i.length; e++) this.unlimitRow(e), n = t ? "number" == typeof t ? t : this.computeRowLevelLimit(e) : !1, n !== !1 && this.limitRow(e, n)
    },
    computeRowLevelLimit: function(t) {
      var e, n, i = this.rowEls.eq(t),
        r = i.height(),
        s = this.rowStructs[t].tbodyEl.children();
      for (e = 0; e < s.length; e++)
        if (n = s.eq(e).removeClass("fc-limited"), n.position().top + n.outerHeight() > r) return e;
      return !1
    },
    limitRow: function(e, n) {
      function i(i) {
        for (; i > C;) r = b.getCell(e, C), u = b.getCellSegs(r, n), u.length && (f = o[n - 1][C], w = b.renderMoreLink(r, u), y = t("<div/>").append(w), f.append(y), E.push(y[0])), C++
      }
      var r, s, o, a, l, d, u, c, h, f, g, p, m, v, y, w, b = this,
        S = this.rowStructs[e],
        E = [],
        C = 0;
      if (n && n < S.segLevels.length) {
        for (s = S.segLevels[n - 1], o = S.cellMatrix, a = S.tbodyEl.children().slice(n).addClass("fc-limited").get(), l = 0; l < s.length; l++) {
          for (d = s[l], i(d.leftCol), h = [], c = 0; C <= d.rightCol;) r = this.getCell(e, C), u = this.getCellSegs(r, n), h.push(u), c += u.length, C++;
          if (c) {
            for (f = o[n - 1][d.leftCol], g = f.attr("rowspan") || 1, p = [], m = 0; m < h.length; m++) v = t('<td class="fc-more-cell"/>').attr("rowspan", g), u = h[m], r = this.getCell(e, d.leftCol + m), w = this.renderMoreLink(r, [d].concat(u)), y = t("<div/>").append(w), v.append(y), p.push(v[0]), E.push(v[0]);
            f.addClass("fc-limited").after(t(p)), a.push(f[0])
          }
        }
        i(this.colCnt), S.moreEls = t(E), S.limitedEls = t(a)
      }
    },
    unlimitRow: function(t) {
      var e = this.rowStructs[t];
      e.moreEls && (e.moreEls.remove(), e.moreEls = null), e.limitedEls && (e.limitedEls.removeClass("fc-limited"), e.limitedEls = null)
    },
    renderMoreLink: function(e, n) {
      var i = this,
        r = this.view;
      return t('<a class="fc-more"/>').text(this.getMoreLinkText(n.length)).on("click", function(s) {
        var o = r.opt("eventLimitClick"),
          a = e.start,
          l = t(this),
          d = i.getCellDayEl(e),
          u = i.getCellSegs(e),
          c = i.resliceDaySegs(u, a),
          h = i.resliceDaySegs(n, a);
        "function" == typeof o && (o = r.trigger("eventLimitClick", null, {
          date: a,
          dayEl: d,
          moreEl: l,
          segs: c,
          hiddenSegs: h
        }, s)), "popover" === o ? i.showSegPopover(e, l, c) : "string" == typeof o && r.calendar.zoomTo(a, o)
      })
    },
    showSegPopover: function(t, e, n) {
      var i, r, s = this,
        o = this.view,
        a = e.parent();
      i = 1 == this.rowCnt ? o.el : this.rowEls.eq(t.row), r = {
        className: "fc-more-popover",
        content: this.renderSegPopoverContent(t, n),
        parentEl: this.el,
        top: i.offset().top,
        autoHide: !0,
        viewportConstrain: o.opt("popoverViewportConstrain"),
        hide: function() {
          s.segPopover.destroy(), s.segPopover = null, s.popoverSegs = null
        }
      }, this.isRTL ? r.right = a.offset().left + a.outerWidth() + 1 : r.left = a.offset().left - 1, this.segPopover = new Bt(r), this.segPopover.show()
    },
    renderSegPopoverContent: function(e, n) {
      var i, r = this.view,
        s = r.opt("theme"),
        o = e.start.format(r.opt("dayPopoverFormat")),
        a = t('<div class="fc-header ' + r.widgetHeaderClass + '"><span class="fc-close ' + (s ? "ui-icon ui-icon-closethick" : "fc-icon fc-icon-x") + '"></span><span class="fc-title">' + N(o) + '</span><div class="fc-clear"/></div><div class="fc-body ' + r.widgetContentClass + '"><div class="fc-event-container"></div></div>'),
        l = a.find(".fc-event-container");
      for (n = this.renderFgSegEls(n, !0), this.popoverSegs = n, i = 0; i < n.length; i++) n[i].cell = e, l.append(n[i].el);
      return a
    },
    resliceDaySegs: function(e, n) {
      var i = t.map(e, function(t) {
          return t.event
        }),
        r = n.clone().stripTime(),
        s = r.clone().add(1, "days"),
        o = {
          start: r,
          end: s
        };
      return e = this.eventsToSegs(i, function(t) {
        var e = y(t, o);
        return e ? [e] : []
      }), e.sort(st), e
    },
    getMoreLinkText: function(t) {
      var e = this.view.opt("eventLimitText");
      return "function" == typeof e ? e(t) : "+" + t + " " + e
    },
    getCellSegs: function(t, e) {
      for (var n, i = this.rowStructs[t.row].segMatrix, r = e || 0, s = []; r < i.length;) n = i[r][t.col], n && s.push(n), r++;
      return s
    }
  });
  var qt = Ut.extend({
    slotDuration: null,
    snapDuration: null,
    minTime: null,
    maxTime: null,
    axisFormat: null,
    dayEls: null,
    slatEls: null,
    slatTops: null,
    helperEl: null,
    businessHourSegs: null,
    constructor: function() {
      Ut.apply(this, arguments), this.processOptions()
    },
    render: function() {
      this.el.html(this.renderHtml()), this.dayEls = this.el.find(".fc-day"), this.slatEls = this.el.find(".fc-slats tr"), this.computeSlatTops(), this.renderBusinessHours(), Ut.prototype.render.call(this)
    },
    renderBusinessHours: function() {
      var t = this.view.calendar.getBusinessHoursEvents();
      this.businessHourSegs = this.renderFill("businessHours", this.eventsToSegs(t), "bgevent")
    },
    renderHtml: function() {
      return '<div class="fc-bg"><table>' + this.rowHtml("slotBg") + '</table></div><div class="fc-slats"><table>' + this.slatRowHtml() + "</table></div>"
    },
    slotBgCellHtml: function(t) {
      return this.bgCellHtml(t)
    },
    slatRowHtml: function() {
      for (var t, n, i, r = this.view, s = this.isRTL, o = "", a = this.slotDuration.asMinutes() % 15 === 0, l = e.duration(+this.minTime); l < this.maxTime;) t = this.start.clone().time(l), n = t.minutes(), i = '<td class="fc-axis fc-time ' + r.widgetContentClass + '" ' + r.axisStyleAttr() + ">" + (a && n ? "" : "<span>" + N(t.format(this.axisFormat)) + "</span>") + "</td>", o += "<tr " + (n ? 'class="fc-minor"' : "") + ">" + (s ? "" : i) + '<td class="' + r.widgetContentClass + '"/>' + (s ? i : "") + "</tr>", l.add(this.slotDuration);
      return o
    },
    processOptions: function() {
      var t = this.view,
        n = t.opt("slotDuration"),
        i = t.opt("snapDuration");
      n = e.duration(n), i = i ? e.duration(i) : n, this.slotDuration = n, this.snapDuration = i, this.minTime = e.duration(t.opt("minTime")), this.maxTime = e.duration(t.opt("maxTime")), this.axisFormat = t.opt("axisFormat") || t.opt("smallTimeFormat")
    },
    computeColHeadFormat: function() {
      return this.colCnt > 1 ? this.view.opt("dayOfMonthFormat") : "dddd";
    },
    computeEventTimeFormat: function() {
      return this.view.opt("noMeridiemTimeFormat")
    },
    computeDisplayEventEnd: function() {
      return !0
    },
    updateCells: function() {
      var t, e = this.view,
        n = [];
      for (t = this.start.clone(); t.isBefore(this.end);) n.push({
        day: t.clone()
      }), t.add(1, "day"), t = e.skipHiddenDays(t);
      this.isRTL && n.reverse(), this.colData = n, this.colCnt = n.length, this.rowCnt = Math.ceil((this.maxTime - this.minTime) / this.snapDuration)
    },
    computeCellRange: function(t) {
      var e = this.computeSnapTime(t.row),
        n = this.view.calendar.rezoneDate(t.day).time(e),
        i = n.clone().add(this.snapDuration);
      return {
        start: n,
        end: i
      }
    },
    getColEl: function(t) {
      return this.dayEls.eq(t)
    },
    computeSnapTime: function(t) {
      return e.duration(this.minTime + this.snapDuration * t)
    },
    rangeToSegs: function(t) {
      var e, n, i, r, s = this.colCnt,
        o = [];
      for (t = {
          start: t.start.clone().stripZone(),
          end: t.end.clone().stripZone()
        }, n = 0; s > n; n++) i = this.colData[n].day, r = {
        start: i.clone().time(this.minTime),
        end: i.clone().time(this.maxTime)
      }, e = y(t, r), e && (e.col = n, o.push(e));
      return o
    },
    resize: function() {
      this.computeSlatTops(), this.updateSegVerticals()
    },
    computeRowCoords: function() {
      var t, e, n = this.el.offset().top,
        i = [];
      for (t = 0; t < this.rowCnt; t++) e = {
        top: n + this.computeTimeTop(this.computeSnapTime(t))
      }, t > 0 && (i[t - 1].bottom = e.top), i.push(e);
      return e.bottom = e.top + this.computeTimeTop(this.computeSnapTime(t)), i
    },
    computeDateTop: function(t, n) {
      return this.computeTimeTop(e.duration(t.clone().stripZone() - n.clone().stripTime()))
    },
    computeTimeTop: function(t) {
      var e, n, i, r, s = (t - this.minTime) / this.slotDuration;
      return s = Math.max(0, s), s = Math.min(this.slatEls.length, s), e = Math.floor(s), n = s - e, i = this.slatTops[e], n ? (r = this.slatTops[e + 1], i + (r - i) * n) : i
    },
    computeSlatTops: function() {
      var e, n = [];
      this.slatEls.each(function(i, r) {
        e = t(r).position().top, n.push(e)
      }), n.push(e + this.slatEls.last().outerHeight()), this.slatTops = n
    },
    renderDrag: function(t, e) {
      var n;
      return e ? (this.renderRangeHelper(t, e), n = this.view.opt("dragOpacity"), void 0 !== n && this.helperEl.css("opacity", n), !0) : void this.renderHighlight(this.view.calendar.ensureVisibleEventRange(t))
    },
    destroyDrag: function() {
      this.destroyHelper(), this.destroyHighlight()
    },
    renderEventResize: function(t, e) {
      this.renderRangeHelper(t, e)
    },
    destroyEventResize: function() {
      this.destroyHelper()
    },
    renderHelper: function(e, n) {
      var i, r, s, o, a = this.eventsToSegs([e]);
      for (a = this.renderFgSegEls(a), i = this.renderSegTable(a), r = 0; r < a.length; r++) s = a[r], n && n.col === s.col && (o = n.el, s.el.css({
        left: o.css("left"),
        right: o.css("right"),
        "margin-left": o.css("margin-left"),
        "margin-right": o.css("margin-right")
      }));
      this.helperEl = t('<div class="fc-helper-skeleton"/>').append(i).appendTo(this.el)
    },
    destroyHelper: function() {
      this.helperEl && (this.helperEl.remove(), this.helperEl = null)
    },
    renderSelection: function(t) {
      this.view.opt("selectHelper") ? this.renderRangeHelper(t) : this.renderHighlight(t)
    },
    destroySelection: function() {
      this.destroyHelper(), this.destroyHighlight()
    },
    renderFill: function(e, n, i) {
      var r, s, o, a, l, d, u, c, h, f;
      if (n.length) {
        for (n = this.renderFillSegEls(e, n), r = this.groupSegCols(n), i = i || e.toLowerCase(), s = t('<div class="fc-' + i + '-skeleton"><table><tr/></table></div>'), o = s.find("tr"), a = 0; a < r.length; a++)
          if (l = r[a], d = t("<td/>").appendTo(o), l.length)
            for (u = t('<div class="fc-' + i + '-container"/>').appendTo(d), c = this.colData[a].day, h = 0; h < l.length; h++) f = l[h], u.append(f.el.css({
              top: this.computeDateTop(f.start, c),
              bottom: -this.computeDateTop(f.end, c)
            }));
        this.bookendCells(o, e), this.el.append(s), this.elsByFill[e] = s
      }
      return n
    }
  });
  qt.mixin({
    eventSkeletonEl: null,
    renderFgSegs: function(e) {
      return e = this.renderFgSegEls(e), this.el.append(this.eventSkeletonEl = t('<div class="fc-content-skeleton"/>').append(this.renderSegTable(e))), e
    },
    destroyFgSegs: function(t) {
      this.eventSkeletonEl && (this.eventSkeletonEl.remove(), this.eventSkeletonEl = null)
    },
    renderSegTable: function(e) {
      var n, i, r, s, o, a, l = t("<table><tr/></table>"),
        d = l.find("tr");
      for (n = this.groupSegCols(e), this.computeSegVerticals(e), s = 0; s < n.length; s++) {
        for (o = n[s], dt(o), a = t('<div class="fc-event-container"/>'), i = 0; i < o.length; i++) r = o[i], r.el.css(this.generateSegPositionCss(r)), r.bottom - r.top < 30 && r.el.addClass("fc-short"), a.append(r.el);
        d.append(t("<td/>").append(a))
      }
      return this.bookendCells(d, "eventSkeleton"), l
    },
    updateSegVerticals: function() {
      var t, e = (this.segs || []).concat(this.businessHourSegs || []);
      for (this.computeSegVerticals(e), t = 0; t < e.length; t++) e[t].el.css(this.generateSegVerticalCss(e[t]))
    },
    computeSegVerticals: function(t) {
      var e, n;
      for (e = 0; e < t.length; e++) n = t[e], n.top = this.computeDateTop(n.start, n.start), n.bottom = this.computeDateTop(n.end, n.start)
    },
    fgSegHtml: function(t, e) {
      var n, i, r, s = this.view,
        o = t.event,
        a = s.isEventDraggable(o),
        l = !e && t.isEnd && s.isEventResizable(o),
        d = this.getSegClasses(t, a, l),
        u = this.getEventSkinCss(o);
      return d.unshift("fc-time-grid-event"), s.isMultiDayEvent(o) ? (t.isStart || t.isEnd) && (n = this.getEventTimeText(t), i = this.getEventTimeText(t, "LT"), r = this.getEventTimeText({
        start: t.start
      })) : (n = this.getEventTimeText(o), i = this.getEventTimeText(o, "LT"), r = this.getEventTimeText({
        start: o.start
      })), '<a class="' + d.join(" ") + '"' + (o.url ? ' href="' + N(o.url) + '"' : "") + (u ? ' style="' + u + '"' : "") + '><div class="fc-content">' + (n ? '<div class="fc-time" data-start="' + N(r) + '" data-full="' + N(i) + '"><span>' + N(n) + "</span></div>" : "") + (o.title ? '<div class="fc-title">' + N(o.title) + "</div>" : "") + '</div><div class="fc-bg"/>' + (l ? '<div class="fc-resizer"/>' : "") + "</a>"
    },
    generateSegPositionCss: function(t) {
      var e, n, i = this.view.opt("slotEventOverlap"),
        r = t.backwardCoord,
        s = t.forwardCoord,
        o = this.generateSegVerticalCss(t);
      return i && (s = Math.min(1, r + 2 * (s - r))), this.isRTL ? (e = 1 - s, n = r) : (e = r, n = 1 - s), o.zIndex = t.level + 1, o.left = 100 * e + "%", o.right = 100 * n + "%", i && t.forwardPressure && (o[this.isRTL ? "marginLeft" : "marginRight"] = 20), o
    },
    generateSegVerticalCss: function(t) {
      return {
        top: t.top,
        bottom: -t.bottom
      }
    },
    groupSegCols: function(t) {
      var e, n = [];
      for (e = 0; e < this.colCnt; e++) n.push([]);
      for (e = 0; e < t.length; e++) n[t[e].col].push(t[e]);
      return n
    }
  });
  var Kt = Dt.View = Q.extend({
    type: null,
    name: null,
    title: null,
    calendar: null,
    options: null,
    coordMap: null,
    el: null,
    start: null,
    end: null,
    intervalStart: null,
    intervalEnd: null,
    intervalDuration: null,
    intervalUnit: null,
    isSelected: !1,
    scrollerEl: null,
    scrollTop: null,
    widgetHeaderClass: null,
    widgetContentClass: null,
    highlightStateClass: null,
    nextDayThreshold: null,
    isHiddenDayHash: null,
    documentMousedownProxy: null,
    constructor: function(n, i, r) {
      this.calendar = n, this.options = i, this.type = this.name = r, this.nextDayThreshold = e.duration(this.opt("nextDayThreshold")), this.initTheming(), this.initHiddenDays(), this.documentMousedownProxy = t.proxy(this, "documentMousedown"), this.initialize()
    },
    initialize: function() {},
    opt: function(e) {
      var n;
      return n = this.options[e], void 0 !== n ? n : (n = this.calendar.options[e], t.isPlainObject(n) && !r(e) ? w(n, this.type) : n)
    },
    trigger: function(t, e) {
      var n = this.calendar;
      return n.trigger.apply(n, [t, e || this].concat(Array.prototype.slice.call(arguments, 2), [this]))
    },
    setDate: function(t) {
      this.setRange(this.computeRange(t))
    },
    setRange: function(e) {
      t.extend(this, e), this.updateTitle()
    },
    computeRange: function(t) {
      var n, i, r = e.duration(this.opt("duration") || this.constructor.duration || {
          days: 1
        }),
        s = E(r),
        o = t.clone().startOf(s),
        a = o.clone().add(r);
      return /year|month|week|day/.test(s) ? (o.stripTime(), a.stripTime()) : (o.hasTime() || (o = this.calendar.rezoneDate(o)), a.hasTime() || (a = this.calendar.rezoneDate(a))), n = o.clone(), n = this.skipHiddenDays(n), i = a.clone(), i = this.skipHiddenDays(i, -1, !0), {
        intervalDuration: r,
        intervalUnit: s,
        intervalStart: o,
        intervalEnd: a,
        start: n,
        end: i
      }
    },
    computePrevDate: function(t) {
      return this.massageCurrentDate(t.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1)
    },
    computeNextDate: function(t) {
      return this.massageCurrentDate(t.clone().startOf(this.intervalUnit).add(this.intervalDuration))
    },
    massageCurrentDate: function(t, n) {
      return this.intervalDuration <= e.duration({
        days: 1
      }) && this.isHiddenDay(t) && (t = this.skipHiddenDays(t, n), t.startOf("day")), t
    },
    updateTitle: function() {
      this.title = this.computeTitle()
    },
    computeTitle: function() {
      return this.formatRange({
        start: this.intervalStart,
        end: this.intervalEnd
      }, this.opt("titleFormat") || this.computeTitleFormat(), this.opt("titleRangeSeparator"))
    },
    computeTitleFormat: function() {
      return "year" == this.intervalUnit ? "YYYY" : "month" == this.intervalUnit ? this.opt("monthYearFormat") : this.intervalDuration.as("days") > 1 ? "ll" : "LL"
    },
    formatRange: function(t, e, n) {
      var i = t.end;
      return i.hasTime() || (i = i.clone().subtract(1)), X(t.start, i, e, n, this.opt("isRTL"))
    },
    renderView: function() {
      this.render(), this.updateSize(), this.initializeScroll(), this.trigger("viewRender", this, this, this.el), t(document).on("mousedown", this.documentMousedownProxy)
    },
    render: function() {},
    destroyView: function() {
      this.unselect(), this.destroyViewEvents(), this.destroy(), this.trigger("viewDestroy", this, this, this.el), t(document).off("mousedown", this.documentMousedownProxy)
    },
    destroy: function() {
      this.el.empty()
    },
    initTheming: function() {
      var t = this.opt("theme") ? "ui" : "fc";
      this.widgetHeaderClass = t + "-widget-header", this.widgetContentClass = t + "-widget-content", this.highlightStateClass = t + "-state-highlight"
    },
    updateSize: function(t) {
      t && this.recordScroll(), this.updateHeight(), this.updateWidth()
    },
    updateWidth: function() {},
    updateHeight: function() {
      var t = this.calendar;
      this.setHeight(t.getSuggestedViewHeight(), t.isHeightAuto())
    },
    setHeight: function(t, e) {},
    computeScrollerHeight: function(t, e) {
      var n, i;
      return e = e || this.scrollerEl, n = this.el.add(e), n.css({
        position: "relative",
        left: -1
      }), i = this.el.outerHeight() - e.height(), n.css({
        position: "",
        left: ""
      }), t - i
    },
    initializeScroll: function() {},
    recordScroll: function() {
      this.scrollerEl && (this.scrollTop = this.scrollerEl.scrollTop())
    },
    restoreScroll: function() {
      null !== this.scrollTop && this.scrollerEl.scrollTop(this.scrollTop)
    },
    renderViewEvents: function(t) {
      this.renderEvents(t), this.eventSegEach(function(t) {
        this.trigger("eventAfterRender", t.event, t.event, t.el)
      }), this.trigger("eventAfterAllRender")
    },
    renderEvents: function() {},
    destroyViewEvents: function() {
      this.eventSegEach(function(t) {
        this.trigger("eventDestroy", t.event, t.event, t.el)
      }), this.destroyEvents()
    },
    destroyEvents: function() {},
    resolveEventEl: function(e, n) {
      var i = this.trigger("eventRender", e, e, n);
      return i === !1 ? n = null : i && i !== !0 && (n = t(i)), n
    },
    showEvent: function(t) {
      this.eventSegEach(function(t) {
        t.el.css("visibility", "")
      }, t)
    },
    hideEvent: function(t) {
      this.eventSegEach(function(t) {
        t.el.css("visibility", "hidden")
      }, t)
    },
    eventSegEach: function(t, e) {
      var n, i = this.getEventSegs();
      for (n = 0; n < i.length; n++) e && i[n].event._id !== e._id || t.call(this, i[n])
    },
    getEventSegs: function() {
      return []
    },
    isEventDraggable: function(t) {
      var e = t.source || {};
      return G(t.startEditable, e.startEditable, this.opt("eventStartEditable"), t.editable, e.editable, this.opt("editable"))
    },
    reportEventDrop: function(t, e, n, i) {
      var r = this.calendar,
        s = r.mutateEvent(t, e),
        o = function() {
          s.undo(), r.reportEventChange()
        };
      this.triggerEventDrop(t, s.dateDelta, o, n, i), r.reportEventChange()
    },
    triggerEventDrop: function(t, e, n, i, r) {
      this.trigger("eventDrop", i[0], t, e, n, r, {})
    },
    reportExternalDrop: function(e, n, i, r, s) {
      var o, a, l = e.eventProps;
      l && (o = t.extend({}, l, n), a = this.calendar.renderEvent(o, e.stick)[0]), this.triggerExternalDrop(a, n, i, r, s)
    },
    triggerExternalDrop: function(t, e, n, i, r) {
      this.trigger("drop", n[0], e.start, i, r), t && this.trigger("eventReceive", null, t)
    },
    renderDrag: function(t, e) {},
    destroyDrag: function() {},
    isEventResizable: function(t) {
      var e = t.source || {};
      return G(t.durationEditable, e.durationEditable, this.opt("eventDurationEditable"), t.editable, e.editable, this.opt("editable"))
    },
    reportEventResize: function(t, e, n, i) {
      var r = this.calendar,
        s = r.mutateEvent(t, {
          end: e
        }),
        o = function() {
          s.undo(), r.reportEventChange()
        };
      this.triggerEventResize(t, s.durationDelta, o, n, i), r.reportEventChange()
    },
    triggerEventResize: function(t, e, n, i, r) {
      this.trigger("eventResize", i[0], t, e, n, r, {})
    },
    select: function(t, e) {
      this.unselect(e), this.renderSelection(t), this.reportSelection(t, e)
    },
    renderSelection: function(t) {},
    reportSelection: function(t, e) {
      this.isSelected = !0, this.trigger("select", null, t.start, t.end, e)
    },
    unselect: function(t) {
      this.isSelected && (this.isSelected = !1, this.destroySelection(), this.trigger("unselect", null, t))
    },
    destroySelection: function() {},
    documentMousedown: function(e) {
      var n;
      this.isSelected && this.opt("unselectAuto") && v(e) && (n = this.opt("unselectCancel"), n && t(e.target).closest(n).length || this.unselect(e))
    },
    initHiddenDays: function() {
      var e, n = this.opt("hiddenDays") || [],
        i = [],
        r = 0;
      for (this.opt("weekends") === !1 && n.push(0, 6), e = 0; 7 > e; e++)(i[e] = -1 !== t.inArray(e, n)) || r++;
      if (!r) throw "invalid hiddenDays";
      this.isHiddenDayHash = i
    },
    isHiddenDay: function(t) {
      return e.isMoment(t) && (t = t.day()), this.isHiddenDayHash[t]
    },
    skipHiddenDays: function(t, e, n) {
      var i = t.clone();
      for (e = e || 1; this.isHiddenDayHash[(i.day() + (n ? e : 0) + 7) % 7];) i.add(e, "days");
      return i
    },
    computeDayRange: function(t) {
      var e, n = t.start.clone().stripTime(),
        i = t.end,
        r = null;
      return i && (r = i.clone().stripTime(), e = +i.time(), e && e >= this.nextDayThreshold && r.add(1, "days")), (!i || n >= r) && (r = n.clone().add(1, "days")), {
        start: n,
        end: r
      }
    },
    isMultiDayEvent: function(t) {
      var e = this.computeDayRange(t);
      return e.end.diff(e.start, "days") > 1
    }
  });
  Dt.sourceNormalizers = [], Dt.sourceFetchers = [];
  var Qt = {
      dataType: "json",
      cache: !1
    },
    Jt = 1,
    te = Tt.basic = Kt.extend({
      dayGrid: null,
      dayNumbersVisible: !1,
      weekNumbersVisible: !1,
      weekNumberWidth: null,
      headRowEl: null,
      initialize: function() {
        this.dayGrid = new $t(this), this.coordMap = this.dayGrid.coordMap
      },
      setRange: function(t) {
        Kt.prototype.setRange.call(this, t), this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit), this.dayGrid.setRange(t)
      },
      computeRange: function(t) {
        var e = Kt.prototype.computeRange.call(this, t);
        return /year|month/.test(e.intervalUnit) && (e.start.startOf("week"), e.start = this.skipHiddenDays(e.start), e.end.weekday() && (e.end.add(1, "week").startOf("week"), e.end = this.skipHiddenDays(e.end, -1, !0))), e
      },
      render: function() {
        this.dayNumbersVisible = this.dayGrid.rowCnt > 1, this.weekNumbersVisible = this.opt("weekNumbers"), this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible, this.el.addClass("fc-basic-view").html(this.renderHtml()), this.headRowEl = this.el.find("thead .fc-row"), this.scrollerEl = this.el.find(".fc-day-grid-container"), this.dayGrid.coordMap.containerEl = this.scrollerEl, this.dayGrid.el = this.el.find(".fc-day-grid"), this.dayGrid.render(this.hasRigidRows())
      },
      destroy: function() {
        this.dayGrid.destroy(), Kt.prototype.destroy.call(this)
      },
      renderHtml: function() {
        return '<table><thead><tr><td class="' + this.widgetHeaderClass + '">' + this.dayGrid.headHtml() + '</td></tr></thead><tbody><tr><td class="' + this.widgetContentClass + '"><div class="fc-day-grid-container"><div class="fc-day-grid"/></div></td></tr></tbody></table>'
      },
      headIntroHtml: function() {
        return this.weekNumbersVisible ? '<th class="fc-week-number ' + this.widgetHeaderClass + '" ' + this.weekNumberStyleAttr() + "><span>" + N(this.opt("weekNumberTitle")) + "</span></th>" : void 0
      },
      numberIntroHtml: function(t) {
        return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + "><span>" + this.calendar.calculateWeekNumber(this.dayGrid.getCell(t, 0).start) + "</span></td>" : void 0
      },
      dayIntroHtml: function() {
        return this.weekNumbersVisible ? '<td class="fc-week-number ' + this.widgetContentClass + '" ' + this.weekNumberStyleAttr() + "></td>" : void 0
      },
      introHtml: function() {
        return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + "></td>" : void 0
      },
      numberCellHtml: function(t) {
        var e, n = t.start;
        return this.dayNumbersVisible ? (e = this.dayGrid.getDayClasses(n), e.unshift("fc-day-number"), '<td class="' + e.join(" ") + '" data-date="' + n.format() + '">' + n.date() + "</td>") : "<td/>"
      },
      weekNumberStyleAttr: function() {
        return null !== this.weekNumberWidth ? 'style="width:' + this.weekNumberWidth + 'px"' : ""
      },
      hasRigidRows: function() {
        var t = this.opt("eventLimit");
        return t && "number" != typeof t
      },
      updateWidth: function() {
        this.weekNumbersVisible && (this.weekNumberWidth = h(this.el.find(".fc-week-number")))
      },
      setHeight: function(t, e) {
        var n, i = this.opt("eventLimit");
        g(this.scrollerEl), a(this.headRowEl), this.dayGrid.destroySegPopover(), i && "number" == typeof i && this.dayGrid.limitRows(i), n = this.computeScrollerHeight(t), this.setGridHeight(n, e), i && "number" != typeof i && this.dayGrid.limitRows(i), !e && f(this.scrollerEl, n) && (o(this.headRowEl, m(this.scrollerEl)), n = this.computeScrollerHeight(t), this.scrollerEl.height(n), this.restoreScroll())
      },
      setGridHeight: function(t, e) {
        e ? c(this.dayGrid.rowEls) : u(this.dayGrid.rowEls, t, !0)
      },
      renderEvents: function(t) {
        this.dayGrid.renderEvents(t), this.updateHeight()
      },
      getEventSegs: function() {
        return this.dayGrid.getEventSegs()
      },
      destroyEvents: function() {
        this.recordScroll(), this.dayGrid.destroyEvents()
      },
      renderDrag: function(t, e) {
        return this.dayGrid.renderDrag(t, e)
      },
      destroyDrag: function() {
        this.dayGrid.destroyDrag()
      },
      renderSelection: function(t) {
        this.dayGrid.renderSelection(t)
      },
      destroySelection: function() {
        this.dayGrid.destroySelection()
      }
    });
  n({
    fixedWeekCount: !0
  });
  var ee = Tt.month = te.extend({
    computeRange: function(t) {
      var e, n = te.prototype.computeRange.call(this, t);
      return this.isFixedWeeks() && (e = Math.ceil(n.end.diff(n.start, "weeks", !0)), n.end.add(6 - e, "weeks")), n
    },
    setGridHeight: function(t, e) {
      e = e || "variable" === this.opt("weekMode"), e && (t *= this.rowCnt / 6), u(this.dayGrid.rowEls, t, !e)
    },
    isFixedWeeks: function() {
      var t = this.opt("weekMode");
      return t ? "fixed" === t : this.opt("fixedWeekCount")
    }
  });
  ee.duration = {
    months: 1
  }, Tt.basicWeek = {
    type: "basic",
    duration: {
      weeks: 1
    }
  }, Tt.basicDay = {
    type: "basic",
    duration: {
      days: 1
    }
  }, n({
    allDaySlot: !0,
    allDayText: "all-day",
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    minTime: "00:00:00",
    maxTime: "24:00:00",
    slotEventOverlap: !0
  });
  var ne = 5;
  Tt.agenda = Kt.extend({
    timeGrid: null,
    dayGrid: null,
    axisWidth: null,
    noScrollRowEls: null,
    bottomRuleEl: null,
    bottomRuleHeight: null,
    initialize: function() {
      this.timeGrid = new qt(this), this.opt("allDaySlot") ? (this.dayGrid = new $t(this), this.coordMap = new It([this.dayGrid.coordMap, this.timeGrid.coordMap])) : this.coordMap = this.timeGrid.coordMap
    },
    setRange: function(t) {
      Kt.prototype.setRange.call(this, t), this.timeGrid.setRange(t), this.dayGrid && this.dayGrid.setRange(t)
    },
    render: function() {
      this.el.addClass("fc-agenda-view").html(this.renderHtml()), this.scrollerEl = this.el.find(".fc-time-grid-container"), this.timeGrid.coordMap.containerEl = this.scrollerEl, this.timeGrid.el = this.el.find(".fc-time-grid"), this.timeGrid.render(), this.bottomRuleEl = t('<hr class="' + this.widgetHeaderClass + '"/>').appendTo(this.timeGrid.el), this.dayGrid && (this.dayGrid.el = this.el.find(".fc-day-grid"), this.dayGrid.render(), this.dayGrid.bottomCoordPadding = this.dayGrid.el.next("hr").outerHeight()), this.noScrollRowEls = this.el.find(".fc-row:not(.fc-scroller *)")
    },
    destroy: function() {
      this.timeGrid.destroy(), this.dayGrid && this.dayGrid.destroy(), Kt.prototype.destroy.call(this)
    },
    renderHtml: function() {
      return '<table><thead><tr><td class="' + this.widgetHeaderClass + '">' + this.timeGrid.headHtml() + '</td></tr></thead><tbody><tr><td class="' + this.widgetContentClass + '">' + (this.dayGrid ? '<div class="fc-day-grid"/><hr class="' + this.widgetHeaderClass + '"/>' : "") + '<div class="fc-time-grid-container"><div class="fc-time-grid"/></div></td></tr></tbody></table>'
    },
    headIntroHtml: function() {
      var t, e, n, i;
      return this.opt("weekNumbers") ? (t = this.timeGrid.getCell(0).start, e = this.calendar.calculateWeekNumber(t), n = this.opt("weekNumberTitle"), i = this.opt("isRTL") ? e + n : n + e, '<th class="fc-axis fc-week-number ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + "><span>" + N(i) + "</span></th>") : '<th class="fc-axis ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + "></th>"
    },
    dayIntroHtml: function() {
      return '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + "><span>" + (this.opt("allDayHtml") || N(this.opt("allDayText"))) + "</span></td>"
    },
    slotBgIntroHtml: function() {
      return '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + "></td>"
    },
    introHtml: function() {
      return '<td class="fc-axis" ' + this.axisStyleAttr() + "></td>"
    },
    axisStyleAttr: function() {
      return null !== this.axisWidth ? 'style="width:' + this.axisWidth + 'px"' : ""
    },
    updateSize: function(t) {
      t && this.timeGrid.resize(), Kt.prototype.updateSize.call(this, t)
    },
    updateWidth: function() {
      this.axisWidth = h(this.el.find(".fc-axis"))
    },
    setHeight: function(t, e) {
      var n, i;
      null === this.bottomRuleHeight && (this.bottomRuleHeight = this.bottomRuleEl.outerHeight()), this.bottomRuleEl.hide(), this.scrollerEl.css("overflow", ""), g(this.scrollerEl), a(this.noScrollRowEls), this.dayGrid && (this.dayGrid.destroySegPopover(), n = this.opt("eventLimit"), n && "number" != typeof n && (n = ne), n && this.dayGrid.limitRows(n)), e || (i = this.computeScrollerHeight(t), f(this.scrollerEl, i) ? (o(this.noScrollRowEls, m(this.scrollerEl)), i = this.computeScrollerHeight(t), this.scrollerEl.height(i), this.restoreScroll()) : (this.scrollerEl.height(i).css("overflow", "hidden"), this.bottomRuleEl.show()))
    },
    initializeScroll: function() {
      function t() {
        n.scrollerEl.scrollTop(r)
      }
      var n = this,
        i = e.duration(this.opt("scrollTime")),
        r = this.timeGrid.computeTimeTop(i);
      r = Math.ceil(r), r && r++, t(), setTimeout(t, 0)
    },
    renderEvents: function(t) {
      var e, n, i = [],
        r = [],
        s = [];
      for (n = 0; n < t.length; n++) t[n].allDay ? i.push(t[n]) : r.push(t[n]);
      e = this.timeGrid.renderEvents(r), this.dayGrid && (s = this.dayGrid.renderEvents(i)), this.updateHeight()
    },
    getEventSegs: function() {
      return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : [])
    },
    destroyEvents: function() {
      this.recordScroll(), this.timeGrid.destroyEvents(), this.dayGrid && this.dayGrid.destroyEvents()
    },
    renderDrag: function(t, e) {
      return t.start.hasTime() ? this.timeGrid.renderDrag(t, e) : this.dayGrid ? this.dayGrid.renderDrag(t, e) : void 0
    },
    destroyDrag: function() {
      this.timeGrid.destroyDrag(), this.dayGrid && this.dayGrid.destroyDrag()
    },
    renderSelection: function(t) {
      t.start.hasTime() || t.end.hasTime() ? this.timeGrid.renderSelection(t) : this.dayGrid && this.dayGrid.renderSelection(t)
    },
    destroySelection: function() {
      this.timeGrid.destroySelection(), this.dayGrid && this.dayGrid.destroySelection()
    }
  }), Tt.agendaWeek = {
    type: "agenda",
    duration: {
      weeks: 1
    }
  }, Tt.agendaDay = {
    type: "agenda",
    duration: {
      days: 1
    }
  }, n({
    yearColumns: 2,
    fixedWeekCount: 5
  }), Tt.year = Kt.extend({
    dayNumbersVisible: !0,
    weekNumbersVisible: !1,
    weekNumberWidth: null,
    table: null,
    body: null,
    bodyRows: null,
    subTables: null,
    bodyCells: null,
    daySegmentContainer: null,
    colCnt: null,
    rowCnt: null,
    dayGrids: [],
    rtl: null,
    dis: null,
    dit: null,
    firstDay: 0,
    firstMonth: null,
    lastMonth: null,
    yearColumns: 2,
    nbMonths: null,
    hiddenMonths: [],
    nwe: null,
    tm: null,
    colFormat: null,
    dayGrid: null,
    coordMap: null,
    otherMonthDays: [],
    rowsForMonth: [],
    initialize: function() {
      this.updateOptions(), this.dayGrid = new $t(this), this.dayGrids[0] = this.dayGrid, this.coordMap = this.dayGrid.coordMap
    },
    updateOptions: function() {
      this.rtl = this.opt("isRTL"), this.rtl ? (this.dis = -1, this.dit = this.colCnt - 1) : (this.dis = 1, this.dit = 0), this.firstDay = parseInt(this.opt("firstDay"), 10), this.firstMonth = parseInt(this.opt("firstMonth"), 10) || 0, this.lastMonth = this.opt("lastMonth") || this.firstMonth + 12, this.hiddenMonths = this.opt("hiddenMonths") || [], this.yearColumns = parseInt(this.opt("yearColumns"), 10) || 2, this.colFormat = this.opt("columnFormat"), this.weekNumbersVisible = this.opt("weekNumbers"), this.nwe = this.opt("weekends") ? 0 : 1, this.tm = this.opt("theme") ? "ui" : "fc", this.nbMonths = this.lastMonth - this.firstMonth, this.lastMonth = this.lastMonth % 12, this.lang = this.opt("lang")
    },
    computeTitle: function() {
      if (null !== this.opt("yearTitleFormat")) {
        var t = this.intervalStart.locale(this.lang).format(this.opt("yearTitleFormat")),
          e = this.intervalStart.clone().add(this.nbMonths - 1, "months");
        return e.year() != this.intervalStart.year() && (t += this.intervalEnd.format(" - YYYY")), t
      }
      return this.formatRange({
        start: this.intervalStart,
        end: this.intervalEnd
      }, this.opt("titleFormat") || this.computeTitleFormat(), this.opt("titleRangeSeparator"))
    },
    render: function(t) {
      var e = Math.floor(this.intervalStart.month() / this.nbMonths) * this.nbMonths;
      !e && this.firstMonth > 0 && !this.opt("lastMonth") && (e = (this.firstMonth + e) % 12), this.intervalStart = Dt.moment([this.intervalStart.year(), e, 1]), this.intervalEnd = this.intervalStart.clone().add(this.nbMonths, "months").add(-15, "minutes"), this.start = this.intervalStart.clone(), this.start = this.skipHiddenDays(this.start), this.start.startOf("week"), this.start = this.skipHiddenDays(this.start), this.end = this.intervalEnd.clone(), this.end = this.skipHiddenDays(this.end, -1, !0), this.end.add((7 - this.end.weekday()) % 7, "days"), this.end = this.skipHiddenDays(this.end, -1, !0);
      var n = parseInt(this.opt("yearColumns"), 10),
        i = this.opt("weekends") ? 7 : 5;
      this.renderYear(n, i, !0)
    },
    renderYear: function(t, e, n) {
      this.colCnt = e;
      var i = !this.table;
      i || (this.destroyEvents(), this.table.remove()), this.buildSkeleton(this.yearColumns, n), this.buildDayGrids(), this.updateCells()
    },
    setRange: function(t) {
      Kt.prototype.setRange.call(this, t)
    },
    computeRange: function(t) {
      this.constructor.duration = {
        months: this.nbMonths || 12
      };
      var e = Kt.prototype.computeRange.call(this, t);
      return /year|month/.test(e.intervalUnit) && (e.start.startOf("week"), e.start = this.skipHiddenDays(e.start), e.end.weekday() && (e.end.add(1, "week").startOf("week"), e.end = this.skipHiddenDays(e.end, -1, !0))), e
    },
    buildSkeleton: function(e, n) {
      var i, r, s, o, a = 0,
        l = 0,
        d = this.intervalStart.year(),
        u = this.tm + "-widget-header",
        c = this.opt("dayNamesShort"),
        h = this.opt("monthNames");
      for (this.rowCnt = 0, o = '<table class="fc-year-main-table fc-border-separate" style="width:100%;"><tr>', o += '<td class="fc-year-month-border fc-first"></td>', r = 0; r < this.nbMonths; r++) {
        var f = this.intervalStart.month() + r,
          g = -1 != t.inArray(f % 12, this.hiddenMonths),
          p = g ? "display:none;" : "",
          m = Dt.moment([d + f / 12, f % 12, 1]).locale(this.lang),
          v = h[r % 12],
          y = m.format("YYYYMM");
        if (s = m.year(), this.firstMonth + this.nbMonths > 12 && (v = v + " " + s), r % e === 0 && r > 0 && !g && (l++, o += '<td class="fc-year-month-border fc-last"></td></tr><tr><td class="fc-year-month-border fc-first"></td>'), e > r % e && r % e > 0 && !g && (o += '<td class="fc-year-month-separator"></td>'), o += '<td class="fc-year-monthly-td" style="' + p + '">', o += '<div class="fc-year-monthly-name' + (0 === l ? " fc-first" : "") + '"><a name="' + y + '" data-year="' + s + '" data-month="' + f + '" href="#">' + N(v) + "</a></div>", o += '<div class="fc-row ' + u + '">', o += '<table class="fc-year-month-header"><thead><tr class="fc-year-week-days">', 0 == this.opt("isRTL"))
          for (o += this.headIntroHtml(), i = this.firstDay; i < this.colCnt + this.firstDay; i++) o += '<th class="fc-day-header fc-year-weekly-head fc-' + Gt[i % 7] + " " + u + '">' + c[i % 7] + "</th>";
        else {
          for (i = this.colCnt + this.firstDay - 1; i > this.firstDay - 1; i--) o += '<th class="fc-day-header fc-year-weekly-head fc-' + Gt[i % 7] + " " + u + '">' + c[i % 7] + "</th>";
          o += this.headIntroHtml()
        }
        o += "</tr><tr></tr></thead></table>", o += "</div>", o += '<div class="fc-day-grid-container"><div class="fc-day-grid">', o += "</div></div>", o += '<div class="fc-year-monthly-footer"></div>', o += "</td>", g && a++
      }
      o += '<td class="fc-year-month-border fc-last"></td>', o += "</tr></table>", this.table = t(o).appendTo(this.el), this.bodyRows = this.table.find(".fc-day-grid .fc-week"), this.bodyCells = this.bodyRows.find("td.fc-day"), this.bodyFirstCells = this.bodyCells.filter(":first-child"), this.subTables = this.table.find("td.fc-year-monthly-td"), this.head = this.table.find("thead"), this.head.find("tr.fc-year-week-days th.fc-year-weekly-head:first").addClass("fc-first"), this.head.find("tr.fc-year-week-days th.fc-year-weekly-head:last").addClass("fc-last"), this.table.find(".fc-year-monthly-name a").click(this.calendar, function(e) {
        e.data.changeView("month"), e.data.gotoDate([t(this).attr("data-year"), t(this).attr("data-month"), 1])
      }), this.dayBind(this.bodyCells), this.daySegmentContainer = t('<div style="position:absolute;z-index:8;top:0;left:0;"/>').appendTo(this.table)
    },
    buildDayGrids: function() {
      for (var e = this, n = [], i = 0; i < this.nbMonths; i++) n.push(i + this.intervalStart.month());
      var r = e.intervalStart.clone();
      this.firstDay;
      e.dayGrids = [], t.each(n, function(t, n) {
        var i = new $t(e),
          s = e.tableByOffset(t),
          o = r.clone().add(t, "months");
        i.headRowEl = s.find(".fc-row:first"), i.scrollerEl = s.find(".fc-day-grid-container"), i.coordMap.containerEl = i.scrollerEl, i.el = s.find(".fc-day-grid"), i.offset = t, i.rowData = [], i.colData = [];
        var a = e.computeMonthRange(o);
        i.start = a.start, i.end = a.end, i.breakOnWeeks = !0, i.updateCells(), e.dayNumbersVisible = i.rowCnt > 1, i.numbersVisible = e.dayNumbersVisible || e.weekNumbersVisible, $t.prototype.render.call(i, e.hasRigidRows()), e.dayGrids.push(i)
      }), e.dayGrid = e.dayGrids[0], e.coordMap = e.dayGrid.coordMap
    },
    isFixedWeeks: function() {
      var t = this.opt("weekMode");
      return t ? "fixed" === t : this.opt("fixedWeekCount")
    },
    computeMonthRange: function(t) {
      var e = this.firstDay;
      this.constructor.duration = {
        months: 1
      };
      var n = Kt.prototype.computeRange.call(this, t);
      if (/year|month/.test(n.intervalUnit)) {
        n.start.startOf("week"), n.start = this.skipHiddenDays(n.start), n.start.day(e), n.end.day(e), n.start.date() > 1 && n.start.date() <= 7 && n.start.subtract(7, "days");
        var i = Math.ceil(n.end.diff(n.start, "weeks", !0));
        5 === this.isFixedWeeks() ? 4 == i && n.end.add(1, "weeks") : this.isFixedWeeks() && 6 >= i && n.end.add(6 - i, "weeks")
      }
      return n
    },
    destroy: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroy()
      }), Kt.prototype.destroy.call(this)
    },
    updateCells: function() {
      var n = this;
      this.subTables.find(".fc-week:first").addClass("fc-first"), this.subTables.find(".fc-week:last").addClass("fc-last"), this.subTables.find(".fc-bg").find("td.fc-day:last").addClass("fc-last"), this.subTables.each(function(i, r) {
        n.curYear || (n.curYear = n.intervalStart);
        var s = n.curYear.clone(),
          o = (i + n.intervalStart.month()) % 12;
        s = n.dayGrids[i].start;
        var a = 0;
        t(r).find(".fc-bg").find("td.fc-day:first").addClass("fc-first"), n.otherMonthDays[o] = [0, 0, 0, 0], t(r).find(".fc-content-skeleton tr").each(function(n, r) {
          t(r).find("td").not(".fc-week-number").each(function(n, r) {
            var s = t(r),
              o = e(s.attr("data-date"));
            o.month() != i ? (s.addClass("fc-other-month"), o.month() == i ? s.addClass("fc-prev-month") : s.addClass("fc-next-month")) : a = o
          })
        })
      }), n.bodyRows.filter(".fc-year-have-event").removeClass("fc-year-have-event")
    },
    headIntroHtml: function() {
      var t = null != this.opt("weekNumberTitle") ? this.opt("weekNumberTitle").substring(0, 1) : "";
      return this.weekNumbersVisible ? '<th class="fc-week-number-head ' + this.widgetHeaderClass + '"><span>' + N(t) + "</span></th>" : ""
    },
    numberIntroHtml: function(t, e) {
      if (this.weekNumbersVisible) {
        e = e || this.dayGrid;
        var n;
        return n = 0 == this.opt("isRTL") ? this.calendar.calculateWeekNumber(e.getCell(t, 0).start) : this.calendar.calculateWeekNumber(e.getCell(t, 6).start), '<td class="fc-week-number" ' + this.weekNumberStyleAttr("") + "><span>" + n + "</span></td>"
      }
      return ""
    },
    dayIntroHtml: function() {
      return this.weekNumbersVisible ? '<td class="fc-week-number ' + this.widgetContentClass + '" ' + this.weekNumberStyleAttr("") + "></td>" : ""
    },
    introHtml: function() {
      return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr("") + "></td>" : ""
    },
    weekNumberStyleAttr: function() {
      var t = "";
      return null !== this.weekNumberWidth && (t = 'style="width:' + this.weekNumberWidth + 'px;"'), t
    },
    numberCellHtml: function(t) {
      if (!this.dayNumbersVisible) return "<td/>";
      var e = t.start,
        n = this.dayGrid.getDayClasses(e);
      return n.unshift("fc-day-number"), '<td class="' + n.join(" ") + '" data-date="' + e.format() + '">' + e.date() + "</td>"
    },
    hasRigidRows: function() {
      var t = this.opt("eventLimit");
      return t && "number" != typeof t
    },
    cellsForMonth: function(t) {
      return this.rowsForMonth[t] * (this.nwe ? 5 : 7)
    },
    addDays: function(t, e) {
      t.add(e, "days")
    },
    skipWeekend: function(t, e, n) {
      for (e = e || 1; !t.day() || n && 1 == t.day() || !n && 6 == t.day();) this.addDays(t, e);
      return t
    },
    daysInMonth: function(t, e) {
      return Dt.moment([t, e, 0]).date()
    },
    dateInMonth: function(t, e) {
      return t.month() == e % 12
    },
    rowToGridOffset: function(t) {
      for (var e = 0, n = this.firstMonth; n < this.lastMonth; n++)
        if (e += this.rowsForMonth[n], e > t) return n - this.firstMonth;
      return -1
    },
    rowToGridRow: function(t) {
      for (var e = 0, n = this.firstMonth; n < this.lastMonth; n++)
        if (e += this.rowsForMonth[n], e > t) return t - (e - this.rowsForMonth[n]);
      return -1
    },
    tableByOffset: function(e) {
      return t(this.subTables[e])
    },
    setGridHeight: function(e, n, i) {
      return "undefined" != typeof i ? void(n ? c(i.rowEls) : u(i.rowEls, e, !0)) : void t.each(this.dayGrids, function(t, i) {
        n ? c(i.rowEls) : u(i.rowEls, e, !0)
      })
    },
    computeScrollerHeight: function(t, e) {
      var n, i;
      e = e || this.scrollerEl;
      var r = e.closest(".fc-year-monthly-td");
      return n = r.add(e), n.css({
        position: "relative",
        left: -1
      }), i = r.outerHeight() - e.height(), n.css({
        position: "",
        left: ""
      }), t - i
    },
    setHeight: function(e, n) {
      var i, r = this,
        s = this.opt("eventLimit");
      t.each(this.dayGrids, function(t, l) {
        l.el.length > 0 && (g(l.scrollerEl), a(l.headRowEl), l.destroySegPopover(), s && "number" == typeof s && l.limitRows(s), i || (i = r.computeScrollerHeight(e, l.scrollerEl)), r.setGridHeight(i, n, l), s && "number" != typeof s && l.limitRows(s), !n && f(l.scrollerEl, i) && (o(l.headRowEl, m(l.scrollerEl)),
          i = r.computeScrollerHeight(e, l.scrollerEl), l.scrollerEl.height(i), r.restoreScroll()))
      })
    },
    updateWidth: function() {
      this.weekNumbersVisible && (this.weekNumberWidth = h(this.el.find(".fc-week-number")), this.weekNumberWidth && this.el.find(".fc-week-number-head").width(this.weekNumberWidth + 2))
    },
    updateHeight: function() {
      var t = this.calendar;
      if (this.yearColumns > 0) {
        var e = t.getSuggestedViewHeight() * (1.1 / (.01 + this.yearColumns));
        this.setHeight(e, t.isHeightAuto())
      }
    },
    dayBind: function(t) {
      t.click(this.dayClick)
    },
    dayClick: function(e) {
      if (!this.opt("selectable")) {
        var n = this.className.match(/fc\-day\-(\d+)\-(\d+)\-(\d+)/),
          i = new Date(n[1], n[2] - 1, n[3]);
        t.trigger("dayClick", this, Dt.moment(i), !0, e)
      }
    },
    renderEvents: function(e) {
      t.each(this.dayGrids, function(t, n) {
        n.renderEvents(e)
      }), this.updateHeight()
    },
    getEventSegs: function() {
      var e = [];
      return t.each(this.dayGrids, function(t, n) {
        for (var i = n.getEventSegs(), r = 0; r < i.length; r++) e.push(i[r])
      }), e
    },
    destroyEvents: function() {
      this.recordScroll(), t.each(this.dayGrids, function(t, e) {
        e.destroyEvents()
      })
    },
    renderDrag: function(e, n) {
      var i = !1;
      return t.each(this.dayGrids, function(t, i) {
        i.renderDrag(e, n)
      }), i
    },
    destroyDrag: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroyDrag()
      })
    },
    renderSelection: function(e, n) {
      t.each(this.dayGrids, function(t, i) {
        i !== n && (i.start <= e.end || i.end >= e.start) && i.renderSelection(e)
      })
    },
    destroySelection: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroySelection()
      })
    }
  })
});
/*! RESOURCE: /scripts/reportcommon/report_includes_hardcoded_defaults.js */
var chartHelpers = window.chartHelpers || {};
chartHelpers.i18n = chartHelpers.i18n || {};
chartHelpers.i18n.building = "Building chart, please wait...";
chartHelpers.i18n.total = "Total";
chartHelpers.i18n.maxCells = "The size of the pivot table is too big. Use filters to reduce it or switch to a modern browser.";
chartHelpers.i18n.chartGenerationError = "An error occurred while generating chart. Please try again later.";
chartHelpers.i18n.showAsHeatmap = "Show data as a heatmap visualization";
chartHelpers.i18n.showAsMarkers = "Show data using latitude and longitude";
chartHelpers.i18n.highlightBasedOn = "Highlight based on:";
chartHelpers.i18n.isRTL = false;
chartHelpers.i18n.weekNumberTitle = "Week";
chartHelpers.i18n.weekNumberTitleShort = "W";
chartHelpers.i18n.seeMoreEvents = "See {0} more events";
chartHelpers.i18n.viewEventsInList = "View {0} events in a list";
chartHelpers.i18n.viewAllEventsInList = "View all events in a list";
chartHelpers.i18n.viewAllRecords = "View all records";
chartHelpers.i18n.none = "None";
chartHelpers.i18n.plusMany = "+ many";
chartHelpers.i18n.plusMore = "+ {0} more";
chartHelpers.i18n.buttonText = {
  prevYear: "",
  nextYear: "",
  today: 'today',
  year: 'year',
  month: 'month',
  week: 'week',
  day: 'day'
};
chartHelpers.i18n.allDayHtml = "all-day";
chartHelpers.i18n.daysNames = ['Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday'
];
chartHelpers.i18n.dayNamesShort = ['Sun',
  'Mon',
  'Tue',
  'Wed',
  'Thu',
  'Fri',
  'Sat'
];
chartHelpers.i18n.monthNames = ['January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December'
];
chartHelpers.i18n.monthNamesShort = ['Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
];
chartHelpers.i18n.none = '-- None --';
chartHelpers.i18n.groupBy = 'Group by';
chartHelpers.i18n.groupByTitle = 'Select a different group by field';
chartHelpers.i18n.stackBy = 'Stacked by';
chartHelpers.i18n.stackByTitle = 'Select a different stacked by field';
chartHelpers.i18n.saveAsJpg = 'Save as JPEG';
chartHelpers.i18n.saveAsPng = 'Save as PNG';
chartHelpers.device = {};
chartHelpers.device.type = "doctype";
chartHelpers.systemParams = {
  firstDay: 1,
  defaultDate: "2017-01-01",
  maxEventsDisplayedPerCell: 3,
  maxMoreEventsPerDay: 30,
  defaultEventDuration: "01:00:00",
  maxDaysBack: 30,
  enablePreviewOnHover: false,
  isCalendarV2Enabled: true,
  fixedHeaders: true,
  slotEventOverlap: false
};;
/*! RESOURCE: /scripts/reportcommon/chart-helpers.js */
var chartHelpers = window.chartHelpers || {};
chartHelpers.objectSize = function objectSize(obj) {
  var size = 0;
  var key;
  for (key in obj)
    if (obj.hasOwnProperty(key))
      size++;
  return size;
};
chartHelpers.compareByProperty = function compareByProperty(property, desc) {
  return function propertyCompare(a, b) {
    if (a[property] > b[property])
      return desc ? -1 : 1;
    if (a[property] < b[property])
      return desc ? 1 : -1;
    return 0;
  };
};
chartHelpers.evaluateColorRules = function evaluateColorRules(score, rules) {
  if (typeof score !== 'undefined' && score !== null && score !== '' && rules) {
    rules.sort(chartHelpers.compareByProperty('ruleOrder', true));
    var operate = {
      '<': function lessThan(x, y) {
        return x < y;
      },
      '<=': function lessThanEqual(x, y) {
        return x <= y;
      },
      '=': function Equal(x, y) {
        return x === y;
      },
      '>=': function greaterThanEqual(x, y) {
        return x >= y;
      },
      '>': function greaterThan(x, y) {
        return x > y;
      },
      between: function between(x, y, z) {
        return x > y && x < z;
      }
    };
    for (var i = 0; i < rules.length; i++)
      if (operate[rules[i].operator](score, rules[i].value1, rules[i].value2))
        return {
          color: rules[i].color,
          bgColor: rules[i].bgColor
        };
  }
  return '';
};
chartHelpers.hexEncode = function(utf8String) {
  var hex;
  var i;
  var result = '';
  for (i = 0; i < utf8String.length; i++) {
    hex = utf8String.charCodeAt(i).toString(16);
    result += '\\u' + ('000' + hex).slice(-4);
  }
  return result;
};;
/*! RESOURCE: /scripts/reportcommon/display_grid.js */
function checkAndEnableDisplayGrid(chartData, args) {
  args.otherDisplay = 'Other';
  args.otherDisplayMore = '(more...)';
  if ('report_properties' in chartData) {
    args.otherDisplay = chartData.report_properties.other_display;
    args.otherDisplayMore = chartData.report_properties.other_display_more;
  }
  var $gridTable = getGridTable(args);
  var hasData = (chartData.series[0].xvalues && chartData.series[0].xvalues.length) || args.chart_type === 'solid_gauge' || args.chart_type === 'angular_gauge';
  if ($gridTable.length && hasData) {
    $gridTable.attr({
      tabindex: '0',
      role: 'grid'
    });
    $gridTable.html('<thead>' +
      '<tr class="header display_grid_header" role="row">' +
      '</tr>' +
      '</thead>' +
      '<tbody class="display_grid_body"/>');
    enableDisplayGrid($gridTable, chartData, args);
  } else
    $gridTable.empty();
}

function enableDisplayGrid($gridTable, chartData, args) {
  if (args.chart_type === 'box' || args.chart_type === 'tbox')
    createBoxDisplayGrid($gridTable, chartData);
  else if (args.chart_type === 'control')
    showControlDisplayGrid($gridTable, chartData);
  else if (args.chart_type === 'solid_gauge' || args.chart_type === 'angular_gauge')
    createGaugeDisplayGrid($gridTable, chartData);
  else
    showDisplayGrid($gridTable, chartData, isTwoLevelDisplayGrid(args), args);
  if (args.display_grid)
    $gridTable.show();
  else
    $gridTable.hide();
  addAccessibility($gridTable, chartData, args);
}

function showDisplayGrid($gridTable, chartData, hasStacking, args) {
  var otherKey = 'zzyynomatchaabb';
  var $gridTableBody = getGridTableBody($gridTable);
  var yDispValsExist = false;
  if (chartData.series.length) {
    var seriesData = chartData.series[0];
    if ('ydisplayvalues' in seriesData && seriesData.ydisplayvalues !== '')
      yDispValsExist = true;
    var trClass = 'odd';
    var omitOther = false;
    if ('display_grid_xvalues' in seriesData)
      omitOther = true;
    if (seriesData.xvalues !== undefined && seriesData.xvalues.length) {
      createBasicDisplayGridHeader($gridTable, seriesData, chartData.report_properties.percents_from_count, hasStacking);
      var multipleOther = false;
      for (var j = 0; j < seriesData.xvalues.length; j++) {
        var value = seriesData.xvalues[j];
        if (value === otherKey && omitOther)
          if (j === seriesData.xvalues.length - 1)
            break;
        if (value === args.otherDisplay && j < seriesData.xvalues.length - 1)
          multipleOther = true;
        if (value === otherKey) {
          if (multipleOther)
            value = args.otherDisplay + ' ' + args.otherDisplayMore;
          else
            value = args.otherDisplay;
        }
        if (yDispValsExist)
          var yVal = seriesData.ydisplayvalues[j];
        else
          yVal = seriesData.yvalues[j];
        if (yVal) {
          var row = createRowForGrid(trClass, value, yVal, seriesData.percentages[j], hasStacking);
          if (trClass === 'odd')
            trClass = 'even';
          else
            trClass = 'odd';
          row.setAttribute('role', 'row');
          $gridTableBody.append(row);
        }
      }
      if ('display_grid_xvalues' in seriesData) {
        var additionalGridYDispValsExist = false;
        if ('display_grid_ydisplayvalues' in seriesData)
          additionalGridYDispValsExist = true;
        for (j = 0; j < seriesData.display_grid_xvalues.length; j++) {
          value = seriesData.display_grid_xvalues[j];
          yVal = null;
          if (additionalGridYDispValsExist)
            yVal = seriesData.display_grid_ydisplayvalues[j];
          else
            yVal = seriesData.display_grid_yvalues[j];
          if (yVal) {
            row = createRowForGrid(trClass, value, yVal, seriesData.display_grid_percents[j], hasStacking);
            if (trClass === 'odd')
              trClass = 'even';
            else
              trClass = 'odd';
            row.setAttribute('role', 'row');
            $gridTableBody.append(row);
          }
        }
      }
      if (hasStacking)
        createTwoLevelDisplayGridTable(chartData, args, $gridTableBody);
      displayGridTotal($gridTableBody, seriesData.display_grid_total, seriesData.total_label, hasStacking);
    }
  }
}

function addAccessibility($gridTable, chartData, args) {
  if (window.g_accessibility === 'true' || window.g_accessibility === true) {
    var $displayGridToggle = getGridExpandAnchor(args);
    var id = $gridTable.attr('id');
    if ($displayGridToggle.length)
      $displayGridToggle.remove();
    $displayGridToggle = jQuery('<a tabindex="0" id="expand.' + id + '" aria-expanded="false" role="button" class="grid-toggle" onclick="toggleDisplayGrid(\'' + id + '\', this)">' +
      '<img title="Click to expand chart data" src="images/section_hide.gifx" alt="Click to expand chart data" width="16px" />' +
      '</a>');
    $gridTable.before($displayGridToggle);
    if (args.display_grid) {
      $displayGridToggle.attr('aria-expanded', true);
      $displayGridToggle.children().attr('src', 'images/section_reveal.gifx');
    }
    $gridTable.prepend('<caption><b></b></caption>');
    $gridTable.find('caption b').text(chartData.series[0].display_grid_title);
  }
}

function createTwoLevelDisplayGridTable(chartData, args, $body) {
  var additionalGridValuesExist = false;
  var seriesData = chartData.series[0];
  var subSeriesData = chartData.series[0].sub_series;
  if (subSeriesData && subSeriesData[0]) {
    createSecondLevelHeader($body, seriesData, chartData.report_properties.percents_from_count);
    if ('display_grid_xvalues' in seriesData && 'dispGridSubSeries' in seriesData)
      additionalGridValuesExist = true;
    var isDuration = false;
    if (('yaxis_duration' in seriesData) && (seriesData.yaxis_duration))
      isDuration = true;
    createSecondLevelDisplayGrid(seriesData.xvalues, subSeriesData, isDuration, $body, args, additionalGridValuesExist);
    if (additionalGridValuesExist) {
      var dispGridSubSeries = chartData.series[0].dispGridSubSeries;
      createSecondLevelDisplayGrid(seriesData.display_grid_xvalues, dispGridSubSeries, isDuration, $body, args, additionalGridValuesExist);
    }
  }
}

function createSecondLevelDisplayGrid(xValues, subSeriesData, isDuration, $body, args, additionalGridValuesExist) {
  var otherKey = 'zzyynomatchaabb';
  var trClass = 'even';
  var multipleOther = false;
  for (var i = 0; i < subSeriesData.length; i++) {
    var firstLevelXVal = xValues[i];
    if (additionalGridValuesExist && firstLevelXVal === otherKey) {
      continue;
    }
    if (!additionalGridValuesExist) {
      if (firstLevelXVal === args.otherDisplay && i < xValues.length - 1)
        multipleOther = true;
      if (firstLevelXVal === otherKey) {
        if (multipleOther)
          firstLevelXVal = args.otherDisplay + ' ' + args.otherDisplayMore;
        else
          firstLevelXVal = args.otherDisplay;
      }
    }
    var curSubSeries = subSeriesData[i];
    if (curSubSeries) {
      var curSubSeriesHasYDispVals = false;
      if ('ydisplayvalues' in curSubSeries && curSubSeries.ydisplayvalues !== '')
        curSubSeriesHasYDispVals = true;
      for (var j = 0; j < curSubSeries.xvalues.length; j++) {
        var row = document.createElement('tr');
        row.className = trClass;
        var chartClass = 'chart';
        if (j === (curSubSeries.xvalues.length - 1))
          chartClass = 'chart-spacer';
        if (j === 0)
          row.appendChild(createDisplayGridHeaderCell('chart-spacer', firstLevelXVal, null, null, null, curSubSeries.xvalues.length));
        xValue = curSubSeries.xvalues[j].displayValue;
        if (xValue === undefined)
          xValue = curSubSeries.xvalues[j];
        row.appendChild(createDisplayGridCell(chartClass, xValue));
        if (curSubSeriesHasYDispVals)
          row.appendChild(createDisplayGridCell(chartClass, curSubSeries.ydisplayvalues[j], 'right'));
        else
          row.appendChild(createDisplayGridCell(chartClass, curSubSeries.yvalues[j], 'right'));
        row.appendChild(createDisplayGridCell(chartClass, curSubSeries.percentages[j] + '%', 'right'));
        if (trClass === 'odd')
          trClass = 'even';
        else
          trClass = 'odd';
        row.setAttribute('role', 'row');
        $body.append(row);
      }
    }
    trClass = 'even';
  }
}

function createBasicDisplayGridHeader($table, series, computePercent, hasStacking) {
  var $header = getGridTableHeader($table);
  var totals = '';
  var colSpan = 1;
  if (hasStacking) {
    totals = ' ' + series.totals_label;
    colSpan = 2;
  }
  $header.append(createDisplayGridHeaderCell('chart', series.group_by_label + totals, null, true, colSpan))
    .append(createDisplayGridHeaderCell('chart', series.yTitle + totals, 'right', true));
  var percentLabel = series.percentage_label + series.aggregate_label;
  if (computePercent || isPieType(series.series_plot_type))
    percentLabel = series.percentage_label + series.table_display_plural;
  $header.append(createDisplayGridHeaderCell('chart', percentLabel, 'right', true));
  series.completePercentLabel = percentLabel;
}

function createSecondLevelHeader($body, series) {
  var $secondHeader = jQuery('<tr class="header display_grid_header"/>');
  $body.append($secondHeader);
  $secondHeader.append(createDisplayGridHeaderCell('chart', series.group_by_label, null, true))
    .append(createDisplayGridHeaderCell('chart', series.second_group_by_label, null, true))
    .append(createDisplayGridHeaderCell('chart', series.yTitle, 'right', true))
    .append(createDisplayGridHeaderCell('chart', series.completePercentLabel, 'right', true));
}

function createBoxDisplayGrid($gridTable, chartData) {
  if (chartData.series.length > 0) {
    var $gridTableBody = getGridTableBody($gridTable);
    var seriesData = chartData.series[0];
    var trClass = 'odd';
    $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.group_by_label, null, true))
      .append(createDisplayGridHeaderCell('chart', seriesData.mean_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.minimum_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.first_quartile_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.median_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.third_quartile_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.maximum_label, 'right', true));
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      var row = document.createElement('tr');
      row.className = trClass;
      var value = seriesData.xvalues[j];
      var style = 'chart';
      var groupByStyle = 'chart';
      row.appendChild(createDisplayGridHeaderCell(groupByStyle, value));
      row.appendChild(createDisplayGridCell(style, seriesData.ydisplayvalues[j], 'right'));
      var boxDisplayVals = seriesData.boxdisplayvalues[j];
      for (var k = 0; k < 5; k++)
        row.appendChild(createDisplayGridCell(style, boxDisplayVals[k], 'right'));
      if (trClass === 'odd')
        trClass = 'even';
      else
        trClass = 'odd';
      row.setAttribute('role', 'row');
      $gridTableBody.append(row);
    }
  }
}

function showControlDisplayGrid($gridTable, chartData) {
  var $gridTableBody = getGridTableBody($gridTable);
  var isDuration = false;
  if (chartData.series.length > 0) {
    var seriesData = chartData.series[0];
    if (('yaxis_duration' in seriesData) && (seriesData.yaxis_duration))
      isDuration = true;
    var $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.group_by_label + ' ' + seriesData.per + ' ' + seriesData.trend, null, true))
      .append(createDisplayGridHeaderCell('chart', seriesData.aggregate_label + ' ' + seriesData.data_points_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.aggregate_label + ' ' + seriesData.trend_line_label, 'right', true));
    var trClass = 'odd';
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      row = document.createElement('tr');
      row.className = trClass;
      var style = 'chart';
      row.appendChild(createDisplayGridCell(style, seriesData.xvalues[j]));
      row.appendChild(createDisplayGridCell(style, seriesData.ydisplayvalues[j], 'right'));
      row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.trenddisplayvalues[j] : seriesData.trendvalues[j], 'right'));
      row.setAttribute('role', 'row');
      $gridTableBody.append(row);
      if (trClass === 'odd')
        trClass = 'even';
      else
        trClass = 'odd';
    }
    var row = document.createElement('tr');
    row.className = 'header display_grid_header';
    row.appendChild(createDisplayGridHeaderCell(style, 'Control Values'));
    row.appendChild(createDisplayGridHeaderCell(style, seriesData.aggregate_label, 'right'));
    row.appendChild(createDisplayGridHeaderCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
    var standDev = seriesData.standard_deviation_label;
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, '-3 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[0] : seriesData.controlvalues[0], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'even';
    row.appendChild(createDisplayGridCell(style, '-2 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration == true ? seriesData.controldisplayvalues[1] : seriesData.controlvalues[1], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, seriesData.mean_label));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[2] : seriesData.controlvalues[2], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'even';
    row.appendChild(createDisplayGridCell(style, '+2 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[3] : seriesData.controlvalues[3], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, '+3 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[4] : seriesData.controlvalues[4], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
  }
}

function createGaugeDisplayGrid($gridTable, chartData) {
  if (chartData.series.length) {
    var seriesData = chartData.series[0];
    var $gridTableBody = getGridTableBody($gridTable);
    var yDispValsExist;
    var $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.yTitle, 'center', true));
    if ('ydisplayvalues' in seriesData && seriesData.ydisplayvalues !== '')
      yDispValsExist = true;
    var row = document.createElement('tr');
    row.className = 'odd';
    var style = 'chart';
    var value;
    if (yDispValsExist)
      value = seriesData.ydisplayvalues;
    else
      value = seriesData.yvalues;
    row.appendChild(createDisplayGridCell(style, value, 'center'));
    row.setAttribute('role', 'row');
    $gridTableBody.append(row);
  }
}

function displayGridTotal($body, total, totalLabel, hasStacking) {
  var $totalRow = jQuery('<tr class="display-grid-total-row" />');
  $totalRow.attr('role', 'row');
  $body.append($totalRow);
  var colSpan = 1;
  if (hasStacking)
    colSpan = 2;
  $totalRow.append(createDisplayGridHeaderCell('chart_total', totalLabel, null, null, colSpan))
    .append(createDisplayGridCell('chart_total', total, 'right'))
    .append(createDisplayGridCell('chart_total', '100%', 'right'));
}

function createRowForGrid(trClass, xVal, yVal, percent, hasStacking) {
  var row = document.createElement('tr');
  row.className = trClass;
  var style = 'chart';
  var groupByStyle = 'chart';
  var colSpan = 1;
  if (hasStacking) {
    xVal += ' Total';
    style = 'chart_subtotal';
    groupByStyle = 'chart_subtotal_text';
    colSpan = 2;
  }
  row.appendChild(createDisplayGridHeaderCell(groupByStyle, xVal, null, null, colSpan));
  row.appendChild(createDisplayGridCell(style, yVal, 'right'));
  if (percent && percent != '')
    row.appendChild(createDisplayGridCell(style, percent + '%', 'right'));
  else
    row.appendChild(createDisplayGridCell(style, 'N/A', 'right'));
  return row;
}

function createDisplayGridHeaderCell(cssClass, value, alignment, isHead, colSpan, rowSpan) {
  var gridCell = document.createElement('th');
  var role = 'rowheader';
  var scope = 'row';
  if (isHead) {
    role = 'columnheader';
    scope = 'col';
  }
  gridCell.setAttribute('role', role);
  gridCell.setAttribute('scope', scope);
  createDisplayGridCellCommon(gridCell, cssClass, value, alignment, colSpan, rowSpan);
  return gridCell;
}

function createDisplayGridCell(cssClass, value, alignment) {
  var gridCell = document.createElement('td');
  gridCell.setAttribute('role', 'gridcell');
  createDisplayGridCellCommon(gridCell, cssClass, value, alignment);
  return gridCell;
}

function createDisplayGridCellCommon(gridCell, cssClass, value, alignment, colSpan, rowSpan) {
  gridCell.className = cssClass;
  gridCell.style.textAlign = 'left';
  if (alignment)
    gridCell.style.textAlign = alignment;
  if (colSpan)
    gridCell.setAttribute('colspan', colSpan);
  if (rowSpan)
    gridCell.setAttribute('rowspan', rowSpan);
  gridCell.appendChild(document.createTextNode(value));
}

function isDisplayGridApplicable(chartType) {
  if (chartType === 'bar' || chartType === 'horizontal_bar' || isPieType(chartType) || chartType === 'line_bar' || chartType === 'line' || chartType === 'step_line' || chartType === 'area' || chartType === 'spline' || chartType === 'availability' || chartType === 'pareto' || chartType === 'trend' || chartType === 'map' || chartType === 'solid_gauge' ||
    chartType === 'angular_gauge')
    return true;
  return false;
}

function getGridTable(args) {
  return jQuery('#display-grid-table-' + args.report_uuid);
}

function getGridTableHeader($table) {
  return $table.find('.display_grid_header');
}

function getGridTableBody($table) {
  return $table.children('.display_grid_body');
}

function getGridExpandAnchor(args) {
  return jQuery('#expand\\.display_grid_table' + args.report_uuid);
}

function isTwoLevelDisplayGrid(args) {
  if ((args.stacked_field !== '' && isBarType(args.chart_type)))
    return true;
  if (args.group_by !== '' && (args.chart_type === 'trend' || args.chart_type === 'line' || args.chart_type === 'step_line' || args.chart_type === 'area' || args.chart_type === 'spline' || args.chart_type === 'line_bar'))
    return true;
  return false;
}

function toggleDisplayGrid(name, anchor) {
  var el = jQuery('#' + name);
  if (!el)
    return;
  var anchorEl = jQuery(anchor);
  if (anchorEl.attr('aria-expanded') === 'true') {
    el.hide();
    anchorEl.children().attr('src', 'images/section_hide.gifx');
    anchorEl.attr('aria-expanded', false);
  } else {
    el.show();
    anchorEl.children().attr('src', 'images/section_reveal.gifx');
    anchorEl.attr('aria-expanded', true);
  }
};
/*! RESOURCE: /scripts/reportcommon/additional_groupby.js */
function hasAdditionalGroupBy(type) {
  return !(type === 'hist' || type === 'pivot' || type === 'heatmap' || type === 'pivot_v2' || type === 'calendar' || type === 'control' || type === 'availability' || type === 'angular_gauge' || type === 'solid_gauge' || type === 'gauge' || type === 'single_score' || type === 'map');
}

function checkAndEnableInteractiveFilters(chartData, args) {
  var isMultiSeries = false;
  if ('report_properties' in chartData)
    isMultiSeries = chartData.series.length > 1;
  var $interactiveContainer = jQuery('#interactive-container-' + args.report_uuid);
  var msgIntoAdditionalGroupByPopup = document.getElementById('msg_additional_group_by');
  if (isMultiSeries) {
    if ($interactiveContainer.length)
      $interactiveContainer.hide();
    if (msgIntoAdditionalGroupByPopup)
      msgIntoAdditionalGroupByPopup.show();
  } else {
    if (msgIntoAdditionalGroupByPopup)
      msgIntoAdditionalGroupByPopup.hide();
    if ($interactiveContainer.length)
      constructInteractiveFilters(chartData.series[0].additional_groupby, args, $interactiveContainer);
  }
}

function constructInteractiveFilters(additionalGroupBy, args, $interactiveContainer) {
  var $stackBySelect;
  $interactiveContainer.append(
    '<div class="additional-groupby-label">' +
    '<label for="additional-groupby-' + args.report_uuid + '" id="additional-groupby-label" title="' + window.chartHelpers.i18n.groupByTitle + '">' +
    window.chartHelpers.i18n.groupBy +
    '</label>' +
    '</div>');
  var $groupByContainer = jQuery('<div class="additional-groupby-select"/>');
  $interactiveContainer.append($groupByContainer);
  var $groupBySelect = jQuery('<select id="additional-groupby-' + args.report_uuid + '" name="additional-groupby" class="interactive"/>');
  createAdditionalOptions($groupBySelect, additionalGroupBy.list, additionalGroupBy.original_group_by, additionalGroupBy.original_stack_by, args.group_by, hasNone(args.chart_type));
  if (isBarType(args.chart_type)) {
    var originalGroupBy = additionalGroupBy.original_group_by_can_be_stacked ? additionalGroupBy.original_group_by : null;
    $stackBySelect = jQuery('<select id="additional-stackby-' + args.report_uuid + '" name="additional-stackby" class="interactive"/>');
    createAdditionalOptions($stackBySelect, additionalGroupBy.stackby_list, additionalGroupBy.original_stack_by, originalGroupBy, args.stacked_field, true);
  }
  $groupBySelect.change(function groupBySelectChangeCallback() {
    applyExecutiveReport(args.report_id, $groupBySelect, $stackBySelect, JSON.parse(args.chart_params).interactive_filter);
  });
  $groupByContainer.append($groupBySelect);
  if ($stackBySelect) {
    $interactiveContainer.append(
      '<div class="additional-stackby-label">' +
      '<label for="additional-stackby-' + args.report_uuid + '" id="additional-stackby-label" title="' + window.chartHelpers.i18n.stackByTitle + '">' +
      window.chartHelpers.i18n.stackBy +
      '</label>' +
      '</div>');
    var $stackByContainer = jQuery('<div class="additional-groupby-select"/>');
    $interactiveContainer.append($stackByContainer);
    $stackBySelect.change(function stackBySelectChangeCallback() {
      applyExecutiveReport(args.report_id, $groupBySelect, $stackBySelect, JSON.parse(args.chart_params).interactive_filter);
    });
    $stackByContainer.append($stackBySelect);
  }
}

function createAdditionalOptions($select, choices, originalGrouping, otherGrouping, selectedValue, hasNoneOption) {
  var option;
  if (hasNoneOption) {
    option = new Option(window.chartHelpers.i18n.none, '');
    $select.append(jQuery(option));
  }
  if (originalGrouping) {
    option = new Option(originalGrouping.label, originalGrouping.value);
    $select.append(jQuery(option));
  }
  for (var i = 0; i < choices.length; ++i) {
    option = new Option(choices[i].label, choices[i].value);
    $select.append(jQuery(option));
  }
  if (otherGrouping && !$select.children('option[value=\'' + otherGrouping.value + '\']').length) {
    option = new Option(otherGrouping.label, otherGrouping.value);
    $select.append(jQuery(option));
  }
  if (selectedValue === 'variables')
    $select.val($select.children()[0].value);
  else
    $select.val(selectedValue);
}

function hasNone(type) {
  return type === 'list' || type === 'bubble' || type === 'trend' || type === 'line' || type === 'step_line' || type === 'line_bar' || type === 'area' || type === 'spline';
};
/*! RESOURCE: /scripts/reportcommon/buildhcoptions.js */
function hc_configureChartProportions(chartType, chartData, hcOptions, isGauge, isUI) {
  hc_configureLegendAlignment(chartType, chartData.report_properties, hcOptions, isGauge, isUI);
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.plotOptions.column = {};
    var closestPointRange = hc_differenceOfClosestStringDateTimesInSeries(chartData.series[0].xvalues);
    if (closestPointRange !== 0)
      hcOptions.plotOptions.column.pointRange = closestPointRange;
  }
}

function hc_configureLegendAlignment(chartType, reportProperties, hcOptions, isGauge, isUI) {
  var legendVerticalAlign = reportProperties.legend_vertical_alignment;
  var legendHorizontalAlign = reportProperties.legend_horizontal_alignment;
  var legendItemsLeftAlign = reportProperties.legend_items_left_align;
  var hasLegend = hcOptions.legend.enabled;
  var titleVerticalAlign = reportProperties.title_vertical_alignment;
  var showChartTitle = !reportProperties.custom_chart_title_position && (reportProperties.show_chart_title === 'always' || (!isGauge && reportProperties.show_chart_title === 'report'));
  var titleSize = Number(reportProperties.chart_title_size);
  var chartWidth = Number(hcOptions.chart.width);
  var chartHeight = Number(hcOptions.chart.height);
  if (hasLegend) {
    if (legendHorizontalAlign === "right") {
      if (legendVerticalAlign === "top") {
        hcOptions.legend.y = 25;
      } else if (legendVerticalAlign === "bottom") {
        hcOptions.legend.maxHeight = chartHeight - 70;
      } else if (legendVerticalAlign === "middle") {
        hcOptions.legend.maxHeight = chartHeight - 100;
      }
    } else if (legendHorizontalAlign === "center") {
      if (legendItemsLeftAlign || chartType === 'heatmap' || chartType === 'map')
        hcOptions.legend.width = chartWidth - 20;
      if (isUI)
        hcOptions.legend.maxHeight = chartHeight / 6;
      if (chartType === 'heatmap' || chartType === 'map') {
        hcOptions.legend.symbolWidth = hcOptions.legend.width - 10;
        hcOptions.legend.maxHeight = '';
      }
      if (legendVerticalAlign === "top") {
        hcOptions.legend.y = -2;
        if (showChartTitle && titleVerticalAlign === "top")
          hcOptions.legend.y = titleSize + 10;
      }
    }
    if (legendVerticalAlign === "bottom" && showChartTitle && titleVerticalAlign === "bottom") {
      hcOptions.legend.y = 0 - (titleSize + 10);
    }
  }
  if ((!hasLegend || (legendHorizontalAlign !== "center" || legendVerticalAlign !== "bottom")) &&
    showChartTitle && titleVerticalAlign === "bottom" && chartType !== "solid_gauge") {
    if (chartType === 'pie' || chartType === 'donut' || chartType === 'semi_donut' || chartType === "angular_gauge")
      hcOptions.chart.marginBottom = titleSize;
    else if (chartType === "funnel" || chartType === "pyramid")
      hcOptions.chart.marginBottom = titleSize + 40;
    else
      hcOptions.chart.marginBottom = titleSize + 75;
  }
}

function hc_setLegendLabelFormatter(hcOptions, isUI, isPercent) {
  var isCentered = (hcOptions.legend.align === 'center');
  if (isUI) {
    if (isCentered && isPercent) {
      hcOptions.legend.labelFormatter = hc_legendLabelPercentFormatter;
    } else if (!isCentered) {
      if (isPercent) {
        hcOptions.legend.labelFormatter = hc_legendLabelShortenedPercentFormatter;
      } else {
        hcOptions.legend.labelFormatter = hc_legendLabelShortenedFormatter;
      }
    }
  } else {
    if (isCentered) {
      if (isPercent) {
        hcOptions.legend.labelFormatter = 'hc_legendLabelPercentFormatter';
      }
    } else {
      if (isPercent) {
        hcOptions.legend.labelFormatter = 'hc_legendLabelShortenedPercentFormatter';
      } else {
        hcOptions.legend.labelFormatter = 'hc_legendLabelShortenedFormatter';
      }
    }
  }
}

function hc_generateChartOptions(chartType, chartData, aggType, stackedField, chartHeight, chartWidth, chartSize, isRtl) {
  var hcOptions = {};
  var chartProps = hc_initDefaultChartOptions(hcOptions, chartData, chartType, chartSize, false, false, '', aggType, stackedField, false, chartHeight, chartWidth, isRtl);
  hc_sanitizeXValues(chartData, chartProps);
  hc_setLegendLabelFormatter(hcOptions, false, false);
  if (chartType == 'bubble') {
    hcOptions.series = hc_createBubbleSeriesData(chartData, chartProps, true);
    hcOptions.xAxis = chartData.series[0].xAxis;
    hcOptions.yAxis = chartData.series[0].yAxis;
    hc_addBubbleChartOptions(hcOptions, true, chartData.series[0].legend.enabled);
  } else if (chartType == 'heatmap') {
    var curSeries = hc_createHeatmapSeriesData(chartData, chartProps, true);
    hcOptions.series.push(curSeries);
    hc_addHeatmapChartOptions(hcOptions, chartProps, true, chartData, curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, true);
    hc_addHeatmapAxisCategories(hcOptions, chartData);
  } else if (chartType == 'pie' || chartType == 'semi_donut' || chartType == 'donut') {
    hc_addPieChartOptions(hcOptions, chartProps, false, chartType == 'semi_donut');
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    if (chartType == 'semi_donut' || chartType == 'donut') {
      curSeries.innerSize = (100 - chartProps.report_properties.donut_width_percent) + "%";
      if (chartProps.report_properties.show_chart_total)
        hc_addTotal(hcOptions, chartProps, curSeries, chartData);
    }
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'funnel') {
    hc_addFunnelChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'pyramid') {
    hc_addPyramidChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == "angular_gauge" || chartType == "solid_gauge") {
    hc_addGaugeChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'bar' || chartType == 'horizontal_bar') {
    if (stackedField == '')
      hc_addBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    else
      hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    var series;
    series = hc_createMultipleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series = series;
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'hist') {
    hc_addHistogramOptions(hcOptions, chartProps, chartData, false);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
  } else if (chartType == 'pareto') {
    hc_addBarChartOptions(hcOptions, chartProps, chartData, 'column', false);
    var series0 = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(series0);
    var cumulative_series = hc_createParetoCumulSeries(hcOptions, chartProps, series0, false);
    hcOptions.series.push(cumulative_series);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'control') {
    hc_addControlChartOptions(hcOptions, chartProps, chartData, false);
    hcOptions.series = hc_createControlSeriesData(hcOptions, chartData, chartProps, false);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'box' || chartType == 'tbox') {
    hc_addBoxChartOptions(hcOptions, chartProps, chartData, false);
    var boxSeries = hc_createBoxPlotData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(boxSeries);
    var meanSeries = hc_createBoxMeanData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(meanSeries);
  } else if (chartType == 'trend') {
    var curSeries;
    if ('sub_series' in chartData.series[0]) {
      hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
      hcOptions.series = hc_createMultipleSeriesData(hcOptions, chartData, chartProps, false);
    } else {
      hc_addBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
      curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
      hcOptions.series.push(curSeries);
    }
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (isLineType(chartType) || chartType == 'availability') {
    if (chartType == 'availability')
      hc_addAvailChartOptions(hcOptions, chartProps, chartData, false);
    else
      hc_addLineChartOptions(hcOptions, chartProps, chartData, false, chartType);
    hcOptions.series = hc_createLineSeriesData(hcOptions, chartData, chartProps, false);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'map') {
    hc_addMapChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createMapSeriesData(hcOptions, chartData, chartProps, true);
    hcOptions.series = curSeries;
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, true);
    hc_updateDataLabelOptionsGeographical(hcOptions, chartData, chartType);
    hc_updateMapVisualizationOptions(hcOptions, chartData, chartProps);
  }
  hc_configureChartProportions(chartType, chartData, hcOptions, false, false);
  return hcOptions;
}

function hc_updateMapVisualizationOptions(hcOptions, chartData, chartProps) {
  var chartSerieProps;
  if (chartData.report_properties_series == undefined)
    chartSerieProps = chartProps;
  else
    chartSerieProps = chartData.report_properties_series[0];
  var mapVisualizationProperties = {}
  if ('report_drilldown' in chartSerieProps)
    mapVisualizationProperties.report_drilldown = chartSerieProps.report_drilldown;
  if ('report_id' in chartSerieProps)
    mapVisualizationProperties.report_id = chartSerieProps.report_id;
  if ('report_drilldown_zoom' in chartSerieProps)
    mapVisualizationProperties.report_drilldown_zoom = chartSerieProps.report_drilldown_zoom;
  if ('report_drilldown_map' in chartSerieProps)
    mapVisualizationProperties.report_drilldown_map = chartSerieProps.report_drilldown_map;
  if ('sysparm_full_query' in chartSerieProps)
    mapVisualizationProperties.full_query = chartSerieProps.sysparm_full_query;
  mapVisualizationProperties.show_data_label = chartSerieProps.show_chart_data_label;
  mapVisualizationProperties.show_geographical_label = chartSerieProps.show_geographical_label;
  hcOptions.mapVisualization = mapVisualizationProperties;
}

function isLineType(type) {
  return (type == 'line' || type == 'area' || type == 'spline' || type == 'line_bar' || type == 'step_line');
}

function hc_getHighChartsType(snType, lineType) {
  if (snType == 'bar' || snType == 'trend')
    return 'column';
  else if (snType == 'horizontal_bar')
    return 'bar';
  else if (snType == 'pie')
    return 'pie';
  else if (snType == 'semi_donut')
    return 'pie';
  else if (snType == 'donut')
    return 'pie';
  else if (snType == 'funnel')
    return 'funnel';
  else if (snType == 'pyramid')
    return 'funnel';
  else if (snType == 'box')
    return 'boxplot';
  else if (snType == 'spline')
    return 'spline';
  else if (snType == 'area')
    return 'area';
  else if (snType == 'line_bar')
    return 'column';
  else if (snType == 'line' || snType == 'step_line')
    return 'line';
  else if (snType == 'heatmap')
    return 'heatmap';
  else if (snType == 'angular_gauge')
    return 'gauge';
  else if (snType == 'solid_gauge')
    return 'solidgauge'
  else if (snType == 'bubble')
    return 'bubble'
  else if (snType == 'map')
    return 'map'
  else
    return '';
}

function hc_setupChartProperties(hcOptions, chartData, chartType, chartSize, isGauge, isPub, aggType, stackedField) {
  var chartProps = {};
  chartProps.defaultFontFamily = 'Arial';
  chartProps.fontSize = '10pt';
  chartProps.otherDisplay = 'Other';
  chartProps.otherDisplayMore = '(more...)';
  chartProps.report_properties = {};
  if ('report_properties' in chartData) {
    chartProps.report_properties = chartData.report_properties;
    if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
      chartProps.defaultFontFamily = chartProps.report_properties.font_family;
    if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
      chartProps.fontSize = chartProps.report_properties.font_size;
    chartProps.otherDisplay = chartProps.report_properties.other_display;
    chartProps.otherDisplayMore = chartProps.report_properties.other_display_more;
  }
  chartProps.isGauge = isGauge;
  chartProps.isPub = isPub;
  chartProps.origXValues = [];
  chartProps.xValues = [];
  chartProps.maxAllowedLabelLen = 20;
  chartProps.grayColor = '#666666';
  chartProps.blackColor = '#000';
  chartProps.aggType = aggType;
  chartProps.stackedField = stackedField;
  chartProps.otherKey = 'zzyynomatchaabb';
  chartProps.chartType = chartType;
  chartProps.chartSize = chartSize;
  chartProps.titleMargin = 50;
  return chartProps;
}

function hc_sanitizeXValues(chartData, chartProps) {
  if (!chartData.series || !chartData.series[0].xvalues)
    return;
  chartProps.origXValues = chartData.series[0].xvalues;
  if ('truncate_x_axis_labels' in chartProps.report_properties && chartProps.report_properties.truncate_x_axis_labels) {
    var removeLeading = false;
    if ('xaxis_labels_remove_leading' in chartProps.report_properties && chartProps.report_properties.xaxis_labels_remove_leading)
      removeLeading = true;
    for (var i = 0; i < chartProps.origXValues.length; i++) {
      if (chartProps.origXValues[i].length > chartProps.maxAllowedLabelLen) {
        if (removeLeading)
          chartProps.xValues.push('...' + chartProps.origXValues[i].substring(chartProps.origXValues[i].length - chartProps.maxAllowedLabelLen + 3));
        else
          chartProps.xValues.push(chartProps.origXValues[i].substring(0, chartProps.maxAllowedLabelLen - 3) + '...');
      } else
        chartProps.xValues.push(chartProps.origXValues[i]);
    }
  } else {
    for (var i = 0; i < chartProps.origXValues.length; i++)
      chartProps.xValues.push(chartProps.origXValues[i]);
  }
  var indx = hc_isPresentInArray(chartProps.origXValues, chartProps.otherKey);
  if (indx >= 0) {
    var indx2 = hc_isPresentInArray(chartProps.origXValues, chartProps.otherDisplay);
    if (indx2 >= 0)
      chartProps.xValues[indx] = chartProps.otherDisplay + ' ' + chartProps.otherDisplayMore;
    else
      chartProps.xValues[indx] = chartProps.otherDisplay;
  }
}

function hc_sanitizeCategoryValues(hcOptions, chartProps) {
  if (hcOptions.xAxis.categories)
    hcOptions.xAxis.categories = hc_sanitizeAxisCategoriesValues(hcOptions.xAxis.categories, chartProps);
  if (hcOptions.yAxis[0].categories)
    hcOptions.yAxis[0].categories = hc_sanitizeAxisCategoriesValues(hcOptions.yAxis[0].categories, chartProps);
}

function hc_sanitizeAxisCategoriesValues(categories, chartProps) {
  if (!categories)
    return;
  var newValues = [];
  var origValues = categories;
  if ('truncate_x_axis_labels' in chartProps.report_properties && chartProps.report_properties.truncate_x_axis_labels) {
    var removeLeading = false;
    if ('xaxis_labels_remove_leading' in chartProps.report_properties && chartProps.report_properties.xaxis_labels_remove_leading)
      removeLeading = true;
    for (var i = 0; i < origValues.length; i++) {
      if (origValues[i].length > chartProps.maxAllowedLabelLen) {
        if (removeLeading)
          newValues.push('...' + origValues[i].substring(origValues[i].length - chartProps.maxAllowedLabelLen + 3));
        else
          newValues.push(origValues[i].substring(0, chartProps.maxAllowedLabelLen - 3) + '...');
      } else
        newValues.push(origValues[i]);
    }
  } else {
    for (var i = 0; i < origValues.length; i++)
      newValues.push(origValues[i]);
  }
  var indx = hc_isPresentInArray(origValues, chartProps.otherKey);
  if (indx >= 0) {
    var indx2 = hc_isPresentInArray(origValues, chartProps.otherDisplay);
    if (indx2 >= 0)
      newValues[indx] = chartProps.otherDisplay + ' ' + chartProps.otherDisplayMore;
    else
      newValues[indx] = chartProps.otherDisplay;
  }
  return newValues;
}

function hc_initDefaultChartOptions(hcOptions, chartData, chartType, chartSize, isGauge, isPub, containerId, aggType, stackedField, isUI, chartHeight, chartWidth, isRtl) {
  hcOptions.chart = {};
  if (containerId != '') {
    hcOptions.chart.renderTo = containerId;
  }
  if (!isUI) {
    hcOptions.chart.height = chartHeight;
    hcOptions.chart.width = chartWidth;
  } else {
    var isCustomChartSize = chartData.report_properties && chartData.report_properties.custom_chart_size;
    hc_setHeightWidthChart(hcOptions, chartData, chartSize, isGauge, containerId, isCustomChartSize, chartHeight, chartWidth);
  }
  hcOptions.lang = hcOptions.lang || {};
  hcOptions.lang.noData = chartData.noDataToDisplayMsg;
  hc_setI18nTranslations(hcOptions, chartData.report_properties.translation);
  hcOptions.credits = {};
  hcOptions.credits.enabled = false;
  hcOptions.legend = {};
  var isMultiSeries = chartData.series.length > 1;
  if (!isMultiSeries && (chartType == 'bar' || chartType == 'horizontal_bar') && (stackedField === '') || chartType === 'angular_gauge' ||
    chartType === 'solid_gauge' || chartType === 'box' || chartType === 'tbox' || chartType === 'hist' || chartType === 'pareto')
    hcOptions.legend.enabled = false;
  else
    hcOptions.legend.enabled = chartData.report_properties.show_legend;
  hcOptions.legend.verticalAlign = chartData.report_properties.legend_vertical_alignment;
  hcOptions.legend.align = chartData.report_properties.legend_horizontal_alignment;
  if (hcOptions.legend.align === 'left' || hcOptions.legend.align === 'right') {
    hcOptions.legend.layout = 'vertical';
  }
  hcOptions.legend.itemStyle = {};
  hcOptions.legend.itemStyle.fontFamily = 'Arial';
  hcOptions.legend.backgroundColor = chartData.report_properties.legend_background_color_value;
  if (chartData.report_properties.show_legend_border === true) {
    hcOptions.legend.borderWidth = chartData.report_properties.legend_border_width;
    hcOptions.legend.borderRadius = chartData.report_properties.legend_border_radius;
    hcOptions.legend.borderColor = chartData.report_properties.legend_border_color_value;
  }
  hcOptions.tooltip = {};
  hcOptions.tooltip.style = {};
  hcOptions.tooltip.style.fontFamily = 'Arial';
  hcOptions.tooltip.style.fontSize = '10pt';
  if (isRtl) {
    hcOptions.tooltip.useHTML = true;
    hcOptions.legend.useHTML = true;
  }
  hcOptions.title = {};
  if (!chartData.report_properties.custom_chart_title_position) {
    if (chartData.report_properties.title_vertical_alignment !== 'top')
      hcOptions.title.verticalAlign = chartData.report_properties.title_vertical_alignment;
    if (hcOptions.title.verticalAlign === 'bottom')
      hcOptions.title.y = 0;
    hcOptions.title.align = chartData.report_properties.title_horizontal_alignment;
    if (hcOptions.title.align === 'right' && chartData.report_properties.title_vertical_alignment === 'top')
      hcOptions.title.x = -40;
  } else {
    hcOptions.title.x = chartData.report_properties.chart_title_x_position;
    hcOptions.title.y = chartData.report_properties.chart_title_y_position;
  }
  hcOptions.title.style = {};
  hcOptions.title.style.color = chartData.report_properties.chart_title_color_value;
  hcOptions.title.style.fontFamily = 'Arial';
  hcOptions.title.style.fontSize = chartData.report_properties.chart_title_size + 'px';
  if ('report_properties' in chartData) {
    if ('font_family' in chartData.report_properties && chartData.report_properties.font_family != '') {
      hcOptions.legend.itemStyle.fontFamily = chartData.report_properties.font_family;
      hcOptions.title.style.fontFamily = chartData.report_properties.font_family;
      hcOptions.tooltip.style.fontFamily = chartData.report_properties.font_family;
    }
    if ('font_size' in chartData.report_properties && chartData.report_properties.font_size != '') {
      hcOptions.tooltip.style.fontSize = chartData.report_properties.font_size;
    }
  }
  hcOptions.chart.backgroundColor = chartData.report_properties.chart_background_color_value;
  if (chartData.report_properties.show_chart_border === true) {
    hcOptions.chart.borderWidth = chartData.report_properties.chart_border_width;
    hcOptions.chart.borderRadius = chartData.report_properties.chart_border_radius;
    hcOptions.chart.borderColor = chartData.report_properties.chart_border_color_value;
  }
  hcOptions.chart.style = {};
  hcOptions.chart.style.margin = "0 auto";
  if (chartData.report_properties.show_chart_title === 'always' || (!isGauge && chartData.report_properties.show_chart_title === 'report')) {
    var title = chartData.title;
    if (chartData.report_properties.chart_title)
      title = chartData.report_properties.chart_title;
    if (isUI)
      title = title ? title.escapeHTML() : '';
    hcOptions.title.text = title;
  } else {
    hcOptions.title = {};
    hcOptions.title.text = '';
  }
  hcOptions.series = [];
  return hc_setupChartProperties(hcOptions, chartData, chartType, chartSize, isGauge, isPub, aggType, stackedField);
}

function hc_setHeightWidthChart(hcOptions, chartData, chartSize, isGauge, containerId, customChartSize, chartHeight, chartWidth) {
  var containerDimensions = {};
  var ie_dynamic_sizing;
  if (typeof chartData !== 'undefined' && chartData.report_properties)
    ie_dynamic_sizing = chartData.report_properties.ie_dynamic_sizing;
  if ((window.SNC && window.SNC.canvas) || !isGauge || !(window.isMSIE || window.isMSIE11) || ie_dynamic_sizing)
    containerDimensions = hc_getDimensions(containerId);
  if (containerDimensions.height && containerDimensions.height > 50)
    hcOptions.chart.height = containerDimensions.height;
  else if (chartHeight != undefined && chartHeight != '' && customChartSize)
    hcOptions.chart.height = chartHeight;
  else {
    hcOptions.chart.height = '375';
    if (chartSize == 'large')
      hcOptions.chart.height = '550';
    else if (chartSize == 'medium')
      hcOptions.chart.height = '450';
  }
  if (containerDimensions.width)
    hcOptions.chart.width = containerDimensions.width;
  else if (chartWidth != undefined && chartWidth != '' && customChartSize)
    hcOptions.chart.width = chartWidth;
  else {
    hcOptions.chart.width = '450';
    if (chartSize == 'large')
      hcOptions.chart.width = '750';
    else if (chartSize == 'medium')
      hcOptions.chart.width = '600';
  }
}

function hc_setI18nTranslations(hcOptions, i18n) {
  var lang = hcOptions.lang;
  lang.months = [i18n.month.january, i18n.month.february, i18n.month.march, i18n.month.april, i18n.month.may, i18n.month.june, i18n.month.july, i18n.month.august, i18n.month.september, i18n.month.october, i18n.month.november, i18n.month.december];
  lang.weekdays = [i18n.weekdays.sunday, i18n.weekdays.monday, i18n.weekdays.tuesday, i18n.weekdays.wednesday, i18n.weekdays.thursday, i18n.weekdays.friday, i18n.weekdays.saturday];
  lang.shortMonths = [i18n.month.shortName.january, i18n.month.shortName.february, i18n.month.shortName.march, i18n.month.shortName.april, i18n.month.shortName.may, i18n.month.shortName.june, i18n.month.shortName.july, i18n.month.shortName.august, i18n.month.shortName.september, i18n.month.shortName.october, i18n.month.shortName.november, i18n.month.shortName.december];
  lang.exportButtonTitle = i18n.exportButtonTitle;
  lang.printButtonTitle = i18n.printButtonTitle;
  lang.rangeSelectorFrom = i18n.rangeSelectorFrom;
  lang.rangeSelectorTo = i18n.rangeSelectorTo;
  lang.rangeSelectorZoom = i18n.rangeSelectorZoom;
  lang.downloadPNG = i18n.downloadPNG;
  lang.downloadJPEG = i18n.downloadJPEG;
  lang.downloadPDF = i18n.downloadPDF;
  lang.downloadSVG = i18n.downloadSVG;
  lang.printChart = i18n.printChart;
  lang.resetZoom = i18n.resetZoom;
  lang.resetZoomTitle = i18n.resetZoomTitle;
  lang.thousandsSep = i18n.thousandsSep;
  lang.decimalPoint = i18n.decimalPoint;
  lang.contextButtonTitle = i18n.contextButtonTitle;
  lang.days = i18n.days;
  lang.hours = i18n.hours;
  lang.minutes = i18n.minutes;
  lang.seconds = i18n.seconds;
}

function hc_getDimensions(containerId, isResize) {
  var containerHeight, containerWidth;
  var mustSubtractChildren = false;
  var isInCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  var $container = jQuery("#" + containerId);
  var $parent = isInCanvas && containerId.indexOf("preview") == -1 ? $container.closest('.grid-widget-content') : $container.parent().parent();
  if ($parent.is("rendered_body"))
    $parent = $parent.parent();
  if (!isResize && $container.height() > 25)
    containerHeight = $container.height();
  else {
    containerHeight = $parent.height();
    mustSubtractChildren = true;
  }
  if (!isResize && $container.width() !== 0)
    containerWidth = $container.width();
  else {
    containerWidth = $parent.width();
  }
  if (mustSubtractChildren) {
    if (window.g_accessibility === "true" || window.g_accessibility === true)
      containerHeight -= 22;
    var children = $container.siblings();
    for (var i = 0; i < children.length; i++) {
      if (children[i].className.indexOf('gauge-size-handle') > -1 || children[i].className.indexOf('timingDiv') > -1)
        containerHeight -= children[i].offsetHeight;
    }
  }
  return {
    height: containerHeight,
    width: containerWidth
  };
}

function hc_saveChart(inputType, outputType, inputData) {
  var ONE_MB = 1048576;
  if (inputData.length > ONE_MB) {
    var errDlg = new GlideDialogWindow('glide_alert_standard');
    errDlg.setTitle(new GwtMessage().getMessage('Error'));
    errDlg.setPreference('warning', true);
    errDlg.setPreference('title', new GwtMessage().getMessage('Chart data too large to be saved'));
    errDlg.setPreference('invokePromptCallBack', function() {
      this.destroy();
    });
    errDlg.render();
    return;
  }
  var dialog = new GwtPollDialog(inputType, inputData, 0, '', outputType);
  dialog.execute();
}

function hc_addHeatmapChartOptions(hcOptions, chartProps, isUI, chartData, curSeries) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.heatmap = {};
  hcOptions.plotOptions.heatmap.cursor = 'pointer';
  if (chartData.report_properties.use_color_heatmap === true) {
    hcOptions.colorAxis = {};
    hcOptions.colorAxis.min = chartData.series[0].min_value;
    hcOptions.colorAxis.max = chartData.series[0].max_value;
    hcOptions.colorAxis.minColor = chartData.report_properties.axis_min_color;
    hcOptions.colorAxis.maxColor = chartData.report_properties.axis_max_color;
  } else {
    hcOptions.legend.enabled = false;
  }
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHeatmapTooltip;
    hcOptions.plotOptions.heatmap.point = {};
    hcOptions.plotOptions.heatmap.point.events = {};
    hcOptions.plotOptions.heatmap.point.events.click = hc_dataPointClicked;
  }
}

function hc_addMapChartOptions(hcOptions, chartProps, isUI, chartData) {
  hcOptions.mapNavigation = {};
  hcOptions.mapNavigation.enabled = true;
  hcOptions.mapNavigation.enableMouseWheelZoom = false;
  hcOptions.plotOptions = {};
  var useLatLon = chartData.report_properties_series[0].map_source.use_lat_lon;
  if (!useLatLon && chartData.report_properties.use_color_heatmap === true) {
    hcOptions.colorAxis = {};
    hcOptions.colorAxis.min = parseInt(chartData.series[0].ymin);
    hcOptions.colorAxis.max = parseInt(chartData.series[0].ymax);
    hcOptions.colorAxis.minColor = chartData.report_properties.axis_min_color;
    hcOptions.colorAxis.maxColor = chartData.report_properties.axis_max_color;
  } else
    hcOptions.legend.enabled = false;
  if (isUI) {
    hcOptions.title.align = chartData.report_properties.title_horizontal_alignment;
    if (hcOptions.title.align === 'right' && chartData.report_properties.title_vertical_alignment === 'top')
      hcOptions.title.x = -80;
    var hasLegend = hcOptions.legend.enabled;
    var legendHorizontalAlign = chartData.report_properties.legend_horizontal_alignment;
    if (hasLegend) {
      if (legendHorizontalAlign === "left") {
        if (!hcOptions.mapNavigation.buttonOptions)
          hcOptions.mapNavigation.buttonOptions = {};
        hcOptions.mapNavigation.buttonOptions.x = 70;
        hcOptions.mapNavigation.buttonOptions.y = -30;
      }
    }
    hcOptions.tooltip.formatter = hc_formatMapTooltip;
    hcOptions.plotOptions.series = {};
    hcOptions.plotOptions.series.point = {};
    hcOptions.plotOptions.series.point.events = {};
    hcOptions.plotOptions.series.point.events.click = hc_dataPointClicked;
    hcOptions.plotOptions.series.point.dataLabels = {};
    hcOptions.plotOptions.series.point.dataLabels.allowOverlap = true;
    hcOptions.plotOptions.series.animation = false;
  }
}

function drillDownButton(event, exactPoint) {
  if (this.series.length > 0 && this.series[0].data.length > 0) {
    var point = this.series[0].data[0];
    var reportDrilldown = point.report_drilldown;
    var element = event.srcElement;
    if (!element)
      element = event.target;
    var content = jQuery(element).closest(".report_content");
    if (reportDrilldown) {
      var mapParams = '&sysparm_report_map_exact_points=' + exactPoint;
      var actualMap = point.report_drilldown_map;
      if (actualMap)
        mapParams += "&sysparm_report_map_parent=" + actualMap;
      drillReport(content.parent(), reportDrilldown, '', mapParams);
    }
  }
  return;
}

function hc_addBubbleChartOptions(hcOptions, isUI, isLegendEnabled) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.bubble = {};
  hcOptions.plotOptions.bubble.cursor = 'pointer';
  hcOptions.plotOptions.bubble.minSize = 8;
  hcOptions.plotOptions.bubble.maxSize = 70;
  if (isLegendEnabled == false)
    hcOptions.legend.enabled = false;
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHeatmapTooltip;
    hcOptions.plotOptions.bubble.point = {};
    hcOptions.plotOptions.bubble.point.events = {};
    hcOptions.plotOptions.bubble.point.events.click = hc_dataPointClicked;
  }
}

function hc_addPieChartOptions(hcOptions, chartProps, isUI, isSemiDonut, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.pie = {};
  if (isPublisher)
    hcOptions.plotOptions.pie.allowPointSelect = true,
    hcOptions.plotOptions.pie.cursor = 'pointer';
  hcOptions.plotOptions.pie.size = '90%';
  if (isSemiDonut) {
    hcOptions.plotOptions.pie.startAngle = '-90';
    hcOptions.plotOptions.pie.endAngle = '90';
    hcOptions.plotOptions.pie.center = ["50%", "75%"];
  }
  hcOptions.plotOptions.pie.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.pie.point = {};
    hcOptions.plotOptions.pie.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.pie.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.pie.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.pie.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.pie.point.events.click = hc_dataPointClicked;
  }
}

function hc_addFunnelChartOptions(hcOptions, chartProps, isUI, chartData, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.funnel = {};
  if (isPublisher)
    hcOptions.plotOptions.funnel.allowPointSelect = true
  hcOptions.plotOptions.funnel.cursor = 'pointer';
  hcOptions.plotOptions.funnel.size = '90%';
  hcOptions.plotOptions.funnel.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.funnel.point = {};
    hcOptions.plotOptions.funnel.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.funnel.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.funnel.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.funnel.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.funnel.point.events.click = hc_dataPointClicked;
  }
  hcOptions.plotOptions.series = {};
  if (chartProps.report_properties.funnel_neck_percent)
    hcOptions.plotOptions.series.neckHeight = chartProps.report_properties.funnel_neck_percent + "%";
}

function hc_addPyramidChartOptions(hcOptions, chartProps, isUI, chartData, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.funnel = {};
  if (isPublisher)
    hcOptions.plotOptions.funnel.allowPointSelect = true;
  hcOptions.plotOptions.funnel.cursor = 'pointer';
  hcOptions.plotOptions.funnel.size = '90%';
  hcOptions.plotOptions.funnel.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.funnel.point = {};
    hcOptions.plotOptions.funnel.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.funnel.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.funnel.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.funnel.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.funnel.point.events.click = hc_dataPointClicked;
  }
  hcOptions.plotOptions.series = {};
  hcOptions.plotOptions.series.neckHeight = "0%";
  hcOptions.plotOptions.series.neckWidth = "0%";
  hcOptions.plotOptions.funnel.reversed = true;
}

function hc_addGaugeChartOptions(hcOptions, chartProps, chartData, chartType, isUI) {
  hcOptions.chart.type = chartType;
  hcOptions.pane = {};
  var yAxis = {};
  hcOptions.plotOptions = {};
  var value = parseFloat(chartData.series[0].yvalues[0]);
  var min = 0;
  var max = 0;
  if (!chartProps.report_properties.gauge_autoscale && chartProps.report_properties.from)
    min = parseInt(chartProps.report_properties.from);
  else if (value < 0)
    min = value * 1.5;
  if (!chartProps.report_properties.gauge_autoscale && chartProps.report_properties.to)
    max = parseInt(chartProps.report_properties.to);
  else if (value == 0)
    max = 10;
  else if (value > 0)
    max = value * 1.5;
  var lower = null;
  var upper = null;
  if (chartProps.report_properties.lower_limit || chartProps.report_properties.lower_limit === 0 || chartProps.report_properties.lower_limit === '0')
    lower = parseInt(chartProps.report_properties.lower_limit);
  if (chartProps.report_properties.upper_limit || chartProps.report_properties.upper_limit === 0 || chartProps.report_properties.upper_limit === '0')
    upper = parseInt(chartProps.report_properties.upper_limit);
  if (lower !== null && upper !== null) {
    if (lower < min && lower <= 0)
      min = lower * 1.5;
    if (upper > max && upper >= 0)
      max = upper * 1.5;
    var total = max - min;
    var middleColor = '#ffca1f';
    var topColor;
    var bottomColor;
    if (chartProps.report_properties.direction == 'maximize') {
      topColor = '#4bd762';
      bottomColor = '#ff402c';
    } else {
      topColor = '#ff402c';
      bottomColor = '#4bd762';
    }
    if (chartType == 'solidgauge') {
      yAxis.stops = [];
      if (chartProps.report_properties.direction == 'maximize') {
        yAxis.stops.push([(lower - min) / total, bottomColor]);
        yAxis.stops.push([(upper - min) / total, middleColor]);
        yAxis.stops.push([1, topColor]);
      } else {
        yAxis.stops.push([0, bottomColor]);
        yAxis.stops.push([(lower - min) / total, middleColor]);
        yAxis.stops.push([(upper - min) / total, topColor]);
      }
    } else {
      yAxis.plotBands = [];
      yAxis.plotBands.push({
        from: min,
        to: lower,
        color: bottomColor
      });
      yAxis.plotBands.push({
        from: lower,
        to: upper,
        color: middleColor
      });
      yAxis.plotBands.push({
        from: upper,
        to: max,
        color: topColor
      });
    }
  } else {
    if (chartType == 'solidgauge') {
      yAxis.stops = [];
      color = chartData.series[0].colors[0];
      yAxis.stops.push([0, color]);
      yAxis.stops.push([1, color]);
    }
  }
  yAxis.min = min;
  yAxis.max = max;
  if (chartType == "solidgauge") {
    hcOptions.pane.size = "100%";
    hcOptions.pane.center = ['50%', '50%'];
    hcOptions.pane.startAngle = -90;
    hcOptions.pane.endAngle = 90;
    hcOptions.pane.background = {};
    hcOptions.pane.background.innerRadius = "60%";
    hcOptions.pane.background.outerRadius = "100%";
    hcOptions.pane.background.shape = "arc";
    hcOptions.pane.background.backgroundColor = "#EEE";
    hcOptions.tooltip = {};
    hcOptions.tooltip.enabled = false;
    yAxis.tickWidth = 0;
    yAxis.lineWidth = 0;
    yAxis.minorTickInterval = null;
    yAxis.tickPositions = [min, max];
    yAxis.labels = {};
    yAxis.labels.y = 14;
    if (!hcOptions.plotOptions.solidgauge)
      hcOptions.plotOptions.solidgauge = {};
    hcOptions.plotOptions.solidgauge.point = {};
    hcOptions.plotOptions.solidgauge.point.events = {};
    hcOptions.plotOptions.solidgauge.point.events.click = hc_dataPointClicked;
  } else {
    hcOptions.chart.plotBackgroundColor = '#ffffff';
    hcOptions.chart.plotBackgroundImage = null;
    hcOptions.chart.plotBorderWidth = 0;
    hcOptions.chart.plotShadow = false;
    hcOptions.pane.startAngle = -150;
    hcOptions.pane.endAngle = 150;
    if (!hcOptions.plotOptions.gauge)
      hcOptions.plotOptions.gauge = {};
    hcOptions.plotOptions.gauge.point = {};
    hcOptions.plotOptions.gauge.point.events = {};
    hcOptions.plotOptions.gauge.point.events.click = hc_dataPointClicked;
    hcOptions.pane.background = [];
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '109%'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '107%'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '105%',
      innerRadius: '103%'
    });
    yAxis.minorTickWidth = 1;
    yAxis.minorTickLength = 10;
    yAxis.minorTickPosition = 'inside';
    yAxis.tickPixelInterval = 30;
    yAxis.tickWidth = 2;
    yAxis.tickPosition = 'inside';
    yAxis.tickLength = 10;
    yAxis.labels = {};
    yAxis.labels.step = 2;
    yAxis.labels.rotation = 'auto';
    if (lower !== null && upper !== null) {
      yAxis.minorTickColor = '#ffffff';
      yAxis.tickColor = '#ffffff';
    } else {
      yAxis.minorTickColor = '#828890';
      yAxis.tickColor = '#828890';
    }
  }
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addBarChartOptions(hcOptions, chartProps, chartData, barType, isUI) {
  hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI);
  hcOptions.plotOptions.series.minPointLength = 2;
  if (chartData.series.length === 1)
    hc_addYAxisMax(chartProps, hcOptions, chartData, chartProps.chartType);
  if (isUI)
    hcOptions.tooltip.formatter = hc_formatToolTip;
}

function hc_updateDataLabelOptionsGeographical(hcOptions, chartData, chartType) {
  if ('map' === chartType) {
    if (hcOptions.series[0].dataLabels == null)
      hcOptions.series[0].dataLabels = {};
    hcOptions.series[0].dataLabels.enabled = true;
    hcOptions.series[0].dataLabels.color = '#000';
    hcOptions.series[0].dataLabels.show_geographical_label = chartData.report_properties_series[0].show_geographical_label;;
    hcOptions.series[0].dataLabels.show_data_label = chartData.report_properties_series[0].show_chart_data_label;
    hcOptions.series[0].dataLabels.formatter = hc_formatMapDataLabels;
  }
}

function hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, isUI) {
  var dataLabelColor = '#606060';
  if (chartData.report_properties_series != undefined && chartData.report_properties_series[0].show_chart_data_label === true) {
    if ('pie' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = true;
      hcOptions.plotOptions.pie.dataLabels.softConnector = false;
      hcOptions.plotOptions.pie.dataLabels.distance = 15;
      hcOptions.plotOptions.pie.dataLabels.style = {};
      hcOptions.plotOptions.pie.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.pie.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.pie.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.pie.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.pie.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('semi_donut' === chartType || 'donut' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = true;
      hcOptions.plotOptions.pie.dataLabels.softConnector = false;
      hcOptions.plotOptions.pie.dataLabels.distance = 15;
      hcOptions.plotOptions.pie.dataLabels.style = {};
      hcOptions.plotOptions.pie.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.pie.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.pie.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.pie.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.pie.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('funnel' === chartType || 'pyramid' === chartType) {
      hcOptions.plotOptions.funnel.dataLabels = {};
      hcOptions.plotOptions.funnel.dataLabels.enabled = true;
      hcOptions.plotOptions.funnel.dataLabels.softConnector = false;
      hcOptions.plotOptions.funnel.dataLabels.distance = 15;
      hcOptions.plotOptions.funnel.dataLabels.style = {};
      hcOptions.plotOptions.funnel.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.funnel.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.funnel.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.funnel.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.funnel.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.funnel.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.funnel.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.funnel.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.funnel.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('control' === chartType) {
      if (hcOptions.plotOptions == null)
        hcOptions.plotOptions = {};
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = true;
      hcOptions.plotOptions.series.dataLabels.softConnector = false;
      hcOptions.plotOptions.series.dataLabels.distance = 15;
      hcOptions.plotOptions.series.dataLabels.style = {};
      hcOptions.plotOptions.series.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.series.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.series.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.series.dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.plotOptions.series.dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('bar' === chartType || 'horizontal_bar' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = true;
      hcOptions.plotOptions.series.dataLabels.softConnector = false;
      hcOptions.plotOptions.series.dataLabels.distance = 15;
      hcOptions.plotOptions.series.dataLabels.style = {};
      hcOptions.plotOptions.series.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.series.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.series.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fontWeight = 'normal';
      hc_setDataLabelPositionProperties(hcOptions, chartData);
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.series.dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.plotOptions.series.dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('pareto' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[1].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = true;
      hcOptions.series[0].dataLabels.softConnector = false;
      hcOptions.series[0].dataLabels.distance = 15;
      hcOptions.series[0].dataLabels.style = {};
      hcOptions.series[0].dataLabels.style.fontFamily = 'Arial';
      hcOptions.series[0].dataLabels.style.fontSize = '10pt';
      hcOptions.series[0].dataLabels.style.color = dataLabelColor;
      hcOptions.series[0].dataLabels.style.fill = dataLabelColor;
      hcOptions.series[0].dataLabels.style.fontWeight = 'normal';
      hc_setDataLabelPositionProperties(hcOptions, chartData);
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.series[0].dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.series[0].dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.series[0].dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.series[0].dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('trend' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      for (i = 0; i < hcOptions.series.length; i++) {
        hcOptions.series[i].dataLabels = {};
        hcOptions.series[i].dataLabels.enabled = true;
        hcOptions.series[i].dataLabels.softConnector = false;
        hcOptions.series[i].dataLabels.distance = 15;
        hcOptions.series[i].dataLabels.inside = false;
        hcOptions.series[i].dataLabels.style = {};
        hcOptions.series[i].dataLabels.style.fontFamily = 'Arial';
        hcOptions.series[i].dataLabels.style.fontSize = '10pt';
        hcOptions.series[i].dataLabels.style.color = dataLabelColor;
        hcOptions.series[i].dataLabels.style.fill = dataLabelColor;
        hcOptions.series[i].dataLabels.style.fontWeight = 'normal';
        if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
          hcOptions.series[i].dataLabels.style.fontFamily = chartProps.report_properties.font_family;
        if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
          hcOptions.series[i].dataLabels.style.fontSize = chartProps.report_properties.font_size;
        if (isUI)
          hcOptions.series[i].dataLabels.formatter = hc_formatValueLabel;
        else
          hcOptions.series[i].dataLabels.formatter = 'hc_formatValueLabel';
      }
      hc_setDataLabelPositionProperties(hcOptions, chartData);
    } else if ('gauge' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
      hcOptions.series[0].dataLabels.borderWidth = 0;
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('angular_gauge' === chartType) {
      if (hcOptions.plotOptions.gauge == null)
        hcOptions.plotOptions.gauge = {};
      if (hcOptions.plotOptions.gauge.dataLabels == null)
        hcOptions.plotOptions.gauge.dataLabels = {};
      hcOptions.plotOptions.gauge.dataLabels.enabled = true;
      hcOptions.plotOptions.gauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.gauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.gauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if ('solid_gauge' === chartType) {
      if (hcOptions.plotOptions.solidgauge == null)
        hcOptions.plotOptions.solidgauge = {};
      if (hcOptions.plotOptions.solidgauge.dataLabels == null)
        hcOptions.plotOptions.solidgauge.dataLabels = {};
      hcOptions.plotOptions.solidgauge.dataLabels.enabled = true;
      hcOptions.plotOptions.solidgauge.dataLabels.y = -35;
      hcOptions.plotOptions.solidgauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.solidgauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.solidgauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if (isLineType(chartType)) {
      hcOptions.series.forEach(function(series) {
        series.dataLabels = series.dataLabels || {};
        series.dataLabels.enabled = series.dataLabels.enabled || false;
        series.dataLabels.softConnector = false;
        series.dataLabels.distance = 15;
        series.dataLabels.style = {};
        series.dataLabels.style.fontFamily = 'Arial';
        series.dataLabels.style.fontSize = '10pt';
        series.dataLabels.style.color = dataLabelColor;
        series.dataLabels.style.fill = dataLabelColor;
        series.dataLabels.style.fontWeight = 'normal';
        if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
          series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
        if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
          series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
        if (chartType == 'line_bar')
          hc_setDataLabelPositionProperties(hcOptions, chartData);
        if (isUI)
          series.dataLabels.formatter = hc_formatValueLabel;
        else
          series.dataLabels.formatter = 'hc_formatValueLabel';
      });
    } else if ('heatmap' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '{point.value_display}';
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('map' === chartType) {} else if ('bubble' == chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '{point.display_vlaue}';
      hcOptions.series[0].dataLabels.enabled = true;
      hcOptions.series[0].dataLabels.color = 'black';
      hcOptions.series[0].dataLabels.style = {};
      hcOptions.series[0].dataLabels.style.textShadow = 'none';
      hcOptions.series[0].dataLabels.style.HcTextStroke = null;
    }
  } else {
    if ('pie' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = false;
    } else if ('heatmap' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '{point.value}';
      hcOptions.series[0].dataLabels.enabled = false;
      hcOptions.series[0].dataLabels.color = 'black';
      hcOptions.series[0].dataLabels.style = {};
      hcOptions.series[0].dataLabels.style.textShadow = 'none';
      hcOptions.series[0].dataLabels.style.HcTextStroke = null;
    } else if ('semi_donut' === chartType || 'donut' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = false;
    } else if ('funnel' === chartType || 'pyramid' === chartType) {
      if (hcOptions.plotOptions.funnel == null)
        hcOptions.plotOptions.funnel = {};
      hcOptions.plotOptions.funnel.dataLabels = {};
      hcOptions.plotOptions.funnel.dataLabels.enabled = false;
    } else if ('control' === chartType) {
      if (hcOptions.plotOptions == null)
        hcOptions.plotOptions = {};
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('bar' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('pareto' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('column' === chartType) {
      if (hcOptions.plotOptions.column == null)
        hcOptions.plotOptions.column = {};
      hcOptions.plotOptions.column.dataLabels = {};
      hcOptions.plotOptions.column.dataLabels.enabled = false;
    } else if ('gauge' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
      hcOptions.series[0].dataLabels.borderWidth = 0;
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('angular_gauge' === chartType) {
      if (hcOptions.plotOptions.gauge == null)
        hcOptions.plotOptions.gauge = {};
      if (hcOptions.plotOptions.gauge.dataLabels == null)
        hcOptions.plotOptions.gauge.dataLabels = {};
      hcOptions.plotOptions.gauge.dataLabels.enabled = true;
      hcOptions.plotOptions.gauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.gauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.gauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if ('solid_gauge' === chartType) {
      if (hcOptions.plotOptions.solidgauge == null)
        hcOptions.plotOptions.solidgauge = {};
      if (hcOptions.plotOptions.solidgauge.dataLabels == null)
        hcOptions.plotOptions.solidgauge.dataLabels = {};
      hcOptions.plotOptions.solidgauge.dataLabels.enabled = true;
      hcOptions.plotOptions.solidgauge.dataLabels.y = -35;
      hcOptions.plotOptions.solidgauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.solidgauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.solidgauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if (isLineType(chartType)) {
      if (hcOptions.series[0] == null)
        hcOptions.series[0] = {};
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = false;
    } else if ('map' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = false;
    }
  }
  if (!isUI) {
    if (hcOptions.plotOptions == null)
      hcOptions.plotOptions = {};
    if (hcOptions.plotOptions.series == null)
      hcOptions.plotOptions.series = {};
  }
}

function hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, barType, isUI, serieProps) {
  hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI);
  if (chartData.series.length === 1 && chartProps.aggType === 'COUNT')
    hc_addYAxisMax(chartProps, hcOptions, chartData, chartProps.chartType);
  if (isUI) {
    hcOptions.tooltip.shared = false;
    hcOptions.tooltip.formatter = hc_formatStackedBarToolTip;
    if (hcOptions.chart.width)
      hcOptions.tooltip.style = {
        width: hcOptions.chart.width / 2
      };
    hcOptions.tooltip.followPointer = true;
    hcOptions.tooltip.positioner = function(labelWidth, labelHeight, point) {
      return tooltipPositioner(labelWidth, labelHeight, point, this.chart);
    }
  }
}

function tooltipPositioner(labelWidth, labelHeight, point, chart) {
  var tooltipX, tooltipY;
  if (point.plotX + labelWidth > chart.plotWidth) {
    tooltipX = point.plotX + chart.plotLeft - labelWidth - 20;
  } else {
    tooltipX = point.plotX + chart.plotLeft + 20;
  }
  tooltipY = point.plotY + chart.plotTop - 20;
  return {
    x: tooltipX,
    y: tooltipY
  };
}

function hc_addLineChartOptions(hcOptions, chartProps, chartData, isUI, chartType) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  hcOptions.plotOptions = {};
  for (i = 0; i < chartData.series.length; i++) {
    var seriesChartType = chartData.series[i].series_plot_type;
    if (seriesChartType === 'line' || seriesChartType === 'step_line') {
      hc_setZoomTypeForSlowMetric(chartData, hcOptions);
      hcOptions.chart.type = 'line';
    } else if (seriesChartType === 'area')
      hcOptions.chart.type = 'area';
    else if (seriesChartType === 'line_bar') {
      hcOptions.chart.type = 'column';
      hc_setZoomTypeForSlowMetric(chartData, hcOptions);
      hc_addSummaryDataToLegendForSlowMetric(chartData, hcOptions, isUI);
    } else if (seriesChartType === 'spline')
      hcOptions.chart.type = 'spline';
    if (isUI) {
      if (hcOptions.tooltip === undefined)
        hcOptions.tooltip = {};
      hcOptions.tooltip.shared = false;
      hcOptions.tooltip.formatter = hc_formatGeneralLineBarToolTip;
      hcOptions.plotOptions[hcOptions.chart.type] = {};
      hcOptions.plotOptions[hcOptions.chart.type].point = hcOptions.plotOptions[hcOptions.chart.type].point || {};
      hcOptions.plotOptions[hcOptions.chart.type].point.events = hcOptions.plotOptions[hcOptions.chart.type].events || {};
      hcOptions.plotOptions[hcOptions.chart.type].point.events.click = hc_dataPointClicked;
    }
  }
}

function hc_addAvailChartOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (hcOptions.tooltip == undefined)
    hcOptions.tooltip = {};
  if ('sub_series' in chartData.series[0]) {
    if (isUI)
      hcOptions.tooltip.formatter = hc_formatStackedBarToolTip;
  } else {
    hcOptions.legend.enabled = false;
    if (isUI)
      hcOptions.tooltip.formatter = hc_formatToolTip;
  }
  hcOptions.yAxis[0].min = 0;
  hcOptions.yAxis[0].max = 100;
  hcOptions.yAxis[0].tickInterval = 10;
}

function hc_addHistogramOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addBarChartOptions(hcOptions, chartProps, chartData, 'column', isUI);
  hcOptions.plotOptions.column.pointPadding = 0;
  hcOptions.plotOptions.column.groupPadding = 0;
  hcOptions.plotOptions.column.borderWidth = 0.5;
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHistToolTip;
    hcOptions.plotOptions.column.point = {};
    hcOptions.plotOptions.column.point.events = {};
    hcOptions.plotOptions.column.point.events.click = '';
  }
  hcOptions.legend.enabled = false;
}

function hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI) {
  hcOptions.chart.type = barType;
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.series = {};
  if (barType == 'column') {
    hc_addSlantLabelOptions(hcOptions, chartProps, true);
    hcOptions.plotOptions.column = {};
    hcOptions.plotOptions.column.groupPadding = 0;
    if ('bar_spacing' in chartProps.report_properties)
      hcOptions.plotOptions.column.pointPadding = chartProps.report_properties.bar_spacing;
    if (isUI) {
      hcOptions.plotOptions.column = hcOptions.plotOptions.column || {};
      hcOptions.plotOptions.column.point = hcOptions.plotOptions.column.point || {};
      hcOptions.plotOptions.column.point.events = hcOptions.plotOptions.column.point.events || {};
      hcOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
    }
  } else if (barType == 'bar') {
    hc_addSlantLabelOptions(hcOptions, chartProps, false);
    hcOptions.xAxis.labels.y = 0;
    hcOptions.plotOptions.bar = {};
    hcOptions.plotOptions.bar.groupPadding = 0;
    if ('bar_spacing' in chartProps.report_properties)
      hcOptions.plotOptions.bar.pointPadding = chartProps.report_properties.bar_spacing;
    if (isUI) {
      hcOptions.plotOptions.bar.point = hcOptions.plotOptions.bar.point || {};
      hcOptions.plotOptions.bar.point.events = hcOptions.plotOptions.bar.point.events || {};
      hcOptions.plotOptions.bar.point.events.click = hc_dataPointClicked;
    }
  }
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatToolTip;
    hcOptions.plotOptions.column = hcOptions.plotOptions.column || {};
    hcOptions.plotOptions.column.point = hcOptions.plotOptions.column.point || {};
    hcOptions.plotOptions.column.point.events = hcOptions.plotOptions.column.point.events || {};
    hcOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
  }
}

function hc_getXAxisLabelStyle(chartProps, isUI) {
  return hc_getAxisLabelStyle(chartProps.report_properties.x_axis_label_color_value, chartProps.report_properties.x_axis_label_size,
    chartProps.report_properties.x_axis_label_bold, chartProps.defaultFontFamily, isUI);
}

function hc_getYAxisLabelStyle(chartProps, isUI) {
  return hc_getAxisLabelStyle(chartProps.report_properties.y_axis_label_color_value, chartProps.report_properties.y_axis_label_size,
    chartProps.report_properties.y_axis_label_bold, chartProps.defaultFontFamily, isUI);
}

function hc_getAxisLabelStyle(axis_label_color_value, axis_label_size, axis_label_bold, fontFamily, isUI) {
  var style = {};
  style.fontFamily = fontFamily;
  style.color = axis_label_color_value;
  style.fontSize = axis_label_size + 'px';
  if (axis_label_bold)
    style.fontWeight = 'bold';
  if (isUI && window.isMSIE) {
    style.backgroundColor = '#fff';
  }
  return style;
}

function unescapeHtmlInput(input) {
  var el = document.createElement('div');
  el.innerHTML = input;
  return el.childNodes.length === 0 ? "" : el.childNodes[0].nodeValue;
}

function hc_axisTitleDisplayText(axisTitle, isUI) {
  if (isUI) {
    var axisLabel = document.createElement('tspan');
    axisLabel.textContent = unescapeHtmlInput(axisTitle);
    axisLabel.setAttribute('title', unescapeHtmlInput(axisTitle));
    return axisLabel.outerHTML;
  } else
    return '<tspan  title="' + axisTitle + '">' + axisTitle + '</tspan>';
}

function hc_buildAxisTitle(axisTitleText, axisTitleBold, axisTitleSize, axisTitleColor, fontFamily, width, isUI) {
  var title = {
    text: axisTitleText,
    useHTML: "true",
    style: {
      fontFamily: fontFamily,
      fontWeight: axisTitleBold ? "bold" : "normal",
      fontSize: axisTitleSize + "px",
      color: axisTitleColor,
      maxWidth: width ? (width - 80) + "px" : "300px",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      "-o-text-overflow": "ellipsis",
      "-ms-text-overflow": "ellipsis",
      "-moz-text-overflow": "ellipsis",
      "white-space": "nowrap",
      "word-wrap": "normal",
      "position": "relative"
    }
  }
  return title;
}

function hc_addHeatmapAxisCategories(hcOptions, chartData) {
  hcOptions.xAxis = {};
  hcOptions.xAxis.categories = fetchAxisCategory(chartData.series[0].xAxisCategories);
  hcOptions.xAxis.title = null;
  hcOptions.xAxis.labels = {};
  hcOptions.xAxis.labels.rotation = -45;
  var yAxis = {};
  yAxis.categories = fetchAxisCategory(chartData.series[0].yAxisCategories);
  yAxis.title = null;
  if (hcOptions.yAxis != undefined)
    yAxis.max = hcOptions.yAxis[0].categories.length - 1;
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addBubbleAxisCategories(hcOptions, chartData) {
  hcOptions.xAxis = {};
  hcOptions.xAxis.title = {};
  hcOptions.xAxis.title.text = chartData.series[0].xAxis;
  hcOptions.yAxis = {};
  hcOptions.yAxis.title = {};
  hcOptions.yAxis.title.text = chartData.series[0].yAxis;
}

function getCategoriesFromJSONArray(category) {
  return category.fieldValues[0].value;
}

function fetchAxisCategory(categories) {
  axisCategories = [];
  if (categories) {
    for (var i = 0; i < categories.length; i++) {
      axisCategories.push(categories[i].fieldValues[0].value)
    }
  }
  return axisCategories;
}

function hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI) {
  var label_style = hc_getXAxisLabelStyle(chartProps, isUI);
  hcOptions.xAxis = {};
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.xAxis.type = 'datetime';
  } else {
    hcOptions.xAxis.categories = [];
    hcOptions.xAxis.categories = chartProps.xValues;
  }
  hcOptions.xAxis.labels = {};
  hcOptions.xAxis.labels.style = label_style;
  hcOptions.xAxis.opposite = chartProps.report_properties.x_axis_opposite;
  hcOptions.xAxis.title = {};
  var xTitleText = chartProps.report_properties.x_axis_title;
  xTitleText = xTitleText === '' || xTitleText === undefined ? '' : xTitleText;
  hcOptions.xAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(xTitleText, isUI), chartProps.report_properties.x_axis_title_bold,
    chartProps.report_properties.x_axis_title_size, chartProps.report_properties.x_axis_title_color_value,
    chartProps.defaultFontFamily, hcOptions.chart.width, isUI);
  if (chartProps.report_properties.x_axis_display_grid) {
    hcOptions.xAxis.gridLineWidth = chartProps.report_properties.x_axis_grid_width;
    hcOptions.xAxis.gridLineColor = chartProps.report_properties.x_axis_grid_color_value;
    if (chartProps.report_properties.x_axis_grid_dotted)
      hcOptions.xAxis.gridLineDashStyle = 'dot';
  } else {
    hcOptions.xAxis.gridLineWidth = 0;
  }
  var yAxis = {};
  yAxis.labels = {};
  yAxis.labels.style = hc_getYAxisLabelStyle(chartProps, isUI);
  if (chartProps.report_properties.y_axis_display_grid) {
    yAxis.gridLineWidth = chartProps.report_properties.y_axis_grid_width;
    yAxis.gridLineColor = chartProps.report_properties.y_axis_grid_color_value;
    if (chartProps.report_properties.y_axis_grid_dotted)
      yAxis.gridLineDashStyle = 'dot';
  } else {
    yAxis.gridLineWidth = 0;
  }
  yAxis.title = {};
  yAxis.title.margin = 20;
  yAxis.opposite = chartProps.report_properties.y_axis_opposite;
  yAxis.title.useHTML = true;
  yAxis.title.style = {};
  var yTitleText = chartProps.report_properties.y_axis_title;
  yTitleText = yTitleText === '' || yTitleText === undefined ? chartData.series[0].yTitle : yTitleText;
  yAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(yTitleText, isUI), chartProps.report_properties.y_axis_title_bold,
    chartProps.report_properties.y_axis_title_size, chartProps.report_properties.y_axis_title_color_value,
    chartProps.defaultFontFamily, hcOptions.chart.height, isUI);
  if (isUI && window.isMSIE) {
    yAxis.title.style.backgroundColor = '#ffffff';
  }
  if (chartProps.aggType == 'COUNT')
    yAxis.allowDecimals = false;
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addSlantLabelOptions(hcOptions, chartProps, xaxis) {
  var minLabelsToSlant = 5;
  if ('slant_axis_labels' in chartProps.report_properties)
    minLabelsToSlant = chartProps.report_properties.slant_axis_labels;
  if (chartProps.xValues.length >= minLabelsToSlant) {
    hcOptions.xAxis.labels.rotation = -45;
    hcOptions.xAxis.labels.align = hcOptions.xAxis.opposite ? 'left' : 'right';
  }
  if (!xaxis) {
    hcOptions.yAxis[0].labels.rotation = -45;
    hcOptions.yAxis[0].labels.align = hcOptions.yAxis[0].opposite ? 'left' : 'right';
  }
}

function hc_addParetoChartOptions(hcOptions, chartProps, total, isUI) {
  var bar_yAxis = hcOptions.yAxis;
  bar_yAxis.lineWidth = 1;
  hcOptions.yAxis = bar_yAxis;
  var percent_axis = {};
  percent_axis.title = {};
  if (isUI)
    percent_axis.title.margin = 20;
  percent_axis.title.style = {};
  percent_axis.title.text = "Percent";
  percent_axis.title.style.color = chartProps.blackColor;
  percent_axis.title.style.fontFamily = chartProps.defaultFontFamily;
  percent_axis.title.style.fontSize = chartProps.fontSize;
  if (isUI && window.isMSIE) {
    percent_axis.title.style.backgroundColor = '#ffffff';
  }
  percent_axis.alignTicks = false;
  percent_axis.gridLineWidth = 0;
  percent_axis.lineColor = '#999';
  percent_axis.lineWidth = 1;
  percent_axis.tickColor = '#666';
  percent_axis.tickWidth = 1;
  percent_axis.tickLength = 3;
  percent_axis.tickInterval = parseFloat(total) / 10;
  percent_axis.endOnTick = false;
  percent_axis.opposite = true;
  percent_axis.linkedTo = 0;
  percent_axis.labels = {};
  if (isUI) {
    percent_axis.labels.formatter = function() {
      var pcnt = Highcharts.numberFormat((this.value / parseFloat(total) * 100), 0, '.');
      return pcnt + '%';
    }
  } else {
    percent_axis.labels.formatter = 'hc_formatParetoAxisLabels_' + total + '_';
  }
  percent_axis.labels.style = hc_getYAxisLabelStyle(chartProps, isUI);
  percent_axis.plotLines = [];
  var percent_plot = {};
  percent_plot.color = 'blue';
  percent_plot.width = 2;
  percent_plot.value = 0.80 * total;
  percent_axis.plotLines.push(percent_plot);
  hcOptions.yAxis.push(percent_axis);
  hcOptions.legend.enabled = false;
}

function hc_addControlChartOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (isUI) {
    hcOptions.plotOptions = {};
    hcOptions.plotOptions.line = {};
    hcOptions.plotOptions.line.point = {};
    hcOptions.plotOptions.line.point.events = {};
    hcOptions.plotOptions.line.point.events.click = hc_dataPointClicked;
    hcOptions.tooltip.formatter = hc_formatControlToolTip;
  }
}

function hc_addBoxChartOptions(hcOptions, chartProps, chartData, isUI) {
  hcOptions.chart.type = 'boxplot';
  hcOptions.legend.enabled = false;
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (isUI)
    hcOptions.tooltip.followPointer = true;
}

function hc_addYAxisMax(chartProps, hcOptions, chartData, chartType) {
  if (chartType == 'pareto')
    return;
  var seriesData = chartData.series[0];
  if (chartData.report_properties_series != undefined && chartData.report_properties_series[0].bar_unstack === true) {
    hcOptions.yAxis[0].startOnTick = true;
    hcOptions.yAxis[0].endOnTick = true;
  } else {
    if ((chartData.report_properties_series[0].y_axis_to === undefined ||
        chartData.report_properties_series[0].y_axis_to === '') &&
      seriesData.ymax !== undefined && seriesData.ymax !== '')
      hcOptions.yAxis[0].max = parseFloat(seriesData.ymax);
  }
}

function hc_addYAxisMaxSeries(seriesProps, hcOptions, seriesData, iSerie) {
  if (seriesData.series_plot_type == 'pareto')
    return;
  if (hcOptions.yAxis[iSerie] == undefined)
    return;
  if (seriesProps.bar_unstack != undefined && seriesProps.bar_unstack === true) {
    hcOptions.yAxis[iSerie].startOnTick = true;
    hcOptions.yAxis[iSerie].endOnTick = true;
  }
  if (seriesProps.y_axis_from !== undefined && seriesProps.y_axis_from !== '')
    hcOptions.yAxis[iSerie].min = seriesProps.y_axis_from;
  if (seriesProps.y_axis_to !== undefined && seriesProps.y_axis_to !== '')
    hcOptions.yAxis[iSerie].max = seriesProps.y_axis_to;
}

function hc_addYAxisIfNedded(hcOptions, chartProps, chartPropsSerie, seriesData, isUI, iSerie) {
  if (chartPropsSerie == null)
    return;
  if (chartPropsSerie.show_y_axis == true) {
    var yAxis = JSON.parse(JSON.stringify(hcOptions.yAxis[0]));
    yAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(chartPropsSerie.y_axis_title, isUI), chartProps.report_properties.y_axis_title_bold,
      chartProps.report_properties.y_axis_title_size, chartProps.report_properties.y_axis_title_color_value,
      chartProps.defaultFontFamily, hcOptions.chart.height, isUI);
    yAxis.min = null;
    yAxis.max = null;
    yAxis.opposite = true;
    yAxis.showEmpty = true;
    var color = seriesData.colors != undefined ? seriesData.colors[0] : '';
    if (yAxis.labels == undefined)
      yAxis.labels = {};
    yAxis.labels.formatter = null;
    if (yAxis.title.style == undefined)
      yAxis.title.style = {};
    if (chartPropsSerie.y_axis_from != undefined && chartPropsSerie.y_axis_from != '')
      yAxis.min = chartPropsSerie.y_axis_from;
    if (chartPropsSerie.y_axis_to != undefined && chartPropsSerie.y_axis_to != '')
      yAxis.max = chartPropsSerie.y_axis_to;
    hcOptions.yAxis.push(yAxis);
    return hcOptions.yAxis.length - 1;
  } else
    return 0;
}

function hc_createMultipleSeriesData(hcOptions, chartData, chartProps, isUI) {
  var series = [];
  if (isUI && isAccessibilityPatternsEnabled())
    hc_enableAccessibility(hcOptions, chartData, chartProps.chartType);
  var showYAxis;
  var yAxisProps = {};
  for (var i = 0; i < chartData.series.length; i++) {
    var yAxisIndex = 0;
    var seriesData = chartData.series[i];
    var seriesName = seriesData.series_name;
    var chartPropsSerie;
    if (!chartData.report_properties_series)
      chartPropsSerie = chartProps;
    else
      chartPropsSerie = chartData.report_properties_series[i];
    if (i > 0)
      yAxisIndex = hc_addYAxisIfNedded(hcOptions, chartProps, chartPropsSerie, seriesData, isUI, i);
    yAxisProps[i] = yAxisIndex;
    if ('sub_series' in seriesData) {
      var stackedSeries = hc_createStackedSeriesData(hcOptions, seriesData, chartProps, isUI, chartPropsSerie, i, yAxisIndex, chartData.series.length > 1);
      for (j = 0; j < stackedSeries.length; j++) {
        stackedSeries[j]['zIndex'] = 999 - i;
        hc_addYAxisMaxSeries(chartPropsSerie, hcOptions, seriesData, stackedSeries[j]['yAxis']);
      }
      series.push.apply(series, stackedSeries);
    } else {
      if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
        var iYAxis = i;
        if (hcOptions.yAxis[i] == undefined)
          iYAxis = 0;
        if (hcOptions.yAxis[iYAxis].labels != undefined) {
          if (isUI)
            hcOptions.yAxis[iYAxis].labels.formatter = hc_formatDurationLabel;
          else
            hcOptions.yAxis[iYAxis].labels.formatter = 'hc_formatDurationLabel';
        }
      }
      var serie = {};
      var yMin = 0;
      serie['name'] = seriesName;
      serie['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartPropsSerie.bar_unstack);
      serie['data'] = [];
      serie['zIndex'] = 999 - i;
      serie['stack'] = seriesName;
      serie['yAxis'] = 0;
      if (chartPropsSerie.show_y_axis === true)
        serie['yAxis'] = yAxisIndex;
      hc_addYAxisMaxSeries(chartPropsSerie, hcOptions, seriesData, serie['yAxis']);
      hc_seriesStyle(serie['type'], chartPropsSerie, serie, seriesData, isUI, i, false);
      var firstColor;
      for (var j = 0; j < seriesData.xvalues.length; j++) {
        if (j == 0)
          firstColor = seriesData.colors[0];
        var dataPoint = hc_createSingleSeriesDataPt(chartProps, j, seriesData, isUI, chartPropsSerie, firstColor, hcOptions);
        serie.data.push(dataPoint);
        if (dataPoint['y'] && dataPoint['y'] < yMin)
          yMin = dataPoint['y'];
      }
      serie['color'] = firstColor;
      if (isLineType(seriesData.series_plot_type) && (chartPropsSerie.y_axis_from === undefined ||
          chartPropsSerie.y_axis_from === '') &&
        (!hcOptions.yAxis[yAxisProps[i]].min || yMin < hcOptions.yAxis[yAxisProps[i]].min)) {
        hcOptions.yAxis[yAxisProps[i]].min = yMin;
      }
      if ("step_line" == seriesData.series_plot_type)
        serie['step'] = "center";
      series.push(serie);
    }
  }
  return series;
}

function hc_createHeatmapSeriesData(chartData, chartProps, isUI) {
  var chartPropsSerie = chartData.report_properties_series[0];
  var seriesData = chartData.series[0];
  var series = {};
  series['name'] = seriesData.series_name;
  series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
  series['data'] = [];
  for (var j = 0; j < seriesData.series.data.length; j++) {
    var dataPoint = hc_createHeatmapSeriesDataPt(chartProps, j, seriesData, chartPropsSerie, isUI);
    series.data.push(dataPoint);
  }
  series['borderWidth'] = 0.5;
  series['borderColor'] = chartData.report_properties.axis_max_color;
  return series;
}

function hc_createMapSeriesData(hcOptions, chartData, chartProps, isUI) {
  var series;
  var mapData = chartData.report_properties_series[0].map_source;
  var map = JSON.parse(mapData.map_json);
  var isGeographicalMap = mapData.is_geographical_map;
  if (isGeographicalMap) {
    var useLatLon = mapData.use_lat_lon;
    if (useLatLon)
      series = hc_createMapSeriesDataLatLon(chartData, chartProps, map, isUI);
    else
      series = hc_createMapSeriesDataHcKey(hcOptions, chartData, chartProps, map, isUI);
  } else {
    series = hc_createMapSeriesDataHcKeyNonGeographical(chartData, chartProps, map, isUI);
  }
  return series;
}

function hc_createMapSeriesDataLatLon(chartData, chartProps, map, isUI) {
  var series = [];
  var serie = {};
  serie['mapData'] = map;
  serie['name'] = 'Basemap';
  serie['borderColor'] = '#C2C2C2';
  serie['showInLegend'] = false;
  series.push(serie);
  serie = {};
  serie['name'] = 'Separators';
  serie['type'] = 'mapline';
  serie['data'] = Highcharts.geojson(map, 'mapline');
  serie['color'] = '#C2C2C2';
  serie['showInLegend'] = false;
  serie['enableMouseTracking'] = false;
  series.push(serie);
  var dataArray = [];
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name;
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  serie = {};
  serie['name'] = seriesName;
  serie['type'] = 'mappoint';
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    dataArray.push(data);
  }
  serie['data'] = dataArray;
  series.push(serie);
  return series;
}

function hc_createMapSeriesDataHcKey(hcOptions, chartData, chartProps, map, isUI) {
  var dataArray = [];
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name;
  var series = [];
  var serie = {};
  serie['mapData'] = map;
  serie['name'] = seriesName;
  serie['showInLegend'] = false;
  var joinBy = chartData.report_properties_series[0].map_source.join_by_column;
  serie['joinBy'] = [joinBy, 'name'];
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationHcKeyPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    if (data['name'] !== '')
      dataArray.push(data);
  }
  serie['data'] = dataArray;
  if (serie['data'].length == 0)
    hcOptions.legend.enabled = false;
  series.push(serie);
  return series;
}

function hc_createMapSeriesDataHcKeyNonGeographical(chartData, chartProps, map, isUI) {
  var series = [];
  var serie = {};
  serie['type'] = 'map';
  serie['showInLegend'] = false;
  var joinBy = chartData.report_properties_series[0].map_source.join_by_column;
  serie['joinBy'] = [joinBy, 'name'];
  serie['mapData'] = map;
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  var dataArray = [];
  var seriesData = chartData.series[0];
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationHcKeyPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    dataArray.push(data);
  }
  serie['data'] = dataArray;
  series.push(serie);
  return series;
}

function hc_createBubbleSeriesData(chartData, chartProps, isUI) {
  var chartPropsSerie = chartData.report_properties_series[0];
  var seriesData = chartData.series[0];
  var bubbleSeriesData = [];
  for (var i = 0; i < seriesData.series.length; i++) {
    var series = {};
    series['name'] = seriesData.series[i].name;
    series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
    series['data'] = [];
    for (var j = 0; j < seriesData.series[i].data.length; j++) {
      var dataPoint = hc_createBubbleSeriesDataPt(chartProps, j, seriesData.series[i].data, chartPropsSerie, isUI, seriesData.table_name);
      series.data.push(dataPoint);
    }
    bubbleSeriesData.push(series);
  }
  return bubbleSeriesData;
}

function addCustomPatterns(hcOptions) {
  var patterns = [{
    'id': 'custom-pattern-0',
    'path': {
      d: 'M 5 5 L 10 10 M 0 10 L 10 0',
      stroke: Highcharts.getOptions().colors[0],
      strokeWidth: 2
    }
  }, {
    'id': 'custom-pattern-1',
    'path': {
      d: 'M 0 0 L 5 5',
      stroke: Highcharts.getOptions().colors[2],
      strokeWidth: 3
    }
  }, {
    'id': 'custom-pattern-2',
    'path': {
      d: 'M 5 5 L 10 0',
      stroke: Highcharts.getOptions().colors[3],
      strokeWidth: 3
    }
  }, {
    'id': 'custom-pattern-3',
    'path': {
      d: 'M 0 8 L 8 0',
      stroke: Highcharts.getOptions().colors[4],
      strokeWidth: 8
    }
  }, {
    'id': 'custom-pattern-4',
    'path': {
      d: 'M 0 0 L 10 10 M 0 10 L 10 0',
      stroke: Highcharts.getOptions().colors[5],
      strokeWidth: 2
    }
  }, {
    'id': 'custom-pattern-5',
    'path': {
      d: 'M 1 0 L 0 5 M 0 5 L 8 5',
      stroke: Highcharts.getOptions().colors[7],
      strokeWidth: 2
    }
  }, {
    'id': 'custom-pattern-6',
    'path': {
      d: 'M 0 0 L 10 10 M 0 10 L 10 0 M 0 5 L 10 5 M 5 0 L 5 10',
      stroke: Highcharts.getOptions().colors[6],
      strokeWidth: 2
    }
  }, {
    'id': 'custom-pattern-7',
    'path': {
      d: 'M 4 4 L 4 5 M 4 5 L 5 5 M 5 5 L 5 4 M 5 4 L 4 4',
      stroke: Highcharts.getOptions().colors[8],
      strokeWidth: 5
    }
  }, {
    'id': 'custom-pattern-8',
    'path': {
      d: 'M 10 5 L 7 2 M 1 3 L 2 4',
      stroke: Highcharts.getOptions().colors[9],
      strokeWidth: 20
    }
  }, {
    'id': 'custom-pattern-9',
    'path': {
      d: 'M 2 8 L 6 2 M 6 2 L 8 8 M 8 8 L 2 8',
      stroke: Highcharts.getOptions().colors[1],
      strokeWidth: 2
    }
  }];
  hcOptions.defs = hcOptions.defs || {};
  hcOptions.defs.patterns = patterns;
  return hcOptions;
}

function getDashStyles() {
  return [
    'Solid',
    'ShortDash',
    'ShortDot',
    'ShortDashDot',
    'ShortDashDotDot',
    'Dot',
    'Dash',
    'LongDash',
    'DashDot',
    'LongDashDot',
    'LongDashDotDot'
  ];
}

function hc_enableAccessibility(hcOptions, chartData, chartType) {
  addCustomPatterns(hcOptions);
  chartData.series.forEach(function a11ySeries(serie, i) {
    chartData.series[i].colors.forEach(function a11yColor(color, j) {
      if (isLineType(chartType) && chartType !== 'line_bar' && chartType !== 'area')
        chartData.series[i].colors[j] = '#000';
      else
        chartData.series[i].colors[j] = j > 9 ? 'url(#custom-pattern-' + (j % 10) + ')' : 'url(#highcharts-default-pattern-' + (j % 10) + ')';
    });
  });
}

function hc_createSingleSeriesData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  if (isUI && isAccessibilityPatternsEnabled())
    hc_enableAccessibility(hcOptions, chartData, chartProps.chartType);
  var chartPropSerie = chartData.report_properties_series[0];
  var seriesName = seriesData.series_name;
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var series = {};
  var yMin = 0;
  series['name'] = seriesName;
  series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
  series['data'] = [];
  if (chartProps.chartType == 'angular_gauge' || chartProps.chartType == 'solid_gauge') {
    var point = {};
    point.y = parseFloat(seriesData.yvalues);
    point.y_tooltip = seriesData.ydisplayvalues;
    point.displayvalue = seriesData.ydisplayvalues;
    point.table = seriesData.table_name;
    point.click_url_info = chartPropSerie.filter;
    if ('list_ui_view_name' in chartPropSerie)
      point['list_ui_view_name'] = chartPropSerie.list_ui_view_name;
    if ('report_drilldown' in chartPropSerie)
      point['report_drilldown'] = chartPropSerie.report_drilldown;
    if ('drill_open_new_win' in chartProps.report_properties)
      point['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    series.data.push(point);
    return series;
  }
  if (isLineType(seriesData.series_plot_type))
    series['color'] = seriesData.colors[0];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = hc_createSingleSeriesDataPt(chartProps, j, seriesData, isUI, chartPropSerie, undefined, hcOptions);
    series.data.push(dataPoint);
    if (dataPoint['y'] && dataPoint['y'] < yMin)
      yMin = dataPoint['y'];
  }
  if (isLineType(chartProps.chartType) && (chartProps.report_properties.y_axis_from === undefined ||
      chartProps.report_properties.y_axis_from === ''))
    hcOptions.yAxis[0].min = yMin;
  if (chartProps.chartType == 'donut' || chartProps.chartType == 'semi_donut') {
    series['total'] = seriesData.display_human_readable_total;
    series['total_value'] = seriesData.display_grid_total;
  }
  return series;
}

function hc_hasAxes(chartType) {
  return !(chartType === 'angular_gauge' || chartType === 'solid_gauge' || chartType === 'pie' ||
    chartType === 'solid_gauge' || chartType === 'funnel' || chartType === 'donut' ||
    chartType === 'semi_donut' || chartType === 'pyramid');
}

function hc_createStackedSeriesData(hcOptions, seriesData, chartProps, isUI, chartPropsSerie, serieIndex, yAxisIndex, isMultiseries) {
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType) && (yAxisIndex == 0 || (yAxisIndex > 0 && chartPropsSerie.show_y_axis == true))) {
    if (hcOptions.yAxis[yAxisIndex] == undefined) {
      hcOptions.yAxis[yAxisIndex] = {};
      hcOptions.yAxis[yAxisIndex].labels = {};
    }
    if (isUI)
      hcOptions.yAxis[yAxisIndex].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[yAxisIndex].labels.formatter = 'hc_formatDurationLabel';
  }
  var x2Vals = seriesData.x2values;
  var x2Colors = seriesData.colors;
  var subSeriesList = seriesData.sub_series;
  var subSeriesDataArray = [];
  for (var j = 0; j < seriesData.xvalues.length; j++)
    subSeriesDataArray.push(subSeriesList[j]);
  var series = [];
  var yMin = 0;
  var isSlowMetricTable = hc_isSlowMetricChart(hcOptions, seriesData);
  hcOptions.yAxis[yAxisIndex].reversedStacks = chartPropsSerie.bar_unstack || false;
  for (var i = 0; i < x2Vals.length; i++) {
    var subseries = {};
    subseries.name = x2Vals[i].displayValue;
    if (chartProps.report_properties != undefined && isMultiseries)
      subseries.name = '[' + seriesData.series_name + '] ' + subseries.name;
    subseries.data = [];
    subseries['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartPropsSerie.bar_unstack);
    subseries['legend_label_max_length'] = chartPropsSerie.legend_label_max_size;
    subseries['id'] = seriesData.series_name;
    subseries['stack'] = seriesData.series_name;
    subseries['yAxis'] = yAxisIndex;
    if (isUI && isAccessibilityPatternsEnabled())
      subseries['dashStyle'] = getDashStyles()[i % x2Vals.length];
    if (chartPropsSerie.show_y_axis === true)
      subseries['yAxis'] = yAxisIndex;
    hc_seriesStyle(subseries['type'], chartPropsSerie, subseries, seriesData, isUI, serieIndex, true);
    hc_addPropsForDataLabelsTruncation(subseries, chartPropsSerie);
    var dataExistsForX2Val = false;
    var categoryIndx;
    var max = Number.MIN_VALUE;
    var min = Number.MAX_VALUE;
    var total = 0;
    var count = 0;
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      var subSeriesData = subSeriesDataArray[j];
      categoryIndx = j;
      var dataPoint = hc_initStackedSeriesDataPoint(i, j, x2Vals, x2Colors, chartProps, seriesData.table_name, seriesData.table_display_plural, isUI, chartPropsSerie, seriesData, categoryIndx);
      var dataFilled = false;
      if (subSeriesData && subSeriesData.xvalues) {
        for (var k = 0; k < subSeriesData.xvalues.length; k++) {
          if (x2Vals[i].value == subSeriesData.xvalues[k].value ||
            x2Vals[i].value == subSeriesData.xvalues[k]
          ) {
            dataExistsForX2Val = true;
            dataFilled = true;
            hc_fillStackedSeriesDataPoint(dataPoint, k, subSeriesData, chartProps, isUI, chartPropsSerie, categoryIndx, isSlowMetricTable, chartProps.xValues[j]);
            break;
          }
        }
      }
      if (!isSlowMetricTable || dataFilled) {
        subseries.data.push(dataPoint);
        if (isSlowMetricTable && dataPoint['y']) {
          max = Math.max(max, dataPoint['y']);
          min = Math.min(min, dataPoint['y']);
          total += dataPoint['y'];
          count++;
        }
      }
      if (dataPoint['y'] && dataPoint['y'] < yMin)
        yMin = dataPoint['y'];
    }
    if (isSlowMetricTable) {
      subseries.max = max;
      subseries.min = min;
      subseries.total = total;
      subseries.average = total / count;
    }
    if (seriesData.series_plot_type === 'step_line')
      subseries.step = 'center';
    if (dataExistsForX2Val) {
      subseries.color = x2Colors[i];
      series.push(subseries);
    }
  }
  if (isLineType(seriesData.series_plot_type) && (chartPropsSerie.y_axis_from === undefined || chartPropsSerie.y_axis_from === ''))
    hcOptions.yAxis[yAxisIndex].min = yMin;
  if (isSlowMetricTable) {
    series.sort(function(x, y) {
      return x.total - y.total;
    });
  }
  return series;
}

function hc_seriesStyle(type, chartPropsSerie, serie, seriesData, isUI, i, stacked) {
  if ('column' === type || 'bar' === type) {
    if (chartPropsSerie.bar_unstack === true)
      serie.stacking = '';
    else
      serie.stacking = 'normal';
  }
  if ('line' === type || 'area' === type || 'spline' === type) {
    var showMarker = chartPropsSerie.show_marker;
    serie.marker = {};
    serie.marker.enabled = showMarker
  }
  serie.color = seriesData.colors[i];
  if ('column' === type || 'bar' === type || isLineType(type) || 'trend' === type) {
    var dataLabelColor = '#606060';
    if (chartPropsSerie.show_chart_data_label === true) {
      serie.dataLabels = {};
      serie.dataLabels.enabled = true;
      serie.dataLabels.softConnector = false;
      serie.dataLabels.distance = 15;
      serie.dataLabels.style = {};
      serie.dataLabels.style.fontFamily = 'Arial';
      serie.dataLabels.style.fontSize = '10pt';
      serie.dataLabels.style.color = dataLabelColor;
      serie.dataLabels.style.fill = dataLabelColor;
      serie.dataLabels.style.fontWeight = 'normal';
      serie.dataLabels.inside = false;
      if (serie.sub_series != undefined)
        serie.dataLabels.inside = true;
      if ('font_family' in chartPropsSerie && chartPropsSerie.font_family != '')
        serie.dataLabels.style.fontFamily = chartPropsSerie.font_family;
      if ('font_size' in chartPropsSerie && chartPropsSerie.font_size != '')
        serie.dataLabels.style.fontSize = chartPropsSerie.font_size;
      if (isUI)
        serie.dataLabels.formatter = hc_formatValueLabel;
      else
        serie.dataLabels.formatter = 'hc_formatValueLabel';
    } else {
      serie.dataLabels = {};
      serie.dataLabels.enabled = false;
    }
  }
  if (isUI) {
    if (isLineType(type) || 'column' === type || 'bar' === type || 'horizontal_bar' === type) {
      serie.tooltip = {};
      if (stacked)
        serie.tooltip.tooltipText = 'stacked';
      else
        serie.tooltip.tooltipText = 'non-stacked';
    }
  }
}

function hc_createParetoCumulSeries(hcOptions, chartProps, series0, isUI) {
  var total = 0;
  var cumulative_totals = [];
  var cumulative_percent = [];
  for (var i = 0; i < series0.data.length; i++) {
    total = parseFloat(total) + parseFloat(series0.data[i].y);
    cumulative_totals.push(total);
  }
  var cuml_percent = 0;
  for (var i = 0; i < series0.data.length; i++) {
    var percent = parseFloat(series0.data[i].y) / parseFloat(total) * 100;
    cuml_percent = parseFloat(cuml_percent) + parseFloat(percent);
    var s = cuml_percent.toString();
    var k = s.indexOf('.');
    if (k >= 0) {
      var sub = s.substring(0, k);
      var rem = s.substring(k + 1);
      if (rem.length > 2) {
        sub += '.';
        for (var j = 0; j < 2; j++)
          sub += rem[j];
      } else
        sub += '.' + rem;
      cumulative_percent.push(sub);
    } else
      cumulative_percent.push(s);
  }
  var cumulative_series = {};
  cumulative_series.type = 'line';
  cumulative_series.name = 'pareto_series';
  cumulative_series.data = [];
  for (var i = 0; i < cumulative_totals.length; i++) {
    var dataPoint = {};
    dataPoint['y'] = cumulative_totals[i];
    dataPoint['percent'] = cumulative_percent[i];
    cumulative_series.data.push(dataPoint);
  }
  hc_addParetoChartOptions(hcOptions, chartProps, total, isUI);
  return cumulative_series;
}

function hc_createSingleSeriesDataPt(chartProps, indx, seriesData, isUI, chartSerieProps, color, hcOptions) {
  var yVal;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = seriesData.xvalues[indx];
  if (chartProps.origXValues[indx] == chartProps.otherKey)
    dataPoint['name'] = chartProps.xValues[indx];
  if (seriesData.yvalues[indx] !== undefined && seriesData.yvalues[indx])
    yVal = parseFloat(seriesData.yvalues[indx]);
  else
    yVal = null;
  var dataPointName = dataPoint['name'];
  if (dataPointName.length > chartProps.maxAllowedLabelLen) {
    dataPointName = dataPointName.substring(0, chartProps.maxAllowedLabelLen - 3) + '...';
  }
  if (hc_isSlowMetricChart(hcOptions, seriesData))
    dataPoint['x'] = hc_convertDateTimeFormatToUnixTime(seriesData.xvalues[indx]);
  else
    dataPoint['x'] = indx;
  dataPoint['y'] = yVal;
  if (!isLineType(seriesData.series_plot_type))
    dataPoint['color'] = seriesData.colors[indx];
  else
    dataPoint['color'] = color;
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  dataPoint['valid'] = (seriesData.valids != undefined ? (seriesData.valids[indx] === "true") : true);
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if (chartProps.chartType == 'hist') {
      dataPoint['tt_label_min'] = chartProps.report_properties.hist_min;
      dataPoint['tt_label_max'] = chartProps.report_properties.hist_max;
      dataPoint['tt_label_cnt'] = chartProps.report_properties.hist_count;
    }
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    generateSeriesUrlInfo(dataPoint, indx, dataPoint['isOther'], seriesData, chartSerieProps, undefined, chartProps, seriesData['table_name']);
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  } else if (chartProps.chartType == 'pie' || chartProps.chartType == 'semi_donut' || chartProps.chartType == 'donut' ||
    chartProps.chartType == 'funnel' || chartProps.chartType == 'pyramid') {
    if ('percentages' in seriesData)
      dataPoint['percent'] = seriesData.percentages[indx];
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function isVariablesGroupby(groupby) {
  return groupby && groupby.startsWith('variables.');
}

function removeNonConditionTerms(filter) {
  var ignoreExpressions = [/^\s*$/, /^ORDERBY/, /^ORDERBYDESC/, /^GROUPBY/, /^TRENDBY/];
  if (!filter)
    return "";
  var terms = filter.split('^');
  var validTerms = [];
  for (var i = 0; i < terms.length; i++) {
    if (isToBeIgnored(terms[i], ignoreExpressions))
      continue;
    validTerms.push(terms[i]);
  }
  var validFilter = validTerms.join('^');
  if (validFilter && validFilter.endsWith('^EQ'))
    validFilter = validFilter.substring(0, validFilter.length - 3);
  return validFilter;
}

function isToBeIgnored(value, ignoreExpressions) {
  for (i = 0; i < ignoreExpressions.length; i++) {
    if (ignoreExpressions[i].test(value))
      return true;
  }
  return false;
}

function combineQueries(filter, aggregateQuery) {
  if (!filter)
    return aggregateQuery;
  if (!aggregateQuery)
    return filter;
  var filterQueries = filter.split('^NQ');
  for (var i = 0; i < filterQueries.length; i++)
    filterQueries[i] += "^" + aggregateQuery;
  return filterQueries.join("^NQ");
}

function generateSeriesUrlInfo(dataPoint, indx, isOther, seriesData, chartSerieProps, aggregateQueryPerSeries, chartProps, tableName) {
  if (isOther) {
    dataPoint['click_url_info'] = generateOtherUrlInfo(indx, chartProps, tableName, chartSerieProps);
    return;
  }
  var categoryItemCondition = '';
  if (isVariablesGroupby(chartSerieProps.groupby) && chartSerieProps.sc_groupby_item_id)
    categoryItemCondition = "^cat_item=" + chartSerieProps.sc_groupby_item_id;
  if (!categoryItemCondition && chartSerieProps.stackby &&
    isVariablesGroupby(chartSerieProps.stackby) && chartSerieProps.sc_stackby_item_id) {
    categoryItemCondition = "^cat_item=" + chartSerieProps.sc_stackby_item_id;
  }
  var aggregateQuery = aggregateQueryPerSeries ? seriesData[indx].aggregate_query : seriesData.aggregate_query[indx];
  var filter = removeNonConditionTerms(chartSerieProps.filter);
  dataPoint['click_url_info'] = combineQueries(combineQueries(filter, categoryItemCondition), aggregateQuery);
  var publisherFilter = removeNonConditionTerms(chartProps.report_properties.publisher_filter);
  dataPoint['publisher_filter'] = combineQueries(combineQueries(publisherFilter, categoryItemCondition), aggregateQuery);
}

function generateOtherUrlInfo(indx, chartProps, tableName, chartSerieProps) {
  var urlObj = {};
  var urlString = 'report_viewer.do?';
  var pagenum = parseInt(chartProps.page_num) + 1;
  if (chartSerieProps.report_id) {
    urlObj = {
      "jvar_report_id": [chartSerieProps.report_id],
      "sysparm_other_series": [chartSerieProps.report_id],
      "sysparm_page_num": [pagenum],
    };
    if (chartProps.interactive_report)
      urlObj.sysparm_interactive_report = chartProps.interactive_report;
  } else {
    var reportProps = chartProps.report_properties;
    if (reportProps) {
      urlObj = {
        "sysparm_bar_unstack": [chartSerieProps.bar_unstack],
        "sysparm_show_chart_total": [reportProps.show_chart_total],
        "sysparm_show_other": [chartProps.show_other],
        "sysparm_lower_limit": [reportProps.lower_limit],
        "sysparm_title": [chartProps.title],
        "sysparm_table": [tableName],
        "sysparm_compute_percent": [reportProps.percents_from_count],
        "sysparm_custom_chart_size": [reportProps.custom_chart_size],
        "sysparm_color_palette": [chartSerieProps.color_palette],
        "sysparm_gauge_autoscale": [reportProps.gauge_autoscale],
        "sysparm_aggregate": [chartProps.aggType],
        "sysparm_show_marker": [chartSerieProps.show_marker],
        "sysparm_show_chart_data_label": [reportProps.show_chart_data_label],
        "sysparm_page_num": [pagenum],
        "sysparm_type": [chartProps.chartType],
        "sysparm_chart_size": [chartProps.chartSize],
        "sysparm_direction": [reportProps.direction],
        "sysparm_field": [chartSerieProps.groupby],
        "sysparm_set_color": [chartSerieProps.set_color],
        "sysparm_funnel_neck_percent": [reportProps.funnel_neck_percent],
        "sysparm_from": [reportProps.from],
        "sysparm_donut_width_percent": [reportProps.donut_width_percent],
        "sysparm_others": [chartProps.other_threshold],
        "sysparm_chart_color": [chartSerieProps.color],
        "sysparm_display_grid": [chartProps.display_grid],
        "sysparm_to": [reportProps.to],
        "sysparm_upper_limit": [reportProps.upper_limit],
        "sysparm_box_field": [chartProps.box_field],
        "sysparm_query": [chartProps.filter_with_orderby],
        "sysparm_sumfield": [chartProps.agg_field],
        "sysparm_stack_field": [chartProps.stack_field],
        "sysparm_trend_field": [chartProps.trend_field],
        "sysparm_trend_interval": [chartProps.trend_interval],
        "sysparm_chart_colors": [chartProps.colors]
      };
      if (reportProps.custom_chart_size) {
        urlObj.sysparm_custom_chart_height = chartProps.chart_height;
        urlObj.sysparm_custom_chart_width = chartProps.chart_width;
      }
    }
  }
  return urlString + jQuery.param(urlObj, true);
}

function hc_createSingleSeriesDataLocationPt(chartProps, indx, seriesData, isUI, chartSerieProps) {
  if (typeof seriesData.locations[indx] === 'undefined')
    return;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = seriesData.locations[indx].city;
  dataPoint['street'] = seriesData.locations[indx].street;
  dataPoint['city'] = seriesData.locations[indx].city;
  dataPoint['state'] = seriesData.locations[indx].state;
  dataPoint['country'] = seriesData.locations[indx].country;
  dataPoint['lat'] = seriesData.locations[indx].latitude;
  dataPoint['lon'] = seriesData.locations[indx].longitude;
  dataPoint['valid'] = (seriesData.valids != undefined ? (seriesData.valids[indx] === "true") : true);
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    if ('click_url_info' in seriesData && seriesData.click_url_info[indx])
      dataPoint['click_url_info'] = seriesData.click_url_info[indx];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    if ('report_drilldown_zoom' in chartSerieProps)
      dataPoint['report_drilldown_zoom'] = chartSerieProps.report_drilldown_zoom;
    if ('report_drilldown_map' in chartSerieProps)
      dataPoint['report_drilldown_map'] = chartSerieProps.report_drilldown_map;
    dataPoint['isLatLon'] = true;
    dataPoint['show_data_label'] = chartSerieProps.show_chart_data_label;
    dataPoint['show_geographical_label'] = chartSerieProps.show_geographical_label;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function hc_createSingleSeriesDataLocationHcKeyPt(chartProps, indx, seriesData, isUI, chartSerieProps) {
  if (typeof seriesData.locations[indx] === 'undefined')
    return;
  var dataPoint = {};
  dataPoint['name'] = seriesData.locations[indx].name;
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  dataPoint['value'] = seriesData.yvalues[indx];
  dataPoint['display_value'] = seriesData.ydisplayvalues[indx];
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    if ('click_url_info' in seriesData && seriesData.click_url_info[indx])
      dataPoint['click_url_info'] = seriesData.click_url_info[indx];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    if ('report_drilldown_zoom' in chartSerieProps)
      dataPoint['report_drilldown_zoom'] = chartSerieProps.report_drilldown_zoom;
    if ('report_drilldown_map' in chartSerieProps)
      dataPoint['report_drilldown_map'] = chartSerieProps.report_drilldown_map;
    dataPoint['isLatLon'] = false;
    dataPoint['show_data_label'] = chartSerieProps.show_chart_data_label;
    dataPoint['show_geographical_label'] = chartSerieProps.show_geographical_label;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  return dataPoint;
}

function hc_createHeatmapSeriesDataPt(chartProps, indx, seriesData, chartSerieProps, isUI) {
  var xIndex = 0,
    yIndex = 1,
    valueIndex = 2,
    displayValueIndex = 3,
    tooltipIndex = 4,
    clickUrlIndex = 5;
  var val;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = chartProps.origXValues[indx];
  dataPoint['x'] = seriesData.series.data[indx][xIndex];
  dataPoint['y'] = seriesData.series.data[indx][yIndex];
  if (seriesData.series.data[indx][valueIndex] === null)
    val = 0;
  else
    val = parseFloat(seriesData.series.data[indx][valueIndex]);
  dataPoint['value'] = val;
  if (seriesData.series.data[indx][displayValueIndex])
    dataPoint['value_display'] = seriesData.series.data[indx][displayValueIndex];
  else
    dataPoint['value_display'] = '0';
  if (dataPoint['value_display'] === '0' && chartProps.report_properties.show_zero === false)
    dataPoint['value_display'] = '';
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['isOther'] = false;
    dataPoint['percent_count'] = false;
    if (seriesData.series.data[indx][clickUrlIndex]) {
      dataPoint['click_url_info'] = generateHeatMapClickUrl(seriesData, indx, clickUrlIndex);
    }
    if (seriesData.series.data[indx][tooltipIndex])
      dataPoint['value_tooltip'] = seriesData.series.data[indx][tooltipIndex];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function generateHeatMapClickUrl(seriesData, indx, clickUrlIndex) {
  var showOther = seriesData.sysparm_show_other;
  var xAxisCategoryCount = seriesData.xAxisCategories.length;
  var aggregateQuery = seriesData.series.data[indx][clickUrlIndex];
  var filter = removeNonConditionTerms(seriesData.filter);
  if (showOther && (indx + 1) % xAxisCategoryCount === 0 && seriesData.otherQuery) {
    aggregateQuery = aggregateQuery + "^" + seriesData.otherQuery;
  }
  return combineQueries(filter, aggregateQuery);
}

function hc_createBubbleSeriesDataPt(chartProps, indx, seriesData, chartSerieProps, isUI, table_name) {
  var dataPoint = {};
  dataPoint['name'] = chartProps.origXValues[indx];
  dataPoint['x'] = seriesData[indx]['x'];
  dataPoint['y'] = seriesData[indx]['y'];
  dataPoint['z'] = seriesData[indx]['z'];
  dataPoint['value_display'] = seriesData[indx]['value_display'];
  if (isUI) {
    dataPoint['table'] = table_name;
    generateSeriesUrlInfo(dataPoint, indx, false, seriesData, chartSerieProps, true, chartProps, dataPoint['table']);
    dataPoint['value_tooltip'] = seriesData[indx]['value_tooltip'];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  return dataPoint;
}

function hc_initStackedSeriesDataPoint(indx, indx2, x2Vals, x2Colors, chartProps, tblName, tblDispPlural, isUI, serieProps, seriesData, categoryIndx) {
  var dataPoint = {};
  if (categoryIndx != undefined)
    dataPoint['x'] = categoryIndx;
  dataPoint['y'] = serieProps.use_null ? null : 0;
  dataPoint['name'] = x2Vals[indx].displayValue;
  dataPoint['color'] = x2Colors[indx];
  dataPoint['table'] = tblName;
  dataPoint['table_display_plural'] = tblDispPlural;
  dataPoint['isOther'] = false;
  if (chartProps.origXValues[indx2] == chartProps.otherKey)
    dataPoint['isOther'] = true;
  dataPoint['valid'] = false;
  hc_addPropsForDataLabelsTruncation(dataPoint, serieProps);
  return dataPoint;
}

function hc_fillStackedSeriesDataPoint(dataPoint, indx, subSeriesData, chartProps, isUI, chartPropsSerie, categoryIndx, isSlowMetricTable, datetime) {
  dataPoint['valid'] = true;
  if ('percents_from_count' in chartPropsSerie && chartPropsSerie.percents_from_count)
    dataPoint['percent_count'] = true;
  else
    dataPoint['percent_count'] = false;
  if (categoryIndx != undefined)
    dataPoint['x'] = categoryIndx;
  dataPoint['y'] = subSeriesData.yvalues[indx] ? parseFloat(subSeriesData.yvalues[indx]) : null;
  dataPoint['y_tooltip'] = subSeriesData.ydisplayvalues[indx];
  dataPoint['percent'] = subSeriesData.percentages[indx];
  if (isUI) {
    if (dataPoint['isOther'] || (subSeriesData.aggregate_query && subSeriesData.aggregate_query[indx]))
      generateSeriesUrlInfo(dataPoint, indx, dataPoint['isOther'], subSeriesData, chartPropsSerie, undefined, chartProps, dataPoint['table']);
    dataPoint['list_ui_view_name'] = chartPropsSerie.list_ui_view_name;
    dataPoint['report_drilldown'] = chartPropsSerie.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  if (isSlowMetricTable) {
    dataPoint['x'] = hc_convertDateTimeFormatToUnixTime(datetime);
  }
}

function hc_createLineSeriesData(hcOptions, chartData, chartProps, isUI) {
  return hc_createMultipleSeriesData(hcOptions, chartData, chartProps, isUI);
}

function hc_createControlSeriesData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var chartSerieProps = chartData.report_properties_series[0];
  var series = [];
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var dataPtSeries = {};
  dataPtSeries.name = 'Data Points';
  dataPtSeries.color = 'black';
  dataPtSeries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = {};
    dataPoint['y'] = seriesData.yvalues[j] ? parseFloat(seriesData.yvalues[j]) : null;
    dataPoint['y_tooltip'] = seriesData.ydisplayvalues[j];
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (isUI) {
      if ('aggregate_query' in seriesData)
        generateSeriesUrlInfo(dataPoint, j, false, seriesData, chartSerieProps, false, chartProps);
      if ('list_ui_view_name' in chartSerieProps)
        dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
      if ('report_drilldown' in chartSerieProps)
        dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
      dataPoint['drill_open_new_win'] = false;
      if ('drill_open_new_win' in chartProps.report_properties)
        dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
      if ('widget_navigation' in chartProps.report_properties) {
        dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
        dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
      }
    }
    hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
    dataPtSeries.data.push(dataPoint);
  }
  series.push(dataPtSeries);
  var trendLineSeries = {};
  trendLineSeries.name = 'Trend Line';
  if (isUI && isAccessibilityPatternsEnabled()) {
    trendLineSeries.dashStyle = 'LongDashDot'
    trendLineSeries.color = '#000';
  } else
    trendLineSeries.color = 'yellow';
  trendLineSeries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPt = {};
    var y = parseFloat(seriesData.trendvalues[j]);
    dataPt.y = y;
    dataPt.y_tooltip = seriesData.trenddisplayvalues[j];
    hc_addPropsForDataLabelsTruncation(dataPt, chartProps.report_properties);
    trendLineSeries.data.push(dataPt);
  }
  series.push(trendLineSeries);
  var controlVals = seriesData.controlvalues;
  var displayVals = [];
  displayVals.push(seriesData.controldisplayvalues[0]);
  displayVals.push(seriesData.controldisplayvalues[1]);
  displayVals.push(seriesData.controldisplayvalues[2]);
  displayVals.push(seriesData.controldisplayvalues[3]);
  displayVals.push(seriesData.controldisplayvalues[4]);
  series.push(hc_createControlPlotLine('-3Z', 'red', parseFloat(controlVals[0]), displayVals[0], chartProps, isUI));
  series.push(hc_createControlPlotLine('-2Z', 'green', parseFloat(controlVals[1]), displayVals[1], chartProps, isUI));
  series.push(hc_createControlPlotLine('Mean', 'blue', parseFloat(controlVals[2]), displayVals[2], chartProps, isUI));
  series.push(hc_createControlPlotLine('+2Z', 'green', parseFloat(controlVals[3]), displayVals[3], chartProps, isUI));
  series.push(hc_createControlPlotLine('+3Z', 'red', parseFloat(controlVals[4]), displayVals[4], chartProps, isUI));
  return series;
}

function hc_createControlPlotLine(label, color, val, disp, chartProps, isUI) {
  var series = {};
  series.name = label;
  if (isUI && isAccessibilityPatternsEnabled()) {
    if (color === 'red')
      series.dashStyle = 'Dot';
    else if (color === 'green')
      series.dashStyle = 'ShortDash';
    else
      series.dashStyle = 'Dash';
    series.color = '#000';
  } else
    series.color = color;
  series.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPt = {};
    dataPt.y = val;
    dataPt.y_tooltip = disp;
    dataPt.marker = {};
    dataPt.marker.enabled = false;
    hc_addPropsForDataLabelsTruncation(dataPt, chartProps.report_properties);
    series.data.push(dataPt);
  }
  return series;
}

function hc_createBoxPlotData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name + ':box';
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var boxseries = {};
  boxseries.name = seriesName;
  if ('box_color' in chartProps.report_properties)
    boxseries.color = chartProps.report_properties.box_color;
  boxseries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var boxValArray = [];
    var boxDisplayValArray = [];
    boxDisplayValArray = seriesData.boxdisplayvalues[j];
    if (isUI)
      boxValArray = seriesData.boxvalues[j].split(',');
    else
      boxValArray = hc_strToArray(seriesData.boxvalues[j], ',');
    var boxVals = {};
    boxVals.low = parseFloat(boxValArray[0]);
    boxVals.q1 = parseFloat(boxValArray[1]);
    boxVals.median = parseFloat(boxValArray[2]);
    boxVals.q3 = parseFloat(boxValArray[3]);
    boxVals.high = parseFloat(boxValArray[4]);
    boxVals.low_display = boxDisplayValArray[0];
    boxVals.q1_display = boxDisplayValArray[1];
    boxVals.median_display = boxDisplayValArray[2];
    boxVals.q3_display = boxDisplayValArray[3];
    boxVals.high_display = boxDisplayValArray[4];
    boxseries.data.push(boxVals);
  }
  if (isUI) {
    boxseries.tooltip = {};
    boxseries.tooltip.pointFormat = '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>' +
      chartProps.report_properties.box_max + ': {point.high_display}<br/>' +
      chartProps.report_properties.box_q3 + ': {point.q3_display}<br/>' +
      chartProps.report_properties.box_median + ': {point.median_display}<br/>' +
      chartProps.report_properties.box_q1 + ': {point.q1_display}<br/>' +
      chartProps.report_properties.box_min + ': {point.low_display}<br/>';
  }
  return boxseries;
}

function hc_createBoxMeanData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name + ':mean';
  var meanseries = {};
  meanseries.name = seriesName;
  meanseries.type = 'scatter';
  if ('box_mean_color' in chartProps.report_properties)
    meanseries.color = chartProps.report_properties.box_mean_color;
  meanseries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = [];
    dataPoint.push(j);
    dataPoint.push(parseFloat(seriesData.yvalues[j]));
    meanseries.data.push(dataPoint);
  }
  if (isUI) {
    meanseries.tooltip = {};
    meanseries.tooltip.pointFormat = chartProps.report_properties.box_mean + ': {point.y}';
  }
  return meanseries;
}

function hc_isPresentInArray(arr, key) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === key)
      return i;
  }
  return -1;
}

function hc_strToArray(str, delim) {
  var arr = [];
  var indx = str.indexOf(delim);
  while (indx >= 0) {
    var elem = str.substring(0, indx);
    arr.push(elem);
    str = str.substring(indx + 1);
    indx = str.indexOf(delim);
  }
  str = str.trim();
  if (str.length > 0)
    arr.push(str);
  return arr;
}

function hc_dataPointSelected(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  if (typeof this.publisher_filter === 'undefined' || event.accumulate === 'preventDataPointSelect')
    return;
  var queryCondition = this.publisher_filter.replace('^', '^EQ^');
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + queryCondition;
  var filterMessage = hc_interactiveFilterMessage(uniqueId, this.table, queryCondition);
  filterMessage.sliced = true;
  if (gridWindow.queryCondition) {
    var oldUniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + gridWindow.queryCondition;
    delete gridWindow.interactiveFilters[oldUniqueId];
  }
  gridWindow.queryCondition = queryCondition;
  gridWindow.interactiveFilters[uniqueId] = filterMessage;
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters, gridWindow._dashboardMessageHandler);
}

function hc_dataPointUnselected(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  if (typeof this.publisher_filter === 'undefined' || (typeof event.accumulate === 'undefined' && event.type === 'unselect'))
    return;
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  var queryCondition = this.publisher_filter.replace('^', '^EQ^');
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + queryCondition;
  delete gridWindow.interactiveFilters[uniqueId];
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters, gridWindow._dashboardMessageHandler);
}

function hc_FilterPublisher(reportId, filter, dashboardMessageHandler) {
  var filterMessages = [];
  for (var key in filter) {
    filterMessages.push(filter[key]);
  }
  var handler = dashboardMessageHandler || new DashboardMessageHandler(reportId);
  var isInCanvas = window.SNC && SNC.canvas && SNC.canvas.interactiveFilters && SNC.canvas.isGridCanvasActive;
  if (filterMessages.length > 0) {
    handler.publishMessage(filterMessages);
    if (isInCanvas)
      SNC.canvas.interactiveFilters.addFilterToDefaultValues(reportId, filterMessages);
  } else {
    if (isInCanvas)
      SNC.canvas.interactiveFilters.removeFilterFromDefaultValues(reportId);
    handler.removeFilter();
  }
};

function hc_dataPointPublishFilter(reportId, filter, dashboardMessageHandler) {
  var currentFilterPublishedTime = Date.now();
  if (isRenderedInCanvas()) {
    SNC.canvas.chartsActingAsFilters = SNC.canvas.chartsActingAsFilters || {};
    SNC.canvas.chartsActingAsFilters.lastPublishTime = SNC.canvas.chartsActingAsFilters.currentPublishTime || currentFilterPublishedTime;
    SNC.canvas.chartsActingAsFilters.currentPublishTime = currentFilterPublishedTime;
    SNC.canvas.chartsActingAsFilters.previousId = SNC.canvas.chartsActingAsFilters.currentId || null;
    SNC.canvas.chartsActingAsFilters.currentId = reportId || null;
  }
  hc_FilterPublisher(reportId, filter, dashboardMessageHandler);
}

function hc_interactiveFilterMessage(uniqueId, table, filter) {
  var filter_message = {};
  filter_message.id = uniqueId;
  filter_message.table = table;
  filter_message.filter = filter;
  return filter_message;
}

function hc_dataPointLegendClick(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  var filtersFromLegend = {};
  if (gridWindow.filtersFromLegend)
    filtersFromLegend = gridWindow.filtersFromLegend;
  var selected = jQuery.grep(this.series.points, function(obj) {
    if (event.target == obj && obj.visible)
      filtersFromLegend[obj.publisher_filter] = obj.publisher_filter;
    return event.target == obj ? !obj.visible : obj.visible
  });
  if (selected.length == this.series.points.length) {
    delete gridWindow.interactiveFilters[uniqueId];
    delete gridWindow.filtersFromLegend;
  } else {
    var queryArr = jQuery.map(selected, function(val, index) {
      return val.publisher_filter;
    });
    var queryCondition = queryArr.join('^NQ');
    var filterMessage = hc_interactiveFilterMessage(uniqueId, this.table, queryCondition);
    gridWindow.interactiveFilters[uniqueId] = filterMessage;
    gridWindow.filtersFromLegend = filtersFromLegend;
  }
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters);
}

function getDashboardMessageHandlerId(publisherId, reportId) {
  var dashboardMesssageHandlerId = '';
  if (typeof glideGrid != "undefined") {
    var gridWindow = glideGrid.getWindowByGaugeId(publisherId);
    if (typeof gridWindow != 'undefined' && gridWindow != null && gridWindow)
      dashboardMesssageHandlerId = publisherId;
    else
      dashboardMesssageHandlerId = reportId;
  } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
    var gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
    if (typeof gridWindow != 'undefined' && gridWindow != null && gridWindow)
      dashboardMesssageHandlerId = reportId;
    else
      dashboardMesssageHandlerId = publisherId;
  }
  return dashboardMesssageHandlerId;
}

function getGridWindow(publisherId, reportId) {
  var gridWindow;
  if (typeof glideGrid != "undefined") {
    gridWindow = glideGrid.getWindowByGaugeId(publisherId);
    if (typeof gridWindow === 'undefined' || gridWindow == null) {
      gridWindow = glideGrid.getWindowByGaugeId(reportId);
    }
  } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
    gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
  } else {
    gridWindow = glideGrid.getWindowByGaugeId(reportId);
  }
  return gridWindow;
}

function hc_dataPointClicked(event) {
  var point = event.point || event.target;
  if (!point || point.valid === false || typeof point.click_url_info === "undefined")
    return;
  var openNewTab;
  if (event.ctrlKey || event.metaKey)
    openNewTab = true;
  if (point.widget_navigation && point.widget_navigation.length) {
    var widgetNav = point.widget_navigation[0];
    window.open(widgetNav.value, openNewTab ? '_blank' : '_self');
  } else if (point.isOther)
    openUrl(event, point.click_url_info);
  else {
    var element = event.srcElement || event.target;
    if (event.target && event.target.graphic)
      element = event.target.graphic.element;
    var hcKey = '';
    if (typeof point.isLatLon !== 'undefined' && !point.isLatLon)
      hcKey = point.properties['hc-key'];
    generateDataPointClickUrl(event, element, point.report_drilldown, point.table, point.click_url_info, point.list_ui_view_name, point.drill_open_new_win, point.isOther,
      (point.report_drilldown_zoom ? hcKey : null), point.report_drilldown_map, point.show_data_label, point.show_geographical_label);
  }
}

function hc_formatToolTip() {
  var tt = '';
  var parenthesisOpen = false;
  if (typeof this.point.valid == 'undefined' || this.point.valid === true) {
    if (this.series.name == 'pareto_series')
      tt = this.point.percent + '%';
    else {
      tt = this.x + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
      parenthesisOpen = true;
    }
    if (this.point.percent_count)
      tt += ' of ' + this.point.table_display_plural;
    if (parenthesisOpen)
      tt += ')';
    if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
      tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
    return tt;
  }
  return false;
}

function hc_formatGeneralLineBarToolTip(event) {
  var typeTooltip = this.series.options.tooltip.tooltipText;
  if ('stacked' === typeTooltip) {
    if (this.point.valid) {
      var xValue = this.x;
      if (hc_isSlowMetricChart(this.series.chart.options))
        xValue = hc_formatDatetimeString(this.x);
      var tt = xValue + ', ' + this.point.name + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
      if (this.point.percent_count)
        tt += ' of ' + this.point.table_display_plural + ')';
      else
        tt += ')';
      if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
        tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
      return tt;
    }
    return false;
  } else {
    var tt = '';
    var parenthesisOpen = false;
    if (typeof this.point.valid == 'undefined' || this.point.valid === true) {
      if (this.series.name == 'pareto_series')
        tt = this.point.percent + '%';
      else {
        var xValue = this.x;
        if (hc_isSlowMetricChart(this.series.chart.options))
          xValue = hc_formatDatetimeString(this.x);
        tt = xValue + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
        parenthesisOpen = true;
      }
      if (this.point.percent_count)
        tt += ' of ' + this.point.table_display_plural;
      if (parenthesisOpen)
        tt += ')';
      if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
        tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
      return tt;
    }
    return false;
  }
}

function hc_formatPie() {
  var tt = this.key + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%)';
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatHeatmapTooltip() {
  var tt = '<b>' + this.point.value_tooltip + '</b>';
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatMapTooltip() {
  var tt = this.point.name + (this.point.y_tooltip != '' ? ':' + this.point.y_tooltip : '');
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatMapDataLabels() {
  var showGeoLabel = this.point.series.chart.series[0].options.dataLabels.show_geographical_label;
  var showDataLabel = this.point.series.chart.series[0].options.dataLabels.show_data_label;
  var name = this.point.name;
  var value = this.point.y_tooltip;
  var out = '';
  if (showDataLabel && showGeoLabel)
    out = value !== undefined && value != '' ? name + ':' + value : name;
  else if (showDataLabel && !showGeoLabel)
    out = value;
  else if (!showDataLabel && showGeoLabel)
    out = name;
  return out;
}

function hc_formatStackedBarToolTip() {
  if (this.point.valid) {
    var tt = this.x + ', ' + this.point.name + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
    if (this.point.percent_count)
      tt += ' of ' + this.point.table_display_plural + ')';
    else
      tt += ')';
    if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
      tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
    return tt;
  }
  return false;
}

function hc_formatHistToolTip() {
  var rangevals = this.x.split(':');
  var tt = this.point.tt_label_min + ' = ' + rangevals[0] + '<br/>' +
    this.point.tt_label_max + ' = ' + rangevals[1] + '<br/>' +
    this.point.tt_label_cnt + ' = ' + this.y;
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatControlToolTip() {
  var tt = this.x + ' = ' + this.point.y_tooltip;
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_addPropsForDataLabelsTruncation(dataPoint, reportProperties) {
  dataPoint.data_label_max_length = reportProperties.data_label_max_size;
  if ('truncate_data_labels' in reportProperties)
    dataPoint.truncate_data_labels = reportProperties.truncate_data_labels;
  if ('data_labels_remove_leading' in reportProperties)
    dataPoint.data_labels_remove_leading = reportProperties.data_labels_remove_leading;
}

function hc_addTotal(hcOptions, chartProps, series, chartData) {
  if (!series.data.length) {
    return;
  }
  hcOptions.subtitle = {};
  hcOptions.subtitle.verticalAlign = 'middle';
  hcOptions.subtitle.align = 'center';
  hcOptions.subtitle.style = {};
  hcOptions.subtitle.style.fontFamily = 'Arial';
  hcOptions.subtitle.style.color = '#000';
  hcOptions.subtitle.style['text-align'] = 'center';
  var titleVerticalAlign = chartData.report_properties.title_vertical_alignment;
  var titleSize = chartData.report_properties.chart_title_size;
  var fontHelper;
  if (hcOptions.chart.width < hcOptions.chart.height)
    fontHelper = hcOptions.chart.width;
  else
    fontHelper = hcOptions.chart.height;
  var fontSize = fontHelper / 15;
  var durationSubFontSize = parseInt(fontHelper / 20);
  hcOptions.subtitle.style.fontSize = parseInt(fontSize) + "pt";
  var yPos = 0;
  if ("yaxis_duration" in chartData.series[0] && chartData.series[0].yaxis_duration) {
    hcOptions.subtitle.useHTML = true;
    hcOptions.subtitle.style['line-height'] = parseInt(fontSize / 1.2) + "pt";
    var days = 'Days';
    var hours = 'Hours';
    var minutes = 'Minutes';
    var seconds = 'Seconds';
    var translation = chartData.report_properties.translation;
    if (translation != undefined) {
      days = translation.days;
      hours = translation.hours;
      minutes = translation.minutes;
      seconds = translation.seconds;
    }
    series.total = series.total.replace(days, days + "<br/><span style='font-size:" + durationSubFontSize + "pt;'>")
      .replace(" " + hours + " ", "h:").replace(" " + minutes + " ", "m:").replace(" " + seconds, "s") +
      "</span>";
    if (chartProps.chartType == 'donut') {
      if (hcOptions.title.text === '') {
        yPos = 0 - fontSize * (.5 + fontSize / 200);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 2 - fontSize * (fontSize / 100);
      } else if (titleVerticalAlign === 'bottom') {
        yPos = 0 - (titleSize / 2 + fontSize * (fontSize / 100));
      }
    } else {
      if (hcOptions.title.text === '') {
        yPos = fontSize * 1.55;
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 3 + fontSize * 1.55;
      } else if (titleVerticalAlign === 'bottom') {
        yPos = (fontSize * 1.55 + 11) - (titleSize / 1.4);
      }
    }
  } else {
    series.total = "<span title=" + series.total_value + ">" + series.total + "</span>";
    if (chartProps.chartType == 'donut') {
      if (hcOptions.title.text === '') {
        yPos = 0 - fontSize * (.2 + fontSize / 200);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 2 + fontSize * (.35 - fontSize / 100);
      } else if (titleVerticalAlign === 'bottom') {
        yPos = 0 - (titleSize / 2.5 + fontSize * (fontSize / 150));
      }
    } else {
      if (hcOptions.title.text === '') {
        yPos = fontSize * (2.3 + fontSize / 400);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 4 + fontSize * 2.55;
      } else if (titleVerticalAlign === 'bottom') {
        yPos = fontSize * (2.8 - fontSize / 400) - titleSize / 1.4;
      }
    }
  }
  hcOptions.subtitle.useHTML = true;
  hcOptions.subtitle.text = series.total;
  hcOptions.subtitle.y = yPos;
  hcOptions.legend.enabled = false;
}

function clickOnABreadcrumb(reportId, containerId, jsonProperties) {
  var decodedJsonProperties = decodeURIComponent(jsonProperties);
  var jsonProperties = JSON.parse(decodedJsonProperties);
  var content = jQuery("#" + containerId);
  var mapParams = '';
  var map;
  var contParams = 0;
  for (var i = 0; i < jsonProperties.length; i++) {
    var jsonProp = jsonProperties[i];
    if (jsonProp.key === 'report_map')
      map = jsonProp.value;
  }
  mapParams += "&sysparm_report_map_parent=" + map;
  drillReport(content.parent().parent(), reportId, '', mapParams);
}

function hc_isSlowMetricChart(hcOptions, seriesData) {
  if (hcOptions && hcOptions.chart && hcOptions.chart.isChartingSlowMetricTable !== undefined)
    return hcOptions.chart.isChartingSlowMetricTable;
  if (seriesData && seriesData.table_name && seriesData.xvalues && seriesData.xvalues[0] &&
    seriesData.table_name.indexOf('v_rrd') === 0 &&
    /(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)/.test(seriesData.xvalues[0])) {
    hcOptions.chart.isChartingSlowMetricTable = true;
    return true;
  } else
    hcOptions.chart.isChartingSlowMetricTable = false;
  return false;
}

function hc_convertDateTimeFormatToUnixTime(datetime) {
  var dateAndTimes = /(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)/.exec(datetime);
  dateAndTimes.shift();
  for (var i = 0; i < dateAndTimes.length; i++) {
    dateAndTimes[i] = parseInt(dateAndTimes[i], 10);
  }
  return Date.UTC(dateAndTimes[0], dateAndTimes[1] - 1, dateAndTimes[2], dateAndTimes[3], dateAndTimes[4], dateAndTimes[5]);
}

function hc_setZoomTypeForSlowMetric(chartData, hcOptions) {
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.chart.zoomType = 'x';
  }
}

function hc_formatDatetimeString(x) {
  var xValue = (new Date(x)).toUTCString();
  xValue = xValue.substring(0, xValue.length - 4);
  return xValue
}

function hc_addSummaryDataToLegendForSlowMetric(chartData, hcOptions, isUI) {
  if (isUI && !(window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils) && hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.legend.statsTable = {
      active: true,
      seriesLinkGenerator: function linkSeriesInLegendToPattern(serie) {
        try {
          var patternSysId = /pattern=(\w*)/.exec(serie.userOptions.data[0].click_url_info)[1];
          var patternType = serie.userOptions.data[0].table.split("_").pop();
          return "sys_" + patternType + "_pattern.do?sys_id=" + patternSysId;
        } catch (e) {
          return "";
        }
      }
    };
    if (chartData.title.indexOf("Time") >= 0)
      hcOptions.legend.statsTable.unit = 'ms';
    hcOptions.chart.height -= 120;
  }
}

function hc_differenceOfClosestStringDateTimesInSeries(xValues) {
  var previousValue = hc_convertDateTimeFormatToUnixTime(xValues[0]);
  var smallestDifference = Number.MAX_VALUE;
  var currentValue, currentDifference;
  for (var i = 1; i < xValues.length; i++) {
    currentValue = hc_convertDateTimeFormatToUnixTime(xValues[i]);
    currentDifference = currentValue - previousValue;
    if (currentDifference < smallestDifference)
      smallestDifference = currentDifference;
    previousValue = currentValue;
  }
  if (smallestDifference === Number.MAX_VALUE)
    return 0;
  return smallestDifference;
}

function hc_disableTurboThreshold(hcOptions) {
  var threshold = 0;
  if (typeof hcOptions !== 'undefined' && typeof hcOptions.series !== 'undefined') {
    for (var i = 0; i < hcOptions.series.length; i++)
      hcOptions.series[i].turboThreshold = threshold;
  }
}

function hc_setDataLabelPositionProperties(hcOptions, chartData) {
  var hcOptionSeriesCount = 0;
  var numberOfDatasets = chartData.series.length;
  for (var datasetIndex = 0; datasetIndex < numberOfDatasets; datasetIndex++) {
    var dataset = chartData.series[datasetIndex];
    var numberOfHcSeriesPerDataset = 1;
    if ('sub_series' in dataset)
      numberOfHcSeriesPerDataset = dataset.x2values.length;
    for (var j = 0; j < numberOfHcSeriesPerDataset; j++) {
      if (chartData.report_properties_series[datasetIndex].show_chart_data_label) {
        hcOptions.series[j + hcOptionSeriesCount].dataLabels.enabled = true;
        if (chartData.report_properties_series[datasetIndex].show_data_label_position_middle) {
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.verticalAlign = 'middle';
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.inside = true;
        } else
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.inside = false;
        if (chartData.report_properties_series[datasetIndex].allow_data_label_overlap)
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.allowOverlap = true;
        else
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.allowOverlap = false;
      } else
        hcOptions.series[j + hcOptionSeriesCount].dataLabels.enabled = false;
    }
    hcOptionSeriesCount += numberOfHcSeriesPerDataset;
  }
}

function isAccessibilityPatternsEnabled() {
  return window.g_accessibility_visual_patterns === 'true' || window.g_accessibility_visual_patterns === true;
};
/*! RESOURCE: /scripts/reportcommon/customvisuals/multilevel-pivot.js */
var MultilevelPivot = function MultilevelPivot(reportUUID, runType, options, notSaveStatistics) {
  'use strict';
  var self = this;
  if (!options) {
    options = window.g_report_params[reportUUID];
    options.is_report_source_filter_already_combined = true;
  }
  options.not_save_statistics = notSaveStatistics;
  createReportTemplate(reportUUID, options);
  this.containerId = 'chart-container-' + reportUUID;
  this.showZero = options.show_zero;
  this.pivotExpanded = options.pivot_expanded !== 'false' && options.pivot_expanded !== false;
  this.displayRowLines = options.display_row_lines !== 'false' && options.display_row_lines !== false;
  this.displayColumnLines = options.display_column_lines !== 'false' && options.display_column_lines !== false;
  this.fixedHeaders = window.chartHelpers.systemParams.fixedHeaders;
  this.table = options.table;
  this.$table = jQuery('<table id="pivot_table" class="pivot-2-levels table" cellspacing="0" cellpadding="0" tabindex="0" role="grid" />');
  this.listUIViewName = '';
  this.isBuilder = jQuery('#reportform_control').length || (typeof gReport !== 'undefined' && gReport && gReport.isDesigner);
  this.isDesigner = (typeof gReport !== 'undefined' && gReport && gReport.isDesigner);
  this.isOldBuilder = jQuery('#reportform_control').length;
  this.isCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  this.options = options;
  this.title = options.title;
  var leftMostRowSpan = [];
  var leftMostRowValue = [];
  var showMessage = function showMessage(msg, level) {
    if (level === 'FAILURE')
      jQuery('#' + self.containerId).html('<div class="pivot-error">ERROR: ' + msg + '</div>');
    else
      jQuery('#' + self.containerId).before('<div class="pivot-infomessage">' + msg + '</div>');
  };
  this.init = function init() {
    self.runPivot(options, runType);
    self.eventHandlers();
  };
  this.runPivot = function runPivot() {
    self.startTime = new Date().getTime();
    var processor = (runType === 'run') ? 'PivotRunProcessor' : 'PivotRunPublishedProcessor';
    jQuery.ajax({
      method: 'POST',
      url: '/xmlhttp.do',
      dataType: 'xml',
      headers: {
        'X-UserToken': window.g_ck
      },
      data: {
        sysparm_processor: processor,
        sysparm_scope: 'global',
        is_portal: options.is_portal,
        sysparm_timer: new Date().getTime(),
        sysparm_request_params: JSON.stringify(self.buildRequestParams(options))
      }
    }).done(function doneCb(xml) {
      self.processResponse(xml);
    }).fail(function failCb(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
  };
  this.processResponse = function processResponse(response) {
    if (!response)
      showError(self.containerId, 'No response from the server');
    else {
      var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
      if (resp.STATUS === 'SUCCESS')
        try {
          response = JSON.parse(resp.RESPONSE_DATA);
          if (response.widget_navigation && response.widget_navigation.length)
            this.widgetNav = response.widget_navigation[0];
          self.reportDrilldown = response.report_drilldown;
          self.renderTable(response);
          if (self.isBuilder && response.drill_message)
            showMessage(response.drill_message);
          if (response.message)
            showMessage(response.message, 'INFO');
          if (self.fixedHeaders)
            self.fixateHeader();
        } catch (err) {
          showMessage(chartHelpers.i18n.chartGenerationError, 'FAILURE');
          throw new Error(err);
        }
      else {
        jQuery('#' + self.containerId).empty();
        showMessage(resp.RESPONSE_DATA, resp.STATUS);
      }
    }
    var now = new Date().getTime();
    var elapsedTime = (now - self.startTime) / 1000;
    console.log('Time taken to render report: ' + elapsedTime);
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
  };
  this.reduceAxisCategories = function reduceAxisCategories(categories, sortKey) {
    var uniqueAxisCategories = {};
    for (var i = 0; i < categories.length; i++) {
      if (!uniqueAxisCategories.hasOwnProperty(categories[i][sortKey])) {
        var record = {};
        record.count = 1;
        record.value = categories[i].value;
        uniqueAxisCategories[categories[i][sortKey]] = record;
      } else
        uniqueAxisCategories[categories[i][sortKey]].count += 1;
    }
    return uniqueAxisCategories;
  }
  this.renderTable = function renderTable(response) {
    var aggregateFunction = response.aggregate.function;
    var titleProps;
    var showTitle = true;
    var config = self.options;
    var $container = jQuery('#' + self.containerId);
    var $table = self.$table;
    var $caption = jQuery('<caption class="sr-only"/>');
    var $row = jQuery('<tr role="row" />');
    var $yLabelsRow = jQuery('<tr class="y-labels-row header-row" role="row"/>');
    var yLastColSpan = 1;
    var xLastRowSpan = 1;
    var headerRows = [];
    var data = response.series.data;
    var xCategories = response.xAxisCategories;
    var yCategories = response.yAxisCategories;
    var xCategorySortKey = xCategories[0].fieldValues[0].hasOwnProperty("sys_id") ? "sys_id" : "value";
    var yCategorySortKey = yCategories[0].fieldValues[0].hasOwnProperty("sys_id") ? "sys_id" : "value";
    var subtotals = response.subtotals;
    self.listUIViewName = response.list_ui_view_name;
    self.drillOpenNewWin = response.drill_open_new_win;
    var xLevel = xCategories[0].fieldValues.length;
    var yLevel = yCategories[0].fieldValues.length;
    var yTopmostCategories = [];
    var xTopmostCategories = [];
    var nextBlocked = 0;
    $caption.text(config.chart_title || config.title);
    $table.append($caption);
    for (var i = 0; i < xLevel; i++)
      headerRows.push(jQuery('<tr class="header-row" role="row"/>'));
    for (i = 0; i < yCategories.length; i++)
      yTopmostCategories[i] = yCategories[i].fieldValues[0];
    for (i = 0; i < xCategories.length; i++)
      xTopmostCategories[i] = xCategories[i].fieldValues[0];
    var yTopmostUniqueCategories = this.reduceAxisCategories(yTopmostCategories, yCategorySortKey);
    var xTopmostUniqueCategories = this.reduceAxisCategories(xTopmostCategories, xCategorySortKey);
    if (yLevel === 1)
      yLastColSpan = 2;
    if (xLevel === 1)
      xLastRowSpan = 2;
    for (i = 0; i < yCategories.length; i++) {
      for (var j = 0; j <= xCategories.length; j++)
        if (j < xCategories.length) {
          var dataPoint = data[(xCategories.length * i) + j];
          var cellQueryParts = [];
          var dataPointValue = dataPoint[0];
          if (dataPointValue || (dataPointValue === 0 && (aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))) {
            var xCategoryQuery = response.otherQuery && !xCategories[j].categoryQuery ? response.otherQuery : xCategories[j].categoryQuery;
            cellQueryParts = [xCategoryQuery, yCategories[i].categoryQuery, response.filter];
          }
          if (dataPointValue === null && self.showZero && dataPoint[1] === "0")
            dataPointValue = 0;
          var colorStyle = chartHelpers.evaluateColorRules(dataPointValue, response.rules);
          var $td = jQuery('<td/>');
          if (colorStyle && colorStyle.color)
            $td.css('color', colorStyle.color);
          if (colorStyle && colorStyle.bgColor)
            $td.css('background-color', colorStyle.bgColor);
          $td.appendTo($row).html(self.generateCell(dataPoint[1], cellQueryParts, dataPoint[2], aggregateFunction));
        } else {
          var yAggregateQueryParts = [yCategories[i].categoryQuery];
          if (!response.sysparm_show_other && response.otherQuery)
            yAggregateQueryParts.push(response.otherQuery);
          yAggregateQueryParts.push(response.filter);
          jQuery('<td class="aggregate-right"/>').appendTo($row).html(self.generateCell(yCategories[i].aggregatedValue, yAggregateQueryParts, yCategories[i].tooltipText));
        }
      for (var k = yLevel - 1; k >= 0; k--)
        if (k === 0)
          if (nextBlocked === 0) {
            if (subtotals) {
              $row.addClass('below-subtotals');
              leftMostRowSpan.push(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count);
              leftMostRowValue.push(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].value);
            } else
              jQuery('<td/>', {
                class: 'y-axis-category-field-leftmost header-left',
                scope: 'row',
                role: 'rowheader',
                colspan: yLastColSpan,
                rowspan: yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count
              }).prependTo($row).text(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].value);
            nextBlocked = yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count - 1;
          } else
            nextBlocked--;
      else
      if (k === yLevel - 1)
        jQuery('<td/>', {
          scope: 'row',
          colspan: 2,
          role: 'rowheader',
          class: 'y-axis-category-field header-left'
        }).prependTo($row).text(yCategories[i].fieldValues[k].value);
      else
        jQuery('<td/>', {
          scope: 'row',
          class: 'y-axis-category-field header-left',
          role: 'rowheader'
        }).prependTo($row).text(yCategories[i].fieldValues[k].value);
      if (!self.pivotExpanded && subtotals)
        $row.css('display', 'none');
      $table.append($row.addClass('content-row'));
      $row = jQuery('<tr role="row"/>');
    }
    for (i = 0; i <= xCategories.length; i++)
      if (i < xCategories.length) {
        xCategoryQuery = response.otherQuery && !xCategories[i].categoryQuery ? response.otherQuery : xCategories[i].categoryQuery;
        var $content = self.generateCell(xCategories[i].aggregatedValue, [xCategoryQuery, response.filter], xCategories[i].tooltipText);
        $row.addClass('totals');
        jQuery('<td class="aggregate-bottom"/>').appendTo($row).html($content);
        for (j = 0; j < xLevel; j++)
          if (typeof xCategories[i].fieldValues[j] !== 'undefined')
            if (j === 0) {
              if (nextBlocked === 0) {
                jQuery('<th/>', {
                  rowspan: xLastRowSpan,
                  scope: 'col',
                  role: 'columnheader',
                  colspan: xTopmostUniqueCategories[xCategories[i].fieldValues[j][xCategorySortKey]].count
                }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
                nextBlocked = xTopmostUniqueCategories[xCategories[i].fieldValues[j][xCategorySortKey]].count - 1;
              } else
                nextBlocked--;
            } else if (j === xLevel - 2)
          jQuery('<th/>', {
            class: 'x-axis-category-field',
            scope: 'col',
            role: 'columnheader'
          }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
        else
          jQuery('<th/>', {
            rowspan: 2,
            class: 'x-axis-category-field',
            scope: 'col',
            role: 'columnheader'
          }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
        else
          headerRows[0].find('th:nth-child(' + chartHelpers.objectSize(xTopmostUniqueCategories) + ')').attr('rowspan', xLevel + 1);
      } else {
        var grantTotalQueryParts = !response.sysparm_show_other && response.otherQuery ? [response.otherQuery, response.filter] : [response.filter];
        $content = self.generateCell(response.aggregate.grandAggregate, grantTotalQueryParts, response.aggregate.tooltipText);
        jQuery('<td class="grand"/>').appendTo($row).html($content);
        $row.prepend('<td colspan="' + (yLevel + 1) + '" class="header-left">' + response.aggregate.functionLabel + '</td>');
        headerRows[0].append('<th class="aggregate-right" scope="col" role="columnheader" rowspan="' + (xLevel + 1) + '"> ' + response.aggregate.functionLabel + ' </th>');
      }
    for (i = 0; i < xLevel; i++) {
      for (k = yLevel - 1; k >= 0; k--)
        if (i === xLevel - 1) {
          jQuery('<th/>', {
            class: 'y-axis-category header-left'
          }).prependTo($yLabelsRow).text(yCategories[0].fieldValues[k].field);
          headerRows[i + 1] = $yLabelsRow;
        }
      jQuery('<th/>', {
        class: 'x-axis-category'
      }).prependTo(headerRows[i]).text(xCategories[0].fieldValues[i].field);
      if (i === 0) {
        var aggregateFieldDisplayValue = '';
        var pointerButton = '';
        if (response.aggregate.aggregateFieldDisplayValue)
          aggregateFieldDisplayValue = response.aggregate.aggregateFieldDisplayValue;
        if (subtotals)
          pointerButton = '<a href="#" class="collapse-all ' + (self.pivotExpanded ? 'expanded' : '') + '"/>';
        headerRows[0].prepend('<th class="top-left-hole" colspan="' + yLevel + '" rowspan="' + xLevel + '">' + pointerButton + aggregateFieldDisplayValue + '</th>');
      }
      if (i === xLevel - 1)
        $yLabelsRow.append('<th/>');
    }
    $table.append($row);
    for (j = xLevel; j >= 0; j--)
      $table.prepend(headerRows[j]);
    if (subtotals)
      self.generateSubtotals($table, subtotals, yLevel, xCategories, aggregateFunction);
    $container.empty().html('<div class="pivot-wrap"/>').find('.pivot-wrap').append($table);
    if (config.show_chart_title === 'never' || (!config.title && !config.chart_title) || (config.show_chart_title === 'report' && !self.isBuilder))
      showTitle = false;
    if (showTitle) {
      if (config.chart_title)
        config.title = config.chart_title;
      titleProps = {
        title: config.title,
        chart_title_size: config.chart_title_size,
        chart_title_x_position: config.chart_title_x_position,
        chart_title_y_position: config.chart_title_y_position,
        title_horizontal_alignment: config.title_horizontal_alignment,
        title_vertical_alignment: config.title_vertical_alignment
      };
      if (response.chart_title_color)
        titleProps.chart_title_color = response.chart_title_color;
      self.generateTitle(titleProps);
    }
    var isServicePortal = jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
    var tip = $container.find('td a');
    if (tip.tooltip && !isServicePortal)
      tip.attr('data-placement', 'bottom').attr('data-container', 'body').tooltip().hideFix();
    if (!self.displayRowLines)
      jQuery('#pivot_table td').addClass('pivot-2-td-border-top-none');
    if (self.displayColumnLines)
      jQuery('#pivot_table td').addClass('pivot-2-td-border-left');
  };
  this.generateTitle = function generateTitle(titleProps) {
    var defaultFontSize = 14;
    var titleSelector = 'pivot_title';
    var $container = jQuery('#' + this.containerId).find('.pivot-wrap');
    var $titleEl = jQuery('<div class="' + titleSelector + '"/>').text(titleProps.title);
    if (titleProps.chart_title_color)
      $titleEl.css('color', titleProps.chart_title_color);
    if (titleProps.chart_title_size)
      $titleEl.css('font-size', titleProps.chart_title_size + 'px');
    if (titleProps.title_horizontal_alignment)
      $titleEl.css('text-align', titleProps.title_horizontal_alignment);
    if (!titleProps.custom_chart_title_position)
      switch (titleProps.title_vertical_alignment) {
        case 'top':
          $container.prepend($titleEl);
          break;
        case 'middle':
          $titleEl.css({
            position: 'absolute',
            width: '100%',
            top: '50%',
            'margin-top': -(titleProps.chart_title_size / 2) || -(defaultFontSize / 2)
          });
          $container.prepend($titleEl);
          break;
        case 'bottom':
          $container.append($titleEl);
          break;
      }
    else {
      $titleEl.css({
        position: 'absolute',
        top: titleProps.chart_title_y_position,
        left: titleProps.chart_title_x_position
      });
      $container.css({
        paddingTop: (titleProps.chart_title_size + 20) || (20 + defaultFontSize)
      });
      $container.prepend($titleEl);
    }
  };
  this.generateCell = function generateCell(displayValue, cellQueryParts, message, aggregateFunction) {
    var cellQuery = this.combineQueries(cellQueryParts);
    var encodedCellQuery = encodeURIComponent(cellQuery);
    var $content = jQuery('').html('&nbsp;');
    var hrefVal = '';
    if (displayValue)
      hrefVal = getListURL(self.table, cellQuery, self.listUiViewName);
    if (aggregateFunction) {
      if (displayValue && (displayValue !== '0' || (displayValue === '0' &&
          (self.showZero === 'true' || self.showZero === true || aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))))
        if (cellQuery)
          $content = jQuery('<a/>', {
            href: hrefVal,
            rel: encodedCellQuery,
            class: 'datapoint',
            title: message
          }).text(displayValue);
        else
          $content = jQuery('<span title="' + message + '"/>').text(displayValue);
    } else
    if (displayValue)
      $content = jQuery('<a/>', {
        href: hrefVal,
        rel: encodedCellQuery,
        class: 'datapoint',
        title: message
      }).text(displayValue);
    return $content;
  };
  this.generateSubtotals = function generateSubtotals($table, subtotals, yLevel, xCategories, aggregateFunction) {
    $table.find('.below-subtotals').before('<tr role="row" class="subtotals ' + (self.pivotExpanded ? 'expanded' : '') + '"/>');
    $table.find('.subtotals').each(function eachCb(key) {
      var $currRow = jQuery(this);
      var totalCols = yLevel + xCategories.length + 1;
      var subtotalsData = subtotals.series.data;
      var subtotalsAgg = subtotals.yAxisCategories;
      for (var i = 0; i < totalCols; i++)
        if (i === 0) {
          var rowSpan;
          if (self.pivotExpanded) {
            rowSpan = leftMostRowSpan[key] + 1;
            $currRow.addClass('expanded');
          } else
            rowSpan = 1;
          $currRow.append('<td class="leftmost-cell" rowspan="' + rowSpan + '" scope="row" role="rowheader" data-mergerows="' + (leftMostRowSpan[key] + 1) + '"><a href="#" class="subcollapse"/>' + leftMostRowValue[key] + '</td>');
        } else if (i === 1)
        $currRow.append('<td class="subtotals-empty">' + chartHelpers.i18n.total + '</td> <td class="subtotals-empty"/>');
      else if (i > 1 && i < yLevel)
        $currRow.append('<td class="subtotals-empty"/>');
      else if (i === totalCols - 1)
        jQuery('<td class="aggregate-right"/>').appendTo($currRow).html(self.generateCell(subtotalsAgg[key].aggregatedValue, [subtotalsAgg[key].categoryQuery, subtotals.filter], subtotalsAgg[key].tooltipText));
      else {
        var currSubtotal = (xCategories.length * key) + (i - yLevel);
        var cellQueryParts = [];
        if (subtotalsData[currSubtotal][0] || (subtotalsData[currSubtotal][0] === 0 && (aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))) {
          var xCategoryQuery = subtotals.otherQuery && !xCategories[i - yLevel].categoryQuery ? subtotals.otherQuery : xCategories[i - yLevel].categoryQuery;
          cellQueryParts = [xCategoryQuery, subtotalsAgg[key].categoryQuery, subtotals.filter];
        }
        jQuery('<td/>').appendTo($currRow).html(self.generateCell(subtotalsData[currSubtotal][1], cellQueryParts, subtotalsData[currSubtotal][2], aggregateFunction));
      }
    });
  };
  this.fixateHeader = function fixateHeader() {
    var $scrollContainer;
    var $table = self.$table;
    var tableOffset = $table.position().top;
    var offsetDiff = 0;
    var offsetFetched = false;
    var $fixedHeader = jQuery('<table class="fixed-header pivot-2-levels table"/>').insertBefore($table).html(self.getSizedHeaders(true));
    if (self.isDesigner) {
      $scrollContainer = jQuery('#main-content');
      tableOffset = $table.offset().top - $scrollContainer.offset().top;
      offsetDiff = tableOffset - $table.position().top;
    } else if (self.isOldBuilder)
      $scrollContainer = jQuery(document);
    else if (self.isCanvas)
      $scrollContainer = jQuery('#' + this.containerId).closest('.grid-widget-content');
    else
      $scrollContainer = jQuery('#' + this.containerId).closest('.widget_body');
    $scrollContainer.scroll(function scrollCb() {
      if (!offsetFetched && self.isOldBuilder) {
        tableOffset = $table.offset().top;
        offsetDiff = tableOffset - $table.position().top;
        offsetFetched = true;
      }
      var offset = jQuery(this).scrollTop() - offsetDiff;
      if (self.isDesigner)
        offset -= jQuery('#condition-builder-wrap form').height();
      if (offset >= tableOffset - offsetDiff)
        $fixedHeader.css({
          top: offset,
          display: 'table'
        });
      else if (offset < tableOffset - offsetDiff)
        $fixedHeader.hide();
    });
  };
  this.getSizedHeaders = function getSizedHeaders(createHeader) {
    var $headerRows = self.$table.find('.header-row');
    var $clonedHeaderRows = createHeader ? $headerRows.clone() : jQuery('#' + self.containerId).find('.fixed-header .header-row');
    $headerRows.each(function eachRowCb(i) {
      var $children = $headerRows.eq(i).children();
      var $clonedChildren = $clonedHeaderRows.eq(i).children();
      $children.each(function eachChildCb(j) {
        $clonedChildren.eq(j).css('min-width', $children.eq(j).outerWidth());
      });
    });
    return $clonedHeaderRows;
  };
  this.buildRequestParams = function buildRequestParams(params) {
    return {
      sysparm_table: params.table,
      sysparm_x_axis_category_fields: params.x_axis_category_fields != null ? params.x_axis_category_fields.trim().split(/[\s,]+/) : '',
      sysparm_y_axis_category_fields: params.y_axis_category_fields != null ? params.y_axis_category_fields.trim().split(/[\s,]+/) : '',
      sysparm_aggregate: params.aggregate,
      sysparm_show_other: params.show_other,
      sysparm_others: params.other_threshold,
      sysparm_chart_title_color: params.chart_title_color,
      sysparm_sumfield: params.agg_field,
      sysparm_query: params.filter,
      sysparm_report_id: params.report_id,
      sysparm_list_ui_view: params.list_ui_view,
      sysparm_interactive_report: params.interactive_report,
      sysparm_report_drilldown: params.report_drilldown,
      sysparm_homepage_sysid: params.homepage_sysid,
      sysparm_decimal_precision: params.decimal_precision,
      sysparm_report_source_id: params.report_source_id,
      sysparm_is_report_source_filter_already_combined: params.is_report_source_filter_already_combined,
      sysparm_is_published: params.is_published,
      sysparm_not_save_statistics: params.not_save_statistics,
      sysparm_set_redirect: params.set_redirect
    };
  };
  this.eventHandlers = function eventHandlers() {
    var $container = jQuery('#' + self.containerId);
    $container.on('click', '.subtotals .subcollapse', function subcollapseClickCb(ev) {
      ev.preventDefault();
      var $parentRow = jQuery(this).closest('.subtotals');
      var $parentCell = jQuery(this).closest('td');
      var $subRows = $parentRow.nextUntil('.subtotals,.totals');
      if ($parentCell.attr('rowspan') > 1) {
        $parentCell.attr('rowspan', 1);
        $parentRow.removeClass('expanded');
        $subRows.hide();
      } else {
        $parentCell.attr('rowspan', $parentCell.data('mergerows'));
        $parentRow.addClass('expanded');
        $subRows.show();
      }
      if (self.fixedHeaders)
        self.getSizedHeaders(false);
    });
    $container.on('click', '.collapse-all', function collapseCb(ev) {
      ev.preventDefault();
      var $contentRows = $container.find('.content-row');
      var $el = jQuery(this);
      if ($el.is('.expanded')) {
        $container.find('.subtotals.expanded').each(function eachCb() {
          jQuery(this).removeClass('expanded');
          jQuery(this).find('.leftmost-cell').attr('rowspan', 1);
        });
        $el.closest('.pivot-wrap').find('.collapse-all').removeClass('expanded');
        $contentRows.hide();
      } else {
        $container.find('.subtotals:not(.expanded)').each(function eachCb() {
          jQuery(this).addClass('expanded');
          var $cell = jQuery(this).find('.leftmost-cell');
          $cell.attr('rowspan', $cell.data('mergerows'));
        });
        $el.closest('.pivot-wrap').find('.collapse-all').addClass('expanded');
        $contentRows.show();
      }
      if (self.fixedHeaders)
        self.getSizedHeaders(false);
    });
    $container.on('click', '.datapoint', function dataPointClickCb(ev) {
      ev.preventDefault();
      var openNewTab;
      if (ev.ctrlKey || ev.metaKey)
        openNewTab = true;
      if (self.widgetNav)
        window.open(self.widgetNav.value, openNewTab ? '_blank' : '_self');
      else {
        generateDataPointClickUrl(ev, '#' + self.containerId, self.reportDrilldown, self.table, decodeURIComponent(jQuery(this).attr('rel')), self.listUIViewName, self.drillOpenNewWin);
      }
    });
  };
  this.combineQueries = function combineQueries(queryParts) {
    if (typeof queryParts === 'string')
      return queryParts;
    queryParts = queryParts.filter(function filterCb(el) {
      return el;
    });
    if (!queryParts.length)
      return '';
    return queryParts.reduce(function reduceCb(acc, curr) {
      var accParts = acc.split('^NQ');
      var currParts = curr.split('^NQ');
      var finalParts = [];
      for (var i = 0; i < accParts.length; i++)
        for (var j = 0; j < currParts.length; j++)
          finalParts[(i * currParts.length) + j] = accParts[i] + '^' + currParts[j];
      return finalParts.join('^NQ');
    });
  };
  this.init();
};;
/*! RESOURCE: /scripts/reportcommon/customvisuals/single-score.js */
function SingleScore(reportUUID, runType, config) {
  'use strict';
  var self = this;
  if (!config) {
    config = window.g_report_params[reportUUID];
    config.is_report_source_filter_already_combined = true;
  }
  createReportTemplate(reportUUID, config);
  this.containerId = 'chart-container-' + reportUUID;
  this.msgContainerId = 'msg-container-' + reportUUID;
  this.$container = jQuery('#' + this.containerId);
  this.$wrap = this.$container;
  this.config = config;
  this.title = config.title;
  this.is_portal = config.is_portal;
  this.isServicePortal = jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
  this.reportId = config.report_id;
  this.table = config.table;
  this.condition = config.filter;
  this.minMargin = 5;
  this.maxFontSize = 200;
  this.minWrapHeight = 64;
  this.listUIViewName = '';
  this.relativeFontSize = 0.7;
  this.real_time = config.real_time;
  if (top.g_ambClient || (top.amb && top.amb.getClient()))
    this.amb = top.g_ambClient || top.amb.getClient();
  this._channelListener = null;
  this.$el = jQuery('<span/>');
  this.rootReportElementClass = '.sysparm_root_report_id';
  this.defaults = {
    value: '0',
    chart_background_color: '#fff',
    displayvalue: 'No value',
    color: '#000',
    displayValueChars: 0
  };
  this.isBuilder = (reportUUID === 'builder');
  (function fetchData() {
    self.unsubscribeListener(self);
    var processor = (runType === 'run') ? 'SingleScoreRunProcessor' : 'SingleScoreRunPublishedProcessor';
    jQuery.ajax({
      method: 'POST',
      url: '/xmlhttp.do',
      dataType: 'xml',
      headers: {
        'X-UserToken': window.g_ck
      },
      data: {
        sysparm_processor: processor,
        sysparm_scope: 'global',
        is_portal: self.is_portal,
        sysparm_timer: new Date().getTime(),
        sysparm_request_params: JSON.stringify(self.buildRequestParams(config))
      }
    }).done(function doneCb(xml) {
      self.render(xml);
    }).fail(function failCb(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
    self.eventHandlers();
  }());
}
SingleScore.prototype.unsubscribeListener = function unsubscribeListener() {
  var self = this;
  if (top.SNC && top.SNC.channelListeners) {
    self._channelListener = top.SNC.channelListeners[self.reportId];
    if (self._channelListener) {
      self._channelListener.unsubscribe();
      delete top.SNC.channelListeners[self.reportId];
    }
  }
};
SingleScore.prototype.shouldShowTitle = function shouldShowTitle() {
  if (this.config.show_chart_title === 'never' || (!this.config.title && !this.config.chart_title) || (this.config.show_chart_title === 'report' && this.isBuilder === false))
    return false;
  return true;
};
SingleScore.prototype.render = function render(response) {
  var self = this;
  var config = self.config;
  var responseData;
  if (!response) {
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
    showError(self.containerId, 'No response from the server');
    return;
  }
  var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
  if (resp.STATUS === 'SUCCESS') {
    try {
      var contentEl;
      var respData = JSON.parse(resp.RESPONSE_DATA);
      var hrefVal;
      var titleProps;
      if (self.isBuilder && respData.drill_message)
        showInfo(self.msgContainerId, respData.drill_message);
      this.reportDrilldown = respData.report_drilldown;
      if (respData.widget_navigation && respData.widget_navigation.length)
        this.widgetNav = respData.widget_navigation[0];
      self.listUIViewName = respData.list_ui_view_name;
      self.drillOpenNewWin = respData.drill_open_new_win;
      responseData = jQuery.extend({}, self.defaults, respData);
      var evaluatedColor = self.evaluateColor(responseData.value, responseData.rules, responseData.color);
      hrefVal = getListURL(self.table, responseData.filter);
      var encodedClickUrlInfo = encodeURIComponent(responseData.filter);
      contentEl = '<a id="' + self.reportId + '" style="color:' + evaluatedColor + '" href="' + hrefVal + '" rel="' + encodedClickUrlInfo + '">' + responseData.displayvalue + '</a>';
      self.$container.html('<div class="single-score" aria-live="polite"/>').find('.single-score').html(self.$el.html(contentEl));
      if (!window.isMSIE9) {
        jQuery(window).on('beforeunload', self.unsubscribeListener.bind(self));
        self.registerWatcher(responseData);
      }
      if (responseData.tooltip) {
        self.$el.attr('title', responseData.tooltip);
        if (!self.isServicePortal && self.$el.tooltip)
          self.$el.attr('data-container', 'body').attr('data-placement', 'bottom').tooltip().hideFix();
      }
      if (!(window.SNC && window.SNC.canvas && window.SNC.canvas.layoutJson && window.SNC.canvas.layoutJson.isConverting))
        self.updateSize();
      if (self.shouldShowTitle()) {
        if (config.chart_title)
          config.title = config.chart_title;
        titleProps = {
          title: config.title,
          chart_title_size: config.chart_title_size,
          chart_title_x_position: config.chart_title_x_position,
          chart_title_y_position: config.chart_title_y_position,
          title_horizontal_alignment: config.title_horizontal_alignment,
          title_vertical_alignment: config.title_vertical_alignment
        };
        if (responseData.chart_title_color)
          titleProps.chart_title_color = responseData.chart_title_color;
        self.generateTitle(titleProps);
        self.updateSize();
      }
    } catch (error) {
      console.log(error);
      showError(self.containerId, 'An error occured while generating chart.');
    }
  } else
    self.showMessage(resp.RESPONSE_DATA, resp.STATUS);
  hideReportIsLoading(findGridWindowFromElementID(self.containerId));
};
SingleScore.prototype.evaluateColor = function evaluateColor(score, rules, defaultColor) {
  if (rules) {
    var colorStyle = chartHelpers.evaluateColorRules(score, rules);
    if (colorStyle.color)
      return colorStyle.color;
  }
  return defaultColor;
};
SingleScore.prototype.base64Encode = function base64Encode(queryString) {
  try {
    return btoa(queryString);
  } catch (error) {
    if (window.DOMException && error instanceof window.DOMException && error.name === 'InvalidCharacterError')
      return btoa(chartHelpers.hexEncode(queryString));
    throw error;
  }
}
SingleScore.prototype.registerWatcher = function registerWatcher(singleScoreResponse) {
  var self = this;
  if (self.is_portal && top.SNC && top.SNC.channelListeners) {
    try {
      var base64EncodeQuery = self.base64Encode(self.condition);
      var channelId = '/rw/count/' + self.table + '/' + base64EncodeQuery.replace(/=/g, '-');
      self._channelListener = top.SNC.channelListeners[self.reportId];
      if (self._channelListener) {
        self._channelListener.unsubscribe();
        delete top.SNC.channelListeners[self.reportId];
      }
      if (self.real_time === 'true' && self.amb && self.amb.getChannel(channelId)) {
        self._channelListener = self.amb.getChannel(channelId);
        self._channelListener.subscribe(function subscribeCb(channelData) {
          self.updateScore(channelData, singleScoreResponse);
        });
        top.SNC.channelListeners[self.reportId] = self._channelListener;
      }
    } catch (error) {}
  }
};
SingleScore.prototype.updateSize = function updateSize() {
  var self = this;
  var wrapHeight;
  var wrapWidth;
  var $widgetBody;
  var fontSize = self.maxFontSize;
  var $widgetContent;
  var titleHeight = 0;
  var isCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  self.$container.css({
    margin: '0'
  });
  if (!self.is_portal) {
    if (self.$wrap.closest('td').length)
      $widgetBody = self.$wrap.closest('td');
    else
      $widgetBody = jQuery('body');
    self.$container.css({
      padding: '10px 0'
    });
    wrapHeight = 100;
    wrapWidth = $widgetBody.width() || 100;
  } else if (isCanvas && self.containerId.indexOf('preview') === -1) {
    $widgetContent = self.$container.closest('.grid-widget-content');
    wrapHeight = $widgetContent.height();
    wrapWidth = $widgetContent.width() - (this.minMargin * 2);
    titleHeight = $widgetContent.find('.singlescore_title').height() || 0;
  } else if (isCanvas && self.containerId.indexOf('preview') >= -1) {
    $widgetContent = self.$container.closest('.widget-preview');
    wrapHeight = $widgetContent.height();
    wrapWidth = $widgetContent.width();
    titleHeight = $widgetContent.find('.singlescore_title').height() || 0;
  } else {
    $widgetBody = self.$wrap.closest('.widget_body');
    if (jQuery('.home_preview ' + self.$containerId).length) {
      self.$container = jQuery('.home_preview #' + self.containerId);
      self.$wrap = self.$container.closest('.single-score-wrap');
      $widgetBody = jQuery('.home_preview');
    }
    wrapHeight = $widgetBody.height();
    wrapWidth = $widgetBody.width() - (this.minMargin * 2);
    if (wrapWidth < 0)
      wrapWidth = 150;
    if (wrapHeight < self.minWrapHeight)
      wrapHeight = self.minWrapHeight;
  }
  wrapHeight -= titleHeight;
  self.$el.css({
    'font-size': fontSize
  });
  while (self.$container.find('span').width() > wrapWidth && fontSize > 15) {
    fontSize -= 5;
    self.$el.css('font-size', fontSize);
  }
  fontSize = self.checkHeight(fontSize, wrapHeight);
  self.$el.css('font-size', fontSize);
  if (!isCanvas) {
    self.$container.css('margin-top', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10) - this.minMargin));
    self.$container.css('margin-bottom', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10) - this.minMargin));
  } else {
    self.$container.css('margin-top', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10)));
    self.$container.css('margin-bottom', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10)));
  }
  self.$container.css({
    'margin-left': this.minMargin + 'px',
    'margin-right': this.minMargin + 'px',
  });
};
SingleScore.prototype.updateScore = function updateScore(channelData, singleScoreResponse) {
  var self = this;
  try {
    var $element = jQuery('#' + self.reportId);
    var $parent = $element.closest('span');
    var score = singleScoreResponse.value * 1;
    if (typeof channelData.data.count !== 'undefined' && typeof score === 'number') {
      score += (channelData.data.count * 1);
      if (score < 0)
        score = 0;
      var localizedScore = score.toLocaleString();
      if (window.isMSIE10)
        localizedScore = localizedScore.substring(0, localizedScore.indexOf('.'));
      if ($parent.attr('data-original-title'))
        $parent.attr('data-original-title', $parent.attr('data-original-title').replace(singleScoreResponse.displayvalue, localizedScore));
      $element.text(localizedScore);
      $element.css('color', self.evaluateColor(score, singleScoreResponse.rules, singleScoreResponse.color));
      if (singleScoreResponse.displayValueChars !== singleScoreResponse.displayvalue.length) {
        self.updateSize();
        singleScoreResponse.displayValueChars = singleScoreResponse.displayvalue.length;
      }
      singleScoreResponse.value = score;
      singleScoreResponse.displayvalue = localizedScore;
    }
  } catch (error) {
    console.log(error);
    showError(SingleScore.containerId, 'An error occured while generating chart.');
  }
};
SingleScore.prototype.generateTitle = function generateTitle(titleProps) {
  var defaultFontSize = 14;
  var $container = jQuery('#' + this.containerId).find('.single-score');
  var $titleEl = jQuery('<div class="singlescore_title"/>')
    .text(titleProps.title)
    .attr('title', titleProps.title);
  if ($titleEl.tooltip && !this.isServicePortal)
    $titleEl
    .attr('data-container', 'body')
    .attr('data-placement', 'top')
    .tooltip()
    .hideFix();
  if (titleProps.chart_title_color)
    $titleEl.css('color', titleProps.chart_title_color);
  if (titleProps.chart_title_size)
    $titleEl.css('font-size', titleProps.chart_title_size + 'px');
  if (titleProps.title_horizontal_alignment)
    $titleEl.css('text-align', titleProps.title_horizontal_alignment);
  if (!titleProps.custom_chart_title_position)
    switch (titleProps.title_vertical_alignment) {
      case 'top':
        $container.prepend($titleEl);
        break;
      case 'middle':
        $titleEl.css({
          position: 'absolute',
          width: '100%',
          top: '50%',
          'margin-top': -(titleProps.chart_title_size / 2) || -(defaultFontSize / 2)
        });
        $container.prepend($titleEl);
        break;
      case 'bottom':
        $container.append($titleEl);
        break;
    }
  else {
    $titleEl.css({
      position: 'absolute',
      top: titleProps.chart_title_y_position,
      left: titleProps.chart_title_x_position
    });
    $container.css({
      paddingTop: (titleProps.chart_title_size + 20) || (20 + defaultFontSize)
    });
    $container.prepend($titleEl);
  }
};
SingleScore.prototype.getMinMargin = function getMinMargin(val) {
  return (val < this.minMargin) ? this.minMargin : val;
};
SingleScore.prototype.checkHeight = function checkHeight(fontSize, height) {
  return ((fontSize + (2 * this.minMargin)) > height) ? parseInt(this.relativeFontSize * height, 10) : fontSize;
};
SingleScore.prototype.buildRequestParams = function buildRequestParams(params) {
  return {
    sysparm_table: params.table,
    sysparm_aggregate: params.aggregate,
    sysparm_sumfield: params.agg_field,
    sysparm_query: params.filter,
    sysparm_interactive_report: params.interactive_report,
    sysparm_report_drilldown: params.report_drilldown,
    sysparm_report_id: params.report_id,
    sysparm_score_color: params.score_color,
    sysparm_chart_title_color: params.chart_title_color,
    sysparm_homepage_sysid: params.homepage_sysid,
    sysparm_chart_background_color: params.chart_background_color,
    sysparm_list_ui_view: params.list_ui_view,
    sysparm_decimal_precision: params.decimal_precision,
    sysparm_report_source_id: params.report_source_id,
    sysparm_is_report_source_filter_already_combined: params.is_report_source_filter_already_combined,
    sysparm_show_zero: params.show_zero,
    sysparm_is_published: params.is_published,
    sysparm_set_redirect: params.set_redirect
  };
};
SingleScore.prototype.showMessage = function showMessage(msg, level) {
  var self = this;
  if (level === 'FAILURE')
    jQuery('#' + self.containerId).html('<div class="single-score-error">ERROR: ' + msg + '</div>');
  else
    jQuery('#' + self.containerId).html('<div>' + msg + '</div>');
};
SingleScore.prototype.resizeHandlers = function resizeHandlers(data) {
  if (data.action === 'resize')
    this.updateSize();
};
SingleScore.prototype.eventHandlers = function eventHandlers() {
  var self = this;
  this.$container.on('click', 'a', function clickCb(ev) {
    ev.preventDefault();
    var openNewTab;
    if (ev.ctrlKey || ev.metaKey)
      openNewTab = true;
    if (self.widgetNav)
      window.open(self.widgetNav.value, openNewTab ? '_blank' : '_self');
    else {
      var drillDownUrl = jQuery(this).attr('rel');
      drillDownUrl = decodeURIComponent(drillDownUrl);
      generateDataPointClickUrl(ev, '#' + self.containerId, self.reportDrilldown, self.table, drillDownUrl, self.listUIViewName, self.drillOpenNewWin);
    }
  });
  if (jQuery && window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && self.containerId.indexOf('preview') === -1) {
    var rootReportId = self.$container.closest('.grid-stack-item').find(self.rootReportElementClass).first().val();
    var uuid = self.$container.closest('.grid-stack-item').attr('data-uuid');
    if (uuid) {
      window.SNC.reportResizingFunctions = window.SNC.reportResizingFunctions || {};
      SNC.canvas.eventbus.subscribe(uuid, this.resizeHandlers.bind(this));
      SNC.reportResizingFunctions[uuid] = this.resizeHandlers;
    }
    window.SNC.reportResizingTimeouts = window.SNC.reportResizingTimeouts || {};
    window.addEventListener('resize', function resizeCb() {
      if (SNC.reportResizingTimeouts[rootReportId])
        clearTimeout(SNC.reportResizingTimeouts[rootReportId]);
      SNC.reportResizingTimeouts[rootReportId] = setTimeout(function resizingTimeoutCb() {
        self.updateSize();
      }, 250);
    }, false);
  }
};;
/*! RESOURCE: /scripts/reportcommon/customvisuals/calendar.js */
var Calendar = function Calendar(reportUUID, runType, reportParams) {
  'use strict';
  var Moment = moment;
  if (!reportParams) {
    reportParams = window.g_report_params[reportUUID];
    reportParams.is_report_source_filter_already_combined = true;
  }
  createReportTemplate(reportUUID, reportParams);
  this.combinedFilter = reportParams.filter;
  this.containerId = 'chart-container-' + reportUUID;
  this.startTime = new Date().getTime();
  var self = this;

  function showMessage(msg, level) {
    if (level === 'FAILURE')
      jQuery('#' + self.containerId).siblings('.report-message').addClass('pivot-error').text(msg);
    else
      jQuery('#' + self.containerId).siblings('.report-message').text(msg);
  }
  this.init = function init() {
    showReportIsLoading(findGridWindowFromElementID(self.containerId));
    self.runCalendar(reportParams, runType);
  };
  this.runCalendar = function runCalendar() {
    self.reportId = reportParams.report_id || 'calendar';
    window.calendarReport = window.calendarReport || {};
    window.calendarReport[self.reportId] = window.calendarReport[self.reportId] || {};
    reportParams.styleField = reportParams.styleField || window.calendarReport[self.reportId].highlight || reportParams.calstyle;
    var defaultDateOverride = null;
    if (reportParams.year || reportParams.month || reportParams.day)
      defaultDateOverride = moment({
        year: reportParams.year,
        month: reportParams.month,
        day: reportParams.day
      }).format('YYYY-MM-DD');
    if (reportParams.calview === 'week')
      reportParams.calview = 'agendaWeek';
    else if (reportParams.calview === 'day')
      reportParams.calview = 'agendaDay';
    var calWidth = jQuery('#' + self.containerId).width();
    var yearCols = 2;
    if (calWidth < 640)
      yearCols = 1;
    else if (calWidth > 1280)
      yearCols = 3;
    jQuery('#' + self.containerId).empty().fullCalendar('destroy');
    jQuery('#' + self.containerId).fullCalendar({
      theme: false,
      buttonText: chartHelpers.i18n.buttonText,
      dayNames: chartHelpers.i18n.daysNames,
      dayNamesShort: chartHelpers.i18n.dayNamesShort,
      monthNames: chartHelpers.i18n.monthNames,
      monthNamesShort: chartHelpers.i18n.monthNamesShort,
      allDayHtml: chartHelpers.i18n.allDayHtml,
      weekNumberTitle: chartHelpers.i18n.weekNumberTitleShort,
      weekNumberCalculation: window.chartHelpers.systemParams.firstDay === 0 ? 'local' : 'ISO',
      isRTL: chartHelpers.i18n.isRTL,
      buttonIcons: {
        prev: 'left-single-arrow',
        next: 'right-single-arrow',
        prevYear: 'left-double-arrow',
        nextYear: 'right-double-arrow'
      },
      fixedWeekCount: true,
      timeFormat: 'H:mm',
      slotLabelFormat: 'H:mm',
      axisFormat: 'H:mm',
      firstDay: window.chartHelpers.systemParams.firstDay,
      defaultDate: window.calendarReport[self.reportId].start || defaultDateOverride || window.chartHelpers.systemParams.defaultDate,
      defaultView: window.calendarReport[self.reportId].view || reportParams.calview || 'month',
      defaultTimedEventDuration: window.chartHelpers.systemParams.defaultEventDuration,
      yearColumns: yearCols,
      slotEventOverlap: window.chartHelpers.systemParams.slotEventOverlap ? true : false,
      lazyFetching: false,
      height: 'auto',
      contentHeight: 'auto',
      eventLimit: parseInt(window.chartHelpers.systemParams.maxEventsDisplayedPerCell, 10) + 1,
      nextDayThreshold: '00:00:00',
      eventLimitText: function eventLimitText(amountOfEvents) {
        if (amountOfEvents <= parseInt(window.chartHelpers.systemParams.maxMoreEventsPerDay, 10))
          return chartHelpers.i18n.plusMore.format(amountOfEvents);
        return chartHelpers.i18n.plusMany;
      },
      eventLimitClick: function eventLimitClick(cellInfo, jsEvent) {
        setTimeout(function timeoutCb() {
          jQuery('#' + self.containerId).find('.fc-close').attr('tabindex', 0);
        }, 500);
        if (cellInfo.date && cellInfo.hiddenSegs && cellInfo.hiddenSegs.length > parseInt(window.chartHelpers.systemParams.maxMoreEventsPerDay, 10)) {
          var selectedDate = moment(cellInfo.date).format('YYYY-MM-DD');
          self.drillViewToList({
            data: {
              startDate: selectedDate,
              endDate: selectedDate
            }
          });
          return false;
        }
        return 'popover';
      },
      views: {
        month: {
          weekNumbers: true
        },
        year: {
          weekNumbers: true
        }
      },
      header: {
        left: 'agendaDay,agendaWeek,month,year',
        center: 'title',
        right: 'today prevYear,prev,next,nextYear'
      },
      eventDataTransform: function(event) {
        var view = jQuery('#' + self.containerId).fullCalendar('getView');
        if (view.name === 'agendaDay') {
          if (event.start && event.end) {
            var viewStartMoment = new Moment(view.intervalStart.toISOString());
            var viewEndMoment = new Moment(view.intervalEnd.toISOString());
            if ((viewStartMoment.isSame(event.start) || viewStartMoment.isAfter(event.start)) &&
              (viewEndMoment.isBefore(event.end) || viewEndMoment.isSame(event.end)))
              event.allDay = true;
          }
        } else if (view.name === 'agendaWeek')
          if (event.start && event.end) {
            var eventStartMoment = new Moment(event.start);
            var eventEndMoment = new Moment(event.end);
            var hoursDiff = eventEndMoment.diff(eventStartMoment, 'hours');
            var startOfDayOfEventStartMoment = new Moment(event.start).startOf('day');
            if (hoursDiff >= 24 &&
              ((startOfDayOfEventStartMoment).isSame(eventStartMoment) ||
                eventEndMoment.diff(startOfDayOfEventStartMoment, 'day') >= 2))
              event.allDay = true;
          }
        return event;
      },
      eventMouseover: function eventMouseover(event, jsEvent, view) {
        if (window.chartHelpers.systemParams.enablePreviewOnHover && window.chartHelpers.systemParams.enablePreviewOnHover !== 'false')
          popRecordDiv(jsEvent, reportParams.table, event.id);
      },
      eventMouseout: function eventMouseout(event, jsEvent, view) {
        if (window.chartHelpers.systemParams.enablePreviewOnHover && window.chartHelpers.systemParams.enablePreviewOnHover !== 'false')
          lockPopup(jsEvent);
      },
      viewRender: function viewRender(view, element) {
        jQuery('#' + self.containerId).siblings('.report-message').text(chartHelpers.i18n.building);
      },
      eventAfterAllRender: function eventAfterAllRender(view) {
        var start = new Moment(view.intervalStart.toISOString());
        if (start.isValid())
          window.calendarReport[self.reportId] = {
            view: view.name,
            start: start.format('YYYY-MM-DD'),
            highlight: reportParams.styleField
          };
        var viewStart = new Moment(view.start.toISOString());
        if (viewStart.isValid()) {
          var dateAfterLastDateInView = new Moment(view.end.toISOString());
          var viewEnd = dateAfterLastDateInView.subtract(1, 'day');
          self.buildDrillViewToListLink(viewStart.format('YYYY-MM-DD'), viewEnd.format('YYYY-MM-DD'));
        }
        jQuery('#' + self.containerId).siblings('.report-message').empty();
        if (window.g_accessibility === 'true' || window.g_accessibility === true)
          self.enableAccessibility();
      },
      eventSources: [{
        allDayDefault: false,
        backgroundColor: 'white',
        borderColor: 'lightgrey',
        textColor: 'black',
        editable: false,
        events: function events(start, end, timezone, fullCalendarCallback) {
          var processor = runType === 'run' ? 'CalendarRunProcessor' : 'CalendarRunPublishedProcessor';
          jQuery.ajax({
            method: 'POST',
            url: '/xmlhttp.do',
            dataType: 'xml',
            headers: {
              'X-UserToken': window.g_ck
            },
            data: {
              sysparm_processor: processor,
              sysparm_scope: 'global',
              is_portal: reportParams.is_portal,
              start_date: start.format('YYYY-MM-DD').toString(),
              end_date: end.format('YYYY-MM-DD').toString(),
              style_field: reportParams.styleField,
              sysparm_timer: new Date().getTime(),
              sysparm_request_params: JSON.stringify(self.buildRequestParams(reportParams))
            }
          }).done(function doneCb(xml) {
            self.processResponse(xml, fullCalendarCallback);
          }).fail(function failCb(jqXHR, textStatus, error) {
            console.log(textStatus, error);
          });
        }
      }],
      dayClick: function dayClick(date, jsEvent, view) {
        jQuery('#' + self.containerId).fullCalendar('changeView', 'agendaDay');
        jQuery('#' + self.containerId).fullCalendar('gotoDate', date);
      }
    });
  };
  this.buildDrillViewToListLink = function buildDrillViewToListLink(startDateString, endDateString) {
    var $drillToListLink = jQuery('#' + self.containerId + ' #drillViewToList');
    if (!$drillToListLink.length) {
      $drillToListLink = jQuery('<a/>', {
        id: 'drillViewToList',
        class: 'all-records-link',
        target: '_blank'
      }).text(chartHelpers.i18n.viewAllRecords);
      jQuery('#' + self.containerId + ' .highlight-wrap').append($drillToListLink);
    }
    $drillToListLink.attr('href', self.buildDrillViewToListUrl(startDateString, endDateString));
  };
  this.buildDrillViewToListUrl = function buildDrillViewToListUrl(startDate, endDate) {
    var calField = reportParams.cal_field;
    var query = '';
    if (self.combinedFilter)
      query += self.combinedFilter + '^';
    var minutesToSubtract = moment.duration(window.chartHelpers.systemParams.defaultEventDuration, 'HH:mm:ss').asMinutes();
    query += calField + '>=javascript:gs.dateAdd(\'minute\', -' + minutesToSubtract + ', gs.dateGenerate(\'' + startDate + '\',\'start\'))^' + calField + '<=javascript:gs.dateGenerate(\'' + endDate + '\',\'end\')';
    var isStartField = calField.indexOf('_start', calField.length - '_start'.length) !== -1 || calField.indexOf('start_') === 0 || calField.indexOf('_start_') !== -1 || calField === 'start';
    if (isStartField) {
      var calEndField = calField.replace(/start/g, 'end');
      var hasEndField = true;
      if (typeof Table !== 'undefined') {
        var calendarTable = Table.get(reportParams.table);
        if (calendarTable)
          var element = calendarTable.getElement(calEndField);
        if (!element)
          hasEndField = false;
      }
      if (hasEndField) {
        var firstDateBeforeStart = new Moment(startDate).subtract(parseInt(window.chartHelpers.systemParams.maxDaysBack, 10), 'day').format('YYYY-MM-DD');
        query += '^NQ';
        if (self.combinedFilter)
          query += self.combinedFilter + '^';
        query += calField + '>=javascript:gs.dateGenerate(\'' + firstDateBeforeStart + '\',\'start\')^' +
          calField + '<=javascript:gs.dateGenerate(\'' + endDate + '\',\'end\')^' +
          calEndField + '>=javascript:gs.dateGenerate(\'' + startDate + '\',\'start\')^EQ';
      }
    }
    return reportParams.table + '_list.do?sysparm_query=' + encodeURIComponent(query);
  };
  this.drillViewToList = function drillViewToList(event) {
    var startDate = event.data.startDate;
    var endDate = event.data.endDate;
    var drillViewToListUrl = self.buildDrillViewToListUrl(startDate, endDate);
    window.open(drillViewToListUrl, '_blank');
  };
  this.processResponse = function processResponse(response, fullcalendarCallback) {
    if (!response)
      showError(self.containerId, 'No response from the server');
    else {
      var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
      if (resp.STATUS === 'SUCCESS')
        try {
          var responseData = resp.RESPONSE_DATA;
          self.combinedFilter = responseData.filterQuery;
          self.populateStyleFields(responseData.styleFields);
          fullcalendarCallback(responseData.calendarEvents);
          if (responseData.message)
            showMessage(responseData.message, 'INFO');
        } catch (err) {
          showMessage(chartHelpers.i18n.chartGenerationError, 'FAILURE');
          console.log(err);
        }
      else {
        fullcalendarCallback([]);
        showMessage(resp.RESPONSE_DATA, resp.STATUS);
      }
    }
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
    var now = new Date().getTime();
    var elapsedTime = (now - self.startTime) / 1000;
    console.log('Time taken to render report: ' + elapsedTime);
  };
  this.populateStyleFields = function populateStyleFields(styleFields, args) {
    if (jQuery('#' + self.containerId + ' .highlight-dropdown').length)
      return;
    var $highlightWrap = jQuery('#' + self.containerId).append('<div class="highlight-wrap"/>');
    if (styleFields && styleFields.length) {
      var highlightOptions;
      var selectedOption = '';
      for (var i = 0; i < styleFields.length; i++) {
        if (i === 0)
          highlightOptions += '<option value="">' + chartHelpers.i18n.none + '</option>';
        if (reportParams.styleField)
          if (styleFields[i].name === reportParams.styleField)
            highlightOptions += '<option selected="selected" value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
          else
            highlightOptions += '<option value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
        else
          highlightOptions += '<option  value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
      }
      $highlightWrap.find('.highlight-wrap')
        .append(jQuery('<label for="highlight_field" />').text(chartHelpers.i18n.highlightBasedOn)).append(jQuery('<select id="highlight_field" class="highlight-dropdown form-control"/>')
          .html(highlightOptions));
      jQuery('#' + self.containerId + ' .highlight-dropdown').on('change', function changeCb() {
        reportParams.styleField = this.value;
        jQuery('#' + self.containerId).fullCalendar('refetchEvents');
      });
    }
  };
  this.enableAccessibility = function enableAccessibility() {
    jQuery('#' + self.containerId).find('table').attr('role', 'grid').find('tr')
      .attr('role', 'row')
      .find('.fc-more')
      .attr('tabindex', 0);
    jQuery('#' + self.containerId).find('thead th').attr({
      role: 'columnheader',
      scope: 'col'
    });
    jQuery('#' + self.containerId).find('tbody td').attr({
      role: 'gridcell'
    });
  };
  this.buildRequestParams = function buildRequestParams() {
    return {
      sysparm_cal_field: reportParams.cal_field,
      sysparm_table: reportParams.table,
      sysparm_report_id: reportParams.report_id,
      sysparm_report_source_id: reportParams.report_source_id,
      sysparm_is_report_source_filter_already_combined: reportParams.is_report_source_filter_already_combined,
      sysparm_query: reportParams.filter,
      sysparm_list_ui_view: reportParams.list_ui_view,
      sysparm_homepage_sysid: reportParams.homepage_sysid,
      sysparm_is_published: reportParams.is_published
    };
  };
  this.init();
};
String.prototype.format = function formatString() {
  var args = arguments;
  return this.replace(/\{(\d+)\}/g, function replaceCb() {
    return args[arguments[1]];
  });
};;
/*! RESOURCE: /scripts/reportcommon/hcformatterfuncs.js */
function hc_legendLabelShortenedFormatter() {
  var legendLabelMaxLength = (this.userOptions !== undefined && this.userOptions.legend_label_max_length !== undefined) ? this.userOptions.legend_label_max_length : 30;
  return this.name.length > legendLabelMaxLength ? this.name.substring(0, legendLabelMaxLength) + '...' : this.name;
}

function hc_legendLabelPercentFormatter() {
  return this.name + ' = ' + this.y_tooltip + ' (' + this.percent + '%)';
}

function hc_legendLabelShortenedPercentFormatter() {
  var shortenedLabel = this.name.length > this.options.legend_label_max_length ? this.name.substring(0, this.options.legend_label_max_length) + '...' : this.name;
  return shortenedLabel + ' = ' + this.y_tooltip + ' (' + this.percent + '%)';
}

function hc_formatNameValueLabel() {
  var label = this.point.name + ' = ' + ((typeof this.point.y_tooltip !== 'undefined') ? this.point.y_tooltip : this.point.y);
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  return label;
}

function hc_formatParetoAxisLabels() {
  var total = 1.0;
  var pcnt = Highcharts.numberFormat(((this.value / parseFloat(total)) * 100), 0, '.');
  return pcnt + '%';
}

function hc_formatValueLabel() {
  var label = ((typeof this.point.y_tooltip !== 'undefined') ? this.point.y_tooltip : this.point.y);
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  if (label)
    return label;
  return undefined;
}

function hc_formatParetoLabelLine() {
  var label = this.point.percent + '%';
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  return label;
}

function hc_formatDurationLabel() {
  var secs = this.value;
  var prepend = '';
  if (secs < 0)
    prepend = '-';
  if (secs < 0)
    secs *= -1;
  var days = Math.floor(secs / 86400);
  var hours = Math.floor((secs % 86400) / 3600);
  var mins = Math.floor(((secs % 86400) % 3600) / 60);
  secs = ((secs % 86400) % 3600) % 60;
  var i18n = this.chart.options.lang;
  if (days > 0)
    return prepend + days + ' ' + i18n.days.toLowerCase() + ' ' + hours + ' ' + i18n.hours.toLowerCase() + ' ' + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  if (hours > 0)
    return prepend + hours + ' ' + i18n.hours.toLowerCase() + ' ' + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  if (mins > 0)
    return prepend + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  return prepend + secs + ' ' + i18n.seconds.toLowerCase();
};
/*! RESOURCE: /scripts/interactive_reports.js */
function getListURL(table, urlInfo, viewName) {
  var url = {};
  url.endpoint = '/' + table + '_list.do';
  url.params = {};
  if (urlInfo)
    url.params.sysparm_query = urlInfo;
  if (viewName)
    url.params.sysparm_view = viewName;
  return generateWholeUrl(url);
}

function generateWholeUrl(url) {
  if (!jQuery.isEmptyObject(url.params))
    return url.endpoint + '?' + Object.keys(url.params).map(function mapFunction(key) {
      return key + '=' + encodeURIComponent(url.params[key]).replace(/%40/gi, '@').replace(/%3A/gi, ':');
    }).join('&');
  return url.endpoint;
}

function drillReport(targetSpan, reportDrillId, newQuery, extraParams) {
  var interactiveReport = {};
  var url = {};
  url.params = {};
  interactiveReport.additional_query = newQuery;
  url.endpoint = '/report_viewer.do';
  var $publicPage = jQuery('#public-page');
  if ($publicPage.length && $publicPage.val() === 'true')
    url.endpoint = '/report_viewer_published.do';
  url.params.jvar_report_id = reportDrillId;
  url.params.sysparm_interactive_report = JSON.stringify(interactiveReport);
  if (extraParams)
    url.endpoint = url.endpoint + '?' + extraParams;
  reportReplace(targetSpan, url, true);
}

function drillList(targetSpan, table, newQuery, listView) {
  var url = {};
  url.endpoint = '/report_viewer.do';
  url.params = {
    sysparm_type: 'list',
    sysparm_query: newQuery,
    sysparm_view: listView,
    sysparm_table: table
  };
  reportReplace(targetSpan, url);
}

function embedReportById(targetSpan, reportId) {
  embedReportByParams(targetSpan, {
    jvar_report_id: reportId
  });
}

function isServicePortal() {
  return jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
}

function embedReportByParams(targetSpan, params) {
  var url = {};
  url.params = {};
  url.endpoint = '/report_viewer.do';
  if (!isServicePortal())
    url.params.sysparm_inline_embed = 'true';
  if (params)
    for (var key in params)
      if (typeof params[key] !== 'undefined')
        url.params[key] = params[key].toString() || '';
  reportReplace(targetSpan, url);
}

function reportReplace(targetSpan, url, stick) {
  if (!targetSpan)
    throw new Error('Report replace called, but the element to replace was not found!');
  CustomEvent.fireTop('request_start', document);
  url.params = url.params || {};
  url.params.sysparm_nostack = 'true';
  url.params['ni.nolog.x_referer'] = 'ignore';
  url.params.x_referer = buildReferringURL();
  var isPortal = targetSpan.find('.jvar_is_portal').first();
  var rootReportId;
  if (isPortal.length && isPortal.val() === 'true')
    url.params.jvar_is_portal = 'true';
  if (isServicePortal())
    url.params.jvar_is_portal = 'true';
  if (window.isEmbeddedReport === 'true')
    window.location.href = generateWholeUrl(url);
  else {
    if (window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && SNC.reportResizingFunctions) {
      rootReportId = targetSpan.find('.sysparm_root_report_id').first().val();
      var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(rootReportId);
      if (uuid && SNC.reportResizingFunctions[uuid])
        SNC.canvas.eventbus.unsubscribe(uuid, SNC.reportResizingFunctions[uuid]);
    }
    url.params.sysparm_direct = 'true';
    if (window.isInlineEmbed) {
      rootReportId = targetSpan.find('.sysparm_root_report_id').first().val();
      url.params.sysparm_inline_embed = window.isInlineEmbed[rootReportId];
    }
    showReportIsLoading(findGridWindowFromElement(targetSpan), targetSpan, stick);
    url.params.sysparm_processor = '';
    url.params.sysparm_scope = 'global';
    url.params.jvar_report_id = url.params.jvar_report_id || '';
    url.params.sysparm_interactive_report = url.params.sysparm_interactive_report || '';
    jQuery.ajax({
      method: 'POST',
      url: url.endpoint,
      dataType: 'text',
      data: url.params
    }).done(function doneAjax(xml) {
      reportReplaceCallback(xml, targetSpan);
    }).fail(function failedAjax(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
  }
}

function evaluateScriptTags(htmlNode) {
  var arr = htmlNode.getElementsByTagName('script');
  try {
    for (var n = 0; n < arr.length; n++) {
      if (arr[n].type !== 'application/xml' && arr[n].innerHTML)
        eval(arr[n].innerHTML);
    }
  } catch (error) {
    throw new Error(error);
  }
}

function reportReplaceCallback(html, targetSpan) {
  var scrollTop;
  if (window.isMSIE)
    scrollTop = document.body.scrollTop;
  var isList = html.indexOf('chart_type = "list"') > -1;
  if (isRenderedInCanvas()) {
    html += ' <div class="end-of-widget"></div>';
    updateWidgetCacheInCanvas(html, targetSpan);
  }
  if (isList && isServicePortal())
    html = '<div style="margin:20px 10px;">List chart is not supported in Service Portal widgets. Please use Simple List widget instead.</div>';
  if (targetSpan[0])
    targetSpan[0].innerHTML = html;
  var htmlNode = document.createElement('div');
  htmlNode.innerHTML = html;
  if (isList && !isServicePortal())
    html.evalScripts();
  else
    evaluateScriptTags(htmlNode);
  CustomEvent.fireTop('request_complete', document);
  CustomEvent.fire('partial.page.reload', targetSpan);
  if (window.isMSIE)
    document.body.scrollTop = scrollTop;
}

function generateDataPointClickUrl(event, element, reportDrilldown, table, clickUrlInfo, listUiViewName, drillOpenNewWin, isOther, mapKey, actualMap, showDataLabel, showGeographicalLabel) {
  var clickUrl;
  if (typeof jQuery !== 'undefined') {
    var content = jQuery(element).closest('.report_content');
    if (content.length && reportDrilldown) {
      var mapParams = '';
      if (mapKey)
        mapParams = 'sysparm_report_map_key=' + mapKey;
      if (actualMap)
        mapParams += '&sysparm_report_map_parent=' + actualMap;
      if (showDataLabel)
        mapParams += '&sysparm_show_chart_data_label=' + showDataLabel;
      if (showGeographicalLabel)
        mapParams += '&sysparm_show_geographical_label=' + showGeographicalLabel;
      drillReport(content.parent(), reportDrilldown, clickUrlInfo, mapParams);
      return;
    }
    clickUrl = getListURL(table, clickUrlInfo, listUiViewName);
  }
  clickUrl = getListURL(table, clickUrlInfo, listUiViewName);
  if (isServicePortal())
    clickUrl = addNavToUrl(clickUrl);
  openUrl(event, clickUrl, drillOpenNewWin, isOther);
}

function addNavToUrl(url) {
  return '/nav_to.do?uri=' + encodeURIComponent(url);
}

function openUrl(event, clickUrl, drillOpenNewWin, isOther) {
  if (('metaKey' in event && event.metaKey) || event.ctrlKey)
    window.open(clickUrl);
  else if (isServicePortal())
    top.location.href = clickUrl;
  else if (drillOpenNewWin && !isOther)
    window.open(clickUrl);
  else if (clickUrl)
    window.location.href = clickUrl;
}

function applyExecutiveReport(reportId, groupEl, stackEl, filter) {
  var $groupEl = jQuery(groupEl);
  var $stackEl = jQuery(stackEl);
  var target = $groupEl.closest('.report_content');
  if (target.length)
    target = target.parent();
  var interactiveReport = {};
  interactiveReport.groupby = $groupEl.val();
  if (filter)
    interactiveReport.additional_query = filter;
  if ($stackEl)
    interactiveReport.stackby = $stackEl.val();
  var gaugeId = $groupEl.closest('.sysparm_gauge_id');
  var gridWindow;
  if (typeof glideGrid !== 'undefined' && target && target.length)
    gridWindow = glideGrid.getWindow(target.closest('[dragpart]').first().attr('dragpart'));
  else if (gaugeId)
    gridWindow = _getGridWindow(gaugeId.value, reportId);
  if (gridWindow && gridWindow.getDashboardMessageHandler() !== undefined)
    interactiveReport.additional_filters = gridWindow.getDashboardMessageHandler().getCurrentFilters();
  interactiveReport = JSON.stringify(interactiveReport);
  var interactiveReportEl = jQuery('#sysparm_interactive_report')[0];
  if (((typeof runReport === 'function' && interactiveReportEl) || (typeof gReport !== 'undefined' && gReport.isDesigner)) && !filter) {
    if (typeof runReport === 'function') {
      interactiveReportEl.value = interactiveReport;
      runReport(false);
    } else
      NOW.CustomEvent.fire('reportDesigner:runInteractiveReport', interactiveReport);
  } else {
    var $publicPage = jQuery('#public-page');
    var url = {
      endpoint: $publicPage.length && $publicPage.val() === 'true' ? '/report_viewer_published.do' : '/report_viewer.do',
      params: {
        jvar_report_id: reportId,
        sysparm_interactive_report: interactiveReport
      }
    };
    reportReplace(target, url);
  }
}

function initializeInteractionOnGauge(reportId, rootReportId, gaugeId, homepageFilters, chartType, aggregateType) {
  if (!gaugeId)
    return;
  var gridWindow = _getGridWindow(gaugeId, rootReportId);
  if (typeof gridWindow === 'undefined' || !gridWindow)
    return;
  var realTime = chartType === 'single_score' && aggregateType === 'COUNT';
  if (realTime) {
    gridWindow.setPreference('can_real_time', 'true');
    if (window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.appProperties.sysparm_media !== 'print') {
      var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(reportId);
      SNC.canvas.canvasUtils.displayRealTimeIndicator(uuid, gridWindow.getPreference('real_time') === 'true');
    }
  }
  gridWindow.setPreference('can_subscribe', 'true');
  var supportedPublisherChartTypes = ['pie', 'donut', 'semi_donut', 'funnel', 'pyramid', 'map'];
  if (supportedPublisherChartTypes.indexOf(chartType) > -1)
    gridWindow.setPreference('can_publish', 'true');
  else
    gridWindow.removePreference('can_publish');
  if (gridWindow.getDashboardMessageHandler() !== undefined) {
    gridWindow.getDashboardMessageHandler().setCurrentFilters(homepageFilters);
    gridWindow.overwriteRefresh(function overwriteRefreshCallback() {
      updateReportInGauge(gridWindow, true, reportId);
    });
    var updateReportFn = updateReportInGauge.bind(null, gridWindow, false, reportId);
    var updateReportWithDelay = debounceHandler(updateReportFn, 600, false);
    var updateReportNow = debounceHandler(updateReportFn, 0, true);
    gridWindow.getDashboardMessageHandler().setCallback(function getDashboardMessageHandlerCallback() {
      var target = getTargetFromGridWindow(gridWindow);
      if (isRenderedInCanvas())
        showCanvasStyleLoading(target);
      applyInteractiveFiltersToReport(updateReportWithDelay, updateReportNow);
    });
  } else
    gridWindow.overwriteRefresh(function overwriteRefreshSimpleCallback() {
      simpleReportRefresh(gaugeId, rootReportId);
    });
}

function _getGridWindow(gaugeId, reportId) {
  var gridWindow;
  if (typeof glideGrid !== 'undefined') {
    gridWindow = glideGrid.getWindowByGaugeId(gaugeId);
    if (typeof gridWindow === 'undefined')
      gridWindow = glideGrid.getWindowByGaugeId(reportId);
  } else if (window.SNC && window.SNC.canvas && window.SNC.canvas.canvasUtils) {
    gridWindow = SNC.canvas.canvasUtils.getGlideWindow(gaugeId);
    if (typeof gridWindow === 'undefined')
      gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
  }
  return gridWindow;
}

function updateReportInGauge(gridWindow, refresh, reportId) {
  var interactiveReport = {};
  if (gridWindow)
    interactiveReport.additional_filters = gridWindow.getDashboardMessageHandler().getCurrentFilters();
  updateAdditionalReportConfig(gridWindow, reportId, interactiveReport);
  var target;
  target = getTargetFromGridWindow(gridWindow);
  if (target && target.length) {
    if (refresh) {
      reportId = target.find('.sysparm_root_report_id').first().val();
    } else {
      var filter = target.find('.sysparm_interactive_filter').first().val();
      if (typeof filter !== 'undefined' && filter)
        interactiveReport.additional_query = filter;
      var groupEl = gel('additional_groupby_' + reportId);
      var stackEl = gel('additional_stackby_' + reportId);
      if (groupEl)
        interactiveReport.groupby = groupEl.value;
      if (stackEl)
        interactiveReport.stackby = stackEl.value;
    }
  }
  var url = {
    endpoint: '/report_viewer.do',
    params: {
      jvar_report_id: reportId,
      jvar_real_time: gridWindow && gridWindow.getPreference('real_time') && gridWindow.getPreference('can_real_time'),
      sysparm_interactive_report: JSON.stringify(interactiveReport)
    }
  };
  reportReplace(target, url);
  if (!isRenderedInCanvas())
    showFilterIndicator(target, gridWindow);
}

function simpleReportRefresh(gaugeId, reportId) {
  var gridWindow = _getGridWindow(gaugeId, reportId);
  if (typeof gridWindow !== 'undefined' && gridWindow) {
    if (typeof jQuery !== 'undefined')
      showReportIsLoading(gridWindow);
    gridWindow.render();
  }
}

function isRenderedInCanvas() {
  return window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
}

function findGridWindowFromElementID(id) {
  if (typeof jQuery === 'undefined')
    return null;
  if (typeof glideGrid !== 'undefined')
    return glideGrid.getWindow(jQuery(document).find('#' + id).closest('[dragpart]').first()
      .attr('dragpart'));
  return null;
}

function findGridWindowFromElement(target) {
  if (typeof jQuery === 'undefined')
    return null;
  if (typeof glideGrid !== 'undefined')
    return glideGrid.getWindow(target.closest('[dragpart]').first().attr('dragpart'));
  return null;
}

function showReportIsLoading(gridWindow, targetSpan, stick) {
  var reportContent;
  var loadingMsg = window.GwtMessage ? new GwtMessage().getMessage('Loading report...') : 'Loading report...';
  if (isServicePortal() || isRenderedInCanvas()) {
    showCanvasStyleLoading(targetSpan);
    return;
  }
  if (!gridWindow) {
    if (targetSpan && targetSpan.length > 0)
      reportContent = targetSpan[0];
    if (!reportContent)
      reportContent = document.querySelector('.report_content .chart-container');
    if (!reportContent)
      reportContent = document.querySelector('.report_content');
    if (reportContent)
      reportContent.textContent = loadingMsg;
    return;
  }
  gridWindow.showLoading(loadingMsg, stick);
}

function hideReportIsLoading(gridWindow) {
  if (typeof gridWindow === 'undefined' || !gridWindow)
    return;
  gridWindow.hideLoading();
}

function showFilterIndicator(target, gridWindow) {
  var isFilterSelected = gridWindow.getDashboardMessageHandler().getCurrentFilters().length > 0;
  var isSubscribedAndOptedForFilterIndication = gridWindow.getPreference('can_subscribe') && typeof gridWindow.getPreference('filter_indicator') === 'undefined' ? false : gridWindow.getPreference('filter_indicator');
  var condition = isFilterSelected && (isSubscribedAndOptedForFilterIndication === 'true');
  var filterIndicatorPlaceholder = jQuery('#filter-indicator-' + gridWindow.id);
  if (condition)
    filterIndicatorPlaceholder.addClass('active');
  else
    filterIndicatorPlaceholder.removeClass('active');
}

function buildReferringURL() {
  var path = location.pathname;
  var args = location.search;
  if (path.substring(path.length - 1) === '/') {
    if (args)
      return args;
    return '';
  }
  return path.substring(path.lastIndexOf('/') + 1) + args;
}

function updateAdditionalReportConfig(gridWindow, reportId, interactiveReport) {
  var isBothPublisherNSubscriber = gridWindow && gridWindow.preferences.can_publish && gridWindow.preferences.can_subscribe;
  if (isBothPublisherNSubscriber) {
    var allFilters = {};
    if (isRenderedInCanvas()) {
      allFilters = SNC.canvas.interactiveFilters.getDefaultValues();
    } else {
      allFilters = getAllFiltersForHomePage();
    }
    if (gridWindow.filtersFromLegend) {
      interactiveReport.filtersFromLegend = gridWindow.filtersFromLegend;
    }
    for (var key in allFilters) {
      if (key == reportId) {
        var filter = allFilters[key];
        filter.forEach(function(item) {
          if (item.sliced)
            interactiveReport.selectedPoint = item.filter;
        });
      }
    }
    removeSelfPublishedFilter(interactiveReport, reportId);
  }
}

function getAllFiltersForHomePage() {
  var draggables = glideGrid && glideGrid._getDraggables();
  var allFilters = {};
  for (var i = 0; i < draggables.length; i++) {
    var current = draggables[i];
    if (current && current.gWindow && current.gWindow.getDashboardMessageHandler() &&
      !jQuery.isEmptyObject(current.gWindow.getDashboardMessageHandler()._filters)) {
      var keys = Object.keys(current.gWindow.getDashboardMessageHandler()._filters);
      keys.forEach(function(item) {
        allFilters[item] = current.gWindow.getDashboardMessageHandler()._filters[item];
      });
    }
  }
  return allFilters;
}

function removeSelfPublishedFilter(interactiveReport, reportId) {
  var hasAdditionalFilter = interactiveReport.additional_filters && interactiveReport.additional_filters.length && interactiveReport.selectedPoint;
  if (hasAdditionalFilter) {
    var newFilter = [];
    interactiveReport.additional_filters.forEach(function(filter) {
      var isCascadingFilter = !Array.isArray(filter);
      if (!isCascadingFilter) {
        filter.forEach(function(childFilter) {
          if (childFilter.id && childFilter.id.substring(0, reportId.length) != reportId) {
            newFilter.push(filter);
          } else if (!childFilter.id) {
            newFilter.push(filter);
          }
        });
      } else {
        newFilter.push(filter);
      }
    });
    interactiveReport.additional_filters = newFilter;
  }
}

function showCanvasStyleLoading(target) {
  jQuery(target).find('.report_content').replaceWith('<div class="spinner-container"><div class="icon icon-loading"></div></div>');
}

function debounceHandler(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this,
      args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

function getTargetFromGridWindow(gridWindow) {
  var target;
  if (typeof jQuery !== 'undefined' && gridWindow) {
    if (isRenderedInCanvas())
      target = jQuery(SNC.canvas.canvasUtils.getWidgetContainer(gridWindow.getID()));
    else
      target = jQuery(gridWindow.body);
  }
  return target;
}

function applyInteractiveFiltersToReport(updateReportWithDelay, updateReportNow) {
  if (!(window.SNC && SNC.canvas && SNC.canvas.chartsActingAsFilters && SNC.canvas.chartsActingAsFilters.lastPublishTime)) {
    updateReportNow();
    return;
  }
  var isFirstFilterPublished = SNC.canvas.chartsActingAsFilters.previousId == null;
  if (isFirstFilterPublished) {
    updateReportWithDelay();
    return;
  }
  var currentTime = Date.now();
  var isFilterPublishedQuickly = (currentTime - SNC.canvas.chartsActingAsFilters.lastPublishTime) < 600;
  var isNewFilterPublishedAfterDelay = (currentTime - SNC.canvas.chartsActingAsFilters.lastPublishTime) > 1000;
  var isFilterFromSameReport = SNC.canvas.chartsActingAsFilters.currentId === SNC.canvas.chartsActingAsFilters.previousId;
  var isFilterFromOneReport = ((isFilterPublishedQuickly || isNewFilterPublishedAfterDelay) && isFilterFromSameReport);
  if (isFilterFromOneReport)
    updateReportWithDelay();
  else
    updateReportNow();
}

function updateWidgetCacheInCanvas(html, targetSpan) {
  try {
    if (SNC.canvas.canvasUtils.updateWidgetCache && typeof SNC.canvas.canvasUtils.updateWidgetCache === "function")
      SNC.canvas.canvasUtils.updateWidgetCache(html, targetSpan);
  } catch (error) {
    if (SNC.canvas.canvasUtils.clearAllWidgetsCache)
      SNC.canvas.canvasUtils.clearAllWidgetsCache();
  }
};
/*! RESOURCE: /scripts/reportcommon/GlideReportChartAjax.js */
var stopWatch;

function runEmbeddedReport(msg_container_id, chart_container_id, title, display_grid, other_threshold, show_empty, table, group_by, filter, aggregate, agg_field, chart_type,
  stack_field, box_field, trend_field, trend_interval, compute_percent, show_other, use_color_palette, chart_size, funnel_neck_percent, donut_width_percent,
  gauge_autoscale, from, to, upper_limit, lower_limit, direction, chart_title, show_chart_title,
  chart_title_size, chart_title_color, custom_chart_title_position, chart_title_x_position, chart_title_y_position,
  title_horizontal_alignment, title_vertical_alignment, legend_horizontal_alignment, legend_vertical_alignment, report_id, show_chart_data_label,
  show_chart_border, chart_border_width, chart_border_radius, chart_border_color, chart_background_color, legend_border_width, legend_border_radius,
  legend_border_color, legend_background_color, show_legend, show_legend_border, chart_height, chart_width, custom_chart_size, report_source_id, bar_unstack, x_axis_title, x_axis_title_size, x_axis_title_color, x_axis_title_bold, x_axis_opposite, x_axis_grid_width, x_axis_grid_color, x_axis_display_grid, x_axis_grid_dotted, x_axis_label_size, x_axis_label_color, x_axis_label_bold, y_axis_title, y_axis_title_size, y_axis_title_color, y_axis_title_bold, y_axis_opposite, y_axis_grid_width, y_axis_grid_color, y_axis_display_grid, y_axis_grid_dotted, y_axis_from, y_axis_to, y_axis_label_size, y_axis_label_color, y_axis_label_bold, show_marker, sc_groupby_item_id, sc_groupby_variable_id, sc_stackby_item_id, sc_stackby_variable_id, list_ui_view, report_drilldown, show_chart_total, use_color_heatmap, axis_max_color, axis_min_color, ct_row, ct_column, show_zero, score_color, interactive_report, set_color, color, colors, color_palette, other_series, report_map
) {
  var params = {};
  params.title = title;
  params.display_grid = display_grid;
  params.other_threshold = other_threshold;
  params.show_empty = show_empty;
  params.table = table;
  params.group_by = group_by;
  params.filter = filter;
  params.aggregate = aggregate;
  params.agg_field = agg_field;
  params.chart_type = chart_type;
  params.stack_field = stack_field;
  params.box_field = box_field;
  params.trend_field = trend_field;
  params.trend_interval = trend_interval;
  params.compute_percent = compute_percent;
  params.show_other = show_other;
  params.chart_size = chart_size;
  params.funnel_neck_percent = funnel_neck_percent;
  params.donut_width_percent = donut_width_percent;
  params.gauge_autoscale = gauge_autoscale;
  params.from = from;
  params.to = to;
  params.upper_limit = upper_limit;
  params.lower_limit = lower_limit;
  params.direction = direction;
  params.chart_title = chart_title;
  params.show_chart_title = show_chart_title;
  params.chart_title_size = chart_title_size;
  params.chart_title_color = chart_title_color;
  params.custom_chart_title_position = custom_chart_title_position;
  params.chart_title_x_position = chart_title_x_position;
  params.chart_title_y_position = chart_title_y_position;
  params.title_horizontal_alignment = title_horizontal_alignment;
  params.title_vertical_alignment = title_vertical_alignment;
  params.legend_horizontal_alignment = legend_horizontal_alignment;
  params.legend_vertical_alignment = legend_vertical_alignment;
  params.report_id = report_id;
  params.show_chart_data_label = show_chart_data_label;
  params.show_chart_border = show_chart_border;
  params.chart_border_width = chart_border_width;
  params.chart_border_radius = chart_border_radius;
  params.chart_border_color = chart_border_color;
  params.chart_background_color = chart_background_color;
  params.legend_border_width = legend_border_width;
  params.legend_border_radius = legend_border_radius;
  params.legend_border_color = legend_border_color;
  params.legend_background_color = legend_background_color;
  params.show_legend = show_legend;
  params.show_legend_border = show_legend_border;
  params.chart_height = chart_height;
  params.chart_width = chart_width;
  params.custom_chart_size = custom_chart_size;
  params.report_source_id = report_source_id;
  params.bar_unstack = bar_unstack;
  params.x_axis_title = x_axis_title;
  params.x_axis_title_size = x_axis_title_size;
  params.x_axis_title_color = x_axis_title_color;
  params.x_axis_title_bold = x_axis_title_bold;
  params.x_axis_opposite = x_axis_opposite;
  params.x_axis_grid_width = x_axis_grid_width;
  params.x_axis_grid_color = x_axis_grid_color;
  params.x_axis_display_grid = x_axis_display_grid;
  params.x_axis_grid_dotted = x_axis_grid_dotted;
  params.x_axis_label_size = x_axis_label_size;
  params.x_axis_label_color = x_axis_label_color;
  params.x_axis_label_bold = x_axis_label_bold;
  params.y_axis_title = y_axis_title;
  params.y_axis_title_size = y_axis_title_size;
  params.y_axis_title_color = y_axis_title_color;
  params.y_axis_title_bold = y_axis_title_bold;
  params.y_axis_opposite = y_axis_opposite;
  params.y_axis_grid_width = y_axis_grid_width;
  params.y_axis_grid_color = y_axis_grid_color;
  params.y_axis_display_grid = y_axis_display_grid;
  params.y_axis_grid_dotted = y_axis_grid_dotted;
  params.y_axis_from = y_axis_from;
  params.y_axis_to = y_axis_to;
  params.y_axis_label_size = y_axis_label_size;
  params.y_axis_label_color = y_axis_label_color;
  params.y_axis_label_bold = y_axis_label_bold;
  params.show_marker = show_marker;
  params.sc_groupby_item_id = sc_groupby_item_id;
  params.sc_groupby_variable_id = sc_groupby_variable_id;
  params.sc_stackby_item_id = sc_stackby_item_id;
  params.sc_stackby_variable_id = sc_stackby_variable_id;
  params.list_ui_view = list_ui_view;
  params.report_drilldown = report_drilldown;
  params.show_chart_total = show_chart_total;
  params.use_color_heatmap = use_color_heatmap;
  params.axis_max_color = axis_max_color;
  params.axis_min_color = axis_min_color;
  params.ct_row = ct_row;
  params.ct_column = ct_column;
  params.show_zero = show_zero;
  params.score_color = score_color;
  params.interactive_report = interactive_report;
  params.set_color = set_color;
  params.color = color;
  params.colors = colors;
  params.color_palette = color_palette;
  params.other_series = other_series;
  params.report_map = report_map;
  runReportAsGauge(params, chart_container_id, msg_container_id, "false", "false", null, true);
}

function runReportAsGauge(params, chartContainerId, msgContainerId, isGauge, isGaugePreview, maxCancelationRetries, noRetry) {
  var startTime = new Date().getTime();
  setupSeries(params);
  if (isGaugePreview == "true")
    params.gauge_preview = true;
  var pageNum = document.getElementById('sysparm_page_num');
  if (pageNum && pageNum.value)
    params.page_num = pageNum.value;
  else
    params.page_num = 0;
  if (isGauge === "true" || isGauge === true)
    isGauge = true;
  else
    isGauge = false;
  var additionalArgs = constructAdditionalArgs(params, chartContainerId, msgContainerId, isGauge, startTime);
  generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, 0, noRetry);
}

function constructAdditionalArgs(params, chartContainerId, msgContainerId, isGauge, startTime) {
  var additionalArgs = {};
  additionalArgs.chart_container_id = chartContainerId;
  additionalArgs.msg_container_id = msgContainerId;
  additionalArgs.chart_type = params.series[0].plot_type;
  additionalArgs.agg_type = params.series[0].aggregate_type;
  additionalArgs.chart_size = params.chart_size;
  additionalArgs.chart_height = params.chart_height;
  additionalArgs.chart_width = params.chart_width;
  additionalArgs.start_time = startTime;
  additionalArgs.compute_percent = params.compute_percent;
  additionalArgs.group_by = params.series[0].groupby;
  additionalArgs.stacked_field = '';
  if (isBarType(additionalArgs.chart_type))
    additionalArgs.stacked_field = params.series[0].stacked_field;
  additionalArgs.display_grid = false;
  if (params.display_grid === "true" || params.display_grid === true)
    additionalArgs.display_grid = true;
  additionalArgs.isGauge = isGauge;
  if (additionalArgs.isGauge) {
    additionalArgs.gauge_id = params.gauge_id;
    additionalArgs.gauge_preview = params.gauge_preview;
  }
  additionalArgs.chart_params = JSON.stringify(params);
  additionalArgs.report_id = params.report_id;
  additionalArgs.source_type = params.source_type;
  if (params.report_uuid)
    additionalArgs.report_uuid = params.report_uuid;
  additionalArgs.publisher_filter = params.publisher_filter;
  return additionalArgs;
}

function isHighChartsSupportedType(chart_type) {
  return chart_type == 'bar' || chart_type == 'horizontal_bar' || isPieType(chart_type) || chart_type == 'pareto' || chart_type == 'hist' || chart_type == 'trend' ||
    chart_type == 'box' || chart_type == 'line' || chart_type == 'step_line' || chart_type == 'area' || chart_type == 'spline' || chart_type == 'line_bar' || chart_type == 'control' || chart_type == 'availability' ||
    chart_type == 'tbox' || isGaugeType(chart_type) || chart_type == 'heatmap' || chart_type == 'bubble' || chart_type == 'map';
}

function runReportFromBuilder(reportUUID, fixedSize, params, maxCancelationRetries, noRetry) {
  if (!params)
    params = window.g_report_params[reportUUID];
  if (!params.report_uuid)
    params.report_uuid = reportUUID;
  createReportTemplate(reportUUID, params, fixedSize);
  runReportAsGauge(params, "chart-container-" + reportUUID, "msg-container-" + reportUUID, "false", "false", maxCancelationRetries, noRetry);
}

function createReportTemplate(reportUUID, params, fixedSize) {
  var $reportContainer = jQuery('#report-container-' + reportUUID);
  $reportContainer.empty();
  $reportContainer.append(jQuery("<div class='gauge-size-handle report_breadcrumbs' />"));
  var $msgContainer = jQuery('<div class="report-message gauge-size-handle" id="msg-container-' + reportUUID + '"/>');
  var containerClass = "chart-container"
  if (isScrollableType(params.chart_type))
    containerClass += " scrollable";
  var $chartContainer = jQuery('<div class="' + containerClass + '" id="chart-container-' + reportUUID + '">Loading report...</div>');
  if (fixedSize) {
    var chartHeight = 550;
    var chartWidth = 750;
    var customChartSize = params.custom_chart_size;
    var customChartHeight = params.chart_height;
    var customChartWidth = params.chart_width;
    var chartSize = params.chart_size;
    if (customChartSize === 'true' && customChartHeight !== 'null' && customChartHeight !== '')
      chartHeight = customChartHeight;
    else if (chartSize === 'medium')
      chartHeight = 450;
    else if (chartSize === 'small')
      chartHeight = 375;
    if (customChartSize === 'true' && customChartWidth !== 'null' && customChartWidth !== '')
      chartWidth = customChartWidth;
    else if (chartSize === 'medium')
      chartWidth = 600;
    else if (chartSize === 'small')
      chartWidth = 450;
    $chartContainer.height(chartHeight).width(chartWidth);
  }
  $reportContainer.append($msgContainer);
  $reportContainer.append($chartContainer);
  if ((!params.page_num || params.page_num == "0") && params.additional_groupby && hasAdditionalGroupBy(params.chart_type)) {
    $reportContainer.append(jQuery('<div id="interactive-container-' + reportUUID + '" class="interactive_container gauge-size-handle" style="text-align: center; padding-top: 5px;"/>'));
  }
  if ((params.display_grid === "true" || params.display_grid === true || window.g_accessibility === "true" || window.g_accessibility === true) && isDisplayGridApplicable(params.chart_type)) {
    $reportContainer.append(jQuery('<div class="display-grid-container">' +
      '<table id="display-grid-table-' + reportUUID + '" align="center" border="0" cellpadding="0" cellspacing="0" class="chart_legend" style="margin-top: 5px; display:none; border-collapse: collapse !important;" />' +
      '</div>'));
  }
}

function isScrollableType(type) {
  return "pivot_v2" == type || "calendar" == type;
}

function generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, cancelledCount, noRetry) {
  maxCancelationRetries = parseInt(maxCancelationRetries) || 15;
  cancelledCount = parseInt(cancelledCount) || 0;
  if (cancelledCount == 0) {
    params.sysparm_request_params = JSON.stringify(params);
    params.sysparm_timer = new Date().getTime();
    if ('chartOnForm' in params)
      params.sysparm_chartonform = true;
    params.sysparm_processor = 'ChartDataProcessor';
    params.sysparm_scope = 'global';
    params.sysparm_want_session_messages = true;
  }
  var config = {
    method: 'POST',
    url: 'xmlhttp.do',
    data: $j.param(params),
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    dataType: 'xml'
  };
  $j.ajax(config).then(function successCallback(response) {
    if (!response || (response.getElementById('transaction_canceled_island') && response.getElementById('transaction_canceled_island').getAttribute('transaction_canceled') === 'true')) {
      var cancelledMsg = response ? response.getElementById('transaction_canceled_island').getAttribute('cancel_message') : '';
      cancelledMsg = cancelledMsg.toLowerCase();
      if (cancelledCount > maxCancelationRetries) {
        if (window.console)
          console.log('Transaction has been cancelled ' + maxCancelationRetries + ' times and stop retrying');
        if (chartContainerId)
          document.getElementById(chartContainerId).innerHTML = cancelledMsg;
      } else {
        if (cancelledMsg && cancelledMsg.indexOf('maximum execution time exceeded') !== -1 && chartContainerId)
          document.getElementById(chartContainerId).innerHTML = cancelledMsg;
        else
        if (!noRetry)
          setTimeout(function() {
            generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, ++cancelledCount, noRetry)
          }, 500);
      }
    } else
      getChartDataDone(response, additionalArgs);
  }, function errorCallback(response) {
    if (!noRetry)
      setTimeout(function() {
        generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, ++cancelledCount, noRetry)
      }, 500);
  });
}

function getReportParams(chartonform, type) {
  var config = getReportConfig(chartonform, type);
  config.show_empty = getReportParamValue('sysparm_show_empty', chartonform);
  var pageNum = document.getElementById('sysparm_page_num');
  if (pageNum && pageNum.value)
    config.page_num = pageNum.value;
  return config;
}

function getReportConfig(chartonform, type) {
  var params = {};
  params.sysparm_report_designer_builder = 'true';
  params.sysparm_is_published = getReportParamValue('sysparm_is_published', chartonform);
  if (type === 'list') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_field = getReportParamValue('sysparm_field', chartonform);
    params.sysparm_field_list = getReportParamValue('sysparm_field_list', chartonform);
    params.sysparm_full_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_additional_groupby = getReportParamValue('sysparm_additional_groupby', chartonform);
    params.sysparm_interactive_report = getReportParamValue('sysparm_interactive_report', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    params.sysparm_view = getReportParamValue('sysparm_view', chartonform);
    return params
  } else if (type === 'pivot') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_ct_row = getReportParamValue('sysparm_ct_row', chartonform);
    params.sysparm_ct_column = getReportParamValue('sysparm_ct_column', chartonform);
    params.sysparm_sumfield = getReportParamValue('sysparm_sumfield', chartonform);
    params.sysparm_aggregate = getReportParamValue('sysparm_aggregate', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_title = getReportParamValue('sysparm_title', chartonform);
    params.sysparm_others = getReportParamValue('sysparm_others', chartonform);
    params.sysparm_show_other = getReportParamValue('sysparm_show_other', chartonform);
    params.sysparm_list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.sysparm_report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    return params
  } else if (type === 'calendar') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_field = getReportParamValue('sysparm_field', chartonform);
    params.sysparm_cal_field = getReportParamValue('sysparm_cal_field', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.sysparm_report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    return params
  } else {
    params.table = getReportParamValue('sysparm_table', chartonform);
    params.report_id = (typeof additionalArgs === 'undefined' ? '' : additionalArgs.report_id);
    if (params.report_id === '')
      params.report_id = getReportParamValue('sysparm_report_id', chartonform);
    params.title = getReportParamValue('sysparm_title', chartonform);
    params.display_grid = getReportParamValue('sysparm_display_grid', chartonform);
    params.other_threshold = getReportParamValue('sysparm_others', chartonform);
    params.compute_percent = getReportParamValue('sysparm_compute_percent', chartonform);
    params.chart_size = getReportParamValue('sysparm_chart_size', chartonform);
    params.custom_chart_size = getReportParamValue('sysparm_custom_chart_size', chartonform);
    params.chart_height = getReportParamValue('sysparm_custom_chart_height', chartonform);
    params.chart_width = getReportParamValue('sysparm_custom_chart_width', chartonform);
    params.show_other = getReportParamValue('sysparm_show_other', chartonform);
    params.chart_type = getReportParamValue('sysparm_type', chartonform);
    params.group_by = getReportParamValue('sysparm_field', chartonform);
    params.filter = getReportParamValue('sysparm_query', chartonform);
    params.aggregate = getReportParamValue('sysparm_aggregate', chartonform);
    params.agg_field = getReportParamValue('sysparm_sumfield', chartonform);
    params.stack_field = getReportParamValue('sysparm_stack_field', chartonform);
    params.box_field = getReportParamValue('sysparm_box_field', chartonform);
    params.trend_field = getReportParamValue('sysparm_trend_field', chartonform);
    params.trend_interval = getReportParamValue('sysparm_trend_interval', chartonform);
    params.funnel_neck_percent = getReportParamValue('sysparm_funnel_neck_percent', chartonform);
    params.donut_width_percent = getReportParamValue('sysparm_donut_width_percent', chartonform);
    params.gauge_autoscale = getReportParamValue('sysparm_gauge_autoscale', chartonform);
    params.from = getReportParamValue('sysparm_from', chartonform);
    params.to = getReportParamValue('sysparm_to', chartonform);
    params.upper_limit = getReportParamValue('sysparm_upper_limit', chartonform);
    params.lower_limit = getReportParamValue('sysparm_lower_limit', chartonform);
    params.direction = getReportParamValue('sysparm_direction', chartonform);
    params.chart_title = getReportParamValue('sysparm_chart_title', chartonform);
    params.show_chart_title = getReportParamValue('sysparm_show_chart_title', chartonform);
    params.chart_title_size = getReportParamValue('sysparm_chart_title_size', chartonform);
    params.chart_title_color = getReportParamValue('sysparm_chart_title_color', chartonform);
    params.custom_chart_title_position = getReportParamValue('sysparm_custom_chart_title_position', chartonform);
    params.chart_title_x_position = getReportParamValue('sysparm_chart_title_x_position', chartonform);
    params.chart_title_y_position = getReportParamValue('sysparm_chart_title_y_position', chartonform);
    params.show_chart_border = getReportParamValue('sysparm_show_chart_border', chartonform);
    params.title_horizontal_alignment = getReportParamValue('sysparm_title_horizontal_alignment', chartonform);
    params.title_vertical_alignment = getReportParamValue('sysparm_title_vertical_alignment', chartonform);
    params.legend_horizontal_alignment = getReportParamValue('sysparm_legend_horizontal_alignment', chartonform);
    params.legend_vertical_alignment = getReportParamValue('sysparm_legend_vertical_alignment', chartonform);
    params.chart_border_width = getReportParamValue('sysparm_chart_border_width', chartonform);
    params.chart_border_radius = getReportParamValue('sysparm_chart_border_radius', chartonform);
    params.chart_border_color = getReportParamValue('sysparm_chart_border_color', chartonform);
    params.score_color = getReportParamValue('sysparm_score_color', chartonform);
    params.chart_background_color = getReportParamValue('sysparm_chart_background_color', chartonform);
    params.legend_border_width = getReportParamValue('sysparm_legend_border_width', chartonform);
    params.legend_border_radius = getReportParamValue('sysparm_legend_border_radius', chartonform);
    params.legend_border_color = getReportParamValue('sysparm_legend_border_color', chartonform);
    params.legend_background_color = getReportParamValue('sysparm_legend_background_color', chartonform);
    params.legend_items_left_align = getReportParamValue('sysparm_legend_items_left_align', chartonform);
    params.show_legend = getReportParamValue('sysparm_show_legend', chartonform);
    params.show_legend_border = getReportParamValue('sysparm_show_legend_border', chartonform);
    params.show_chart_data_label = getReportParamValue('sysparm_show_chart_data_label', chartonform);
    params.show_data_label_position_middle = getReportParamValue('sysparm_show_data_label_position_middle', chartonform);
    params.allow_data_label_overlap = getReportParamValue('sysparm_allow_data_label_overlap', chartonform);
    params.show_geographical_label = getReportParamValue('sysparm_show_geographical_label', chartonform);
    params.show_zero = getReportParamValue('sysparm_show_zero', chartonform);
    params.show_marker = getReportParamValue('sysparm_show_marker', chartonform);
    params.bar_unstack = getReportParamValue('sysparm_bar_unstack', chartonform);
    params.x_axis_title = getReportParamValue('sysparm_x_axis_title', chartonform);
    params.x_axis_title_size = getReportParamValue('sysparm_x_axis_title_size', chartonform);
    params.x_axis_title_color = getReportParamValue('sysparm_x_axis_title_color', chartonform);
    params.x_axis_title_bold = getReportParamValue('sysparm_x_axis_title_bold', chartonform);
    params.x_axis_opposite = getReportParamValue('sysparm_x_axis_opposite', chartonform);
    params.x_axis_grid_width = getReportParamValue('sysparm_x_axis_grid_width', chartonform);
    params.x_axis_grid_color = getReportParamValue('sysparm_x_axis_grid_color', chartonform);
    params.x_axis_display_grid = getReportParamValue('sysparm_x_axis_display_grid', chartonform);
    params.x_axis_grid_dotted = getReportParamValue('sysparm_x_axis_grid_dotted', chartonform);
    params.x_axis_label_size = getReportParamValue('sysparm_x_axis_label_size', chartonform);
    params.x_axis_label_color = getReportParamValue('sysparm_x_axis_label_color', chartonform);
    params.x_axis_label_bold = getReportParamValue('sysparm_x_axis_label_bold', chartonform);
    params.y_axis_title = getReportParamValue('sysparm_y_axis_title', chartonform);
    params.y_axis_title_size = getReportParamValue('sysparm_y_axis_title_size', chartonform);
    params.y_axis_title_color = getReportParamValue('sysparm_y_axis_title_color', chartonform);
    params.y_axis_title_bold = getReportParamValue('sysparm_y_axis_title_bold', chartonform);
    params.y_axis_opposite = getReportParamValue('sysparm_y_axis_opposite', chartonform);
    params.y_axis_grid_width = getReportParamValue('sysparm_y_axis_grid_width', chartonform);
    params.y_axis_grid_color = getReportParamValue('sysparm_y_axis_grid_color', chartonform);
    params.y_axis_display_grid = getReportParamValue('sysparm_y_axis_display_grid', chartonform);
    params.y_axis_grid_dotted = getReportParamValue('sysparm_y_axis_grid_dotted', chartonform);
    params.y_axis_from = getReportParamValue('sysparm_y_axis_from', chartonform);
    params.y_axis_to = getReportParamValue('sysparm_y_axis_to', chartonform);
    params.y_axis_label_size = getReportParamValue('sysparm_y_axis_label_size', chartonform);
    params.y_axis_label_color = getReportParamValue('sysparm_y_axis_label_color', chartonform);
    params.y_axis_label_bold = getReportParamValue('sysparm_y_axis_label_bold', chartonform);
    params.report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    params.sc_groupby_item_id = getReportParamValue('sysparm_sc_groupby_item_id', chartonform);
    params.sc_groupby_variable_id = getReportParamValue('sysparm_sc_groupby_variable_id', chartonform);
    params.sc_stackby_item_id = getReportParamValue('sysparm_sc_stackby_item_id', chartonform);
    params.sc_stackby_variable_id = getReportParamValue('sysparm_sc_stackby_variable_id', chartonform);
    params.list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.show_chart_total = getReportParamValue('sysparm_show_chart_total', chartonform);
    params.use_color_heatmap = getReportParamValue('sysparm_use_color_heatmap_map', chartonform);
    params.axis_max_color = getReportParamValue('sysparm_axis_max_color', chartonform);
    params.axis_min_color = getReportParamValue('sysparm_axis_min_color', chartonform);
    params.ct_column = getReportParamValue('sysparm_ct_column', chartonform);
    params.ct_row = getReportParamValue('sysparm_ct_row', chartonform);
    params.interactive_report = getReportParamValue('sysparm_interactive_report', chartonform);
    params.set_color = getReportParamValue('sysparm_set_color', chartonform);
    params.color = getReportParamValue('sysparm_chart_color', chartonform);
    params.colors = getReportParamValue('sysparm_chart_colors', chartonform);
    params.color_palette = getReportParamValue('sysparm_color_palette', chartonform);
    params.decimal_precision = getReportParamValue('sysparm_decimal_precision', chartonform);
    params.show_empty = true;
    params.other_series = '';
    params.report_map = getReportParamValue('sysparm_report_map', chartonform);
    params.report_map_source = getReportParamValue('sysparm_report_map_source', chartonform);
    params.additional_groupby = getReportParamValue('sysparm_additional_groupby', chartonform);
    params.original_groupby = getReportParamValue('sysparm_field', chartonform);
    params.original_stackby = getReportParamValue('sysparm_stack_field', chartonform);
    params.is_published = params.sysparm_is_published;
    params.use_null_in_trend = getReportParamValue('sysparm_use_null_in_trend', chartonform);
    params.series_name_text = getReportParamValue('sysparm_series_name_text', chartonform);
    params.x_axis_category_fields = getReportParamValue('sysparm_x_axis_category_fields', chartonform);
    params.y_axis_category_fields = getReportParamValue('sysparm_y_axis_category_fields', chartonform);
    params.pivot_expanded = getReportParamValue('sysparm_pivot_expanded', chartonform);
    params.display_row_lines = getReportParamValue('sysparm_display_row_lines', chartonform);
    params.display_column_lines = getReportParamValue('sysparm_display_column_lines', chartonform);
    params.cal_field = getReportParamValue('sysparm_cal_field', chartonform);
    params.source_type = getReportParamValue('sysparm_source_type', chartonform);
    params.custom_config = getReportParamValue('sysparm_custom_config', chartonform);
    params.start_time = getReportParamValue('sysparm_start_time', chartonform);
    params.end_time = getReportParamValue('sysparm_end_time', chartonform);
    return setupSeries(params);
  }
}

function getReportParamValue(name, chartonform) {
  var fullName = name;
  if (chartonform)
    fullName += chartonform;
  var element = document.getElementById(fullName);
  if (element)
    return element.value;
  return '';
}

function setupSeries(params) {
  if (params.chart_type == 'line' || params.chart_type == 'area' || params.chart_type == 'spline' ||
    params.chart_type == 'line_bar' || params.chart_type == 'step_line')
    params.other_threshold = -1;
  params.series = new Array();
  var curSeries = {};
  var interactiveReport = {};
  if (params.interactive_report) {
    try {
      interactiveReport = JSON.parse(params.interactive_report);
    } catch (err) {
      console.log("unable to parse interactive reports JSON definition")
    }
  }
  curSeries.table = params.table;
  curSeries.report_source_id = params.report_source_id;
  if (interactiveReport.groupby || interactiveReport.groupby === '')
    curSeries.groupby = interactiveReport.groupby;
  else
    curSeries.groupby = params.group_by;
  curSeries.location = params.location;
  curSeries.report_map_source = params.report_map_source;
  curSeries.report_map = params.report_map;
  curSeries.sc_groupby_item_id = params.sc_groupby_item_id;
  curSeries.sc_groupby_variable_id = params.sc_groupby_variable_id;
  curSeries.sc_stackby_item_id = params.sc_stackby_item_id;
  curSeries.sc_stackby_variable_id = params.sc_stackby_variable_id;
  curSeries.filter = params.filter;
  curSeries.interactive_report = params.interactive_report;
  curSeries.plot_type = params.chart_type;
  if (curSeries.plot_type == 'pareto')
    curSeries.aggregate_type = 'COUNT';
  else {
    curSeries.aggregate_type = params.aggregate;
    if (params.aggregate != 'COUNT')
      curSeries.aggregate_field = params.agg_field;
  }
  if (isBarType(curSeries.plot_type)) {
    if (interactiveReport.stackby === '' || interactiveReport.stackby)
      curSeries.stacked_field = interactiveReport.stackby;
    else
      curSeries.stacked_field = params.stack_field;
  } else if (curSeries.plot_type == 'hist') {
    curSeries.hist_field = params.box_field;
  } else if (curSeries.plot_type == 'box') {
    curSeries.box_field = params.box_field;
  } else if (curSeries.plot_type == 'trend' || curSeries.plot_type == 'line' || curSeries.plot_type == 'area' || curSeries.plot_type == 'spline' || curSeries.plot_type == 'line_bar' ||
    curSeries.plot_type == 'control' || curSeries.plot_type == 'availability' ||
    curSeries.plot_type == 'tbox' || curSeries.plot_type == 'step_line') {
    curSeries.trend_field = params.trend_field;
    curSeries.trend_interval = params.trend_interval;
  } else if (curSeries.plot_type == 'heatmap' || curSeries.plot_type == 'bubble') {
    curSeries.ct_row = params.ct_row;
    curSeries.ct_column = params.ct_column;
  } else if (curSeries.plot_type == 'map')
    curSeries.show_geographical_label = params.show_geographical_label;
  curSeries.show_chart_data_label = params.show_chart_data_label;
  curSeries.show_data_label_position_middle = params.show_data_label_position_middle;
  curSeries.allow_data_label_overlap = params.allow_data_label_overlap;
  curSeries.show_marker = params.show_marker;
  curSeries.bar_unstack = params.bar_unstack;
  curSeries.list_ui_view = params.list_ui_view;
  curSeries.set_color = params.set_color;
  curSeries.color = params.color;
  curSeries.colors = params.colors;
  curSeries.color_palette = params.color_palette;
  curSeries.show_y_axis = params.show_y_axis;
  curSeries.y_axis_from = params.y_axis_from;
  curSeries.y_axis_to = params.y_axis_to;
  curSeries.y_axis_title = params.y_axis_title;
  curSeries.series_name_text = params.series_name_text;
  curSeries.source_type = params.source_type;
  curSeries.custom_config = params.custom_config;
  curSeries.use_null_in_trend = params.use_null_in_trend;
  params.series.push(curSeries);
  return params;
}

function getChartDataDone(response, args) {
  var chartDataResponse = response.getElementsByTagName('CHART_DATA_RESPONSE');
  if (!response || !chartDataResponse) {
    showError(args['msg_container_id'], "No response from the server");
  } else {
    var resp = JSON.parse(getTextValue((chartDataResponse)[0]));
    processChartDataResponse(resp, args);
  }
  var now = new Date().getTime();
  var elapsedTime = (now - args['start_time']) / 1000;
  console.log('Time taken to render chart: ' + elapsedTime);
}

function processChartDataResponse(resp, args) {
  if (resp.STATUS == 'SUCCESS') {
    var mychart;
    if ('chartOnForm' in args)
      mychart = new GlideReportChart(args['chart_container_id'], args['msg_container_id'], args['isGauge'], args['chart_size'],
        args['chart_type'], args['report_id'], args['chart_params'], args['chart_height'], args['chart_width'], args['source_type']);
    else
      mychart = new GlideReportChart(args['chart_container_id'], args['msg_container_id'], args['isGauge'], args['chart_size'],
        args['chart_type'], args['report_id'], args['chart_params'], args['chart_height'], args['chart_width'], args['source_type']);
    if ('isPub' in args && args.isPub) {
      mychart.setPub(args.isPub);
    } else
      mychart.setPub(false);
    var chart_data = JSON.parse(resp.CHART_DATA);
    if (!renderChart(mychart, chart_data, args, interval)) {
      var interval = setInterval(function() {
        if (renderChart(mychart, chart_data, args, interval)) {
          clearInterval(interval);
        }
      }, 1000);
    }
  } else if (resp.STATUS == 'INFO') {
    showInfo(args['chart_container_id'], resp.INFO_MESSAGE);
    document.getElementById(args['msg_container_id']).innerHTML = '';
  } else {
    showError(args['chart_container_id'], resp.ERROR_MESSAGE);
    document.getElementById(args['msg_container_id']).innerHTML = '';
  }
}

function renderChart(mychart, chart_data, args, interval) {
  if (jQuery("#" + args['chart_container_id']).is(":visible")) {
    if (args['source_type'] === 'metricbase') {
      var chartParams;
      if (mychart.chartParams)
        chartParams = JSON.parse(mychart.chartParams);
      mychart.buildMetricBase(chart_data, chartParams);
    } else {
      chart_data.report_properties.publisher_id = args['publisher_id'];
      chart_data.report_properties.report_id = args['report_id'];
      chart_data.report_properties.publisher_filter = args['publisher_filter'];
      checkAndEnableInteractiveFilters(chart_data, args);
      mychart.buildGroupChartForSingleSeries(chart_data, args['stacked_field'], args['agg_type'], args['source_type']);
      checkAndEnableDisplayGrid(chart_data, args);
    }
    return true;
  } else
    return false;
}

function isBarType(chart_type) {
  return chart_type === 'bar' || chart_type === 'horizontal_bar';
}

function isPieType(chart_type) {
  return (chart_type === 'pie' || chart_type === 'funnel' || chart_type === 'semi_donut' || chart_type === 'pyramid' || chart_type === 'donut');
}

function isGaugeType(chartType) {
  return (chartType === 'angular_gauge' || chartType === 'solid_gauge');
}

function formatDuration(secs) {
  var days = Math.floor(secs / 86400);
  var hours = Math.floor((secs % 86400) / 3600);
  var mins = Math.floor(((secs % 86400) % 3600) / 60);
  var secs = ((secs % 86400) % 3600) % 60;
  if (days > 0)
    return days + ' days ' + hours + ' hours ' + mins + ' minutes ' + secs + ' seconds';
  if (hours > 0)
    return hours + ' hours ' + mins + ' minutes ' + secs + ' seconds';
  if (mins > 0)
    return mins + ' minutes ' + secs + ' seconds';
  return secs + ' seconds';
}

function showError(container, errorMsg) {
  document.getElementById(container).innerHTML = '<div style="text-align:center;color:red">' + 'ERROR: ' + errorMsg + '</div>';
}

function showInfo(container, infoMsg) {
  document.getElementById(container).innerHTML = '<div style="text-align:center;color:black">' + infoMsg + '</div>';
};
/*! RESOURCE: /scripts/reportcommon/GlideReportChart.js */
var GlideReportChart = function GlideReportChart() {
  this.initialize.apply(this, arguments);
};
GlideReportChart.prototype = {
  initialize: function initialize(elemId1, elemId2, isGauge, chartSize, chartType, reportId, chartParams, chartHeight, chartWidth, sourceType) {
    this.chartContainerId = elemId1;
    this.msgContainerId = elemId2;
    this.isGauge = isGauge;
    this.chartSize = chartSize;
    this.chartHeight = chartHeight;
    this.chartWidth = chartWidth;
    this.chartOptions = {};
    this.chartingEngine = 'Highcharts';
    this.chartType = chartType;
    this.reportId = reportId;
    this.chartParams = chartParams;
    this.isPub = false;
    this.sourceType = sourceType;
    this.titleMargin = 50;
  },
  setPub: function setPub(isPub) {
    this.isPub = isPub;
  },
  showError: function showError(errorMsg) {
    document.getElementById(this.chartContainerId).innerHTML = '<div style="text-align:center;color:red">ERROR: ' + errorMsg + '</div>';
  },
  showWarning: function showWarning(warnMsg) {
    document.getElementById(this.msgContainerId).innerHTML = '<div style="text-align:center;color:black">WARNING: ' + warnMsg + '</div>';
  },
  showMessage: function showMessage(msg) {
    document.getElementById(this.msgContainerId).innerHTML = '<div style="text-align:center;color:black">' + msg + '</div>';
  },
  setRenderTo: function setRenderTo(elem) {
    this.chartOptions.renderTo = elem;
  },
  initDefaultChartOptions: function initDefaultChartOptions(chartData, aggType, stackedField) {
    var isRtl = (jQuery('html').hasClass('rtl') || jQuery('html').attr('dir') === 'rtl');
    var chartOptionsProps = hc_initDefaultChartOptions(this.chartOptions, chartData, this.chartType, this.chartSize, this.isGauge, this.isPub, this.chartContainerId, aggType, stackedField, true, this.chartHeight, this.chartWidth, isRtl) || {};
    var chartParamsObj = JSON.parse(this.chartParams);
    chartOptionsProps.other_threshold = chartParamsObj.other_threshold;
    chartOptionsProps.display_grid = chartParamsObj.display_grid;
    chartOptionsProps.show_other = chartParamsObj.show_other;
    chartOptionsProps.interactive_report = chartParamsObj.interactive_report;
    chartOptionsProps.page_num = chartParamsObj.page_num;
    chartOptionsProps.box_field = chartParamsObj.box_field;
    chartOptionsProps.filter_with_orderby = chartParamsObj.filter;
    chartOptionsProps.agg_field = chartParamsObj.agg_field;
    chartOptionsProps.other_series = chartParamsObj.other_series;
    chartOptionsProps.stack_field = chartParamsObj.stack_field;
    chartOptionsProps.box_field = chartParamsObj.box_field;
    chartOptionsProps.trend_field = chartParamsObj.trend_field;
    chartOptionsProps.trend_interval = chartParamsObj.trend_interval;
    chartOptionsProps.colors = chartParamsObj.colors;
    chartOptionsProps.sourceType = this.sourceType;
    return chartOptionsProps;
  },
  createBreadcrumbsMapChart: function createBreadcrumbsMapChart(reportId, containerId, breadcrumbs) {
    if (reportId) {
      var breadcrumbsContainer = jQuery('#' + containerId).siblings('.report_breadcrumbs')[0];
      if (breadcrumbsContainer) {
        var ol = document.createElement('ol');
        ol.className = 'breadcrumb';
        ol.style.marginBottom = '0';
        for (i = 0; i < breadcrumbs.length; i++) {
          var breadcrumb = breadcrumbs[i];
          var li = document.createElement('li');
          var text = document.createTextNode(breadcrumb.name);
          if (i === breadcrumbs.length - 1) {
            li.className = 'active';
            li.appendChild(text);
          } else {
            var a = document.createElement('a');
            a.setAttribute('href', 'javascript:void(0)');
            a.setAttribute('onclick', 'clickOnABreadcrumb(\'' + reportId + '\',\'' + containerId + '\',\'' + encodeURIComponent(JSON.stringify(breadcrumb.params)) + '\')');
            a.appendChild(text);
            li.appendChild(a);
          }
          ol.appendChild(li);
        }
        breadcrumbsContainer.appendChild(ol);
      }
    }
  },
  buildMetricBase: function buildMetricBase(chartData, chartParams) {
    this.showMessage('');
    this.chartOptions = chartData;
    if (this.chartContainerId)
      this.chartOptions.chart.renderTo = this.chartContainerId;
    hc_setHeightWidthChart(this.chartOptions, chartData, this.chartSize, this.isGauge, this.chartContainerId, chartParams.custom_chart_size, this.chartHeight, this.chartWidth);
    var props = {};
    props.sourceType = this.sourceType;
    props.display_grid = JSON.parse(this.chartParams).display_grid;
    props.isGauge = this.isGauge;
    props.isPub = this.isPub;
    var hcWrapper = new GlideHCWrapper(this.chartOptions, chartData, props, this.reportId, this.chartParams, this.chartSize, this.sourceType);
    hcWrapper.createMetricBase(chartParams, this.chartType);
  },
  buildGroupChartForSingleSeries: function buildGroupChartForSingleSeries(chartData, stackedField, aggType, sourceType) {
    this.showMessage('');
    if ('additional_msg' in chartData)
      this.showMessage(chartData.additional_msg);
    if ('additional_msg' in chartData.report_properties_series[0])
      this.showMessage(chartData.report_properties_series[0].additional_msg);
    if ('additional_msg' in chartData.report_properties_series[0])
      this.showMessage(chartData.report_properties_series[0].additional_msg);
    if (this.chartType !== 'heatmap' && 'warning' in chartData.series[0])
      this.showWarning(chartData.series[0].warning);
    if (this.chartingEngine === 'Highcharts') {
      if (this.chartType === 'map') {
        var reportId = this.reportId;
        var containerId = this.chartContainerId;
        var breadcrumbs = chartData.report_properties_series[0].breadcrumbs;
        this.createBreadcrumbsMapChart(reportId, containerId, breadcrumbs);
      }
      var props = this.initDefaultChartOptions(chartData, aggType, stackedField);
      var hcWrapper = new GlideHCWrapper(this.chartOptions, chartData, props, this.reportId, this.chartParams, this.chartSize, sourceType);
      hc_setLegendLabelFormatter(this.chartOptions, true, false);
      if (this.isBarType(this.chartType)) {
        if (stackedField === '')
          hcWrapper.createBarChart(this.chartType);
        else
          hcWrapper.createStackedBarChart(this.chartType);
      } else if (this.chartType === 'pie' || this.chartType === 'semi_donut' || this.chartType === 'donut')
        hcWrapper.createPieChart(this.chartType);
      else if (this.chartType === 'funnel')
        hcWrapper.createFunnelChart(this.chartType);
      else if (this.chartType === 'heatmap')
        hcWrapper.createHeatmapChart(this.chartType);
      else if (this.chartType === 'map')
        hcWrapper.createMapChart(this.chartType);
      else if (this.chartType === 'bubble')
        hcWrapper.createBubbleChart(this.chartType);
      else if (this.chartType === 'pyramid')
        hcWrapper.createPyramidChart(this.chartType);
      else if (this.chartType === 'hist')
        hcWrapper.createHistogramChart(this.chartType);
      else if (this.chartType === 'pareto')
        hcWrapper.createParetoChart(this.chartType);
      else if (this.chartType === 'box' || this.chartType === 'tbox')
        hcWrapper.createBoxChart(this.chartType);
      else if (this.chartType === 'trend')
        hcWrapper.createTrendChart(this.chartType);
      else if (isLineType(this.chartType))
        hcWrapper.createLineChart(this.chartType);
      else if (this.chartType === 'control')
        hcWrapper.createControlChart(this.chartType);
      else if (this.chartType === 'availability')
        hcWrapper.createAvailChart(this.chartType);
      else if (this.chartType === 'angular_gauge' || this.chartType === 'solid_gauge')
        hcWrapper.createGaugeChart(this.chartType);
    }
  },
  isBarType: function isBarType(type) {
    if (type === 'bar' || type === 'horizontal_bar')
      return true;
    return false;
  },
  isLineType: function isLineType(type) {
    return (type === 'line' || type === 'area' || type === 'spline' || type === 'line_bar' || type === 'step_line');
  },
  type: 'GlideReportChart'
};;
/*! RESOURCE: /scripts/reportcommon/GlideHCWrapper.js */
var GlideHCWrapper = function GlideHCWrapper() {
  this.initialize.apply(this, arguments);
};
GlideHCWrapper.prototype = {
  initialize: function initialize(defaultChartOptions, data, chartProps, reportId, chartParams, chartSize, sourceType) {
    this.chartOptions = defaultChartOptions;
    this.chartData = data;
    this.chartProps = chartProps;
    this.chartSize = chartSize;
    this.chartPropsSeries = data.report_properties_series;
    this.isReportViewer = window.location.pathname.indexOf('report_viewer.do') !== -1;
    this.defaultFontFamily = 'Helvetica';
    this.otherDisplay = 'Other';
    this.otherDisplayMore = '(more...)';
    this.isGauge = chartProps.isGauge;
    this.origXValues = [];
    this.xValues = [];
    this.maxAllowedLabelLen = 20;
    this.grayColor = '#666';
    this.blackColor = '#000';
    this.aggType = chartProps.aggType;
    this.otherKey = 'zzyynomatchaabb';
    this.chartType = chartProps.chartType;
    this.report_properties = {};
    if (chartProps.isPub) {
      this.chartOptions.exporting = {};
      this.chartOptions.exporting.enabled = false;
    } else
      this.setupExportOptions(reportId, chartParams, chartProps.isGauge);
    if (sourceType !== 'metricbase') {
      this.report_properties = {};
      if ('report_properties' in data) {
        this.report_properties = data.report_properties;
        if ('font_family' in this.report_properties && this.report_properties.font_family !== '')
          this.defaultFontFamily = this.report_properties.font_family;
        this.otherDisplay = this.report_properties.other_display;
        this.otherDisplayMore = this.report_properties.other_display_more;
      }
      this.chartOptions.publisher_id = this.chartData.report_properties.publisher_id;
      this.chartOptions.report_id = this.chartData.report_properties.report_id;
      this.isPublisher = false;
      var gridWindow = '';
      if (typeof glideGrid !== 'undefined') {
        gridWindow = glideGrid.getWindowByGaugeId(this.chartOptions.publisher_id);
        if (typeof gridWindow === 'undefined' || !gridWindow)
          gridWindow = glideGrid.getWindowByGaugeId(this.chartOptions.report_id);
      } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
        gridWindow = SNC.canvas.canvasUtils.getGlideWindow(this.chartOptions.report_id);
        if (!gridWindow)
          gridWindow = SNC.canvas.canvasUtils.getGlideWindow(this.chartOptions.publisher_id);
      }
      if (typeof gridWindow !== 'undefined' && gridWindow) {
        var publisherWidget = gridWindow.getPreference('publisher_widget');
        this.isPublisher = publisherWidget === 'true';
      }
    }
    this.chartOptions.credits = {
      enabled: false
    };
  },
  setupExportOptions: function setupExportOptions(reportId, chartParams, isGauge) {
    if (!this.chartData.series.length || (this.chartData.series[0].xvalues && !this.chartData.series[0].xvalues.length)) {
      this.chartOptions.exporting = false;
      return;
    }
    this.chartOptions.exporting = {};
    this.chartOptions.exporting.enabled = !(typeof chartHelpers !== 'undefined' && chartHelpers && chartHelpers.device) ||
      (chartHelpers.device.type !== 'mobile' && chartHelpers.device.type !== 'm' && chartHelpers.device.type !== 'tablet');
    this.chartOptions.exporting.reportId = reportId;
    this.chartOptions.exporting.isGauge = isGauge;
    var jsonParameters = JSON.parse(chartParams);
    jsonParameters.is_gauge = isGauge;
    this.chartOptions.exporting.params = JSON.stringify(jsonParameters);
    this.chartOptions.exporting.buttons = {
      contextButton: {
        align: 'right',
        x: 0,
        y: -2,
        theme: {
          stroke: 'silver'
        },
        menuItems: []
      }
    };
    var oldFirefox = false;
    if (window.isFirefox && this.getVersion('firefox') < '40')
      oldFirefox = true;
    var oldChrome = false;
    if (window.isChrome && this.getVersion('chrome') < '64')
      oldChrome = true;
    var isEdge = this.isBrowser('edge');
    var oldBrowser = window.isMSIE9 || window.isMSIE10 || oldFirefox || oldChrome || isEdge;
    this.chartOptions.exporting.downloadMsg = chartHelpers.i18n.downloadComplete;
    var self = this;
    var item1 = {};
    var item2 = {};
    item1.text = chartHelpers.i18n.saveAsPng;
    item2.text = chartHelpers.i18n.saveAsJpg;
    if (oldBrowser)
      this.chartOptions.exporting.enabled = false;
    if (window.isSafari || jsonParameters.chart_type === 'pareto') {
      item1.onclick = function() {
        self.saveChartServerSide('png', this)
      };
      item2.onclick = function() {
        self.saveChartServerSide('jpg', this)
      };
    } else {
      item1.onclick = function() {
        self.saveChartClientSide('png', this)
      };
      item2.onclick = function() {
        self.saveChartClientSide('jpg', this)
      };
    }
    this.chartOptions.exporting.buttons.contextButton.menuItems.push(item1);
    this.chartOptions.exporting.buttons.contextButton.menuItems.push(item2);
  },
  getVersion: function(browser) {
    var userAgent = navigator.userAgent.toLowerCase()
    userAgent = userAgent.substring(userAgent.indexOf(browser + '/') + (browser === 'firefox' ? 8 : 7));
    userAgent = userAgent.substring(0, userAgent.indexOf('.'));
    var version = userAgent;
    return version;
  },
  isBrowser: function(browser) {
    var userAgent = navigator.userAgent.toLowerCase()
    return userAgent.indexOf(browser.toLowerCase()) > 0;
  },
  saveChartClientSide: function(type, obj) {
    if (typeof obj.options.exporting == '')
      obj.options.exporting = {};
    obj.options.exporting.fallbackToExportServer = false;
    obj.options.exporting.type = 'image/' + type;
    var titleReport = obj.options.title.text;
    if (titleReport) {
      titleReport = titleReport.length > 100 ? titleReport.substring(0, 100) : titleReport;
      titleReport = titleReport.replace(/\s+/g, "_");
      obj.options.exporting.filename = titleReport;
    }
    var expParams = JSON.parse(obj.options.exporting.params);
    var widthTmp = obj.options.chart.width;
    var heightTmp = obj.options.chart.height;
    obj.options.chart.width = expParams.chart_width;
    obj.options.chart.height = expParams.chart_height;
    obj.exportChartLocal();
    obj.options.chart.width = widthTmp;
    obj.options.chart.height = heightTmp;
    this.showMessage(obj.options.exporting.downloadMsg, 'info', 8000);
  },
  showMessage: function showMessage(message, type, timeInMiliSeconds) {
    if (message) {
      var span = document.createElement('span');
      span.setAttribute('data-type', (type ? type : this.msgType.type_default));
      span.setAttribute('data-text', message);
      span.setAttribute('data-duration', (timeInMiliSeconds ? timeInMiliSeconds : '5000'));
      if (typeof GlideUI !== 'undefined')
        GlideUI.get().fire(new GlideUINotification({
          xml: span
        }));
    }
  },
  saveChartServerSide: function(type, obj) {
    var reportDetails = {};
    reportDetails['report_id'] = obj.options.exporting.reportId;
    reportDetails['is_gauge'] = obj.options.exporting.isGauge;
    var chartExportParams = obj.options.exporting.params;
    obj.options.exporting.fallbackToExportServer = true;
    if (chartExportParams === '')
      hc_saveChart('report_id', 'hcexport_' + type, JSON.stringify(reportDetails));
    else
      hc_saveChart('report_params', 'hcexport_' + type, chartExportParams);
  },
  createHeatmapChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var curSeries = hc_createHeatmapSeriesData(this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_addHeatmapChartOptions(this.chartOptions, this.chartProps, true, this.chartData, curSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_addHeatmapAxisCategories(this.chartOptions, this.chartData);
    hc_sanitizeCategoryValues(this.chartOptions, this.chartProps);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createMapChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addMapChartOptions(this.chartOptions, this.chartProps, true, this.chartData);
    var curSeries = hc_createMapSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series = curSeries;
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_updateDataLabelOptionsGeographical(this.chartOptions, this.chartData, this.chartType);
    hc_updateMapVisualizationOptions(this.chartOptions, this.chartData, this.chartProps);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart(true);
  },
  createBubbleChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createBubbleSeriesData(this.chartData, this.chartProps, true);
    this.chartOptions.xAxis = this.chartData.series[0].xAxis;
    this.chartOptions.yAxis = this.chartData.series[0].yAxis;
    hc_addBubbleChartOptions(this.chartOptions, true, this.chartData.series[0].legend.enabled);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createBarChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBarChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createMultipleSeriesData(this.chartOptions, this.chartData, this.chartProps, true, this.chartPropsSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createMetricBase: function(chartParams, chartType) {
    if (chartParams.show_chart_title === 'never' || (this.isGauge && chartParams.show_chart_title === 'report')) {
      this.chartOptions.title = {};
      this.chartOptions.title.text = '';
    }
    hc_configureLegendAlignment(chartType, chartParams, this.chartOptions, false, true);
    hc_setLegendLabelFormatter(this.chartOptions, true, false);
    this.chartOptions.series.forEach(function(series) {
      series.dataLabels = series.dataLabels || {};
      series.dataLabels.formatter = hc_formatValueLabel;
    });
    this.renderChart();
  },
  createStackedBarChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addStackedBarChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true, this.chartPropsSeries);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createMultipleSeriesData(this.chartOptions, this.chartData, this.chartProps, true, this.chartPropsSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, 'trend', true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createPieChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addPieChartOptions(this.chartOptions, this.chartProps, true, chartType == "semi_donut", this.isPublisher);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    if (chartType == "semi_donut" || chartType == "donut") {
      curSeries.innerSize = (100 - this.chartProps.report_properties.donut_width_percent) + "%";
      if (this.chartProps.report_properties.show_chart_total)
        hc_addTotal(this.chartOptions, this.chartProps, curSeries, this.chartData);
    }
    this.chartOptions.series.push(curSeries);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createFunnelChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addFunnelChartOptions(this.chartOptions, this.chartProps, true, this.chartData, this.isPublisher);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createPyramidChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addPyramidChartOptions(this.chartOptions, this.chartProps, true, this.chartData, this.isPublisher);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createGaugeChart: function(chartType) {
    hc_addGaugeChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, 'gauge', true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createHistogramChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addHistogramOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var histogramSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(histogramSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createBoxChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBoxChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var boxSeries = hc_createBoxPlotData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(boxSeries);
    var meanSeries = hc_createBoxMeanData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(meanSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createParetoChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBarChartOptions(this.chartOptions, this.chartProps, this.chartData, 'column', true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.plotOptions.column.point = {};
    this.chartOptions.plotOptions.column.point.events = {};
    this.chartOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
    var series0 = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(series0);
    var cumulative_series = hc_createParetoCumulSeries(this.chartOptions, this.chartProps, series0, true);
    this.chartOptions.series.push(cumulative_series);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createTrendChart: function(chartType) {
    if ('sub_series' in this.chartData.series[0])
      this.createStackedBarChart();
    else
      this.createBarChart('trend');
  },
  createLineChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addLineChartOptions(this.chartOptions, this.chartProps, this.chartData, true, chartType);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createLineSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createAvailChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addAvailChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createLineSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createControlChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addControlChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    this.chartOptions.series = hc_createControlSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  renderChart: function renderChart(isMap) {
    var chart;
    var chartData = this.chartData;
    var chartType = this.chartProps.chartType;
    var self = this;
    if (typeof isMap === 'undefined' || isMap !== true) {
      this.setAnimation(chartData);
      chart = new Highcharts.Chart(this.chartOptions);
    } else
      chart = new Highcharts.Map(this.chartOptions, function(chart) {
        var reportId = self.chartOptions.mapVisualization.report_id;
        if (reportId) {
          var iconHeatmap = '/images/icons/button-heatmap.png';
          var iconHeatmapActive = '/images/icons/button-heatmap-selected.png';
          var iconMarker = '/images/icons/button-pin.png';
          var iconMarkerActive = '/images/icons/button-pin-selected.png';
          var heatmapImg;
          var markerImg;
          var isLastLevel = chartData.report_properties_series[0].map_source.is_map_source_last_level;
          var containsLatLonLevel = chartData.report_properties_series[0].map_source.map_source_contains_lat_lon_level;
          var showPinLocations = containsLatLonLevel && !isLastLevel;
          var useLatLon = chartData.report_properties_series[0].map_source.use_lat_lon;
          if (showPinLocations && !chart.options.chart.forExport) {
            if (!useLatLon) {
              heatmapImg = chart.renderer.image(iconHeatmapActive, chart.chartWidth - 85, 10, 20, 20);
              markerImg = chart.renderer.image(iconMarker, chart.chartWidth - 60, 10, 20, 20);
            } else {
              heatmapImg = chart.renderer.image(iconHeatmap, chart.chartWidth - 85, 10, 20, 20);
              markerImg = chart.renderer.image(iconMarkerActive, chart.chartWidth - 60, 10, 20, 20);
            }
            heatmapImg.add();
            heatmapImg.css({
              cursor: 'pointer'
            });
            heatmapImg.attr({
              title: chartHelpers.i18n.showAsHeatmap,
              class: 'hc-image'
            });
            heatmapImg.on('click', function clickHeatmapImg(ev) {
              heatmapImg.attr({
                href: iconHeatmapActive
              });
              markerImg.attr({
                href: iconMarker
              });
              self.onClickCustomButton(ev, 'heatmap', reportId);
            });
            markerImg.add();
            markerImg.css({
              cursor: 'pointer'
            });
            markerImg.attr({
              title: chartHelpers.i18n.showAsMarkers,
              class: 'hc-image'
            });
            markerImg.on('click', function clickMarkerImg(ev) {
              markerImg.attr({
                href: iconMarkerActive
              });
              heatmapImg.attr({
                href: iconHeatmap
              });
              self.onClickCustomButton(ev, 'marker', reportId);
            });
          }
        }
      });
    var chartsWithDataTable = ['control', 'heatmap', 'bubble', 'tbox', 'box', 'hist'];
    var containerId = this.chartOptions.chart.renderTo;
    var shouldDisplayGridMetricbase = self.chartProps.sourceType === 'metricbase' && self.chartProps.display_grid;
    if (((window.g_accessibility === 'true' || window.g_accessibility === true) && chartsWithDataTable.indexOf(chartType) > -1) || shouldDisplayGridMetricbase === true || shouldDisplayGridMetricbase === 'true') {
      chart.viewData();
      jQuery('#' + containerId).siblings('.highcharts-data-table').find('table').attr('tabindex', 0);
    }
    jQuery('#' + containerId + '>div[role=region] h3,#' + containerId + '> h3, #' + containerId + '>div[role=region]>div[tabindex=0]').remove();
    if (chart.exportSVGElements && chart.exportSVGElements[0])
      chart.exportSVGElements[0].toFront();
    var isCanvas = window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils;
    var rootReportId;
    if (this.isReportViewer || (isCanvas && containerId.indexOf('preview') === -1)) {
      if (isCanvas) {
        rootReportId = jQuery('#' + containerId).closest('.grid-stack-item').find('.sysparm_root_report_id').first().val();
        var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(rootReportId);
        if (uuid) {
          window.SNC.reportResizingFunctions = window.SNC.reportResizingFunctions || {};
          SNC.canvas.eventbus.subscribe(uuid, this.resizeChartFromCanvas.bind(this));
          SNC.reportResizingFunctions[uuid] = this.resizeChartFromCanvas;
        }
      } else
        rootReportId = jQuery('#' + containerId).parent().parent().find('.sysparm_root_report_id').first().val();
      window.SNC = window.SNC || {};
      window.SNC.reportResizingTimeouts = window.SNC.reportResizingTimeouts || {};
      window.addEventListener('resize', function() {
        if (SNC.reportResizingTimeouts[rootReportId])
          clearTimeout(SNC.reportResizingTimeouts[rootReportId]);
        SNC.reportResizingTimeouts[rootReportId] = setTimeout(function() {
          var containerDimensions = hc_getDimensions(containerId, true);
          chart.setSize(containerDimensions.width, containerDimensions.height);
        }, 250);
      }, false);
    }
    this.applyPreviousStateForInteractiveFilter(chart);
  },
  setAnimation: function(chartData) {
    this.chartOptions.plotOptions = this.chartOptions.plotOptions || {};
    this.chartOptions.plotOptions.series = this.chartOptions.plotOptions.series || {};
    this.chartOptions.plotOptions.series.animation = chartData.report_properties.chart_animation;
    this.chartOptions.chart.animation = chartData.report_properties.chart_animation;
    var isEdge = this.isBrowser('edge');
    var isMSIE11 = this.isBrowser('trident');
    if (window.isMSIE || isMSIE11 || isEdge) {
      this.chartOptions.plotOptions.series.animation = false;
      this.chartOptions.chart.animation = false;
    }
  },
  applyPreviousStateForInteractiveFilter: function(chart) {
    var isChartFilterable = this.chartProps.chartType == 'pie' || this.chartProps.chartType == 'semi_donut' || this.chartProps.chartType == 'donut' ||
      this.chartProps.chartType == 'funnel' || this.chartProps.chartType == 'pyramid';
    if (isChartFilterable) {
      if (this.chartProps.interactive_report) {
        var interActiveReport = JSON.parse(this.chartProps.interactive_report);
        var selectedPointUrl = interActiveReport.selectedPoint || "";
        var filtersFromLegend = interActiveReport.filtersFromLegend || {};
        chart.series[0].data.forEach(function(dataPoint) {
          if (dataPoint['publisher_filter']) {
            var url = dataPoint['publisher_filter'].replace("^", "^EQ^");
            if (url === selectedPointUrl)
              dataPoint.select('select', 'preventDataPointSelect');
            url = dataPoint['publisher_filter'];
            if (filtersFromLegend[url])
              dataPoint.setVisible(false);
          }
        });
      }
    }
  },
  resizeChartFromCanvas: function resizeChartFromCanvas(data) {
    if (data.action === 'resize') {
      var containerId = this.chartOptions.chart.renderTo;
      var chart = jQuery('#' + containerId).highcharts();
      if (chart) {
        var containerDimensions = hc_getDimensions(containerId, true);
        chart.setSize(containerDimensions.width, containerDimensions.height);
      }
    }
  },
  onClickCustomButton: function onClickCustomButton(event, button, reportId) {
    if (typeof this.chartOptions.mapVisualization !== 'undefined') {
      var mapVis = this.chartOptions.mapVisualization;
      var fullQuery = mapVis.full_query;
      var showDataLabel = mapVis.show_data_label;
      var showGeographicalLabel = mapVis.show_geographical_label;
      var mapParams = '';
      var element = event.srcElement;
      if (!element)
        element = event.target;
      var content = jQuery(element).closest(".report_content");
      if (reportId) {
        var actualMap = mapVis.report_drilldown_map;
        if (actualMap)
          mapParams += "sysparm_report_map_parent=" + actualMap;
        if (showDataLabel)
          mapParams += "&sysparm_show_chart_data_label=" + showDataLabel;
        if (showGeographicalLabel)
          mapParams += "&sysparm_show_geographical_label=" + showGeographicalLabel;
        if (fullQuery)
          mapParams += "&sysparm_full_query_map=" + fullQuery;
        if (button === 'heatmap')
          mapParams += '&sysparm_report_map_exact_points=false';
        else
          mapParams += '&sysparm_report_map_exact_points=true';
        drillReport(content.parent(), reportId, '', mapParams);
      }
    }
  },
  getHighChartsType: function getHighChartsType(snType) {
    if (snType == 'bar' || snType == 'trend')
      return 'column';
    else if (snType == 'horizontal_bar')
      return 'bar';
    else if (snType == 'pie')
      return 'pie';
    else if (snType == 'semi_donut')
      return 'pie';
    else if (snType == 'donut')
      return 'pie';
    else if (snType == 'funnel')
      return 'funnel';
    else if (snType == 'pyramid')
      return 'funnel';
    else if (snType == 'box')
      return 'boxplot';
    else if (snType == 'angular_gauge')
      return 'gauge';
    else if (snType == 'solid_gauge')
      return 'solidgauge';
    else if (snType == 'heatmap')
      return 'heatmap';
    else if (snType == 'bubble')
      return 'bubble';
    else
      return "";
  },
  type: "GlideHCWrapper"
};;
/*! RESOURCE: /scripts/glide-highcharts.js */
/*! RESOURCE: /scripts/highcharts/highstock.src.js */
'use strict';
(function(root, factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = root.document ?
      factory(root) :
      factory;
  } else {
    root.Highcharts = factory(root);
  }
}(typeof window !== 'undefined' ? window : this, function(win) {
  var Highcharts = (function() {
    'use strict';
    var win = window,
      doc = win.document;
    var SVG_NS = 'http://www.w3.org/2000/svg',
      userAgent = (win.navigator && win.navigator.userAgent) || '',
      svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
      isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,
      vml = !svg,
      isFirefox = /Firefox/.test(userAgent),
      hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4;
    var Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {
      product: 'Highstock',
      version: '5.0.7',
      deg2rad: Math.PI * 2 / 360,
      doc: doc,
      hasBidiBug: hasBidiBug,
      hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
      isMS: isMS,
      isWebKit: /AppleWebKit/.test(userAgent),
      isFirefox: isFirefox,
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
      SVG_NS: SVG_NS,
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: svg,
      vml: vml,
      win: win,
      charts: [],
      marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
      noop: function() {
        return undefined;
      }
    };
    return Highcharts;
  }());
  (function(H) {
    'use strict';
    var timers = [];
    var charts = H.charts,
      doc = H.doc,
      win = H.win;
    H.error = function(code, stop) {
      var msg = H.isNumber(code) ?
        'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :
        code;
      if (stop) {
        throw new Error(msg);
      }
      if (win.console) {
        console.log(msg);
      }
    };
    H.Fx = function(elem, options, prop) {
      this.options = options;
      this.elem = elem;
      this.prop = prop;
    };
    H.Fx.prototype = {
      dSetter: function() {
        var start = this.paths[0],
          end = this.paths[1],
          ret = [],
          now = this.now,
          i = start.length,
          startVal;
        if (now === 1) {
          ret = this.toD;
        } else if (i === end.length && now < 1) {
          while (i--) {
            startVal = parseFloat(start[i]);
            ret[i] =
              isNaN(startVal) ?
              start[i] :
              now * (parseFloat(end[i] - startVal)) + startVal;
          }
        } else {
          ret = end;
        }
        this.elem.attr('d', ret, null, true);
      },
      update: function() {
        var elem = this.elem,
          prop = this.prop,
          now = this.now,
          step = this.options.step;
        if (this[prop + 'Setter']) {
          this[prop + 'Setter']();
        } else if (elem.attr) {
          if (elem.element) {
            elem.attr(prop, now, null, true);
          }
        } else {
          elem.style[prop] = now + this.unit;
        }
        if (step) {
          step.call(elem, now, this);
        }
      },
      run: function(from, to, unit) {
        var self = this,
          timer = function(gotoEnd) {
            return timer.stopped ? false : self.step(gotoEnd);
          },
          i;
        this.startTime = +new Date();
        this.start = from;
        this.end = to;
        this.unit = unit;
        this.now = this.start;
        this.pos = 0;
        timer.elem = this.elem;
        timer.prop = this.prop;
        if (timer() && timers.push(timer) === 1) {
          timer.timerId = setInterval(function() {
            for (i = 0; i < timers.length; i++) {
              if (!timers[i]()) {
                timers.splice(i--, 1);
              }
            }
            if (!timers.length) {
              clearInterval(timer.timerId);
            }
          }, 13);
        }
      },
      step: function(gotoEnd) {
        var t = +new Date(),
          ret,
          done,
          options = this.options,
          elem = this.elem,
          complete = options.complete,
          duration = options.duration,
          curAnim = options.curAnim,
          i;
        if (elem.attr && !elem.element) {
          ret = false;
        } else if (gotoEnd || t >= duration + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          curAnim[this.prop] = true;
          done = true;
          for (i in curAnim) {
            if (curAnim[i] !== true) {
              done = false;
            }
          }
          if (done && complete) {
            complete.call(elem);
          }
          ret = false;
        } else {
          this.pos = options.easing((t - this.startTime) / duration);
          this.now = this.start + ((this.end - this.start) * this.pos);
          this.update();
          ret = true;
        }
        return ret;
      },
      initPath: function(elem, fromD, toD) {
        fromD = fromD || '';
        var shift,
          startX = elem.startX,
          endX = elem.endX,
          bezier = fromD.indexOf('C') > -1,
          numParams = bezier ? 7 : 3,
          fullLength,
          slice,
          i,
          start = fromD.split(' '),
          end = toD.slice(),
          isArea = elem.isArea,
          positionFactor = isArea ? 2 : 1,
          reverse;

        function sixify(arr) {
          var isOperator,
            nextIsOperator;
          i = arr.length;
          while (i--) {
            isOperator = arr[i] === 'M' || arr[i] === 'L';
            nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);
            if (isOperator && nextIsOperator) {
              arr.splice(
                i + 1, 0,
                arr[i + 1], arr[i + 2],
                arr[i + 1], arr[i + 2]
              );
            }
          }
        }

        function insertSlice(arr, subArr, index) {
          [].splice.apply(
            arr, [index, 0].concat(subArr)
          );
        }

        function prepend(arr, other) {
          while (arr.length < fullLength) {
            arr[0] = other[fullLength - arr.length];
            insertSlice(arr, arr.slice(0, numParams), 0);
            if (isArea) {
              insertSlice(
                arr,
                arr.slice(arr.length - numParams), arr.length
              );
              i--;
            }
          }
          arr[0] = 'M';
        }

        function append(arr, other) {
          var i = (fullLength - arr.length) / numParams;
          while (i > 0 && i--) {
            slice = arr.slice().splice(
              (arr.length / positionFactor) - numParams,
              numParams * positionFactor
            );
            slice[0] = other[fullLength - numParams - (i * numParams)];
            if (bezier) {
              slice[numParams - 6] = slice[numParams - 2];
              slice[numParams - 5] = slice[numParams - 1];
            }
            insertSlice(arr, slice, arr.length / positionFactor);
            if (isArea) {
              i--;
            }
          }
        }
        if (bezier) {
          sixify(start);
          sixify(end);
        }
        if (startX && endX) {
          for (i = 0; i < startX.length; i++) {
            if (startX[i] === endX[0]) {
              shift = i;
              break;
            } else if (startX[0] ===
              endX[endX.length - startX.length + i]) {
              shift = i;
              reverse = true;
              break;
            }
          }
          if (shift === undefined) {
            start = [];
          }
        }
        if (start.length && H.isNumber(shift)) {
          fullLength = end.length + shift * positionFactor * numParams;
          if (!reverse) {
            prepend(end, start);
            append(start, end);
          } else {
            prepend(start, end);
            append(end, start);
          }
        }
        return [start, end];
      }
    };
    H.extend = function(a, b) {
      var n;
      if (!a) {
        a = {};
      }
      for (n in b) {
        a[n] = b[n];
      }
      return a;
    };
    H.merge = function() {
      var i,
        args = arguments,
        len,
        ret = {},
        doCopy = function(copy, original) {
          var value, key;
          if (typeof copy !== 'object') {
            copy = {};
          }
          for (key in original) {
            if (original.hasOwnProperty(key)) {
              value = original[key];
              if (H.isObject(value, true) &&
                key !== 'renderTo' &&
                typeof value.nodeType !== 'number') {
                copy[key] = doCopy(copy[key] || {}, value);
              } else {
                copy[key] = original[key];
              }
            }
          }
          return copy;
        };
      if (args[0] === true) {
        ret = args[1];
        args = Array.prototype.slice.call(args, 2);
      }
      len = args.length;
      for (i = 0; i < len; i++) {
        ret = doCopy(ret, args[i]);
      }
      return ret;
    };
    H.pInt = function(s, mag) {
      return parseInt(s, mag || 10);
    };
    H.isString = function(s) {
      return typeof s === 'string';
    };
    H.isArray = function(obj) {
      var str = Object.prototype.toString.call(obj);
      return str === '[object Array]' || str === '[object Array Iterator]';
    };
    H.isObject = function(obj, strict) {
      return obj && typeof obj === 'object' && (!strict || !H.isArray(obj));
    };
    H.isNumber = function(n) {
      return typeof n === 'number' && !isNaN(n);
    };
    H.erase = function(arr, item) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === item) {
          arr.splice(i, 1);
          break;
        }
      }
    };
    H.defined = function(obj) {
      return obj !== undefined && obj !== null;
    };
    H.attr = function(elem, prop, value) {
      var key,
        ret;
      if (H.isString(prop)) {
        if (H.defined(value)) {
          elem.setAttribute(prop, value);
        } else if (elem && elem.getAttribute) {
          ret = elem.getAttribute(prop);
        }
      } else if (H.defined(prop) && H.isObject(prop)) {
        for (key in prop) {
          elem.setAttribute(key, prop[key]);
        }
      }
      return ret;
    };
    H.splat = function(obj) {
      return H.isArray(obj) ? obj : [obj];
    };
    H.syncTimeout = function(fn, delay, context) {
      if (delay) {
        return setTimeout(fn, delay, context);
      }
      fn.call(0, context);
    };
    H.pick = function() {
      var args = arguments,
        i,
        arg,
        length = args.length;
      for (i = 0; i < length; i++) {
        arg = args[i];
        if (arg !== undefined && arg !== null) {
          return arg;
        }
      }
    };
    H.css = function(el, styles) {
      if (H.isMS && !H.svg) {
        if (styles && styles.opacity !== undefined) {
          styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
        }
      }
      H.extend(el.style, styles);
    };
    H.createElement = function(tag, attribs, styles, parent, nopad) {
      var el = doc.createElement(tag),
        css = H.css;
      if (attribs) {
        H.extend(el, attribs);
      }
      if (nopad) {
        css(el, {
          padding: 0,
          border: 'none',
          margin: 0
        });
      }
      if (styles) {
        css(el, styles);
      }
      if (parent) {
        parent.appendChild(el);
      }
      return el;
    };
    H.extendClass = function(parent, members) {
      var object = function() {};
      object.prototype = new parent();
      H.extend(object.prototype, members);
      return object;
    };
    H.pad = function(number, length, padder) {
      return new Array((length || 2) + 1 -
        String(number).length).join(padder || 0) + number;
    };
    H.relativeLength = function(value, base) {
      return (/%$/).test(value) ?
        base * parseFloat(value) / 100 :
        parseFloat(value);
    };
    H.wrap = function(obj, method, func) {
      var proceed = obj[method];
      obj[method] = function() {
        var args = Array.prototype.slice.call(arguments),
          outerArgs = arguments,
          ctx = this,
          ret;
        ctx.proceed = function() {
          proceed.apply(ctx, arguments.length ? arguments : outerArgs);
        };
        args.unshift(proceed);
        ret = func.apply(this, args);
        ctx.proceed = null;
        return ret;
      };
    };
    H.getTZOffset = function(timestamp) {
      var d = H.Date;
      return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) ||
        d.hcTimezoneOffset || 0) * 60000;
    };
    H.dateFormat = function(format, timestamp, capitalize) {
      if (!H.defined(timestamp) || isNaN(timestamp)) {
        return H.defaultOptions.lang.invalidDate || '';
      }
      format = H.pick(format, '%Y-%m-%d %H:%M:%S');
      var D = H.Date,
        date = new D(timestamp - H.getTZOffset(timestamp)),
        key,
        hours = date[D.hcGetHours](),
        day = date[D.hcGetDay](),
        dayOfMonth = date[D.hcGetDate](),
        month = date[D.hcGetMonth](),
        fullYear = date[D.hcGetFullYear](),
        lang = H.defaultOptions.lang,
        langWeekdays = lang.weekdays,
        shortWeekdays = lang.shortWeekdays,
        pad = H.pad,
        replacements = H.extend({
          'a': shortWeekdays ?
            shortWeekdays[day] : langWeekdays[day].substr(0, 3),
          'A': langWeekdays[day],
          'd': pad(dayOfMonth),
          'e': pad(dayOfMonth, 2, ' '),
          'w': day,
          'b': lang.shortMonths[month],
          'B': lang.months[month],
          'm': pad(month + 1),
          'y': fullYear.toString().substr(2, 2),
          'Y': fullYear,
          'H': pad(hours),
          'k': hours,
          'I': pad((hours % 12) || 12),
          'l': (hours % 12) || 12,
          'M': pad(date[D.hcGetMinutes]()),
          'p': hours < 12 ? 'AM' : 'PM',
          'P': hours < 12 ? 'am' : 'pm',
          'S': pad(date.getSeconds()),
          'L': pad(Math.round(timestamp % 1000), 3)
        }, H.dateFormats);
      for (key in replacements) {
        while (format.indexOf('%' + key) !== -1) {
          format = format.replace(
            '%' + key,
            typeof replacements[key] === 'function' ?
            replacements[key](timestamp) :
            replacements[key]
          );
        }
      }
      return capitalize ?
        format.substr(0, 1).toUpperCase() + format.substr(1) :
        format;
    };
    H.formatSingle = function(format, val) {
      var floatRegex = /f$/,
        decRegex = /\.([0-9])/,
        lang = H.defaultOptions.lang,
        decimals;
      if (floatRegex.test(format)) {
        decimals = format.match(decRegex);
        decimals = decimals ? decimals[1] : -1;
        if (val !== null) {
          val = H.numberFormat(
            val,
            decimals,
            lang.decimalPoint,
            format.indexOf(',') > -1 ? lang.thousandsSep : ''
          );
        }
      } else {
        val = H.dateFormat(format, val);
      }
      return val;
    };
    H.format = function(str, ctx) {
      var splitter = '{',
        isInside = false,
        segment,
        valueAndFormat,
        path,
        i,
        len,
        ret = [],
        val,
        index;
      while (str) {
        index = str.indexOf(splitter);
        if (index === -1) {
          break;
        }
        segment = str.slice(0, index);
        if (isInside) {
          valueAndFormat = segment.split(':');
          path = valueAndFormat.shift().split('.');
          len = path.length;
          val = ctx;
          for (i = 0; i < len; i++) {
            val = val[path[i]];
          }
          if (valueAndFormat.length) {
            val = H.formatSingle(valueAndFormat.join(':'), val);
          }
          ret.push(val);
        } else {
          ret.push(segment);
        }
        str = str.slice(index + 1);
        isInside = !isInside;
        splitter = isInside ? '}' : '{';
      }
      ret.push(str);
      return ret.join('');
    };
    H.getMagnitude = function(num) {
      return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
    };
    H.normalizeTickInterval = function(interval, multiples, magnitude,
      allowDecimals, hasTickAmount) {
      var normalized,
        i,
        retInterval = interval;
      magnitude = H.pick(magnitude, 1);
      normalized = interval / magnitude;
      if (!multiples) {
        multiples = hasTickAmount ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10];
        if (allowDecimals === false) {
          if (magnitude === 1) {
            multiples = H.grep(multiples, function(num) {
              return num % 1 === 0;
            });
          } else if (magnitude <= 0.1) {
            multiples = [1 / magnitude];
          }
        }
      }
      for (i = 0; i < multiples.length; i++) {
        retInterval = multiples[i];
        if ((hasTickAmount && retInterval * magnitude >= interval) ||
          (!hasTickAmount && (normalized <= (multiples[i] +
            (multiples[i + 1] || multiples[i])) / 2))) {
          break;
        }
      }
      retInterval = H.correctFloat(
        retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10)
      );
      return retInterval;
    };
    H.stableSort = function(arr, sortFunction) {
      var length = arr.length,
        sortValue,
        i;
      for (i = 0; i < length; i++) {
        arr[i].safeI = i;
      }
      arr.sort(function(a, b) {
        sortValue = sortFunction(a, b);
        return sortValue === 0 ? a.safeI - b.safeI : sortValue;
      });
      for (i = 0; i < length; i++) {
        delete arr[i].safeI;
      }
    };
    H.arrayMin = function(data) {
      var i = data.length,
        min = data[0];
      while (i--) {
        if (data[i] < min) {
          min = data[i];
        }
      }
      return min;
    };
    H.arrayMax = function(data) {
      var i = data.length,
        max = data[0];
      while (i--) {
        if (data[i] > max) {
          max = data[i];
        }
      }
      return max;
    };
    H.destroyObjectProperties = function(obj, except) {
      var n;
      for (n in obj) {
        if (obj[n] && obj[n] !== except && obj[n].destroy) {
          obj[n].destroy();
        }
        delete obj[n];
      }
    };
    H.discardElement = function(element) {
      var garbageBin = H.garbageBin;
      if (!garbageBin) {
        garbageBin = H.createElement('div');
      }
      if (element) {
        garbageBin.appendChild(element);
      }
      garbageBin.innerHTML = '';
    };
    H.correctFloat = function(num, prec) {
      return parseFloat(
        num.toPrecision(prec || 14)
      );
    };
    H.setAnimation = function(animation, chart) {
      chart.renderer.globalAnimation = H.pick(
        animation,
        chart.options.chart.animation,
        true
      );
    };
    H.animObject = function(animation) {
      return H.isObject(animation) ?
        H.merge(animation) : {
          duration: animation ? 500 : 0
        };
    };
    H.timeUnits = {
      millisecond: 1,
      second: 1000,
      minute: 60000,
      hour: 3600000,
      day: 24 * 3600000,
      week: 7 * 24 * 3600000,
      month: 28 * 24 * 3600000,
      year: 364 * 24 * 3600000
    };
    H.numberFormat = function(number, decimals, decimalPoint, thousandsSep) {
      number = +number || 0;
      decimals = +decimals;
      var lang = H.defaultOptions.lang,
        origDec = (number.toString().split('.')[1] || '').length,
        strinteger,
        thousands,
        ret,
        roundedNumber;
      if (decimals === -1) {
        decimals = Math.min(origDec, 20);
      } else if (!H.isNumber(decimals)) {
        decimals = 2;
      }
      roundedNumber = (
        Math.abs(number) + Math.pow(10, -Math.max(decimals, origDec) - 1)
      ).toFixed(decimals);
      strinteger = String(H.pInt(roundedNumber));
      thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
      decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
      thousandsSep = H.pick(thousandsSep, lang.thousandsSep);
      ret = number < 0 ? '-' : '';
      ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';
      ret += strinteger
        .substr(thousands)
        .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);
      if (decimals) {
        ret += decimalPoint + roundedNumber.slice(-decimals);
      }
      return ret;
    };
    Math.easeInOutSine = function(pos) {
      return -0.5 * (Math.cos(Math.PI * pos) - 1);
    };
    H.getStyle = function(el, prop) {
      var style;
      if (prop === 'width') {
        return Math.min(el.offsetWidth, el.scrollWidth) -
          H.getStyle(el, 'padding-left') -
          H.getStyle(el, 'padding-right');
      } else if (prop === 'height') {
        return Math.min(el.offsetHeight, el.scrollHeight) -
          H.getStyle(el, 'padding-top') -
          H.getStyle(el, 'padding-bottom');
      }
      style = win.getComputedStyle(el, undefined);
      return style && H.pInt(style.getPropertyValue(prop));
    };
    H.inArray = function(item, arr) {
      return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
    };
    H.grep = function(arr, callback) {
      return [].filter.call(arr, callback);
    };
    H.find = function(arr, callback) {
      return [].find.call(arr, callback);
    };
    H.map = function(arr, fn) {
      var results = [],
        i = 0,
        len = arr.length;
      for (; i < len; i++) {
        results[i] = fn.call(arr[i], arr[i], i, arr);
      }
      return results;
    };
    H.offset = function(el) {
      var docElem = doc.documentElement,
        box = el.getBoundingClientRect();
      return {
        top: box.top + (win.pageYOffset || docElem.scrollTop) -
          (docElem.clientTop || 0),
        left: box.left + (win.pageXOffset || docElem.scrollLeft) -
          (docElem.clientLeft || 0)
      };
    };
    H.stop = function(el, prop) {
      var i = timers.length;
      while (i--) {
        if (timers[i].elem === el && (!prop || prop === timers[i].prop)) {
          timers[i].stopped = true;
        }
      }
    };
    H.each = function(arr, fn, ctx) {
      return Array.prototype.forEach.call(arr, fn, ctx);
    };
    H.addEvent = function(el, type, fn) {
      var events = el.hcEvents = el.hcEvents || {};

      function wrappedFn(e) {
        e.target = e.srcElement || win;
        fn.call(el, e);
      }
      if (el.addEventListener) {
        el.addEventListener(type, fn, false);
      } else if (el.attachEvent) {
        if (!el.hcEventsIE) {
          el.hcEventsIE = {};
        }
        el.hcEventsIE[fn.toString()] = wrappedFn;
        el.attachEvent('on' + type, wrappedFn);
      }
      if (!events[type]) {
        events[type] = [];
      }
      events[type].push(fn);
      return function() {
        H.removeEvent(el, type, fn);
      };
    };
    H.removeEvent = function(el, type, fn) {
      var events,
        hcEvents = el.hcEvents,
        index;

      function removeOneEvent(type, fn) {
        if (el.removeEventListener) {
          el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
          fn = el.hcEventsIE[fn.toString()];
          el.detachEvent('on' + type, fn);
        }
      }

      function removeAllEvents() {
        var types,
          len,
          n;
        if (!el.nodeName) {
          return;
        }
        if (type) {
          types = {};
          types[type] = true;
        } else {
          types = hcEvents;
        }
        for (n in types) {
          if (hcEvents[n]) {
            len = hcEvents[n].length;
            while (len--) {
              removeOneEvent(n, hcEvents[n][len]);
            }
          }
        }
      }
      if (hcEvents) {
        if (type) {
          events = hcEvents[type] || [];
          if (fn) {
            index = H.inArray(fn, events);
            if (index > -1) {
              events.splice(index, 1);
              hcEvents[type] = events;
            }
            removeOneEvent(type, fn);
          } else {
            removeAllEvents();
            hcEvents[type] = [];
          }
        } else {
          removeAllEvents();
          el.hcEvents = {};
        }
      }
    };
    H.fireEvent = function(el, type, eventArguments, defaultFunction) {
      var e,
        hcEvents = el.hcEvents,
        events,
        len,
        i,
        fn;
      eventArguments = eventArguments || {};
      if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
        e = doc.createEvent('Events');
        e.initEvent(type, true, true);
        H.extend(e, eventArguments);
        if (el.dispatchEvent) {
          el.dispatchEvent(e);
        } else {
          el.fireEvent(type, e);
        }
      } else if (hcEvents) {
        events = hcEvents[type] || [];
        len = events.length;
        if (!eventArguments.target) {
          H.extend(eventArguments, {
            preventDefault: function() {
              eventArguments.defaultPrevented = true;
            },
            target: el,
            type: type
          });
        }
        for (i = 0; i < len; i++) {
          fn = events[i];
          if (fn && fn.call(el, eventArguments) === false) {
            eventArguments.preventDefault();
          }
        }
      }
      if (defaultFunction && !eventArguments.defaultPrevented) {
        defaultFunction(eventArguments);
      }
    };
    H.animate = function(el, params, opt) {
      var start,
        unit = '',
        end,
        fx,
        args,
        prop;
      if (!H.isObject(opt)) {
        args = arguments;
        opt = {
          duration: args[2],
          easing: args[3],
          complete: args[4]
        };
      }
      if (!H.isNumber(opt.duration)) {
        opt.duration = 400;
      }
      opt.easing = typeof opt.easing === 'function' ?
        opt.easing :
        (Math[opt.easing] || Math.easeInOutSine);
      opt.curAnim = H.merge(params);
      for (prop in params) {
        H.stop(el, prop);
        fx = new H.Fx(el, opt, prop);
        end = null;
        if (prop === 'd') {
          fx.paths = fx.initPath(
            el,
            el.d,
            params.d
          );
          fx.toD = params.d;
          start = 0;
          end = 1;
        } else if (el.attr) {
          start = el.attr(prop);
        } else {
          start = parseFloat(H.getStyle(el, prop)) || 0;
          if (prop !== 'opacity') {
            unit = 'px';
          }
        }
        if (!end) {
          end = params[prop];
        }
        if (end.match && end.match('px')) {
          end = end.replace(/px/g, '');
        }
        fx.run(start, end, unit);
      }
    };
    H.seriesType = function(type, parent, options, props, pointProps) {
      var defaultOptions = H.getOptions(),
        seriesTypes = H.seriesTypes;
      defaultOptions.plotOptions[type] = H.merge(
        defaultOptions.plotOptions[parent],
        options
      );
      seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
        function() {}, props);
      seriesTypes[type].prototype.type = type;
      if (pointProps) {
        seriesTypes[type].prototype.pointClass =
          H.extendClass(H.Point, pointProps);
      }
      return seriesTypes[type];
    };
    H.uniqueKey = (function() {
      var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
        idCounter = 0;
      return function() {
        return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
      };
    }());
    if (win.jQuery) {
      win.jQuery.fn.highcharts = function() {
        var args = [].slice.call(arguments);
        if (this[0]) {
          if (args[0]) {
            new H[
              H.isString(args[0]) ? args.shift() : 'Chart'
            ](this[0], args[0], args[1]);
            return this;
          }
          return charts[H.attr(this[0], 'data-highcharts-chart')];
        }
      };
    }
    if (doc && !doc.defaultView) {
      H.getStyle = function(el, prop) {
        var val,
          alias = {
            width: 'clientWidth',
            height: 'clientHeight'
          } [prop];
        if (el.style[prop]) {
          return H.pInt(el.style[prop]);
        }
        if (prop === 'opacity') {
          prop = 'filter';
        }
        if (alias) {
          el.style.zoom = 1;
          return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);
        }
        val = el.currentStyle[prop.replace(/\-(\w)/g, function(a, b) {
          return b.toUpperCase();
        })];
        if (prop === 'filter') {
          val = val.replace(
            /alpha\(opacity=([0-9]+)\)/,
            function(a, b) {
              return b / 100;
            }
          );
        }
        return val === '' ? 1 : H.pInt(val);
      };
    }
    if (!Array.prototype.forEach) {
      H.each = function(arr, fn, ctx) {
        var i = 0,
          len = arr.length;
        for (; i < len; i++) {
          if (fn.call(ctx, arr[i], i, arr) === false) {
            return i;
          }
        }
      };
    }
    if (!Array.prototype.indexOf) {
      H.inArray = function(item, arr) {
        var len,
          i = 0;
        if (arr) {
          len = arr.length;
          for (; i < len; i++) {
            if (arr[i] === item) {
              return i;
            }
          }
        }
        return -1;
      };
    }
    if (!Array.prototype.filter) {
      H.grep = function(elements, fn) {
        var ret = [],
          i = 0,
          length = elements.length;
        for (; i < length; i++) {
          if (fn(elements[i], i)) {
            ret.push(elements[i]);
          }
        }
        return ret;
      };
    }
    if (!Array.prototype.find) {
      H.find = function(arr, fn) {
        var i,
          length = arr.length;
        for (i = 0; i < length; i++) {
          if (fn(arr[i], i)) {
            return arr[i];
          }
        }
      };
    }
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      isNumber = H.isNumber,
      map = H.map,
      merge = H.merge,
      pInt = H.pInt;
    H.Color = function(input) {
      if (!(this instanceof H.Color)) {
        return new H.Color(input);
      }
      this.init(input);
    };
    H.Color.prototype = {
      parsers: [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function(result) {
          return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
        }
      }, {
        regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
        parse: function(result) {
          return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function(result) {
          return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
        }
      }],
      names: {
        white: '#ffffff',
        black: '#000000'
      },
      init: function(input) {
        var result,
          rgba,
          i,
          parser;
        this.input = input = this.names[input] || input;
        if (input && input.stops) {
          this.stops = map(input.stops, function(stop) {
            return new H.Color(stop[1]);
          });
        } else {
          i = this.parsers.length;
          while (i-- && !rgba) {
            parser = this.parsers[i];
            result = parser.regex.exec(input);
            if (result) {
              rgba = parser.parse(result);
            }
          }
        }
        this.rgba = rgba || [];
      },
      get: function(format) {
        var input = this.input,
          rgba = this.rgba,
          ret;
        if (this.stops) {
          ret = merge(input);
          ret.stops = [].concat(ret.stops);
          each(this.stops, function(stop, i) {
            ret.stops[i] = [ret.stops[i][0], stop.get(format)];
          });
        } else if (rgba && isNumber(rgba[0])) {
          if (format === 'rgb' || (!format && rgba[3] === 1)) {
            ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
          } else if (format === 'a') {
            ret = rgba[3];
          } else {
            ret = 'rgba(' + rgba.join(',') + ')';
          }
        } else {
          ret = input;
        }
        return ret;
      },
      brighten: function(alpha) {
        var i,
          rgba = this.rgba;
        if (this.stops) {
          each(this.stops, function(stop) {
            stop.brighten(alpha);
          });
        } else if (isNumber(alpha) && alpha !== 0) {
          for (i = 0; i < 3; i++) {
            rgba[i] += pInt(alpha * 255);
            if (rgba[i] < 0) {
              rgba[i] = 0;
            }
            if (rgba[i] > 255) {
              rgba[i] = 255;
            }
          }
        }
        return this;
      },
      setOpacity: function(alpha) {
        this.rgba[3] = alpha;
        return this;
      }
    };
    H.color = function(input) {
      return new H.Color(input);
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var SVGElement,
      SVGRenderer,
      addEvent = H.addEvent,
      animate = H.animate,
      attr = H.attr,
      charts = H.charts,
      color = H.color,
      css = H.css,
      createElement = H.createElement,
      defined = H.defined,
      deg2rad = H.deg2rad,
      destroyObjectProperties = H.destroyObjectProperties,
      doc = H.doc,
      each = H.each,
      extend = H.extend,
      erase = H.erase,
      grep = H.grep,
      hasTouch = H.hasTouch,
      inArray = H.inArray,
      isArray = H.isArray,
      isFirefox = H.isFirefox,
      isMS = H.isMS,
      isObject = H.isObject,
      isString = H.isString,
      isWebKit = H.isWebKit,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      removeEvent = H.removeEvent,
      splat = H.splat,
      stop = H.stop,
      svg = H.svg,
      SVG_NS = H.SVG_NS,
      symbolSizes = H.symbolSizes,
      win = H.win;
    SVGElement = H.SVGElement = function() {
      return this;
    };
    SVGElement.prototype = {
      opacity: 1,
      SVG_NS: SVG_NS,
      textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',
        'fontStyle', 'color', 'lineHeight', 'width', 'textDecoration',
        'textOverflow', 'textOutline'
      ],
      init: function(renderer, nodeName) {
        this.element = nodeName === 'span' ?
          createElement(nodeName) :
          doc.createElementNS(this.SVG_NS, nodeName);
        this.renderer = renderer;
      },
      animate: function(params, options, complete) {
        var animOptions = H.animObject(
          pick(options, this.renderer.globalAnimation, true)
        );
        if (animOptions.duration !== 0) {
          if (complete) {
            animOptions.complete = complete;
          }
          animate(this, params, animOptions);
        } else {
          this.attr(params, null, complete);
        }
        return this;
      },
      colorGradient: function(color, prop, elem) {
        var renderer = this.renderer,
          colorObject,
          gradName,
          gradAttr,
          radAttr,
          gradients,
          gradientObject,
          stops,
          stopColor,
          stopOpacity,
          radialReference,
          n,
          id,
          key = [],
          value;
        if (color.linearGradient) {
          gradName = 'linearGradient';
        } else if (color.radialGradient) {
          gradName = 'radialGradient';
        }
        if (gradName) {
          gradAttr = color[gradName];
          gradients = renderer.gradients;
          stops = color.stops;
          radialReference = elem.radialReference;
          if (isArray(gradAttr)) {
            color[gradName] = gradAttr = {
              x1: gradAttr[0],
              y1: gradAttr[1],
              x2: gradAttr[2],
              y2: gradAttr[3],
              gradientUnits: 'userSpaceOnUse'
            };
          }
          if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
            radAttr = gradAttr;
            gradAttr = merge(gradAttr,
              renderer.getRadialAttr(radialReference, radAttr), {
                gradientUnits: 'userSpaceOnUse'
              }
            );
          }
          for (n in gradAttr) {
            if (n !== 'id') {
              key.push(n, gradAttr[n]);
            }
          }
          for (n in stops) {
            key.push(stops[n]);
          }
          key = key.join(',');
          if (gradients[key]) {
            id = gradients[key].attr('id');
          } else {
            gradAttr.id = id = H.uniqueKey();
            gradients[key] = gradientObject = renderer.createElement(gradName)
              .attr(gradAttr)
              .add(renderer.defs);
            gradientObject.radAttr = radAttr;
            gradientObject.stops = [];
            each(stops, function(stop) {
              var stopObject;
              if (stop[1].indexOf('rgba') === 0) {
                colorObject = H.color(stop[1]);
                stopColor = colorObject.get('rgb');
                stopOpacity = colorObject.get('a');
              } else {
                stopColor = stop[1];
                stopOpacity = 1;
              }
              stopObject = renderer.createElement('stop').attr({
                offset: stop[0],
                'stop-color': stopColor,
                'stop-opacity': stopOpacity
              }).add(gradientObject);
              gradientObject.stops.push(stopObject);
            });
          }
          value = 'url(' + renderer.url + '#' + id + ')';
          elem.setAttribute(prop, value);
          elem.gradient = key;
          color.toString = function() {
            return value;
          };
        }
      },
      applyTextOutline: function(textOutline) {
        var elem = this.element,
          tspans,
          hasContrast = textOutline.indexOf('contrast') !== -1,
          styles = {},
          color,
          strokeWidth,
          firstRealChild;
        if (hasContrast) {
          styles.textOutline = textOutline = textOutline.replace(
            /contrast/g,
            this.renderer.getContrast(elem.style.fill)
          );
        }
        this.fakeTS = true;
        this.ySetter = this.xSetter;
        tspans = [].slice.call(elem.getElementsByTagName('tspan'));
        textOutline = textOutline.split(' ');
        color = textOutline[textOutline.length - 1];
        strokeWidth = textOutline[0];
        if (strokeWidth && strokeWidth !== 'none') {
          strokeWidth = strokeWidth.replace(
            /(^[\d\.]+)(.*?)$/g,
            function(match, digit, unit) {
              return (2 * digit) + unit;
            }
          );
          each(tspans, function(tspan) {
            if (tspan.getAttribute('class') === 'highcharts-text-outline') {
              erase(tspans, elem.removeChild(tspan));
            }
          });
          firstRealChild = elem.firstChild;
          each(tspans, function(tspan, y) {
            var clone;
            if (y === 0) {
              tspan.setAttribute('x', elem.getAttribute('x'));
              y = elem.getAttribute('y');
              tspan.setAttribute('y', y || 0);
              if (y === null) {
                elem.setAttribute('y', 0);
              }
            }
            clone = tspan.cloneNode(1);
            attr(clone, {
              'class': 'highcharts-text-outline',
              'fill': color,
              'stroke': color,
              'stroke-width': strokeWidth,
              'stroke-linejoin': 'round'
            });
            elem.insertBefore(clone, firstRealChild);
          });
        }
      },
      attr: function(hash, val, complete, continueAnimation) {
        var key,
          value,
          element = this.element,
          hasSetSymbolSize,
          ret = this,
          skipAttr,
          setter;
        if (typeof hash === 'string' && val !== undefined) {
          key = hash;
          hash = {};
          hash[key] = val;
        }
        if (typeof hash === 'string') {
          ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
        } else {
          for (key in hash) {
            value = hash[key];
            skipAttr = false;
            if (!continueAnimation) {
              stop(this, key);
            }
            if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
              if (!hasSetSymbolSize) {
                this.symbolAttr(hash);
                hasSetSymbolSize = true;
              }
              skipAttr = true;
            }
            if (this.rotation && (key === 'x' || key === 'y')) {
              this.doTransform = true;
            }
            if (!skipAttr) {
              setter = this[key + 'Setter'] || this._defaultSetter;
              setter.call(this, value, key, element);
              if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                this.updateShadows(key, value, setter);
              }
            }
          }
          if (this.doTransform) {
            this.updateTransform();
            this.doTransform = false;
          }
        }
        if (complete) {
          complete();
        }
        return ret;
      },
      updateShadows: function(key, value, setter) {
        var shadows = this.shadows,
          i = shadows.length;
        while (i--) {
          setter.call(
            shadows[i],
            key === 'height' ?
            Math.max(value - (shadows[i].cutHeight || 0), 0) :
            key === 'd' ? this.d : value,
            key,
            shadows[i]
          );
        }
      },
      addClass: function(className, replace) {
        var currentClassName = this.attr('class') || '';
        if (currentClassName.indexOf(className) === -1) {
          if (!replace) {
            className =
              (currentClassName + (currentClassName ? ' ' : '') +
                className).replace('  ', ' ');
          }
          this.attr('class', className);
        }
        return this;
      },
      hasClass: function(className) {
        return attr(this.element, 'class').indexOf(className) !== -1;
      },
      removeClass: function(className) {
        attr(this.element, 'class', (attr(this.element, 'class') || '').replace(className, ''));
        return this;
      },
      symbolAttr: function(hash) {
        var wrapper = this;
        each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function(key) {
          wrapper[key] = pick(hash[key], wrapper[key]);
        });
        wrapper.attr({
          d: wrapper.renderer.symbols[wrapper.symbolName](
            wrapper.x,
            wrapper.y,
            wrapper.width,
            wrapper.height,
            wrapper
          )
        });
      },
      clip: function(clipRect) {
        return this.attr(
          'clip-path',
          clipRect ?
          'url(' + this.renderer.url + '#' + clipRect.id + ')' :
          'none'
        );
      },
      crisp: function(rect, strokeWidth) {
        var wrapper = this,
          key,
          attribs = {},
          normalizer;
        strokeWidth = strokeWidth || rect.strokeWidth || 0;
        normalizer = Math.round(strokeWidth) % 2 / 2;
        rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
        rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
        rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);
        rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);
        if (defined(rect.strokeWidth)) {
          rect.strokeWidth = strokeWidth;
        }
        for (key in rect) {
          if (wrapper[key] !== rect[key]) {
            wrapper[key] = attribs[key] = rect[key];
          }
        }
        return attribs;
      },
      css: function(styles) {
        var elemWrapper = this,
          oldStyles = elemWrapper.styles,
          newStyles = {},
          elem = elemWrapper.element,
          textWidth,
          n,
          serializedCss = '',
          hyphenate,
          hasNew = !oldStyles,
          svgPseudoProps = ['textOverflow', 'width'];
        if (styles && styles.color) {
          styles.fill = styles.color;
        }
        if (oldStyles) {
          for (n in styles) {
            if (styles[n] !== oldStyles[n]) {
              newStyles[n] = styles[n];
              hasNew = true;
            }
          }
        }
        if (hasNew) {
          textWidth = elemWrapper.textWidth =
            (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||
            elemWrapper.textWidth;
          if (oldStyles) {
            styles = extend(
              oldStyles,
              newStyles
            );
          }
          elemWrapper.styles = styles;
          if (textWidth && (!svg && elemWrapper.renderer.forExport)) {
            delete styles.width;
          }
          if (isMS && !svg) {
            css(elemWrapper.element, styles);
          } else {
            hyphenate = function(a, b) {
              return '-' + b.toLowerCase();
            };
            for (n in styles) {
              if (inArray(n, svgPseudoProps) === -1) {
                serializedCss +=
                  n.replace(/([A-Z])/g, hyphenate) + ':' +
                  styles[n] + ';';
              }
            }
            if (serializedCss) {
              attr(elem, 'style', serializedCss);
            }
          }
          if (elemWrapper.added) {
            if (textWidth) {
              elemWrapper.renderer.buildText(elemWrapper);
            }
            if (styles && styles.textOutline) {
              elemWrapper.applyTextOutline(styles.textOutline);
            }
          }
        }
        return elemWrapper;
      },
      strokeWidth: function() {
        return this['stroke-width'] || 0;
      },
      on: function(eventType, handler) {
        var svgElement = this,
          element = svgElement.element;
        if (hasTouch && eventType === 'click') {
          element.ontouchstart = function(e) {
            svgElement.touchEventFired = Date.now();
            e.preventDefault();
            handler.call(element, e);
          };
          element.onclick = function(e) {
            if (win.navigator.userAgent.indexOf('Android') === -1 ||
              Date.now() - (svgElement.touchEventFired || 0) > 1100) {
              handler.call(element, e);
            }
          };
        } else {
          element['on' + eventType] = handler;
        }
        return this;
      },
      setRadialReference: function(coordinates) {
        var existingGradient = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = coordinates;
        if (existingGradient && existingGradient.radAttr) {
          existingGradient.animate(
            this.renderer.getRadialAttr(
              coordinates,
              existingGradient.radAttr
            )
          );
        }
        return this;
      },
      translate: function(x, y) {
        return this.attr({
          translateX: x,
          translateY: y
        });
      },
      invert: function(inverted) {
        var wrapper = this;
        wrapper.inverted = inverted;
        wrapper.updateTransform();
        return wrapper;
      },
      updateTransform: function() {
        var wrapper = this,
          translateX = wrapper.translateX || 0,
          translateY = wrapper.translateY || 0,
          scaleX = wrapper.scaleX,
          scaleY = wrapper.scaleY,
          inverted = wrapper.inverted,
          rotation = wrapper.rotation,
          element = wrapper.element,
          transform;
        if (inverted) {
          translateX += wrapper.width;
          translateY += wrapper.height;
        }
        transform = ['translate(' + translateX + ',' + translateY + ')'];
        if (inverted) {
          transform.push('rotate(90) scale(-1,1)');
        } else if (rotation) {
          transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
        }
        if (defined(scaleX) || defined(scaleY)) {
          transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
        }
        if (transform.length) {
          element.setAttribute('transform', transform.join(' '));
        }
      },
      toFront: function() {
        var element = this.element;
        element.parentNode.appendChild(element);
        return this;
      },
      align: function(alignOptions, alignByTranslate, box) {
        var align,
          vAlign,
          x,
          y,
          attribs = {},
          alignTo,
          renderer = this.renderer,
          alignedObjects = renderer.alignedObjects,
          alignFactor,
          vAlignFactor;
        if (alignOptions) {
          this.alignOptions = alignOptions;
          this.alignByTranslate = alignByTranslate;
          if (!box || isString(box)) {
            this.alignTo = alignTo = box || 'renderer';
            erase(alignedObjects, this);
            alignedObjects.push(this);
            box = null;
          }
        } else {
          alignOptions = this.alignOptions;
          alignByTranslate = this.alignByTranslate;
          alignTo = this.alignTo;
        }
        box = pick(box, renderer[alignTo], renderer);
        align = alignOptions.align;
        vAlign = alignOptions.verticalAlign;
        x = (box.x || 0) + (alignOptions.x || 0);
        y = (box.y || 0) + (alignOptions.y || 0);
        if (align === 'right') {
          alignFactor = 1;
        } else if (align === 'center') {
          alignFactor = 2;
        }
        if (alignFactor) {
          x += (box.width - (alignOptions.width || 0)) / alignFactor;
        }
        attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);
        if (vAlign === 'bottom') {
          vAlignFactor = 1;
        } else if (vAlign === 'middle') {
          vAlignFactor = 2;
        }
        if (vAlignFactor) {
          y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
        }
        attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);
        this[this.placed ? 'animate' : 'attr'](attribs);
        this.placed = true;
        this.alignAttr = attribs;
        return this;
      },
      getBBox: function(reload, rot) {
        var wrapper = this,
          bBox,
          renderer = wrapper.renderer,
          width,
          height,
          rotation,
          rad,
          element = wrapper.element,
          styles = wrapper.styles,
          fontSize,
          textStr = wrapper.textStr,
          toggleTextShadowShim,
          cache = renderer.cache,
          cacheKeys = renderer.cacheKeys,
          cacheKey;
        rotation = pick(rot, wrapper.rotation);
        rad = rotation * deg2rad;
        fontSize = styles && styles.fontSize;
        if (textStr !== undefined) {
          cacheKey = textStr.toString();
          if (cacheKey.indexOf('<') === -1) {
            cacheKey = cacheKey.replace(/[0-9]/g, '0');
          }
          cacheKey += [
              '',
              rotation || 0,
              fontSize,
              styles && styles.width,
              styles && styles.textOverflow
            ]
            .join(',');
        }
        if (cacheKey && !reload) {
          bBox = cache[cacheKey];
        }
        if (!bBox) {
          if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
            try {
              toggleTextShadowShim = this.fakeTS && function(display) {
                each(element.querySelectorAll('.highcharts-text-outline'), function(tspan) {
                  tspan.style.display = display;
                });
              };
              if (toggleTextShadowShim) {
                toggleTextShadowShim('none');
              }
              bBox = element.getBBox ?
                extend({}, element.getBBox()) : {
                  width: element.offsetWidth,
                  height: element.offsetHeight
                };
              if (toggleTextShadowShim) {
                toggleTextShadowShim('');
              }
            } catch (e) {}
            if (!bBox || bBox.width < 0) {
              bBox = {
                width: 0,
                height: 0
              };
            }
          } else {
            bBox = wrapper.htmlGetBBox();
          }
          if (renderer.isSVG) {
            width = bBox.width;
            height = bBox.height;
            if (
              styles &&
              styles.fontSize === '11px' &&
              Math.round(height) === 17
            ) {
              bBox.height = height = 14;
            }
            if (rotation) {
              bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
              bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
            }
          }
          if (cacheKey && bBox.height > 0) {
            while (cacheKeys.length > 250) {
              delete cache[cacheKeys.shift()];
            }
            if (!cache[cacheKey]) {
              cacheKeys.push(cacheKey);
            }
            cache[cacheKey] = bBox;
          }
        }
        return bBox;
      },
      show: function(inherit) {
        return this.attr({
          visibility: inherit ? 'inherit' : 'visible'
        });
      },
      hide: function() {
        return this.attr({
          visibility: 'hidden'
        });
      },
      fadeOut: function(duration) {
        var elemWrapper = this;
        elemWrapper.animate({
          opacity: 0
        }, {
          duration: duration || 150,
          complete: function() {
            elemWrapper.attr({
              y: -9999
            });
          }
        });
      },
      add: function(parent) {
        var renderer = this.renderer,
          element = this.element,
          inserted;
        if (parent) {
          this.parentGroup = parent;
        }
        this.parentInverted = parent && parent.inverted;
        if (this.textStr !== undefined) {
          renderer.buildText(this);
        }
        this.added = true;
        if (!parent || parent.handleZ || this.zIndex) {
          inserted = this.zIndexSetter();
        }
        if (!inserted) {
          (parent ? parent.element : renderer.box).appendChild(element);
        }
        if (this.onAdd) {
          this.onAdd();
        }
        return this;
      },
      safeRemoveChild: function(element) {
        var parentNode = element.parentNode;
        if (parentNode) {
          parentNode.removeChild(element);
        }
      },
      destroy: function() {
        var wrapper = this,
          element = wrapper.element || {},
          parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
          grandParent,
          key,
          i;
        element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
        stop(wrapper);
        if (wrapper.clipPath) {
          wrapper.clipPath = wrapper.clipPath.destroy();
        }
        if (wrapper.stops) {
          for (i = 0; i < wrapper.stops.length; i++) {
            wrapper.stops[i] = wrapper.stops[i].destroy();
          }
          wrapper.stops = null;
        }
        wrapper.safeRemoveChild(element);
        wrapper.destroyShadows();
        while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
          grandParent = parentToClean.parentGroup;
          wrapper.safeRemoveChild(parentToClean.div);
          delete parentToClean.div;
          parentToClean = grandParent;
        }
        if (wrapper.alignTo) {
          erase(wrapper.renderer.alignedObjects, wrapper);
        }
        for (key in wrapper) {
          delete wrapper[key];
        }
        return null;
      },
      shadow: function(shadowOptions, group, cutOff) {
        var shadows = [],
          i,
          shadow,
          element = this.element,
          strokeWidth,
          shadowWidth,
          shadowElementOpacity,
          transform;
        if (!shadowOptions) {
          this.destroyShadows();
        } else if (!this.shadows) {
          shadowWidth = pick(shadowOptions.width, 3);
          shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
          transform = this.parentInverted ?
            '(-1,-1)' :
            '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
          for (i = 1; i <= shadowWidth; i++) {
            shadow = element.cloneNode(0);
            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
            attr(shadow, {
              'isShadow': 'true',
              'stroke': shadowOptions.color || '#000000',
              'stroke-opacity': shadowElementOpacity * i,
              'stroke-width': strokeWidth,
              'transform': 'translate' + transform,
              'fill': 'none'
            });
            if (cutOff) {
              attr(shadow, 'height', Math.max(attr(shadow, 'height') - strokeWidth, 0));
              shadow.cutHeight = strokeWidth;
            }
            if (group) {
              group.element.appendChild(shadow);
            } else {
              element.parentNode.insertBefore(shadow, element);
            }
            shadows.push(shadow);
          }
          this.shadows = shadows;
        }
        return this;
      },
      destroyShadows: function() {
        each(this.shadows || [], function(shadow) {
          this.safeRemoveChild(shadow);
        }, this);
        this.shadows = undefined;
      },
      xGetter: function(key) {
        if (this.element.nodeName === 'circle') {
          if (key === 'x') {
            key = 'cx';
          } else if (key === 'y') {
            key = 'cy';
          }
        }
        return this._defaultGetter(key);
      },
      _defaultGetter: function(key) {
        var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);
        if (/^[\-0-9\.]+$/.test(ret)) {
          ret = parseFloat(ret);
        }
        return ret;
      },
      dSetter: function(value, key, element) {
        if (value && value.join) {
          value = value.join(' ');
        }
        if (/(NaN| {2}|^$)/.test(value)) {
          value = 'M 0 0';
        }
        element.setAttribute(key, value);
        this[key] = value;
      },
      dashstyleSetter: function(value) {
        var i,
          strokeWidth = this['stroke-width'];
        if (strokeWidth === 'inherit') {
          strokeWidth = 1;
        }
        value = value && value.toLowerCase();
        if (value) {
          value = value
            .replace('shortdashdotdot', '3,1,1,1,1,1,')
            .replace('shortdashdot', '3,1,1,1')
            .replace('shortdot', '1,1,')
            .replace('shortdash', '3,1,')
            .replace('longdash', '8,3,')
            .replace(/dot/g, '1,3,')
            .replace('dash', '4,3,')
            .replace(/,$/, '')
            .split(',');
          i = value.length;
          while (i--) {
            value[i] = pInt(value[i]) * strokeWidth;
          }
          value = value.join(',')
            .replace(/NaN/g, 'none');
          this.element.setAttribute('stroke-dasharray', value);
        }
      },
      alignSetter: function(value) {
        var convert = {
          left: 'start',
          center: 'middle',
          right: 'end'
        };
        this.element.setAttribute('text-anchor', convert[value]);
      },
      opacitySetter: function(value, key, element) {
        this[key] = value;
        element.setAttribute(key, value);
      },
      titleSetter: function(value) {
        var titleNode = this.element.getElementsByTagName('title')[0];
        if (!titleNode) {
          titleNode = doc.createElementNS(this.SVG_NS, 'title');
          this.element.appendChild(titleNode);
        }
        if (titleNode.firstChild) {
          titleNode.removeChild(titleNode.firstChild);
        }
        titleNode.appendChild(
          doc.createTextNode(
            (String(pick(value), '')).replace(/<[^>]*>/g, '')
          )
        );
      },
      textSetter: function(value) {
        if (value !== this.textStr) {
          delete this.bBox;
          this.textStr = value;
          if (this.added) {
            this.renderer.buildText(this);
          }
        }
      },
      fillSetter: function(value, key, element) {
        if (typeof value === 'string') {
          element.setAttribute(key, value);
        } else if (value) {
          this.colorGradient(value, key, element);
        }
      },
      visibilitySetter: function(value, key, element) {
        if (value === 'inherit') {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, value);
        }
      },
      zIndexSetter: function(value, key) {
        var renderer = this.renderer,
          parentGroup = this.parentGroup,
          parentWrapper = parentGroup || renderer,
          parentNode = parentWrapper.element || renderer.box,
          childNodes,
          otherElement,
          otherZIndex,
          element = this.element,
          inserted,
          run = this.added,
          i;
        if (defined(value)) {
          element.zIndex = value;
          value = +value;
          if (this[key] === value) {
            run = false;
          }
          this[key] = value;
        }
        if (run) {
          value = this.zIndex;
          if (value && parentGroup) {
            parentGroup.handleZ = true;
          }
          childNodes = parentNode.childNodes;
          for (i = 0; i < childNodes.length && !inserted; i++) {
            otherElement = childNodes[i];
            otherZIndex = otherElement.zIndex;
            if (otherElement !== element && (
                pInt(otherZIndex) > value ||
                (!defined(value) && defined(otherZIndex)) ||
                (value < 0 && !defined(otherZIndex) && parentNode !== renderer.box)
              )) {
              parentNode.insertBefore(element, otherElement);
              inserted = true;
            }
          }
          if (!inserted) {
            parentNode.appendChild(element);
          }
        }
        return inserted;
      },
      _defaultSetter: function(value, key, element) {
        element.setAttribute(key, value);
      }
    };
    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
      SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
      SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function(value, key) {
        this[key] = value;
        this.doTransform = true;
      };
    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function(value, key, element) {
      this[key] = value;
      if (this.stroke && this['stroke-width']) {
        SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element);
        element.setAttribute('stroke-width', this['stroke-width']);
        this.hasStroke = true;
      } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
        element.removeAttribute('stroke');
        this.hasStroke = false;
      }
    };
    SVGRenderer = H.SVGRenderer = function() {
      this.init.apply(this, arguments);
    };
    SVGRenderer.prototype = {
      Element: SVGElement,
      SVG_NS: SVG_NS,
      init: function(container, width, height, style, forExport, allowHTML) {
        var renderer = this,
          boxWrapper,
          element,
          desc;
        boxWrapper = renderer.createElement('svg')
          .attr({
            'version': '1.1',
            'class': 'highcharts-root'
          })
          .css(this.getStyle(style));
        element = boxWrapper.element;
        container.appendChild(element);
        if (container.innerHTML.indexOf('xmlns') === -1) {
          attr(element, 'xmlns', this.SVG_NS);
        }
        renderer.isSVG = true;
        this.box = element;
        this.boxWrapper = boxWrapper;
        renderer.alignedObjects = [];
        this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
          win.location.href
          .replace(/#.*?$/, '')
          .replace(/<[^>]*>/g, '')
          .replace(/([\('\)])/g, '\\$1')
          .replace(/ /g, '%20') :
          '';
        desc = this.createElement('desc').add();
        desc.element.appendChild(doc.createTextNode('Created with Highstock 5.0.7'));
        renderer.defs = this.createElement('defs').add();
        renderer.allowHTML = allowHTML;
        renderer.forExport = forExport;
        renderer.gradients = {};
        renderer.cache = {};
        renderer.cacheKeys = [];
        renderer.imgCount = 0;
        renderer.setSize(width, height, false);
        var subPixelFix, rect;
        if (isFirefox && container.getBoundingClientRect) {
          subPixelFix = function() {
            css(container, {
              left: 0,
              top: 0
            });
            rect = container.getBoundingClientRect();
            css(container, {
              left: (Math.ceil(rect.left) - rect.left) + 'px',
              top: (Math.ceil(rect.top) - rect.top) + 'px'
            });
          };
          subPixelFix();
          renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);
        }
      },
      getStyle: function(style) {
        this.style = extend({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: '12px'
        }, style);
        return this.style;
      },
      setStyle: function(style) {
        this.boxWrapper.css(this.getStyle(style));
      },
      isHidden: function() {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function() {
        var renderer = this,
          rendererDefs = renderer.defs;
        renderer.box = null;
        renderer.boxWrapper = renderer.boxWrapper.destroy();
        destroyObjectProperties(renderer.gradients || {});
        renderer.gradients = null;
        if (rendererDefs) {
          renderer.defs = rendererDefs.destroy();
        }
        if (renderer.unSubPixelFix) {
          renderer.unSubPixelFix();
        }
        renderer.alignedObjects = null;
        return null;
      },
      createElement: function(nodeName) {
        var wrapper = new this.Element();
        wrapper.init(this, nodeName);
        return wrapper;
      },
      draw: noop,
      getRadialAttr: function(radialReference, gradAttr) {
        return {
          cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
          cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
          r: gradAttr.r * radialReference[2]
        };
      },
      buildText: function(wrapper) {
        var textNode = wrapper.element,
          renderer = this,
          forExport = renderer.forExport,
          textStr = pick(wrapper.textStr, '').toString(),
          hasMarkup = textStr.indexOf('<') !== -1,
          lines,
          childNodes = textNode.childNodes,
          clsRegex,
          styleRegex,
          hrefRegex,
          wasTooLong,
          parentX = attr(textNode, 'x'),
          textStyles = wrapper.styles,
          width = wrapper.textWidth,
          textLineHeight = textStyles && textStyles.lineHeight,
          textOutline = textStyles && textStyles.textOutline,
          ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
          noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
          fontSize = textStyles && textStyles.fontSize,
          textCache,
          i = childNodes.length,
          tempParent = width && !wrapper.added && this.box,
          getLineHeight = function(tspan) {
            var fontSizeStyle;
            fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?
              tspan.style.fontSize :
              (fontSize || renderer.style.fontSize || 12);
            return textLineHeight ?
              pInt(textLineHeight) :
              renderer.fontMetrics(
                fontSizeStyle,
                tspan.getAttribute('style') ? tspan : textNode
              ).h;
          },
          unescapeAngleBrackets = function(inputStr) {
            return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
          };
        textCache = [
          textStr,
          ellipsis,
          noWrap,
          textLineHeight,
          textOutline,
          fontSize,
          width
        ].join(',');
        if (textCache === wrapper.textCache) {
          return;
        }
        wrapper.textCache = textCache;
        while (i--) {
          textNode.removeChild(childNodes[i]);
        }
        if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {
          textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
        } else {
          clsRegex = /<.*class="([^"]+)".*>/;
          styleRegex = /<.*style="([^"]+)".*>/;
          hrefRegex = /<.*href="(http[^"]+)".*>/;
          if (tempParent) {
            tempParent.appendChild(textNode);
          }
          if (hasMarkup) {
            lines = textStr
              .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
              .replace(/<(i|em)>/g, '<span style="font-style:italic">')
              .replace(/<a/g, '<span')
              .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
              .split(/<br.*?>/g);
          } else {
            lines = [textStr];
          }
          lines = grep(lines, function(line) {
            return line !== '';
          });
          each(lines, function buildTextLines(line, lineNo) {
            var spans,
              spanNo = 0;
            line = line
              .replace(/^\s+|\s+$/g, '')
              .replace(/<span/g, '|||<span')
              .replace(/<\/span>/g, '</span>|||');
            spans = line.split('|||');
            each(spans, function buildTextSpans(span) {
              if (span !== '' || spans.length === 1) {
                var attributes = {},
                  tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),
                  spanCls,
                  spanStyle;
                if (clsRegex.test(span)) {
                  spanCls = span.match(clsRegex)[1];
                  attr(tspan, 'class', spanCls);
                }
                if (styleRegex.test(span)) {
                  spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
                  attr(tspan, 'style', spanStyle);
                }
                if (hrefRegex.test(span) && !forExport) {
                  attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
                  css(tspan, {
                    cursor: 'pointer'
                  });
                }
                span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');
                if (span !== ' ') {
                  tspan.appendChild(doc.createTextNode(span));
                  if (!spanNo) {
                    if (lineNo && parentX !== null) {
                      attributes.x = parentX;
                    }
                  } else {
                    attributes.dx = 0;
                  }
                  attr(tspan, attributes);
                  textNode.appendChild(tspan);
                  if (!spanNo && lineNo) {
                    if (!svg && forExport) {
                      css(tspan, {
                        display: 'block'
                      });
                    }
                    attr(
                      tspan,
                      'dy',
                      getLineHeight(tspan)
                    );
                  }
                  if (width) {
                    var words = span.replace(/([^\^])-/g, '$1- ').split(' '),
                      hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),
                      tooLong,
                      actualWidth,
                      rest = [],
                      dy = getLineHeight(tspan),
                      rotation = wrapper.rotation,
                      wordStr = span,
                      cursor = wordStr.length,
                      bBox;
                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
                      wrapper.rotation = 0;
                      bBox = wrapper.getBBox(true);
                      actualWidth = bBox.width;
                      if (!svg && renderer.forExport) {
                        actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
                      }
                      tooLong = actualWidth > width;
                      if (wasTooLong === undefined) {
                        wasTooLong = tooLong;
                      }
                      if (ellipsis && wasTooLong) {
                        cursor /= 2;
                        if (wordStr === '' || (!tooLong && cursor < 0.5)) {
                          words = [];
                        } else {
                          wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * Math.ceil(cursor));
                          words = [wordStr + (width > 3 ? '\u2026' : '')];
                          tspan.removeChild(tspan.firstChild);
                        }
                      } else if (!tooLong || words.length === 1) {
                        words = rest;
                        rest = [];
                        if (words.length && !noWrap) {
                          tspan = doc.createElementNS(SVG_NS, 'tspan');
                          attr(tspan, {
                            dy: dy,
                            x: parentX
                          });
                          if (spanStyle) {
                            attr(tspan, 'style', spanStyle);
                          }
                          textNode.appendChild(tspan);
                        }
                        if (actualWidth > width) {
                          width = actualWidth;
                        }
                      } else {
                        tspan.removeChild(tspan.firstChild);
                        rest.unshift(words.pop());
                      }
                      if (words.length) {
                        tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
                      }
                    }
                    wrapper.rotation = rotation;
                  }
                  spanNo++;
                }
              }
            });
          });
          if (wasTooLong) {
            wrapper.attr('title', wrapper.textStr);
          }
          if (tempParent) {
            tempParent.removeChild(textNode);
          }
          if (textOutline && wrapper.applyTextOutline) {
            wrapper.applyTextOutline(textOutline);
          }
        }
      },
      getContrast: function(rgba) {
        rgba = color(rgba).rgba;
        return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';
      },
      button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
        var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
          curState = 0;
        label.attr(merge({
          'padding': 8,
          'r': 2
        }, normalState));
        var normalStyle,
          hoverStyle,
          pressedStyle,
          disabledStyle;
        normalState = merge({
          fill: '#f7f7f7',
          stroke: '#cccccc',
          'stroke-width': 1,
          style: {
            color: '#333333',
            cursor: 'pointer',
            fontWeight: 'normal'
          }
        }, normalState);
        normalStyle = normalState.style;
        delete normalState.style;
        hoverState = merge(normalState, {
          fill: '#e6e6e6'
        }, hoverState);
        hoverStyle = hoverState.style;
        delete hoverState.style;
        pressedState = merge(normalState, {
          fill: '#e6ebf5',
          style: {
            color: '#000000',
            fontWeight: 'bold'
          }
        }, pressedState);
        pressedStyle = pressedState.style;
        delete pressedState.style;
        disabledState = merge(normalState, {
          style: {
            color: '#cccccc'
          }
        }, disabledState);
        disabledStyle = disabledState.style;
        delete disabledState.style;
        addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {
          if (curState !== 3) {
            label.setState(1);
          }
        });
        addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {
          if (curState !== 3) {
            label.setState(curState);
          }
        });
        label.setState = function(state) {
          if (state !== 1) {
            label.state = curState = state;
          }
          label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)
            .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);
          label.attr([normalState, hoverState, pressedState, disabledState][state || 0])
            .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);
        };
        label
          .attr(normalState)
          .css(extend({
            cursor: 'default'
          }, normalStyle));
        return label
          .on('click', function(e) {
            if (curState !== 3) {
              callback.call(label, e);
            }
          });
      },
      crispLine: function(points, width) {
        if (points[1] === points[4]) {
          points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);
        }
        if (points[2] === points[5]) {
          points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);
        }
        return points;
      },
      path: function(path) {
        var attribs = {
          fill: 'none'
        };
        if (isArray(path)) {
          attribs.d = path;
        } else if (isObject(path)) {
          extend(attribs, path);
        }
        return this.createElement('path').attr(attribs);
      },
      circle: function(x, y, r) {
        var attribs = isObject(x) ? x : {
            x: x,
            y: y,
            r: r
          },
          wrapper = this.createElement('circle');
        wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
          element.setAttribute('c' + key, value);
        };
        return wrapper.attr(attribs);
      },
      arc: function(x, y, r, innerR, start, end) {
        var arc;
        if (isObject(x)) {
          y = x.y;
          r = x.r;
          innerR = x.innerR;
          start = x.start;
          end = x.end;
          x = x.x;
        }
        arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
          innerR: innerR || 0,
          start: start || 0,
          end: end || 0
        });
        arc.r = r;
        return arc;
      },
      rect: function(x, y, width, height, r, strokeWidth) {
        r = isObject(x) ? x.r : r;
        var wrapper = this.createElement('rect'),
          attribs = isObject(x) ? x : x === undefined ? {} : {
            x: x,
            y: y,
            width: Math.max(width, 0),
            height: Math.max(height, 0)
          };
        if (strokeWidth !== undefined) {
          attribs.strokeWidth = strokeWidth;
          attribs = wrapper.crisp(attribs);
        }
        attribs.fill = 'none';
        if (r) {
          attribs.r = r;
        }
        wrapper.rSetter = function(value, key, element) {
          attr(element, {
            rx: value,
            ry: value
          });
        };
        return wrapper.attr(attribs);
      },
      setSize: function(width, height, animate) {
        var renderer = this,
          alignedObjects = renderer.alignedObjects,
          i = alignedObjects.length;
        renderer.width = width;
        renderer.height = height;
        renderer.boxWrapper.animate({
          width: width,
          height: height
        }, {
          step: function() {
            this.attr({
              viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')
            });
          },
          duration: pick(animate, true) ? undefined : 0
        });
        while (i--) {
          alignedObjects[i].align();
        }
      },
      g: function(name) {
        var elem = this.createElement('g');
        return name ? elem.attr({
          'class': 'highcharts-' + name
        }) : elem;
      },
      image: function(src, x, y, width, height) {
        var attribs = {
            preserveAspectRatio: 'none'
          },
          elemWrapper;
        if (arguments.length > 1) {
          extend(attribs, {
            x: x,
            y: y,
            width: width,
            height: height
          });
        }
        elemWrapper = this.createElement('image').attr(attribs);
        if (elemWrapper.element.setAttributeNS) {
          elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
            'href', src);
        } else {
          elemWrapper.element.setAttribute('hc-svg-href', src);
        }
        return elemWrapper;
      },
      symbol: function(symbol, x, y, width, height, options) {
        var ren = this,
          obj,
          symbolFn = this.symbols[symbol],
          path = defined(x) && symbolFn && this.symbols[symbol](
            Math.round(x),
            Math.round(y),
            width,
            height,
            options
          ),
          imageRegex = /^url\((.*?)\)$/,
          imageSrc,
          centerImage;
        if (symbolFn) {
          obj = this.path(path);
          obj.attr('fill', 'none');
          extend(obj, {
            symbolName: symbol,
            x: x,
            y: y,
            width: width,
            height: height
          });
          if (options) {
            extend(obj, options);
          }
        } else if (imageRegex.test(symbol)) {
          imageSrc = symbol.match(imageRegex)[1];
          obj = this.image(imageSrc);
          obj.imgwidth = pick(
            symbolSizes[imageSrc] && symbolSizes[imageSrc].width,
            options && options.width
          );
          obj.imgheight = pick(
            symbolSizes[imageSrc] && symbolSizes[imageSrc].height,
            options && options.height
          );
          centerImage = function() {
            obj.attr({
              width: obj.width,
              height: obj.height
            });
          };
          each(['width', 'height'], function(key) {
            obj[key + 'Setter'] = function(value, key) {
              var attribs = {},
                imgSize = this['img' + key],
                trans = key === 'width' ? 'translateX' : 'translateY';
              this[key] = value;
              if (defined(imgSize)) {
                if (this.element) {
                  this.element.setAttribute(key, imgSize);
                }
                if (!this.alignByTranslate) {
                  attribs[trans] = ((this[key] || 0) - imgSize) / 2;
                  this.attr(attribs);
                }
              }
            };
          });
          if (defined(x)) {
            obj.attr({
              x: x,
              y: y
            });
          }
          obj.isImg = true;
          if (defined(obj.imgwidth) && defined(obj.imgheight)) {
            centerImage();
          } else {
            obj.attr({
              width: 0,
              height: 0
            });
            createElement('img', {
              onload: function() {
                var chart = charts[ren.chartIndex];
                if (this.width === 0) {
                  css(this, {
                    position: 'absolute',
                    top: '-999em'
                  });
                  doc.body.appendChild(this);
                }
                symbolSizes[imageSrc] = {
                  width: this.width,
                  height: this.height
                };
                obj.imgwidth = this.width;
                obj.imgheight = this.height;
                if (obj.element) {
                  centerImage();
                }
                if (this.parentNode) {
                  this.parentNode.removeChild(this);
                }
                ren.imgCount--;
                if (!ren.imgCount && chart && chart.onload) {
                  chart.onload();
                }
              },
              src: imageSrc
            });
            this.imgCount++;
          }
        }
        return obj;
      },
      symbols: {
        'circle': function(x, y, w, h) {
          return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
            start: 0,
            end: Math.PI * 2,
            open: false
          });
        },
        'square': function(x, y, w, h) {
          return [
            'M', x, y,
            'L', x + w, y,
            x + w, y + h,
            x, y + h,
            'Z'
          ];
        },
        'triangle': function(x, y, w, h) {
          return [
            'M', x + w / 2, y,
            'L', x + w, y + h,
            x, y + h,
            'Z'
          ];
        },
        'triangle-down': function(x, y, w, h) {
          return [
            'M', x, y,
            'L', x + w, y,
            x + w / 2, y + h,
            'Z'
          ];
        },
        'diamond': function(x, y, w, h) {
          return [
            'M', x + w / 2, y,
            'L', x + w, y + h / 2,
            x + w / 2, y + h,
            x, y + h / 2,
            'Z'
          ];
        },
        'arc': function(x, y, w, h, options) {
          var start = options.start,
            rx = options.r || w,
            ry = options.r || h || w,
            end = options.end - 0.001,
            innerRadius = options.innerR,
            open = options.open,
            cosStart = Math.cos(start),
            sinStart = Math.sin(start),
            cosEnd = Math.cos(end),
            sinEnd = Math.sin(end),
            longArc = options.end - start < Math.PI ? 0 : 1,
            arc;
          arc = [
            'M',
            x + rx * cosStart,
            y + ry * sinStart,
            'A',
            rx,
            ry,
            0,
            longArc,
            1,
            x + rx * cosEnd,
            y + ry * sinEnd
          ];
          if (defined(innerRadius)) {
            arc.push(
              open ? 'M' : 'L',
              x + innerRadius * cosEnd,
              y + innerRadius * sinEnd,
              'A',
              innerRadius,
              innerRadius,
              0,
              longArc,
              0,
              x + innerRadius * cosStart,
              y + innerRadius * sinStart
            );
          }
          arc.push(open ? '' : 'Z');
          return arc;
        },
        callout: function(x, y, w, h, options) {
          var arrowLength = 6,
            halfDistance = 6,
            r = Math.min((options && options.r) || 0, w, h),
            safeDistance = r + halfDistance,
            anchorX = options && options.anchorX,
            anchorY = options && options.anchorY,
            path;
          path = [
            'M', x + r, y,
            'L', x + w - r, y,
            'C', x + w, y, x + w, y, x + w, y + r,
            'L', x + w, y + h - r,
            'C', x + w, y + h, x + w, y + h, x + w - r, y + h,
            'L', x + r, y + h,
            'C', x, y + h, x, y + h, x, y + h - r,
            'L', x, y + r,
            'C', x, y, x, y, x + r, y
          ];
          if (anchorX && anchorX > w) {
            if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
              path.splice(13, 3,
                'L', x + w, anchorY - halfDistance,
                x + w + arrowLength, anchorY,
                x + w, anchorY + halfDistance,
                x + w, y + h - r
              );
            } else {
              path.splice(13, 3,
                'L', x + w, h / 2,
                anchorX, anchorY,
                x + w, h / 2,
                x + w, y + h - r
              );
            }
          } else if (anchorX && anchorX < 0) {
            if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
              path.splice(33, 3,
                'L', x, anchorY + halfDistance,
                x - arrowLength, anchorY,
                x, anchorY - halfDistance,
                x, y + r
              );
            } else {
              path.splice(33, 3,
                'L', x, h / 2,
                anchorX, anchorY,
                x, h / 2,
                x, y + r
              );
            }
          } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
            path.splice(23, 3,
              'L', anchorX + halfDistance, y + h,
              anchorX, y + h + arrowLength,
              anchorX - halfDistance, y + h,
              x + r, y + h
            );
          } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
            path.splice(3, 3,
              'L', anchorX - halfDistance, y,
              anchorX, y - arrowLength,
              anchorX + halfDistance, y,
              w - r, y
            );
          }
          return path;
        }
      },
      clipRect: function(x, y, width, height) {
        var wrapper,
          id = H.uniqueKey(),
          clipPath = this.createElement('clipPath').attr({
            id: id
          }).add(this.defs);
        wrapper = this.rect(x, y, width, height, 0).add(clipPath);
        wrapper.id = id;
        wrapper.clipPath = clipPath;
        wrapper.count = 0;
        return wrapper;
      },
      text: function(str, x, y, useHTML) {
        var renderer = this,
          fakeSVG = !svg && renderer.forExport,
          wrapper,
          attribs = {};
        if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
          return renderer.html(str, x, y);
        }
        attribs.x = Math.round(x || 0);
        if (y) {
          attribs.y = Math.round(y);
        }
        if (str || str === 0) {
          attribs.text = str;
        }
        wrapper = renderer.createElement('text')
          .attr(attribs);
        if (fakeSVG) {
          wrapper.css({
            position: 'absolute'
          });
        }
        if (!useHTML) {
          wrapper.xSetter = function(value, key, element) {
            var tspans = element.getElementsByTagName('tspan'),
              tspan,
              parentVal = element.getAttribute(key),
              i;
            for (i = 0; i < tspans.length; i++) {
              tspan = tspans[i];
              if (tspan.getAttribute(key) === parentVal) {
                tspan.setAttribute(key, value);
              }
            }
            element.setAttribute(key, value);
          };
        }
        return wrapper;
      },
      fontMetrics: function(fontSize, elem) {
        var lineHeight,
          baseline;
        fontSize = fontSize ||
          (elem && elem.style && elem.style.fontSize) ||
          (this.style && this.style.fontSize);
        if (/px/.test(fontSize)) {
          fontSize = pInt(fontSize);
        } else if (/em/.test(fontSize)) {
          fontSize = parseFloat(fontSize) *
            (elem ? this.fontMetrics(null, elem.parentNode).f : 16);
        } else {
          fontSize = 12;
        }
        lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
        baseline = Math.round(lineHeight * 0.8);
        return {
          h: lineHeight,
          b: baseline,
          f: fontSize
        };
      },
      rotCorr: function(baseline, rotation, alterY) {
        var y = baseline;
        if (rotation && alterY) {
          y = Math.max(y * Math.cos(rotation * deg2rad), 4);
        }
        return {
          x: (-baseline / 3) * Math.sin(rotation * deg2rad),
          y: y
        };
      },
      label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
        var renderer = this,
          wrapper = renderer.g(className !== 'button' && 'label'),
          text = wrapper.text = renderer.text('', 0, 0, useHTML)
          .attr({
            zIndex: 1
          }),
          box,
          bBox,
          alignFactor = 0,
          padding = 3,
          paddingLeft = 0,
          width,
          height,
          wrapperX,
          wrapperY,
          textAlign,
          deferredAttr = {},
          strokeWidth,
          baselineOffset,
          hasBGImage = /^url\((.*?)\)$/.test(shape),
          needsBox = hasBGImage,
          getCrispAdjust,
          updateBoxSize,
          updateTextPadding,
          boxAttr;
        if (className) {
          wrapper.addClass('highcharts-' + className);
        }
        needsBox = hasBGImage;
        getCrispAdjust = function() {
          return (strokeWidth || 0) % 2 / 2;
        };
        updateBoxSize = function() {
          var style = text.element.style,
            crispAdjust,
            attribs = {};
          bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&
            text.getBBox();
          wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
          wrapper.height = (height || bBox.height || 0) + 2 * padding;
          baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;
          if (needsBox) {
            if (!box) {
              wrapper.box = box = renderer.symbols[shape] || hasBGImage ?
                renderer.symbol(shape) :
                renderer.rect();
              box.addClass(
                (className === 'button' ? '' : 'highcharts-label-box') +
                (className ? ' highcharts-' + className + '-box' : '')
              );
              box.add(wrapper);
              crispAdjust = getCrispAdjust();
              attribs.x = crispAdjust;
              attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
            }
            attribs.width = Math.round(wrapper.width);
            attribs.height = Math.round(wrapper.height);
            box.attr(extend(attribs, deferredAttr));
            deferredAttr = {};
          }
        };
        updateTextPadding = function() {
          var textX = paddingLeft + padding,
            textY;
          textY = baseline ? 0 : baselineOffset;
          if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
            textX += {
              center: 0.5,
              right: 1
            } [textAlign] * (width - bBox.width);
          }
          if (textX !== text.x || textY !== text.y) {
            text.attr('x', textX);
            if (textY !== undefined) {
              text.attr('y', textY);
            }
          }
          text.x = textX;
          text.y = textY;
        };
        boxAttr = function(key, value) {
          if (box) {
            box.attr(key, value);
          } else {
            deferredAttr[key] = value;
          }
        };
        wrapper.onAdd = function() {
          text.add(wrapper);
          wrapper.attr({
            text: (str || str === 0) ? str : '',
            x: x,
            y: y
          });
          if (box && defined(anchorX)) {
            wrapper.attr({
              anchorX: anchorX,
              anchorY: anchorY
            });
          }
        };
        wrapper.widthSetter = function(value) {
          width = value;
        };
        wrapper.heightSetter = function(value) {
          height = value;
        };
        wrapper['text-alignSetter'] = function(value) {
          textAlign = value;
        };
        wrapper.paddingSetter = function(value) {
          if (defined(value) && value !== padding) {
            padding = wrapper.padding = value;
            updateTextPadding();
          }
        };
        wrapper.paddingLeftSetter = function(value) {
          if (defined(value) && value !== paddingLeft) {
            paddingLeft = value;
            updateTextPadding();
          }
        };
        wrapper.alignSetter = function(value) {
          value = {
            left: 0,
            center: 0.5,
            right: 1
          } [value];
          if (value !== alignFactor) {
            alignFactor = value;
            if (bBox) {
              wrapper.attr({
                x: wrapperX
              });
            }
          }
        };
        wrapper.textSetter = function(value) {
          if (value !== undefined) {
            text.textSetter(value);
          }
          updateBoxSize();
          updateTextPadding();
        };
        wrapper['stroke-widthSetter'] = function(value, key) {
          if (value) {
            needsBox = true;
          }
          strokeWidth = this['stroke-width'] = value;
          boxAttr(key, value);
        };
        wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key) {
          if (key === 'fill' && value) {
            needsBox = true;
          }
          boxAttr(key, value);
        };
        wrapper.anchorXSetter = function(value, key) {
          anchorX = value;
          boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
        };
        wrapper.anchorYSetter = function(value, key) {
          anchorY = value;
          boxAttr(key, value - wrapperY);
        };
        wrapper.xSetter = function(value) {
          wrapper.x = value;
          if (alignFactor) {
            value -= alignFactor * ((width || bBox.width) + 2 * padding);
          }
          wrapperX = Math.round(value);
          wrapper.attr('translateX', wrapperX);
        };
        wrapper.ySetter = function(value) {
          wrapperY = wrapper.y = Math.round(value);
          wrapper.attr('translateY', wrapperY);
        };
        var baseCss = wrapper.css;
        return extend(wrapper, {
          css: function(styles) {
            if (styles) {
              var textStyles = {};
              styles = merge(styles);
              each(wrapper.textProps, function(prop) {
                if (styles[prop] !== undefined) {
                  textStyles[prop] = styles[prop];
                  delete styles[prop];
                }
              });
              text.css(textStyles);
            }
            return baseCss.call(wrapper, styles);
          },
          getBBox: function() {
            return {
              width: bBox.width + 2 * padding,
              height: bBox.height + 2 * padding,
              x: bBox.x - padding,
              y: bBox.y - padding
            };
          },
          shadow: function(b) {
            if (b) {
              updateBoxSize();
              if (box) {
                box.shadow(b);
              }
            }
            return wrapper;
          },
          destroy: function() {
            removeEvent(wrapper.element, 'mouseenter');
            removeEvent(wrapper.element, 'mouseleave');
            if (text) {
              text = text.destroy();
            }
            if (box) {
              box = box.destroy();
            }
            SVGElement.prototype.destroy.call(wrapper);
            wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
          }
        });
      }
    };
    H.Renderer = SVGRenderer;
  }(Highcharts));
  (function(H) {
    'use strict';
    var attr = H.attr,
      createElement = H.createElement,
      css = H.css,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      isFirefox = H.isFirefox,
      isMS = H.isMS,
      isWebKit = H.isWebKit,
      pInt = H.pInt,
      SVGElement = H.SVGElement,
      SVGRenderer = H.SVGRenderer,
      win = H.win,
      wrap = H.wrap;
    extend(SVGElement.prototype, {
      htmlCss: function(styles) {
        var wrapper = this,
          element = wrapper.element,
          textWidth = styles && element.tagName === 'SPAN' && styles.width;
        if (textWidth) {
          delete styles.width;
          wrapper.textWidth = textWidth;
          wrapper.updateTransform();
        }
        if (styles && styles.textOverflow === 'ellipsis') {
          styles.whiteSpace = 'nowrap';
          styles.overflow = 'hidden';
        }
        wrapper.styles = extend(wrapper.styles, styles);
        css(wrapper.element, styles);
        return wrapper;
      },
      htmlGetBBox: function() {
        var wrapper = this,
          element = wrapper.element;
        if (element.nodeName === 'text') {
          element.style.position = 'absolute';
        }
        return {
          x: element.offsetLeft,
          y: element.offsetTop,
          width: element.offsetWidth,
          height: element.offsetHeight
        };
      },
      htmlUpdateTransform: function() {
        if (!this.added) {
          this.alignOnAdd = true;
          return;
        }
        var wrapper = this,
          renderer = wrapper.renderer,
          elem = wrapper.element,
          translateX = wrapper.translateX || 0,
          translateY = wrapper.translateY || 0,
          x = wrapper.x || 0,
          y = wrapper.y || 0,
          align = wrapper.textAlign || 'left',
          alignCorrection = {
            left: 0,
            center: 0.5,
            right: 1
          } [align],
          styles = wrapper.styles;
        css(elem, {
          marginLeft: translateX,
          marginTop: translateY
        });
        if (wrapper.shadows) {
          each(wrapper.shadows, function(shadow) {
            css(shadow, {
              marginLeft: translateX + 1,
              marginTop: translateY + 1
            });
          });
        }
        if (wrapper.inverted) {
          each(elem.childNodes, function(child) {
            renderer.invertChild(child, elem);
          });
        }
        if (elem.tagName === 'SPAN') {
          var rotation = wrapper.rotation,
            baseline,
            textWidth = pInt(wrapper.textWidth),
            whiteSpace = styles && styles.whiteSpace,
            currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');
          if (currentTextTransform !== wrapper.cTT) {
            baseline = renderer.fontMetrics(elem.style.fontSize).b;
            if (defined(rotation)) {
              wrapper.setSpanRotation(rotation, alignCorrection, baseline);
            }
            css(elem, {
              width: '',
              whiteSpace: whiteSpace || 'nowrap'
            });
            if (elem.offsetWidth > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) {
              css(elem, {
                width: textWidth + 'px',
                display: 'block',
                whiteSpace: whiteSpace || 'normal'
              });
            }
            wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);
          }
          css(elem, {
            left: (x + (wrapper.xCorr || 0)) + 'px',
            top: (y + (wrapper.yCorr || 0)) + 'px'
          });
          if (isWebKit) {
            baseline = elem.offsetHeight;
          }
          wrapper.cTT = currentTextTransform;
        }
      },
      setSpanRotation: function(rotation, alignCorrection, baseline) {
        var rotationStyle = {},
          cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : '';
        rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
        rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
        css(this.element, rotationStyle);
      },
      getSpanCorrection: function(width, baseline, alignCorrection) {
        this.xCorr = -width * alignCorrection;
        this.yCorr = -baseline;
      }
    });
    extend(SVGRenderer.prototype, {
      html: function(str, x, y) {
        var wrapper = this.createElement('span'),
          element = wrapper.element,
          renderer = wrapper.renderer,
          isSVG = renderer.isSVG,
          addSetters = function(element, style) {
            each(['opacity', 'visibility'], function(prop) {
              wrap(element, prop + 'Setter', function(proceed, value, key, elem) {
                proceed.call(this, value, key, elem);
                style[key] = value;
              });
            });
          };
        wrapper.textSetter = function(value) {
          if (value !== element.innerHTML) {
            delete this.bBox;
          }
          element.innerHTML = this.textStr = value;
          wrapper.htmlUpdateTransform();
        };
        if (isSVG) {
          addSetters(wrapper, wrapper.element.style);
        }
        wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
          if (key === 'align') {
            key = 'textAlign';
          }
          wrapper[key] = value;
          wrapper.htmlUpdateTransform();
        };
        wrapper
          .attr({
            text: str,
            x: Math.round(x),
            y: Math.round(y)
          })
          .css({
            fontFamily: this.style.fontFamily,
            fontSize: this.style.fontSize,
            position: 'absolute'
          });
        element.style.whiteSpace = 'nowrap';
        wrapper.css = wrapper.htmlCss;
        if (isSVG) {
          wrapper.add = function(svgGroupWrapper) {
            var htmlGroup,
              container = renderer.box.parentNode,
              parentGroup,
              parents = [];
            this.parentGroup = svgGroupWrapper;
            if (svgGroupWrapper) {
              htmlGroup = svgGroupWrapper.div;
              if (!htmlGroup) {
                parentGroup = svgGroupWrapper;
                while (parentGroup) {
                  parents.push(parentGroup);
                  parentGroup = parentGroup.parentGroup;
                }
                each(parents.reverse(), function(parentGroup) {
                  var htmlGroupStyle,
                    cls = attr(parentGroup.element, 'class');
                  if (cls) {
                    cls = {
                      className: cls
                    };
                  }
                  htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls, {
                    position: 'absolute',
                    left: (parentGroup.translateX || 0) + 'px',
                    top: (parentGroup.translateY || 0) + 'px',
                    display: parentGroup.display,
                    opacity: parentGroup.opacity,
                    pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents
                  }, htmlGroup || container);
                  htmlGroupStyle = htmlGroup.style;
                  extend(parentGroup, {
                    on: function() {
                      wrapper.on.apply({
                        element: parents[0].div
                      }, arguments);
                      return parentGroup;
                    },
                    translateXSetter: function(value, key) {
                      htmlGroupStyle.left = value + 'px';
                      parentGroup[key] = value;
                      parentGroup.doTransform = true;
                    },
                    translateYSetter: function(value, key) {
                      htmlGroupStyle.top = value + 'px';
                      parentGroup[key] = value;
                      parentGroup.doTransform = true;
                    }
                  });
                  addSetters(parentGroup, htmlGroupStyle);
                });
              }
            } else {
              htmlGroup = container;
            }
            htmlGroup.appendChild(element);
            wrapper.added = true;
            if (wrapper.alignOnAdd) {
              wrapper.htmlUpdateTransform();
            }
            return wrapper;
          };
        }
        return wrapper;
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var VMLRenderer,
      VMLRendererExtension,
      VMLElement,
      createElement = H.createElement,
      css = H.css,
      defined = H.defined,
      deg2rad = H.deg2rad,
      discardElement = H.discardElement,
      doc = H.doc,
      each = H.each,
      erase = H.erase,
      extend = H.extend,
      extendClass = H.extendClass,
      isArray = H.isArray,
      isNumber = H.isNumber,
      isObject = H.isObject,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      svg = H.svg,
      SVGElement = H.SVGElement,
      SVGRenderer = H.SVGRenderer,
      win = H.win;
    if (!svg) {
      VMLElement = {
        docMode8: doc && doc.documentMode === 8,
        init: function(renderer, nodeName) {
          var wrapper = this,
            markup = ['<', nodeName, ' filled="f" stroked="f"'],
            style = ['position: ', 'absolute', ';'],
            isDiv = nodeName === 'div';
          if (nodeName === 'shape' || isDiv) {
            style.push('left:0;top:0;width:1px;height:1px;');
          }
          style.push('visibility: ', isDiv ? 'hidden' : 'visible');
          markup.push(' style="', style.join(''), '"/>');
          if (nodeName) {
            markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
              markup.join('') :
              renderer.prepVML(markup);
            wrapper.element = createElement(markup);
          }
          wrapper.renderer = renderer;
        },
        add: function(parent) {
          var wrapper = this,
            renderer = wrapper.renderer,
            element = wrapper.element,
            box = renderer.box,
            inverted = parent && parent.inverted,
            parentNode = parent ?
            parent.element || parent :
            box;
          if (parent) {
            this.parentGroup = parent;
          }
          if (inverted) {
            renderer.invertChild(element, parentNode);
          }
          parentNode.appendChild(element);
          wrapper.added = true;
          if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
            wrapper.updateTransform();
          }
          if (wrapper.onAdd) {
            wrapper.onAdd();
          }
          if (this.className) {
            this.attr('class', this.className);
          }
          return wrapper;
        },
        updateTransform: SVGElement.prototype.htmlUpdateTransform,
        setSpanRotation: function() {
          var rotation = this.rotation,
            costheta = Math.cos(rotation * deg2rad),
            sintheta = Math.sin(rotation * deg2rad);
          css(this.element, {
            filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
              ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
              ', sizingMethod=\'auto expand\')'
            ].join('') : 'none'
          });
        },
        getSpanCorrection: function(width, baseline, alignCorrection, rotation, align) {
          var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,
            sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,
            height = pick(this.elemHeight, this.element.offsetHeight),
            quad,
            nonLeft = align && align !== 'left';
          this.xCorr = costheta < 0 && -width;
          this.yCorr = sintheta < 0 && -height;
          quad = costheta * sintheta < 0;
          this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
          this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
          if (nonLeft) {
            this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
            if (rotation) {
              this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
            }
            css(this.element, {
              textAlign: align
            });
          }
        },
        pathToVML: function(value) {
          var i = value.length,
            path = [];
          while (i--) {
            if (isNumber(value[i])) {
              path[i] = Math.round(value[i] * 10) - 5;
            } else if (value[i] === 'Z') {
              path[i] = 'x';
            } else {
              path[i] = value[i];
              if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
                if (path[i + 5] === path[i + 7]) {
                  path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
                }
                if (path[i + 6] === path[i + 8]) {
                  path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
                }
              }
            }
          }
          return path.join(' ') || 'x';
        },
        clip: function(clipRect) {
          var wrapper = this,
            clipMembers,
            cssRet;
          if (clipRect) {
            clipMembers = clipRect.members;
            erase(clipMembers, wrapper);
            clipMembers.push(wrapper);
            wrapper.destroyClip = function() {
              erase(clipMembers, wrapper);
            };
            cssRet = clipRect.getCSS(wrapper);
          } else {
            if (wrapper.destroyClip) {
              wrapper.destroyClip();
            }
            cssRet = {
              clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)'
            };
          }
          return wrapper.css(cssRet);
        },
        css: SVGElement.prototype.htmlCss,
        safeRemoveChild: function(element) {
          if (element.parentNode) {
            discardElement(element);
          }
        },
        destroy: function() {
          if (this.destroyClip) {
            this.destroyClip();
          }
          return SVGElement.prototype.destroy.apply(this);
        },
        on: function(eventType, handler) {
          this.element['on' + eventType] = function() {
            var evt = win.event;
            evt.target = evt.srcElement;
            handler(evt);
          };
          return this;
        },
        cutOffPath: function(path, length) {
          var len;
          path = path.split(/[ ,]/);
          len = path.length;
          if (len === 9 || len === 11) {
            path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
          }
          return path.join(' ');
        },
        shadow: function(shadowOptions, group, cutOff) {
          var shadows = [],
            i,
            element = this.element,
            renderer = this.renderer,
            shadow,
            elemStyle = element.style,
            markup,
            path = element.path,
            strokeWidth,
            modifiedPath,
            shadowWidth,
            shadowElementOpacity;
          if (path && typeof path.value !== 'string') {
            path = 'x';
          }
          modifiedPath = path;
          if (shadowOptions) {
            shadowWidth = pick(shadowOptions.width, 3);
            shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
            for (i = 1; i <= 3; i++) {
              strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
              if (cutOff) {
                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
              }
              markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
                '" filled="false" path="', modifiedPath,
                '" coordsize="10 10" style="', element.style.cssText, '" />'
              ];
              shadow = createElement(renderer.prepVML(markup),
                null, {
                  left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                  top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                }
              );
              if (cutOff) {
                shadow.cutOff = strokeWidth + 1;
              }
              markup = [
                '<stroke color="',
                shadowOptions.color || '#000000',
                '" opacity="', shadowElementOpacity * i, '"/>'
              ];
              createElement(renderer.prepVML(markup), null, null, shadow);
              if (group) {
                group.element.appendChild(shadow);
              } else {
                element.parentNode.insertBefore(shadow, element);
              }
              shadows.push(shadow);
            }
            this.shadows = shadows;
          }
          return this;
        },
        updateShadows: noop,
        setAttr: function(key, value) {
          if (this.docMode8) {
            this.element[key] = value;
          } else {
            this.element.setAttribute(key, value);
          }
        },
        classSetter: function(value) {
          (this.added ? this.element : this).className = value;
        },
        dashstyleSetter: function(value, key, element) {
          var strokeElem = element.getElementsByTagName('stroke')[0] ||
            createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
          strokeElem[key] = value || 'solid';
          this[key] = value;
        },
        dSetter: function(value, key, element) {
          var i,
            shadows = this.shadows;
          value = value || [];
          this.d = value.join && value.join(' ');
          element.path = value = this.pathToVML(value);
          if (shadows) {
            i = shadows.length;
            while (i--) {
              shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
            }
          }
          this.setAttr(key, value);
        },
        fillSetter: function(value, key, element) {
          var nodeName = element.nodeName;
          if (nodeName === 'SPAN') {
            element.style.color = value;
          } else if (nodeName !== 'IMG') {
            element.filled = value !== 'none';
            this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
          }
        },
        'fill-opacitySetter': function(value, key, element) {
          createElement(
            this.renderer.prepVML(['<', key.split('-')[0], ' opacity="', value, '"/>']),
            null,
            null,
            element
          );
        },
        opacitySetter: noop,
        rotationSetter: function(value, key, element) {
          var style = element.style;
          this[key] = style[key] = value;
          style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';
          style.top = Math.round(Math.cos(value * deg2rad)) + 'px';
        },
        strokeSetter: function(value, key, element) {
          this.setAttr('strokecolor', this.renderer.color(value, element, key, this));
        },
        'stroke-widthSetter': function(value, key, element) {
          element.stroked = !!value;
          this[key] = value;
          if (isNumber(value)) {
            value += 'px';
          }
          this.setAttr('strokeweight', value);
        },
        titleSetter: function(value, key) {
          this.setAttr(key, value);
        },
        visibilitySetter: function(value, key, element) {
          if (value === 'inherit') {
            value = 'visible';
          }
          if (this.shadows) {
            each(this.shadows, function(shadow) {
              shadow.style[key] = value;
            });
          }
          if (element.nodeName === 'DIV') {
            value = value === 'hidden' ? '-999em' : 0;
            if (!this.docMode8) {
              element.style[key] = value ? 'visible' : 'hidden';
            }
            key = 'top';
          }
          element.style[key] = value;
        },
        xSetter: function(value, key, element) {
          this[key] = value;
          if (key === 'x') {
            key = 'left';
          } else if (key === 'y') {
            key = 'top';
          }
          if (this.updateClipping) {
            this[key] = value;
            this.updateClipping();
          } else {
            element.style[key] = value;
          }
        },
        zIndexSetter: function(value, key, element) {
          element.style[key] = value;
        }
      };
      VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];
      H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);
      VMLElement.prototype.ySetter =
        VMLElement.prototype.widthSetter =
        VMLElement.prototype.heightSetter =
        VMLElement.prototype.xSetter;
      VMLRendererExtension = {
        Element: VMLElement,
        isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,
        init: function(container, width, height) {
          var renderer = this,
            boxWrapper,
            box,
            css;
          renderer.alignedObjects = [];
          boxWrapper = renderer.createElement('div')
            .css({
              position: 'relative'
            });
          box = boxWrapper.element;
          container.appendChild(boxWrapper.element);
          renderer.isVML = true;
          renderer.box = box;
          renderer.boxWrapper = boxWrapper;
          renderer.gradients = {};
          renderer.cache = {};
          renderer.cacheKeys = [];
          renderer.imgCount = 0;
          renderer.setSize(width, height, false);
          if (!doc.namespaces.hcv) {
            doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');
            css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
              '{ behavior:url(#default#VML); display: inline-block; } ';
            try {
              doc.createStyleSheet().cssText = css;
            } catch (e) {
              doc.styleSheets[0].cssText += css;
            }
          }
        },
        isHidden: function() {
          return !this.box.offsetWidth;
        },
        clipRect: function(x, y, width, height) {
          var clipRect = this.createElement(),
            isObj = isObject(x);
          return extend(clipRect, {
            members: [],
            count: 0,
            left: (isObj ? x.x : x) + 1,
            top: (isObj ? x.y : y) + 1,
            width: (isObj ? x.width : width) - 1,
            height: (isObj ? x.height : height) - 1,
            getCSS: function(wrapper) {
              var element = wrapper.element,
                nodeName = element.nodeName,
                isShape = nodeName === 'shape',
                inverted = wrapper.inverted,
                rect = this,
                top = rect.top - (isShape ? element.offsetTop : 0),
                left = rect.left,
                right = left + rect.width,
                bottom = top + rect.height,
                ret = {
                  clip: 'rect(' +
                    Math.round(inverted ? left : top) + 'px,' +
                    Math.round(inverted ? bottom : right) + 'px,' +
                    Math.round(inverted ? right : bottom) + 'px,' +
                    Math.round(inverted ? top : left) + 'px)'
                };
              if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {
                extend(ret, {
                  width: right + 'px',
                  height: bottom + 'px'
                });
              }
              return ret;
            },
            updateClipping: function() {
              each(clipRect.members, function(member) {
                if (member.element) {
                  member.css(clipRect.getCSS(member));
                }
              });
            }
          });
        },
        color: function(color, elem, prop, wrapper) {
          var renderer = this,
            colorObject,
            regexRgba = /^rgba/,
            markup,
            fillType,
            ret = 'none';
          if (color && color.linearGradient) {
            fillType = 'gradient';
          } else if (color && color.radialGradient) {
            fillType = 'pattern';
          }
          if (fillType) {
            var stopColor,
              stopOpacity,
              gradient = color.linearGradient || color.radialGradient,
              x1,
              y1,
              x2,
              y2,
              opacity1,
              opacity2,
              color1,
              color2,
              fillAttr = '',
              stops = color.stops,
              firstStop,
              lastStop,
              colors = [],
              addFillNode = function() {
                markup = ['<fill colors="' + colors.join(',') +
                  '" opacity="', opacity2, '" o:opacity2="',
                  opacity1, '" type="', fillType, '" ', fillAttr,
                  'focus="100%" method="any" />'
                ];
                createElement(renderer.prepVML(markup), null, null, elem);
              };
            firstStop = stops[0];
            lastStop = stops[stops.length - 1];
            if (firstStop[0] > 0) {
              stops.unshift([
                0,
                firstStop[1]
              ]);
            }
            if (lastStop[0] < 1) {
              stops.push([
                1,
                lastStop[1]
              ]);
            }
            each(stops, function(stop, i) {
              if (regexRgba.test(stop[1])) {
                colorObject = H.color(stop[1]);
                stopColor = colorObject.get('rgb');
                stopOpacity = colorObject.get('a');
              } else {
                stopColor = stop[1];
                stopOpacity = 1;
              }
              colors.push((stop[0] * 100) + '% ' + stopColor);
              if (!i) {
                opacity1 = stopOpacity;
                color2 = stopColor;
              } else {
                opacity2 = stopOpacity;
                color1 = stopColor;
              }
            });
            if (prop === 'fill') {
              if (fillType === 'gradient') {
                x1 = gradient.x1 || gradient[0] || 0;
                y1 = gradient.y1 || gradient[1] || 0;
                x2 = gradient.x2 || gradient[2] || 0;
                y2 = gradient.y2 || gradient[3] || 0;
                fillAttr = 'angle="' + (90 - Math.atan(
                  (y2 - y1) /
                  (x2 - x1)
                ) * 180 / Math.PI) + '"';
                addFillNode();
              } else {
                var r = gradient.r,
                  sizex = r * 2,
                  sizey = r * 2,
                  cx = gradient.cx,
                  cy = gradient.cy,
                  radialReference = elem.radialReference,
                  bBox,
                  applyRadialGradient = function() {
                    if (radialReference) {
                      bBox = wrapper.getBBox();
                      cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
                      cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
                      sizex *= radialReference[2] / bBox.width;
                      sizey *= radialReference[2] / bBox.height;
                    }
                    fillAttr = 'src="' + H.getOptions().global.VMLRadialGradientURL + '" ' +
                      'size="' + sizex + ',' + sizey + '" ' +
                      'origin="0.5,0.5" ' +
                      'position="' + cx + ',' + cy + '" ' +
                      'color2="' + color2 + '" ';
                    addFillNode();
                  };
                if (wrapper.added) {
                  applyRadialGradient();
                } else {
                  wrapper.onAdd = applyRadialGradient;
                }
                ret = color1;
              }
            } else {
              ret = stopColor;
            }
          } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {
            colorObject = H.color(color);
            wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);
            ret = colorObject.get('rgb');
          } else {
            var propNodes = elem.getElementsByTagName(prop);
            if (propNodes.length) {
              propNodes[0].opacity = 1;
              propNodes[0].type = 'solid';
            }
            ret = color;
          }
          return ret;
        },
        prepVML: function(markup) {
          var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
            isIE8 = this.isIE8;
          markup = markup.join('');
          if (isIE8) {
            markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
            if (markup.indexOf('style="') === -1) {
              markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
            } else {
              markup = markup.replace('style="', 'style="' + vmlStyle);
            }
          } else {
            markup = markup.replace('<', '<hcv:');
          }
          return markup;
        },
        text: SVGRenderer.prototype.html,
        path: function(path) {
          var attr = {
            coordsize: '10 10'
          };
          if (isArray(path)) {
            attr.d = path;
          } else if (isObject(path)) {
            extend(attr, path);
          }
          return this.createElement('shape').attr(attr);
        },
        circle: function(x, y, r) {
          var circle = this.symbol('circle');
          if (isObject(x)) {
            r = x.r;
            y = x.y;
            x = x.x;
          }
          circle.isCircle = true;
          circle.r = r;
          return circle.attr({
            x: x,
            y: y
          });
        },
        g: function(name) {
          var wrapper,
            attribs;
          if (name) {
            attribs = {
              'className': 'highcharts-' + name,
              'class': 'highcharts-' + name
            };
          }
          wrapper = this.createElement('div').attr(attribs);
          return wrapper;
        },
        image: function(src, x, y, width, height) {
          var obj = this.createElement('img')
            .attr({
              src: src
            });
          if (arguments.length > 1) {
            obj.attr({
              x: x,
              y: y,
              width: width,
              height: height
            });
          }
          return obj;
        },
        createElement: function(nodeName) {
          return nodeName === 'rect' ?
            this.symbol(nodeName) :
            SVGRenderer.prototype.createElement.call(this, nodeName);
        },
        invertChild: function(element, parentNode) {
          var ren = this,
            parentStyle = parentNode.style,
            imgStyle = element.tagName === 'IMG' && element.style;
          css(element, {
            flip: 'x',
            left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
            top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
            rotation: -90
          });
          each(element.childNodes, function(child) {
            ren.invertChild(child, element);
          });
        },
        symbols: {
          arc: function(x, y, w, h, options) {
            var start = options.start,
              end = options.end,
              radius = options.r || w || h,
              innerRadius = options.innerR,
              cosStart = Math.cos(start),
              sinStart = Math.sin(start),
              cosEnd = Math.cos(end),
              sinEnd = Math.sin(end),
              ret;
            if (end - start === 0) {
              return ['x'];
            }
            ret = [
              'wa',
              x - radius,
              y - radius,
              x + radius,
              y + radius,
              x + radius * cosStart,
              y + radius * sinStart,
              x + radius * cosEnd,
              y + radius * sinEnd
            ];
            if (options.open && !innerRadius) {
              ret.push(
                'e',
                'M',
                x,
                y
              );
            }
            ret.push(
              'at',
              x - innerRadius,
              y - innerRadius,
              x + innerRadius,
              y + innerRadius,
              x + innerRadius * cosEnd,
              y + innerRadius * sinEnd,
              x + innerRadius * cosStart,
              y + innerRadius * sinStart,
              'x',
              'e'
            );
            ret.isArc = true;
            return ret;
          },
          circle: function(x, y, w, h, wrapper) {
            if (wrapper && defined(wrapper.r)) {
              w = h = 2 * wrapper.r;
            }
            if (wrapper && wrapper.isCircle) {
              x -= w / 2;
              y -= h / 2;
            }
            return [
              'wa',
              x,
              y,
              x + w,
              y + h,
              x + w,
              y + h / 2,
              x + w,
              y + h / 2,
              'e'
            ];
          },
          rect: function(x, y, w, h, options) {
            return SVGRenderer.prototype.symbols[!defined(options) || !options.r ? 'square' : 'callout'].call(0, x, y, w, h, options);
          }
        }
      };
      H.VMLRenderer = VMLRenderer = function() {
        this.init.apply(this, arguments);
      };
      VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);
      H.Renderer = VMLRenderer;
    }
    SVGRenderer.prototype.measureSpanWidth = function(text, styles) {
      var measuringSpan = doc.createElement('span'),
        offsetWidth,
        textNode = doc.createTextNode(text);
      measuringSpan.appendChild(textNode);
      css(measuringSpan, styles);
      this.box.appendChild(measuringSpan);
      offsetWidth = measuringSpan.offsetWidth;
      discardElement(measuringSpan);
      return offsetWidth;
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var color = H.color,
      each = H.each,
      getTZOffset = H.getTZOffset,
      isTouchDevice = H.isTouchDevice,
      merge = H.merge,
      pick = H.pick,
      svg = H.svg,
      win = H.win;
    H.defaultOptions = {
      colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),
      symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
      lang: {
        loading: 'Loading...',
        months: [
          'January', 'February', 'March', 'April', 'May', 'June', 'July',
          'August', 'September', 'October', 'November', 'December'
        ],
        shortMonths: [
          'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
          'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        weekdays: [
          'Sunday', 'Monday', 'Tuesday', 'Wednesday',
          'Thursday', 'Friday', 'Saturday'
        ],
        decimalPoint: '.',
        numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],
        resetZoom: 'Reset zoom',
        resetZoomTitle: 'Reset zoom level 1:1',
        thousandsSep: ' '
      },
      global: {
        useUTC: true,
        VMLRadialGradientURL: 'http://code.highcharts.com/5.0.7/gfx/vml-radial-gradient.png'
      },
      chart: {
        borderRadius: 0,
        defaultSeriesType: 'line',
        ignoreHiddenSeries: true,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 20
          },
          position: {
            align: 'right',
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null,
        borderColor: '#335cad',
        backgroundColor: '#ffffff',
        plotBorderColor: '#cccccc'
      },
      title: {
        text: 'Chart title',
        align: 'center',
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: '',
        align: 'center',
        widthAdjust: -44
      },
      plotOptions: {},
      labels: {
        style: {
          position: 'absolute',
          color: '#333333'
        }
      },
      legend: {
        enabled: true,
        align: 'center',
        layout: 'horizontal',
        labelFormatter: function() {
          return this.name;
        },
        borderColor: '#999999',
        borderRadius: 0,
        navigation: {
          activeColor: '#003399',
          inactiveColor: '#cccccc'
        },
        itemStyle: {
          color: '#333333',
          fontSize: '12px',
          fontWeight: 'bold'
        },
        itemHoverStyle: {
          color: '#000000'
        },
        itemHiddenStyle: {
          color: '#cccccc'
        },
        shadow: false,
        itemCheckboxStyle: {
          position: 'absolute',
          width: '13px',
          height: '13px'
        },
        squareSymbol: true,
        symbolPadding: 5,
        verticalAlign: 'bottom',
        x: 0,
        y: 0,
        title: {
          style: {
            fontWeight: 'bold'
          }
        }
      },
      loading: {
        labelStyle: {
          fontWeight: 'bold',
          position: 'relative',
          top: '45%'
        },
        style: {
          position: 'absolute',
          backgroundColor: '#ffffff',
          opacity: 0.5,
          textAlign: 'center'
        }
      },
      tooltip: {
        enabled: true,
        animation: svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: '%A, %b %e, %H:%M:%S.%L',
          second: '%A, %b %e, %H:%M:%S',
          minute: '%A, %b %e, %H:%M',
          hour: '%A, %b %e, %H:%M',
          day: '%A, %b %e, %Y',
          week: 'Week from %A, %b %e, %Y',
          month: '%B %Y',
          year: '%Y'
        },
        footerFormat: '',
        padding: 8,
        snap: isTouchDevice ? 25 : 10,
        backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),
        borderWidth: 1,
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
        shadow: true,
        style: {
          color: '#333333',
          cursor: 'default',
          fontSize: '12px',
          pointerEvents: 'none',
          whiteSpace: 'nowrap'
        }
      },
      credits: {
        enabled: true,
        href: 'http://www.highcharts.com',
        position: {
          align: 'right',
          x: -10,
          verticalAlign: 'bottom',
          y: -5
        },
        style: {
          cursor: 'pointer',
          color: '#999999',
          fontSize: '9px'
        },
        text: 'Highcharts.com'
      }
    };

    function getTimezoneOffsetOption() {
      var globalOptions = H.defaultOptions.global,
        moment = win.moment;
      if (globalOptions.timezone) {
        if (!moment) {
          H.error(25);
        } else {
          return function(timestamp) {
            return -moment.tz(
              timestamp,
              globalOptions.timezone
            ).utcOffset();
          };
        }
      }
      return globalOptions.useUTC && globalOptions.getTimezoneOffset;
    }

    function setTimeMethods() {
      var globalOptions = H.defaultOptions.global,
        Date,
        useUTC = globalOptions.useUTC,
        GET = useUTC ? 'getUTC' : 'get',
        SET = useUTC ? 'setUTC' : 'set';
      H.Date = Date = globalOptions.Date || win.Date;
      Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;
      Date.hcGetTimezoneOffset = getTimezoneOffsetOption();
      Date.hcMakeTime = function(year, month, date, hours, minutes, seconds) {
        var d;
        if (useUTC) {
          d = Date.UTC.apply(0, arguments);
          d += getTZOffset(d);
        } else {
          d = new Date(
            year,
            month,
            pick(date, 1),
            pick(hours, 0),
            pick(minutes, 0),
            pick(seconds, 0)
          ).getTime();
        }
        return d;
      };
      each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function(s) {
        Date['hcGet' + s] = GET + s;
      });
      each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function(s) {
        Date['hcSet' + s] = SET + s;
      });
    }
    H.setOptions = function(options) {
      H.defaultOptions = merge(true, H.defaultOptions, options);
      setTimeMethods();
      return H.defaultOptions;
    };
    H.getOptions = function() {
      return H.defaultOptions;
    };
    H.defaultPlotOptions = H.defaultOptions.plotOptions;
    setTimeMethods();
  }(Highcharts));
  (function(H) {
    'use strict';
    var arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      each = H.each,
      erase = H.erase,
      merge = H.merge,
      pick = H.pick;
    H.PlotLineOrBand = function(axis, options) {
      this.axis = axis;
      if (options) {
        this.options = options;
        this.id = options.id;
      }
    };
    H.PlotLineOrBand.prototype = {
      render: function() {
        var plotLine = this,
          axis = plotLine.axis,
          horiz = axis.horiz,
          options = plotLine.options,
          optionsLabel = options.label,
          label = plotLine.label,
          to = options.to,
          from = options.from,
          value = options.value,
          isBand = defined(from) && defined(to),
          isLine = defined(value),
          svgElem = plotLine.svgElem,
          isNew = !svgElem,
          path = [],
          addEvent,
          eventType,
          color = options.color,
          zIndex = pick(options.zIndex, 0),
          events = options.events,
          attribs = {
            'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')
          },
          groupAttribs = {},
          renderer = axis.chart.renderer,
          groupName = isBand ? 'bands' : 'lines',
          group,
          log2lin = axis.log2lin;
        if (axis.isLog) {
          from = log2lin(from);
          to = log2lin(to);
          value = log2lin(value);
        }
        if (isLine) {
          attribs = {
            stroke: color,
            'stroke-width': options.width
          };
          if (options.dashStyle) {
            attribs.dashstyle = options.dashStyle;
          }
        } else if (isBand) {
          if (color) {
            attribs.fill = color;
          }
          if (options.borderWidth) {
            attribs.stroke = options.borderColor;
            attribs['stroke-width'] = options.borderWidth;
          }
        }
        groupAttribs.zIndex = zIndex;
        groupName += '-' + zIndex;
        group = axis[groupName];
        if (!group) {
          axis[groupName] = group = renderer.g('plot-' + groupName)
            .attr(groupAttribs).add();
        }
        if (isNew) {
          plotLine.svgElem = svgElem =
            renderer
            .path()
            .attr(attribs).add(group);
        }
        if (isLine) {
          path = axis.getPlotLinePath(value, svgElem.strokeWidth());
        } else if (isBand) {
          path = axis.getPlotBandPath(from, to, options);
        } else {
          return;
        }
        if (isNew && path && path.length) {
          svgElem.attr({
            d: path
          });
          if (events) {
            addEvent = function(eventType) {
              svgElem.on(eventType, function(e) {
                events[eventType].apply(plotLine, [e]);
              });
            };
            for (eventType in events) {
              addEvent(eventType);
            }
          }
        } else if (svgElem) {
          if (path) {
            svgElem.show();
            svgElem.animate({
              d: path
            });
          } else {
            svgElem.hide();
            if (label) {
              plotLine.label = label = label.destroy();
            }
          }
        }
        if (optionsLabel && defined(optionsLabel.text) && path && path.length &&
          axis.width > 0 && axis.height > 0 && !path.flat) {
          optionsLabel = merge({
            align: horiz && isBand && 'center',
            x: horiz ? !isBand && 4 : 10,
            verticalAlign: !horiz && isBand && 'middle',
            y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
            rotation: horiz && !isBand && 90
          }, optionsLabel);
          this.renderLabel(optionsLabel, path, isBand, zIndex);
        } else if (label) {
          label.hide();
        }
        return plotLine;
      },
      renderLabel: function(optionsLabel, path, isBand, zIndex) {
        var plotLine = this,
          label = plotLine.label,
          renderer = plotLine.axis.chart.renderer,
          attribs,
          xs,
          ys,
          x,
          y;
        if (!label) {
          attribs = {
            align: optionsLabel.textAlign || optionsLabel.align,
            rotation: optionsLabel.rotation,
            'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')
          };
          attribs.zIndex = zIndex;
          plotLine.label = label = renderer.text(
              optionsLabel.text,
              0,
              0,
              optionsLabel.useHTML
            )
            .attr(attribs)
            .add();
          label.css(optionsLabel.style);
        }
        xs = [path[1], path[4], (isBand ? path[6] : path[1])];
        ys = [path[2], path[5], (isBand ? path[7] : path[2])];
        x = arrayMin(xs);
        y = arrayMin(ys);
        label.align(optionsLabel, false, {
          x: x,
          y: y,
          width: arrayMax(xs) - x,
          height: arrayMax(ys) - y
        });
        label.show();
      },
      destroy: function() {
        erase(this.axis.plotLinesAndBands, this);
        delete this.axis;
        destroyObjectProperties(this);
      }
    };
    H.AxisPlotLineOrBandExtension = {
      getPlotBandPath: function(from, to) {
        var toPath = this.getPlotLinePath(to, null, null, true),
          path = this.getPlotLinePath(from, null, null, true);
        if (path && toPath) {
          path.flat = path.toString() === toPath.toString();
          path.push(
            toPath[4],
            toPath[5],
            toPath[1],
            toPath[2],
            'z'
          );
        } else {
          path = null;
        }
        return path;
      },
      addPlotBand: function(options) {
        return this.addPlotBandOrLine(options, 'plotBands');
      },
      addPlotLine: function(options) {
        return this.addPlotBandOrLine(options, 'plotLines');
      },
      addPlotBandOrLine: function(options, coll) {
        var obj = new H.PlotLineOrBand(this, options).render(),
          userOptions = this.userOptions;
        if (obj) {
          if (coll) {
            userOptions[coll] = userOptions[coll] || [];
            userOptions[coll].push(options);
          }
          this.plotLinesAndBands.push(obj);
        }
        return obj;
      },
      removePlotBandOrLine: function(id) {
        var plotLinesAndBands = this.plotLinesAndBands,
          options = this.options,
          userOptions = this.userOptions,
          i = plotLinesAndBands.length;
        while (i--) {
          if (plotLinesAndBands[i].id === id) {
            plotLinesAndBands[i].destroy();
          }
        }
        each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function(arr) {
          i = arr.length;
          while (i--) {
            if (arr[i].id === id) {
              erase(arr, arr[i]);
            }
          }
        });
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var correctFloat = H.correctFloat,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      isNumber = H.isNumber,
      merge = H.merge,
      pick = H.pick,
      deg2rad = H.deg2rad;
    H.Tick = function(axis, pos, type, noLabel) {
      this.axis = axis;
      this.pos = pos;
      this.type = type || '';
      this.isNew = true;
      if (!type && !noLabel) {
        this.addLabel();
      }
    };
    H.Tick.prototype = {
      addLabel: function() {
        var tick = this,
          axis = tick.axis,
          options = axis.options,
          chart = axis.chart,
          categories = axis.categories,
          names = axis.names,
          pos = tick.pos,
          labelOptions = options.labels,
          str,
          tickPositions = axis.tickPositions,
          isFirst = pos === tickPositions[0],
          isLast = pos === tickPositions[tickPositions.length - 1],
          value = categories ?
          pick(categories[pos], names[pos], pos) :
          pos,
          label = tick.label,
          tickPositionInfo = tickPositions.info,
          dateTimeLabelFormat;
        if (axis.isDatetimeAxis && tickPositionInfo) {
          dateTimeLabelFormat =
            options.dateTimeLabelFormats[
              tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName
            ];
        }
        tick.isFirst = isFirst;
        tick.isLast = isLast;
        str = axis.labelFormatter.call({
          axis: axis,
          chart: chart,
          isFirst: isFirst,
          isLast: isLast,
          dateTimeLabelFormat: dateTimeLabelFormat,
          value: axis.isLog ? correctFloat(axis.lin2log(value)) : value
        });
        if (!defined(label)) {
          tick.label = label =
            defined(str) && labelOptions.enabled ?
            chart.renderer.text(
              str,
              0,
              0,
              labelOptions.useHTML
            )
            .css(merge(labelOptions.style))
            .add(axis.labelGroup) :
            null;
          tick.labelLength = label && label.getBBox().width;
          tick.rotation = 0;
        } else if (label) {
          label.attr({
            text: str
          });
        }
      },
      getLabelSize: function() {
        return this.label ?
          this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
          0;
      },
      handleOverflow: function(xy) {
        var axis = this.axis,
          pxPos = xy.x,
          chartWidth = axis.chart.chartWidth,
          spacing = axis.chart.spacing,
          leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),
          rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),
          label = this.label,
          rotation = this.rotation,
          factor = {
            left: 0,
            center: 0.5,
            right: 1
          } [axis.labelAlign],
          labelWidth = label.getBBox().width,
          slotWidth = axis.getSlotWidth(),
          modifiedSlotWidth = slotWidth,
          xCorrection = factor,
          goRight = 1,
          leftPos,
          rightPos,
          textWidth,
          css = {};
        if (!rotation) {
          leftPos = pxPos - factor * labelWidth;
          rightPos = pxPos + (1 - factor) * labelWidth;
          if (leftPos < leftBound) {
            modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
          } else if (rightPos > rightBound) {
            modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
            goRight = -1;
          }
          modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
          if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
            xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *
              (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
          }
          if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {
            textWidth = modifiedSlotWidth;
          }
        } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
          textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);
        } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
          textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));
        }
        if (textWidth) {
          css.width = textWidth;
          if (!(axis.options.labels.style || {}).textOverflow) {
            css.textOverflow = 'ellipsis';
          }
          label.css(css);
        }
      },
      getPosition: function(horiz, pos, tickmarkOffset, old) {
        var axis = this.axis,
          chart = axis.chart,
          cHeight = (old && chart.oldChartHeight) || chart.chartHeight;
        return {
          x: horiz ?
            axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset +
            (axis.opposite ?
              ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :
              0
            ),
          y: horiz ?
            cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
        };
      },
      getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
        var axis = this.axis,
          transA = axis.transA,
          reversed = axis.reversed,
          staggerLines = axis.staggerLines,
          rotCorr = axis.tickRotCorr || {
            x: 0,
            y: 0
          },
          yOffset = labelOptions.y,
          line;
        if (!defined(yOffset)) {
          if (axis.side === 0) {
            yOffset = label.rotation ? -8 : -label.getBBox().height;
          } else if (axis.side === 2) {
            yOffset = rotCorr.y + 8;
          } else {
            yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
          }
        }
        x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
          tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
        y = y + yOffset - (tickmarkOffset && !horiz ?
          tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
        if (staggerLines) {
          line = (index / (step || 1) % staggerLines);
          if (axis.opposite) {
            line = staggerLines - line - 1;
          }
          y += line * (axis.labelOffset / staggerLines);
        }
        return {
          x: x,
          y: Math.round(y)
        };
      },
      getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {
        return renderer.crispLine([
          'M',
          x,
          y,
          'L',
          x + (horiz ? 0 : -tickLength),
          y + (horiz ? tickLength : 0)
        ], tickWidth);
      },
      render: function(index, old, opacity) {
        var tick = this,
          axis = tick.axis,
          options = axis.options,
          chart = axis.chart,
          renderer = chart.renderer,
          horiz = axis.horiz,
          type = tick.type,
          label = tick.label,
          pos = tick.pos,
          labelOptions = options.labels,
          gridLine = tick.gridLine,
          tickPrefix = type ? type + 'Tick' : 'tick',
          tickSize = axis.tickSize(tickPrefix),
          gridLinePath,
          mark = tick.mark,
          isNewMark = !mark,
          step = labelOptions.step,
          attribs = {},
          show = true,
          tickmarkOffset = axis.tickmarkOffset,
          xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
          x = xy.x,
          y = xy.y,
          reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
            (!horiz && y === axis.pos)) ? -1 : 1;
        var gridPrefix = type ? type + 'Grid' : 'grid',
          gridLineWidth = options[gridPrefix + 'LineWidth'],
          gridLineColor = options[gridPrefix + 'LineColor'],
          dashStyle = options[gridPrefix + 'LineDashStyle'],
          tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0),
          tickColor = options[tickPrefix + 'Color'];
        opacity = pick(opacity, 1);
        this.isActive = true;
        if (!gridLine) {
          attribs.stroke = gridLineColor;
          attribs['stroke-width'] = gridLineWidth;
          if (dashStyle) {
            attribs.dashstyle = dashStyle;
          }
          if (!type) {
            attribs.zIndex = 1;
          }
          if (old) {
            attribs.opacity = 0;
          }
          tick.gridLine = gridLine = renderer.path()
            .attr(attribs)
            .addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line')
            .add(axis.gridGroup);
        }
        if (!old && gridLine) {
          gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, true);
          if (gridLinePath) {
            gridLine[tick.isNew ? 'attr' : 'animate']({
              d: gridLinePath,
              opacity: opacity
            });
          }
        }
        if (tickSize) {
          if (axis.opposite) {
            tickSize[0] = -tickSize[0];
          }
          if (isNewMark) {
            tick.mark = mark = renderer.path()
              .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
              .add(axis.axisGroup);
            mark.attr({
              stroke: tickColor,
              'stroke-width': tickWidth
            });
          }
          mark[isNewMark ? 'attr' : 'animate']({
            d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, horiz, renderer),
            opacity: opacity
          });
        }
        if (label && isNumber(x)) {
          label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
          if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
            (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
            show = false;
          } else if (horiz && !axis.isRadial && !labelOptions.step &&
            !labelOptions.rotation && !old && opacity !== 0) {
            tick.handleOverflow(xy);
          }
          if (step && index % step) {
            show = false;
          }
          if (show && isNumber(xy.y)) {
            xy.opacity = opacity;
            label[tick.isNew ? 'attr' : 'animate'](xy);
          } else {
            label.attr('y', -9999);
          }
          tick.isNew = false;
        }
      },
      destroy: function() {
        destroyObjectProperties(this, this.axis);
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      animObject = H.animObject,
      arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      AxisPlotLineOrBandExtension = H.AxisPlotLineOrBandExtension,
      color = H.color,
      correctFloat = H.correctFloat,
      defaultOptions = H.defaultOptions,
      defined = H.defined,
      deg2rad = H.deg2rad,
      destroyObjectProperties = H.destroyObjectProperties,
      each = H.each,
      extend = H.extend,
      fireEvent = H.fireEvent,
      format = H.format,
      getMagnitude = H.getMagnitude,
      grep = H.grep,
      inArray = H.inArray,
      isArray = H.isArray,
      isNumber = H.isNumber,
      isString = H.isString,
      merge = H.merge,
      normalizeTickInterval = H.normalizeTickInterval,
      pick = H.pick,
      PlotLineOrBand = H.PlotLineOrBand,
      removeEvent = H.removeEvent,
      splat = H.splat,
      syncTimeout = H.syncTimeout,
      Tick = H.Tick;
    H.Axis = function() {
      this.init.apply(this, arguments);
    };
    H.Axis.prototype = {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: '%H:%M:%S.%L',
          second: '%H:%M:%S',
          minute: '%H:%M',
          hour: '%H:%M',
          day: '%e. %b',
          week: '%e. %b',
          month: '%b \'%y',
          year: '%Y'
        },
        endOnTick: false,
        labels: {
          enabled: true,
          style: {
            color: '#666666',
            cursor: 'default',
            fontSize: '11px'
          },
          x: 0
        },
        minPadding: 0.01,
        maxPadding: 0.01,
        minorTickLength: 2,
        minorTickPosition: 'outside',
        startOfWeek: 1,
        startOnTick: false,
        tickLength: 10,
        tickmarkPlacement: 'between',
        tickPixelInterval: 100,
        tickPosition: 'outside',
        title: {
          align: 'middle',
          style: {
            color: '#666666'
          }
        },
        type: 'linear',
        minorGridLineColor: '#f2f2f2',
        minorGridLineWidth: 1,
        minorTickColor: '#999999',
        lineColor: '#ccd6eb',
        lineWidth: 1,
        gridLineColor: '#e6e6e6',
        tickColor: '#ccd6eb'
      },
      defaultYAxisOptions: {
        endOnTick: true,
        tickPixelInterval: 72,
        showLastLabel: true,
        labels: {
          x: -8
        },
        maxPadding: 0.05,
        minPadding: 0.05,
        startOnTick: true,
        title: {
          rotation: 270,
          text: 'Values'
        },
        stackLabels: {
          enabled: false,
          formatter: function() {
            return H.numberFormat(this.total, -1);
          },
          style: {
            fontSize: '11px',
            fontWeight: 'bold',
            color: '#000000',
            textOutline: '1px contrast'
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      init: function(chart, userOptions) {
        var isXAxis = userOptions.isX,
          axis = this;
        axis.chart = chart;
        axis.horiz = chart.inverted ? !isXAxis : isXAxis;
        axis.isXAxis = isXAxis;
        axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');
        axis.opposite = userOptions.opposite;
        axis.side = userOptions.side || (axis.horiz ?
          (axis.opposite ? 0 : 2) :
          (axis.opposite ? 1 : 3));
        axis.setOptions(userOptions);
        var options = this.options,
          type = options.type,
          isDatetimeAxis = type === 'datetime';
        axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter;
        axis.userOptions = userOptions;
        axis.minPixelPadding = 0;
        axis.reversed = options.reversed;
        axis.visible = options.visible !== false;
        axis.zoomEnabled = options.zoomEnabled !== false;
        axis.hasNames = type === 'category' || options.categories === true;
        axis.categories = options.categories || axis.hasNames;
        axis.names = axis.names || [];
        axis.isLog = type === 'logarithmic';
        axis.isDatetimeAxis = isDatetimeAxis;
        axis.isLinked = defined(options.linkedTo);
        axis.ticks = {};
        axis.labelEdge = [];
        axis.minorTicks = {};
        axis.plotLinesAndBands = [];
        axis.alternateBands = {};
        axis.len = 0;
        axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
        axis.range = options.range;
        axis.offset = options.offset || 0;
        axis.stacks = {};
        axis.oldStacks = {};
        axis.stacksTouched = 0;
        axis.max = null;
        axis.min = null;
        axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
        var eventType,
          events = axis.options.events;
        if (inArray(axis, chart.axes) === -1) {
          if (isXAxis) {
            chart.axes.splice(chart.xAxis.length, 0, axis);
          } else {
            chart.axes.push(axis);
          }
          chart[axis.coll].push(axis);
        }
        axis.series = axis.series || [];
        if (chart.inverted && isXAxis && axis.reversed === undefined) {
          axis.reversed = true;
        }
        axis.removePlotBand = axis.removePlotBandOrLine;
        axis.removePlotLine = axis.removePlotBandOrLine;
        for (eventType in events) {
          addEvent(axis, eventType, events[eventType]);
        }
        if (axis.isLog) {
          axis.val2lin = axis.log2lin;
          axis.lin2val = axis.lin2log;
        }
      },
      setOptions: function(userOptions) {
        this.options = merge(
          this.defaultOptions,
          this.coll === 'yAxis' && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions,
            this.defaultBottomAxisOptions, this.defaultLeftAxisOptions
          ][this.side],
          merge(
            defaultOptions[this.coll],
            userOptions
          )
        );
      },
      defaultLabelFormatter: function() {
        var axis = this.axis,
          value = this.value,
          categories = axis.categories,
          dateTimeLabelFormat = this.dateTimeLabelFormat,
          lang = defaultOptions.lang,
          numericSymbols = lang.numericSymbols,
          numSymMagnitude = lang.numericSymbolMagnitude || 1000,
          i = numericSymbols && numericSymbols.length,
          multi,
          ret,
          formatOption = axis.options.labels.format,
          numericSymbolDetector = axis.isLog ? value : axis.tickInterval;
        if (formatOption) {
          ret = format(formatOption, this);
        } else if (categories) {
          ret = value;
        } else if (dateTimeLabelFormat) {
          ret = H.dateFormat(dateTimeLabelFormat, value);
        } else if (i && numericSymbolDetector >= 1000) {
          while (i-- && ret === undefined) {
            multi = Math.pow(numSymMagnitude, i + 1);
            if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null && value !== 0) {
              ret = H.numberFormat(value / multi, -1) + numericSymbols[i];
            }
          }
        }
        if (ret === undefined) {
          if (Math.abs(value) >= 10000) {
            ret = H.numberFormat(value, -1);
          } else {
            ret = H.numberFormat(value, -1, undefined, '');
          }
        }
        return ret;
      },
      getSeriesExtremes: function() {
        var axis = this,
          chart = axis.chart;
        axis.hasVisibleSeries = false;
        axis.dataMin = axis.dataMax = axis.threshold = null;
        axis.softThreshold = !axis.isXAxis;
        if (axis.buildStacks) {
          axis.buildStacks();
        }
        each(axis.series, function(series) {
          if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
            var seriesOptions = series.options,
              xData,
              threshold = seriesOptions.threshold,
              seriesDataMin,
              seriesDataMax;
            axis.hasVisibleSeries = true;
            if (axis.isLog && threshold <= 0) {
              threshold = null;
            }
            if (axis.isXAxis) {
              xData = series.xData;
              if (xData.length) {
                seriesDataMin = arrayMin(xData);
                if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date)) {
                  xData = grep(xData, function(x) {
                    return isNumber(x);
                  });
                  seriesDataMin = arrayMin(xData);
                }
                axis.dataMin = Math.min(pick(axis.dataMin, xData[0]), seriesDataMin);
                axis.dataMax = Math.max(pick(axis.dataMax, xData[0]), arrayMax(xData));
              }
            } else {
              series.getExtremes();
              seriesDataMax = series.dataMax;
              seriesDataMin = series.dataMin;
              if (defined(seriesDataMin) && defined(seriesDataMax)) {
                axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);
              }
              if (defined(threshold)) {
                axis.threshold = threshold;
              }
              if (!seriesOptions.softThreshold || axis.isLog) {
                axis.softThreshold = false;
              }
            }
          }
        });
      },
      translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
        var axis = this.linkedParent || this,
          sign = 1,
          cvsOffset = 0,
          localA = old ? axis.oldTransA : axis.transA,
          localMin = old ? axis.oldMin : axis.min,
          returnValue,
          minPixelPadding = axis.minPixelPadding,
          doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;
        if (!localA) {
          localA = axis.transA;
        }
        if (cvsCoord) {
          sign *= -1;
          cvsOffset = axis.len;
        }
        if (axis.reversed) {
          sign *= -1;
          cvsOffset -= sign * (axis.sector || axis.len);
        }
        if (backwards) {
          val = val * sign + cvsOffset;
          val -= minPixelPadding;
          returnValue = val / localA + localMin;
          if (doPostTranslate) {
            returnValue = axis.lin2val(returnValue);
          }
        } else {
          if (doPostTranslate) {
            val = axis.val2lin(val);
          }
          returnValue = sign * (val - localMin) * localA + cvsOffset +
            (sign * minPixelPadding) +
            (isNumber(pointPlacement) ? localA * pointPlacement : 0);
        }
        return returnValue;
      },
      toPixels: function(value, paneCoordinates) {
        return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
      },
      toValue: function(pixel, paneCoordinates) {
        return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
      },
      getPlotLinePath: function(value, lineWidth, old, force, translatedValue) {
        var axis = this,
          chart = axis.chart,
          axisLeft = axis.left,
          axisTop = axis.top,
          x1,
          y1,
          x2,
          y2,
          cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
          cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
          skip,
          transB = axis.transB,
          between = function(x, a, b) {
            if (x < a || x > b) {
              if (force) {
                x = Math.min(Math.max(a, x), b);
              } else {
                skip = true;
              }
            }
            return x;
          };
        translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
        x1 = x2 = Math.round(translatedValue + transB);
        y1 = y2 = Math.round(cHeight - translatedValue - transB);
        if (!isNumber(translatedValue)) {
          skip = true;
        } else if (axis.horiz) {
          y1 = axisTop;
          y2 = cHeight - axis.bottom;
          x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
        } else {
          x1 = axisLeft;
          x2 = cWidth - axis.right;
          y1 = y2 = between(y1, axisTop, axisTop + axis.height);
        }
        return skip && !force ?
          null :
          chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);
      },
      getLinearTickPositions: function(tickInterval, min, max) {
        var pos,
          lastPos,
          roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),
          roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),
          tickPositions = [];
        if (min === max && isNumber(min)) {
          return [min];
        }
        pos = roundedMin;
        while (pos <= roundedMax) {
          tickPositions.push(pos);
          pos = correctFloat(pos + tickInterval);
          if (pos === lastPos) {
            break;
          }
          lastPos = pos;
        }
        return tickPositions;
      },
      getMinorTickPositions: function() {
        var axis = this,
          options = axis.options,
          tickPositions = axis.tickPositions,
          minorTickInterval = axis.minorTickInterval,
          minorTickPositions = [],
          pos,
          i,
          pointRangePadding = axis.pointRangePadding || 0,
          min = axis.min - pointRangePadding,
          max = axis.max + pointRangePadding,
          range = max - min,
          len;
        if (range && range / minorTickInterval < axis.len / 3) {
          if (axis.isLog) {
            len = tickPositions.length;
            for (i = 1; i < len; i++) {
              minorTickPositions = minorTickPositions.concat(
                axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
              );
            }
          } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') {
            minorTickPositions = minorTickPositions.concat(
              axis.getTimeTicks(
                axis.normalizeTimeTickInterval(minorTickInterval),
                min,
                max,
                options.startOfWeek
              )
            );
          } else {
            for (
              pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval
            ) {
              if (pos === minorTickPositions[0]) {
                break;
              }
              minorTickPositions.push(pos);
            }
          }
        }
        if (minorTickPositions.length !== 0) {
          axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick);
        }
        return minorTickPositions;
      },
      adjustForMinRange: function() {
        var axis = this,
          options = axis.options,
          min = axis.min,
          max = axis.max,
          zoomOffset,
          spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
          closestDataRange,
          i,
          distance,
          xData,
          loopLength,
          minArgs,
          maxArgs,
          minRange;
        if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {
          if (defined(options.min) || defined(options.max)) {
            axis.minRange = null;
          } else {
            each(axis.series, function(series) {
              xData = series.xData;
              loopLength = series.xIncrement ? 1 : xData.length - 1;
              for (i = loopLength; i > 0; i--) {
                distance = xData[i] - xData[i - 1];
                if (closestDataRange === undefined || distance < closestDataRange) {
                  closestDataRange = distance;
                }
              }
            });
            axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
          }
        }
        if (max - min < axis.minRange) {
          minRange = axis.minRange;
          zoomOffset = (minRange - max + min) / 2;
          minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
          if (spaceAvailable) {
            minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;
          }
          min = arrayMax(minArgs);
          maxArgs = [min + minRange, pick(options.max, min + minRange)];
          if (spaceAvailable) {
            maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;
          }
          max = arrayMin(maxArgs);
          if (max - min < minRange) {
            minArgs[0] = max - minRange;
            minArgs[1] = pick(options.min, max - minRange);
            min = arrayMax(minArgs);
          }
        }
        axis.min = min;
        axis.max = max;
      },
      getClosest: function() {
        var ret;
        if (this.categories) {
          ret = 1;
        } else {
          each(this.series, function(series) {
            var seriesClosest = series.closestPointRange,
              visible = series.visible ||
              !series.chart.options.chart.ignoreHiddenSeries;
            if (!series.noSharedTooltip &&
              defined(seriesClosest) &&
              visible
            ) {
              ret = defined(ret) ?
                Math.min(ret, seriesClosest) :
                seriesClosest;
            }
          });
        }
        return ret;
      },
      nameToX: function(point) {
        var explicitCategories = isArray(this.categories),
          names = explicitCategories ? this.categories : this.names,
          nameX = point.options.x,
          x;
        point.series.requireSorting = false;
        if (!defined(nameX)) {
          nameX = this.options.uniqueNames === false ?
            point.series.autoIncrement() :
            inArray(point.name, names);
        }
        if (nameX === -1) {
          if (!explicitCategories) {
            x = names.length;
          }
        } else {
          x = nameX;
        }
        this.names[x] = point.name;
        return x;
      },
      updateNames: function() {
        var axis = this;
        if (this.names.length > 0) {
          this.names.length = 0;
          this.minRange = undefined;
          each(this.series || [], function(series) {
            series.xIncrement = null;
            if (!series.points || series.isDirtyData) {
              series.processData();
              series.generatePoints();
            }
            each(series.points, function(point, i) {
              var x;
              if (point.options) {
                x = axis.nameToX(point);
                if (x !== point.x) {
                  point.x = x;
                  series.xData[i] = x;
                }
              }
            });
          });
        }
      },
      setAxisTranslation: function(saveOld) {
        var axis = this,
          range = axis.max - axis.min,
          pointRange = axis.axisPointRange || 0,
          closestPointRange,
          minPointOffset = 0,
          pointRangePadding = 0,
          linkedParent = axis.linkedParent,
          ordinalCorrection,
          hasCategories = !!axis.categories,
          transA = axis.transA,
          isXAxis = axis.isXAxis;
        if (isXAxis || hasCategories || pointRange) {
          closestPointRange = axis.getClosest();
          if (linkedParent) {
            minPointOffset = linkedParent.minPointOffset;
            pointRangePadding = linkedParent.pointRangePadding;
          } else {
            each(axis.series, function(series) {
              var seriesPointRange = hasCategories ?
                1 :
                (isXAxis ?
                  pick(series.options.pointRange, closestPointRange, 0) :
                  (axis.axisPointRange || 0)),
                pointPlacement = series.options.pointPlacement;
              pointRange = Math.max(pointRange, seriesPointRange);
              if (!axis.single) {
                minPointOffset = Math.max(
                  minPointOffset,
                  isString(pointPlacement) ? 0 : seriesPointRange / 2
                );
                pointRangePadding = Math.max(
                  pointRangePadding,
                  pointPlacement === 'on' ? 0 : seriesPointRange
                );
              }
            });
          }
          ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1;
          axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
          axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
          axis.pointRange = Math.min(pointRange, range);
          if (isXAxis) {
            axis.closestPointRange = closestPointRange;
          }
        }
        if (saveOld) {
          axis.oldTransA = transA;
        }
        axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
        axis.transB = axis.horiz ? axis.left : axis.bottom;
        axis.minPixelPadding = transA * minPointOffset;
      },
      minFromRange: function() {
        return this.max - this.range;
      },
      setTickInterval: function(secondPass) {
        var axis = this,
          chart = axis.chart,
          options = axis.options,
          isLog = axis.isLog,
          log2lin = axis.log2lin,
          isDatetimeAxis = axis.isDatetimeAxis,
          isXAxis = axis.isXAxis,
          isLinked = axis.isLinked,
          maxPadding = options.maxPadding,
          minPadding = options.minPadding,
          length,
          linkedParentExtremes,
          tickIntervalOption = options.tickInterval,
          minTickInterval,
          tickPixelIntervalOption = options.tickPixelInterval,
          categories = axis.categories,
          threshold = axis.threshold,
          softThreshold = axis.softThreshold,
          thresholdMin,
          thresholdMax,
          hardMin,
          hardMax;
        if (!isDatetimeAxis && !categories && !isLinked) {
          this.getTickAmount();
        }
        hardMin = pick(axis.userMin, options.min);
        hardMax = pick(axis.userMax, options.max);
        if (isLinked) {
          axis.linkedParent = chart[axis.coll][options.linkedTo];
          linkedParentExtremes = axis.linkedParent.getExtremes();
          axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
          axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
          if (options.type !== axis.linkedParent.options.type) {
            H.error(11, 1);
          }
        } else {
          if (!softThreshold && defined(threshold)) {
            if (axis.dataMin >= threshold) {
              thresholdMin = threshold;
              minPadding = 0;
            } else if (axis.dataMax <= threshold) {
              thresholdMax = threshold;
              maxPadding = 0;
            }
          }
          axis.min = pick(hardMin, thresholdMin, axis.dataMin);
          axis.max = pick(hardMax, thresholdMax, axis.dataMax);
        }
        if (isLog) {
          if (!secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {
            H.error(10, 1);
          }
          axis.min = correctFloat(log2lin(axis.min), 15);
          axis.max = correctFloat(log2lin(axis.max), 15);
        }
        if (axis.range && defined(axis.max)) {
          axis.userMin = axis.min = hardMin = Math.max(axis.min, axis.minFromRange());
          axis.userMax = hardMax = axis.max;
          axis.range = null;
        }
        fireEvent(axis, 'foundExtremes');
        if (axis.beforePadding) {
          axis.beforePadding();
        }
        axis.adjustForMinRange();
        if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
          length = axis.max - axis.min;
          if (length) {
            if (!defined(hardMin) && minPadding) {
              axis.min -= length * minPadding;
            }
            if (!defined(hardMax) && maxPadding) {
              axis.max += length * maxPadding;
            }
          }
        }
        if (isNumber(options.floor)) {
          axis.min = Math.max(axis.min, options.floor);
        } else if (isNumber(options.softMin)) {
          axis.min = Math.min(axis.min, options.softMin);
        }
        if (isNumber(options.ceiling)) {
          axis.max = Math.min(axis.max, options.ceiling);
        } else if (isNumber(options.softMax)) {
          axis.max = Math.max(axis.max, options.softMax);
        }
        if (softThreshold && defined(axis.dataMin)) {
          threshold = threshold || 0;
          if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
            axis.min = threshold;
          } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
            axis.max = threshold;
          }
        }
        if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
          axis.tickInterval = 1;
        } else if (isLinked && !tickIntervalOption &&
          tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
          axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
        } else {
          axis.tickInterval = pick(
            tickIntervalOption,
            this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,
            categories ?
            1 :
            (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
          );
        }
        if (isXAxis && !secondPass) {
          each(axis.series, function(series) {
            series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
          });
        }
        axis.setAxisTranslation(true);
        if (axis.beforeSetTickPositions) {
          axis.beforeSetTickPositions();
        }
        if (axis.postProcessTickInterval) {
          axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
        }
        if (axis.pointRange && !tickIntervalOption) {
          axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
        }
        minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
        if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
          axis.tickInterval = minTickInterval;
        }
        if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
          axis.tickInterval = normalizeTickInterval(
            axis.tickInterval,
            null,
            getMagnitude(axis.tickInterval),
            pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount
          );
        }
        if (!this.tickAmount) {
          axis.tickInterval = axis.unsquish();
        }
        this.setTickPositions();
      },
      setTickPositions: function() {
        var options = this.options,
          tickPositions,
          tickPositionsOption = options.tickPositions,
          tickPositioner = options.tickPositioner,
          startOnTick = options.startOnTick,
          endOnTick = options.endOnTick,
          single;
        this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
          this.tickInterval === 1) ? 0.5 : 0;
        this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
          this.tickInterval / 5 : options.minorTickInterval;
        this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();
        if (!tickPositions) {
          if (this.isDatetimeAxis) {
            tickPositions = this.getTimeTicks(
              this.normalizeTimeTickInterval(this.tickInterval, options.units),
              this.min,
              this.max,
              options.startOfWeek,
              this.ordinalPositions,
              this.closestPointRange,
              true
            );
          } else if (this.isLog) {
            tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
          } else {
            tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
          }
          if (tickPositions.length > this.len) {
            tickPositions = [tickPositions[0], tickPositions.pop()];
          }
          this.tickPositions = tickPositions;
          if (tickPositioner) {
            tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
            if (tickPositioner) {
              this.tickPositions = tickPositions = tickPositioner;
            }
          }
        }
        this.trimTicks(tickPositions, startOnTick, endOnTick);
        if (!this.isLinked) {
          if (this.min === this.max && defined(this.min) && !this.tickAmount) {
            single = true;
            this.min -= 0.5;
            this.max += 0.5;
          }
          this.single = single;
          if (!tickPositionsOption && !tickPositioner) {
            this.adjustTickAmount();
          }
        }
      },
      trimTicks: function(tickPositions, startOnTick, endOnTick) {
        var roundedMin = tickPositions[0],
          roundedMax = tickPositions[tickPositions.length - 1],
          minPointOffset = this.minPointOffset || 0;
        if (!this.isLinked) {
          if (startOnTick) {
            this.min = roundedMin;
          } else {
            while (this.min - minPointOffset > tickPositions[0]) {
              tickPositions.shift();
            }
          }
          if (endOnTick) {
            this.max = roundedMax;
          } else {
            while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
              tickPositions.pop();
            }
          }
          if (tickPositions.length === 0 && defined(roundedMin)) {
            tickPositions.push((roundedMax + roundedMin) / 2);
          }
        }
      },
      alignToOthers: function() {
        var others = {},
          hasOther,
          options = this.options;
        if (
          this.chart.options.chart.alignTicks !== false &&
          options.alignTicks !== false &&
          !this.isLog
        ) {
          each(this.chart[this.coll], function(axis) {
            var otherOptions = axis.options,
              horiz = axis.horiz,
              key = [
                horiz ? otherOptions.left : otherOptions.top,
                otherOptions.width,
                otherOptions.height,
                otherOptions.pane
              ].join(',');
            if (axis.series.length) {
              if (others[key]) {
                hasOther = true;
              } else {
                others[key] = 1;
              }
            }
          });
        }
        return hasOther;
      },
      getTickAmount: function() {
        var options = this.options,
          tickAmount = options.tickAmount,
          tickPixelInterval = options.tickPixelInterval;
        if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
          !this.isLog && options.startOnTick && options.endOnTick) {
          tickAmount = 2;
        }
        if (!tickAmount && this.alignToOthers()) {
          tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
        }
        if (tickAmount < 4) {
          this.finalTickAmt = tickAmount;
          tickAmount = 5;
        }
        this.tickAmount = tickAmount;
      },
      adjustTickAmount: function() {
        var tickInterval = this.tickInterval,
          tickPositions = this.tickPositions,
          tickAmount = this.tickAmount,
          finalTickAmt = this.finalTickAmt,
          currentTickAmount = tickPositions && tickPositions.length,
          i,
          len;
        if (currentTickAmount < tickAmount) {
          while (tickPositions.length < tickAmount) {
            tickPositions.push(correctFloat(
              tickPositions[tickPositions.length - 1] + tickInterval
            ));
          }
          this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
          this.max = tickPositions[tickPositions.length - 1];
        } else if (currentTickAmount > tickAmount) {
          this.tickInterval *= 2;
          this.setTickPositions();
        }
        if (defined(finalTickAmt)) {
          i = len = tickPositions.length;
          while (i--) {
            if (
              (finalTickAmt === 3 && i % 2 === 1) ||
              (finalTickAmt <= 2 && i > 0 && i < len - 1)
            ) {
              tickPositions.splice(i, 1);
            }
          }
          this.finalTickAmt = undefined;
        }
      },
      setScale: function() {
        var axis = this,
          isDirtyData,
          isDirtyAxisLength;
        axis.oldMin = axis.min;
        axis.oldMax = axis.max;
        axis.oldAxisLength = axis.len;
        axis.setAxisSize();
        isDirtyAxisLength = axis.len !== axis.oldAxisLength;
        each(axis.series, function(series) {
          if (series.isDirtyData || series.isDirty ||
            series.xAxis.isDirty) {
            isDirtyData = true;
          }
        });
        if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
          axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {
          if (axis.resetStacks) {
            axis.resetStacks();
          }
          axis.forceRedraw = false;
          axis.getSeriesExtremes();
          axis.setTickInterval();
          axis.oldUserMin = axis.userMin;
          axis.oldUserMax = axis.userMax;
          if (!axis.isDirty) {
            axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
          }
        } else if (axis.cleanStacks) {
          axis.cleanStacks();
        }
      },
      setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {
        var axis = this,
          chart = axis.chart;
        redraw = pick(redraw, true);
        each(axis.series, function(serie) {
          delete serie.kdTree;
        });
        eventArguments = extend(eventArguments, {
          min: newMin,
          max: newMax
        });
        fireEvent(axis, 'setExtremes', eventArguments, function() {
          axis.userMin = newMin;
          axis.userMax = newMax;
          axis.eventArgs = eventArguments;
          if (redraw) {
            chart.redraw(animation);
          }
        });
      },
      zoom: function(newMin, newMax) {
        var dataMin = this.dataMin,
          dataMax = this.dataMax,
          options = this.options,
          min = Math.min(dataMin, pick(options.min, dataMin)),
          max = Math.max(dataMax, pick(options.max, dataMax));
        if (newMin !== this.min || newMax !== this.max) {
          if (!this.allowZoomOutside) {
            if (defined(dataMin)) {
              if (newMin < min) {
                newMin = min;
              }
              if (newMin > max) {
                newMin = max;
              }
            }
            if (defined(dataMax)) {
              if (newMax < min) {
                newMax = min;
              }
              if (newMax > max) {
                newMax = max;
              }
            }
          }
          this.displayBtn = newMin !== undefined || newMax !== undefined;
          this.setExtremes(
            newMin,
            newMax,
            false,
            undefined, {
              trigger: 'zoom'
            }
          );
        }
        return true;
      },
      setAxisSize: function() {
        var chart = this.chart,
          options = this.options,
          offsets = options.offsets || [0, 0, 0, 0],
          horiz = this.horiz,
          width = pick(options.width, chart.plotWidth - offsets[3] + offsets[1]),
          height = pick(options.height, chart.plotHeight - offsets[0] + offsets[2]),
          top = pick(options.top, chart.plotTop + offsets[0]),
          left = pick(options.left, chart.plotLeft + offsets[3]),
          percentRegex = /%$/;
        if (percentRegex.test(height)) {
          height = Math.round(parseFloat(height) / 100 * chart.plotHeight);
        }
        if (percentRegex.test(top)) {
          top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);
        }
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.bottom = chart.chartHeight - height - top;
        this.right = chart.chartWidth - width - left;
        this.len = Math.max(horiz ? width : height, 0);
        this.pos = horiz ? left : top;
      },
      getExtremes: function() {
        var axis = this,
          isLog = axis.isLog,
          lin2log = axis.lin2log;
        return {
          min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
          max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
          dataMin: axis.dataMin,
          dataMax: axis.dataMax,
          userMin: axis.userMin,
          userMax: axis.userMax
        };
      },
      getThreshold: function(threshold) {
        var axis = this,
          isLog = axis.isLog,
          lin2log = axis.lin2log,
          realMin = isLog ? lin2log(axis.min) : axis.min,
          realMax = isLog ? lin2log(axis.max) : axis.max;
        if (threshold === null) {
          threshold = realMin;
        } else if (realMin > threshold) {
          threshold = realMin;
        } else if (realMax < threshold) {
          threshold = realMax;
        }
        return axis.translate(threshold, 0, 1, 0, 1);
      },
      autoLabelAlign: function(rotation) {
        var ret,
          angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;
        if (angle > 15 && angle < 165) {
          ret = 'right';
        } else if (angle > 195 && angle < 345) {
          ret = 'left';
        } else {
          ret = 'center';
        }
        return ret;
      },
      tickSize: function(prefix) {
        var options = this.options,
          tickLength = options[prefix + 'Length'],
          tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0);
        if (tickWidth && tickLength) {
          if (options[prefix + 'Position'] === 'inside') {
            tickLength = -tickLength;
          }
          return [tickLength, tickWidth];
        }
      },
      labelMetrics: function() {
        return this.chart.renderer.fontMetrics(
          this.options.labels.style && this.options.labels.style.fontSize,
          this.ticks[0] && this.ticks[0].label
        );
      },
      unsquish: function() {
        var labelOptions = this.options.labels,
          horiz = this.horiz,
          tickInterval = this.tickInterval,
          newTickInterval = tickInterval,
          slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
          rotation,
          rotationOption = labelOptions.rotation,
          labelMetrics = this.labelMetrics(),
          step,
          bestScore = Number.MAX_VALUE,
          autoRotation,
          getStep = function(spaceNeeded) {
            var step = spaceNeeded / (slotSize || 1);
            step = step > 1 ? Math.ceil(step) : 1;
            return step * tickInterval;
          };
        if (horiz) {
          autoRotation = !labelOptions.staggerLines && !labelOptions.step && (
            defined(rotationOption) ? [rotationOption] :
            slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
          );
          if (autoRotation) {
            each(autoRotation, function(rot) {
              var score;
              if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) {
                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));
                score = step + Math.abs(rot / 360);
                if (score < bestScore) {
                  bestScore = score;
                  rotation = rot;
                  newTickInterval = step;
                }
              }
            });
          }
        } else if (!labelOptions.step) {
          newTickInterval = getStep(labelMetrics.h);
        }
        this.autoRotation = autoRotation;
        this.labelRotation = pick(rotation, rotationOption);
        return newTickInterval;
      },
      getSlotWidth: function() {
        var chart = this.chart,
          horiz = this.horiz,
          labelOptions = this.options.labels,
          slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          marginLeft = chart.margin[3];
        return (
          horiz &&
          (labelOptions.step || 0) < 2 &&
          !labelOptions.rotation &&
          ((this.staggerLines || 1) * this.len) / slotCount
        ) || (!horiz && (
          (marginLeft && (marginLeft - chart.spacing[3])) ||
          chart.chartWidth * 0.33
        ));
      },
      renderUnsquish: function() {
        var chart = this.chart,
          renderer = chart.renderer,
          tickPositions = this.tickPositions,
          ticks = this.ticks,
          labelOptions = this.options.labels,
          horiz = this.horiz,
          slotWidth = this.getSlotWidth(),
          innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),
          attr = {},
          labelMetrics = this.labelMetrics(),
          textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,
          css,
          maxLabelLength = 0,
          label,
          i,
          pos;
        if (!isString(labelOptions.rotation)) {
          attr.rotation = labelOptions.rotation || 0;
        }
        each(tickPositions, function(tick) {
          tick = ticks[tick];
          if (tick && tick.labelLength > maxLabelLength) {
            maxLabelLength = tick.labelLength;
          }
        });
        this.maxLabelLength = maxLabelLength;
        if (this.autoRotation) {
          if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
            attr.rotation = this.labelRotation;
          } else {
            this.labelRotation = 0;
          }
        } else if (slotWidth) {
          css = {
            width: innerWidth + 'px'
          };
          if (!textOverflowOption) {
            css.textOverflow = 'clip';
            i = tickPositions.length;
            while (!horiz && i--) {
              pos = tickPositions[i];
              label = ticks[pos].label;
              if (label) {
                if (label.styles && label.styles.textOverflow === 'ellipsis') {
                  label.css({
                    textOverflow: 'clip'
                  });
                } else if (ticks[pos].labelLength > slotWidth) {
                  label.css({
                    width: slotWidth + 'px'
                  });
                }
                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                  label.specCss = {
                    textOverflow: 'ellipsis'
                  };
                }
              }
            }
          }
        }
        if (attr.rotation) {
          css = {
            width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'
          };
          if (!textOverflowOption) {
            css.textOverflow = 'ellipsis';
          }
        }
        this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
        if (this.labelAlign) {
          attr.align = this.labelAlign;
        }
        each(tickPositions, function(pos) {
          var tick = ticks[pos],
            label = tick && tick.label;
          if (label) {
            label.attr(attr);
            if (css) {
              label.css(merge(css, label.specCss));
            }
            delete label.specCss;
            tick.rotation = attr.rotation;
          }
        });
        this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
      },
      hasData: function() {
        return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
      },
      addTitle: function(display) {
        var axis = this,
          renderer = axis.chart.renderer,
          horiz = axis.horiz,
          opposite = axis.opposite,
          options = axis.options,
          axisTitleOptions = options.title,
          textAlign;
        if (!axis.axisTitle) {
          textAlign = axisTitleOptions.textAlign;
          if (!textAlign) {
            textAlign = (horiz ? {
              low: 'left',
              middle: 'center',
              high: 'right'
            } : {
              low: opposite ? 'right' : 'left',
              middle: 'center',
              high: opposite ? 'left' : 'right'
            })[axisTitleOptions.align];
          }
          axis.axisTitle = renderer.text(
              axisTitleOptions.text,
              0,
              0,
              axisTitleOptions.useHTML
            )
            .attr({
              zIndex: 7,
              rotation: axisTitleOptions.rotation || 0,
              align: textAlign
            })
            .addClass('highcharts-axis-title')
            .css(axisTitleOptions.style)
            .add(axis.axisGroup);
          axis.axisTitle.isNew = true;
        }
        axis.axisTitle[display ? 'show' : 'hide'](true);
      },
      generateTick: function(pos) {
        var ticks = this.ticks;
        if (!ticks[pos]) {
          ticks[pos] = new Tick(this, pos);
        } else {
          ticks[pos].addLabel();
        }
      },
      getOffset: function() {
        var axis = this,
          chart = axis.chart,
          renderer = chart.renderer,
          options = axis.options,
          tickPositions = axis.tickPositions,
          ticks = axis.ticks,
          horiz = axis.horiz,
          side = axis.side,
          invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
          hasData,
          showAxis,
          titleOffset = 0,
          titleOffsetOption,
          titleMargin = 0,
          axisTitleOptions = options.title,
          labelOptions = options.labels,
          labelOffset = 0,
          labelOffsetPadded,
          axisOffset = chart.axisOffset,
          clipOffset = chart.clipOffset,
          clip,
          directionFactor = [-1, 1, 1, -1][side],
          n,
          className = options.className,
          axisParent = axis.axisParent,
          lineHeightCorrection,
          tickSize = this.tickSize('tick');
        hasData = axis.hasData();
        axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);
        axis.staggerLines = axis.horiz && labelOptions.staggerLines;
        if (!axis.axisGroup) {
          axis.gridGroup = renderer.g('grid')
            .attr({
              zIndex: options.gridZIndex || 1
            })
            .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || ''))
            .add(axisParent);
          axis.axisGroup = renderer.g('axis')
            .attr({
              zIndex: options.zIndex || 2
            })
            .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || ''))
            .add(axisParent);
          axis.labelGroup = renderer.g('axis-labels')
            .attr({
              zIndex: labelOptions.zIndex || 7
            })
            .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))
            .add(axisParent);
        }
        if (hasData || axis.isLinked) {
          each(tickPositions, function(pos, i) {
            axis.generateTick(pos, i);
          });
          axis.renderUnsquish();
          if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 || {
              1: 'left',
              3: 'right'
            } [side] === axis.labelAlign || axis.labelAlign === 'center')) {
            each(tickPositions, function(pos) {
              labelOffset = Math.max(
                ticks[pos].getLabelSize(),
                labelOffset
              );
            });
          }
          if (axis.staggerLines) {
            labelOffset *= axis.staggerLines;
            axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
          }
        } else {
          for (n in ticks) {
            ticks[n].destroy();
            delete ticks[n];
          }
        }
        if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
          axis.addTitle(showAxis);
          if (showAxis) {
            titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
            titleOffsetOption = axisTitleOptions.offset;
            titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
          }
        }
        axis.renderLine();
        axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
        axis.tickRotCorr = axis.tickRotCorr || {
          x: 0,
          y: 0
        };
        if (side === 0) {
          lineHeightCorrection = -axis.labelMetrics().h;
        } else if (side === 2) {
          lineHeightCorrection = axis.tickRotCorr.y;
        } else {
          lineHeightCorrection = 0;
        }
        labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
        if (labelOffset) {
          labelOffsetPadded -= lineHeightCorrection;
          labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
        }
        axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);
        axisOffset[side] = Math.max(
          axisOffset[side],
          axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
          labelOffsetPadded,
          hasData && tickPositions.length && tickSize ? tickSize[0] : 0
        );
        clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2;
        clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
      },
      getLinePath: function(lineWidth) {
        var chart = this.chart,
          opposite = this.opposite,
          offset = this.offset,
          horiz = this.horiz,
          lineLeft = this.left + (opposite ? this.width : 0) + offset,
          lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
        if (opposite) {
          lineWidth *= -1;
        }
        return chart.renderer
          .crispLine([
            'M',
            horiz ?
            this.left :
            lineLeft,
            horiz ?
            lineTop :
            this.top,
            'L',
            horiz ?
            chart.chartWidth - this.right :
            lineLeft,
            horiz ?
            lineTop :
            chart.chartHeight - this.bottom
          ], lineWidth);
      },
      renderLine: function() {
        if (!this.axisLine) {
          this.axisLine = this.chart.renderer.path()
            .addClass('highcharts-axis-line')
            .add(this.axisGroup);
          this.axisLine.attr({
            stroke: this.options.lineColor,
            'stroke-width': this.options.lineWidth,
            zIndex: 7
          });
        }
      },
      getTitlePosition: function() {
        var horiz = this.horiz,
          axisLeft = this.left,
          axisTop = this.top,
          axisLength = this.len,
          axisTitleOptions = this.options.title,
          margin = horiz ? axisLeft : axisTop,
          opposite = this.opposite,
          offset = this.offset,
          xOption = axisTitleOptions.x || 0,
          yOption = axisTitleOptions.y || 0,
          fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, this.axisTitle).f,
          alongAxis = {
            low: margin + (horiz ? 0 : axisLength),
            middle: margin + axisLength / 2,
            high: margin + (horiz ? axisLength : 0)
          } [axisTitleOptions.align],
          offAxis = (horiz ? axisTop + this.height : axisLeft) +
          (horiz ? 1 : -1) *
          (opposite ? -1 : 1) *
          this.axisTitleMargin +
          (this.side === 2 ? fontSize : 0);
        return {
          x: horiz ?
            alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
          y: horiz ?
            offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
        };
      },
      renderMinorTick: function(pos) {
        var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),
          minorTicks = this.minorTicks;
        if (!minorTicks[pos]) {
          minorTicks[pos] = new Tick(this, pos, 'minor');
        }
        if (slideInTicks && minorTicks[pos].isNew) {
          minorTicks[pos].render(null, true);
        }
        minorTicks[pos].render(null, false, 1);
      },
      renderTick: function(pos, i) {
        var isLinked = this.isLinked,
          ticks = this.ticks,
          slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);
        if (!isLinked || (pos >= this.min && pos <= this.max)) {
          if (!ticks[pos]) {
            ticks[pos] = new Tick(this, pos);
          }
          if (slideInTicks && ticks[pos].isNew) {
            ticks[pos].render(i, true, 0.1);
          }
          ticks[pos].render(i);
        }
      },
      render: function() {
        var axis = this,
          chart = axis.chart,
          renderer = chart.renderer,
          options = axis.options,
          isLog = axis.isLog,
          lin2log = axis.lin2log,
          isLinked = axis.isLinked,
          tickPositions = axis.tickPositions,
          axisTitle = axis.axisTitle,
          ticks = axis.ticks,
          minorTicks = axis.minorTicks,
          alternateBands = axis.alternateBands,
          stackLabelOptions = options.stackLabels,
          alternateGridColor = options.alternateGridColor,
          tickmarkOffset = axis.tickmarkOffset,
          axisLine = axis.axisLine,
          showAxis = axis.showAxis,
          animation = animObject(renderer.globalAnimation),
          from,
          to;
        axis.labelEdge.length = 0;
        axis.overlap = false;
        each([ticks, minorTicks, alternateBands], function(coll) {
          var pos;
          for (pos in coll) {
            coll[pos].isActive = false;
          }
        });
        if (axis.hasData() || isLinked) {
          if (axis.minorTickInterval && !axis.categories) {
            each(axis.getMinorTickPositions(), function(pos) {
              axis.renderMinorTick(pos);
            });
          }
          if (tickPositions.length) {
            each(tickPositions, function(pos, i) {
              axis.renderTick(pos, i);
            });
            if (tickmarkOffset && (axis.min === 0 || axis.single)) {
              if (!ticks[-1]) {
                ticks[-1] = new Tick(axis, -1, null, true);
              }
              ticks[-1].render(-1);
            }
          }
          if (alternateGridColor) {
            each(tickPositions, function(pos, i) {
              to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
              if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                if (!alternateBands[pos]) {
                  alternateBands[pos] = new PlotLineOrBand(axis);
                }
                from = pos + tickmarkOffset;
                alternateBands[pos].options = {
                  from: isLog ? lin2log(from) : from,
                  to: isLog ? lin2log(to) : to,
                  color: alternateGridColor
                };
                alternateBands[pos].render();
                alternateBands[pos].isActive = true;
              }
            });
          }
          if (!axis._addedPlotLB) {
            each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
              axis.addPlotBandOrLine(plotLineOptions);
            });
            axis._addedPlotLB = true;
          }
        }
        each([ticks, minorTicks, alternateBands], function(coll) {
          var pos,
            i,
            forDestruction = [],
            delay = animation.duration,
            destroyInactiveItems = function() {
              i = forDestruction.length;
              while (i--) {
                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                  coll[forDestruction[i]].destroy();
                  delete coll[forDestruction[i]];
                }
              }
            };
          for (pos in coll) {
            if (!coll[pos].isActive) {
              coll[pos].render(pos, false, 0);
              coll[pos].isActive = false;
              forDestruction.push(pos);
            }
          }
          syncTimeout(
            destroyInactiveItems,
            coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay
          );
        });
        if (axisLine) {
          axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
            d: this.getLinePath(axisLine.strokeWidth())
          });
          axisLine.isPlaced = true;
          axisLine[showAxis ? 'show' : 'hide'](true);
        }
        if (axisTitle && showAxis) {
          axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
            axis.getTitlePosition()
          );
          axisTitle.isNew = false;
        }
        if (stackLabelOptions && stackLabelOptions.enabled) {
          axis.renderStackTotals();
        }
        axis.isDirty = false;
      },
      redraw: function() {
        if (this.visible) {
          this.render();
          each(this.plotLinesAndBands, function(plotLine) {
            plotLine.render();
          });
        }
        each(this.series, function(series) {
          series.isDirty = true;
        });
      },
      keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],
      destroy: function(keepEvents) {
        var axis = this,
          stacks = axis.stacks,
          stackKey,
          plotLinesAndBands = axis.plotLinesAndBands,
          i,
          n;
        if (!keepEvents) {
          removeEvent(axis);
        }
        for (stackKey in stacks) {
          destroyObjectProperties(stacks[stackKey]);
          stacks[stackKey] = null;
        }
        each([axis.ticks, axis.minorTicks, axis.alternateBands], function(coll) {
          destroyObjectProperties(coll);
        });
        if (plotLinesAndBands) {
          i = plotLinesAndBands.length;
          while (i--) {
            plotLinesAndBands[i].destroy();
          }
        }
        each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function(prop) {
          if (axis[prop]) {
            axis[prop] = axis[prop].destroy();
          }
        });
        for (n in axis) {
          if (axis.hasOwnProperty(n) && inArray(n, axis.keepProps) === -1) {
            delete axis[n];
          }
        }
      },
      drawCrosshair: function(e, point) {
        var path,
          options = this.crosshair,
          snap = pick(options.snap, true),
          pos,
          categorized,
          graphic = this.cross;
        if (!e) {
          e = this.cross && this.cross.e;
        }
        if (
          !this.crosshair ||
          ((defined(point) || !snap) === false)
        ) {
          this.hideCrosshair();
        } else {
          if (!snap) {
            pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
          } else if (defined(point)) {
            pos = this.isXAxis ? point.plotX : this.len - point.plotY;
          }
          if (defined(pos)) {
            path = this.getPlotLinePath(
              point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
              null,
              null,
              null,
              pos
            ) || null;
          }
          if (!defined(path)) {
            this.hideCrosshair();
            return;
          }
          categorized = this.categories && !this.isRadial;
          if (!graphic) {
            this.cross = graphic = this.chart.renderer
              .path()
              .addClass('highcharts-crosshair highcharts-crosshair-' +
                (categorized ? 'category ' : 'thin ') + options.className)
              .attr({
                zIndex: pick(options.zIndex, 2)
              })
              .add();
            graphic.attr({
              'stroke': options.color || (categorized ? color('#ccd6eb').setOpacity(0.25).get() : '#cccccc'),
              'stroke-width': pick(options.width, 1)
            });
            if (options.dashStyle) {
              graphic.attr({
                dashstyle: options.dashStyle
              });
            }
          }
          graphic.show().attr({
            d: path
          });
          if (categorized && !options.width) {
            graphic.attr({
              'stroke-width': this.transA
            });
          }
          this.cross.e = e;
        }
      },
      hideCrosshair: function() {
        if (this.cross) {
          this.cross.hide();
        }
      }
    };
    extend(H.Axis.prototype, AxisPlotLineOrBandExtension);
  }(Highcharts));
  (function(H) {
    'use strict';
    var Axis = H.Axis,
      Date = H.Date,
      dateFormat = H.dateFormat,
      defaultOptions = H.defaultOptions,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      getMagnitude = H.getMagnitude,
      getTZOffset = H.getTZOffset,
      normalizeTickInterval = H.normalizeTickInterval,
      pick = H.pick,
      timeUnits = H.timeUnits;
    Axis.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {
      var tickPositions = [],
        i,
        higherRanks = {},
        useUTC = defaultOptions.global.useUTC,
        minYear,
        minDate = new Date(min - getTZOffset(min)),
        makeTime = Date.hcMakeTime,
        interval = normalizedInterval.unitRange,
        count = normalizedInterval.count,
        variableDayLength;
      if (defined(min)) {
        minDate[Date.hcSetMilliseconds](interval >= timeUnits.second ? 0 :
          count * Math.floor(minDate.getMilliseconds() / count));
        if (interval >= timeUnits.second) {
          minDate[Date.hcSetSeconds](interval >= timeUnits.minute ? 0 :
            count * Math.floor(minDate.getSeconds() / count));
        }
        if (interval >= timeUnits.minute) {
          minDate[Date.hcSetMinutes](interval >= timeUnits.hour ? 0 :
            count * Math.floor(minDate[Date.hcGetMinutes]() / count));
        }
        if (interval >= timeUnits.hour) {
          minDate[Date.hcSetHours](interval >= timeUnits.day ? 0 :
            count * Math.floor(minDate[Date.hcGetHours]() / count));
        }
        if (interval >= timeUnits.day) {
          minDate[Date.hcSetDate](interval >= timeUnits.month ? 1 :
            count * Math.floor(minDate[Date.hcGetDate]() / count));
        }
        if (interval >= timeUnits.month) {
          minDate[Date.hcSetMonth](interval >= timeUnits.year ? 0 :
            count * Math.floor(minDate[Date.hcGetMonth]() / count));
          minYear = minDate[Date.hcGetFullYear]();
        }
        if (interval >= timeUnits.year) {
          minYear -= minYear % count;
          minDate[Date.hcSetFullYear](minYear);
        }
        if (interval === timeUnits.week) {
          minDate[Date.hcSetDate](minDate[Date.hcGetDate]() - minDate[Date.hcGetDay]() +
            pick(startOfWeek, 1));
        }
        minYear = minDate[Date.hcGetFullYear]();
        var minMonth = minDate[Date.hcGetMonth](),
          minDateDate = minDate[Date.hcGetDate](),
          minHours = minDate[Date.hcGetHours]();
        if (Date.hcTimezoneOffset || Date.hcGetTimezoneOffset) {
          variableDayLength =
            (!useUTC || !!Date.hcGetTimezoneOffset) &&
            (
              max - min > 4 * timeUnits.month ||
              getTZOffset(min) !== getTZOffset(max)
            );
          minDate = minDate.getTime();
          minDate = new Date(minDate + getTZOffset(minDate));
        }
        var time = minDate.getTime();
        i = 1;
        while (time < max) {
          tickPositions.push(time);
          if (interval === timeUnits.year) {
            time = makeTime(minYear + i * count, 0);
          } else if (interval === timeUnits.month) {
            time = makeTime(minYear, minMonth + i * count);
          } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {
            time = makeTime(minYear, minMonth, minDateDate +
              i * count * (interval === timeUnits.day ? 1 : 7));
          } else if (variableDayLength && interval === timeUnits.hour) {
            time = makeTime(minYear, minMonth, minDateDate, minHours + i * count);
          } else {
            time += interval * count;
          }
          i++;
        }
        tickPositions.push(time);
        if (interval <= timeUnits.hour && tickPositions.length < 10000) {
          each(tickPositions, function(time) {
            if (
              time % 1800000 === 0 &&
              dateFormat('%H%M%S%L', time) === '000000000'
            ) {
              higherRanks[time] = 'day';
            }
          });
        }
      }
      tickPositions.info = extend(normalizedInterval, {
        higherRanks: higherRanks,
        totalRange: interval * count
      });
      return tickPositions;
    };
    Axis.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
      var units = unitsOption || [
          [
            'millisecond',
            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
          ],
          [
            'second', [1, 2, 5, 10, 15, 30]
          ],
          [
            'minute', [1, 2, 5, 10, 15, 30]
          ],
          [
            'hour', [1, 2, 3, 4, 6, 8, 12]
          ],
          [
            'day', [1, 2]
          ],
          [
            'week', [1, 2]
          ],
          [
            'month', [1, 2, 3, 4, 6]
          ],
          [
            'year',
            null
          ]
        ],
        unit = units[units.length - 1],
        interval = timeUnits[unit[0]],
        multiples = unit[1],
        count,
        i;
      for (i = 0; i < units.length; i++) {
        unit = units[i];
        interval = timeUnits[unit[0]];
        multiples = unit[1];
        if (units[i + 1]) {
          var lessThan = (interval * multiples[multiples.length - 1] +
            timeUnits[units[i + 1][0]]) / 2;
          if (tickInterval <= lessThan) {
            break;
          }
        }
      }
      if (interval === timeUnits.year && tickInterval < 5 * interval) {
        multiples = [1, 2, 5];
      }
      count = normalizeTickInterval(
        tickInterval / interval,
        multiples,
        unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1
      );
      return {
        unitRange: interval,
        count: count,
        unitName: unit[0]
      };
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var Axis = H.Axis,
      getMagnitude = H.getMagnitude,
      map = H.map,
      normalizeTickInterval = H.normalizeTickInterval,
      pick = H.pick;
    Axis.prototype.getLogTickPositions = function(interval, min, max, minor) {
      var axis = this,
        options = axis.options,
        axisLength = axis.len,
        lin2log = axis.lin2log,
        log2lin = axis.log2lin,
        positions = [];
      if (!minor) {
        axis._minorAutoInterval = null;
      }
      if (interval >= 0.5) {
        interval = Math.round(interval);
        positions = axis.getLinearTickPositions(interval, min, max);
      } else if (interval >= 0.08) {
        var roundedMin = Math.floor(min),
          intermediate,
          i,
          j,
          len,
          pos,
          lastPos,
          break2;
        if (interval > 0.3) {
          intermediate = [1, 2, 4];
        } else if (interval > 0.15) {
          intermediate = [1, 2, 4, 6, 8];
        } else {
          intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        }
        for (i = roundedMin; i < max + 1 && !break2; i++) {
          len = intermediate.length;
          for (j = 0; j < len && !break2; j++) {
            pos = log2lin(lin2log(i) * intermediate[j]);
            if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) {
              positions.push(lastPos);
            }
            if (lastPos > max) {
              break2 = true;
            }
            lastPos = pos;
          }
        }
      } else {
        var realMin = lin2log(min),
          realMax = lin2log(max),
          tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
          filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
          tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
          totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
        interval = pick(
          filteredTickIntervalOption,
          axis._minorAutoInterval,
          (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
        );
        interval = normalizeTickInterval(
          interval,
          null,
          getMagnitude(interval)
        );
        positions = map(axis.getLinearTickPositions(
          interval,
          realMin,
          realMax
        ), log2lin);
        if (!minor) {
          axis._minorAutoInterval = interval / 5;
        }
      }
      if (!minor) {
        axis.tickInterval = interval;
      }
      return positions;
    };
    Axis.prototype.log2lin = function(num) {
      return Math.log(num) / Math.LN10;
    };
    Axis.prototype.lin2log = function(num) {
      return Math.pow(10, num);
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var dateFormat = H.dateFormat,
      each = H.each,
      extend = H.extend,
      format = H.format,
      isNumber = H.isNumber,
      map = H.map,
      merge = H.merge,
      pick = H.pick,
      splat = H.splat,
      syncTimeout = H.syncTimeout,
      timeUnits = H.timeUnits;
    H.Tooltip = function() {
      this.init.apply(this, arguments);
    };
    H.Tooltip.prototype = {
      init: function(chart, options) {
        this.chart = chart;
        this.options = options;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = true;
        this.split = options.split && !chart.inverted;
        this.shared = options.shared || this.split;
      },
      cleanSplit: function(force) {
        each(this.chart.series, function(series) {
          var tt = series && series.tt;
          if (tt) {
            if (!tt.isActive || force) {
              series.tt = tt.destroy();
            } else {
              tt.isActive = false;
            }
          }
        });
      },
      getLabel: function() {
        var renderer = this.chart.renderer,
          options = this.options;
        if (!this.label) {
          if (this.split) {
            this.label = renderer.g('tooltip');
          } else {
            this.label = renderer.label(
                '',
                0,
                0,
                options.shape || 'callout',
                null,
                null,
                options.useHTML,
                null,
                'tooltip'
              )
              .attr({
                padding: options.padding,
                r: options.borderRadius
              });
            this.label
              .attr({
                'fill': options.backgroundColor,
                'stroke-width': options.borderWidth
              })
              .css(options.style)
              .shadow(options.shadow);
          }
          this.label
            .attr({
              zIndex: 8
            })
            .add();
        }
        return this.label;
      },
      update: function(options) {
        this.destroy();
        this.init(this.chart, merge(true, this.options, options));
      },
      destroy: function() {
        if (this.label) {
          this.label = this.label.destroy();
        }
        if (this.split && this.tt) {
          this.cleanSplit(this.chart, true);
          this.tt = this.tt.destroy();
        }
        clearTimeout(this.hideTimer);
        clearTimeout(this.tooltipTimeout);
      },
      move: function(x, y, anchorX, anchorY) {
        var tooltip = this,
          now = tooltip.now,
          animate = tooltip.options.animation !== false && !tooltip.isHidden &&
          (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
          skipAnchor = tooltip.followPointer || tooltip.len > 1;
        extend(now, {
          x: animate ? (2 * now.x + x) / 3 : x,
          y: animate ? (now.y + y) / 2 : y,
          anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
          anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY
        });
        tooltip.getLabel().attr(now);
        if (animate) {
          clearTimeout(this.tooltipTimeout);
          this.tooltipTimeout = setTimeout(function() {
            if (tooltip) {
              tooltip.move(x, y, anchorX, anchorY);
            }
          }, 32);
        }
      },
      hide: function(delay) {
        var tooltip = this;
        clearTimeout(this.hideTimer);
        delay = pick(delay, this.options.hideDelay, 500);
        if (!this.isHidden) {
          this.hideTimer = syncTimeout(function() {
            tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
            tooltip.isHidden = true;
          }, delay);
        }
      },
      getAnchor: function(points, mouseEvent) {
        var ret,
          chart = this.chart,
          inverted = chart.inverted,
          plotTop = chart.plotTop,
          plotLeft = chart.plotLeft,
          plotX = 0,
          plotY = 0,
          yAxis,
          xAxis;
        points = splat(points);
        ret = points[0].tooltipPos;
        if (this.followPointer && mouseEvent) {
          if (mouseEvent.chartX === undefined) {
            mouseEvent = chart.pointer.normalize(mouseEvent);
          }
          ret = [
            mouseEvent.chartX - chart.plotLeft,
            mouseEvent.chartY - plotTop
          ];
        }
        if (!ret) {
          each(points, function(point) {
            yAxis = point.series.yAxis;
            xAxis = point.series.xAxis;
            plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
            plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
              (!inverted && yAxis ? yAxis.top - plotTop : 0);
          });
          plotX /= points.length;
          plotY /= points.length;
          ret = [
            inverted ? chart.plotWidth - plotY : plotX,
            this.shared && !inverted && points.length > 1 && mouseEvent ?
            mouseEvent.chartY - plotTop :
            inverted ? chart.plotHeight - plotX : plotY
          ];
        }
        return map(ret, Math.round);
      },
      getPosition: function(boxWidth, boxHeight, point) {
        var chart = this.chart,
          distance = this.distance,
          ret = {},
          h = point.h || 0,
          swapped,
          first = ['y', chart.chartHeight, boxHeight,
            point.plotY + chart.plotTop, chart.plotTop,
            chart.plotTop + chart.plotHeight
          ],
          second = ['x', chart.chartWidth, boxWidth,
            point.plotX + chart.plotLeft, chart.plotLeft,
            chart.plotLeft + chart.plotWidth
          ],
          preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative),
          firstDimension = function(dim, outerSize, innerSize, point, min, max) {
            var roomLeft = innerSize < point - distance,
              roomRight = point + distance + innerSize < outerSize,
              alignedLeft = point - distance - innerSize,
              alignedRight = point + distance;
            if (preferFarSide && roomRight) {
              ret[dim] = alignedRight;
            } else if (!preferFarSide && roomLeft) {
              ret[dim] = alignedLeft;
            } else if (roomLeft) {
              ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
            } else if (roomRight) {
              ret[dim] = Math.max(
                min,
                alignedRight + h + innerSize > outerSize ?
                alignedRight :
                alignedRight + h
              );
            } else {
              return false;
            }
          },
          secondDimension = function(dim, outerSize, innerSize, point) {
            var retVal;
            if (point < distance || point > outerSize - distance) {
              retVal = false;
            } else if (point < innerSize / 2) {
              ret[dim] = 1;
            } else if (point > outerSize - innerSize / 2) {
              ret[dim] = outerSize - innerSize - 2;
            } else {
              ret[dim] = point - innerSize / 2;
            }
            return retVal;
          },
          swap = function(count) {
            var temp = first;
            first = second;
            second = temp;
            swapped = count;
          },
          run = function() {
            if (firstDimension.apply(0, first) !== false) {
              if (secondDimension.apply(0, second) === false && !swapped) {
                swap(true);
                run();
              }
            } else if (!swapped) {
              swap(true);
              run();
            } else {
              ret.x = ret.y = 0;
            }
          };
        if (chart.inverted || this.len > 1) {
          swap();
        }
        run();
        return ret;
      },
      defaultFormatter: function(tooltip) {
        var items = this.points || splat(this),
          s;
        s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
        s = s.concat(tooltip.bodyFormatter(items));
        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
        return s;
      },
      refresh: function(point, mouseEvent) {
        var tooltip = this,
          chart = tooltip.chart,
          label,
          options = tooltip.options,
          x,
          y,
          anchor,
          textConfig = {},
          text,
          pointConfig = [],
          formatter = options.formatter || tooltip.defaultFormatter,
          hoverPoints = chart.hoverPoints,
          shared = tooltip.shared,
          currentSeries;
        clearTimeout(this.hideTimer);
        tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
        anchor = tooltip.getAnchor(point, mouseEvent);
        x = anchor[0];
        y = anchor[1];
        if (shared && !(point.series && point.series.noSharedTooltip)) {
          chart.hoverPoints = point;
          if (hoverPoints) {
            each(hoverPoints, function(point) {
              point.setState();
            });
          }
          each(point, function(item) {
            item.setState('hover');
            pointConfig.push(item.getLabelConfig());
          });
          textConfig = {
            x: point[0].category,
            y: point[0].y
          };
          textConfig.points = pointConfig;
          point = point[0];
        } else {
          textConfig = point.getLabelConfig();
        }
        this.len = pointConfig.length;
        text = formatter.call(textConfig, tooltip);
        currentSeries = point.series;
        this.distance = pick(currentSeries.tooltipOptions.distance, 16);
        if (text === false) {
          this.hide();
        } else {
          label = tooltip.getLabel();
          if (tooltip.isHidden) {
            label.attr({
              opacity: 1
            }).show();
          }
          if (tooltip.split) {
            this.renderSplit(text, chart.hoverPoints);
          } else {
            label.attr({
              text: text && text.join ? text.join('') : text
            });
            label.removeClass(/highcharts-color-[\d]+/g)
              .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));
            label.attr({
              stroke: options.borderColor || point.color || currentSeries.color || '#666666'
            });
            tooltip.updatePosition({
              plotX: x,
              plotY: y,
              negative: point.negative,
              ttBelow: point.ttBelow,
              h: anchor[2] || 0
            });
          }
          this.isHidden = false;
        }
      },
      renderSplit: function(labels, points) {
        var tooltip = this,
          boxes = [],
          chart = this.chart,
          ren = chart.renderer,
          rightAligned = true,
          options = this.options,
          headerHeight,
          tooltipLabel = this.getLabel();
        each(labels.slice(0, points.length + 1), function(str, i) {
          var point = points[i - 1] || {
              isHeader: true,
              plotX: points[0].plotX
            },
            owner = point.series || tooltip,
            tt = owner.tt,
            series = point.series || {},
            colorClass = 'highcharts-color-' + pick(point.colorIndex, series.colorIndex, 'none'),
            target,
            x,
            bBox,
            boxWidth;
          if (!tt) {
            owner.tt = tt = ren.label(null, null, null, 'callout')
              .addClass('highcharts-tooltip-box ' + colorClass)
              .attr({
                'padding': options.padding,
                'r': options.borderRadius,
                'fill': options.backgroundColor,
                'stroke': point.color || series.color || '#333333',
                'stroke-width': options.borderWidth
              })
              .add(tooltipLabel);
          }
          tt.isActive = true;
          tt.attr({
            text: str
          });
          tt.css(options.style);
          bBox = tt.getBBox();
          boxWidth = bBox.width + tt.strokeWidth();
          if (point.isHeader) {
            headerHeight = bBox.height;
            x = Math.max(
              0,
              Math.min(
                point.plotX + chart.plotLeft - boxWidth / 2,
                chart.chartWidth - boxWidth
              )
            );
          } else {
            x = point.plotX + chart.plotLeft - pick(options.distance, 16) -
              boxWidth;
          }
          if (x < 0) {
            rightAligned = false;
          }
          target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);
          target -= chart.plotTop;
          boxes.push({
            target: point.isHeader ? chart.plotHeight + headerHeight : target,
            rank: point.isHeader ? 1 : 0,
            size: owner.tt.getBBox().height + 1,
            point: point,
            x: x,
            tt: tt
          });
        });
        this.cleanSplit();
        H.distribute(boxes, chart.plotHeight + headerHeight);
        each(boxes, function(box) {
          var point = box.point,
            series = point.series;
          box.tt.attr({
            visibility: box.pos === undefined ? 'hidden' : 'inherit',
            x: (rightAligned || point.isHeader ?
              box.x :
              point.plotX + chart.plotLeft + pick(options.distance, 16)),
            y: box.pos + chart.plotTop,
            anchorX: point.isHeader ?
              point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,
            anchorY: point.isHeader ?
              box.pos + chart.plotTop - 15 : point.plotY + series.yAxis.pos
          });
        });
      },
      updatePosition: function(point) {
        var chart = this.chart,
          label = this.getLabel(),
          pos = (this.options.positioner || this.getPosition).call(
            this,
            label.width,
            label.height,
            point
          );
        this.move(
          Math.round(pos.x),
          Math.round(pos.y || 0),
          point.plotX + chart.plotLeft,
          point.plotY + chart.plotTop
        );
      },
      getDateFormat: function(range, date, startOfWeek, dateTimeLabelFormats) {
        var dateStr = dateFormat('%m-%d %H:%M:%S.%L', date),
          format,
          n,
          blank = '01-01 00:00:00.000',
          strpos = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          lastN = 'millisecond';
        for (n in timeUnits) {
          if (range === timeUnits.week && +dateFormat('%w', date) === startOfWeek &&
            dateStr.substr(6) === blank.substr(6)) {
            n = 'week';
            break;
          }
          if (timeUnits[n] > range) {
            n = lastN;
            break;
          }
          if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
            break;
          }
          if (n !== 'week') {
            lastN = n;
          }
        }
        if (n) {
          format = dateTimeLabelFormats[n];
        }
        return format;
      },
      getXDateFormat: function(point, options, xAxis) {
        var xDateFormat,
          dateTimeLabelFormats = options.dateTimeLabelFormats,
          closestPointRange = xAxis && xAxis.closestPointRange;
        if (closestPointRange) {
          xDateFormat = this.getDateFormat(
            closestPointRange,
            point.x,
            xAxis.options.startOfWeek,
            dateTimeLabelFormats
          );
        } else {
          xDateFormat = dateTimeLabelFormats.day;
        }
        return xDateFormat || dateTimeLabelFormats.year;
      },
      tooltipFooterHeaderFormatter: function(labelConfig, isFooter) {
        var footOrHead = isFooter ? 'footer' : 'header',
          series = labelConfig.series,
          tooltipOptions = series.tooltipOptions,
          xDateFormat = tooltipOptions.xDateFormat,
          xAxis = series.xAxis,
          isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),
          formatString = tooltipOptions[footOrHead + 'Format'];
        if (isDateTime && !xDateFormat) {
          xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
        }
        if (isDateTime && xDateFormat) {
          formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
        }
        return format(formatString, {
          point: labelConfig,
          series: series
        });
      },
      bodyFormatter: function(items) {
        return map(items, function(item) {
          var tooltipOptions = item.series.tooltipOptions;
          return (tooltipOptions.pointFormatter || item.point.tooltipFormatter)
            .call(item.point, tooltipOptions.pointFormat);
        });
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      attr = H.attr,
      charts = H.charts,
      color = H.color,
      css = H.css,
      defined = H.defined,
      doc = H.doc,
      each = H.each,
      extend = H.extend,
      fireEvent = H.fireEvent,
      offset = H.offset,
      pick = H.pick,
      removeEvent = H.removeEvent,
      splat = H.splat,
      Tooltip = H.Tooltip,
      win = H.win;
    H.Pointer = function(chart, options) {
      this.init(chart, options);
    };
    H.Pointer.prototype = {
      init: function(chart, options) {
        this.options = options;
        this.chart = chart;
        this.runChartClick = options.chart.events && !!options.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        if (Tooltip && options.tooltip.enabled) {
          chart.tooltip = new Tooltip(chart, options.tooltip);
          this.followTouchMove = pick(options.tooltip.followTouchMove, true);
        }
        this.setDOMEvents();
      },
      zoomOption: function(e) {
        var chart = this.chart,
          options = chart.options.chart,
          zoomType = options.zoomType || '',
          inverted = chart.inverted,
          zoomX,
          zoomY;
        if (/touch/.test(e.type)) {
          zoomType = pick(options.pinchType, zoomType);
        }
        this.zoomX = zoomX = /x/.test(zoomType);
        this.zoomY = zoomY = /y/.test(zoomType);
        this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
        this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
        this.hasZoom = zoomX || zoomY;
      },
      normalize: function(e, chartPosition) {
        var chartX,
          chartY,
          ePos;
        e = e || win.event;
        if (!e.target) {
          e.target = e.srcElement;
        }
        ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;
        if (!chartPosition) {
          this.chartPosition = chartPosition = offset(this.chart.container);
        }
        if (ePos.pageX === undefined) {
          chartX = Math.max(e.x, e.clientX - chartPosition.left);
          chartY = e.y;
        } else {
          chartX = ePos.pageX - chartPosition.left;
          chartY = ePos.pageY - chartPosition.top;
        }
        return extend(e, {
          chartX: Math.round(chartX),
          chartY: Math.round(chartY)
        });
      },
      getCoordinates: function(e) {
        var coordinates = {
          xAxis: [],
          yAxis: []
        };
        each(this.chart.axes, function(axis) {
          coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
            axis: axis,
            value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
          });
        });
        return coordinates;
      },
      runPointActions: function(e) {
        var pointer = this,
          chart = pointer.chart,
          series = chart.series,
          tooltip = chart.tooltip,
          shared = tooltip ? tooltip.shared : false,
          followPointer,
          updatePosition = true,
          hoverPoint = chart.hoverPoint,
          hoverSeries = chart.hoverSeries,
          i,
          anchor,
          noSharedTooltip,
          stickToHoverSeries,
          directTouch,
          kdpoints = [],
          kdpointT;
        if (!shared && !hoverSeries) {
          for (i = 0; i < series.length; i++) {
            if (series[i].directTouch || !series[i].options.stickyTracking) {
              series = [];
            }
          }
        }
        stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);
        if (stickToHoverSeries && hoverPoint) {
          kdpoints = [hoverPoint];
        } else {
          if (!shared && hoverSeries && !hoverSeries.options.stickyTracking) {
            series = [hoverSeries];
          }
          each(series, function(s) {
            noSharedTooltip = s.noSharedTooltip && shared;
            directTouch = !shared && s.directTouch;
            if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) {
              kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1);
              if (kdpointT && kdpointT.series) {
                kdpoints.push(kdpointT);
              }
            }
          });
          kdpoints.sort(function(p1, p2) {
            var isCloserX = p1.distX - p2.distX,
              isCloser = p1.dist - p2.dist,
              isAbove = (p2.series.group && p2.series.group.zIndex) -
              (p1.series.group && p1.series.group.zIndex);
            if (isCloserX !== 0 && shared) {
              return isCloserX;
            }
            if (isCloser !== 0) {
              return isCloser;
            }
            if (isAbove !== 0) {
              return isAbove;
            }
            return p1.series.index > p2.series.index ? -1 : 1;
          });
        }
        if (shared) {
          i = kdpoints.length;
          while (i--) {
            if (kdpoints[i].x !== kdpoints[0].x || kdpoints[i].series.noSharedTooltip) {
              kdpoints.splice(i, 1);
            }
          }
        }
        if (kdpoints[0] && (kdpoints[0] !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
          if (shared && !kdpoints[0].series.noSharedTooltip) {
            for (i = 0; i < kdpoints.length; i++) {
              kdpoints[i].onMouseOver(e, kdpoints[i] !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoints[0]));
            }
            if (kdpoints.length && tooltip) {
              tooltip.refresh(kdpoints.sort(function(p1, p2) {
                return p1.series.index - p2.series.index;
              }), e);
            }
          } else {
            if (tooltip) {
              tooltip.refresh(kdpoints[0], e);
            }
            if (!hoverSeries || !hoverSeries.directTouch) {
              kdpoints[0].onMouseOver(e);
            }
          }
          this.prevKDPoint = kdpoints[0];
          updatePosition = false;
        }
        if (updatePosition) {
          followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
          if (tooltip && followPointer && !tooltip.isHidden) {
            anchor = tooltip.getAnchor([{}], e);
            tooltip.updatePosition({
              plotX: anchor[0],
              plotY: anchor[1]
            });
          }
        }
        if (!pointer.unDocMouseMove) {
          pointer.unDocMouseMove = addEvent(doc, 'mousemove', function(e) {
            if (charts[H.hoverChartIndex]) {
              charts[H.hoverChartIndex].pointer.onDocumentMouseMove(e);
            }
          });
        }
        each(shared ? kdpoints : [pick(hoverPoint, kdpoints[0])], function drawPointCrosshair(point) {
          each(chart.axes, function drawAxisCrosshair(axis) {
            if (!point || point.series && point.series[axis.coll] === axis) {
              axis.drawCrosshair(e, point);
            }
          });
        });
      },
      reset: function(allowMove, delay) {
        var pointer = this,
          chart = pointer.chart,
          hoverSeries = chart.hoverSeries,
          hoverPoint = chart.hoverPoint,
          hoverPoints = chart.hoverPoints,
          tooltip = chart.tooltip,
          tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
        if (allowMove && tooltipPoints) {
          each(splat(tooltipPoints), function(point) {
            if (point.series.isCartesian && point.plotX === undefined) {
              allowMove = false;
            }
          });
        }
        if (allowMove) {
          if (tooltip && tooltipPoints) {
            tooltip.refresh(tooltipPoints);
            if (hoverPoint) {
              hoverPoint.setState(hoverPoint.state, true);
              each(chart.axes, function(axis) {
                if (axis.crosshair) {
                  axis.drawCrosshair(null, hoverPoint);
                }
              });
            }
          }
        } else {
          if (hoverPoint) {
            hoverPoint.onMouseOut();
          }
          if (hoverPoints) {
            each(hoverPoints, function(point) {
              point.setState();
            });
          }
          if (hoverSeries) {
            hoverSeries.onMouseOut();
          }
          if (tooltip) {
            tooltip.hide(delay);
          }
          if (pointer.unDocMouseMove) {
            pointer.unDocMouseMove = pointer.unDocMouseMove();
          }
          each(chart.axes, function(axis) {
            axis.hideCrosshair();
          });
          pointer.hoverX = pointer.prevKDPoint = chart.hoverPoints = chart.hoverPoint = null;
        }
      },
      scaleGroups: function(attribs, clip) {
        var chart = this.chart,
          seriesAttribs;
        each(chart.series, function(series) {
          seriesAttribs = attribs || series.getPlotBox();
          if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
            series.group.attr(seriesAttribs);
            if (series.markerGroup) {
              series.markerGroup.attr(seriesAttribs);
              series.markerGroup.clip(clip ? chart.clipRect : null);
            }
            if (series.dataLabelsGroup) {
              series.dataLabelsGroup.attr(seriesAttribs);
            }
          }
        });
        chart.clipRect.attr(clip || chart.clipBox);
      },
      dragStart: function(e) {
        var chart = this.chart;
        chart.mouseIsDown = e.type;
        chart.cancelClick = false;
        chart.mouseDownX = this.mouseDownX = e.chartX;
        chart.mouseDownY = this.mouseDownY = e.chartY;
      },
      drag: function(e) {
        var chart = this.chart,
          chartOptions = chart.options.chart,
          chartX = e.chartX,
          chartY = e.chartY,
          zoomHor = this.zoomHor,
          zoomVert = this.zoomVert,
          plotLeft = chart.plotLeft,
          plotTop = chart.plotTop,
          plotWidth = chart.plotWidth,
          plotHeight = chart.plotHeight,
          clickedInside,
          size,
          selectionMarker = this.selectionMarker,
          mouseDownX = this.mouseDownX,
          mouseDownY = this.mouseDownY,
          panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];
        if (selectionMarker && selectionMarker.touch) {
          return;
        }
        if (chartX < plotLeft) {
          chartX = plotLeft;
        } else if (chartX > plotLeft + plotWidth) {
          chartX = plotLeft + plotWidth;
        }
        if (chartY < plotTop) {
          chartY = plotTop;
        } else if (chartY > plotTop + plotHeight) {
          chartY = plotTop + plotHeight;
        }
        this.hasDragged = Math.sqrt(
          Math.pow(mouseDownX - chartX, 2) +
          Math.pow(mouseDownY - chartY, 2)
        );
        if (this.hasDragged > 10) {
          clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
          if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
            if (!selectionMarker) {
              this.selectionMarker = selectionMarker = chart.renderer.rect(
                  plotLeft,
                  plotTop,
                  zoomHor ? 1 : plotWidth,
                  zoomVert ? 1 : plotHeight,
                  0
                )
                .attr({
                  fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),
                  'class': 'highcharts-selection-marker',
                  'zIndex': 7
                })
                .add();
            }
          }
          if (selectionMarker && zoomHor) {
            size = chartX - mouseDownX;
            selectionMarker.attr({
              width: Math.abs(size),
              x: (size > 0 ? 0 : size) + mouseDownX
            });
          }
          if (selectionMarker && zoomVert) {
            size = chartY - mouseDownY;
            selectionMarker.attr({
              height: Math.abs(size),
              y: (size > 0 ? 0 : size) + mouseDownY
            });
          }
          if (clickedInside && !selectionMarker && chartOptions.panning) {
            chart.pan(e, chartOptions.panning);
          }
        }
      },
      drop: function(e) {
        var pointer = this,
          chart = this.chart,
          hasPinched = this.hasPinched;
        if (this.selectionMarker) {
          var selectionData = {
              originalEvent: e,
              xAxis: [],
              yAxis: []
            },
            selectionBox = this.selectionMarker,
            selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
            selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
            selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
            selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
            runZoom;
          if (this.hasDragged || hasPinched) {
            each(chart.axes, function(axis) {
              if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
                  xAxis: 'zoomX',
                  yAxis: 'zoomY'
                } [axis.coll]])) {
                var horiz = axis.horiz,
                  minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0,
                  selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                  selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);
                selectionData[axis.coll].push({
                  axis: axis,
                  min: Math.min(selectionMin, selectionMax),
                  max: Math.max(selectionMin, selectionMax)
                });
                runZoom = true;
              }
            });
            if (runZoom) {
              fireEvent(chart, 'selection', selectionData, function(args) {
                chart.zoom(extend(args, hasPinched ? {
                  animation: false
                } : null));
              });
            }
          }
          this.selectionMarker = this.selectionMarker.destroy();
          if (hasPinched) {
            this.scaleGroups();
          }
        }
        if (chart) {
          css(chart.container, {
            cursor: chart._cursor
          });
          chart.cancelClick = this.hasDragged > 10;
          chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
          this.pinchDown = [];
        }
      },
      onContainerMouseDown: function(e) {
        e = this.normalize(e);
        this.zoomOption(e);
        if (e.preventDefault) {
          e.preventDefault();
        }
        this.dragStart(e);
      },
      onDocumentMouseUp: function(e) {
        if (charts[H.hoverChartIndex]) {
          charts[H.hoverChartIndex].pointer.drop(e);
        }
      },
      onDocumentMouseMove: function(e) {
        var chart = this.chart,
          chartPosition = this.chartPosition;
        e = this.normalize(e, chartPosition);
        if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
          !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
          this.reset();
        }
      },
      onContainerMouseLeave: function(e) {
        var chart = charts[H.hoverChartIndex];
        if (chart && (e.relatedTarget || e.toElement)) {
          chart.pointer.reset();
          chart.pointer.chartPosition = null;
        }
      },
      onContainerMouseMove: function(e) {
        var chart = this.chart;
        if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {
          H.hoverChartIndex = chart.index;
        }
        e = this.normalize(e);
        e.returnValue = false;
        if (chart.mouseIsDown === 'mousedown') {
          this.drag(e);
        }
        if ((this.inClass(e.target, 'highcharts-tracker') ||
            chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
          this.runPointActions(e);
        }
      },
      inClass: function(element, className) {
        var elemClassName;
        while (element) {
          elemClassName = attr(element, 'class');
          if (elemClassName) {
            if (elemClassName.indexOf(className) !== -1) {
              return true;
            }
            if (elemClassName.indexOf('highcharts-container') !== -1) {
              return false;
            }
          }
          element = element.parentNode;
        }
      },
      onTrackerMouseOut: function(e) {
        var series = this.chart.hoverSeries,
          relatedTarget = e.relatedTarget || e.toElement;
        if (series && relatedTarget && !series.options.stickyTracking &&
          !this.inClass(relatedTarget, 'highcharts-tooltip') &&
          (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) ||
            !this.inClass(relatedTarget, 'highcharts-tracker')
          )
        ) {
          series.onMouseOut();
        }
      },
      onContainerClick: function(e) {
        var chart = this.chart,
          hoverPoint = chart.hoverPoint,
          plotLeft = chart.plotLeft,
          plotTop = chart.plotTop;
        e = this.normalize(e);
        if (!chart.cancelClick) {
          if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {
            fireEvent(hoverPoint.series, 'click', extend(e, {
              point: hoverPoint
            }));
            if (chart.hoverPoint) {
              hoverPoint.firePointEvent('click', e);
            }
          } else {
            extend(e, this.getCoordinates(e));
            if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
              fireEvent(chart, 'click', e);
            }
          }
        }
      },
      setDOMEvents: function() {
        var pointer = this,
          container = pointer.chart.container;
        container.onmousedown = function(e) {
          pointer.onContainerMouseDown(e);
        };
        container.onmousemove = function(e) {
          pointer.onContainerMouseMove(e);
        };
        container.onclick = function(e) {
          pointer.onContainerClick(e);
        };
        addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
        if (H.chartCount === 1) {
          addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
        }
        if (H.hasTouch) {
          container.ontouchstart = function(e) {
            pointer.onContainerTouchStart(e);
          };
          container.ontouchmove = function(e) {
            pointer.onContainerTouchMove(e);
          };
          if (H.chartCount === 1) {
            addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
          }
        }
      },
      destroy: function() {
        var prop;
        removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
        if (!H.chartCount) {
          removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
          removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
        }
        clearInterval(this.tooltipTimeout);
        for (prop in this) {
          this[prop] = null;
        }
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var charts = H.charts,
      each = H.each,
      extend = H.extend,
      map = H.map,
      noop = H.noop,
      pick = H.pick,
      Pointer = H.Pointer;
    extend(Pointer.prototype, {
      pinchTranslate: function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
        if (this.zoomHor) {
          this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
        }
        if (this.zoomVert) {
          this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
        }
      },
      pinchTranslateDirection: function(horiz, pinchDown, touches, transform,
        selectionMarker, clip, lastValidTouch, forcedScale) {
        var chart = this.chart,
          xy = horiz ? 'x' : 'y',
          XY = horiz ? 'X' : 'Y',
          sChartXY = 'chart' + XY,
          wh = horiz ? 'width' : 'height',
          plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
          selectionWH,
          selectionXY,
          clipXY,
          scale = forcedScale || 1,
          inverted = chart.inverted,
          bounds = chart.bounds[horiz ? 'h' : 'v'],
          singleTouch = pinchDown.length === 1,
          touch0Start = pinchDown[0][sChartXY],
          touch0Now = touches[0][sChartXY],
          touch1Start = !singleTouch && pinchDown[1][sChartXY],
          touch1Now = !singleTouch && touches[1][sChartXY],
          outOfBounds,
          transformScale,
          scaleKey,
          setScale = function() {
            if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
              scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
            }
            clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
            selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
          };
        setScale();
        selectionXY = clipXY;
        if (selectionXY < bounds.min) {
          selectionXY = bounds.min;
          outOfBounds = true;
        } else if (selectionXY + selectionWH > bounds.max) {
          selectionXY = bounds.max - selectionWH;
          outOfBounds = true;
        }
        if (outOfBounds) {
          touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
          if (!singleTouch) {
            touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
          }
          setScale();
        } else {
          lastValidTouch[xy] = [touch0Now, touch1Now];
        }
        if (!inverted) {
          clip[xy] = clipXY - plotLeftTop;
          clip[wh] = selectionWH;
        }
        scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
        transformScale = inverted ? 1 / scale : scale;
        selectionMarker[wh] = selectionWH;
        selectionMarker[xy] = selectionXY;
        transform[scaleKey] = scale;
        transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
      },
      pinch: function(e) {
        var self = this,
          chart = self.chart,
          pinchDown = self.pinchDown,
          touches = e.touches,
          touchesLength = touches.length,
          lastValidTouch = self.lastValidTouch,
          hasZoom = self.hasZoom,
          selectionMarker = self.selectionMarker,
          transform = {},
          fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&
            chart.runTrackerClick) || self.runChartClick),
          clip = {};
        if (touchesLength > 1) {
          self.initiated = true;
        }
        if (hasZoom && self.initiated && !fireClickEvent) {
          e.preventDefault();
        }
        map(touches, function(e) {
          return self.normalize(e);
        });
        if (e.type === 'touchstart') {
          each(touches, function(e, i) {
            pinchDown[i] = {
              chartX: e.chartX,
              chartY: e.chartY
            };
          });
          lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
          lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
          each(chart.axes, function(axis) {
            if (axis.zoomEnabled) {
              var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
                minPixelPadding = axis.minPixelPadding,
                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
                absMin = Math.min(min, max),
                absMax = Math.max(min, max);
              bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
              bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
            }
          });
          self.res = true;
        } else if (self.followTouchMove && touchesLength === 1) {
          this.runPointActions(self.normalize(e));
        } else if (pinchDown.length) {
          if (!selectionMarker) {
            self.selectionMarker = selectionMarker = extend({
              destroy: noop,
              touch: true
            }, chart.plotBox);
          }
          self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
          self.hasPinched = hasZoom;
          self.scaleGroups(transform, clip);
          if (self.res) {
            self.res = false;
            this.reset(false, 0);
          }
        }
      },
      touch: function(e, start) {
        var chart = this.chart,
          hasMoved,
          pinchDown,
          isInside;
        if (chart.index !== H.hoverChartIndex) {
          this.onContainerMouseLeave({
            relatedTarget: true
          });
        }
        H.hoverChartIndex = chart.index;
        if (e.touches.length === 1) {
          e = this.normalize(e);
          isInside = chart.isInsidePlot(
            e.chartX - chart.plotLeft,
            e.chartY - chart.plotTop
          );
          if (isInside && !chart.openMenu) {
            if (start) {
              this.runPointActions(e);
            }
            if (e.type === 'touchmove') {
              pinchDown = this.pinchDown;
              hasMoved = pinchDown[0] ? Math.sqrt(
                Math.pow(pinchDown[0].chartX - e.chartX, 2) +
                Math.pow(pinchDown[0].chartY - e.chartY, 2)
              ) >= 4 : false;
            }
            if (pick(hasMoved, true)) {
              this.pinch(e);
            }
          } else if (start) {
            this.reset();
          }
        } else if (e.touches.length === 2) {
          this.pinch(e);
        }
      },
      onContainerTouchStart: function(e) {
        this.zoomOption(e);
        this.touch(e, true);
      },
      onContainerTouchMove: function(e) {
        this.touch(e);
      },
      onDocumentTouchEnd: function(e) {
        if (charts[H.hoverChartIndex]) {
          charts[H.hoverChartIndex].pointer.drop(e);
        }
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      charts = H.charts,
      css = H.css,
      doc = H.doc,
      extend = H.extend,
      noop = H.noop,
      Pointer = H.Pointer,
      removeEvent = H.removeEvent,
      win = H.win,
      wrap = H.wrap;
    if (win.PointerEvent || win.MSPointerEvent) {
      var touches = {},
        hasPointerEvent = !!win.PointerEvent,
        getWebkitTouches = function() {
          var key,
            fake = [];
          fake.item = function(i) {
            return this[i];
          };
          for (key in touches) {
            if (touches.hasOwnProperty(key)) {
              fake.push({
                pageX: touches[key].pageX,
                pageY: touches[key].pageY,
                target: touches[key].target
              });
            }
          }
          return fake;
        },
        translateMSPointer = function(e, method, wktype, func) {
          var p;
          if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {
            func(e);
            p = charts[H.hoverChartIndex].pointer;
            p[method]({
              type: wktype,
              target: e.currentTarget,
              preventDefault: noop,
              touches: getWebkitTouches()
            });
          }
        };
      extend(Pointer.prototype, {
        onContainerPointerDown: function(e) {
          translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function(e) {
            touches[e.pointerId] = {
              pageX: e.pageX,
              pageY: e.pageY,
              target: e.currentTarget
            };
          });
        },
        onContainerPointerMove: function(e) {
          translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function(e) {
            touches[e.pointerId] = {
              pageX: e.pageX,
              pageY: e.pageY
            };
            if (!touches[e.pointerId].target) {
              touches[e.pointerId].target = e.currentTarget;
            }
          });
        },
        onDocumentPointerUp: function(e) {
          translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function(e) {
            delete touches[e.pointerId];
          });
        },
        batchMSEvents: function(fn) {
          fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
          fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
          fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
        }
      });
      wrap(Pointer.prototype, 'init', function(proceed, chart, options) {
        proceed.call(this, chart, options);
        if (this.hasZoom) {
          css(chart.container, {
            '-ms-touch-action': 'none',
            'touch-action': 'none'
          });
        }
      });
      wrap(Pointer.prototype, 'setDOMEvents', function(proceed) {
        proceed.apply(this);
        if (this.hasZoom || this.followTouchMove) {
          this.batchMSEvents(addEvent);
        }
      });
      wrap(Pointer.prototype, 'destroy', function(proceed) {
        this.batchMSEvents(removeEvent);
        proceed.call(this);
      });
    }
  }(Highcharts));
  (function(H) {
    'use strict';
    var Legend,
      addEvent = H.addEvent,
      css = H.css,
      discardElement = H.discardElement,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      isFirefox = H.isFirefox,
      marginNames = H.marginNames,
      merge = H.merge,
      pick = H.pick,
      setAnimation = H.setAnimation,
      stableSort = H.stableSort,
      win = H.win,
      wrap = H.wrap;
    Legend = H.Legend = function(chart, options) {
      this.init(chart, options);
    };
    Legend.prototype = {
      init: function(chart, options) {
        this.chart = chart;
        this.setOptions(options);
        if (options.enabled) {
          this.render();
          addEvent(this.chart, 'endResize', function() {
            this.legend.positionCheckboxes();
          });
        }
      },
      setOptions: function(options) {
        var padding = pick(options.padding, 8);
        this.options = options;
        this.itemStyle = options.itemStyle;
        this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);
        this.itemMarginTop = options.itemMarginTop || 0;
        this.padding = padding;
        this.initialItemX = padding;
        this.initialItemY = padding - 5;
        this.maxItemWidth = 0;
        this.itemHeight = 0;
        this.symbolWidth = pick(options.symbolWidth, 16);
        this.pages = [];
      },
      update: function(options, redraw) {
        var chart = this.chart;
        this.setOptions(merge(true, this.options, options));
        this.destroy();
        chart.isDirtyLegend = chart.isDirtyBox = true;
        if (pick(redraw, true)) {
          chart.redraw();
        }
      },
      colorizeItem: function(item, visible) {
        item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');
        var legend = this,
          options = legend.options,
          legendItem = item.legendItem,
          legendLine = item.legendLine,
          legendSymbol = item.legendSymbol,
          hiddenColor = legend.itemHiddenStyle.color,
          textColor = visible ? options.itemStyle.color : hiddenColor,
          symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
          markerOptions = item.options && item.options.marker,
          symbolAttr = {
            fill: symbolColor
          },
          key;
        if (legendItem) {
          legendItem.css({
            fill: textColor,
            color: textColor
          });
        }
        if (legendLine) {
          legendLine.attr({
            stroke: symbolColor
          });
        }
        if (legendSymbol) {
          if (markerOptions && legendSymbol.isMarker) {
            symbolAttr = item.pointAttribs();
            if (!visible) {
              for (key in symbolAttr) {
                symbolAttr[key] = hiddenColor;
              }
            }
          }
          legendSymbol.attr(symbolAttr);
        }
      },
      positionItem: function(item) {
        var legend = this,
          options = legend.options,
          symbolPadding = options.symbolPadding,
          ltr = !options.rtl,
          legendItemPos = item._legendItemPos,
          itemX = legendItemPos[0],
          itemY = legendItemPos[1],
          checkbox = item.checkbox,
          legendGroup = item.legendGroup;
        if (legendGroup && legendGroup.element) {
          legendGroup.translate(
            ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
            itemY
          );
        }
        if (checkbox) {
          checkbox.x = itemX;
          checkbox.y = itemY;
        }
      },
      destroyItem: function(item) {
        var checkbox = item.checkbox;
        each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function(key) {
          if (item[key]) {
            item[key] = item[key].destroy();
          }
        });
        if (checkbox) {
          discardElement(item.checkbox);
        }
      },
      destroy: function() {
        function destroyItems(key) {
          if (this[key]) {
            this[key] = this[key].destroy();
          }
        }
        each(this.getAllItems(), function(item) {
          each(['legendItem', 'legendGroup'], destroyItems, item);
        });
        each(['box', 'title', 'group'], destroyItems, this);
        this.display = null;
      },
      positionCheckboxes: function(scrollOffset) {
        var alignAttr = this.group && this.group.alignAttr,
          translateY,
          clipHeight = this.clipHeight || this.legendHeight,
          titleHeight = this.titleHeight;
        if (alignAttr) {
          translateY = alignAttr.translateY;
          each(this.allItems, function(item) {
            var checkbox = item.checkbox,
              top;
            if (checkbox) {
              top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;
              css(checkbox, {
                left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + 'px',
                top: top + 'px',
                display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'
              });
            }
          });
        }
      },
      renderTitle: function() {
        var options = this.options,
          padding = this.padding,
          titleOptions = options.title,
          titleHeight = 0,
          bBox;
        if (titleOptions.text) {
          if (!this.title) {
            this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
              .attr({
                zIndex: 1
              })
              .css(titleOptions.style)
              .add(this.group);
          }
          bBox = this.title.getBBox();
          titleHeight = bBox.height;
          this.offsetWidth = bBox.width;
          this.contentGroup.attr({
            translateY: titleHeight
          });
        }
        this.titleHeight = titleHeight;
      },
      setText: function(item) {
        var options = this.options;
        item.legendItem.attr({
          text: options.labelFormat ? H.format(options.labelFormat, item) : options.labelFormatter.call(item)
        });
      },
      renderItem: function(item) {
        var legend = this,
          chart = legend.chart,
          renderer = chart.renderer,
          options = legend.options,
          horizontal = options.layout === 'horizontal',
          symbolWidth = legend.symbolWidth,
          symbolPadding = options.symbolPadding,
          itemStyle = legend.itemStyle,
          itemHiddenStyle = legend.itemHiddenStyle,
          padding = legend.padding,
          itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
          ltr = !options.rtl,
          itemHeight,
          widthOption = options.width,
          itemMarginBottom = options.itemMarginBottom || 0,
          itemMarginTop = legend.itemMarginTop,
          initialItemX = legend.initialItemX,
          bBox,
          itemWidth,
          li = item.legendItem,
          isSeries = !item.series,
          series = !isSeries && item.series.drawLegendSymbol ? item.series : item,
          seriesOptions = series.options,
          showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
          useHTML = options.useHTML,
          fontSize = 12;
        if (!li) {
          item.legendGroup = renderer.g('legend-item')
            .addClass('highcharts-' + series.type + '-series highcharts-color-' + item.colorIndex +
              (item.options.className ? ' ' + item.options.className : '') +
              (isSeries ? ' highcharts-series-' + item.index : '')
            )
            .attr({
              zIndex: 1
            })
            .add(legend.scrollGroup);
          item.legendItem = li = renderer.text(
              '',
              ltr ? symbolWidth + symbolPadding : -symbolPadding,
              legend.baseline || 0,
              useHTML
            )
            .css(merge(item.visible ? itemStyle : itemHiddenStyle))
            .attr({
              align: ltr ? 'left' : 'right',
              zIndex: 2
            })
            .add(item.legendGroup);
          if (!legend.baseline) {
            fontSize = itemStyle.fontSize;
            legend.fontMetrics = renderer.fontMetrics(
              fontSize,
              li
            );
            legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
            li.attr('y', legend.baseline);
          }
          legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
          series.drawLegendSymbol(legend, item);
          if (legend.setItemEvents) {
            legend.setItemEvents(item, li, useHTML);
          }
          if (showCheckbox) {
            legend.createCheckboxForItem(item);
          }
        }
        legend.colorizeItem(item, item.visible);
        legend.setText(item);
        bBox = li.getBBox();
        itemWidth = item.checkboxOffset =
          options.itemWidth ||
          item.legendItemWidth ||
          symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
        legend.itemHeight = itemHeight = Math.round(item.legendItemHeight || bBox.height);
        if (horizontal && legend.itemX - initialItemX + itemWidth >
          (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
          legend.itemX = initialItemX;
          legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
          legend.lastLineHeight = 0;
        }
        legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);
        legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
        legend.lastLineHeight = Math.max(itemHeight, legend.lastLineHeight);
        item._legendItemPos = [legend.itemX, legend.itemY];
        if (horizontal) {
          legend.itemX += itemWidth;
        } else {
          legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
          legend.lastLineHeight = itemHeight;
        }
        legend.offsetWidth = widthOption || Math.max(
          (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
          legend.offsetWidth
        );
      },
      getAllItems: function() {
        var allItems = [];
        each(this.chart.series, function(series) {
          var seriesOptions = series && series.options;
          if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true)) {
            allItems = allItems.concat(
              series.legendItems ||
              (seriesOptions.legendType === 'point' ?
                series.data :
                series)
            );
          }
        });
        return allItems;
      },
      adjustMargins: function(margin, spacing) {
        var chart = this.chart,
          options = this.options,
          alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
        if (!options.floating) {
          each([
            /(lth|ct|rth)/,
            /(rtv|rm|rbv)/,
            /(rbh|cb|lbh)/,
            /(lbv|lm|ltv)/
          ], function(alignments, side) {
            if (alignments.test(alignment) && !defined(margin[side])) {
              chart[marginNames[side]] = Math.max(
                chart[marginNames[side]],
                chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +
                pick(options.margin, 12) +
                spacing[side]
              );
            }
          });
        }
      },
      render: function() {
        var legend = this,
          chart = legend.chart,
          renderer = chart.renderer,
          legendGroup = legend.group,
          allItems,
          display,
          legendWidth,
          legendHeight,
          box = legend.box,
          options = legend.options,
          padding = legend.padding;
        legend.itemX = legend.initialItemX;
        legend.itemY = legend.initialItemY;
        legend.offsetWidth = 0;
        legend.lastItemY = 0;
        if (!legendGroup) {
          legend.group = legendGroup = renderer.g('legend')
            .attr({
              zIndex: 7
            })
            .add();
          legend.contentGroup = renderer.g()
            .attr({
              zIndex: 1
            })
            .add(legendGroup);
          legend.scrollGroup = renderer.g()
            .add(legend.contentGroup);
        }
        legend.renderTitle();
        allItems = legend.getAllItems();
        stableSort(allItems, function(a, b) {
          return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
        });
        if (options.reversed) {
          allItems.reverse();
        }
        legend.allItems = allItems;
        legend.display = display = !!allItems.length;
        legend.lastLineHeight = 0;
        each(allItems, function(item) {
          legend.renderItem(item);
        });
        legendWidth = (options.width || legend.offsetWidth) + padding;
        legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
        legendHeight = legend.handleOverflow(legendHeight);
        legendHeight += padding;
        if (!box) {
          legend.box = box = renderer.rect()
            .addClass('highcharts-legend-box')
            .attr({
              r: options.borderRadius
            })
            .add(legendGroup);
          box.isNew = true;
        }
        box
          .attr({
            stroke: options.borderColor,
            'stroke-width': options.borderWidth || 0,
            fill: options.backgroundColor || 'none'
          })
          .shadow(options.shadow);
        if (legendWidth > 0 && legendHeight > 0) {
          box[box.isNew ? 'attr' : 'animate'](
            box.crisp({
              x: 0,
              y: 0,
              width: legendWidth,
              height: legendHeight
            }, box.strokeWidth())
          );
          box.isNew = false;
        }
        box[display ? 'show' : 'hide']();
        legend.legendWidth = legendWidth;
        legend.legendHeight = legendHeight;
        each(allItems, function(item) {
          legend.positionItem(item);
        });
        if (display) {
          legendGroup.align(extend({
            width: legendWidth,
            height: legendHeight
          }, options), true, 'spacingBox');
        }
        if (!chart.isResizing) {
          this.positionCheckboxes();
        }
      },
      handleOverflow: function(legendHeight) {
        var legend = this,
          chart = this.chart,
          renderer = chart.renderer,
          options = this.options,
          optionsY = options.y,
          alignTop = options.verticalAlign === 'top',
          spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
          maxHeight = options.maxHeight,
          clipHeight,
          clipRect = this.clipRect,
          navOptions = options.navigation,
          animation = pick(navOptions.animation, true),
          arrowSize = navOptions.arrowSize || 12,
          nav = this.nav,
          pages = this.pages,
          padding = this.padding,
          lastY,
          allItems = this.allItems,
          clipToHeight = function(height) {
            if (height) {
              clipRect.attr({
                height: height
              });
            } else if (clipRect) {
              legend.clipRect = clipRect.destroy();
              legend.contentGroup.clip();
            }
            if (legend.contentGroup.div) {
              legend.contentGroup.div.style.clip = height ?
                'rect(' + padding + 'px,9999px,' +
                (padding + height) + 'px,0)' :
                'auto';
            }
          };
        if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {
          spaceHeight /= 2;
        }
        if (maxHeight) {
          spaceHeight = Math.min(spaceHeight, maxHeight);
        }
        pages.length = 0;
        if (legendHeight > spaceHeight && navOptions.enabled !== false) {
          this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
          this.currentPage = pick(this.currentPage, 1);
          this.fullHeight = legendHeight;
          each(allItems, function(item, i) {
            var y = item._legendItemPos[1],
              h = Math.round(item.legendItem.getBBox().height),
              len = pages.length;
            if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
              pages.push(lastY || y);
              len++;
            }
            if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
              pages.push(y);
            }
            if (y !== lastY) {
              lastY = y;
            }
          });
          if (!clipRect) {
            clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
            legend.contentGroup.clip(clipRect);
          }
          clipToHeight(clipHeight);
          if (!nav) {
            this.nav = nav = renderer.g().attr({
              zIndex: 1
            }).add(this.group);
            this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
              .on('click', function() {
                legend.scroll(-1, animation);
              })
              .add(nav);
            this.pager = renderer.text('', 15, 10)
              .addClass('highcharts-legend-navigation')
              .css(navOptions.style)
              .add(nav);
            this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
              .on('click', function() {
                legend.scroll(1, animation);
              })
              .add(nav);
          }
          legend.scroll(0);
          legendHeight = spaceHeight;
        } else if (nav) {
          clipToHeight();
          nav.hide();
          this.scrollGroup.attr({
            translateY: 1
          });
          this.clipHeight = 0;
        }
        return legendHeight;
      },
      scroll: function(scrollBy, animation) {
        var pages = this.pages,
          pageCount = pages.length,
          currentPage = this.currentPage + scrollBy,
          clipHeight = this.clipHeight,
          navOptions = this.options.navigation,
          pager = this.pager,
          padding = this.padding,
          scrollOffset;
        if (currentPage > pageCount) {
          currentPage = pageCount;
        }
        if (currentPage > 0) {
          if (animation !== undefined) {
            setAnimation(animation, this.chart);
          }
          this.nav.attr({
            translateX: padding,
            translateY: clipHeight + this.padding + 7 + this.titleHeight,
            visibility: 'visible'
          });
          this.up.attr({
            'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
          });
          pager.attr({
            text: currentPage + '/' + pageCount
          });
          this.down.attr({
            'x': 18 + this.pager.getBBox().width,
            'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
          });
          this.up
            .attr({
              fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
            })
            .css({
              cursor: currentPage === 1 ? 'default' : 'pointer'
            });
          this.down
            .attr({
              fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
            })
            .css({
              cursor: currentPage === pageCount ? 'default' : 'pointer'
            });
          scrollOffset = -pages[currentPage - 1] + this.initialItemY;
          this.scrollGroup.animate({
            translateY: scrollOffset
          });
          this.currentPage = currentPage;
          this.positionCheckboxes(scrollOffset);
        }
      }
    };
    H.LegendSymbolMixin = {
      drawRectangle: function(legend, item) {
        var options = legend.options,
          symbolHeight = legend.symbolHeight,
          square = options.squareSymbol,
          symbolWidth = square ? symbolHeight : legend.symbolWidth;
        item.legendSymbol = this.chart.renderer.rect(
            square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
            legend.baseline - symbolHeight + 1,
            symbolWidth,
            symbolHeight,
            pick(legend.options.symbolRadius, symbolHeight / 2)
          )
          .addClass('highcharts-point')
          .attr({
            zIndex: 3
          }).add(item.legendGroup);
      },
      drawLineMarker: function(legend) {
        var options = this.options,
          markerOptions = options.marker,
          radius,
          legendSymbol,
          symbolWidth = legend.symbolWidth,
          symbolHeight = legend.symbolHeight,
          generalRadius = symbolHeight / 2,
          renderer = this.chart.renderer,
          legendItemGroup = this.legendGroup,
          verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),
          attr = {};
        attr = {
          'stroke-width': options.lineWidth || 0
        };
        if (options.dashStyle) {
          attr.dashstyle = options.dashStyle;
        }
        this.legendLine = renderer.path([
            'M',
            0,
            verticalCenter,
            'L',
            symbolWidth,
            verticalCenter
          ])
          .addClass('highcharts-graph')
          .attr(attr)
          .add(legendItemGroup);
        if (markerOptions && markerOptions.enabled !== false) {
          radius = Math.min(
            pick(markerOptions.radius, generalRadius),
            generalRadius
          );
          if (this.symbol.indexOf('url') === 0) {
            markerOptions = merge(markerOptions, {
              width: symbolHeight,
              height: symbolHeight
            });
            radius = 0;
          }
          this.legendSymbol = legendSymbol = renderer.symbol(
              this.symbol,
              (symbolWidth / 2) - radius,
              verticalCenter - radius,
              2 * radius,
              2 * radius,
              markerOptions
            )
            .addClass('highcharts-point')
            .add(legendItemGroup);
          legendSymbol.isMarker = true;
        }
      }
    };
    if (/Trident\/7\.0/.test(win.navigator.userAgent) || isFirefox) {
      wrap(Legend.prototype, 'positionItem', function(proceed, item) {
        var legend = this,
          runPositionItem = function() {
            if (item._legendItemPos) {
              proceed.call(legend, item);
            }
          };
        runPositionItem();
        setTimeout(runPositionItem);
      });
    }
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      animate = H.animate,
      animObject = H.animObject,
      attr = H.attr,
      doc = H.doc,
      Axis = H.Axis,
      createElement = H.createElement,
      defaultOptions = H.defaultOptions,
      discardElement = H.discardElement,
      charts = H.charts,
      css = H.css,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      find = H.find,
      fireEvent = H.fireEvent,
      getStyle = H.getStyle,
      grep = H.grep,
      isNumber = H.isNumber,
      isObject = H.isObject,
      isString = H.isString,
      Legend = H.Legend,
      marginNames = H.marginNames,
      merge = H.merge,
      Pointer = H.Pointer,
      pick = H.pick,
      pInt = H.pInt,
      removeEvent = H.removeEvent,
      seriesTypes = H.seriesTypes,
      splat = H.splat,
      svg = H.svg,
      syncTimeout = H.syncTimeout,
      win = H.win,
      Renderer = H.Renderer;
    var Chart = H.Chart = function() {
      this.getArgs.apply(this, arguments);
    };
    H.chart = function(a, b, c) {
      return new Chart(a, b, c);
    };
    Chart.prototype = {
      callbacks: [],
      getArgs: function() {
        var args = [].slice.call(arguments);
        if (isString(args[0]) || args[0].nodeName) {
          this.renderTo = args.shift();
        }
        this.init(args[0], args[1]);
      },
      init: function(userOptions, callback) {
        var options,
          seriesOptions = userOptions.series;
        userOptions.series = null;
        options = merge(defaultOptions, userOptions);
        options.series = userOptions.series = seriesOptions;
        this.userOptions = userOptions;
        this.respRules = [];
        var optionsChart = options.chart;
        var chartEvents = optionsChart.events;
        this.margin = [];
        this.spacing = [];
        this.bounds = {
          h: {},
          v: {}
        };
        this.callback = callback;
        this.isResizing = 0;
        this.options = options;
        this.axes = [];
        this.series = [];
        this.hasCartesianSeries = optionsChart.showAxes;
        var chart = this,
          eventType;
        chart.index = charts.length;
        charts.push(chart);
        H.chartCount++;
        if (chartEvents) {
          for (eventType in chartEvents) {
            addEvent(chart, eventType, chartEvents[eventType]);
          }
        }
        chart.xAxis = [];
        chart.yAxis = [];
        chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
        chart.firstRender();
      },
      initSeries: function(options) {
        var chart = this,
          optionsChart = chart.options.chart,
          type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
          series,
          Constr = seriesTypes[type];
        if (!Constr) {
          H.error(17, true);
        }
        series = new Constr();
        series.init(this, options);
        return series;
      },
      orderSeries: function(fromIndex) {
        var series = this.series,
          i = fromIndex || 0;
        for (; i < series.length; i++) {
          if (series[i]) {
            series[i].index = i;
            series[i].name = series[i].name ||
              'Series ' + (series[i].index + 1);
          }
        }
      },
      isInsidePlot: function(plotX, plotY, inverted) {
        var x = inverted ? plotY : plotX,
          y = inverted ? plotX : plotY;
        return x >= 0 &&
          x <= this.plotWidth &&
          y >= 0 &&
          y <= this.plotHeight;
      },
      redraw: function(animation) {
        var chart = this,
          axes = chart.axes,
          series = chart.series,
          pointer = chart.pointer,
          legend = chart.legend,
          redrawLegend = chart.isDirtyLegend,
          hasStackedSeries,
          hasDirtyStacks,
          hasCartesianSeries = chart.hasCartesianSeries,
          isDirtyBox = chart.isDirtyBox,
          seriesLength = series.length,
          i = seriesLength,
          serie,
          renderer = chart.renderer,
          isHiddenChart = renderer.isHidden(),
          afterRedraw = [];
        if (chart.setResponsive) {
          chart.setResponsive(false);
        }
        H.setAnimation(animation, chart);
        if (isHiddenChart) {
          chart.cloneRenderTo();
        }
        chart.layOutTitles();
        while (i--) {
          serie = series[i];
          if (serie.options.stacking) {
            hasStackedSeries = true;
            if (serie.isDirty) {
              hasDirtyStacks = true;
              break;
            }
          }
        }
        if (hasDirtyStacks) {
          i = seriesLength;
          while (i--) {
            serie = series[i];
            if (serie.options.stacking) {
              serie.isDirty = true;
            }
          }
        }
        each(series, function(serie) {
          if (serie.isDirty) {
            if (serie.options.legendType === 'point') {
              if (serie.updateTotals) {
                serie.updateTotals();
              }
              redrawLegend = true;
            }
          }
          if (serie.isDirtyData) {
            fireEvent(serie, 'updatedData');
          }
        });
        if (redrawLegend && legend.options.enabled) {
          legend.render();
          chart.isDirtyLegend = false;
        }
        if (hasStackedSeries) {
          chart.getStacks();
        }
        if (hasCartesianSeries) {
          each(axes, function(axis) {
            axis.updateNames();
            axis.setScale();
          });
        }
        chart.getMargins();
        if (hasCartesianSeries) {
          each(axes, function(axis) {
            if (axis.isDirty) {
              isDirtyBox = true;
            }
          });
          each(axes, function(axis) {
            var key = axis.min + ',' + axis.max;
            if (axis.extKey !== key) {
              axis.extKey = key;
              afterRedraw.push(function() {
                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes()));
                delete axis.eventArgs;
              });
            }
            if (isDirtyBox || hasStackedSeries) {
              axis.redraw();
            }
          });
        }
        if (isDirtyBox) {
          chart.drawChartBox();
        }
        fireEvent(chart, 'predraw');
        each(series, function(serie) {
          if ((isDirtyBox || serie.isDirty) && serie.visible) {
            serie.redraw();
          }
          serie.isDirtyData = false;
        });
        if (pointer) {
          pointer.reset(true);
        }
        renderer.draw();
        fireEvent(chart, 'redraw');
        fireEvent(chart, 'render');
        if (isHiddenChart) {
          chart.cloneRenderTo(true);
        }
        each(afterRedraw, function(callback) {
          callback.call();
        });
      },
      get: function(id) {
        var ret,
          series = this.series,
          i;

        function itemById(item) {
          return item.id === id || (item.options && item.options.id === id);
        }
        ret =
          find(this.axes, itemById) ||
          find(this.series, itemById);
        for (i = 0; !ret && i < series.length; i++) {
          ret = find(series[i].points || [], itemById);
        }
        return ret;
      },
      getAxes: function() {
        var chart = this,
          options = this.options,
          xAxisOptions = options.xAxis = splat(options.xAxis || {}),
          yAxisOptions = options.yAxis = splat(options.yAxis || {}),
          optionsArray;
        each(xAxisOptions, function(axis, i) {
          axis.index = i;
          axis.isX = true;
        });
        each(yAxisOptions, function(axis, i) {
          axis.index = i;
        });
        optionsArray = xAxisOptions.concat(yAxisOptions);
        each(optionsArray, function(axisOptions) {
          new Axis(chart, axisOptions);
        });
      },
      getSelectedPoints: function() {
        var points = [];
        each(this.series, function(serie) {
          points = points.concat(grep(serie.points || [], function(point) {
            return point.selected;
          }));
        });
        return points;
      },
      getSelectedSeries: function() {
        return grep(this.series, function(serie) {
          return serie.selected;
        });
      },
      setTitle: function(titleOptions, subtitleOptions, redraw) {
        var chart = this,
          options = chart.options,
          chartTitleOptions,
          chartSubtitleOptions;
        chartTitleOptions = options.title = merge({
            style: {
              color: '#333333',
              fontSize: options.isStock ? '16px' : '18px'
            }
          },
          options.title,
          titleOptions
        );
        chartSubtitleOptions = options.subtitle = merge({
            style: {
              color: '#666666'
            }
          },
          options.subtitle,
          subtitleOptions
        );
        each([
          ['title', titleOptions, chartTitleOptions],
          ['subtitle', subtitleOptions, chartSubtitleOptions]
        ], function(arr, i) {
          var name = arr[0],
            title = chart[name],
            titleOptions = arr[1],
            chartTitleOptions = arr[2];
          if (title && titleOptions) {
            chart[name] = title = title.destroy();
          }
          if (chartTitleOptions && chartTitleOptions.text && !title) {
            chart[name] = chart.renderer.text(
                chartTitleOptions.text,
                0,
                0,
                chartTitleOptions.useHTML
              )
              .attr({
                align: chartTitleOptions.align,
                'class': 'highcharts-' + name,
                zIndex: chartTitleOptions.zIndex || 4
              })
              .add();
            chart[name].update = function(o) {
              chart.setTitle(!i && o, i && o);
            };
            chart[name].css(chartTitleOptions.style);
          }
        });
        chart.layOutTitles(redraw);
      },
      layOutTitles: function(redraw) {
        var titleOffset = 0,
          requiresDirtyBox,
          renderer = this.renderer,
          spacingBox = this.spacingBox;
        each(['title', 'subtitle'], function(key) {
          var title = this[key],
            titleOptions = this.options[key],
            titleSize;
          if (title) {
            titleSize = titleOptions.style.fontSize;
            titleSize = renderer.fontMetrics(titleSize, title).b;
            title
              .css({
                width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + 'px'
              })
              .align(extend({
                y: titleOffset + titleSize + (key === 'title' ? -3 : 2)
              }, titleOptions), false, 'spacingBox');
            if (!titleOptions.floating && !titleOptions.verticalAlign) {
              titleOffset = Math.ceil(titleOffset + title.getBBox().height);
            }
          }
        }, this);
        requiresDirtyBox = this.titleOffset !== titleOffset;
        this.titleOffset = titleOffset;
        if (!this.isDirtyBox && requiresDirtyBox) {
          this.isDirtyBox = requiresDirtyBox;
          if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
            this.redraw();
          }
        }
      },
      getChartSize: function() {
        var chart = this,
          optionsChart = chart.options.chart,
          widthOption = optionsChart.width,
          heightOption = optionsChart.height,
          renderTo = chart.renderToClone || chart.renderTo;
        if (!defined(widthOption)) {
          chart.containerWidth = getStyle(renderTo, 'width');
        }
        if (!defined(heightOption)) {
          chart.containerHeight = getStyle(renderTo, 'height');
        }
        chart.chartWidth = Math.max(
          0,
          widthOption || chart.containerWidth || 600
        );
        chart.chartHeight = Math.max(
          0,
          heightOption || chart.containerHeight || 400
        );
      },
      cloneRenderTo: function(revert) {
        var clone = this.renderToClone,
          container = this.container;
        if (revert) {
          if (clone) {
            while (clone.childNodes.length) {
              this.renderTo.appendChild(clone.firstChild);
            }
            discardElement(clone);
            delete this.renderToClone;
          }
        } else {
          if (container && container.parentNode === this.renderTo) {
            this.renderTo.removeChild(container);
          }
          this.renderToClone = clone = this.renderTo.cloneNode(0);
          css(clone, {
            position: 'absolute',
            top: '-9999px',
            display: 'block'
          });
          if (clone.style.setProperty) {
            clone.style.setProperty('display', 'block', 'important');
          }
          doc.body.appendChild(clone);
          if (container) {
            clone.appendChild(container);
          }
        }
      },
      setClassName: function(className) {
        this.container.className = 'highcharts-container ' + (className || '');
      },
      getContainer: function() {
        var chart = this,
          container,
          options = chart.options,
          optionsChart = options.chart,
          chartWidth,
          chartHeight,
          renderTo = chart.renderTo,
          indexAttrName = 'data-highcharts-chart',
          oldChartIndex,
          Ren,
          containerId = H.uniqueKey(),
          containerStyle,
          key;
        if (!renderTo) {
          chart.renderTo = renderTo = optionsChart.renderTo;
        }
        if (isString(renderTo)) {
          chart.renderTo = renderTo = doc.getElementById(renderTo);
        }
        if (!renderTo) {
          H.error(13, true);
        }
        oldChartIndex = pInt(attr(renderTo, indexAttrName));
        if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
          charts[oldChartIndex].destroy();
        }
        attr(renderTo, indexAttrName, chart.index);
        renderTo.innerHTML = '';
        if (!optionsChart.skipClone && !renderTo.offsetWidth) {
          chart.cloneRenderTo();
        }
        chart.getChartSize();
        chartWidth = chart.chartWidth;
        chartHeight = chart.chartHeight;
        containerStyle = extend({
          position: 'relative',
          overflow: 'hidden',
          width: chartWidth + 'px',
          height: chartHeight + 'px',
          textAlign: 'left',
          lineHeight: 'normal',
          zIndex: 0,
          '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
        }, optionsChart.style);
        chart.container = container = createElement(
          'div', {
            id: containerId
          },
          containerStyle,
          chart.renderToClone || renderTo
        );
        chart._cursor = container.style.cursor;
        Ren = H[optionsChart.renderer] || Renderer;
        chart.renderer = new Ren(
          container,
          chartWidth,
          chartHeight,
          null,
          optionsChart.forExport,
          options.exporting && options.exporting.allowHTML
        );
        chart.setClassName(optionsChart.className);
        chart.renderer.setStyle(optionsChart.style);
        chart.renderer.chartIndex = chart.index;
      },
      getMargins: function(skipAxes) {
        var chart = this,
          spacing = chart.spacing,
          margin = chart.margin,
          titleOffset = chart.titleOffset;
        chart.resetMargins();
        if (titleOffset && !defined(margin[0])) {
          chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
        }
        if (chart.legend && chart.legend.display) {
          chart.legend.adjustMargins(margin, spacing);
        }
        if (chart.extraMargin) {
          chart[chart.extraMargin.type] = (chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;
        }
        if (chart.extraTopMargin) {
          chart.plotTop += chart.extraTopMargin;
        }
        if (!skipAxes) {
          this.getAxisMargins();
        }
      },
      getAxisMargins: function() {
        var chart = this,
          axisOffset = chart.axisOffset = [0, 0, 0, 0],
          margin = chart.margin;
        if (chart.hasCartesianSeries) {
          each(chart.axes, function(axis) {
            if (axis.visible) {
              axis.getOffset();
            }
          });
        }
        each(marginNames, function(m, side) {
          if (!defined(margin[side])) {
            chart[m] += axisOffset[side];
          }
        });
        chart.setChartSize();
      },
      reflow: function(e) {
        var chart = this,
          optionsChart = chart.options.chart,
          renderTo = chart.renderTo,
          hasUserWidth = defined(optionsChart.width),
          width = optionsChart.width || getStyle(renderTo, 'width'),
          height = optionsChart.height || getStyle(renderTo, 'height'),
          target = e ? e.target : win;
        if (!hasUserWidth && !chart.isPrinting && width && height && (target === win || target === doc)) {
          if (width !== chart.containerWidth || height !== chart.containerHeight) {
            clearTimeout(chart.reflowTimeout);
            chart.reflowTimeout = syncTimeout(function() {
              if (chart.container) {
                chart.setSize(undefined, undefined, false);
              }
            }, e ? 100 : 0);
          }
          chart.containerWidth = width;
          chart.containerHeight = height;
        }
      },
      initReflow: function() {
        var chart = this,
          unbind;
        unbind = addEvent(win, 'resize', function(e) {
          chart.reflow(e);
        });
        addEvent(chart, 'destroy', unbind);
      },
      setSize: function(width, height, animation) {
        var chart = this,
          renderer = chart.renderer,
          globalAnimation;
        chart.isResizing += 1;
        H.setAnimation(animation, chart);
        chart.oldChartHeight = chart.chartHeight;
        chart.oldChartWidth = chart.chartWidth;
        if (width !== undefined) {
          chart.options.chart.width = width;
        }
        if (height !== undefined) {
          chart.options.chart.height = height;
        }
        chart.getChartSize();
        globalAnimation = renderer.globalAnimation;
        (globalAnimation ? animate : css)(chart.container, {
          width: chart.chartWidth + 'px',
          height: chart.chartHeight + 'px'
        }, globalAnimation);
        chart.setChartSize(true);
        renderer.setSize(chart.chartWidth, chart.chartHeight, animation);
        each(chart.axes, function(axis) {
          axis.isDirty = true;
          axis.setScale();
        });
        chart.isDirtyLegend = true;
        chart.isDirtyBox = true;
        chart.layOutTitles();
        chart.getMargins();
        chart.redraw(animation);
        chart.oldChartHeight = null;
        fireEvent(chart, 'resize');
        syncTimeout(function() {
          if (chart) {
            fireEvent(chart, 'endResize', null, function() {
              chart.isResizing -= 1;
            });
          }
        }, animObject(globalAnimation).duration);
      },
      setChartSize: function(skipAxes) {
        var chart = this,
          inverted = chart.inverted,
          renderer = chart.renderer,
          chartWidth = chart.chartWidth,
          chartHeight = chart.chartHeight,
          optionsChart = chart.options.chart,
          spacing = chart.spacing,
          clipOffset = chart.clipOffset,
          clipX,
          clipY,
          plotLeft,
          plotTop,
          plotWidth,
          plotHeight,
          plotBorderWidth;
        chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
        chart.plotTop = plotTop = Math.round(chart.plotTop);
        chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
        chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
        chart.plotSizeX = inverted ? plotHeight : plotWidth;
        chart.plotSizeY = inverted ? plotWidth : plotHeight;
        chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
        chart.spacingBox = renderer.spacingBox = {
          x: spacing[3],
          y: spacing[0],
          width: chartWidth - spacing[3] - spacing[1],
          height: chartHeight - spacing[0] - spacing[2]
        };
        chart.plotBox = renderer.plotBox = {
          x: plotLeft,
          y: plotTop,
          width: plotWidth,
          height: plotHeight
        };
        plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
        clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);
        clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
        chart.clipBox = {
          x: clipX,
          y: clipY,
          width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
          height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
        };
        if (!skipAxes) {
          each(chart.axes, function(axis) {
            axis.setAxisSize();
            axis.setAxisTranslation();
          });
        }
      },
      resetMargins: function() {
        var chart = this,
          chartOptions = chart.options.chart;
        each(['margin', 'spacing'], function splashArrays(target) {
          var value = chartOptions[target],
            values = isObject(value) ? value : [value, value, value, value];
          each(['Top', 'Right', 'Bottom', 'Left'], function(sideName, side) {
            chart[target][side] = pick(chartOptions[target + sideName], values[side]);
          });
        });
        each(marginNames, function(m, side) {
          chart[m] = pick(chart.margin[side], chart.spacing[side]);
        });
        chart.axisOffset = [0, 0, 0, 0];
        chart.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function() {
        var chart = this,
          optionsChart = chart.options.chart,
          renderer = chart.renderer,
          chartWidth = chart.chartWidth,
          chartHeight = chart.chartHeight,
          chartBackground = chart.chartBackground,
          plotBackground = chart.plotBackground,
          plotBorder = chart.plotBorder,
          chartBorderWidth,
          plotBGImage = chart.plotBGImage,
          chartBackgroundColor = optionsChart.backgroundColor,
          plotBackgroundColor = optionsChart.plotBackgroundColor,
          plotBackgroundImage = optionsChart.plotBackgroundImage,
          mgn,
          bgAttr,
          plotLeft = chart.plotLeft,
          plotTop = chart.plotTop,
          plotWidth = chart.plotWidth,
          plotHeight = chart.plotHeight,
          plotBox = chart.plotBox,
          clipRect = chart.clipRect,
          clipBox = chart.clipBox,
          verb = 'animate';
        if (!chartBackground) {
          chart.chartBackground = chartBackground = renderer.rect()
            .addClass('highcharts-background')
            .add();
          verb = 'attr';
        }
        chartBorderWidth = optionsChart.borderWidth || 0;
        mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
        bgAttr = {
          fill: chartBackgroundColor || 'none'
        };
        if (chartBorderWidth || chartBackground['stroke-width']) {
          bgAttr.stroke = optionsChart.borderColor;
          bgAttr['stroke-width'] = chartBorderWidth;
        }
        chartBackground
          .attr(bgAttr)
          .shadow(optionsChart.shadow);
        chartBackground[verb]({
          x: mgn / 2,
          y: mgn / 2,
          width: chartWidth - mgn - chartBorderWidth % 2,
          height: chartHeight - mgn - chartBorderWidth % 2,
          r: optionsChart.borderRadius
        });
        verb = 'animate';
        if (!plotBackground) {
          verb = 'attr';
          chart.plotBackground = plotBackground = renderer.rect()
            .addClass('highcharts-plot-background')
            .add();
        }
        plotBackground[verb](plotBox);
        plotBackground
          .attr({
            fill: plotBackgroundColor || 'none'
          })
          .shadow(optionsChart.plotShadow);
        if (plotBackgroundImage) {
          if (!plotBGImage) {
            chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
              .add();
          } else {
            plotBGImage.animate(plotBox);
          }
        }
        if (!clipRect) {
          chart.clipRect = renderer.clipRect(clipBox);
        } else {
          clipRect.animate({
            width: clipBox.width,
            height: clipBox.height
          });
        }
        verb = 'animate';
        if (!plotBorder) {
          verb = 'attr';
          chart.plotBorder = plotBorder = renderer.rect()
            .addClass('highcharts-plot-border')
            .attr({
              zIndex: 1
            })
            .add();
        }
        plotBorder.attr({
          stroke: optionsChart.plotBorderColor,
          'stroke-width': optionsChart.plotBorderWidth || 0,
          fill: 'none'
        });
        plotBorder[verb](plotBorder.crisp({
          x: plotLeft,
          y: plotTop,
          width: plotWidth,
          height: plotHeight
        }, -plotBorder.strokeWidth()));
        chart.isDirtyBox = false;
      },
      propFromSeries: function() {
        var chart = this,
          optionsChart = chart.options.chart,
          klass,
          seriesOptions = chart.options.series,
          i,
          value;
        each(['inverted', 'angular', 'polar'], function(key) {
          klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
          value =
            optionsChart[key] ||
            (klass && klass.prototype[key]);
          i = seriesOptions && seriesOptions.length;
          while (!value && i--) {
            klass = seriesTypes[seriesOptions[i].type];
            if (klass && klass.prototype[key]) {
              value = true;
            }
          }
          chart[key] = value;
        });
      },
      linkSeries: function() {
        var chart = this,
          chartSeries = chart.series;
        each(chartSeries, function(series) {
          series.linkedSeries.length = 0;
        });
        each(chartSeries, function(series) {
          var linkedTo = series.options.linkedTo;
          if (isString(linkedTo)) {
            if (linkedTo === ':previous') {
              linkedTo = chart.series[series.index - 1];
            } else {
              linkedTo = chart.get(linkedTo);
            }
            if (linkedTo && linkedTo.linkedParent !== series) {
              linkedTo.linkedSeries.push(series);
              series.linkedParent = linkedTo;
              series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible);
            }
          }
        });
      },
      renderSeries: function() {
        each(this.series, function(serie) {
          serie.translate();
          serie.render();
        });
      },
      renderLabels: function() {
        var chart = this,
          labels = chart.options.labels;
        if (labels.items) {
          each(labels.items, function(label) {
            var style = extend(labels.style, label.style),
              x = pInt(style.left) + chart.plotLeft,
              y = pInt(style.top) + chart.plotTop + 12;
            delete style.left;
            delete style.top;
            chart.renderer.text(
                label.html,
                x,
                y
              )
              .attr({
                zIndex: 2
              })
              .css(style)
              .add();
          });
        }
      },
      render: function() {
        var chart = this,
          axes = chart.axes,
          renderer = chart.renderer,
          options = chart.options,
          tempWidth,
          tempHeight,
          redoHorizontal,
          redoVertical;
        chart.setTitle();
        chart.legend = new Legend(chart, options.legend);
        if (chart.getStacks) {
          chart.getStacks();
        }
        chart.getMargins(true);
        chart.setChartSize();
        tempWidth = chart.plotWidth;
        tempHeight = chart.plotHeight = chart.plotHeight - 21;
        each(axes, function(axis) {
          axis.setScale();
        });
        chart.getAxisMargins();
        redoHorizontal = tempWidth / chart.plotWidth > 1.1;
        redoVertical = tempHeight / chart.plotHeight > 1.05;
        if (redoHorizontal || redoVertical) {
          each(axes, function(axis) {
            if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
              axis.setTickInterval(true);
            }
          });
          chart.getMargins();
        }
        chart.drawChartBox();
        if (chart.hasCartesianSeries) {
          each(axes, function(axis) {
            if (axis.visible) {
              axis.render();
            }
          });
        }
        if (!chart.seriesGroup) {
          chart.seriesGroup = renderer.g('series-group')
            .attr({
              zIndex: 3
            })
            .add();
        }
        chart.renderSeries();
        chart.renderLabels();
        chart.addCredits();
        if (chart.setResponsive) {
          chart.setResponsive();
        }
        chart.hasRendered = true;
      },
      addCredits: function(credits) {
        var chart = this;
        credits = merge(true, this.options.credits, credits);
        if (credits.enabled && !this.credits) {
          this.credits = this.renderer.text(
              credits.text + (this.mapCredits || ''),
              0,
              0
            )
            .addClass('highcharts-credits')
            .on('click', function() {
              if (credits.href) {
                win.location.href = credits.href;
              }
            })
            .attr({
              align: credits.position.align,
              zIndex: 8
            })
            .css(credits.style)
            .add()
            .align(credits.position);
          this.credits.update = function(options) {
            chart.credits = chart.credits.destroy();
            chart.addCredits(options);
          };
        }
      },
      destroy: function() {
        var chart = this,
          axes = chart.axes,
          series = chart.series,
          container = chart.container,
          i,
          parentNode = container && container.parentNode;
        fireEvent(chart, 'destroy');
        charts[chart.index] = undefined;
        H.chartCount--;
        chart.renderTo.removeAttribute('data-highcharts-chart');
        removeEvent(chart);
        i = axes.length;
        while (i--) {
          axes[i] = axes[i].destroy();
        }
        if (this.scroller && this.scroller.destroy) {
          this.scroller.destroy();
        }
        i = series.length;
        while (i--) {
          series[i] = series[i].destroy();
        }
        each([
          'title', 'subtitle', 'chartBackground', 'plotBackground',
          'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
          'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
          'renderer'
        ], function(name) {
          var prop = chart[name];
          if (prop && prop.destroy) {
            chart[name] = prop.destroy();
          }
        });
        if (container) {
          container.innerHTML = '';
          removeEvent(container);
          if (parentNode) {
            discardElement(container);
          }
        }
        for (i in chart) {
          delete chart[i];
        }
      },
      isReadyToRender: function() {
        var chart = this;
        if ((!svg && (win == win.top && doc.readyState !== 'complete'))) {
          doc.attachEvent('onreadystatechange', function() {
            doc.detachEvent('onreadystatechange', chart.firstRender);
            if (doc.readyState === 'complete') {
              chart.firstRender();
            }
          });
          return false;
        }
        return true;
      },
      firstRender: function() {
        var chart = this,
          options = chart.options;
        if (!chart.isReadyToRender()) {
          return;
        }
        chart.getContainer();
        fireEvent(chart, 'init');
        chart.resetMargins();
        chart.setChartSize();
        chart.propFromSeries();
        chart.getAxes();
        each(options.series || [], function(serieOptions) {
          chart.initSeries(serieOptions);
        });
        chart.linkSeries();
        fireEvent(chart, 'beforeRender');
        if (Pointer) {
          chart.pointer = new Pointer(chart, options);
        }
        chart.render();
        if (!chart.renderer.imgCount && chart.onload) {
          chart.onload();
        }
        chart.cloneRenderTo(true);
      },
      onload: function() {
        each([this.callback].concat(this.callbacks), function(fn) {
          if (fn && this.index !== undefined) {
            fn.apply(this, [this]);
          }
        }, this);
        fireEvent(this, 'load');
        fireEvent(this, 'render');
        if (defined(this.index) && this.options.chart.reflow !== false) {
          this.initReflow();
        }
        this.onload = null;
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var Point,
      each = H.each,
      extend = H.extend,
      erase = H.erase,
      fireEvent = H.fireEvent,
      format = H.format,
      isArray = H.isArray,
      isNumber = H.isNumber,
      pick = H.pick,
      removeEvent = H.removeEvent;
    Point = H.Point = function() {};
    Point.prototype = {
      init: function(series, options, x) {
        var point = this,
          colors,
          colorCount = series.chart.options.chart.colorCount,
          colorIndex;
        point.series = series;
        point.color = series.color;
        point.applyOptions(options, x);
        if (series.options.colorByPoint) {
          colors = series.options.colors || series.chart.options.colors;
          point.color = point.color || colors[series.colorCounter];
          colorCount = colors.length;
          colorIndex = series.colorCounter;
          series.colorCounter++;
          if (series.colorCounter === colorCount) {
            series.colorCounter = 0;
          }
        } else {
          colorIndex = series.colorIndex;
        }
        point.colorIndex = pick(point.colorIndex, colorIndex);
        series.chart.pointCount++;
        return point;
      },
      applyOptions: function(options, x) {
        var point = this,
          series = point.series,
          pointValKey = series.options.pointValKey || series.pointValKey;
        options = Point.prototype.optionsToObject.call(this, options);
        extend(point, options);
        point.options = point.options ? extend(point.options, options) : options;
        if (options.group) {
          delete point.group;
        }
        if (pointValKey) {
          point.y = point[pointValKey];
        }
        point.isNull = pick(
          point.isValid && !point.isValid(),
          point.x === null || !isNumber(point.y, true)
        );
        if (point.selected) {
          point.state = 'select';
        }
        if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {
          point.x = series.xAxis.nameToX(point);
        }
        if (point.x === undefined && series) {
          if (x === undefined) {
            point.x = series.autoIncrement(point);
          } else {
            point.x = x;
          }
        }
        return point;
      },
      optionsToObject: function(options) {
        var ret = {},
          series = this.series,
          keys = series.options.keys,
          pointArrayMap = keys || series.pointArrayMap || ['y'],
          valueCount = pointArrayMap.length,
          firstItemType,
          i = 0,
          j = 0;
        if (isNumber(options) || options === null) {
          ret[pointArrayMap[0]] = options;
        } else if (isArray(options)) {
          if (!keys && options.length > valueCount) {
            firstItemType = typeof options[0];
            if (firstItemType === 'string') {
              ret.name = options[0];
            } else if (firstItemType === 'number') {
              ret.x = options[0];
            }
            i++;
          }
          while (j < valueCount) {
            if (!keys || options[i] !== undefined) {
              ret[pointArrayMap[j]] = options[i];
            }
            i++;
            j++;
          }
        } else if (typeof options === 'object') {
          ret = options;
          if (options.dataLabels) {
            series._hasPointLabels = true;
          }
          if (options.marker) {
            series._hasPointMarkers = true;
          }
        }
        return ret;
      },
      getClassName: function() {
        return 'highcharts-point' +
          (this.selected ? ' highcharts-point-select' : '') +
          (this.negative ? ' highcharts-negative' : '') +
          (this.isNull ? ' highcharts-null-point' : '') +
          (this.colorIndex !== undefined ? ' highcharts-color-' +
            this.colorIndex : '') +
          (this.options.className ? ' ' + this.options.className : '') +
          (this.zone && this.zone.className ? ' ' +
            this.zone.className.replace('highcharts-negative', '') : '');
      },
      getZone: function() {
        var series = this.series,
          zones = series.zones,
          zoneAxis = series.zoneAxis || 'y',
          i = 0,
          zone;
        zone = zones[i];
        while (this[zoneAxis] >= zone.value) {
          zone = zones[++i];
        }
        if (zone && zone.color && !this.options.color) {
          this.color = zone.color;
        }
        return zone;
      },
      destroy: function() {
        var point = this,
          series = point.series,
          chart = series.chart,
          hoverPoints = chart.hoverPoints,
          prop;
        chart.pointCount--;
        if (hoverPoints) {
          point.setState();
          erase(hoverPoints, point);
          if (!hoverPoints.length) {
            chart.hoverPoints = null;
          }
        }
        if (point === chart.hoverPoint) {
          point.onMouseOut();
        }
        if (point.graphic || point.dataLabel) {
          removeEvent(point);
          point.destroyElements();
        }
        if (point.legendItem) {
          chart.legend.destroyItem(point);
        }
        for (prop in point) {
          point[prop] = null;
        }
      },
      destroyElements: function() {
        var point = this,
          props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
          prop,
          i = 6;
        while (i--) {
          prop = props[i];
          if (point[prop]) {
            point[prop] = point[prop].destroy();
          }
        }
      },
      getLabelConfig: function() {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      },
      tooltipFormatter: function(pointFormat) {
        var series = this.series,
          seriesTooltipOptions = series.tooltipOptions,
          valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
          valuePrefix = seriesTooltipOptions.valuePrefix || '',
          valueSuffix = seriesTooltipOptions.valueSuffix || '';
        each(series.pointArrayMap || ['y'], function(key) {
          key = '{point.' + key;
          if (valuePrefix || valueSuffix) {
            pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
          }
          pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
        });
        return format(pointFormat, {
          point: this,
          series: this.series
        });
      },
      firePointEvent: function(eventType, eventArgs, defaultFunction) {
        var point = this,
          series = this.series,
          seriesOptions = series.options;
        if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
          this.importEvents();
        }
        if (eventType === 'click' && seriesOptions.allowPointSelect) {
          defaultFunction = function(event) {
            if (point.select) {
              point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
            }
          };
        }
        fireEvent(this, eventType, eventArgs, defaultFunction);
      },
      visible: true
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      animObject = H.animObject,
      arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      correctFloat = H.correctFloat,
      Date = H.Date,
      defaultOptions = H.defaultOptions,
      defaultPlotOptions = H.defaultPlotOptions,
      defined = H.defined,
      each = H.each,
      erase = H.erase,
      extend = H.extend,
      fireEvent = H.fireEvent,
      grep = H.grep,
      isArray = H.isArray,
      isNumber = H.isNumber,
      isString = H.isString,
      LegendSymbolMixin = H.LegendSymbolMixin,
      merge = H.merge,
      pick = H.pick,
      Point = H.Point,
      removeEvent = H.removeEvent,
      splat = H.splat,
      SVGElement = H.SVGElement,
      syncTimeout = H.syncTimeout,
      win = H.win;
    H.Series = H.seriesType('line', null, {
      lineWidth: 2,
      allowPointSelect: false,
      showCheckbox: false,
      animation: {
        duration: 1000
      },
      events: {},
      marker: {
        lineWidth: 0,
        lineColor: '#ffffff',
        radius: 4,
        states: {
          hover: {
            animation: {
              duration: 50
            },
            enabled: true,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: '#cccccc',
            lineColor: '#000000',
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: 'center',
        formatter: function() {
          return this.y === null ? '' : H.numberFormat(this.y, -1);
        },
        style: {
          fontSize: '11px',
          fontWeight: 'bold',
          color: 'contrast',
          textOutline: '1px contrast'
        },
        verticalAlign: 'bottom',
        x: 0,
        y: 0,
        padding: 5
      },
      cropThreshold: 300,
      pointRange: 0,
      softThreshold: true,
      states: {
        hover: {
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: 0.25
          }
        },
        select: {
          marker: {}
        }
      },
      stickyTracking: true,
      turboThreshold: 1000
    }, {
      isCartesian: true,
      pointClass: Point,
      sorted: true,
      requireSorting: true,
      directTouch: false,
      axisTypes: ['xAxis', 'yAxis'],
      colorCounter: 0,
      parallelArrays: ['x', 'y'],
      coll: 'series',
      init: function(chart, options) {
        var series = this,
          eventType,
          events,
          chartSeries = chart.series,
          lastSeries;
        series.chart = chart;
        series.options = options = series.setOptions(options);
        series.linkedSeries = [];
        series.bindAxes();
        extend(series, {
          name: options.name,
          state: '',
          visible: options.visible !== false,
          selected: options.selected === true
        });
        events = options.events;
        for (eventType in events) {
          addEvent(series, eventType, events[eventType]);
        }
        if (
          (events && events.click) ||
          (options.point && options.point.events && options.point.events.click) ||
          options.allowPointSelect
        ) {
          chart.runTrackerClick = true;
        }
        series.getColor();
        series.getSymbol();
        each(series.parallelArrays, function(key) {
          series[key + 'Data'] = [];
        });
        series.setData(options.data, false);
        if (series.isCartesian) {
          chart.hasCartesianSeries = true;
        }
        if (chartSeries.length) {
          lastSeries = chartSeries[chartSeries.length - 1];
        }
        series._i = pick(lastSeries && lastSeries._i, -1) + 1;
        chart.orderSeries(this.insert(chartSeries));
      },
      insert: function(collection) {
        var indexOption = this.options.index,
          i;
        if (isNumber(indexOption)) {
          i = collection.length;
          while (i--) {
            if (indexOption >=
              pick(collection[i].options.index, collection[i]._i)) {
              collection.splice(i + 1, 0, this);
              break;
            }
          }
          if (i === -1) {
            collection.unshift(this);
          }
          i = i + 1;
        } else {
          collection.push(this);
        }
        return pick(i, collection.length - 1);
      },
      bindAxes: function() {
        var series = this,
          seriesOptions = series.options,
          chart = series.chart,
          axisOptions;
        each(series.axisTypes || [], function(AXIS) {
          each(chart[AXIS], function(axis) {
            axisOptions = axis.options;
            if ((seriesOptions[AXIS] === axisOptions.index) ||
              (seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id) ||
              (seriesOptions[AXIS] === undefined && axisOptions.index === 0)) {
              series.insert(axis.series);
              series[AXIS] = axis;
              axis.isDirty = true;
            }
          });
          if (!series[AXIS] && series.optionalAxis !== AXIS) {
            H.error(18, true);
          }
        });
      },
      updateParallelArrays: function(point, i) {
        var series = point.series,
          args = arguments,
          fn = isNumber(i) ?
          function(key) {
            var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
            series[key + 'Data'][i] = val;
          } :
          function(key) {
            Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
          };
        each(series.parallelArrays, fn);
      },
      autoIncrement: function() {
        var options = this.options,
          xIncrement = this.xIncrement,
          date,
          pointInterval,
          pointIntervalUnit = options.pointIntervalUnit;
        xIncrement = pick(xIncrement, options.pointStart, 0);
        this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
        if (pointIntervalUnit) {
          date = new Date(xIncrement);
          if (pointIntervalUnit === 'day') {
            date = +date[Date.hcSetDate](date[Date.hcGetDate]() + pointInterval);
          } else if (pointIntervalUnit === 'month') {
            date = +date[Date.hcSetMonth](date[Date.hcGetMonth]() + pointInterval);
          } else if (pointIntervalUnit === 'year') {
            date = +date[Date.hcSetFullYear](date[Date.hcGetFullYear]() + pointInterval);
          }
          pointInterval = date - xIncrement;
        }
        this.xIncrement = xIncrement + pointInterval;
        return xIncrement;
      },
      setOptions: function(itemOptions) {
        var chart = this.chart,
          chartOptions = chart.options,
          plotOptions = chartOptions.plotOptions,
          userOptions = chart.userOptions || {},
          userPlotOptions = userOptions.plotOptions || {},
          typeOptions = plotOptions[this.type],
          options,
          zones;
        this.userOptions = itemOptions;
        options = merge(
          typeOptions,
          plotOptions.series,
          itemOptions
        );
        this.tooltipOptions = merge(
          defaultOptions.tooltip,
          defaultOptions.plotOptions[this.type].tooltip,
          userOptions.tooltip,
          userPlotOptions.series && userPlotOptions.series.tooltip,
          userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
          itemOptions.tooltip
        );
        if (typeOptions.marker === null) {
          delete options.marker;
        }
        this.zoneAxis = options.zoneAxis;
        zones = this.zones = (options.zones || []).slice();
        if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
          zones.push({
            value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
            className: 'highcharts-negative',
            color: options.negativeColor,
            fillColor: options.negativeFillColor
          });
        }
        if (zones.length) {
          if (defined(zones[zones.length - 1].value)) {
            zones.push({
              color: this.color,
              fillColor: this.fillColor
            });
          }
        }
        return options;
      },
      getCyclic: function(prop, value, defaults) {
        var i,
          chart = this.chart,
          userOptions = this.userOptions,
          indexName = prop + 'Index',
          counterName = prop + 'Counter',
          len = defaults ? defaults.length : pick(
            chart.options.chart[prop + 'Count'],
            chart[prop + 'Count']
          ),
          setting;
        if (!value) {
          setting = pick(userOptions[indexName], userOptions['_' + indexName]);
          if (defined(setting)) {
            i = setting;
          } else {
            if (!chart.series.length) {
              chart[counterName] = 0;
            }
            userOptions['_' + indexName] = i = chart[counterName] % len;
            chart[counterName] += 1;
          }
          if (defaults) {
            value = defaults[i];
          }
        }
        if (i !== undefined) {
          this[indexName] = i;
        }
        this[prop] = value;
      },
      getColor: function() {
        if (this.options.colorByPoint) {
          this.options.color = null;
        } else {
          this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
        }
      },
      getSymbol: function() {
        var seriesMarkerOption = this.options.marker;
        this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);
      },
      drawLegendSymbol: LegendSymbolMixin.drawLineMarker,
      setData: function(data, redraw, animation, updatePoints) {
        var series = this,
          oldData = series.points,
          oldDataLength = (oldData && oldData.length) || 0,
          dataLength,
          options = series.options,
          chart = series.chart,
          firstPoint = null,
          xAxis = series.xAxis,
          i,
          turboThreshold = options.turboThreshold,
          pt,
          xData = this.xData,
          yData = this.yData,
          pointArrayMap = series.pointArrayMap,
          valueCount = pointArrayMap && pointArrayMap.length;
        data = data || [];
        dataLength = data.length;
        redraw = pick(redraw, true);
        if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
          each(data, function(point, i) {
            if (oldData[i].update && point !== options.data[i]) {
              oldData[i].update(point, false, null, false);
            }
          });
        } else {
          series.xIncrement = null;
          series.colorCounter = 0;
          each(this.parallelArrays, function(key) {
            series[key + 'Data'].length = 0;
          });
          if (turboThreshold && dataLength > turboThreshold) {
            i = 0;
            while (firstPoint === null && i < dataLength) {
              firstPoint = data[i];
              i++;
            }
            if (isNumber(firstPoint)) {
              for (i = 0; i < dataLength; i++) {
                xData[i] = this.autoIncrement();
                yData[i] = data[i];
              }
            } else if (isArray(firstPoint)) {
              if (valueCount) {
                for (i = 0; i < dataLength; i++) {
                  pt = data[i];
                  xData[i] = pt[0];
                  yData[i] = pt.slice(1, valueCount + 1);
                }
              } else {
                for (i = 0; i < dataLength; i++) {
                  pt = data[i];
                  xData[i] = pt[0];
                  yData[i] = pt[1];
                }
              }
            } else {
              H.error(12);
            }
          } else {
            for (i = 0; i < dataLength; i++) {
              if (data[i] !== undefined) {
                pt = {
                  series: series
                };
                series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                series.updateParallelArrays(pt, i);
              }
            }
          }
          if (isString(yData[0])) {
            H.error(14, true);
          }
          series.data = [];
          series.options.data = series.userOptions.data = data;
          i = oldDataLength;
          while (i--) {
            if (oldData[i] && oldData[i].destroy) {
              oldData[i].destroy();
            }
          }
          if (xAxis) {
            xAxis.minRange = xAxis.userMinRange;
          }
          series.isDirty = chart.isDirtyBox = true;
          series.isDirtyData = !!oldData;
          animation = false;
        }
        if (options.legendType === 'point') {
          this.processData();
          this.generatePoints();
        }
        if (redraw) {
          chart.redraw(animation);
        }
      },
      processData: function(force) {
        var series = this,
          processedXData = series.xData,
          processedYData = series.yData,
          dataLength = processedXData.length,
          croppedData,
          cropStart = 0,
          cropped,
          distance,
          closestPointRange,
          xAxis = series.xAxis,
          i,
          options = series.options,
          cropThreshold = options.cropThreshold,
          getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll,
          isCartesian = series.isCartesian,
          xExtremes,
          val2lin = xAxis && xAxis.val2lin,
          isLog = xAxis && xAxis.isLog,
          min,
          max;
        if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
          return false;
        }
        if (xAxis) {
          xExtremes = xAxis.getExtremes();
          min = xExtremes.min;
          max = xExtremes.max;
        }
        if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
          if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
            processedXData = [];
            processedYData = [];
          } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
            croppedData = this.cropData(series.xData, series.yData, min, max);
            processedXData = croppedData.xData;
            processedYData = croppedData.yData;
            cropStart = croppedData.start;
            cropped = true;
          }
        }
        i = processedXData.length || 1;
        while (--i) {
          distance = isLog ?
            val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
            processedXData[i] - processedXData[i - 1];
          if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {
            closestPointRange = distance;
          } else if (distance < 0 && series.requireSorting) {
            H.error(15);
          }
        }
        series.cropped = cropped;
        series.cropStart = cropStart;
        series.processedXData = processedXData;
        series.processedYData = processedYData;
        series.closestPointRange = closestPointRange;
      },
      cropData: function(xData, yData, min, max) {
        var dataLength = xData.length,
          cropStart = 0,
          cropEnd = dataLength,
          cropShoulder = pick(this.cropShoulder, 1),
          i,
          j;
        for (i = 0; i < dataLength; i++) {
          if (xData[i] >= min) {
            cropStart = Math.max(0, i - cropShoulder);
            break;
          }
        }
        for (j = i; j < dataLength; j++) {
          if (xData[j] > max) {
            cropEnd = j + cropShoulder;
            break;
          }
        }
        return {
          xData: xData.slice(cropStart, cropEnd),
          yData: yData.slice(cropStart, cropEnd),
          start: cropStart,
          end: cropEnd
        };
      },
      generatePoints: function() {
        var series = this,
          options = series.options,
          dataOptions = options.data,
          data = series.data,
          dataLength,
          processedXData = series.processedXData,
          processedYData = series.processedYData,
          PointClass = series.pointClass,
          processedDataLength = processedXData.length,
          cropStart = series.cropStart || 0,
          cursor,
          hasGroupedData = series.hasGroupedData,
          point,
          points = [],
          i;
        if (!data && !hasGroupedData) {
          var arr = [];
          arr.length = dataOptions.length;
          data = series.data = arr;
        }
        for (i = 0; i < processedDataLength; i++) {
          cursor = cropStart + i;
          if (!hasGroupedData) {
            point = data[cursor];
            if (!point && dataOptions[cursor] !== undefined) {
              data[cursor] = point = (new PointClass()).init(series, dataOptions[cursor], processedXData[i]);
            }
          } else {
            point = (new PointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
            point.dataGroup = series.groupMap[i];
          }
          point.index = cursor;
          points[i] = point;
        }
        if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
          for (i = 0; i < dataLength; i++) {
            if (i === cropStart && !hasGroupedData) {
              i += processedDataLength;
            }
            if (data[i]) {
              data[i].destroyElements();
              data[i].plotX = undefined;
            }
          }
        }
        series.data = data;
        series.points = points;
      },
      getExtremes: function(yData) {
        var xAxis = this.xAxis,
          yAxis = this.yAxis,
          xData = this.processedXData,
          yDataLength,
          activeYData = [],
          activeCounter = 0,
          xExtremes = xAxis.getExtremes(),
          xMin = xExtremes.min,
          xMax = xExtremes.max,
          validValue,
          withinRange,
          x,
          y,
          i,
          j;
        yData = yData || this.stackedYData || this.processedYData || [];
        yDataLength = yData.length;
        for (i = 0; i < yDataLength; i++) {
          x = xData[i];
          y = yData[i];
          validValue = (isNumber(y, true) || isArray(y)) && (!yAxis.isLog || (y.length || y > 0));
          withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
            ((xData[i + 1] || x) >= xMin && (xData[i - 1] || x) <= xMax);
          if (validValue && withinRange) {
            j = y.length;
            if (j) {
              while (j--) {
                if (y[j] !== null) {
                  activeYData[activeCounter++] = y[j];
                }
              }
            } else {
              activeYData[activeCounter++] = y;
            }
          }
        }
        this.dataMin = arrayMin(activeYData);
        this.dataMax = arrayMax(activeYData);
      },
      translate: function() {
        if (!this.processedXData) {
          this.processData();
        }
        this.generatePoints();
        var series = this,
          options = series.options,
          stacking = options.stacking,
          xAxis = series.xAxis,
          categories = xAxis.categories,
          yAxis = series.yAxis,
          points = series.points,
          dataLength = points.length,
          hasModifyValue = !!series.modifyValue,
          i,
          pointPlacement = options.pointPlacement,
          dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
          threshold = options.threshold,
          stackThreshold = options.startFromThreshold ? threshold : 0,
          plotX,
          plotY,
          lastPlotX,
          stackIndicator,
          closestPointRangePx = Number.MAX_VALUE;
        if (pointPlacement === 'between') {
          pointPlacement = 0.5;
        }
        if (isNumber(pointPlacement)) {
          pointPlacement *= pick(options.pointRange || xAxis.pointRange);
        }
        for (i = 0; i < dataLength; i++) {
          var point = points[i],
            xValue = point.x,
            yValue = point.y,
            yBottom = point.low,
            stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
            pointStack,
            stackValues;
          if (yAxis.isLog && yValue !== null && yValue <= 0) {
            point.isNull = true;
          }
          point.plotX = plotX = correctFloat(
            Math.min(Math.max(-1e5, xAxis.translate(
              xValue,
              0,
              0,
              0,
              1,
              pointPlacement,
              this.type === 'flags'
            )), 1e5)
          );
          if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {
            stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
            pointStack = stack[xValue];
            stackValues = pointStack.points[stackIndicator.key];
            yBottom = stackValues[0];
            yValue = stackValues[1];
            if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
              yBottom = pick(threshold, yAxis.min);
            }
            if (yAxis.isLog && yBottom <= 0) {
              yBottom = null;
            }
            point.total = point.stackTotal = pointStack.total;
            point.percentage = pointStack.total && (point.y / pointStack.total * 100);
            point.stackY = yValue;
            pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
          }
          point.yBottom = defined(yBottom) ?
            yAxis.translate(yBottom, 0, 1, 0, 1) :
            null;
          if (hasModifyValue) {
            yValue = series.modifyValue(yValue, point);
          }
          point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
            Math.min(Math.max(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) :
            undefined;
          point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len &&
            plotX >= 0 && plotX <= xAxis.len;
          point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX;
          point.negative = point.y < (threshold || 0);
          point.category = categories && categories[point.x] !== undefined ?
            categories[point.x] : point.x;
          if (!point.isNull) {
            if (lastPlotX !== undefined) {
              closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
            }
            lastPlotX = plotX;
          }
          point.zone = this.zones.length && point.getZone();
        }
        series.closestPointRangePx = closestPointRangePx;
      },
      getValidPoints: function(points, insideOnly) {
        var chart = this.chart;
        return grep(points || this.points || [], function isValidPoint(point) {
          if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) {
            return false;
          }
          return !point.isNull;
        });
      },
      setClip: function(animation) {
        var chart = this.chart,
          options = this.options,
          renderer = chart.renderer,
          inverted = chart.inverted,
          seriesClipBox = this.clipBox,
          clipBox = seriesClipBox || chart.clipBox,
          sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','),
          clipRect = chart[sharedClipKey],
          markerClipRect = chart[sharedClipKey + 'm'];
        if (!clipRect) {
          if (animation) {
            clipBox.width = 0;
            chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(-99,
              inverted ? -chart.plotLeft : -chart.plotTop,
              99,
              inverted ? chart.chartWidth : chart.chartHeight
            );
          }
          chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
          clipRect.count = {
            length: 0
          };
        }
        if (animation) {
          if (!clipRect.count[this.index]) {
            clipRect.count[this.index] = true;
            clipRect.count.length += 1;
          }
        }
        if (options.clip !== false) {
          this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
          this.markerGroup.clip(markerClipRect);
          this.sharedClipKey = sharedClipKey;
        }
        if (!animation) {
          if (clipRect.count[this.index]) {
            delete clipRect.count[this.index];
            clipRect.count.length -= 1;
          }
          if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
            if (!seriesClipBox) {
              chart[sharedClipKey] = chart[sharedClipKey].destroy();
            }
            if (chart[sharedClipKey + 'm']) {
              this.markerGroup.clip();
              chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
            }
          }
        }
      },
      animate: function(init) {
        var series = this,
          chart = series.chart,
          clipRect,
          animation = animObject(series.options.animation),
          sharedClipKey;
        if (init) {
          series.setClip(animation);
        } else {
          sharedClipKey = this.sharedClipKey;
          clipRect = chart[sharedClipKey];
          if (clipRect) {
            clipRect.animate({
              width: chart.plotSizeX
            }, animation);
          }
          if (chart[sharedClipKey + 'm']) {
            chart[sharedClipKey + 'm'].animate({
              width: chart.plotSizeX + 99
            }, animation);
          }
          series.animate = null;
        }
      },
      afterAnimate: function() {
        this.setClip();
        fireEvent(this, 'afterAnimate');
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          chart = series.chart,
          plotY,
          i,
          point,
          symbol,
          graphic,
          options = series.options,
          seriesMarkerOptions = options.marker,
          pointMarkerOptions,
          hasPointMarker,
          enabled,
          isInside,
          markerGroup = series.markerGroup,
          xAxis = series.xAxis,
          markerAttribs,
          globallyEnabled = pick(
            seriesMarkerOptions.enabled,
            xAxis.isRadial ? true : null,
            series.closestPointRangePx > 2 * seriesMarkerOptions.radius
          );
        if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
          for (i = 0; i < points.length; i++) {
            point = points[i];
            plotY = point.plotY;
            graphic = point.graphic;
            pointMarkerOptions = point.marker || {};
            hasPointMarker = !!point.marker;
            enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;
            isInside = point.isInside;
            if (enabled && isNumber(plotY) && point.y !== null) {
              symbol = pick(pointMarkerOptions.symbol, series.symbol);
              point.hasImage = symbol.indexOf('url') === 0;
              markerAttribs = series.markerAttribs(
                point,
                point.selected && 'select'
              );
              if (graphic) {
                graphic[isInside ? 'show' : 'hide'](true)
                  .animate(markerAttribs);
              } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {
                point.graphic = graphic = chart.renderer.symbol(
                    symbol,
                    markerAttribs.x,
                    markerAttribs.y,
                    markerAttribs.width,
                    markerAttribs.height,
                    hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
                  )
                  .add(markerGroup);
              }
              if (graphic) {
                graphic.attr(series.pointAttribs(point, point.selected && 'select'));
              }
              if (graphic) {
                graphic.addClass(point.getClassName(), true);
              }
            } else if (graphic) {
              point.graphic = graphic.destroy();
            }
          }
        }
      },
      markerAttribs: function(point, state) {
        var seriesMarkerOptions = this.options.marker,
          seriesStateOptions,
          pointMarkerOptions = point.marker || {},
          pointStateOptions,
          radius = pick(
            pointMarkerOptions.radius,
            seriesMarkerOptions.radius
          ),
          attribs;
        if (state) {
          seriesStateOptions = seriesMarkerOptions.states[state];
          pointStateOptions = pointMarkerOptions.states &&
            pointMarkerOptions.states[state];
          radius = pick(
            pointStateOptions && pointStateOptions.radius,
            seriesStateOptions && seriesStateOptions.radius,
            radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)
          );
        }
        if (point.hasImage) {
          radius = 0;
        }
        attribs = {
          x: Math.floor(point.plotX) - radius,
          y: point.plotY - radius
        };
        if (radius) {
          attribs.width = attribs.height = 2 * radius;
        }
        return attribs;
      },
      pointAttribs: function(point, state) {
        var seriesMarkerOptions = this.options.marker,
          seriesStateOptions,
          pointOptions = point && point.options,
          pointMarkerOptions = (pointOptions && pointOptions.marker) || {},
          pointStateOptions,
          color = this.color,
          pointColorOption = pointOptions && pointOptions.color,
          pointColor = point && point.color,
          strokeWidth = pick(
            pointMarkerOptions.lineWidth,
            seriesMarkerOptions.lineWidth
          ),
          zoneColor = point && point.zone && point.zone.color,
          fill,
          stroke;
        color = pointColorOption || zoneColor || pointColor || color;
        fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;
        stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;
        if (state) {
          seriesStateOptions = seriesMarkerOptions.states[state];
          pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};
          strokeWidth = pick(
            pointStateOptions.lineWidth,
            seriesStateOptions.lineWidth,
            strokeWidth + pick(
              pointStateOptions.lineWidthPlus,
              seriesStateOptions.lineWidthPlus,
              0
            )
          );
          fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
          stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
        }
        return {
          'stroke': stroke,
          'stroke-width': strokeWidth,
          'fill': fill
        };
      },
      destroy: function() {
        var series = this,
          chart = series.chart,
          issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent),
          destroy,
          i,
          data = series.data || [],
          point,
          prop,
          axis;
        fireEvent(series, 'destroy');
        removeEvent(series);
        each(series.axisTypes || [], function(AXIS) {
          axis = series[AXIS];
          if (axis && axis.series) {
            erase(axis.series, series);
            axis.isDirty = axis.forceRedraw = true;
          }
        });
        if (series.legendItem) {
          series.chart.legend.destroyItem(series);
        }
        i = data.length;
        while (i--) {
          point = data[i];
          if (point && point.destroy) {
            point.destroy();
          }
        }
        series.points = null;
        clearTimeout(series.animationTimeout);
        for (prop in series) {
          if (series[prop] instanceof SVGElement && !series[prop].survive) {
            destroy = issue134 && prop === 'group' ?
              'hide' :
              'destroy';
            series[prop][destroy]();
          }
        }
        if (chart.hoverSeries === series) {
          chart.hoverSeries = null;
        }
        erase(chart.series, series);
        chart.orderSeries();
        for (prop in series) {
          delete series[prop];
        }
      },
      getGraphPath: function(points, nullsAsZeroes, connectCliffs) {
        var series = this,
          options = series.options,
          step = options.step,
          reversed,
          graphPath = [],
          xMap = [],
          gap;
        points = points || series.points;
        reversed = points.reversed;
        if (reversed) {
          points.reverse();
        }
        step = {
          right: 1,
          center: 2
        } [step] || (step && 3);
        if (step && reversed) {
          step = 4 - step;
        }
        if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
          points = this.getValidPoints(points);
        }
        each(points, function(point, i) {
          var plotX = point.plotX,
            plotY = point.plotY,
            lastPoint = points[i - 1],
            pathToPoint;
          if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
            gap = true;
          }
          if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
            gap = !options.connectNulls;
          } else if (point.isNull && !nullsAsZeroes) {
            gap = true;
          } else {
            if (i === 0 || gap) {
              pathToPoint = ['M', point.plotX, point.plotY];
            } else if (series.getPointSpline) {
              pathToPoint = series.getPointSpline(points, point, i);
            } else if (step) {
              if (step === 1) {
                pathToPoint = [
                  'L',
                  lastPoint.plotX,
                  plotY
                ];
              } else if (step === 2) {
                pathToPoint = [
                  'L',
                  (lastPoint.plotX + plotX) / 2,
                  lastPoint.plotY,
                  'L',
                  (lastPoint.plotX + plotX) / 2,
                  plotY
                ];
              } else {
                pathToPoint = [
                  'L',
                  plotX,
                  lastPoint.plotY
                ];
              }
              pathToPoint.push('L', plotX, plotY);
            } else {
              pathToPoint = [
                'L',
                plotX,
                plotY
              ];
            }
            xMap.push(point.x);
            if (step) {
              xMap.push(point.x);
            }
            graphPath.push.apply(graphPath, pathToPoint);
            gap = false;
          }
        });
        graphPath.xMap = xMap;
        series.graphPath = graphPath;
        return graphPath;
      },
      drawGraph: function() {
        var series = this,
          options = this.options,
          graphPath = (this.gappedPath || this.getGraphPath).call(this),
          props = [
            [
              'graph',
              'highcharts-graph',
              options.lineColor || this.color,
              options.dashStyle
            ]
          ];
        each(this.zones, function(zone, i) {
          props.push([
            'zone-graph-' + i,
            'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),
            zone.color || series.color,
            zone.dashStyle || options.dashStyle
          ]);
        });
        each(props, function(prop, i) {
          var graphKey = prop[0],
            graph = series[graphKey],
            attribs;
          if (graph) {
            graph.endX = graphPath.xMap;
            graph.animate({
              d: graphPath
            });
          } else if (graphPath.length) {
            series[graphKey] = series.chart.renderer.path(graphPath)
              .addClass(prop[1])
              .attr({
                zIndex: 1
              })
              .add(series.group);
            attribs = {
              'stroke': prop[2],
              'stroke-width': options.lineWidth,
              'fill': (series.fillGraph && series.color) || 'none'
            };
            if (prop[3]) {
              attribs.dashstyle = prop[3];
            } else if (options.linecap !== 'square') {
              attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
            }
            graph = series[graphKey]
              .attr(attribs)
              .shadow((i < 2) && options.shadow);
          }
          if (graph) {
            graph.startX = graphPath.xMap;
            graph.isArea = graphPath.isArea;
          }
        });
      },
      applyZones: function() {
        var series = this,
          chart = this.chart,
          renderer = chart.renderer,
          zones = this.zones,
          translatedFrom,
          translatedTo,
          clips = this.clips || [],
          clipAttr,
          graph = this.graph,
          area = this.area,
          chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
          axis = this[(this.zoneAxis || 'y') + 'Axis'],
          extremes,
          reversed,
          inverted = chart.inverted,
          horiz,
          pxRange,
          pxPosMin,
          pxPosMax,
          ignoreZones = false;
        if (zones.length && (graph || area) && axis && axis.min !== undefined) {
          reversed = axis.reversed;
          horiz = axis.horiz;
          if (graph) {
            graph.hide();
          }
          if (area) {
            area.hide();
          }
          extremes = axis.getExtremes();
          each(zones, function(threshold, i) {
            translatedFrom = reversed ?
              (horiz ? chart.plotWidth : 0) :
              (horiz ? 0 : axis.toPixels(extremes.min));
            translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);
            translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);
            if (ignoreZones) {
              translatedFrom = translatedTo = axis.toPixels(extremes.max);
            }
            pxRange = Math.abs(translatedFrom - translatedTo);
            pxPosMin = Math.min(translatedFrom, translatedTo);
            pxPosMax = Math.max(translatedFrom, translatedTo);
            if (axis.isXAxis) {
              clipAttr = {
                x: inverted ? pxPosMax : pxPosMin,
                y: 0,
                width: pxRange,
                height: chartSizeMax
              };
              if (!horiz) {
                clipAttr.x = chart.plotHeight - clipAttr.x;
              }
            } else {
              clipAttr = {
                x: 0,
                y: inverted ? pxPosMax : pxPosMin,
                width: chartSizeMax,
                height: pxRange
              };
              if (horiz) {
                clipAttr.y = chart.plotWidth - clipAttr.y;
              }
            }
            if (inverted && renderer.isVML) {
              if (axis.isXAxis) {
                clipAttr = {
                  x: 0,
                  y: reversed ? pxPosMin : pxPosMax,
                  height: clipAttr.width,
                  width: chart.chartWidth
                };
              } else {
                clipAttr = {
                  x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                  y: 0,
                  width: clipAttr.height,
                  height: chart.chartHeight
                };
              }
            }
            if (clips[i]) {
              clips[i].animate(clipAttr);
            } else {
              clips[i] = renderer.clipRect(clipAttr);
              if (graph) {
                series['zone-graph-' + i].clip(clips[i]);
              }
              if (area) {
                series['zone-area-' + i].clip(clips[i]);
              }
            }
            ignoreZones = threshold.value > extremes.max;
          });
          this.clips = clips;
        }
      },
      invertGroups: function(inverted) {
        var series = this,
          chart = series.chart,
          remover;

        function setInvert() {
          each(['group', 'markerGroup'], function(groupName) {
            if (series[groupName]) {
              series[groupName].width = series.yAxis.len;
              series[groupName].height = series.xAxis.len;
              series[groupName].invert(inverted);
            }
          });
        }
        if (!series.xAxis) {
          return;
        }
        remover = addEvent(chart, 'resize', setInvert);
        addEvent(series, 'destroy', remover);
        setInvert(inverted);
        series.invertGroups = setInvert;
      },
      plotGroup: function(prop, name, visibility, zIndex, parent) {
        var group = this[prop],
          isNew = !group;
        if (isNew) {
          this[prop] = group = this.chart.renderer.g(name)
            .attr({
              zIndex: zIndex || 0.1
            })
            .add(parent);
          group.addClass('highcharts-series-' + this.index + ' highcharts-' + this.type + '-series highcharts-color-' + this.colorIndex +
            ' ' + (this.options.className || ''));
        }
        group.attr({
          visibility: visibility
        })[isNew ? 'attr' : 'animate'](this.getPlotBox());
        return group;
      },
      getPlotBox: function() {
        var chart = this.chart,
          xAxis = this.xAxis,
          yAxis = this.yAxis;
        if (chart.inverted) {
          xAxis = yAxis;
          yAxis = this.xAxis;
        }
        return {
          translateX: xAxis ? xAxis.left : chart.plotLeft,
          translateY: yAxis ? yAxis.top : chart.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      render: function() {
        var series = this,
          chart = series.chart,
          group,
          options = series.options,
          animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,
          visibility = series.visible ? 'inherit' : 'hidden',
          zIndex = options.zIndex,
          hasRendered = series.hasRendered,
          chartSeriesGroup = chart.seriesGroup,
          inverted = chart.inverted;
        group = series.plotGroup(
          'group',
          'series',
          visibility,
          zIndex,
          chartSeriesGroup
        );
        series.markerGroup = series.plotGroup(
          'markerGroup',
          'markers',
          visibility,
          zIndex,
          chartSeriesGroup
        );
        if (animDuration) {
          series.animate(true);
        }
        group.inverted = series.isCartesian ? inverted : false;
        if (series.drawGraph) {
          series.drawGraph();
          series.applyZones();
        }
        if (series.drawDataLabels) {
          series.drawDataLabels();
        }
        if (series.visible) {
          series.drawPoints();
        }
        if (series.drawTracker && series.options.enableMouseTracking !== false) {
          series.drawTracker();
        }
        series.invertGroups(inverted);
        if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
          group.clip(chart.clipRect);
        }
        if (animDuration) {
          series.animate();
        }
        if (!hasRendered) {
          series.animationTimeout = syncTimeout(function() {
            series.afterAnimate();
          }, animDuration);
        }
        series.isDirty = false;
        series.hasRendered = true;
      },
      redraw: function() {
        var series = this,
          chart = series.chart,
          wasDirty = series.isDirty || series.isDirtyData,
          group = series.group,
          xAxis = series.xAxis,
          yAxis = series.yAxis;
        if (group) {
          if (chart.inverted) {
            group.attr({
              width: chart.plotWidth,
              height: chart.plotHeight
            });
          }
          group.animate({
            translateX: pick(xAxis && xAxis.left, chart.plotLeft),
            translateY: pick(yAxis && yAxis.top, chart.plotTop)
          });
        }
        series.translate();
        series.render();
        if (wasDirty) {
          delete this.kdTree;
        }
      },
      kdDimensions: 1,
      kdAxisArray: ['clientX', 'plotY'],
      searchPoint: function(e, compareX) {
        var series = this,
          xAxis = series.xAxis,
          yAxis = series.yAxis,
          inverted = series.chart.inverted;
        return this.searchKDTree({
          clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
          plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
        }, compareX);
      },
      buildKDTree: function() {
        this.buildingKdTree = true;
        var series = this,
          dimensions = series.kdDimensions;

        function _kdtree(points, depth, dimensions) {
          var axis,
            median,
            length = points && points.length;
          if (length) {
            axis = series.kdAxisArray[depth % dimensions];
            points.sort(function(a, b) {
              return a[axis] - b[axis];
            });
            median = Math.floor(length / 2);
            return {
              point: points[median],
              left: _kdtree(points.slice(0, median), depth + 1, dimensions),
              right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
            };
          }
        }

        function startRecursive() {
          series.kdTree = _kdtree(
            series.getValidPoints(
              null, !series.directTouch
            ),
            dimensions,
            dimensions
          );
          series.buildingKdTree = false;
        }
        delete series.kdTree;
        syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
      },
      searchKDTree: function(point, compareX) {
        var series = this,
          kdX = this.kdAxisArray[0],
          kdY = this.kdAxisArray[1],
          kdComparer = compareX ? 'distX' : 'dist';

        function setDistance(p1, p2) {
          var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
            y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
            r = (x || 0) + (y || 0);
          p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
          p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
        }

        function _search(search, tree, depth, dimensions) {
          var point = tree.point,
            axis = series.kdAxisArray[depth % dimensions],
            tdist,
            sideA,
            sideB,
            ret = point,
            nPoint1,
            nPoint2;
          setDistance(search, point);
          tdist = search[axis] - point[axis];
          sideA = tdist < 0 ? 'left' : 'right';
          sideB = tdist < 0 ? 'right' : 'left';
          if (tree[sideA]) {
            nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
            ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
          }
          if (tree[sideB]) {
            if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
              nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
              ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
            }
          }
          return ret;
        }
        if (!this.kdTree && !this.buildingKdTree) {
          this.buildKDTree();
        }
        if (this.kdTree) {
          return _search(point,
            this.kdTree, this.kdDimensions, this.kdDimensions);
        }
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var Axis = H.Axis,
      Chart = H.Chart,
      correctFloat = H.correctFloat,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      each = H.each,
      format = H.format,
      pick = H.pick,
      Series = H.Series;

    function StackItem(axis, options, isNegative, x, stackOption) {
      var inverted = axis.chart.inverted;
      this.axis = axis;
      this.isNegative = isNegative;
      this.options = options;
      this.x = x;
      this.total = null;
      this.points = {};
      this.stack = stackOption;
      this.leftCliff = 0;
      this.rightCliff = 0;
      this.alignOptions = {
        align: options.align ||
          (inverted ? (isNegative ? 'left' : 'right') : 'center'),
        verticalAlign: options.verticalAlign ||
          (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
        y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
        x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
      };
      this.textAlign = options.textAlign ||
        (inverted ? (isNegative ? 'right' : 'left') : 'center');
    }
    StackItem.prototype = {
      destroy: function() {
        destroyObjectProperties(this, this.axis);
      },
      render: function(group) {
        var options = this.options,
          formatOption = options.format,
          str = formatOption ?
          format(formatOption, this) :
          options.formatter.call(this);
        if (this.label) {
          this.label.attr({
            text: str,
            visibility: 'hidden'
          });
        } else {
          this.label =
            this.axis.chart.renderer.text(str, null, null, options.useHTML)
            .css(options.style)
            .attr({
              align: this.textAlign,
              rotation: options.rotation,
              visibility: 'hidden'
            })
            .add(group);
        }
      },
      setOffset: function(xOffset, xWidth) {
        var stackItem = this,
          axis = stackItem.axis,
          chart = axis.chart,
          inverted = chart.inverted,
          reversed = axis.reversed,
          neg = (this.isNegative && !reversed) ||
          (!this.isNegative && reversed),
          y = axis.translate(
            axis.usePercentage ? 100 : this.total,
            0,
            0,
            0,
            1
          ),
          yZero = axis.translate(0),
          h = Math.abs(y - yZero),
          x = chart.xAxis[0].translate(this.x) + xOffset,
          plotHeight = chart.plotHeight,
          stackBox = {
            x: inverted ? (neg ? y : y - h) : x,
            y: inverted ?
              plotHeight - x - xWidth : (neg ? (plotHeight - y - h) :
                plotHeight - y),
            width: inverted ? h : xWidth,
            height: inverted ? xWidth : h
          },
          label = this.label,
          alignAttr;
        if (label) {
          label.align(this.alignOptions, null, stackBox);
          alignAttr = label.alignAttr;
          label[
            this.options.crop === false || chart.isInsidePlot(
              alignAttr.x,
              alignAttr.y
            ) ? 'show' : 'hide'](true);
        }
      }
    };
    Chart.prototype.getStacks = function() {
      var chart = this;
      each(chart.yAxis, function(axis) {
        if (axis.stacks && axis.hasVisibleSeries) {
          axis.oldStacks = axis.stacks;
        }
      });
      each(chart.series, function(series) {
        if (series.options.stacking && (series.visible === true ||
            chart.options.chart.ignoreHiddenSeries === false)) {
          series.stackKey = series.type + pick(series.options.stack, '');
        }
      });
    };
    Axis.prototype.buildStacks = function() {
      var axisSeries = this.series,
        series,
        reversedStacks = pick(this.options.reversedStacks, true),
        len = axisSeries.length,
        i;
      if (!this.isXAxis) {
        this.usePercentage = false;
        i = len;
        while (i--) {
          axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
        }
        i = len;
        while (i--) {
          series = axisSeries[reversedStacks ? i : len - i - 1];
          if (series.setStackCliffs) {
            series.setStackCliffs();
          }
        }
        if (this.usePercentage) {
          for (i = 0; i < len; i++) {
            axisSeries[i].setPercentStacks();
          }
        }
      }
    };
    Axis.prototype.renderStackTotals = function() {
      var axis = this,
        chart = axis.chart,
        renderer = chart.renderer,
        stacks = axis.stacks,
        stackKey,
        oneStack,
        stackCategory,
        stackTotalGroup = axis.stackTotalGroup;
      if (!stackTotalGroup) {
        axis.stackTotalGroup = stackTotalGroup =
          renderer.g('stack-labels')
          .attr({
            visibility: 'visible',
            zIndex: 6
          })
          .add();
      }
      stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
      for (stackKey in stacks) {
        oneStack = stacks[stackKey];
        for (stackCategory in oneStack) {
          oneStack[stackCategory].render(stackTotalGroup);
        }
      }
    };
    Axis.prototype.resetStacks = function() {
      var stacks = this.stacks,
        type,
        i;
      if (!this.isXAxis) {
        for (type in stacks) {
          for (i in stacks[type]) {
            if (stacks[type][i].touched < this.stacksTouched) {
              stacks[type][i].destroy();
              delete stacks[type][i];
            } else {
              stacks[type][i].total = null;
              stacks[type][i].cum = null;
            }
          }
        }
      }
    };
    Axis.prototype.cleanStacks = function() {
      var stacks, type, i;
      if (!this.isXAxis) {
        if (this.oldStacks) {
          stacks = this.stacks = this.oldStacks;
        }
        for (type in stacks) {
          for (i in stacks[type]) {
            stacks[type][i].cum = stacks[type][i].total;
          }
        }
      }
    };
    Series.prototype.setStackedPoints = function() {
      if (!this.options.stacking || (this.visible !== true &&
          this.chart.options.chart.ignoreHiddenSeries !== false)) {
        return;
      }
      var series = this,
        xData = series.processedXData,
        yData = series.processedYData,
        stackedYData = [],
        yDataLength = yData.length,
        seriesOptions = series.options,
        threshold = seriesOptions.threshold,
        stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
        stackOption = seriesOptions.stack,
        stacking = seriesOptions.stacking,
        stackKey = series.stackKey,
        negKey = '-' + stackKey,
        negStacks = series.negStacks,
        yAxis = series.yAxis,
        stacks = yAxis.stacks,
        oldStacks = yAxis.oldStacks,
        stackIndicator,
        isNegative,
        stack,
        other,
        key,
        pointKey,
        i,
        x,
        y;
      yAxis.stacksTouched += 1;
      for (i = 0; i < yDataLength; i++) {
        x = xData[i];
        y = yData[i];
        stackIndicator = series.getStackIndicator(
          stackIndicator,
          x,
          series.index
        );
        pointKey = stackIndicator.key;
        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
        key = isNegative ? negKey : stackKey;
        if (!stacks[key]) {
          stacks[key] = {};
        }
        if (!stacks[key][x]) {
          if (oldStacks[key] && oldStacks[key][x]) {
            stacks[key][x] = oldStacks[key][x];
            stacks[key][x].total = null;
          } else {
            stacks[key][x] = new StackItem(
              yAxis,
              yAxis.options.stackLabels,
              isNegative,
              x,
              stackOption
            );
          }
        }
        stack = stacks[key][x];
        if (y !== null) {
          stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];
          if (!defined(stack.cum)) {
            stack.base = pointKey;
          }
          stack.touched = yAxis.stacksTouched;
          if (stackIndicator.index > 0 && series.singleStacks === false) {
            stack.points[pointKey][0] =
              stack.points[series.index + ',' + x + ',0'][0];
          }
        }
        if (stacking === 'percent') {
          other = isNegative ? stackKey : negKey;
          if (negStacks && stacks[other] && stacks[other][x]) {
            other = stacks[other][x];
            stack.total = other.total =
              Math.max(other.total, stack.total) + Math.abs(y) || 0;
          } else {
            stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
          }
        } else {
          stack.total = correctFloat(stack.total + (y || 0));
        }
        stack.cum = pick(stack.cum, stackThreshold) + (y || 0);
        if (y !== null) {
          stack.points[pointKey].push(stack.cum);
          stackedYData[i] = stack.cum;
        }
      }
      if (stacking === 'percent') {
        yAxis.usePercentage = true;
      }
      this.stackedYData = stackedYData;
      yAxis.oldStacks = {};
    };
    Series.prototype.setPercentStacks = function() {
      var series = this,
        stackKey = series.stackKey,
        stacks = series.yAxis.stacks,
        processedXData = series.processedXData,
        stackIndicator;
      each([stackKey, '-' + stackKey], function(key) {
        var i = processedXData.length,
          x,
          stack,
          pointExtremes,
          totalFactor;
        while (i--) {
          x = processedXData[i];
          stackIndicator = series.getStackIndicator(
            stackIndicator,
            x,
            series.index,
            key
          );
          stack = stacks[key] && stacks[key][x];
          pointExtremes = stack && stack.points[stackIndicator.key];
          if (pointExtremes) {
            totalFactor = stack.total ? 100 / stack.total : 0;
            pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
            pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
            series.stackedYData[i] = pointExtremes[1];
          }
        }
      });
    };
    Series.prototype.getStackIndicator = function(stackIndicator, x, index, key) {
      if (!defined(stackIndicator) || stackIndicator.x !== x ||
        (key && stackIndicator.key !== key)) {
        stackIndicator = {
          x: x,
          index: 0,
          key: key
        };
      } else {
        stackIndicator.index++;
      }
      stackIndicator.key = [index, x, stackIndicator.index].join(',');
      return stackIndicator;
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      animate = H.animate,
      Axis = H.Axis,
      Chart = H.Chart,
      createElement = H.createElement,
      css = H.css,
      defined = H.defined,
      each = H.each,
      erase = H.erase,
      extend = H.extend,
      fireEvent = H.fireEvent,
      inArray = H.inArray,
      isNumber = H.isNumber,
      isObject = H.isObject,
      merge = H.merge,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      setAnimation = H.setAnimation,
      splat = H.splat;
    extend(Chart.prototype, {
      addSeries: function(options, redraw, animation) {
        var series,
          chart = this;
        if (options) {
          redraw = pick(redraw, true);
          fireEvent(chart, 'addSeries', {
            options: options
          }, function() {
            series = chart.initSeries(options);
            chart.isDirtyLegend = true;
            chart.linkSeries();
            if (redraw) {
              chart.redraw(animation);
            }
          });
        }
        return series;
      },
      addAxis: function(options, isX, redraw, animation) {
        var key = isX ? 'xAxis' : 'yAxis',
          chartOptions = this.options,
          userOptions = merge(options, {
            index: this[key].length,
            isX: isX
          });
        new Axis(this, userOptions);
        chartOptions[key] = splat(chartOptions[key] || {});
        chartOptions[key].push(userOptions);
        if (pick(redraw, true)) {
          this.redraw(animation);
        }
      },
      showLoading: function(str) {
        var chart = this,
          options = chart.options,
          loadingDiv = chart.loadingDiv,
          loadingOptions = options.loading,
          setLoadingSize = function() {
            if (loadingDiv) {
              css(loadingDiv, {
                left: chart.plotLeft + 'px',
                top: chart.plotTop + 'px',
                width: chart.plotWidth + 'px',
                height: chart.plotHeight + 'px'
              });
            }
          };
        if (!loadingDiv) {
          chart.loadingDiv = loadingDiv = createElement('div', {
            className: 'highcharts-loading highcharts-loading-hidden'
          }, null, chart.container);
          chart.loadingSpan = createElement(
            'span', {
              className: 'highcharts-loading-inner'
            },
            null,
            loadingDiv
          );
          addEvent(chart, 'redraw', setLoadingSize);
        }
        loadingDiv.className = 'highcharts-loading';
        chart.loadingSpan.innerHTML = str || options.lang.loading;
        css(loadingDiv, extend(loadingOptions.style, {
          zIndex: 10
        }));
        css(chart.loadingSpan, loadingOptions.labelStyle);
        if (!chart.loadingShown) {
          css(loadingDiv, {
            opacity: 0,
            display: ''
          });
          animate(loadingDiv, {
            opacity: loadingOptions.style.opacity || 0.5
          }, {
            duration: loadingOptions.showDuration || 0
          });
        }
        chart.loadingShown = true;
        setLoadingSize();
      },
      hideLoading: function() {
        var options = this.options,
          loadingDiv = this.loadingDiv;
        if (loadingDiv) {
          loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';
          animate(loadingDiv, {
            opacity: 0
          }, {
            duration: options.loading.hideDuration || 100,
            complete: function() {
              css(loadingDiv, {
                display: 'none'
              });
            }
          });
        }
        this.loadingShown = false;
      },
      propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',
        'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',
        'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth',
        'plotShadow', 'shadow'
      ],
      propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',
        'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions'
      ],
      update: function(options, redraw) {
        var key,
          adders = {
            credits: 'addCredits',
            title: 'setTitle',
            subtitle: 'setSubtitle'
          },
          optionsChart = options.chart,
          updateAllAxes,
          updateAllSeries,
          newWidth,
          newHeight;
        if (optionsChart) {
          merge(true, this.options.chart, optionsChart);
          if ('className' in optionsChart) {
            this.setClassName(optionsChart.className);
          }
          if ('inverted' in optionsChart || 'polar' in optionsChart) {
            this.propFromSeries();
            updateAllAxes = true;
          }
          for (key in optionsChart) {
            if (optionsChart.hasOwnProperty(key)) {
              if (inArray('chart.' + key, this.propsRequireUpdateSeries) !== -1) {
                updateAllSeries = true;
              }
              if (inArray(key, this.propsRequireDirtyBox) !== -1) {
                this.isDirtyBox = true;
              }
            }
          }
          if ('style' in optionsChart) {
            this.renderer.setStyle(optionsChart.style);
          }
        }
        for (key in options) {
          if (this[key] && typeof this[key].update === 'function') {
            this[key].update(options[key], false);
          } else if (typeof this[adders[key]] === 'function') {
            this[adders[key]](options[key]);
          }
          if (key !== 'chart' && inArray(key, this.propsRequireUpdateSeries) !== -1) {
            updateAllSeries = true;
          }
        }
        if (options.colors) {
          this.options.colors = options.colors;
        }
        if (options.plotOptions) {
          merge(true, this.options.plotOptions, options.plotOptions);
        }
        each(['xAxis', 'yAxis', 'series'], function(coll) {
          if (options[coll]) {
            each(splat(options[coll]), function(newOptions, i) {
              var item = (
                defined(newOptions.id) &&
                this.get(newOptions.id)
              ) || this[coll][i];
              if (item && item.coll === coll) {
                item.update(newOptions, false);
              }
            }, this);
          }
        }, this);
        if (updateAllAxes) {
          each(this.axes, function(axis) {
            axis.update({}, false);
          });
        }
        if (updateAllSeries) {
          each(this.series, function(series) {
            series.update({}, false);
          });
        }
        if (options.loading) {
          merge(true, this.options.loading, options.loading);
        }
        newWidth = optionsChart && optionsChart.width;
        newHeight = optionsChart && optionsChart.height;
        if ((isNumber(newWidth) && newWidth !== this.chartWidth) ||
          (isNumber(newHeight) && newHeight !== this.chartHeight)) {
          this.setSize(newWidth, newHeight);
        } else if (pick(redraw, true)) {
          this.redraw();
        }
      },
      setSubtitle: function(options) {
        this.setTitle(undefined, options);
      }
    });
    extend(Point.prototype, {
      update: function(options, redraw, animation, runEvent) {
        var point = this,
          series = point.series,
          graphic = point.graphic,
          i,
          chart = series.chart,
          seriesOptions = series.options;
        redraw = pick(redraw, true);

        function update() {
          point.applyOptions(options);
          if (point.y === null && graphic) {
            point.graphic = graphic.destroy();
          }
          if (isObject(options, true)) {
            if (graphic && graphic.element) {
              if (options && options.marker && options.marker.symbol) {
                point.graphic = graphic.destroy();
              }
            }
            if (options && options.dataLabels && point.dataLabel) {
              point.dataLabel = point.dataLabel.destroy();
            }
          }
          i = point.index;
          series.updateParallelArrays(point, i);
          seriesOptions.data[i] = isObject(seriesOptions.data[i], true) ? point.options : options;
          series.isDirty = series.isDirtyData = true;
          if (!series.fixedBox && series.hasCartesianSeries) {
            chart.isDirtyBox = true;
          }
          if (seriesOptions.legendType === 'point') {
            chart.isDirtyLegend = true;
          }
          if (redraw) {
            chart.redraw(animation);
          }
        }
        if (runEvent === false) {
          update();
        } else {
          point.firePointEvent('update', {
            options: options
          }, update);
        }
      },
      remove: function(redraw, animation) {
        this.series.removePoint(inArray(this, this.series.data), redraw, animation);
      }
    });
    extend(Series.prototype, {
      addPoint: function(options, redraw, shift, animation) {
        var series = this,
          seriesOptions = series.options,
          data = series.data,
          chart = series.chart,
          xAxis = series.xAxis,
          names = xAxis && xAxis.hasNames && xAxis.names,
          dataOptions = seriesOptions.data,
          point,
          isInTheMiddle,
          xData = series.xData,
          i,
          x;
        redraw = pick(redraw, true);
        point = {
          series: series
        };
        series.pointClass.prototype.applyOptions.apply(point, [options]);
        x = point.x;
        i = xData.length;
        if (series.requireSorting && x < xData[i - 1]) {
          isInTheMiddle = true;
          while (i && xData[i - 1] > x) {
            i--;
          }
        }
        series.updateParallelArrays(point, 'splice', i, 0, 0);
        series.updateParallelArrays(point, i);
        if (names && point.name) {
          names[x] = point.name;
        }
        dataOptions.splice(i, 0, options);
        if (isInTheMiddle) {
          series.data.splice(i, 0, null);
          series.processData();
        }
        if (seriesOptions.legendType === 'point') {
          series.generatePoints();
        }
        if (shift) {
          if (data[0] && data[0].remove) {
            data[0].remove(false);
          } else {
            data.shift();
            series.updateParallelArrays(point, 'shift');
            dataOptions.shift();
          }
        }
        series.isDirty = true;
        series.isDirtyData = true;
        if (redraw) {
          chart.redraw(animation);
        }
      },
      removePoint: function(i, redraw, animation) {
        var series = this,
          data = series.data,
          point = data[i],
          points = series.points,
          chart = series.chart,
          remove = function() {
            if (points && points.length === data.length) {
              points.splice(i, 1);
            }
            data.splice(i, 1);
            series.options.data.splice(i, 1);
            series.updateParallelArrays(point || {
              series: series
            }, 'splice', i, 1);
            if (point) {
              point.destroy();
            }
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
              chart.redraw();
            }
          };
        setAnimation(animation, chart);
        redraw = pick(redraw, true);
        if (point) {
          point.firePointEvent('remove', null, remove);
        } else {
          remove();
        }
      },
      remove: function(redraw, animation, withEvent) {
        var series = this,
          chart = series.chart;

        function remove() {
          series.destroy();
          chart.isDirtyLegend = chart.isDirtyBox = true;
          chart.linkSeries();
          if (pick(redraw, true)) {
            chart.redraw(animation);
          }
        }
        if (withEvent !== false) {
          fireEvent(series, 'remove', null, remove);
        } else {
          remove();
        }
      },
      update: function(newOptions, redraw) {
        var series = this,
          chart = this.chart,
          oldOptions = this.userOptions,
          oldType = this.type,
          newType = newOptions.type || oldOptions.type || chart.options.chart.type,
          proto = seriesTypes[oldType].prototype,
          preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
          n;
        if ((newType && newType !== oldType) || newOptions.zIndex !== undefined) {
          preserve.length = 0;
        }
        each(preserve, function(prop) {
          preserve[prop] = series[prop];
          delete series[prop];
        });
        newOptions = merge(oldOptions, {
          animation: false,
          index: this.index,
          pointStart: this.xData[0]
        }, {
          data: this.options.data
        }, newOptions);
        this.remove(false, null, false);
        for (n in proto) {
          this[n] = undefined;
        }
        extend(this, seriesTypes[newType || oldType].prototype);
        each(preserve, function(prop) {
          series[prop] = preserve[prop];
        });
        this.init(chart, newOptions);
        chart.linkSeries();
        if (pick(redraw, true)) {
          chart.redraw(false);
        }
      }
    });
    extend(Axis.prototype, {
      update: function(newOptions, redraw) {
        var chart = this.chart;
        newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);
        this.destroy(true);
        this.init(chart, extend(newOptions, {
          events: undefined
        }));
        chart.isDirtyBox = true;
        if (pick(redraw, true)) {
          chart.redraw();
        }
      },
      remove: function(redraw) {
        var chart = this.chart,
          key = this.coll,
          axisSeries = this.series,
          i = axisSeries.length;
        while (i--) {
          if (axisSeries[i]) {
            axisSeries[i].remove(false);
          }
        }
        erase(chart.axes, this);
        erase(chart[key], this);
        chart.options[key].splice(this.options.index, 1);
        each(chart[key], function(axis, i) {
          axis.options.index = i;
        });
        this.destroy();
        chart.isDirtyBox = true;
        if (pick(redraw, true)) {
          chart.redraw();
        }
      },
      setTitle: function(newTitleOptions, redraw) {
        this.update({
          title: newTitleOptions
        }, redraw);
      },
      setCategories: function(categories, redraw) {
        this.update({
          categories: categories
        }, redraw);
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var color = H.color,
      each = H.each,
      LegendSymbolMixin = H.LegendSymbolMixin,
      map = H.map,
      pick = H.pick,
      Series = H.Series,
      seriesType = H.seriesType;
    seriesType('area', 'line', {
      softThreshold: false,
      threshold: 0
    }, {
      singleStacks: false,
      getStackPoints: function() {
        var series = this,
          segment = [],
          keys = [],
          xAxis = this.xAxis,
          yAxis = this.yAxis,
          stack = yAxis.stacks[this.stackKey],
          pointMap = {},
          points = this.points,
          seriesIndex = series.index,
          yAxisSeries = yAxis.series,
          seriesLength = yAxisSeries.length,
          visibleSeries,
          upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
          i,
          x;
        if (this.options.stacking) {
          for (i = 0; i < points.length; i++) {
            pointMap[points[i].x] = points[i];
          }
          for (x in stack) {
            if (stack[x].total !== null) {
              keys.push(x);
            }
          }
          keys.sort(function(a, b) {
            return a - b;
          });
          visibleSeries = map(yAxisSeries, function() {
            return this.visible;
          });
          each(keys, function(x, idx) {
            var y = 0,
              stackPoint,
              stackedValues;
            if (pointMap[x] && !pointMap[x].isNull) {
              segment.push(pointMap[x]);
              each([-1, 1], function(direction) {
                var nullName = direction === 1 ? 'rightNull' : 'leftNull',
                  cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
                  cliff = 0,
                  otherStack = stack[keys[idx + direction]];
                if (otherStack) {
                  i = seriesIndex;
                  while (i >= 0 && i < seriesLength) {
                    stackPoint = otherStack.points[i];
                    if (!stackPoint) {
                      if (i === seriesIndex) {
                        pointMap[x][nullName] = true;
                      } else if (visibleSeries[i]) {
                        stackedValues = stack[x].points[i];
                        if (stackedValues) {
                          cliff -= stackedValues[1] - stackedValues[0];
                        }
                      }
                    }
                    i += upOrDown;
                  }
                }
                pointMap[x][cliffName] = cliff;
              });
            } else {
              i = seriesIndex;
              while (i >= 0 && i < seriesLength) {
                stackPoint = stack[x].points[i];
                if (stackPoint) {
                  y = stackPoint[1];
                  break;
                }
                i += upOrDown;
              }
              y = yAxis.toPixels(y, true);
              segment.push({
                isNull: true,
                plotX: xAxis.toPixels(x, true),
                plotY: y,
                yBottom: y
              });
            }
          });
        }
        return segment;
      },
      getGraphPath: function(points) {
        var getGraphPath = Series.prototype.getGraphPath,
          graphPath,
          options = this.options,
          stacking = options.stacking,
          yAxis = this.yAxis,
          topPath,
          bottomPath,
          bottomPoints = [],
          graphPoints = [],
          seriesIndex = this.index,
          i,
          areaPath,
          plotX,
          stacks = yAxis.stacks[this.stackKey],
          threshold = options.threshold,
          translatedThreshold = yAxis.getThreshold(options.threshold),
          isNull,
          yBottom,
          connectNulls = options.connectNulls || stacking === 'percent',
          addDummyPoints = function(i, otherI, side) {
            var point = points[i],
              stackedValues = stacking && stacks[point.x].points[seriesIndex],
              nullVal = point[side + 'Null'] || 0,
              cliffVal = point[side + 'Cliff'] || 0,
              top,
              bottom,
              isNull = true;
            if (cliffVal || nullVal) {
              top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
              bottom = stackedValues[0] + cliffVal;
              isNull = !!nullVal;
            } else if (!stacking && points[otherI] && points[otherI].isNull) {
              top = bottom = threshold;
            }
            if (top !== undefined) {
              graphPoints.push({
                plotX: plotX,
                plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
                isNull: isNull
              });
              bottomPoints.push({
                plotX: plotX,
                plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
                doCurve: false
              });
            }
          };
        points = points || this.points;
        if (stacking) {
          points = this.getStackPoints();
        }
        for (i = 0; i < points.length; i++) {
          isNull = points[i].isNull;
          plotX = pick(points[i].rectPlotX, points[i].plotX);
          yBottom = pick(points[i].yBottom, translatedThreshold);
          if (!isNull || connectNulls) {
            if (!connectNulls) {
              addDummyPoints(i, i - 1, 'left');
            }
            if (!(isNull && !stacking && connectNulls)) {
              graphPoints.push(points[i]);
              bottomPoints.push({
                x: i,
                plotX: plotX,
                plotY: yBottom
              });
            }
            if (!connectNulls) {
              addDummyPoints(i, i + 1, 'right');
            }
          }
        }
        topPath = getGraphPath.call(this, graphPoints, true, true);
        bottomPoints.reversed = true;
        bottomPath = getGraphPath.call(this, bottomPoints, true, true);
        if (bottomPath.length) {
          bottomPath[0] = 'L';
        }
        areaPath = topPath.concat(bottomPath);
        graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
        areaPath.xMap = topPath.xMap;
        this.areaPath = areaPath;
        return graphPath;
      },
      drawGraph: function() {
        this.areaPath = [];
        Series.prototype.drawGraph.apply(this);
        var series = this,
          areaPath = this.areaPath,
          options = this.options,
          zones = this.zones,
          props = [
            [
              'area',
              'highcharts-area',
              this.color,
              options.fillColor
            ]
          ];
        each(zones, function(zone, i) {
          props.push([
            'zone-area-' + i,
            'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,
            zone.color || series.color,
            zone.fillColor || options.fillColor
          ]);
        });
        each(props, function(prop) {
          var areaKey = prop[0],
            area = series[areaKey];
          if (area) {
            area.endX = areaPath.xMap;
            area.animate({
              d: areaPath
            });
          } else {
            area = series[areaKey] = series.chart.renderer.path(areaPath)
              .addClass(prop[1])
              .attr({
                fill: pick(
                  prop[3],
                  color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()
                ),
                zIndex: 0
              }).add(series.group);
            area.isArea = true;
          }
          area.startX = areaPath.xMap;
          area.shiftUnit = options.step ? 2 : 1;
        });
      },
      drawLegendSymbol: LegendSymbolMixin.drawRectangle
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var pick = H.pick,
      seriesType = H.seriesType;
    seriesType('spline', 'line', {}, {
      getPointSpline: function(points, point, i) {
        var smoothing = 1.5,
          denom = smoothing + 1,
          plotX = point.plotX,
          plotY = point.plotY,
          lastPoint = points[i - 1],
          nextPoint = points[i + 1],
          leftContX,
          leftContY,
          rightContX,
          rightContY,
          ret;

        function doCurve(otherPoint) {
          return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false;
        }
        if (doCurve(lastPoint) && doCurve(nextPoint)) {
          var lastX = lastPoint.plotX,
            lastY = lastPoint.plotY,
            nextX = nextPoint.plotX,
            nextY = nextPoint.plotY,
            correction = 0;
          leftContX = (smoothing * plotX + lastX) / denom;
          leftContY = (smoothing * plotY + lastY) / denom;
          rightContX = (smoothing * plotX + nextX) / denom;
          rightContY = (smoothing * plotY + nextY) / denom;
          if (rightContX !== leftContX) {
            correction = ((rightContY - leftContY) * (rightContX - plotX)) /
              (rightContX - leftContX) + plotY - rightContY;
          }
          leftContY += correction;
          rightContY += correction;
          if (leftContY > lastY && leftContY > plotY) {
            leftContY = Math.max(lastY, plotY);
            rightContY = 2 * plotY - leftContY;
          } else if (leftContY < lastY && leftContY < plotY) {
            leftContY = Math.min(lastY, plotY);
            rightContY = 2 * plotY - leftContY;
          }
          if (rightContY > nextY && rightContY > plotY) {
            rightContY = Math.max(nextY, plotY);
            leftContY = 2 * plotY - rightContY;
          } else if (rightContY < nextY && rightContY < plotY) {
            rightContY = Math.min(nextY, plotY);
            leftContY = 2 * plotY - rightContY;
          }
          point.rightContX = rightContX;
          point.rightContY = rightContY;
        }
        ret = [
          'C',
          pick(lastPoint.rightContX, lastPoint.plotX),
          pick(lastPoint.rightContY, lastPoint.plotY),
          pick(leftContX, plotX),
          pick(leftContY, plotY),
          plotX,
          plotY
        ];
        lastPoint.rightContX = lastPoint.rightContY = null;
        return ret;
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var areaProto = H.seriesTypes.area.prototype,
      defaultPlotOptions = H.defaultPlotOptions,
      LegendSymbolMixin = H.LegendSymbolMixin,
      seriesType = H.seriesType;
    seriesType('areaspline', 'spline', defaultPlotOptions.area, {
      getStackPoints: areaProto.getStackPoints,
      getGraphPath: areaProto.getGraphPath,
      setStackCliffs: areaProto.setStackCliffs,
      drawGraph: areaProto.drawGraph,
      drawLegendSymbol: LegendSymbolMixin.drawRectangle
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var animObject = H.animObject,
      color = H.color,
      each = H.each,
      extend = H.extend,
      isNumber = H.isNumber,
      LegendSymbolMixin = H.LegendSymbolMixin,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      Series = H.Series,
      seriesType = H.seriesType,
      svg = H.svg;
    seriesType('column', 'line', {
      borderRadius: 0,
      groupPadding: 0.2,
      marker: null,
      pointPadding: 0.1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: false,
          brightness: 0.1,
          shadow: false
        },
        select: {
          color: '#cccccc',
          borderColor: '#000000',
          shadow: false
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: false,
      startFromThreshold: true,
      stickyTracking: false,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: '#ffffff'
    }, {
      cropShoulder: 0,
      directTouch: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      negStacks: true,
      init: function() {
        Series.prototype.init.apply(this, arguments);
        var series = this,
          chart = series.chart;
        if (chart.hasRendered) {
          each(chart.series, function(otherSeries) {
            if (otherSeries.type === series.type) {
              otherSeries.isDirty = true;
            }
          });
        }
      },
      getColumnMetrics: function() {
        var series = this,
          options = series.options,
          xAxis = series.xAxis,
          yAxis = series.yAxis,
          reversedXAxis = xAxis.reversed,
          stackKey,
          stackGroups = {},
          columnCount = 0;
        if (options.grouping === false) {
          columnCount = 1;
        } else {
          each(series.chart.series, function(otherSeries) {
            var otherOptions = otherSeries.options,
              otherYAxis = otherSeries.yAxis,
              columnIndex;
            if (otherSeries.type === series.type && otherSeries.visible &&
              yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
              if (otherOptions.stacking) {
                stackKey = otherSeries.stackKey;
                if (stackGroups[stackKey] === undefined) {
                  stackGroups[stackKey] = columnCount++;
                }
                columnIndex = stackGroups[stackKey];
              } else if (otherOptions.grouping !== false) {
                columnIndex = columnCount++;
              }
              otherSeries.columnIndex = columnIndex;
            }
          });
        }
        var categoryWidth = Math.min(
            Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1),
            xAxis.len
          ),
          groupPadding = categoryWidth * options.groupPadding,
          groupWidth = categoryWidth - 2 * groupPadding,
          pointOffsetWidth = groupWidth / (columnCount || 1),
          pointWidth = Math.min(
            options.maxPointWidth || xAxis.len,
            pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
          ),
          pointPadding = (pointOffsetWidth - pointWidth) / 2,
          colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0),
          pointXOffset = pointPadding + (groupPadding + colIndex *
            pointOffsetWidth - (categoryWidth / 2)) *
          (reversedXAxis ? -1 : 1);
        series.columnMetrics = {
          width: pointWidth,
          offset: pointXOffset
        };
        return series.columnMetrics;
      },
      crispCol: function(x, y, w, h) {
        var chart = this.chart,
          borderWidth = this.borderWidth,
          xCrisp = -(borderWidth % 2 ? 0.5 : 0),
          yCrisp = borderWidth % 2 ? 0.5 : 1,
          right,
          bottom,
          fromTop;
        if (chart.inverted && chart.renderer.isVML) {
          yCrisp += 1;
        }
        right = Math.round(x + w) + xCrisp;
        x = Math.round(x) + xCrisp;
        w = right - x;
        bottom = Math.round(y + h) + yCrisp;
        fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
        y = Math.round(y) + yCrisp;
        h = bottom - y;
        if (fromTop && h) {
          y -= 1;
          h += 1;
        }
        return {
          x: x,
          y: y,
          width: w,
          height: h
        };
      },
      translate: function() {
        var series = this,
          chart = series.chart,
          options = series.options,
          dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,
          borderWidth = series.borderWidth = pick(
            options.borderWidth,
            dense ? 0 : 1
          ),
          yAxis = series.yAxis,
          threshold = options.threshold,
          translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
          minPointLength = pick(options.minPointLength, 5),
          metrics = series.getColumnMetrics(),
          pointWidth = metrics.width,
          seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth),
          pointXOffset = series.pointXOffset = metrics.offset;
        if (chart.inverted) {
          translatedThreshold -= 0.5;
        }
        if (options.pointPadding) {
          seriesBarW = Math.ceil(seriesBarW);
        }
        Series.prototype.translate.apply(series);
        each(series.points, function(point) {
          var yBottom = pick(point.yBottom, translatedThreshold),
            safeDistance = 999 + Math.abs(yBottom),
            plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance),
            barX = point.plotX + pointXOffset,
            barW = seriesBarW,
            barY = Math.min(plotY, yBottom),
            up,
            barH = Math.max(plotY, yBottom) - barY;
          if (Math.abs(barH) < minPointLength) {
            if (minPointLength) {
              barH = minPointLength;
              up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
              barY = Math.abs(barY - translatedThreshold) > minPointLength ?
                yBottom - minPointLength :
                translatedThreshold - (up ? minPointLength : 0);
            }
          }
          point.barX = barX;
          point.pointWidth = pointWidth;
          point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];
          point.shapeType = 'rect';
          point.shapeArgs = series.crispCol.apply(
            series,
            point.isNull ? [point.plotX, yAxis.len / 2, 0, 0] : [barX, barY, barW, barH]
          );
        });
      },
      getSymbol: noop,
      drawLegendSymbol: LegendSymbolMixin.drawRectangle,
      drawGraph: function() {
        this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
      },
      pointAttribs: function(point, state) {
        var options = this.options,
          stateOptions,
          ret,
          p2o = this.pointAttrToOptions || {},
          strokeOption = p2o.stroke || 'borderColor',
          strokeWidthOption = p2o['stroke-width'] || 'borderWidth',
          fill = (point && point.color) || this.color,
          stroke = point[strokeOption] || options[strokeOption] ||
          this.color || fill,
          strokeWidth = point[strokeWidthOption] ||
          options[strokeWidthOption] || this[strokeWidthOption] || 0,
          dashstyle = options.dashStyle,
          zone,
          brightness;
        if (point && this.zones.length) {
          zone = point.getZone();
          fill = (zone && zone.color) || point.options.color || this.color;
        }
        if (state) {
          stateOptions = options.states[state];
          brightness = stateOptions.brightness;
          fill = stateOptions.color ||
            (brightness !== undefined && color(fill).brighten(stateOptions.brightness).get()) ||
            fill;
          stroke = stateOptions[strokeOption] || stroke;
          strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
          dashstyle = stateOptions.dashStyle || dashstyle;
        }
        ret = {
          'fill': fill,
          'stroke': stroke,
          'stroke-width': strokeWidth
        };
        if (options.borderRadius) {
          ret.r = options.borderRadius;
        }
        if (dashstyle) {
          ret.dashstyle = dashstyle;
        }
        return ret;
      },
      drawPoints: function() {
        var series = this,
          chart = this.chart,
          options = series.options,
          renderer = chart.renderer,
          animationLimit = options.animationLimit || 250,
          shapeArgs;
        each(series.points, function(point) {
          var plotY = point.plotY,
            graphic = point.graphic;
          if (isNumber(plotY) && point.y !== null) {
            shapeArgs = point.shapeArgs;
            if (graphic) {
              graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](
                merge(shapeArgs)
              );
            } else {
              point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                .attr({
                  'class': point.getClassName()
                })
                .add(point.group || series.group);
            }
            graphic
              .attr(series.pointAttribs(point, point.selected && 'select'))
              .shadow(options.shadow, null, options.stacking && !options.borderRadius);
          } else if (graphic) {
            point.graphic = graphic.destroy();
          }
        });
      },
      animate: function(init) {
        var series = this,
          yAxis = this.yAxis,
          options = series.options,
          inverted = this.chart.inverted,
          attr = {},
          translatedThreshold;
        if (svg) {
          if (init) {
            attr.scaleY = 0.001;
            translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));
            if (inverted) {
              attr.translateX = translatedThreshold - yAxis.len;
            } else {
              attr.translateY = translatedThreshold;
            }
            series.group.attr(attr);
          } else {
            attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
            series.group.animate(attr, extend(animObject(series.options.animation), {
              step: function(val, fx) {
                series.group.attr({
                  scaleY: Math.max(0.001, fx.pos)
                });
              }
            }));
            series.animate = null;
          }
        }
      },
      remove: function() {
        var series = this,
          chart = series.chart;
        if (chart.hasRendered) {
          each(chart.series, function(otherSeries) {
            if (otherSeries.type === series.type) {
              otherSeries.isDirty = true;
            }
          });
        }
        Series.prototype.remove.apply(series, arguments);
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var seriesType = H.seriesType;
    seriesType('bar', 'column', null, {
      inverted: true
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var Series = H.Series,
      seriesType = H.seriesType;
    seriesType('scatter', 'line', {
      lineWidth: 0,
      marker: {
        enabled: true
      },
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25CF</span> ' +
          '<span style="font-size: 0.85em"> {series.name}</span><br/>',
        pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
      }
    }, {
      sorted: false,
      requireSorting: false,
      noSharedTooltip: true,
      trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
      takeOrdinalPosition: false,
      kdDimensions: 2,
      drawGraph: function() {
        if (this.options.lineWidth) {
          Series.prototype.drawGraph.call(this);
        }
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var pick = H.pick,
      relativeLength = H.relativeLength;
    H.CenteredSeriesMixin = {
      getCenter: function() {
        var options = this.options,
          chart = this.chart,
          slicingRoom = 2 * (options.slicedOffset || 0),
          handleSlicingRoom,
          plotWidth = chart.plotWidth - 2 * slicingRoom,
          plotHeight = chart.plotHeight - 2 * slicingRoom,
          centerOption = options.center,
          positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
          smallestSize = Math.min(plotWidth, plotHeight),
          i,
          value;
        for (i = 0; i < 4; ++i) {
          value = positions[i];
          handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));
          positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
            (handleSlicingRoom ? slicingRoom : 0);
        }
        if (positions[3] > positions[2]) {
          positions[3] = positions[2];
        }
        return positions;
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      CenteredSeriesMixin = H.CenteredSeriesMixin,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      inArray = H.inArray,
      LegendSymbolMixin = H.LegendSymbolMixin,
      noop = H.noop,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes,
      setAnimation = H.setAnimation;
    seriesType('pie', 'line', {
      center: [null, null],
      clip: false,
      colorByPoint: true,
      dataLabels: {
        distance: 30,
        enabled: true,
        formatter: function() {
          return this.y === null ? undefined : this.point.name;
        },
        x: 0
      },
      ignoreHiddenPoint: true,
      legendType: 'point',
      marker: null,
      size: null,
      showInLegend: false,
      slicedOffset: 10,
      stickyTracking: false,
      tooltip: {
        followPointer: true
      },
      borderColor: '#ffffff',
      borderWidth: 1,
      states: {
        hover: {
          brightness: 0.1,
          shadow: false
        }
      }
    }, {
      isCartesian: false,
      requireSorting: false,
      directTouch: true,
      noSharedTooltip: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      axisTypes: [],
      pointAttribs: seriesTypes.column.prototype.pointAttribs,
      animate: function(init) {
        var series = this,
          points = series.points,
          startAngleRad = series.startAngleRad;
        if (!init) {
          each(points, function(point) {
            var graphic = point.graphic,
              args = point.shapeArgs;
            if (graphic) {
              graphic.attr({
                r: point.startR || (series.center[3] / 2),
                start: startAngleRad,
                end: startAngleRad
              });
              graphic.animate({
                r: args.r,
                start: args.start,
                end: args.end
              }, series.options.animation);
            }
          });
          series.animate = null;
        }
      },
      updateTotals: function() {
        var i,
          total = 0,
          points = this.points,
          len = points.length,
          point,
          ignoreHiddenPoint = this.options.ignoreHiddenPoint;
        for (i = 0; i < len; i++) {
          point = points[i];
          if (point.y < 0) {
            point.y = null;
          }
          total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
        }
        this.total = total;
        for (i = 0; i < len; i++) {
          point = points[i];
          point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
          point.total = total;
        }
      },
      generatePoints: function() {
        Series.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      translate: function(positions) {
        this.generatePoints();
        var series = this,
          cumulative = 0,
          precision = 1000,
          options = series.options,
          slicedOffset = options.slicedOffset,
          connectorOffset = slicedOffset + (options.borderWidth || 0),
          start,
          end,
          angle,
          startAngle = options.startAngle || 0,
          startAngleRad = series.startAngleRad = Math.PI / 180 * (startAngle - 90),
          endAngleRad = series.endAngleRad = Math.PI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
          circ = endAngleRad - startAngleRad,
          points = series.points,
          radiusX,
          radiusY,
          labelDistance = options.dataLabels.distance,
          ignoreHiddenPoint = options.ignoreHiddenPoint,
          i,
          len = points.length,
          point;
        if (!positions) {
          series.center = positions = series.getCenter();
        }
        series.getX = function(y, left) {
          angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));
          return positions[0] +
            (left ? -1 : 1) *
            (Math.cos(angle) * (positions[2] / 2 + labelDistance));
        };
        for (i = 0; i < len; i++) {
          point = points[i];
          start = startAngleRad + (cumulative * circ);
          if (!ignoreHiddenPoint || point.visible) {
            cumulative += point.percentage / 100;
          }
          end = startAngleRad + (cumulative * circ);
          point.shapeType = 'arc';
          point.shapeArgs = {
            x: positions[0],
            y: positions[1],
            r: positions[2] / 2,
            innerR: positions[3] / 2,
            start: Math.round(start * precision) / precision,
            end: Math.round(end * precision) / precision
          };
          angle = (end + start) / 2;
          if (angle > 1.5 * Math.PI) {
            angle -= 2 * Math.PI;
          } else if (angle < -Math.PI / 2) {
            angle += 2 * Math.PI;
          }
          point.slicedTranslation = {
            translateX: Math.round(Math.cos(angle) * slicedOffset),
            translateY: Math.round(Math.sin(angle) * slicedOffset)
          };
          radiusX = Math.cos(angle) * positions[2] / 2;
          radiusY = Math.sin(angle) * positions[2] / 2;
          point.tooltipPos = [
            positions[0] + radiusX * 0.7,
            positions[1] + radiusY * 0.7
          ];
          point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
          point.angle = angle;
          connectorOffset = Math.min(connectorOffset, labelDistance / 5);
          point.labelPos = [
            positions[0] + radiusX + Math.cos(angle) * labelDistance,
            positions[1] + radiusY + Math.sin(angle) * labelDistance,
            positions[0] + radiusX + Math.cos(angle) * connectorOffset,
            positions[1] + radiusY + Math.sin(angle) * connectorOffset,
            positions[0] + radiusX,
            positions[1] + radiusY,
            labelDistance < 0 ?
            'center' :
            point.half ? 'right' : 'left',
            angle
          ];
        }
      },
      drawGraph: null,
      drawPoints: function() {
        var series = this,
          chart = series.chart,
          renderer = chart.renderer,
          groupTranslation,
          graphic,
          pointAttr,
          shapeArgs;
        var shadow = series.options.shadow;
        if (shadow && !series.shadowGroup) {
          series.shadowGroup = renderer.g('shadow')
            .add(series.group);
        }
        each(series.points, function(point) {
          if (point.y !== null) {
            graphic = point.graphic;
            shapeArgs = point.shapeArgs;
            groupTranslation = point.sliced ? point.slicedTranslation : {};
            var shadowGroup = point.shadowGroup;
            if (shadow && !shadowGroup) {
              shadowGroup = point.shadowGroup = renderer.g('shadow')
                .add(series.shadowGroup);
            }
            if (shadowGroup) {
              shadowGroup.attr(groupTranslation);
            }
            pointAttr = series.pointAttribs(point, point.selected && 'select');
            if (graphic) {
              graphic
                .setRadialReference(series.center)
                .attr(pointAttr)
                .animate(extend(shapeArgs, groupTranslation));
            } else {
              point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                .addClass(point.getClassName())
                .setRadialReference(series.center)
                .attr(groupTranslation)
                .add(series.group);
              if (!point.visible) {
                graphic.attr({
                  visibility: 'hidden'
                });
              }
              graphic
                .attr(pointAttr)
                .attr({
                  'stroke-linejoin': 'round'
                })
                .shadow(shadow, shadowGroup);
            }
          }
        });
      },
      searchPoint: noop,
      sortByAngle: function(points, sign) {
        points.sort(function(a, b) {
          return a.angle !== undefined && (b.angle - a.angle) * sign;
        });
      },
      drawLegendSymbol: LegendSymbolMixin.drawRectangle,
      getCenter: CenteredSeriesMixin.getCenter,
      getSymbol: noop
    }, {
      init: function() {
        Point.prototype.init.apply(this, arguments);
        var point = this,
          toggleSlice;
        point.name = pick(point.name, 'Slice');
        toggleSlice = function(e) {
          point.slice(e.type === 'select');
        };
        addEvent(point, 'select', toggleSlice);
        addEvent(point, 'unselect', toggleSlice);
        return point;
      },
      setVisible: function(vis, redraw) {
        var point = this,
          series = point.series,
          chart = series.chart,
          ignoreHiddenPoint = series.options.ignoreHiddenPoint;
        redraw = pick(redraw, ignoreHiddenPoint);
        if (vis !== point.visible) {
          point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;
          series.options.data[inArray(point, series.data)] = point.options;
          each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function(key) {
            if (point[key]) {
              point[key][vis ? 'show' : 'hide'](true);
            }
          });
          if (point.legendItem) {
            chart.legend.colorizeItem(point, vis);
          }
          if (!vis && point.state === 'hover') {
            point.setState('');
          }
          if (ignoreHiddenPoint) {
            series.isDirty = true;
          }
          if (redraw) {
            chart.redraw();
          }
        }
      },
      slice: function(sliced, redraw, animation) {
        var point = this,
          series = point.series,
          chart = series.chart,
          translation;
        setAnimation(animation, chart);
        redraw = pick(redraw, true);
        point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
        series.options.data[inArray(point, series.data)] = point.options;
        translation = sliced ? point.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
        point.graphic.animate(translation);
        if (point.shadowGroup) {
          point.shadowGroup.animate(translation);
        }
      },
      haloPath: function(size) {
        var shapeArgs = this.shapeArgs;
        return this.sliced || !this.visible ? [] :
          this.series.chart.renderer.symbols.arc(
            shapeArgs.x,
            shapeArgs.y,
            shapeArgs.r + size,
            shapeArgs.r + size, {
              innerR: this.shapeArgs.r,
              start: shapeArgs.start,
              end: shapeArgs.end
            }
          );
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      arrayMax = H.arrayMax,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      format = H.format,
      map = H.map,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      relativeLength = H.relativeLength,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      stableSort = H.stableSort;
    H.distribute = function(boxes, len) {
      var i,
        overlapping = true,
        origBoxes = boxes,
        restBoxes = [],
        box,
        target,
        total = 0;

      function sortByTarget(a, b) {
        return a.target - b.target;
      }
      i = boxes.length;
      while (i--) {
        total += boxes[i].size;
      }
      if (total > len) {
        stableSort(boxes, function(a, b) {
          return (b.rank || 0) - (a.rank || 0);
        });
        i = 0;
        total = 0;
        while (total <= len) {
          total += boxes[i].size;
          i++;
        }
        restBoxes = boxes.splice(i - 1, boxes.length);
      }
      stableSort(boxes, sortByTarget);
      boxes = map(boxes, function(box) {
        return {
          size: box.size,
          targets: [box.target]
        };
      });
      while (overlapping) {
        i = boxes.length;
        while (i--) {
          box = boxes[i];
          target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
          box.pos = Math.min(Math.max(0, target - box.size / 2), len - box.size);
        }
        i = boxes.length;
        overlapping = false;
        while (i--) {
          if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
            boxes[i - 1].size += boxes[i].size;
            boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
            if (boxes[i - 1].pos + boxes[i - 1].size > len) {
              boxes[i - 1].pos = len - boxes[i - 1].size;
            }
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      }
      i = 0;
      each(boxes, function(box) {
        var posInCompositeBox = 0;
        each(box.targets, function() {
          origBoxes[i].pos = box.pos + posInCompositeBox;
          posInCompositeBox += origBoxes[i].size;
          i++;
        });
      });
      origBoxes.push.apply(origBoxes, restBoxes);
      stableSort(origBoxes, sortByTarget);
    };
    Series.prototype.drawDataLabels = function() {
      var series = this,
        seriesOptions = series.options,
        options = seriesOptions.dataLabels,
        points = series.points,
        pointOptions,
        generalOptions,
        hasRendered = series.hasRendered || 0,
        str,
        dataLabelsGroup,
        defer = pick(options.defer, true),
        renderer = series.chart.renderer;
      if (options.enabled || series._hasPointLabels) {
        if (series.dlProcessOptions) {
          series.dlProcessOptions(options);
        }
        dataLabelsGroup = series.plotGroup(
          'dataLabelsGroup',
          'data-labels',
          defer && !hasRendered ? 'hidden' : 'visible',
          options.zIndex || 6
        );
        if (defer) {
          dataLabelsGroup.attr({
            opacity: +hasRendered
          });
          if (!hasRendered) {
            addEvent(series, 'afterAnimate', function() {
              if (series.visible) {
                dataLabelsGroup.show(true);
              }
              dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({
                opacity: 1
              }, {
                duration: 200
              });
            });
          }
        }
        generalOptions = options;
        each(points, function(point) {
          var enabled,
            dataLabel = point.dataLabel,
            labelConfig,
            attr,
            name,
            rotation,
            connector = point.connector,
            isNew = !dataLabel,
            style;
          pointOptions = point.dlOptions || (point.options && point.options.dataLabels);
          enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null;
          if (enabled) {
            options = merge(generalOptions, pointOptions);
            labelConfig = point.getLabelConfig();
            str = options.format ?
              format(options.format, labelConfig) :
              options.formatter.call(labelConfig, options);
            style = options.style;
            rotation = options.rotation;
            style.color = pick(options.color, style.color, series.color, '#000000');
            if (style.color === 'contrast') {
              style.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?
                renderer.getContrast(point.color || series.color) :
                '#000000';
            }
            if (seriesOptions.cursor) {
              style.cursor = seriesOptions.cursor;
            }
            attr = {
              fill: options.backgroundColor,
              stroke: options.borderColor,
              'stroke-width': options.borderWidth,
              r: options.borderRadius || 0,
              rotation: rotation,
              padding: options.padding,
              zIndex: 1
            };
            for (name in attr) {
              if (attr[name] === undefined) {
                delete attr[name];
              }
            }
          }
          if (dataLabel && (!enabled || !defined(str))) {
            point.dataLabel = dataLabel = dataLabel.destroy();
            if (connector) {
              point.connector = connector.destroy();
            }
          } else if (enabled && defined(str)) {
            if (!dataLabel) {
              dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label'](
                str,
                0, -9999,
                options.shape,
                null,
                null,
                options.useHTML,
                null,
                'data-label'
              );
              dataLabel.addClass(
                'highcharts-data-label-color-' + point.colorIndex +
                ' ' + (options.className || '') +
                (options.useHTML ? 'highcharts-tracker' : '')
              );
            } else {
              attr.text = str;
            }
            dataLabel.attr(attr);
            dataLabel.css(style).shadow(options.shadow);
            if (!dataLabel.added) {
              dataLabel.add(dataLabelsGroup);
            }
            series.alignDataLabel(point, dataLabel, options, null, isNew);
          }
        });
      }
    };
    Series.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
      var chart = this.chart,
        inverted = chart.inverted,
        plotX = pick(point.plotX, -9999),
        plotY = pick(point.plotY, -9999),
        bBox = dataLabel.getBBox(),
        fontSize,
        baseline,
        rotation = options.rotation,
        normRotation,
        negRotation,
        align = options.align,
        rotCorr,
        visible =
        this.visible &&
        (
          point.series.forceDL ||
          chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||
          (
            alignTo && chart.isInsidePlot(
              plotX,
              inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1,
              inverted
            )
          )
        ),
        alignAttr,
        justify = pick(options.overflow, 'justify') === 'justify';
      if (visible) {
        fontSize = options.style.fontSize;
        baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;
        alignTo = extend({
          x: inverted ? chart.plotWidth - plotY : plotX,
          y: Math.round(inverted ? chart.plotHeight - plotX : plotY),
          width: 0,
          height: 0
        }, alignTo);
        extend(options, {
          width: bBox.width,
          height: bBox.height
        });
        if (rotation) {
          justify = false;
          rotCorr = chart.renderer.rotCorr(baseline, rotation);
          alignAttr = {
            x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
            y: alignTo.y + options.y + {
              top: 0,
              middle: 0.5,
              bottom: 1
            } [options.verticalAlign] * alignTo.height
          };
          dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
            .attr({
              align: align
            });
          normRotation = (rotation + 720) % 360;
          negRotation = normRotation > 180 && normRotation < 360;
          if (align === 'left') {
            alignAttr.y -= negRotation ? bBox.height : 0;
          } else if (align === 'center') {
            alignAttr.x -= bBox.width / 2;
            alignAttr.y -= bBox.height / 2;
          } else if (align === 'right') {
            alignAttr.x -= bBox.width;
            alignAttr.y -= negRotation ? 0 : bBox.height;
          }
        } else {
          dataLabel.align(options, null, alignTo);
          alignAttr = dataLabel.alignAttr;
        }
        if (justify) {
          this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
        } else if (pick(options.crop, true)) {
          visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
        }
        if (options.shape && !rotation) {
          dataLabel.attr({
            anchorX: point.plotX,
            anchorY: point.plotY
          });
        }
      }
      if (!visible) {
        dataLabel.attr({
          y: -9999
        });
        dataLabel.placed = false;
      }
    };
    Series.prototype.justifyDataLabel = function(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
      var chart = this.chart,
        align = options.align,
        verticalAlign = options.verticalAlign,
        off,
        justified,
        padding = dataLabel.box ? 0 : (dataLabel.padding || 0);
      off = alignAttr.x + padding;
      if (off < 0) {
        if (align === 'right') {
          options.align = 'left';
        } else {
          options.x = -off;
        }
        justified = true;
      }
      off = alignAttr.x + bBox.width - padding;
      if (off > chart.plotWidth) {
        if (align === 'left') {
          options.align = 'right';
        } else {
          options.x = chart.plotWidth - off;
        }
        justified = true;
      }
      off = alignAttr.y + padding;
      if (off < 0) {
        if (verticalAlign === 'bottom') {
          options.verticalAlign = 'top';
        } else {
          options.y = -off;
        }
        justified = true;
      }
      off = alignAttr.y + bBox.height - padding;
      if (off > chart.plotHeight) {
        if (verticalAlign === 'top') {
          options.verticalAlign = 'bottom';
        } else {
          options.y = chart.plotHeight - off;
        }
        justified = true;
      }
      if (justified) {
        dataLabel.placed = !isNew;
        dataLabel.align(options, null, alignTo);
      }
    };
    if (seriesTypes.pie) {
      seriesTypes.pie.prototype.drawDataLabels = function() {
        var series = this,
          data = series.data,
          point,
          chart = series.chart,
          options = series.options.dataLabels,
          connectorPadding = pick(options.connectorPadding, 10),
          connectorWidth = pick(options.connectorWidth, 1),
          plotWidth = chart.plotWidth,
          plotHeight = chart.plotHeight,
          connector,
          distanceOption = options.distance,
          seriesCenter = series.center,
          radius = seriesCenter[2] / 2,
          centerY = seriesCenter[1],
          outside = distanceOption > 0,
          dataLabel,
          dataLabelWidth,
          labelPos,
          labelHeight,
          halves = [
            [],
            []
          ],
          x,
          y,
          visibility,
          j,
          overflow = [0, 0, 0, 0];
        if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
          return;
        }
        Series.prototype.drawDataLabels.apply(series);
        each(data, function(point) {
          if (point.dataLabel && point.visible) {
            halves[point.half].push(point);
            point.dataLabel._pos = null;
          }
        });
        each(halves, function(points, i) {
          var top,
            bottom,
            length = points.length,
            positions,
            naturalY,
            size;
          if (!length) {
            return;
          }
          series.sortByAngle(points, i - 0.5);
          if (distanceOption > 0) {
            top = Math.max(0, centerY - radius - distanceOption);
            bottom = Math.min(centerY + radius + distanceOption, chart.plotHeight);
            positions = map(points, function(point) {
              if (point.dataLabel) {
                size = point.dataLabel.getBBox().height || 21;
                return {
                  target: point.labelPos[1] - top + size / 2,
                  size: size,
                  rank: point.y
                };
              }
            });
            H.distribute(positions, bottom + size - top);
          }
          for (j = 0; j < length; j++) {
            point = points[j];
            labelPos = point.labelPos;
            dataLabel = point.dataLabel;
            visibility = point.visible === false ? 'hidden' : 'inherit';
            naturalY = labelPos[1];
            if (positions) {
              if (positions[j].pos === undefined) {
                visibility = 'hidden';
              } else {
                labelHeight = positions[j].size;
                y = top + positions[j].pos;
              }
            } else {
              y = naturalY;
            }
            if (options.justify) {
              x = seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption);
            } else {
              x = series.getX(y < top + 2 || y > bottom - 2 ? naturalY : y, i);
            }
            dataLabel._attr = {
              visibility: visibility,
              align: labelPos[6]
            };
            dataLabel._pos = {
              x: x + options.x +
                ({
                  left: connectorPadding,
                  right: -connectorPadding
                } [labelPos[6]] || 0),
              y: y + options.y - 10
            };
            labelPos.x = x;
            labelPos.y = y;
            if (series.options.size === null) {
              dataLabelWidth = dataLabel.width;
              if (x - dataLabelWidth < connectorPadding) {
                overflow[3] = Math.max(Math.round(dataLabelWidth - x + connectorPadding), overflow[3]);
              } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
                overflow[1] = Math.max(Math.round(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
              }
              if (y - labelHeight / 2 < 0) {
                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
              } else if (y + labelHeight / 2 > plotHeight) {
                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
              }
            }
          }
        });
        if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
          this.placeDataLabels();
          if (outside && connectorWidth) {
            each(this.points, function(point) {
              var isNew;
              connector = point.connector;
              dataLabel = point.dataLabel;
              if (dataLabel && dataLabel._pos && point.visible) {
                visibility = dataLabel._attr.visibility;
                isNew = !connector;
                if (isNew) {
                  point.connector = connector = chart.renderer.path()
                    .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)
                    .add(series.dataLabelsGroup);
                  connector.attr({
                    'stroke-width': connectorWidth,
                    'stroke': options.connectorColor || point.color || '#666666'
                  });
                }
                connector[isNew ? 'attr' : 'animate']({
                  d: series.connectorPath(point.labelPos)
                });
                connector.attr('visibility', visibility);
              } else if (connector) {
                point.connector = connector.destroy();
              }
            });
          }
        }
      };
      seriesTypes.pie.prototype.connectorPath = function(labelPos) {
        var x = labelPos.x,
          y = labelPos.y;
        return pick(this.options.dataLabels.softConnector, true) ? [
          'M',
          x + (labelPos[6] === 'left' ? 5 : -5), y,
          'C',
          x, y,
          2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
          labelPos[2], labelPos[3],
          'L',
          labelPos[4], labelPos[5]
        ] : [
          'M',
          x + (labelPos[6] === 'left' ? 5 : -5), y,
          'L',
          labelPos[2], labelPos[3],
          'L',
          labelPos[4], labelPos[5]
        ];
      };
      seriesTypes.pie.prototype.placeDataLabels = function() {
        each(this.points, function(point) {
          var dataLabel = point.dataLabel,
            _pos;
          if (dataLabel && point.visible) {
            _pos = dataLabel._pos;
            if (_pos) {
              dataLabel.attr(dataLabel._attr);
              dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
              dataLabel.moved = true;
            } else if (dataLabel) {
              dataLabel.attr({
                y: -9999
              });
            }
          }
        });
      };
      seriesTypes.pie.prototype.alignDataLabel = noop;
      seriesTypes.pie.prototype.verifyDataLabelOverflow = function(overflow) {
        var center = this.center,
          options = this.options,
          centerOption = options.center,
          minSize = options.minSize || 80,
          newSize = minSize,
          ret;
        if (centerOption[0] !== null) {
          newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
        } else {
          newSize = Math.max(
            center[2] - overflow[1] - overflow[3],
            minSize
          );
          center[0] += (overflow[3] - overflow[1]) / 2;
        }
        if (centerOption[1] !== null) {
          newSize = Math.max(Math.min(newSize, center[2] - Math.max(overflow[0], overflow[2])), minSize);
        } else {
          newSize = Math.max(
            Math.min(
              newSize,
              center[2] - overflow[0] - overflow[2]
            ),
            minSize
          );
          center[1] += (overflow[0] - overflow[2]) / 2;
        }
        if (newSize < center[2]) {
          center[2] = newSize;
          center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize);
          this.translate(center);
          if (this.drawDataLabels) {
            this.drawDataLabels();
          }
        } else {
          ret = true;
        }
        return ret;
      };
    }
    if (seriesTypes.column) {
      seriesTypes.column.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
        var inverted = this.chart.inverted,
          series = point.series,
          dlBox = point.dlBox || point.shapeArgs,
          below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)),
          inside = pick(options.inside, !!this.options.stacking),
          overshoot;
        if (dlBox) {
          alignTo = merge(dlBox);
          if (alignTo.y < 0) {
            alignTo.height += alignTo.y;
            alignTo.y = 0;
          }
          overshoot = alignTo.y + alignTo.height - series.yAxis.len;
          if (overshoot > 0) {
            alignTo.height -= overshoot;
          }
          if (inverted) {
            alignTo = {
              x: series.yAxis.len - alignTo.y - alignTo.height,
              y: series.xAxis.len - alignTo.x - alignTo.width,
              width: alignTo.height,
              height: alignTo.width
            };
          }
          if (!inside) {
            if (inverted) {
              alignTo.x += below ? 0 : alignTo.width;
              alignTo.width = 0;
            } else {
              alignTo.y += below ? alignTo.height : 0;
              alignTo.height = 0;
            }
          }
        }
        options.align = pick(
          options.align, !inverted || inside ? 'center' : below ? 'right' : 'left'
        );
        options.verticalAlign = pick(
          options.verticalAlign,
          inverted || inside ? 'middle' : below ? 'top' : 'bottom'
        );
        Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
      };
    }
  }(Highcharts));
  (function(H) {
    'use strict';
    var Chart = H.Chart,
      each = H.each,
      pick = H.pick,
      addEvent = H.addEvent;
    Chart.prototype.callbacks.push(function(chart) {
      function collectAndHide() {
        var labels = [];
        each(chart.series, function(series) {
          var dlOptions = series.options.dataLabels,
            collections = series.dataLabelCollections || ['dataLabel'];
          if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) {
            each(collections, function(coll) {
              each(series.points, function(point) {
                if (point[coll]) {
                  point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height);
                  labels.push(point[coll]);
                }
              });
            });
          }
        });
        chart.hideOverlappingLabels(labels);
      }
      collectAndHide();
      addEvent(chart, 'redraw', collectAndHide);
    });
    Chart.prototype.hideOverlappingLabels = function(labels) {
      var len = labels.length,
        label,
        i,
        j,
        label1,
        label2,
        isIntersecting,
        pos1,
        pos2,
        parent1,
        parent2,
        padding,
        intersectRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {
          return !(
            x2 > x1 + w1 ||
            x2 + w2 < x1 ||
            y2 > y1 + h1 ||
            y2 + h2 < y1
          );
        };
      for (i = 0; i < len; i++) {
        label = labels[i];
        if (label) {
          label.oldOpacity = label.opacity;
          label.newOpacity = 1;
        }
      }
      labels.sort(function(a, b) {
        return (b.labelrank || 0) - (a.labelrank || 0);
      });
      for (i = 0; i < len; i++) {
        label1 = labels[i];
        for (j = i + 1; j < len; ++j) {
          label2 = labels[j];
          if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
            pos1 = label1.alignAttr;
            pos2 = label2.alignAttr;
            parent1 = label1.parentGroup;
            parent2 = label2.parentGroup;
            padding = 2 * (label1.box ? 0 : label1.padding);
            isIntersecting = intersectRect(
              pos1.x + parent1.translateX,
              pos1.y + parent1.translateY,
              label1.width - padding,
              label1.height - padding,
              pos2.x + parent2.translateX,
              pos2.y + parent2.translateY,
              label2.width - padding,
              label2.height - padding
            );
            if (isIntersecting) {
              (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
            }
          }
        }
      }
      each(labels, function(label) {
        var complete,
          newOpacity;
        if (label) {
          newOpacity = label.newOpacity;
          if (label.oldOpacity !== newOpacity && label.placed) {
            if (newOpacity) {
              label.show(true);
            } else {
              complete = function() {
                label.hide();
              };
            }
            label.alignAttr.opacity = newOpacity;
            label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
          }
          label.isOld = true;
        }
      });
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      Chart = H.Chart,
      createElement = H.createElement,
      css = H.css,
      defaultOptions = H.defaultOptions,
      defaultPlotOptions = H.defaultPlotOptions,
      each = H.each,
      extend = H.extend,
      fireEvent = H.fireEvent,
      hasTouch = H.hasTouch,
      inArray = H.inArray,
      isObject = H.isObject,
      Legend = H.Legend,
      merge = H.merge,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      svg = H.svg,
      TrackerMixin;
    TrackerMixin = H.TrackerMixin = {
      drawTrackerPoint: function() {
        var series = this,
          chart = series.chart,
          pointer = chart.pointer,
          onMouseOver = function(e) {
            var target = e.target,
              point;
            while (target && !point) {
              point = target.point;
              target = target.parentNode;
            }
            if (point !== undefined && point !== chart.hoverPoint) {
              point.onMouseOver(e);
            }
          };
        each(series.points, function(point) {
          if (point.graphic) {
            point.graphic.element.point = point;
          }
          if (point.dataLabel) {
            if (point.dataLabel.div) {
              point.dataLabel.div.point = point;
            } else {
              point.dataLabel.element.point = point;
            }
          }
        });
        if (!series._hasTracking) {
          each(series.trackerGroups, function(key) {
            if (series[key]) {
              series[key]
                .addClass('highcharts-tracker')
                .on('mouseover', onMouseOver)
                .on('mouseout', function(e) {
                  pointer.onTrackerMouseOut(e);
                });
              if (hasTouch) {
                series[key].on('touchstart', onMouseOver);
              }
              if (series.options.cursor) {
                series[key]
                  .css(css)
                  .css({
                    cursor: series.options.cursor
                  });
              }
            }
          });
          series._hasTracking = true;
        }
      },
      drawTrackerGraph: function() {
        var series = this,
          options = series.options,
          trackByArea = options.trackByArea,
          trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
          trackerPathLength = trackerPath.length,
          chart = series.chart,
          pointer = chart.pointer,
          renderer = chart.renderer,
          snap = chart.options.tooltip.snap,
          tracker = series.tracker,
          i,
          onMouseOver = function() {
            if (chart.hoverSeries !== series) {
              series.onMouseOver();
            }
          },
          TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';
        if (trackerPathLength && !trackByArea) {
          i = trackerPathLength + 1;
          while (i--) {
            if (trackerPath[i] === 'M') {
              trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');
            }
            if ((i && trackerPath[i] === 'M') || i === trackerPathLength) {
              trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);
            }
          }
        }
        if (tracker) {
          tracker.attr({
            d: trackerPath
          });
        } else if (series.graph) {
          series.tracker = renderer.path(trackerPath)
            .attr({
              'stroke-linejoin': 'round',
              visibility: series.visible ? 'visible' : 'hidden',
              stroke: TRACKER_FILL,
              fill: trackByArea ? TRACKER_FILL : 'none',
              'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),
              zIndex: 2
            })
            .add(series.group);
          each([series.tracker, series.markerGroup], function(tracker) {
            tracker.addClass('highcharts-tracker')
              .on('mouseover', onMouseOver)
              .on('mouseout', function(e) {
                pointer.onTrackerMouseOut(e);
              });
            if (options.cursor) {
              tracker.css({
                cursor: options.cursor
              });
            }
            if (hasTouch) {
              tracker.on('touchstart', onMouseOver);
            }
          });
        }
      }
    };
    if (seriesTypes.column) {
      seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }
    if (seriesTypes.pie) {
      seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }
    if (seriesTypes.scatter) {
      seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }
    extend(Legend.prototype, {
      setItemEvents: function(item, legendItem, useHTML) {
        var legend = this,
          chart = legend.chart,
          activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';
        (useHTML ? legendItem : item.legendGroup).on('mouseover', function() {
            item.setState('hover');
            chart.seriesGroup.addClass(activeClass);
            legendItem.css(legend.options.itemHoverStyle);
          })
          .on('mouseout', function() {
            legendItem.css(item.visible ? legend.itemStyle : legend.itemHiddenStyle);
            chart.seriesGroup.removeClass(activeClass);
            item.setState();
          })
          .on('click', function(event) {
            var strLegendItemClick = 'legendItemClick',
              fnLegendItemClick = function() {
                if (item.setVisible) {
                  item.setVisible();
                }
              };
            event = {
              browserEvent: event
            };
            if (item.firePointEvent) {
              item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
            } else {
              fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
            }
          });
      },
      createCheckboxForItem: function(item) {
        var legend = this;
        item.checkbox = createElement('input', {
          type: 'checkbox',
          checked: item.selected,
          defaultChecked: item.selected
        }, legend.options.itemCheckboxStyle, legend.chart.container);
        addEvent(item.checkbox, 'click', function(event) {
          var target = event.target;
          fireEvent(
            item.series || item,
            'checkboxClick', {
              checked: target.checked,
              item: item
            },
            function() {
              item.select();
            }
          );
        });
      }
    });
    defaultOptions.legend.itemStyle.cursor = 'pointer';
    extend(Chart.prototype, {
      showResetZoom: function() {
        var chart = this,
          lang = defaultOptions.lang,
          btnOptions = chart.options.chart.resetZoomButton,
          theme = btnOptions.theme,
          states = theme.states,
          alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

        function zoomOut() {
          chart.zoomOut();
        }
        this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
          .attr({
            align: btnOptions.position.align,
            title: lang.resetZoomTitle
          })
          .addClass('highcharts-reset-zoom')
          .add()
          .align(btnOptions.position, false, alignTo);
      },
      zoomOut: function() {
        var chart = this;
        fireEvent(chart, 'selection', {
          resetSelection: true
        }, function() {
          chart.zoom();
        });
      },
      zoom: function(event) {
        var chart = this,
          hasZoomed,
          pointer = chart.pointer,
          displayButton = false,
          resetZoomButton;
        if (!event || event.resetSelection) {
          each(chart.axes, function(axis) {
            hasZoomed = axis.zoom();
          });
        } else {
          each(event.xAxis.concat(event.yAxis), function(axisData) {
            var axis = axisData.axis,
              isXAxis = axis.isXAxis;
            if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
              hasZoomed = axis.zoom(axisData.min, axisData.max);
              if (axis.displayBtn) {
                displayButton = true;
              }
            }
          });
        }
        resetZoomButton = chart.resetZoomButton;
        if (displayButton && !resetZoomButton) {
          chart.showResetZoom();
        } else if (!displayButton && isObject(resetZoomButton)) {
          chart.resetZoomButton = resetZoomButton.destroy();
        }
        if (hasZoomed) {
          chart.redraw(
            pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100)
          );
        }
      },
      pan: function(e, panning) {
        var chart = this,
          hoverPoints = chart.hoverPoints,
          doRedraw;
        if (hoverPoints) {
          each(hoverPoints, function(point) {
            point.setState();
          });
        }
        each(panning === 'xy' ? [1, 0] : [1], function(isX) {
          var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
            horiz = axis.horiz,
            mousePos = e[horiz ? 'chartX' : 'chartY'],
            mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
            startPos = chart[mouseDown],
            halfPointRange = (axis.pointRange || 0) / 2,
            extremes = axis.getExtremes(),
            panMin = axis.toValue(startPos - mousePos, true) +
            halfPointRange,
            panMax = axis.toValue(startPos + axis.len - mousePos, true) -
            halfPointRange,
            flipped = panMax < panMin,
            newMin = flipped ? panMax : panMin,
            newMax = flipped ? panMin : panMax,
            distMin = Math.min(extremes.dataMin, extremes.min) - newMin,
            distMax = newMax - Math.max(extremes.dataMax, extremes.max);
          if (axis.series.length && distMin < 0 && distMax < 0) {
            axis.setExtremes(
              newMin,
              newMax,
              false,
              false, {
                trigger: 'pan'
              }
            );
            doRedraw = true;
          }
          chart[mouseDown] = mousePos;
        });
        if (doRedraw) {
          chart.redraw(false);
        }
        css(chart.container, {
          cursor: 'move'
        });
      }
    });
    extend(Point.prototype, {
      select: function(selected, accumulate) {
        var point = this,
          series = point.series,
          chart = series.chart;
        selected = pick(selected, !point.selected);
        point.firePointEvent(selected ? 'select' : 'unselect', {
          accumulate: accumulate
        }, function() {
          point.selected = point.options.selected = selected;
          series.options.data[inArray(point, series.data)] = point.options;
          point.setState(selected && 'select');
          if (!accumulate) {
            each(chart.getSelectedPoints(), function(loopPoint) {
              if (loopPoint.selected && loopPoint !== point) {
                loopPoint.selected = loopPoint.options.selected = false;
                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                loopPoint.setState('');
                loopPoint.firePointEvent('unselect');
              }
            });
          }
        });
      },
      onMouseOver: function(e, byProximity) {
        var point = this,
          series = point.series,
          chart = series.chart,
          tooltip = chart.tooltip,
          hoverPoint = chart.hoverPoint;
        if (point.series) {
          if (!byProximity) {
            if (hoverPoint && hoverPoint !== point) {
              hoverPoint.onMouseOut();
            }
            if (chart.hoverSeries !== series) {
              series.onMouseOver();
            }
            chart.hoverPoint = point;
          }
          if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
            point.setState('hover');
            tooltip.refresh(point, e);
          } else if (!tooltip) {
            point.setState('hover');
          }
          point.firePointEvent('mouseOver');
        }
      },
      onMouseOut: function() {
        var chart = this.series.chart,
          hoverPoints = chart.hoverPoints;
        this.firePointEvent('mouseOut');
        if (!hoverPoints || inArray(this, hoverPoints) === -1) {
          this.setState();
          chart.hoverPoint = null;
        }
      },
      importEvents: function() {
        if (!this.hasImportedEvents) {
          var point = this,
            options = merge(point.series.options.point, point.options),
            events = options.events,
            eventType;
          point.events = events;
          for (eventType in events) {
            addEvent(point, eventType, events[eventType]);
          }
          this.hasImportedEvents = true;
        }
      },
      setState: function(state, move) {
        var point = this,
          plotX = Math.floor(point.plotX),
          plotY = point.plotY,
          series = point.series,
          stateOptions = series.options.states[state] || {},
          markerOptions = defaultPlotOptions[series.type].marker &&
          series.options.marker,
          normalDisabled = markerOptions && markerOptions.enabled === false,
          markerStateOptions = (markerOptions && markerOptions.states &&
            markerOptions.states[state]) || {},
          stateDisabled = markerStateOptions.enabled === false,
          stateMarkerGraphic = series.stateMarkerGraphic,
          pointMarker = point.marker || {},
          chart = series.chart,
          halo = series.halo,
          haloOptions,
          markerAttribs,
          hasMarkers = markerOptions && series.markerAttribs,
          newSymbol;
        state = state || '';
        if (
          (state === point.state && !move) ||
          (point.selected && state !== 'select') ||
          (stateOptions.enabled === false) ||
          (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
          (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false)
        ) {
          return;
        }
        if (hasMarkers) {
          markerAttribs = series.markerAttribs(point, state);
        }
        if (point.graphic) {
          if (point.state) {
            point.graphic.removeClass('highcharts-point-' + point.state);
          }
          if (state) {
            point.graphic.addClass('highcharts-point-' + state);
          }
          point.graphic.attr(series.pointAttribs(point, state));
          if (markerAttribs) {
            point.graphic.animate(
              markerAttribs,
              pick(
                chart.options.chart.animation,
                markerStateOptions.animation,
                markerOptions.animation
              )
            );
          }
          if (stateMarkerGraphic) {
            stateMarkerGraphic.hide();
          }
        } else {
          if (state && markerStateOptions) {
            newSymbol = pointMarker.symbol || series.symbol;
            if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
              stateMarkerGraphic = stateMarkerGraphic.destroy();
            }
            if (!stateMarkerGraphic) {
              if (newSymbol) {
                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
                    newSymbol,
                    markerAttribs.x,
                    markerAttribs.y,
                    markerAttribs.width,
                    markerAttribs.height
                  )
                  .add(series.markerGroup);
                stateMarkerGraphic.currentSymbol = newSymbol;
              }
            } else {
              stateMarkerGraphic[move ? 'animate' : 'attr']({
                x: markerAttribs.x,
                y: markerAttribs.y
              });
            }
            if (stateMarkerGraphic) {
              stateMarkerGraphic.attr(series.pointAttribs(point, state));
            }
          }
          if (stateMarkerGraphic) {
            stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide']();
            stateMarkerGraphic.element.point = point;
          }
        }
        haloOptions = stateOptions.halo;
        if (haloOptions && haloOptions.size) {
          if (!halo) {
            series.halo = halo = chart.renderer.path()
              .add(hasMarkers ? series.markerGroup : series.group);
          }
          halo[move ? 'animate' : 'attr']({
            d: point.haloPath(haloOptions.size)
          });
          halo.attr({
            'class': 'highcharts-halo highcharts-color-' +
              pick(point.colorIndex, series.colorIndex)
          });
          halo.point = point;
          halo.attr(extend({
            'fill': point.color || series.color,
            'fill-opacity': haloOptions.opacity,
            'zIndex': -1
          }, haloOptions.attributes));
        } else if (halo && halo.point && halo.point.haloPath) {
          halo.animate({
            d: halo.point.haloPath(0)
          });
        }
        point.state = state;
      },
      haloPath: function(size) {
        var series = this.series,
          chart = series.chart;
        return chart.renderer.symbols.circle(
          Math.floor(this.plotX) - size,
          this.plotY - size,
          size * 2,
          size * 2
        );
      }
    });
    extend(Series.prototype, {
      onMouseOver: function() {
        var series = this,
          chart = series.chart,
          hoverSeries = chart.hoverSeries;
        if (hoverSeries && hoverSeries !== series) {
          hoverSeries.onMouseOut();
        }
        if (series.options.events.mouseOver) {
          fireEvent(series, 'mouseOver');
        }
        series.setState('hover');
        chart.hoverSeries = series;
      },
      onMouseOut: function() {
        var series = this,
          options = series.options,
          chart = series.chart,
          tooltip = chart.tooltip,
          hoverPoint = chart.hoverPoint;
        chart.hoverSeries = null;
        if (hoverPoint) {
          hoverPoint.onMouseOut();
        }
        if (series && options.events.mouseOut) {
          fireEvent(series, 'mouseOut');
        }
        if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
          tooltip.hide();
        }
        series.setState();
      },
      setState: function(state) {
        var series = this,
          options = series.options,
          graph = series.graph,
          stateOptions = options.states,
          lineWidth = options.lineWidth,
          attribs,
          i = 0;
        state = state || '';
        if (series.state !== state) {
          each([series.group, series.markerGroup], function(group) {
            if (group) {
              if (series.state) {
                group.removeClass('highcharts-series-' + series.state);
              }
              if (state) {
                group.addClass('highcharts-series-' + state);
              }
            }
          });
          series.state = state;
          if (stateOptions[state] && stateOptions[state].enabled === false) {
            return;
          }
          if (state) {
            lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
          }
          if (graph && !graph.dashstyle) {
            attribs = {
              'stroke-width': lineWidth
            };
            graph.attr(attribs);
            while (series['zone-graph-' + i]) {
              series['zone-graph-' + i].attr(attribs);
              i = i + 1;
            }
          }
        }
      },
      setVisible: function(vis, redraw) {
        var series = this,
          chart = series.chart,
          legendItem = series.legendItem,
          showOrHide,
          ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
          oldVisibility = series.visible;
        series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis;
        showOrHide = vis ? 'show' : 'hide';
        each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function(key) {
          if (series[key]) {
            series[key][showOrHide]();
          }
        });
        if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
          series.onMouseOut();
        }
        if (legendItem) {
          chart.legend.colorizeItem(series, vis);
        }
        series.isDirty = true;
        if (series.options.stacking) {
          each(chart.series, function(otherSeries) {
            if (otherSeries.options.stacking && otherSeries.visible) {
              otherSeries.isDirty = true;
            }
          });
        }
        each(series.linkedSeries, function(otherSeries) {
          otherSeries.setVisible(vis, false);
        });
        if (ignoreHiddenSeries) {
          chart.isDirtyBox = true;
        }
        if (redraw !== false) {
          chart.redraw();
        }
        fireEvent(series, showOrHide);
      },
      show: function() {
        this.setVisible(true);
      },
      hide: function() {
        this.setVisible(false);
      },
      select: function(selected) {
        var series = this;
        series.selected = selected = (selected === undefined) ? !series.selected : selected;
        if (series.checkbox) {
          series.checkbox.checked = selected;
        }
        fireEvent(series, selected ? 'select' : 'unselect');
      },
      drawTracker: TrackerMixin.drawTrackerGraph
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var Chart = H.Chart,
      each = H.each,
      inArray = H.inArray,
      isObject = H.isObject,
      pick = H.pick,
      splat = H.splat;
    Chart.prototype.setResponsive = function(redraw) {
      var options = this.options.responsive;
      if (options && options.rules) {
        each(options.rules, function(rule) {
          this.matchResponsiveRule(rule, redraw);
        }, this);
      }
    };
    Chart.prototype.matchResponsiveRule = function(rule, redraw) {
      var respRules = this.respRules,
        condition = rule.condition,
        matches,
        fn = condition.callback || function() {
          return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&
            this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&
            this.chartWidth >= pick(condition.minWidth, 0) &&
            this.chartHeight >= pick(condition.minHeight, 0);
        };
      if (rule._id === undefined) {
        rule._id = H.uniqueKey();
      }
      matches = fn.call(this);
      if (!respRules[rule._id] && matches) {
        if (rule.chartOptions) {
          respRules[rule._id] = this.currentOptions(rule.chartOptions);
          this.update(rule.chartOptions, redraw);
        }
      } else if (respRules[rule._id] && !matches) {
        this.update(respRules[rule._id], redraw);
        delete respRules[rule._id];
      }
    };
    Chart.prototype.currentOptions = function(options) {
      var ret = {};

      function getCurrent(options, curr, ret, depth) {
        var key, i;
        for (key in options) {
          if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {
            options[key] = splat(options[key]);
            ret[key] = [];
            for (i = 0; i < options[key].length; i++) {
              ret[key][i] = {};
              getCurrent(
                options[key][i],
                curr[key][i],
                ret[key][i],
                depth + 1
              );
            }
          } else if (isObject(options[key])) {
            ret[key] = {};
            getCurrent(
              options[key],
              curr[key] || {},
              ret[key],
              depth + 1
            );
          } else {
            ret[key] = curr[key] || null;
          }
        }
      }
      getCurrent(options, this.options, ret, 0);
      return ret;
    };
  }(Highcharts));
  var Highcharts = (function(Highcharts) {
    'use strict';
    return Highcharts;
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      Axis = H.Axis,
      Chart = H.Chart,
      css = H.css,
      dateFormat = H.dateFormat,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      noop = H.noop,
      Series = H.Series,
      timeUnits = H.timeUnits,
      wrap = H.wrap;
    wrap(Series.prototype, 'init', function(proceed) {
      var series = this,
        xAxis;
      proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      xAxis = series.xAxis;
      if (xAxis && xAxis.options.ordinal) {
        addEvent(series, 'updatedData', function() {
          delete xAxis.ordinalIndex;
        });
      }
    });
    wrap(Axis.prototype, 'getTimeTicks', function(proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
      var start = 0,
        end,
        segmentPositions,
        higherRanks = {},
        hasCrossedHigherRank,
        info,
        posLength,
        outsideMax,
        groupPositions = [],
        lastGroupPosition = -Number.MAX_VALUE,
        tickPixelIntervalOption = this.options.tickPixelInterval;
      if ((!this.options.ordinal && !this.options.breaks) || !positions || positions.length < 3 || min === undefined) {
        return proceed.call(this, normalizedInterval, min, max, startOfWeek);
      }
      posLength = positions.length;
      for (end = 0; end < posLength; end++) {
        outsideMax = end && positions[end - 1] > max;
        if (positions[end] < min) {
          start = end;
        }
        if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
          if (positions[end] > lastGroupPosition) {
            segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);
            while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
              segmentPositions.shift();
            }
            if (segmentPositions.length) {
              lastGroupPosition = segmentPositions[segmentPositions.length - 1];
            }
            groupPositions = groupPositions.concat(segmentPositions);
          }
          start = end + 1;
        }
        if (outsideMax) {
          break;
        }
      }
      info = segmentPositions.info;
      if (findHigherRanks && info.unitRange <= timeUnits.hour) {
        end = groupPositions.length - 1;
        for (start = 1; start < end; start++) {
          if (dateFormat('%d', groupPositions[start]) !== dateFormat('%d', groupPositions[start - 1])) {
            higherRanks[groupPositions[start]] = 'day';
            hasCrossedHigherRank = true;
          }
        }
        if (hasCrossedHigherRank) {
          higherRanks[groupPositions[0]] = 'day';
        }
        info.higherRanks = higherRanks;
      }
      groupPositions.info = info;
      if (findHigherRanks && defined(tickPixelIntervalOption)) {
        var length = groupPositions.length,
          i = length,
          itemToRemove,
          translated,
          translatedArr = [],
          lastTranslated,
          medianDistance,
          distance,
          distances = [];
        while (i--) {
          translated = this.translate(groupPositions[i]);
          if (lastTranslated) {
            distances[i] = lastTranslated - translated;
          }
          translatedArr[i] = lastTranslated = translated;
        }
        distances.sort();
        medianDistance = distances[Math.floor(distances.length / 2)];
        if (medianDistance < tickPixelIntervalOption * 0.6) {
          medianDistance = null;
        }
        i = groupPositions[length - 1] > max ? length - 1 : length;
        lastTranslated = undefined;
        while (i--) {
          translated = translatedArr[i];
          distance = Math.abs(lastTranslated - translated);
          if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&
            (medianDistance === null || distance < medianDistance * 0.8)) {
            if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
              itemToRemove = i + 1;
              lastTranslated = translated;
            } else {
              itemToRemove = i;
            }
            groupPositions.splice(itemToRemove, 1);
          } else {
            lastTranslated = translated;
          }
        }
      }
      return groupPositions;
    });
    extend(Axis.prototype, {
      beforeSetTickPositions: function() {
        var axis = this,
          len,
          ordinalPositions = [],
          useOrdinal = false,
          dist,
          extremes = axis.getExtremes(),
          min = extremes.min,
          max = extremes.max,
          minIndex,
          maxIndex,
          slope,
          hasBreaks = axis.isXAxis && !!axis.options.breaks,
          isOrdinal = axis.options.ordinal,
          ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,
          i;
        if (isOrdinal || hasBreaks) {
          each(axis.series, function(series, i) {
            if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {
              ordinalPositions = ordinalPositions.concat(series.processedXData);
              len = ordinalPositions.length;
              ordinalPositions.sort(function(a, b) {
                return a - b;
              });
              if (len) {
                i = len - 1;
                while (i--) {
                  if (ordinalPositions[i] === ordinalPositions[i + 1]) {
                    ordinalPositions.splice(i, 1);
                  }
                }
              }
            }
          });
          len = ordinalPositions.length;
          if (len > 2) {
            dist = ordinalPositions[1] - ordinalPositions[0];
            i = len - 1;
            while (i-- && !useOrdinal) {
              if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
                useOrdinal = true;
              }
            }
            if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
              useOrdinal = true;
            }
          }
          if (useOrdinal) {
            axis.ordinalPositions = ordinalPositions;
            minIndex = axis.ordinal2lin(
              Math.max(
                min,
                ordinalPositions[0]
              ),
              true
            );
            maxIndex = Math.max(axis.ordinal2lin(
              Math.min(
                max,
                ordinalPositions[ordinalPositions.length - 1]
              ),
              true
            ), 1);
            axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
            axis.ordinalOffset = min - (minIndex * slope);
          } else {
            axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = undefined;
          }
        }
        axis.isOrdinal = isOrdinal && useOrdinal;
        axis.groupIntervalFactor = null;
      },
      val2lin: function(val, toIndex) {
        var axis = this,
          ordinalPositions = axis.ordinalPositions,
          ret;
        if (!ordinalPositions) {
          ret = val;
        } else {
          var ordinalLength = ordinalPositions.length,
            i,
            distance,
            ordinalIndex;
          i = ordinalLength;
          while (i--) {
            if (ordinalPositions[i] === val) {
              ordinalIndex = i;
              break;
            }
          }
          i = ordinalLength - 1;
          while (i--) {
            if (val > ordinalPositions[i] || i === 0) {
              distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]);
              ordinalIndex = i + distance;
              break;
            }
          }
          ret = toIndex ?
            ordinalIndex :
            axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
        }
        return ret;
      },
      lin2val: function(val, fromIndex) {
        var axis = this,
          ordinalPositions = axis.ordinalPositions,
          ret;
        if (!ordinalPositions) {
          ret = val;
        } else {
          var ordinalSlope = axis.ordinalSlope,
            ordinalOffset = axis.ordinalOffset,
            i = ordinalPositions.length - 1,
            linearEquivalentLeft,
            linearEquivalentRight,
            distance;
          if (fromIndex) {
            if (val < 0) {
              val = ordinalPositions[0];
            } else if (val > i) {
              val = ordinalPositions[i];
            } else {
              i = Math.floor(val);
              distance = val - i;
            }
          } else {
            while (i--) {
              linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
              if (val >= linearEquivalentLeft) {
                linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
                distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft);
                break;
              }
            }
          }
          return distance !== undefined && ordinalPositions[i] !== undefined ?
            ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :
            val;
        }
        return ret;
      },
      getExtendedPositions: function() {
        var axis = this,
          chart = axis.chart,
          grouping = axis.series[0].currentDataGrouping,
          ordinalIndex = axis.ordinalIndex,
          key = grouping ? grouping.count + grouping.unitName : 'raw',
          extremes = axis.getExtremes(),
          fakeAxis,
          fakeSeries;
        if (!ordinalIndex) {
          ordinalIndex = axis.ordinalIndex = {};
        }
        if (!ordinalIndex[key]) {
          fakeAxis = {
            series: [],
            chart: chart,
            getExtremes: function() {
              return {
                min: extremes.dataMin,
                max: extremes.dataMax
              };
            },
            options: {
              ordinal: true
            },
            val2lin: Axis.prototype.val2lin
          };
          each(axis.series, function(series) {
            fakeSeries = {
              xAxis: fakeAxis,
              xData: series.xData,
              chart: chart,
              destroyGroupedData: noop
            };
            fakeSeries.options = {
              dataGrouping: grouping ? {
                enabled: true,
                forced: true,
                approximation: 'open',
                units: [
                  [grouping.unitName, [grouping.count]]
                ]
              } : {
                enabled: false
              }
            };
            series.processData.apply(fakeSeries);
            fakeAxis.series.push(fakeSeries);
          });
          axis.beforeSetTickPositions.apply(fakeAxis);
          ordinalIndex[key] = fakeAxis.ordinalPositions;
        }
        return ordinalIndex[key];
      },
      getGroupIntervalFactor: function(xMin, xMax, series) {
        var i,
          processedXData = series.processedXData,
          len = processedXData.length,
          distances = [],
          median,
          groupIntervalFactor = this.groupIntervalFactor;
        if (!groupIntervalFactor) {
          for (i = 0; i < len - 1; i++) {
            distances[i] = processedXData[i + 1] - processedXData[i];
          }
          distances.sort(function(a, b) {
            return a - b;
          });
          median = distances[Math.floor(len / 2)];
          xMin = Math.max(xMin, processedXData[0]);
          xMax = Math.min(xMax, processedXData[len - 1]);
          this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);
        }
        return groupIntervalFactor;
      },
      postProcessTickInterval: function(tickInterval) {
        var ordinalSlope = this.ordinalSlope,
          ret;
        if (ordinalSlope) {
          if (!this.options.breaks) {
            ret = tickInterval / (ordinalSlope / this.closestPointRange);
          } else {
            ret = this.closestPointRange;
          }
        } else {
          ret = tickInterval;
        }
        return ret;
      }
    });
    Axis.prototype.ordinal2lin = Axis.prototype.val2lin;
    wrap(Chart.prototype, 'pan', function(proceed, e) {
      var chart = this,
        xAxis = chart.xAxis[0],
        chartX = e.chartX,
        runBase = false;
      if (xAxis.options.ordinal && xAxis.series.length) {
        var mouseDownX = chart.mouseDownX,
          extremes = xAxis.getExtremes(),
          dataMax = extremes.dataMax,
          min = extremes.min,
          max = extremes.max,
          trimmedRange,
          hoverPoints = chart.hoverPoints,
          closestPointRange = xAxis.closestPointRange,
          pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
          movedUnits = (mouseDownX - chartX) / pointPixelWidth,
          extendedAxis = {
            ordinalPositions: xAxis.getExtendedPositions()
          },
          ordinalPositions,
          searchAxisLeft,
          lin2val = xAxis.lin2val,
          val2lin = xAxis.val2lin,
          searchAxisRight;
        if (!extendedAxis.ordinalPositions) {
          runBase = true;
        } else if (Math.abs(movedUnits) > 1) {
          if (hoverPoints) {
            each(hoverPoints, function(point) {
              point.setState();
            });
          }
          if (movedUnits < 0) {
            searchAxisLeft = extendedAxis;
            searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
          } else {
            searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
            searchAxisRight = extendedAxis;
          }
          ordinalPositions = searchAxisRight.ordinalPositions;
          if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
            ordinalPositions.push(dataMax);
          }
          chart.fixedRange = max - min;
          trimmedRange = xAxis.toFixedRange(null, null,
            lin2val.apply(searchAxisLeft, [
              val2lin.apply(searchAxisLeft, [min, true]) + movedUnits,
              true
            ]),
            lin2val.apply(searchAxisRight, [
              val2lin.apply(searchAxisRight, [max, true]) + movedUnits,
              true
            ])
          );
          if (trimmedRange.min >= Math.min(extremes.dataMin, min) && trimmedRange.max <= Math.max(dataMax, max)) {
            xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, {
              trigger: 'pan'
            });
          }
          chart.mouseDownX = chartX;
          css(chart.container, {
            cursor: 'move'
          });
        }
      } else {
        runBase = true;
      }
      if (runBase) {
        proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      }
    });
    Series.prototype.gappedPath = function() {
      var gapSize = this.options.gapSize,
        points = this.points.slice(),
        i = points.length - 1;
      if (gapSize && i > 0) {
        while (i--) {
          if (points[i + 1].x - points[i].x > this.closestPointRange * gapSize) {
            points.splice(
              i + 1,
              0, {
                isNull: true
              }
            );
          }
        }
      }
      return this.getGraphPath(points);
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var pick = H.pick,
      wrap = H.wrap,
      each = H.each,
      extend = H.extend,
      isArray = H.isArray,
      fireEvent = H.fireEvent,
      Axis = H.Axis,
      Series = H.Series;

    function stripArguments() {
      return Array.prototype.slice.call(arguments, 1);
    }
    extend(Axis.prototype, {
      isInBreak: function(brk, val) {
        var ret,
          repeat = brk.repeat || Infinity,
          from = brk.from,
          length = brk.to - brk.from,
          test = (val >= from ? (val - from) % repeat : repeat - ((from - val) % repeat));
        if (!brk.inclusive) {
          ret = test < length && test !== 0;
        } else {
          ret = test <= length;
        }
        return ret;
      },
      isInAnyBreak: function(val, testKeep) {
        var breaks = this.options.breaks,
          i = breaks && breaks.length,
          inbrk,
          keep,
          ret;
        if (i) {
          while (i--) {
            if (this.isInBreak(breaks[i], val)) {
              inbrk = true;
              if (!keep) {
                keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);
              }
            }
          }
          if (inbrk && testKeep) {
            ret = inbrk && !keep;
          } else {
            ret = inbrk;
          }
        }
        return ret;
      }
    });
    wrap(Axis.prototype, 'setTickPositions', function(proceed) {
      proceed.apply(this, Array.prototype.slice.call(arguments, 1));
      if (this.options.breaks) {
        var axis = this,
          tickPositions = this.tickPositions,
          info = this.tickPositions.info,
          newPositions = [],
          i;
        for (i = 0; i < tickPositions.length; i++) {
          if (!axis.isInAnyBreak(tickPositions[i])) {
            newPositions.push(tickPositions[i]);
          }
        }
        this.tickPositions = newPositions;
        this.tickPositions.info = info;
      }
    });
    wrap(Axis.prototype, 'init', function(proceed, chart, userOptions) {
      var axis = this,
        breaks;
      if (userOptions.breaks && userOptions.breaks.length) {
        userOptions.ordinal = false;
      }
      proceed.call(this, chart, userOptions);
      breaks = this.options.breaks;
      axis.isBroken = (isArray(breaks) && !!breaks.length);
      if (axis.isBroken) {
        axis.val2lin = function(val) {
          var nval = val,
            brk,
            i;
          for (i = 0; i < axis.breakArray.length; i++) {
            brk = axis.breakArray[i];
            if (brk.to <= val) {
              nval -= brk.len;
            } else if (brk.from >= val) {
              break;
            } else if (axis.isInBreak(brk, val)) {
              nval -= (val - brk.from);
              break;
            }
          }
          return nval;
        };
        axis.lin2val = function(val) {
          var nval = val,
            brk,
            i;
          for (i = 0; i < axis.breakArray.length; i++) {
            brk = axis.breakArray[i];
            if (brk.from >= nval) {
              break;
            } else if (brk.to < nval) {
              nval += brk.len;
            } else if (axis.isInBreak(brk, nval)) {
              nval += brk.len;
            }
          }
          return nval;
        };
        axis.setExtremes = function(newMin, newMax, redraw, animation, eventArguments) {
          while (this.isInAnyBreak(newMin)) {
            newMin -= this.closestPointRange;
          }
          while (this.isInAnyBreak(newMax)) {
            newMax -= this.closestPointRange;
          }
          Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);
        };
        axis.setAxisTranslation = function(saveOld) {
          Axis.prototype.setAxisTranslation.call(this, saveOld);
          var breaks = axis.options.breaks,
            breakArrayT = [],
            breakArray = [],
            length = 0,
            inBrk,
            repeat,
            brk,
            min = axis.userMin || axis.min,
            max = axis.userMax || axis.max,
            start,
            i,
            j;
          for (i in breaks) {
            brk = breaks[i];
            repeat = brk.repeat || Infinity;
            if (axis.isInBreak(brk, min)) {
              min += (brk.to % repeat) - (min % repeat);
            }
            if (axis.isInBreak(brk, max)) {
              max -= (max % repeat) - (brk.from % repeat);
            }
          }
          for (i in breaks) {
            brk = breaks[i];
            start = brk.from;
            repeat = brk.repeat || Infinity;
            while (start - repeat > min) {
              start -= repeat;
            }
            while (start < min) {
              start += repeat;
            }
            for (j = start; j < max; j += repeat) {
              breakArrayT.push({
                value: j,
                move: 'in'
              });
              breakArrayT.push({
                value: j + (brk.to - brk.from),
                move: 'out',
                size: brk.breakSize
              });
            }
          }
          breakArrayT.sort(function(a, b) {
            var ret;
            if (a.value === b.value) {
              ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);
            } else {
              ret = a.value - b.value;
            }
            return ret;
          });
          inBrk = 0;
          start = min;
          for (i in breakArrayT) {
            brk = breakArrayT[i];
            inBrk += (brk.move === 'in' ? 1 : -1);
            if (inBrk === 1 && brk.move === 'in') {
              start = brk.value;
            }
            if (inBrk === 0) {
              breakArray.push({
                from: start,
                to: brk.value,
                len: brk.value - start - (brk.size || 0)
              });
              length += brk.value - start - (brk.size || 0);
            }
          }
          axis.breakArray = breakArray;
          fireEvent(axis, 'afterBreaks');
          axis.transA *= ((max - axis.min) / (max - min - length));
          axis.min = min;
          axis.max = max;
        };
      }
    });
    wrap(Series.prototype, 'generatePoints', function(proceed) {
      proceed.apply(this, stripArguments(arguments));
      var series = this,
        xAxis = series.xAxis,
        yAxis = series.yAxis,
        points = series.points,
        point,
        i = points.length,
        connectNulls = series.options.connectNulls,
        nullGap;
      if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {
        while (i--) {
          point = points[i];
          nullGap = point.y === null && connectNulls === false;
          if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {
            points.splice(i, 1);
            if (this.data[i]) {
              this.data[i].destroyElements();
            }
          }
        }
      }
    });

    function drawPointsWrapped(proceed) {
      proceed.apply(this);
      this.drawBreaks(this.xAxis, ['x']);
      this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));
    }
    H.Series.prototype.drawBreaks = function(axis, keys) {
      var series = this,
        points = series.points,
        breaks,
        threshold,
        eventName,
        y;
      if (!axis) {
        return;
      }
      each(keys, function(key) {
        breaks = axis.breakArray || [];
        threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);
        each(points, function(point) {
          y = pick(point['stack' + key.toUpperCase()], point[key]);
          each(breaks, function(brk) {
            eventName = false;
            if ((threshold < brk.from && y > brk.to) || (threshold > brk.from && y < brk.from)) {
              eventName = 'pointBreak';
            } else if ((threshold < brk.from && y > brk.from && y < brk.to) || (threshold > brk.from && y > brk.to && y < brk.from)) {
              eventName = 'pointInBreak';
            }
            if (eventName) {
              fireEvent(axis, eventName, {
                point: point,
                brk: brk
              });
            }
          });
        });
      });
    };
    wrap(H.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);
    wrap(H.Series.prototype, 'drawPoints', drawPointsWrapped);
  }(Highcharts));
  (function() {
    'use strict';
  }());
  (function(H) {
    'use strict';
    var arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      Axis = H.Axis,
      defaultPlotOptions = H.defaultPlotOptions,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      format = H.format,
      isNumber = H.isNumber,
      merge = H.merge,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      Tooltip = H.Tooltip,
      wrap = H.wrap;
    var seriesProto = Series.prototype,
      baseProcessData = seriesProto.processData,
      baseGeneratePoints = seriesProto.generatePoints,
      baseDestroy = seriesProto.destroy,
      commonOptions = {
        approximation: 'average',
        groupPixelWidth: 2,
        dateTimeLabelFormats: {
          millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
          second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
          minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
          hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
          day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
          week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
          month: ['%B %Y', '%B', '-%B %Y'],
          year: ['%Y', '%Y', '-%Y']
        }
      },
      specificOptions = {
        line: {},
        spline: {},
        area: {},
        areaspline: {},
        column: {
          approximation: 'sum',
          groupPixelWidth: 10
        },
        arearange: {
          approximation: 'range'
        },
        areasplinerange: {
          approximation: 'range'
        },
        columnrange: {
          approximation: 'range',
          groupPixelWidth: 10
        },
        candlestick: {
          approximation: 'ohlc',
          groupPixelWidth: 10
        },
        ohlc: {
          approximation: 'ohlc',
          groupPixelWidth: 5
        }
      },
      defaultDataGroupingUnits = H.defaultDataGroupingUnits = [
        [
          'millisecond',
          [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
        ],
        [
          'second', [1, 2, 5, 10, 15, 30]
        ],
        [
          'minute', [1, 2, 5, 10, 15, 30]
        ],
        [
          'hour', [1, 2, 3, 4, 6, 8, 12]
        ],
        [
          'day', [1]
        ],
        [
          'week', [1]
        ],
        [
          'month', [1, 3, 6]
        ],
        [
          'year',
          null
        ]
      ],
      approximations = {
        sum: function(arr) {
          var len = arr.length,
            ret;
          if (!len && arr.hasNulls) {
            ret = null;
          } else if (len) {
            ret = 0;
            while (len--) {
              ret += arr[len];
            }
          }
          return ret;
        },
        average: function(arr) {
          var len = arr.length,
            ret = approximations.sum(arr);
          if (isNumber(ret) && len) {
            ret = ret / len;
          }
          return ret;
        },
        open: function(arr) {
          return arr.length ? arr[0] : (arr.hasNulls ? null : undefined);
        },
        high: function(arr) {
          return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : undefined);
        },
        low: function(arr) {
          return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : undefined);
        },
        close: function(arr) {
          return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : undefined);
        },
        ohlc: function(open, high, low, close) {
          open = approximations.open(open);
          high = approximations.high(high);
          low = approximations.low(low);
          close = approximations.close(close);
          if (isNumber(open) || isNumber(high) || isNumber(low) || isNumber(close)) {
            return [open, high, low, close];
          }
        },
        range: function(low, high) {
          low = approximations.low(low);
          high = approximations.high(high);
          if (isNumber(low) || isNumber(high)) {
            return [low, high];
          }
        }
      };
    seriesProto.groupData = function(xData, yData, groupPositions, approximation) {
      var series = this,
        data = series.data,
        dataOptions = series.options.data,
        groupedXData = [],
        groupedYData = [],
        groupMap = [],
        dataLength = xData.length,
        pointX,
        pointY,
        groupedY,
        handleYData = !!yData,
        values = [
          [],
          [],
          [],
          []
        ],
        approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],
        pointArrayMap = series.pointArrayMap,
        pointArrayMapLength = pointArrayMap && pointArrayMap.length,
        i,
        pos = 0,
        start = 0;
      for (i = 0; i <= dataLength; i++) {
        if (xData[i] >= groupPositions[0]) {
          break;
        }
      }
      for (i; i <= dataLength; i++) {
        while ((groupPositions[pos + 1] !== undefined && xData[i] >= groupPositions[pos + 1]) ||
          i === dataLength) {
          pointX = groupPositions[pos];
          series.dataGroupInfo = {
            start: start,
            length: values[0].length
          };
          groupedY = approximationFn.apply(series, values);
          if (groupedY !== undefined) {
            groupedXData.push(pointX);
            groupedYData.push(groupedY);
            groupMap.push(series.dataGroupInfo);
          }
          start = i;
          values[0] = [];
          values[1] = [];
          values[2] = [];
          values[3] = [];
          pos += 1;
          if (i === dataLength) {
            break;
          }
        }
        if (i === dataLength) {
          break;
        }
        if (pointArrayMap) {
          var index = series.cropStart + i,
            point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({
              series: series
            }, [dataOptions[index]]),
            j,
            val;
          for (j = 0; j < pointArrayMapLength; j++) {
            val = point[pointArrayMap[j]];
            if (isNumber(val)) {
              values[j].push(val);
            } else if (val === null) {
              values[j].hasNulls = true;
            }
          }
        } else {
          pointY = handleYData ? yData[i] : null;
          if (isNumber(pointY)) {
            values[0].push(pointY);
          } else if (pointY === null) {
            values[0].hasNulls = true;
          }
        }
      }
      return [groupedXData, groupedYData, groupMap];
    };
    seriesProto.processData = function() {
      var series = this,
        chart = series.chart,
        options = series.options,
        dataGroupingOptions = options.dataGrouping,
        groupingEnabled = series.allowDG !== false && dataGroupingOptions &&
        pick(dataGroupingOptions.enabled, chart.options.isStock),
        visible = series.visible || !chart.options.chart.ignoreHiddenSeries,
        hasGroupedData,
        skip;
      series.forceCrop = groupingEnabled;
      series.groupPixelWidth = null;
      series.hasProcessed = true;
      skip = baseProcessData.apply(series, arguments) === false ||
        !groupingEnabled || !visible;
      if (!skip) {
        series.destroyGroupedData();
        var i,
          processedXData = series.processedXData,
          processedYData = series.processedYData,
          plotSizeX = chart.plotSizeX,
          xAxis = series.xAxis,
          ordinal = xAxis.options.ordinal,
          groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();
        if (groupPixelWidth) {
          hasGroupedData = true;
          series.isDirty = true;
          var extremes = xAxis.getExtremes(),
            xMin = extremes.min,
            xMax = extremes.max,
            groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,
            interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,
            groupPositions = xAxis.getTimeTicks(
              xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
              Math.min(xMin, processedXData[0]),
              Math.max(xMax, processedXData[processedXData.length - 1]),
              xAxis.options.startOfWeek,
              processedXData,
              series.closestPointRange
            ),
            groupedData = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
            groupedXData = groupedData[0],
            groupedYData = groupedData[1];
          if (dataGroupingOptions.smoothed) {
            i = groupedXData.length - 1;
            groupedXData[i] = Math.min(groupedXData[i], xMax);
            while (i-- && i > 0) {
              groupedXData[i] += interval / 2;
            }
            groupedXData[0] = Math.max(groupedXData[0], xMin);
          }
          series.currentDataGrouping = groupPositions.info;
          series.closestPointRange = groupPositions.info.totalRange;
          series.groupMap = groupedData[2];
          if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin) {
            if (xAxis.min === xAxis.dataMin) {
              xAxis.min = groupedXData[0];
            }
            xAxis.dataMin = groupedXData[0];
          }
          series.processedXData = groupedXData;
          series.processedYData = groupedYData;
        } else {
          series.currentDataGrouping = series.groupMap = null;
        }
        series.hasGroupedData = hasGroupedData;
      }
    };
    seriesProto.destroyGroupedData = function() {
      var groupedData = this.groupedData;
      each(groupedData || [], function(point, i) {
        if (point) {
          groupedData[i] = point.destroy ? point.destroy() : null;
        }
      });
      this.groupedData = null;
    };
    seriesProto.generatePoints = function() {
      baseGeneratePoints.apply(this);
      this.destroyGroupedData();
      this.groupedData = this.hasGroupedData ? this.points : null;
    };
    wrap(Point.prototype, 'update', function(proceed) {
      if (this.dataGroup) {
        H.error(24);
      } else {
        proceed.apply(this, [].slice.call(arguments, 1));
      }
    });
    wrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function(proceed, labelConfig, isFooter) {
      var tooltip = this,
        series = labelConfig.series,
        options = series.options,
        tooltipOptions = series.tooltipOptions,
        dataGroupingOptions = options.dataGrouping,
        xDateFormat = tooltipOptions.xDateFormat,
        xDateFormatEnd,
        xAxis = series.xAxis,
        dateFormat = H.dateFormat,
        currentDataGrouping,
        dateTimeLabelFormats,
        labelFormats,
        formattedKey;
      if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(labelConfig.key)) {
        currentDataGrouping = series.currentDataGrouping;
        dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;
        if (currentDataGrouping) {
          labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
          if (currentDataGrouping.count === 1) {
            xDateFormat = labelFormats[0];
          } else {
            xDateFormat = labelFormats[1];
            xDateFormatEnd = labelFormats[2];
          }
        } else if (!xDateFormat && dateTimeLabelFormats) {
          xDateFormat = tooltip.getXDateFormat(labelConfig, tooltipOptions, xAxis);
        }
        formattedKey = dateFormat(xDateFormat, labelConfig.key);
        if (xDateFormatEnd) {
          formattedKey += dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);
        }
        return format(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {
          point: extend(labelConfig.point, {
            key: formattedKey
          }),
          series: series
        });
      }
      return proceed.call(tooltip, labelConfig, isFooter);
    });
    seriesProto.destroy = function() {
      var series = this,
        groupedData = series.groupedData || [],
        i = groupedData.length;
      while (i--) {
        if (groupedData[i]) {
          groupedData[i].destroy();
        }
      }
      baseDestroy.apply(series);
    };
    wrap(seriesProto, 'setOptions', function(proceed, itemOptions) {
      var options = proceed.call(this, itemOptions),
        type = this.type,
        plotOptions = this.chart.options.plotOptions,
        defaultOptions = defaultPlotOptions[type].dataGrouping;
      if (specificOptions[type]) {
        if (!defaultOptions) {
          defaultOptions = merge(commonOptions, specificOptions[type]);
        }
        options.dataGrouping = merge(
          defaultOptions,
          plotOptions.series && plotOptions.series.dataGrouping,
          plotOptions[type].dataGrouping,
          itemOptions.dataGrouping
        );
      }
      if (this.chart.options.isStock) {
        this.requireSorting = true;
      }
      return options;
    });
    wrap(Axis.prototype, 'setScale', function(proceed) {
      proceed.call(this);
      each(this.series, function(series) {
        series.hasProcessed = false;
      });
    });
    Axis.prototype.getGroupPixelWidth = function() {
      var series = this.series,
        len = series.length,
        i,
        groupPixelWidth = 0,
        doGrouping = false,
        dataLength,
        dgOptions;
      i = len;
      while (i--) {
        dgOptions = series[i].options.dataGrouping;
        if (dgOptions) {
          groupPixelWidth = Math.max(groupPixelWidth, dgOptions.groupPixelWidth);
        }
      }
      i = len;
      while (i--) {
        dgOptions = series[i].options.dataGrouping;
        if (dgOptions && series[i].hasProcessed) {
          dataLength = (series[i].processedXData || series[i].data).length;
          if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {
            doGrouping = true;
          }
        }
      }
      return doGrouping ? groupPixelWidth : 0;
    };
    Axis.prototype.setDataGrouping = function(dataGrouping, redraw) {
      var i;
      redraw = pick(redraw, true);
      if (!dataGrouping) {
        dataGrouping = {
          forced: false,
          units: null
        };
      }
      if (this instanceof Axis) {
        i = this.series.length;
        while (i--) {
          this.series[i].update({
            dataGrouping: dataGrouping
          }, false);
        }
      } else {
        each(this.chart.options.series, function(seriesOptions) {
          seriesOptions.dataGrouping = dataGrouping;
        }, false);
      }
      if (redraw) {
        this.chart.redraw();
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      Point = H.Point,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('ohlc', 'column', {
      lineWidth: 1,
      tooltip: {
        pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>' +
          'Open: {point.open}<br/>' +
          'High: {point.high}<br/>' +
          'Low: {point.low}<br/>' +
          'Close: {point.close}<br/>'
      },
      threshold: null,
      states: {
        hover: {
          lineWidth: 3
        }
      }
    }, {
      pointArrayMap: ['open', 'high', 'low', 'close'],
      toYData: function(point) {
        return [point.open, point.high, point.low, point.close];
      },
      pointValKey: 'high',
      pointAttrToOptions: {
        'stroke': 'color',
        'stroke-width': 'lineWidth'
      },
      pointAttribs: function(point, state) {
        var attribs = seriesTypes.column.prototype.pointAttribs.call(
            this,
            point,
            state
          ),
          options = this.options;
        delete attribs.fill;
        if (!point.options.color &&
          options.upColor &&
          point.open < point.close
        ) {
          attribs.stroke = options.upColor;
        }
        return attribs;
      },
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          hasModifyValue = !!series.modifyValue,
          translatedOLC = ['plotOpen', 'yBottom', 'plotClose'];
        seriesTypes.column.prototype.translate.apply(series);
        each(series.points, function(point) {
          each([point.open, point.low, point.close], function(value, i) {
            if (value !== null) {
              if (hasModifyValue) {
                value = series.modifyValue(value);
              }
              point[translatedOLC[i]] = yAxis.toPixels(value, true);
            }
          });
        });
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          chart = series.chart;
        each(points, function(point) {
          var plotOpen,
            plotClose,
            crispCorr,
            halfWidth,
            path,
            graphic = point.graphic,
            crispX,
            isNew = !graphic;
          if (point.plotY !== undefined) {
            if (!graphic) {
              point.graphic = graphic = chart.renderer.path()
                .add(series.group);
            }
            graphic.attr(series.pointAttribs(point, point.selected && 'select'));
            crispCorr = (graphic.strokeWidth() % 2) / 2;
            crispX = Math.round(point.plotX) - crispCorr;
            halfWidth = Math.round(point.shapeArgs.width / 2);
            path = [
              'M',
              crispX, Math.round(point.yBottom),
              'L',
              crispX, Math.round(point.plotY)
            ];
            if (point.open !== null) {
              plotOpen = Math.round(point.plotOpen) + crispCorr;
              path.push(
                'M',
                crispX,
                plotOpen,
                'L',
                crispX - halfWidth,
                plotOpen
              );
            }
            if (point.close !== null) {
              plotClose = Math.round(point.plotClose) + crispCorr;
              path.push(
                'M',
                crispX,
                plotClose,
                'L',
                crispX + halfWidth,
                plotClose
              );
            }
            graphic[isNew ? 'attr' : 'animate']({
                d: path
              })
              .addClass(point.getClassName(), true);
          }
        });
      },
      animate: null
    }, {
      getClassName: function() {
        return Point.prototype.getClassName.call(this) +
          (this.open < this.close ? ' highcharts-point-up' : ' highcharts-point-down');
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var defaultPlotOptions = H.defaultPlotOptions,
      each = H.each,
      merge = H.merge,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('candlestick', 'ohlc', merge(defaultPlotOptions.column, {
      states: {
        hover: {
          lineWidth: 2
        }
      },
      tooltip: defaultPlotOptions.ohlc.tooltip,
      threshold: null,
      lineColor: '#000000',
      lineWidth: 1,
      upColor: '#ffffff'
    }), {
      pointAttribs: function(point, state) {
        var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),
          options = this.options,
          isUp = point.open < point.close,
          stroke = options.lineColor || this.color,
          stateOptions;
        attribs['stroke-width'] = options.lineWidth;
        attribs.fill = point.options.color || (isUp ? (options.upColor || this.color) : this.color);
        attribs.stroke = point.lineColor || (isUp ? (options.upLineColor || stroke) : stroke);
        if (state) {
          stateOptions = options.states[state];
          attribs.fill = stateOptions.color || attribs.fill;
          attribs.stroke = stateOptions.lineColor || attribs.stroke;
          attribs['stroke-width'] =
            stateOptions.lineWidth || attribs['stroke-width'];
        }
        return attribs;
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          chart = series.chart;
        each(points, function(point) {
          var graphic = point.graphic,
            plotOpen,
            plotClose,
            topBox,
            bottomBox,
            hasTopWhisker,
            hasBottomWhisker,
            crispCorr,
            crispX,
            path,
            halfWidth,
            isNew = !graphic;
          if (point.plotY !== undefined) {
            if (!graphic) {
              point.graphic = graphic = chart.renderer.path()
                .add(series.group);
            }
            graphic
              .attr(series.pointAttribs(point, point.selected && 'select'))
              .shadow(series.options.shadow);
            crispCorr = (graphic.strokeWidth() % 2) / 2;
            crispX = Math.round(point.plotX) - crispCorr;
            plotOpen = point.plotOpen;
            plotClose = point.plotClose;
            topBox = Math.min(plotOpen, plotClose);
            bottomBox = Math.max(plotOpen, plotClose);
            halfWidth = Math.round(point.shapeArgs.width / 2);
            hasTopWhisker = Math.round(topBox) !== Math.round(point.plotY);
            hasBottomWhisker = bottomBox !== point.yBottom;
            topBox = Math.round(topBox) + crispCorr;
            bottomBox = Math.round(bottomBox) + crispCorr;
            path = [];
            path.push(
              'M',
              crispX - halfWidth, bottomBox,
              'L',
              crispX - halfWidth, topBox,
              'L',
              crispX + halfWidth, topBox,
              'L',
              crispX + halfWidth, bottomBox,
              'Z',
              'M',
              crispX, topBox,
              'L',
              crispX, hasTopWhisker ? Math.round(point.plotY) : topBox,
              'M',
              crispX, bottomBox,
              'L',
              crispX, hasBottomWhisker ? Math.round(point.yBottom) : bottomBox
            );
            graphic[isNew ? 'attr' : 'animate']({
                d: path
              })
              .addClass(point.getClassName(), true);
          }
        });
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      each = H.each,
      merge = H.merge,
      noop = H.noop,
      Renderer = H.Renderer,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes,
      SVGRenderer = H.SVGRenderer,
      TrackerMixin = H.TrackerMixin,
      VMLRenderer = H.VMLRenderer,
      symbols = SVGRenderer.prototype.symbols;
    seriesType('flags', 'column', {
      pointRange: 0,
      shape: 'flag',
      stackDistance: 12,
      textAlign: 'center',
      tooltip: {
        pointFormat: '{point.text}<br/>'
      },
      threshold: null,
      y: -30,
      fillColor: '#ffffff',
      lineWidth: 1,
      states: {
        hover: {
          lineColor: '#000000',
          fillColor: '#ccd6eb'
        }
      },
      style: {
        fontSize: '11px',
        fontWeight: 'bold'
      }
    }, {
      sorted: false,
      noSharedTooltip: true,
      allowDG: false,
      takeOrdinalPosition: false,
      trackerGroups: ['markerGroup'],
      forceCrop: true,
      init: Series.prototype.init,
      pointAttribs: function(point, state) {
        var options = this.options,
          color = (point && point.color) || this.color,
          lineColor = options.lineColor,
          lineWidth = (point && point.lineWidth),
          fill = (point && point.fillColor) || options.fillColor;
        if (state) {
          fill = options.states[state].fillColor;
          lineColor = options.states[state].lineColor;
          lineWidth = options.states[state].lineWidth;
        }
        return {
          'fill': fill || color,
          'stroke': lineColor || color,
          'stroke-width': lineWidth || options.lineWidth || 0
        };
      },
      translate: function() {
        seriesTypes.column.prototype.translate.apply(this);
        var series = this,
          options = series.options,
          chart = series.chart,
          points = series.points,
          cursor = points.length - 1,
          point,
          lastPoint,
          optionsOnSeries = options.onSeries,
          onSeries = optionsOnSeries && chart.get(optionsOnSeries),
          onKey = options.onKey || 'y',
          step = onSeries && onSeries.options.step,
          onData = onSeries && onSeries.points,
          i = onData && onData.length,
          xAxis = series.xAxis,
          xAxisExt = xAxis.getExtremes(),
          xOffset = 0,
          leftPoint,
          lastX,
          rightPoint,
          currentDataGrouping;
        if (onSeries && onSeries.visible && i) {
          xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
          currentDataGrouping = onSeries.currentDataGrouping;
          lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0);
          points.sort(function(a, b) {
            return (a.x - b.x);
          });
          onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);
          while (i-- && points[cursor]) {
            point = points[cursor];
            leftPoint = onData[i];
            if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
              if (point.x <= lastX) {
                point.plotY = leftPoint[onKey];
                if (leftPoint.x < point.x && !step) {
                  rightPoint = onData[i + 1];
                  if (rightPoint && rightPoint[onKey] !== undefined) {
                    point.plotY +=
                      ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) *
                      (rightPoint[onKey] - leftPoint[onKey]);
                  }
                }
              }
              cursor--;
              i++;
              if (cursor < 0) {
                break;
              }
            }
          }
        }
        each(points, function(point, i) {
          var stackIndex;
          if (point.plotY === undefined) {
            if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) {
              point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - chart.plotTop;
            } else {
              point.shapeArgs = {};
            }
          }
          point.plotX += xOffset;
          lastPoint = points[i - 1];
          if (lastPoint && lastPoint.plotX === point.plotX) {
            if (lastPoint.stackIndex === undefined) {
              lastPoint.stackIndex = 0;
            }
            stackIndex = lastPoint.stackIndex + 1;
          }
          point.stackIndex = stackIndex;
        });
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          chart = series.chart,
          renderer = chart.renderer,
          plotX,
          plotY,
          options = series.options,
          optionsY = options.y,
          shape,
          i,
          point,
          graphic,
          stackIndex,
          anchorX,
          anchorY,
          outsideRight,
          yAxis = series.yAxis;
        i = points.length;
        while (i--) {
          point = points[i];
          outsideRight = point.plotX > series.xAxis.len;
          plotX = point.plotX;
          stackIndex = point.stackIndex;
          shape = point.options.shape || options.shape;
          plotY = point.plotY;
          if (plotY !== undefined) {
            plotY = point.plotY + optionsY - (stackIndex !== undefined && stackIndex * options.stackDistance);
          }
          anchorX = stackIndex ? undefined : point.plotX;
          anchorY = stackIndex ? undefined : point.plotY;
          graphic = point.graphic;
          if (plotY !== undefined && plotX >= 0 && !outsideRight) {
            if (!graphic) {
              graphic = point.graphic = renderer.label(
                  '',
                  null,
                  null,
                  shape,
                  null,
                  null,
                  options.useHTML
                )
                .attr(series.pointAttribs(point))
                .css(merge(options.style, point.style))
                .attr({
                  align: shape === 'flag' ? 'left' : 'center',
                  width: options.width,
                  height: options.height,
                  'text-align': options.textAlign
                })
                .addClass('highcharts-point')
                .add(series.markerGroup);
              graphic.shadow(options.shadow);
            }
            if (plotX > 0) {
              plotX -= graphic.strokeWidth() % 2;
            }
            graphic.attr({
              text: point.options.title || options.title || 'A',
              x: plotX,
              y: plotY,
              anchorX: anchorX,
              anchorY: anchorY
            });
            point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - plotX] : [plotX, plotY];
          } else if (graphic) {
            point.graphic = graphic.destroy();
          }
        }
      },
      drawTracker: function() {
        var series = this,
          points = series.points;
        TrackerMixin.drawTrackerPoint.apply(this);
        each(points, function(point) {
          var graphic = point.graphic;
          if (graphic) {
            addEvent(graphic.element, 'mouseover', function() {
              if (point.stackIndex > 0 && !point.raised) {
                point._y = graphic.y;
                graphic.attr({
                  y: point._y - 8
                });
                point.raised = true;
              }
              each(points, function(otherPoint) {
                if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
                  otherPoint.graphic.attr({
                    y: otherPoint._y
                  });
                  otherPoint.raised = false;
                }
              });
            });
          }
        });
      },
      animate: noop,
      buildKDTree: noop,
      setClip: noop
    });
    symbols.flag = function(x, y, w, h, options) {
      var anchorX = (options && options.anchorX) || x,
        anchorY = (options && options.anchorY) || y;
      return [
        'M', anchorX, anchorY,
        'L', x, y + h,
        x, y,
        x + w, y,
        x + w, y + h,
        x, y + h,
        'Z'
      ];
    };
    each(['circle', 'square'], function(shape) {
      symbols[shape + 'pin'] = function(x, y, w, h, options) {
        var anchorX = options && options.anchorX,
          anchorY = options && options.anchorY,
          path,
          labelTopOrBottomY;
        if (shape === 'circle' && h > w) {
          x -= Math.round((h - w) / 2);
          w = h;
        }
        path = symbols[shape](x, y, w, h);
        if (anchorX && anchorY) {
          labelTopOrBottomY = (y > anchorY) ? y : y + h;
          path.push('M', anchorX, labelTopOrBottomY, 'L', anchorX, anchorY);
        }
        return path;
      };
    });
    if (Renderer === VMLRenderer) {
      each(['flag', 'circlepin', 'squarepin'], function(shape) {
        VMLRenderer.prototype.symbols[shape] = symbols[shape];
      });
    }
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      Axis = H.Axis,
      correctFloat = H.correctFloat,
      defaultOptions = H.defaultOptions,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      doc = H.doc,
      each = H.each,
      fireEvent = H.fireEvent,
      hasTouch = H.hasTouch,
      isTouchDevice = H.isTouchDevice,
      merge = H.merge,
      pick = H.pick,
      removeEvent = H.removeEvent,
      svg = H.svg,
      wrap = H.wrap,
      swapXY;
    var defaultScrollbarOptions = {
      height: isTouchDevice ? 20 : 14,
      barBorderRadius: 0,
      buttonBorderRadius: 0,
      liveRedraw: svg && !isTouchDevice,
      margin: 10,
      minWidth: 6,
      step: 0.2,
      zIndex: 3,
      barBackgroundColor: '#cccccc',
      barBorderWidth: 1,
      barBorderColor: '#cccccc',
      buttonArrowColor: '#333333',
      buttonBackgroundColor: '#e6e6e6',
      buttonBorderColor: '#cccccc',
      buttonBorderWidth: 1,
      rifleColor: '#333333',
      trackBackgroundColor: '#f2f2f2',
      trackBorderColor: '#f2f2f2',
      trackBorderWidth: 1
    };
    defaultOptions.scrollbar = merge(true, defaultScrollbarOptions, defaultOptions.scrollbar);
    H.swapXY = swapXY = function(path, vertical) {
      var i,
        len = path.length,
        temp;
      if (vertical) {
        for (i = 0; i < len; i += 3) {
          temp = path[i + 1];
          path[i + 1] = path[i + 2];
          path[i + 2] = temp;
        }
      }
      return path;
    };

    function Scrollbar(renderer, options, chart) {
      this.init(renderer, options, chart);
    }
    Scrollbar.prototype = {
      init: function(renderer, options, chart) {
        this.scrollbarButtons = [];
        this.renderer = renderer;
        this.userOptions = options;
        this.options = merge(defaultScrollbarOptions, options);
        this.chart = chart;
        this.size = pick(this.options.size, this.options.height);
        if (options.enabled) {
          this.render();
          this.initEvents();
          this.addEvents();
        }
      },
      render: function() {
        var scroller = this,
          renderer = scroller.renderer,
          options = scroller.options,
          size = scroller.size,
          group;
        scroller.group = group = renderer.g('scrollbar').attr({
          zIndex: options.zIndex,
          translateY: -99999
        }).add();
        scroller.track = renderer.rect()
          .addClass('highcharts-scrollbar-track')
          .attr({
            x: 0,
            r: options.trackBorderRadius || 0,
            height: size,
            width: size
          }).add(group);
        scroller.track.attr({
          fill: options.trackBackgroundColor,
          stroke: options.trackBorderColor,
          'stroke-width': options.trackBorderWidth
        });
        this.trackBorderWidth = scroller.track.strokeWidth();
        scroller.track.attr({
          y: -this.trackBorderWidth % 2 / 2
        });
        scroller.scrollbarGroup = renderer.g().add(group);
        scroller.scrollbar = renderer.rect()
          .addClass('highcharts-scrollbar-thumb')
          .attr({
            height: size,
            width: size,
            r: options.barBorderRadius || 0
          }).add(scroller.scrollbarGroup);
        scroller.scrollbarRifles = renderer.path(
            swapXY([
              'M', -3, size / 4,
              'L', -3, 2 * size / 3,
              'M',
              0, size / 4,
              'L',
              0, 2 * size / 3,
              'M',
              3, size / 4,
              'L',
              3, 2 * size / 3
            ], options.vertical))
          .addClass('highcharts-scrollbar-rifles')
          .add(scroller.scrollbarGroup);
        scroller.scrollbar.attr({
          fill: options.barBackgroundColor,
          stroke: options.barBorderColor,
          'stroke-width': options.barBorderWidth
        });
        scroller.scrollbarRifles.attr({
          stroke: options.rifleColor,
          'stroke-width': 1
        });
        scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
        scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2);
        scroller.drawScrollbarButton(0);
        scroller.drawScrollbarButton(1);
      },
      position: function(x, y, width, height) {
        var scroller = this,
          options = scroller.options,
          vertical = options.vertical,
          xOffset = height,
          yOffset = 0,
          method = scroller.rendered ? 'animate' : 'attr';
        scroller.x = x;
        scroller.y = y + this.trackBorderWidth;
        scroller.width = width;
        scroller.height = height;
        scroller.xOffset = xOffset;
        scroller.yOffset = yOffset;
        if (vertical) {
          scroller.width = scroller.yOffset = width = yOffset = scroller.size;
          scroller.xOffset = xOffset = 0;
          scroller.barWidth = height - width * 2;
          scroller.x = x = x + scroller.options.margin;
        } else {
          scroller.height = scroller.xOffset = height = xOffset = scroller.size;
          scroller.barWidth = width - height * 2;
          scroller.y = scroller.y + scroller.options.margin;
        }
        scroller.group[method]({
          translateX: x,
          translateY: scroller.y
        });
        scroller.track[method]({
          width: width,
          height: height
        });
        scroller.scrollbarButtons[1][method]({
          translateX: vertical ? 0 : width - xOffset,
          translateY: vertical ? height - yOffset : 0
        });
      },
      drawScrollbarButton: function(index) {
        var scroller = this,
          renderer = scroller.renderer,
          scrollbarButtons = scroller.scrollbarButtons,
          options = scroller.options,
          size = scroller.size,
          group,
          tempElem;
        group = renderer.g().add(scroller.group);
        scrollbarButtons.push(group);
        tempElem = renderer.rect()
          .addClass('highcharts-scrollbar-button')
          .add(group);
        tempElem.attr({
          stroke: options.buttonBorderColor,
          'stroke-width': options.buttonBorderWidth,
          fill: options.buttonBackgroundColor
        });
        tempElem.attr(tempElem.crisp({
          x: -0.5,
          y: -0.5,
          width: size + 1,
          height: size + 1,
          r: options.buttonBorderRadius
        }, tempElem.strokeWidth()));
        tempElem = renderer
          .path(swapXY([
            'M',
            size / 2 + (index ? -1 : 1),
            size / 2 - 3,
            'L',
            size / 2 + (index ? -1 : 1),
            size / 2 + 3,
            'L',
            size / 2 + (index ? 2 : -2),
            size / 2
          ], options.vertical))
          .addClass('highcharts-scrollbar-arrow')
          .add(scrollbarButtons[index]);
        tempElem.attr({
          fill: options.buttonArrowColor
        });
      },
      setRange: function(from, to) {
        var scroller = this,
          options = scroller.options,
          vertical = options.vertical,
          minWidth = options.minWidth,
          fullWidth = scroller.barWidth,
          fromPX,
          toPX,
          newPos,
          newSize,
          newRiflesPos,
          method = this.rendered && !this.hasDragged ? 'animate' : 'attr';
        if (!defined(fullWidth)) {
          return;
        }
        from = Math.max(from, 0);
        fromPX = fullWidth * from;
        toPX = fullWidth * Math.min(to, 1);
        scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);
        if (newSize < minWidth) {
          fromPX = (fullWidth - minWidth + newSize) * from;
          newSize = minWidth;
        }
        newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
        newRiflesPos = newSize / 2 - 0.5;
        scroller.from = from;
        scroller.to = to;
        if (!vertical) {
          scroller.scrollbarGroup[method]({
            translateX: newPos
          });
          scroller.scrollbar[method]({
            width: newSize
          });
          scroller.scrollbarRifles[method]({
            translateX: newRiflesPos
          });
          scroller.scrollbarLeft = newPos;
          scroller.scrollbarTop = 0;
        } else {
          scroller.scrollbarGroup[method]({
            translateY: newPos
          });
          scroller.scrollbar[method]({
            height: newSize
          });
          scroller.scrollbarRifles[method]({
            translateY: newRiflesPos
          });
          scroller.scrollbarTop = newPos;
          scroller.scrollbarLeft = 0;
        }
        if (newSize <= 12) {
          scroller.scrollbarRifles.hide();
        } else {
          scroller.scrollbarRifles.show(true);
        }
        if (options.showFull === false) {
          if (from <= 0 && to >= 1) {
            scroller.group.hide();
          } else {
            scroller.group.show();
          }
        }
        scroller.rendered = true;
      },
      initEvents: function() {
        var scroller = this;
        scroller.mouseMoveHandler = function(e) {
          var normalizedEvent = scroller.chart.pointer.normalize(e),
            options = scroller.options,
            direction = options.vertical ? 'chartY' : 'chartX',
            initPositions = scroller.initPositions,
            scrollPosition,
            chartPosition,
            change;
          if (scroller.grabbedCenter && (!e.touches || e.touches[0][direction] !== 0)) {
            chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
            scrollPosition = scroller[direction];
            change = chartPosition - scrollPosition;
            scroller.hasDragged = true;
            scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);
            if (scroller.hasDragged) {
              fireEvent(scroller, 'changed', {
                from: scroller.from,
                to: scroller.to,
                trigger: 'scrollbar',
                DOMType: e.type,
                DOMEvent: e
              });
            }
          }
        };
        scroller.mouseUpHandler = function(e) {
          if (scroller.hasDragged) {
            fireEvent(scroller, 'changed', {
              from: scroller.from,
              to: scroller.to,
              trigger: 'scrollbar',
              DOMType: e.type,
              DOMEvent: e
            });
          }
          scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
        };
        scroller.mouseDownHandler = function(e) {
          var normalizedEvent = scroller.chart.pointer.normalize(e),
            mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
          scroller.chartX = mousePosition.chartX;
          scroller.chartY = mousePosition.chartY;
          scroller.initPositions = [scroller.from, scroller.to];
          scroller.grabbedCenter = true;
        };
        scroller.buttonToMinClick = function(e) {
          var range = correctFloat(scroller.to - scroller.from) * scroller.options.step;
          scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));
          fireEvent(scroller, 'changed', {
            from: scroller.from,
            to: scroller.to,
            trigger: 'scrollbar',
            DOMEvent: e
          });
        };
        scroller.buttonToMaxClick = function(e) {
          var range = (scroller.to - scroller.from) * scroller.options.step;
          scroller.updatePosition(scroller.from + range, scroller.to + range);
          fireEvent(scroller, 'changed', {
            from: scroller.from,
            to: scroller.to,
            trigger: 'scrollbar',
            DOMEvent: e
          });
        };
        scroller.trackClick = function(e) {
          var normalizedEvent = scroller.chart.pointer.normalize(e),
            range = scroller.to - scroller.from,
            top = scroller.y + scroller.scrollbarTop,
            left = scroller.x + scroller.scrollbarLeft;
          if ((scroller.options.vertical && normalizedEvent.chartY > top) ||
            (!scroller.options.vertical && normalizedEvent.chartX > left)) {
            scroller.updatePosition(scroller.from + range, scroller.to + range);
          } else {
            scroller.updatePosition(scroller.from - range, scroller.to - range);
          }
          fireEvent(scroller, 'changed', {
            from: scroller.from,
            to: scroller.to,
            trigger: 'scrollbar',
            DOMEvent: e
          });
        };
      },
      cursorToScrollbarPosition: function(normalizedEvent) {
        var scroller = this,
          options = scroller.options,
          minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0;
        return {
          chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
          chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
        };
      },
      updatePosition: function(from, to) {
        if (to > 1) {
          from = correctFloat(1 - correctFloat(to - from));
          to = 1;
        }
        if (from < 0) {
          to = correctFloat(to - from);
          from = 0;
        }
        this.from = from;
        this.to = to;
      },
      update: function(options) {
        this.destroy();
        this.init(this.chart.renderer, merge(true, this.options, options), this.chart);
      },
      addEvents: function() {
        var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1],
          buttons = this.scrollbarButtons,
          bar = this.scrollbarGroup.element,
          track = this.track.element,
          mouseDownHandler = this.mouseDownHandler,
          mouseMoveHandler = this.mouseMoveHandler,
          mouseUpHandler = this.mouseUpHandler,
          _events;
        _events = [
          [buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick],
          [buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick],
          [track, 'click', this.trackClick],
          [bar, 'mousedown', mouseDownHandler],
          [doc, 'mousemove', mouseMoveHandler],
          [doc, 'mouseup', mouseUpHandler]
        ];
        if (hasTouch) {
          _events.push(
            [bar, 'touchstart', mouseDownHandler], [doc, 'touchmove', mouseMoveHandler], [doc, 'touchend', mouseUpHandler]
          );
        }
        each(_events, function(args) {
          addEvent.apply(null, args);
        });
        this._events = _events;
      },
      removeEvents: function() {
        each(this._events, function(args) {
          removeEvent.apply(null, args);
        });
        this._events = undefined;
      },
      destroy: function() {
        var scroller = this.chart.scroller;
        this.removeEvents();
        each(['track', 'scrollbarRifles', 'scrollbar', 'scrollbarGroup', 'group'], function(prop) {
          if (this[prop] && this[prop].destroy) {
            this[prop] = this[prop].destroy();
          }
        }, this);
        if (scroller) {
          scroller.scrollbar = null;
          destroyObjectProperties(scroller.scrollbarButtons);
        }
      }
    };
    wrap(Axis.prototype, 'init', function(proceed) {
      var axis = this;
      proceed.apply(axis, [].slice.call(arguments, 1));
      if (axis.options.scrollbar && axis.options.scrollbar.enabled) {
        axis.options.scrollbar.vertical = !axis.horiz;
        axis.options.startOnTick = axis.options.endOnTick = false;
        axis.scrollbar = new Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);
        addEvent(axis.scrollbar, 'changed', function(e) {
          var unitedMin = Math.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),
            unitedMax = Math.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),
            range = unitedMax - unitedMin,
            to,
            from;
          if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
            to = unitedMin + range * this.to;
            from = unitedMin + range * this.from;
          } else {
            to = unitedMin + range * (1 - this.from);
            from = unitedMin + range * (1 - this.to);
          }
          axis.setExtremes(from, to, true, false, e);
        });
      }
    });
    wrap(Axis.prototype, 'render', function(proceed) {
      var axis = this,
        scrollMin = Math.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),
        scrollMax = Math.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),
        scrollbar = axis.scrollbar,
        from,
        to;
      proceed.apply(axis, [].slice.call(arguments, 1));
      if (scrollbar) {
        if (axis.horiz) {
          scrollbar.position(
            axis.left,
            axis.top + axis.height + axis.offset + 2 + (axis.opposite ? 0 : axis.axisTitleMargin),
            axis.width,
            axis.height
          );
        } else {
          scrollbar.position(
            axis.left + axis.width + 2 + axis.offset + (axis.opposite ? axis.axisTitleMargin : 0),
            axis.top,
            axis.width,
            axis.height
          );
        }
        if (isNaN(scrollMin) || isNaN(scrollMax) || !defined(axis.min) || !defined(axis.max)) {
          scrollbar.setRange(0, 0);
        } else {
          from = (axis.min - scrollMin) / (scrollMax - scrollMin);
          to = (axis.max - scrollMin) / (scrollMax - scrollMin);
          if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
            scrollbar.setRange(from, to);
          } else {
            scrollbar.setRange(1 - to, 1 - from);
          }
        }
      }
    });
    wrap(Axis.prototype, 'getOffset', function(proceed) {
      var axis = this,
        index = axis.horiz ? 2 : 1,
        scrollbar = axis.scrollbar;
      proceed.apply(axis, [].slice.call(arguments, 1));
      if (scrollbar) {
        axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
      }
    });
    wrap(Axis.prototype, 'destroy', function(proceed) {
      if (this.scrollbar) {
        this.scrollbar = this.scrollbar.destroy();
      }
      proceed.apply(this, [].slice.call(arguments, 1));
    });
    H.Scrollbar = Scrollbar;
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      Axis = H.Axis,
      Chart = H.Chart,
      color = H.color,
      defaultDataGroupingUnits = H.defaultDataGroupingUnits,
      defaultOptions = H.defaultOptions,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      doc = H.doc,
      each = H.each,
      erase = H.erase,
      error = H.error,
      extend = H.extend,
      grep = H.grep,
      hasTouch = H.hasTouch,
      isNumber = H.isNumber,
      isObject = H.isObject,
      merge = H.merge,
      pick = H.pick,
      removeEvent = H.removeEvent,
      Scrollbar = H.Scrollbar,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      wrap = H.wrap,
      swapXY = H.swapXY,
      units = [].concat(defaultDataGroupingUnits),
      defaultSeriesType,
      numExt = function(extreme) {
        var numbers = grep(arguments, isNumber);
        if (numbers.length) {
          return Math[extreme].apply(0, numbers);
        }
      };
    units[4] = ['day', [1, 2, 3, 4]];
    units[5] = ['week', [1, 2, 3]];
    defaultSeriesType = seriesTypes.areaspline === undefined ? 'line' : 'areaspline';
    extend(defaultOptions, {
      navigator: {
        height: 40,
        margin: 25,
        maskInside: true,
        handles: {
          backgroundColor: '#f2f2f2',
          borderColor: '#999999'
        },
        maskFill: color('#6685c2').setOpacity(0.3).get(),
        outlineColor: '#cccccc',
        outlineWidth: 1,
        series: {
          type: defaultSeriesType,
          color: '#335cad',
          fillOpacity: 0.05,
          lineWidth: 1,
          compare: null,
          dataGrouping: {
            approximation: 'average',
            enabled: true,
            groupPixelWidth: 2,
            smoothed: true,
            units: units
          },
          dataLabels: {
            enabled: false,
            zIndex: 2
          },
          id: 'highcharts-navigator-series',
          className: 'highcharts-navigator-series',
          lineColor: null,
          marker: {
            enabled: false
          },
          pointRange: 0,
          shadow: false,
          threshold: null
        },
        xAxis: {
          className: 'highcharts-navigator-xaxis',
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: '#e6e6e6',
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: 'left',
            style: {
              color: '#999999'
            },
            x: 3,
            y: -4
          },
          crosshair: false
        },
        yAxis: {
          className: 'highcharts-navigator-yaxis',
          gridLineWidth: 0,
          startOnTick: false,
          endOnTick: false,
          minPadding: 0.1,
          maxPadding: 0.1,
          labels: {
            enabled: false
          },
          crosshair: false,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }
    });

    function Navigator(chart) {
      this.init(chart);
    }
    Navigator.prototype = {
      drawHandle: function(x, index, inverted, verb) {
        var navigator = this;
        navigator.handles[index][verb](inverted ? {
          translateX: Math.round(navigator.left + navigator.height / 2 - 8),
          translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5)
        } : {
          translateX: Math.round(navigator.left + parseInt(x, 10)),
          translateY: Math.round(navigator.top + navigator.height / 2 - 8)
        });
      },
      getHandlePath: function(inverted) {
        return swapXY([
          'M', -4.5, 0.5,
          'L',
          3.5, 0.5,
          'L',
          3.5, 15.5,
          'L', -4.5, 15.5,
          'L', -4.5, 0.5,
          'M', -1.5, 4,
          'L', -1.5, 12,
          'M',
          0.5, 4,
          'L',
          0.5, 12
        ], inverted);
      },
      drawOutline: function(zoomedMin, zoomedMax, inverted, verb) {
        var navigator = this,
          maskInside = navigator.navigatorOptions.maskInside,
          outlineWidth = navigator.outline.strokeWidth(),
          halfOutline = outlineWidth / 2,
          outlineHeight = navigator.outlineHeight,
          scrollbarHeight = navigator.scrollbarHeight,
          navigatorSize = navigator.size,
          left = navigator.left - scrollbarHeight,
          navigatorTop = navigator.top,
          verticalMin,
          path;
        if (inverted) {
          left -= halfOutline;
          verticalMin = navigatorTop + zoomedMax + halfOutline;
          zoomedMax = navigatorTop + zoomedMin + halfOutline;
          path = [
            'M',
            left + outlineHeight,
            navigatorTop - scrollbarHeight - halfOutline,
            'L',
            left + outlineHeight,
            verticalMin,
            'L',
            left,
            verticalMin,
            'L',
            left,
            zoomedMax,
            'L',
            left + outlineHeight,
            zoomedMax,
            'L',
            left + outlineHeight,
            navigatorTop + navigatorSize + scrollbarHeight
          ].concat(maskInside ? [
            'M',
            left + outlineHeight,
            verticalMin - halfOutline,
            'L',
            left + outlineHeight,
            zoomedMax + halfOutline
          ] : []);
        } else {
          zoomedMin += left + scrollbarHeight - halfOutline;
          zoomedMax += left + scrollbarHeight - halfOutline;
          navigatorTop += halfOutline;
          path = [
            'M',
            left,
            navigatorTop,
            'L',
            zoomedMin,
            navigatorTop,
            'L',
            zoomedMin,
            navigatorTop + outlineHeight,
            'L',
            zoomedMax,
            navigatorTop + outlineHeight,
            'L',
            zoomedMax,
            navigatorTop,
            'L',
            left + navigatorSize + scrollbarHeight * 2,
            navigatorTop
          ].concat(maskInside ? [
            'M',
            zoomedMin - halfOutline,
            navigatorTop,
            'L',
            zoomedMax + halfOutline,
            navigatorTop
          ] : []);
        }
        navigator.outline[verb]({
          d: path
        });
      },
      drawMasks: function(zoomedMin, zoomedMax, inverted, verb) {
        var navigator = this,
          left = navigator.left,
          top = navigator.top,
          navigatorHeight = navigator.height,
          height,
          width,
          x,
          y;
        if (inverted) {
          x = [left, left, left];
          y = [top, top + zoomedMin, top + zoomedMax];
          width = [navigatorHeight, navigatorHeight, navigatorHeight];
          height = [
            zoomedMin,
            zoomedMax - zoomedMin,
            navigator.size - zoomedMax
          ];
        } else {
          x = [left, left + zoomedMin, left + zoomedMax];
          y = [top, top, top];
          width = [
            zoomedMin,
            zoomedMax - zoomedMin,
            navigator.size - zoomedMax
          ];
          height = [navigatorHeight, navigatorHeight, navigatorHeight];
        }
        each(navigator.shades, function(shade, i) {
          shade[verb]({
            x: x[i],
            y: y[i],
            width: width[i],
            height: height[i]
          });
        });
      },
      renderElements: function() {
        var navigator = this,
          navigatorOptions = navigator.navigatorOptions,
          maskInside = navigatorOptions.maskInside,
          chart = navigator.chart,
          inverted = chart.inverted,
          renderer = chart.renderer,
          navigatorGroup;
        navigator.navigatorGroup = navigatorGroup = renderer.g('navigator')
          .attr({
            zIndex: 8,
            visibility: 'hidden'
          })
          .add();
        var mouseCursor = {
          cursor: inverted ? 'ns-resize' : 'ew-resize'
        };
        each([!maskInside, maskInside, !maskInside], function(hasMask, index) {
          navigator.shades[index] = renderer.rect()
            .addClass('highcharts-navigator-mask' +
              (index === 1 ? '-inside' : '-outside'))
            .attr({
              fill: hasMask ? navigatorOptions.maskFill : 'transparent'
            })
            .css(index === 1 && mouseCursor)
            .add(navigatorGroup);
        });
        navigator.outline = renderer.path()
          .addClass('highcharts-navigator-outline')
          .attr({
            'stroke-width': navigatorOptions.outlineWidth,
            stroke: navigatorOptions.outlineColor
          })
          .add(navigatorGroup);
        each([0, 1], function(index) {
          navigator.handles[index] = renderer
            .path(navigator.getHandlePath(inverted))
            .attr({
              zIndex: 7 - index
            })
            .addClass(
              'highcharts-navigator-handle highcharts-navigator-handle-' + ['left', 'right'][index]
            ).add(navigatorGroup);
          var handlesOptions = navigatorOptions.handles;
          navigator.handles[index]
            .attr({
              fill: handlesOptions.backgroundColor,
              stroke: handlesOptions.borderColor,
              'stroke-width': 1
            })
            .css(mouseCursor);
        });
      },
      update: function(options) {
        this.destroy();
        var chartOptions = this.chart.options;
        merge(true, chartOptions.navigator, this.options, options);
        this.init(this.chart);
      },
      render: function(min, max, pxMin, pxMax) {
        var navigator = this,
          chart = navigator.chart,
          navigatorWidth,
          scrollbarLeft,
          scrollbarTop,
          scrollbarHeight = navigator.scrollbarHeight,
          navigatorSize,
          xAxis = navigator.xAxis,
          navigatorEnabled = navigator.navigatorEnabled,
          zoomedMin,
          zoomedMax,
          rendered = navigator.rendered,
          inverted = chart.inverted,
          verb,
          newMin,
          newMax,
          minRange = chart.xAxis[0].minRange;
        if (this.hasDragged && !defined(pxMin)) {
          return;
        }
        if (!isNumber(min) || !isNumber(max)) {
          if (rendered) {
            pxMin = 0;
            pxMax = xAxis.width;
          } else {
            return;
          }
        }
        navigator.left = pick(
          xAxis.left,
          chart.plotLeft + scrollbarHeight
        );
        if (inverted) {
          navigator.size = zoomedMax = navigatorSize = pick(
            xAxis.len,
            chart.plotHeight - 2 * scrollbarHeight
          );
          navigatorWidth = scrollbarHeight;
        } else {
          navigator.size = zoomedMax = navigatorSize = pick(
            xAxis.len,
            chart.plotWidth - 2 * scrollbarHeight
          );
          navigatorWidth = navigatorSize + 2 * scrollbarHeight;
        }
        pxMin = pick(pxMin, xAxis.toPixels(min, true));
        pxMax = pick(pxMax, xAxis.toPixels(max, true));
        if (!isNumber(pxMin) || Math.abs(pxMin) === Infinity) {
          pxMin = 0;
          pxMax = navigatorWidth;
        }
        newMin = xAxis.toValue(pxMin, true);
        newMax = xAxis.toValue(pxMax, true);
        if (Math.abs(newMax - newMin) < minRange) {
          if (this.grabbedLeft) {
            pxMin = xAxis.toPixels(newMax - minRange, true);
          } else if (this.grabbedRight) {
            pxMax = xAxis.toPixels(newMin + minRange, true);
          } else {
            return;
          }
        }
        navigator.zoomedMax = Math.min(Math.max(pxMin, pxMax, 0), zoomedMax);
        navigator.zoomedMin = Math.min(
          Math.max(
            navigator.fixedWidth ?
            navigator.zoomedMax - navigator.fixedWidth :
            Math.min(pxMin, pxMax),
            0
          ),
          zoomedMax
        );
        navigator.range = navigator.zoomedMax - navigator.zoomedMin;
        zoomedMax = Math.round(navigator.zoomedMax);
        zoomedMin = Math.round(navigator.zoomedMin);
        if (navigatorEnabled) {
          navigator.navigatorGroup.attr({
            visibility: 'visible'
          });
          verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';
          navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
          navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
          navigator.drawHandle(zoomedMin, 0, inverted, verb);
          navigator.drawHandle(zoomedMax, 1, inverted, verb);
        }
        if (navigator.scrollbar) {
          if (inverted) {
            scrollbarTop = navigator.top - scrollbarHeight;
            scrollbarLeft = navigator.left - scrollbarHeight +
              (navigatorEnabled ? 0 : navigator.height);
            scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
          } else {
            scrollbarTop = navigator.top +
              (navigatorEnabled ? navigator.height : -scrollbarHeight);
            scrollbarLeft = navigator.left - scrollbarHeight;
          }
          navigator.scrollbar.position(
            scrollbarLeft,
            scrollbarTop,
            navigatorWidth,
            scrollbarHeight
          );
          navigator.scrollbar.setRange(
            zoomedMin / navigatorSize,
            zoomedMax / navigatorSize
          );
        }
        navigator.rendered = true;
      },
      addMouseEvents: function() {
        var navigator = this,
          chart = navigator.chart,
          container = chart.container,
          eventsToUnbind = [],
          mouseMoveHandler,
          mouseUpHandler;
        navigator.mouseMoveHandler = mouseMoveHandler = function(e) {
          navigator.onMouseMove(e);
        };
        navigator.mouseUpHandler = mouseUpHandler = function(e) {
          navigator.onMouseUp(e);
        };
        eventsToUnbind = navigator.getPartsEvents('mousedown');
        eventsToUnbind.push(
          addEvent(container, 'mousemove', mouseMoveHandler),
          addEvent(doc, 'mouseup', mouseUpHandler)
        );
        if (hasTouch) {
          eventsToUnbind.push(
            addEvent(container, 'touchmove', mouseMoveHandler),
            addEvent(doc, 'touchend', mouseUpHandler)
          );
          eventsToUnbind.concat(navigator.getPartsEvents('touchstart'));
        }
        navigator.eventsToUnbind = eventsToUnbind;
        if (navigator.series && navigator.series[0]) {
          eventsToUnbind.push(
            addEvent(navigator.series[0].xAxis, 'foundExtremes', function() {
              chart.navigator.modifyNavigatorAxisExtremes();
            })
          );
        }
      },
      getPartsEvents: function(eventName) {
        var navigator = this,
          events = [];
        each(['shades', 'handles'], function(name) {
          each(navigator[name], function(navigatorItem, index) {
            events.push(
              addEvent(
                navigatorItem.element,
                eventName,
                function(e) {
                  navigator[name + 'Mousedown'](e, index);
                }
              )
            );
          });
        });
        return events;
      },
      shadesMousedown: function(e, index) {
        e = this.chart.pointer.normalize(e);
        var navigator = this,
          chart = navigator.chart,
          xAxis = navigator.xAxis,
          zoomedMin = navigator.zoomedMin,
          navigatorPosition = navigator.left,
          navigatorSize = navigator.size,
          range = navigator.range,
          chartX = e.chartX,
          fixedMax,
          ext,
          left;
        if (chart.inverted) {
          chartX = e.chartY;
          navigatorPosition = navigator.top;
        }
        if (index === 1) {
          navigator.grabbedCenter = chartX;
          navigator.fixedWidth = range;
          navigator.dragOffset = chartX - zoomedMin;
        } else {
          left = chartX - navigatorPosition - range / 2;
          if (index === 0) {
            left = Math.max(0, left);
          } else if (index === 2 && left + range >= navigatorSize) {
            left = navigatorSize - range;
            fixedMax = navigator.getUnionExtremes().dataMax;
          }
          if (left !== zoomedMin) {
            navigator.fixedWidth = range;
            ext = xAxis.toFixedRange(left, left + range, null, fixedMax);
            chart.xAxis[0].setExtremes(
              Math.min(ext.min, ext.max),
              Math.max(ext.min, ext.max),
              true,
              null, {
                trigger: 'navigator'
              }
            );
          }
        }
      },
      handlesMousedown: function(e, index) {
        e = this.chart.pointer.normalize(e);
        var navigator = this,
          chart = navigator.chart,
          baseXAxis = chart.xAxis[0],
          reverse = (chart.inverted && !baseXAxis.reversed) ||
          (!chart.inverted && baseXAxis.reversed);
        if (index === 0) {
          navigator.grabbedLeft = true;
          navigator.otherHandlePos = navigator.zoomedMax;
          navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
        } else {
          navigator.grabbedRight = true;
          navigator.otherHandlePos = navigator.zoomedMin;
          navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
        }
        chart.fixedRange = null;
      },
      onMouseMove: function(e) {
        var navigator = this,
          chart = navigator.chart,
          left = navigator.left,
          navigatorSize = navigator.navigatorSize,
          range = navigator.range,
          dragOffset = navigator.dragOffset,
          inverted = chart.inverted,
          chartX;
        if (!e.touches || e.touches[0].pageX !== 0) {
          e = chart.pointer.normalize(e);
          chartX = e.chartX;
          if (inverted) {
            left = navigator.top;
            chartX = e.chartY;
          }
          if (navigator.grabbedLeft) {
            navigator.hasDragged = true;
            navigator.render(
              0,
              0,
              chartX - left,
              navigator.otherHandlePos
            );
          } else if (navigator.grabbedRight) {
            navigator.hasDragged = true;
            navigator.render(
              0,
              0,
              navigator.otherHandlePos,
              chartX - left
            );
          } else if (navigator.grabbedCenter) {
            navigator.hasDragged = true;
            if (chartX < dragOffset) {
              chartX = dragOffset;
            } else if (chartX > navigatorSize + dragOffset - range) {
              chartX = navigatorSize + dragOffset - range;
            }
            navigator.render(
              0,
              0,
              chartX - dragOffset,
              chartX - dragOffset + range
            );
          }
          if (navigator.hasDragged && navigator.scrollbar && navigator.scrollbar.options.liveRedraw) {
            e.DOMType = e.type;
            setTimeout(function() {
              navigator.onMouseUp(e);
            }, 0);
          }
        }
      },
      onMouseUp: function(e) {
        var navigator = this,
          chart = navigator.chart,
          xAxis = navigator.xAxis,
          fixedMin,
          fixedMax,
          ext,
          DOMEvent = e.DOMEvent || e;
        if (navigator.hasDragged || e.trigger === 'scrollbar') {
          if (navigator.zoomedMin === navigator.otherHandlePos) {
            fixedMin = navigator.fixedExtreme;
          } else if (navigator.zoomedMax === navigator.otherHandlePos) {
            fixedMax = navigator.fixedExtreme;
          }
          if (navigator.zoomedMax === navigator.navigatorSize) {
            fixedMax = navigator.getUnionExtremes().dataMax;
          }
          ext = xAxis.toFixedRange(
            navigator.zoomedMin,
            navigator.zoomedMax,
            fixedMin,
            fixedMax
          );
          if (defined(ext.min)) {
            chart.xAxis[0].setExtremes(
              Math.min(ext.min, ext.max),
              Math.max(ext.min, ext.max),
              true,
              navigator.hasDragged ? false : null, {
                trigger: 'navigator',
                triggerOp: 'navigator-drag',
                DOMEvent: DOMEvent
              }
            );
          }
        }
        if (e.DOMType !== 'mousemove') {
          navigator.grabbedLeft = navigator.grabbedRight =
            navigator.grabbedCenter = navigator.fixedWidth =
            navigator.fixedExtreme = navigator.otherHandlePos =
            navigator.hasDragged = navigator.dragOffset = null;
        }
      },
      removeEvents: function() {
        if (this.eventsToUnbind) {
          each(this.eventsToUnbind, function(unbind) {
            unbind();
          });
          this.eventsToUnbind = undefined;
        }
        this.removeBaseSeriesEvents();
      },
      removeBaseSeriesEvents: function() {
        var baseSeries = this.baseSeries || [];
        if (this.navigatorEnabled && baseSeries[0] && this.navigatorOptions.adaptToUpdatedData !== false) {
          each(baseSeries, function(series) {
            removeEvent(series, 'updatedData', this.updatedDataHandler);
          }, this);
          if (baseSeries[0].xAxis) {
            removeEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);
          }
        }
      },
      init: function(chart) {
        var chartOptions = chart.options,
          navigatorOptions = chartOptions.navigator,
          navigatorEnabled = navigatorOptions.enabled,
          scrollbarOptions = chartOptions.scrollbar,
          scrollbarEnabled = scrollbarOptions.enabled,
          height = navigatorEnabled ? navigatorOptions.height : 0,
          scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;
        this.handles = [];
        this.shades = [];
        this.chart = chart;
        this.setBaseSeries();
        this.height = height;
        this.scrollbarHeight = scrollbarHeight;
        this.scrollbarEnabled = scrollbarEnabled;
        this.navigatorEnabled = navigatorEnabled;
        this.navigatorOptions = navigatorOptions;
        this.scrollbarOptions = scrollbarOptions;
        this.outlineHeight = height + scrollbarHeight;
        var navigator = this,
          baseSeries = navigator.baseSeries,
          xAxisIndex = chart.xAxis.length,
          yAxisIndex = chart.yAxis.length,
          baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0];
        chart.extraMargin = {
          type: navigatorOptions.opposite ? 'plotTop' : 'marginBottom',
          value: navigator.outlineHeight + navigatorOptions.margin
        };
        if (chart.inverted) {
          chart.extraMargin.type = navigatorOptions.opposite ? 'marginRight' : 'plotLeft';
        }
        chart.isDirtyBox = true;
        if (navigator.navigatorEnabled) {
          navigator.xAxis = new Axis(chart, merge({
            breaks: baseXaxis.options.breaks,
            ordinal: baseXaxis.options.ordinal
          }, navigatorOptions.xAxis, {
            id: 'navigator-x-axis',
            yAxis: 'navigator-y-axis',
            isX: true,
            type: 'datetime',
            index: xAxisIndex,
            offset: 0,
            keepOrdinalPadding: true,
            startOnTick: false,
            endOnTick: false,
            minPadding: 0,
            maxPadding: 0,
            zoomEnabled: false
          }, chart.inverted ? {
            offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
            width: height
          } : {
            offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
            height: height
          }));
          navigator.yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {
            id: 'navigator-y-axis',
            alignTicks: false,
            offset: 0,
            index: yAxisIndex,
            zoomEnabled: false
          }, chart.inverted ? {
            width: height
          } : {
            height: height
          }));
          if (baseSeries || navigatorOptions.series.data) {
            navigator.addBaseSeries();
          } else if (chart.series.length === 0) {
            wrap(chart, 'redraw', function(proceed, animation) {
              if (chart.series.length > 0 && !navigator.series) {
                navigator.setBaseSeries();
                chart.redraw = proceed;
              }
              proceed.call(chart, animation);
            });
          }
          navigator.renderElements();
          navigator.addMouseEvents();
        } else {
          navigator.xAxis = {
            translate: function(value, reverse) {
              var axis = chart.xAxis[0],
                ext = axis.getExtremes(),
                scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,
                min = numExt('min', axis.options.min, ext.dataMin),
                valueRange = numExt('max', axis.options.max, ext.dataMax) - min;
              return reverse ?
                (value * valueRange / scrollTrackWidth) + min :
                scrollTrackWidth * (value - min) / valueRange;
            },
            toPixels: function(value) {
              return this.translate(value);
            },
            toValue: function(value) {
              return this.translate(value, true);
            },
            toFixedRange: Axis.prototype.toFixedRange,
            fake: true
          };
        }
        if (chart.options.scrollbar.enabled) {
          chart.scrollbar = navigator.scrollbar = new Scrollbar(
            chart.renderer,
            merge(chart.options.scrollbar, {
              margin: navigator.navigatorEnabled ? 0 : 10,
              vertical: chart.inverted
            }),
            chart
          );
          addEvent(navigator.scrollbar, 'changed', function(e) {
            var range = navigator.size,
              to = range * this.to,
              from = range * this.from;
            navigator.hasDragged = navigator.scrollbar.hasDragged;
            navigator.render(0, 0, from, to);
            if (chart.options.scrollbar.liveRedraw || e.DOMType !== 'mousemove') {
              setTimeout(function() {
                navigator.onMouseUp(e);
              });
            }
          });
        }
        navigator.addBaseSeriesEvents();
        navigator.addChartEvents();
      },
      getUnionExtremes: function(returnFalseOnNoBaseSeries) {
        var baseAxis = this.chart.xAxis[0],
          navAxis = this.xAxis,
          navAxisOptions = navAxis.options,
          baseAxisOptions = baseAxis.options,
          ret;
        if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
          ret = {
            dataMin: pick(
              navAxisOptions && navAxisOptions.min,
              numExt(
                'min',
                baseAxisOptions.min,
                baseAxis.dataMin,
                navAxis.dataMin,
                navAxis.min
              )
            ),
            dataMax: pick(
              navAxisOptions && navAxisOptions.max,
              numExt(
                'max',
                baseAxisOptions.max,
                baseAxis.dataMax,
                navAxis.dataMax,
                navAxis.max
              )
            )
          };
        }
        return ret;
      },
      setBaseSeries: function(baseSeriesOptions) {
        var chart = this.chart,
          baseSeries = this.baseSeries = [];
        baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || 0;
        if (this.series) {
          this.removeBaseSeriesEvents();
          each(this.series, function(s) {
            s.destroy();
          });
        }
        each(chart.series || [], function(series, i) {
          if (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) &&
            series.options.showInNavigator !== false) {
            baseSeries.push(series);
          }
        });
        if (this.xAxis && !this.xAxis.fake) {
          this.addBaseSeries();
        }
      },
      addBaseSeries: function() {
        var navigator = this,
          chart = navigator.chart,
          navigatorSeries = navigator.series = [],
          baseSeries = navigator.baseSeries,
          baseOptions,
          mergedNavSeriesOptions,
          chartNavigatorOptions = navigator.navigatorOptions.series,
          baseNavigatorOptions,
          navSeriesMixin = {
            enableMouseTracking: false,
            index: null,
            group: 'nav',
            padXAxis: false,
            xAxis: 'navigator-x-axis',
            yAxis: 'navigator-y-axis',
            showInLegend: false,
            stacking: false,
            isInternal: true,
            visible: true
          };
        if (baseSeries) {
          each(baseSeries, function(base, i) {
            navSeriesMixin.name = 'Navigator ' + (i + 1);
            baseOptions = base.options || {};
            baseNavigatorOptions = baseOptions.navigatorOptions || {};
            mergedNavSeriesOptions = merge(baseOptions, navSeriesMixin, chartNavigatorOptions, baseNavigatorOptions);
            var navigatorSeriesData = baseNavigatorOptions.data || chartNavigatorOptions.data;
            navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
            mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0);
            base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
            navigatorSeries.push(base.navigatorSeries);
          });
        } else {
          mergedNavSeriesOptions = merge(chartNavigatorOptions, navSeriesMixin);
          mergedNavSeriesOptions.data = chartNavigatorOptions.data;
          navigator.hasNavigatorData = !!mergedNavSeriesOptions.data;
          navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
        }
        this.addBaseSeriesEvents();
      },
      addBaseSeriesEvents: function() {
        var navigator = this,
          baseSeries = navigator.baseSeries || [];
        if (baseSeries[0] && baseSeries[0].xAxis) {
          addEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);
        }
        if (this.navigatorOptions.adaptToUpdatedData !== false) {
          each(baseSeries, function(base) {
            if (base.xAxis) {
              addEvent(base, 'updatedData', this.updatedDataHandler);
              base.userOptions.events = extend(base.userOptions.event, {
                updatedData: this.updatedDataHandler
              });
            }
            addEvent(base, 'remove', function() {
              if (this.navigatorSeries) {
                erase(navigator.series, this.navigatorSeries);
                this.navigatorSeries.remove();
                delete this.navigatorSeries;
              }
            });
          }, this);
        }
      },
      modifyNavigatorAxisExtremes: function() {
        var xAxis = this.xAxis,
          unionExtremes;
        if (xAxis.getExtremes) {
          unionExtremes = this.getUnionExtremes(true);
          if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
            xAxis.min = unionExtremes.dataMin;
            xAxis.max = unionExtremes.dataMax;
          }
        }
      },
      modifyBaseAxisExtremes: function() {
        var baseXAxis = this,
          navigator = baseXAxis.chart.navigator,
          baseExtremes = baseXAxis.getExtremes(),
          baseMin = baseExtremes.min,
          baseMax = baseExtremes.max,
          baseDataMin = baseExtremes.dataMin,
          baseDataMax = baseExtremes.dataMax,
          range = baseMax - baseMin,
          stickToMin = navigator.stickToMin,
          stickToMax = navigator.stickToMax,
          newMax,
          newMin,
          navigatorSeries = navigator.series && navigator.series[0],
          hasSetExtremes = !!baseXAxis.setExtremes,
          unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === 'rangeSelectorButton';
        if (!unmutable) {
          if (stickToMin) {
            newMin = baseDataMin;
            newMax = newMin + range;
          }
          if (stickToMax) {
            newMax = baseDataMax;
            if (!stickToMin) {
              newMin = Math.max(
                newMax - range,
                navigatorSeries && navigatorSeries.xData ?
                navigatorSeries.xData[0] : -Number.MAX_VALUE
              );
            }
          }
          if (hasSetExtremes && (stickToMin || stickToMax)) {
            if (isNumber(newMin)) {
              baseXAxis.min = baseXAxis.userMin = newMin;
              baseXAxis.max = baseXAxis.userMax = newMax;
            }
          }
        }
        navigator.stickToMin = navigator.stickToMax = null;
      },
      updatedDataHandler: function() {
        var navigator = this.chart.navigator,
          baseSeries = this,
          navigatorSeries = this.navigatorSeries;
        navigator.stickToMin = isNumber(baseSeries.xAxis.min) && (baseSeries.xAxis.min <= baseSeries.xData[0]);
        navigator.stickToMax = Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
        if (navigatorSeries && !navigator.hasNavigatorData) {
          navigatorSeries.options.pointStart = baseSeries.xData[0];
          navigatorSeries.setData(baseSeries.options.data, false, null, false);
        }
      },
      addChartEvents: function() {
        addEvent(this.chart, 'redraw', function() {
          var navigator = this.navigator,
            xAxis = navigator && (
              navigator.baseSeries &&
              navigator.baseSeries[0] &&
              navigator.baseSeries[0].xAxis ||
              navigator.scrollbar && this.xAxis[0]
            );
          if (xAxis) {
            navigator.render(xAxis.min, xAxis.max);
          }
        });
      },
      destroy: function() {
        this.removeEvents();
        if (this.xAxis) {
          erase(this.chart.xAxis, this.xAxis);
          erase(this.chart.axes, this.xAxis);
        }
        if (this.yAxis) {
          erase(this.chart.yAxis, this.yAxis);
          erase(this.chart.axes, this.yAxis);
        }
        each(this.series || [], function(s) {
          if (s.destroy) {
            s.destroy();
          }
        });
        each([
          'series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack',
          'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup',
          'rendered'
        ], function(prop) {
          if (this[prop] && this[prop].destroy) {
            this[prop].destroy();
          }
          this[prop] = null;
        }, this);
        each([this.handles], function(coll) {
          destroyObjectProperties(coll);
        }, this);
      }
    };
    H.Navigator = Navigator;
    wrap(Axis.prototype, 'zoom', function(proceed, newMin, newMax) {
      var chart = this.chart,
        chartOptions = chart.options,
        zoomType = chartOptions.chart.zoomType,
        previousZoom,
        navigator = chartOptions.navigator,
        rangeSelector = chartOptions.rangeSelector,
        ret;
      if (this.isXAxis && ((navigator && navigator.enabled) ||
          (rangeSelector && rangeSelector.enabled))) {
        if (zoomType === 'x') {
          chart.resetZoomButton = 'blocked';
        } else if (zoomType === 'y') {
          ret = false;
        } else if (zoomType === 'xy') {
          previousZoom = this.previousZoom;
          if (defined(newMin)) {
            this.previousZoom = [this.min, this.max];
          } else if (previousZoom) {
            newMin = previousZoom[0];
            newMax = previousZoom[1];
            delete this.previousZoom;
          }
        }
      }
      return ret !== undefined ? ret : proceed.call(this, newMin, newMax);
    });
    wrap(Chart.prototype, 'init', function(proceed, options, callback) {
      addEvent(this, 'beforeRender', function() {
        var options = this.options;
        if (options.navigator.enabled || options.scrollbar.enabled) {
          this.scroller = this.navigator = new Navigator(this);
        }
      });
      proceed.call(this, options, callback);
    });
    wrap(Chart.prototype, 'setChartSize', function(proceed) {
      var legend = this.legend,
        navigator = this.navigator,
        scrollbarHeight,
        legendOptions,
        xAxis,
        yAxis;
      proceed.apply(this, [].slice.call(arguments, 1));
      if (navigator) {
        legendOptions = legend && legend.options;
        xAxis = navigator.xAxis;
        yAxis = navigator.yAxis;
        scrollbarHeight = navigator.scrollbarHeight;
        if (this.inverted) {
          navigator.left = navigator.navigatorOptions.opposite ?
            this.chartWidth - scrollbarHeight - navigator.height :
            this.spacing[3] + scrollbarHeight;
          navigator.top = this.plotTop + scrollbarHeight;
        } else {
          navigator.left = this.plotLeft + scrollbarHeight;
          navigator.top = navigator.navigatorOptions.top ||
            this.chartHeight - navigator.height - scrollbarHeight - this.spacing[2] -
            (legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ?
              legend.legendHeight + pick(legendOptions.margin, 10) : 0);
        }
        if (xAxis && yAxis) {
          if (this.inverted) {
            xAxis.options.left = yAxis.options.left = navigator.left;
          } else {
            xAxis.options.top = yAxis.options.top = navigator.top;
          }
          xAxis.setAxisSize();
          yAxis.setAxisSize();
        }
      }
    });
    wrap(Series.prototype, 'addPoint', function(proceed, options, redraw, shift, animation) {
      var turboThreshold = this.options.turboThreshold;
      if (turboThreshold && this.xData.length > turboThreshold && isObject(options, true) && this.chart.navigator) {
        error(20, true);
      }
      proceed.call(this, options, redraw, shift, animation);
    });
    wrap(Chart.prototype, 'addSeries', function(proceed, options, redraw, animation) {
      var series = proceed.call(this, options, false, animation);
      if (this.navigator) {
        this.navigator.setBaseSeries();
      }
      if (pick(redraw, true)) {
        this.redraw();
      }
      return series;
    });
    wrap(Series.prototype, 'update', function(proceed, newOptions, redraw) {
      proceed.call(this, newOptions, false);
      if (this.chart.navigator) {
        this.chart.navigator.setBaseSeries();
      }
      if (pick(redraw, true)) {
        this.chart.redraw();
      }
    });
    Chart.prototype.callbacks.push(function(chart) {
      var extremes,
        navigator = chart.navigator;
      if (navigator) {
        extremes = chart.xAxis[0].getExtremes();
        navigator.render(extremes.min, extremes.max);
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var addEvent = H.addEvent,
      Axis = H.Axis,
      Chart = H.Chart,
      css = H.css,
      createElement = H.createElement,
      dateFormat = H.dateFormat,
      defaultOptions = H.defaultOptions,
      useUTC = defaultOptions.global.useUTC,
      defined = H.defined,
      destroyObjectProperties = H.destroyObjectProperties,
      discardElement = H.discardElement,
      each = H.each,
      extend = H.extend,
      fireEvent = H.fireEvent,
      HCDate = H.Date,
      isNumber = H.isNumber,
      merge = H.merge,
      pick = H.pick,
      pInt = H.pInt,
      splat = H.splat,
      wrap = H.wrap;
    extend(defaultOptions, {
      rangeSelector: {
        buttonTheme: {
          'stroke-width': 0,
          width: 28,
          height: 18,
          padding: 2,
          zIndex: 7
        },
        height: 35,
        inputPosition: {
          align: 'right'
        },
        labelStyle: {
          color: '#666666'
        }
      }
    });
    defaultOptions.lang = merge(defaultOptions.lang, {
      rangeSelectorZoom: 'Zoom',
      rangeSelectorFrom: 'From',
      rangeSelectorTo: 'To'
    });

    function RangeSelector(chart) {
      this.init(chart);
    }
    RangeSelector.prototype = {
      clickButton: function(i, redraw) {
        var rangeSelector = this,
          chart = rangeSelector.chart,
          rangeOptions = rangeSelector.buttonOptions[i],
          baseAxis = chart.xAxis[0],
          unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},
          dataMin = unionExtremes.dataMin,
          dataMax = unionExtremes.dataMax,
          newMin,
          newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))),
          type = rangeOptions.type,
          baseXAxisOptions,
          range = rangeOptions._range,
          rangeMin,
          minSetting,
          rangeSetting,
          ctx,
          ytdExtremes,
          dataGrouping = rangeOptions.dataGrouping;
        if (dataMin === null || dataMax === null) {
          return;
        }
        chart.fixedRange = range;
        if (dataGrouping) {
          this.forcedDataGrouping = true;
          Axis.prototype.setDataGrouping.call(baseAxis || {
            chart: this.chart
          }, dataGrouping, false);
        }
        if (type === 'month' || type === 'year') {
          if (!baseAxis) {
            range = rangeOptions;
          } else {
            ctx = {
              range: rangeOptions,
              max: newMax,
              dataMin: dataMin,
              dataMax: dataMax
            };
            newMin = baseAxis.minFromRange.call(ctx);
            if (isNumber(ctx.newMax)) {
              newMax = ctx.newMax;
            }
          }
        } else if (range) {
          newMin = Math.max(newMax - range, dataMin);
          newMax = Math.min(newMin + range, dataMax);
        } else if (type === 'ytd') {
          if (baseAxis) {
            if (dataMax === undefined) {
              dataMin = Number.MAX_VALUE;
              dataMax = Number.MIN_VALUE;
              each(chart.series, function(series) {
                var xData = series.xData;
                dataMin = Math.min(xData[0], dataMin);
                dataMax = Math.max(xData[xData.length - 1], dataMax);
              });
              redraw = false;
            }
            ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, useUTC);
            newMin = rangeMin = ytdExtremes.min;
            newMax = ytdExtremes.max;
          } else {
            addEvent(chart, 'beforeRender', function() {
              rangeSelector.clickButton(i);
            });
            return;
          }
        } else if (type === 'all' && baseAxis) {
          newMin = dataMin;
          newMax = dataMax;
        }
        rangeSelector.setSelected(i);
        if (!baseAxis) {
          baseXAxisOptions = splat(chart.options.xAxis)[0];
          rangeSetting = baseXAxisOptions.range;
          baseXAxisOptions.range = range;
          minSetting = baseXAxisOptions.min;
          baseXAxisOptions.min = rangeMin;
          addEvent(chart, 'load', function resetMinAndRange() {
            baseXAxisOptions.range = rangeSetting;
            baseXAxisOptions.min = minSetting;
          });
        } else {
          baseAxis.setExtremes(
            newMin,
            newMax,
            pick(redraw, 1),
            null, {
              trigger: 'rangeSelectorButton',
              rangeSelectorButton: rangeOptions
            }
          );
        }
      },
      setSelected: function(selected) {
        this.selected = this.options.selected = selected;
      },
      defaultButtons: [{
        type: 'month',
        count: 1,
        text: '1m'
      }, {
        type: 'month',
        count: 3,
        text: '3m'
      }, {
        type: 'month',
        count: 6,
        text: '6m'
      }, {
        type: 'ytd',
        text: 'YTD'
      }, {
        type: 'year',
        count: 1,
        text: '1y'
      }, {
        type: 'all',
        text: 'All'
      }],
      init: function(chart) {
        var rangeSelector = this,
          options = chart.options.rangeSelector,
          buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),
          selectedOption = options.selected,
          blurInputs = function() {
            var minInput = rangeSelector.minInput,
              maxInput = rangeSelector.maxInput;
            if (minInput && minInput.blur) {
              fireEvent(minInput, 'blur');
            }
            if (maxInput && maxInput.blur) {
              fireEvent(maxInput, 'blur');
            }
          };
        rangeSelector.chart = chart;
        rangeSelector.options = options;
        rangeSelector.buttons = [];
        chart.extraTopMargin = options.height;
        rangeSelector.buttonOptions = buttonOptions;
        this.unMouseDown = addEvent(chart.container, 'mousedown', blurInputs);
        this.unResize = addEvent(chart, 'resize', blurInputs);
        each(buttonOptions, rangeSelector.computeButtonRange);
        if (selectedOption !== undefined && buttonOptions[selectedOption]) {
          this.clickButton(selectedOption, false);
        }
        addEvent(chart, 'load', function() {
          addEvent(chart.xAxis[0], 'setExtremes', function(e) {
            if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' &&
              e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping) {
              this.setDataGrouping(false, false);
            }
          });
        });
      },
      updateButtonStates: function() {
        var rangeSelector = this,
          chart = this.chart,
          baseAxis = chart.xAxis[0],
          actualRange = Math.round(baseAxis.max - baseAxis.min),
          hasNoData = !baseAxis.hasVisibleSeries,
          day = 24 * 36e5,
          unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis,
          dataMin = unionExtremes.dataMin,
          dataMax = unionExtremes.dataMax,
          ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, useUTC),
          ytdMin = ytdExtremes.min,
          ytdMax = ytdExtremes.max,
          selected = rangeSelector.selected,
          selectedExists = isNumber(selected),
          allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
          buttons = rangeSelector.buttons;
        each(rangeSelector.buttonOptions, function(rangeOptions, i) {
          var range = rangeOptions._range,
            type = rangeOptions.type,
            count = rangeOptions.count || 1,
            button = buttons[i],
            state = 0,
            disable,
            select,
            isSelected = i === selected,
            isTooGreatRange = range > dataMax - dataMin,
            isTooSmallRange = range < baseAxis.minRange,
            isYTDButNotSelected = false,
            isAllButAlreadyShowingAll = false,
            isSameRange = range === actualRange;
          if (
            (type === 'month' || type === 'year') &&
            (actualRange >= {
              month: 28,
              year: 365
            } [type] * day * count) &&
            (actualRange <= {
              month: 31,
              year: 366
            } [type] * day * count)
          ) {
            isSameRange = true;
          } else if (type === 'ytd') {
            isSameRange = (ytdMax - ytdMin) === actualRange;
            isYTDButNotSelected = !isSelected;
          } else if (type === 'all') {
            isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
            isAllButAlreadyShowingAll = !isSelected && selectedExists && isSameRange;
          }
          disable = (!allButtonsEnabled &&
            (
              isTooGreatRange ||
              isTooSmallRange ||
              isAllButAlreadyShowingAll ||
              hasNoData
            )
          );
          select = (
            (isSelected && isSameRange) ||
            (isSameRange && !selectedExists && !isYTDButNotSelected)
          );
          if (disable) {
            state = 3;
          } else if (select) {
            selectedExists = true;
            state = 2;
          }
          if (button.state !== state) {
            button.setState(state);
          }
        });
      },
      computeButtonRange: function(rangeOptions) {
        var type = rangeOptions.type,
          count = rangeOptions.count || 1,
          fixedTimes = {
            millisecond: 1,
            second: 1000,
            minute: 60 * 1000,
            hour: 3600 * 1000,
            day: 24 * 3600 * 1000,
            week: 7 * 24 * 3600 * 1000
          };
        if (fixedTimes[type]) {
          rangeOptions._range = fixedTimes[type] * count;
        } else if (type === 'month' || type === 'year') {
          rangeOptions._range = {
            month: 30,
            year: 365
          } [type] * 24 * 36e5 * count;
        }
      },
      setInputValue: function(name, time) {
        var options = this.chart.options.rangeSelector,
          input = this[name + 'Input'];
        if (defined(time)) {
          input.previousValue = input.HCTime;
          input.HCTime = time;
        }
        input.value = dateFormat(
          options.inputEditDateFormat || '%Y-%m-%d',
          input.HCTime
        );
        this[name + 'DateBox'].attr({
          text: dateFormat(options.inputDateFormat || '%b %e, %Y', input.HCTime)
        });
      },
      showInput: function(name) {
        var inputGroup = this.inputGroup,
          dateBox = this[name + 'DateBox'];
        css(this[name + 'Input'], {
          left: (inputGroup.translateX + dateBox.x) + 'px',
          top: inputGroup.translateY + 'px',
          width: (dateBox.width - 2) + 'px',
          height: (dateBox.height - 2) + 'px',
          border: '2px solid silver'
        });
      },
      hideInput: function(name) {
        css(this[name + 'Input'], {
          border: 0,
          width: '1px',
          height: '1px'
        });
        this.setInputValue(name);
      },
      drawInput: function(name) {
        var rangeSelector = this,
          chart = rangeSelector.chart,
          chartStyle = chart.renderer.style || {},
          renderer = chart.renderer,
          options = chart.options.rangeSelector,
          lang = defaultOptions.lang,
          div = rangeSelector.div,
          isMin = name === 'min',
          input,
          label,
          dateBox,
          inputGroup = this.inputGroup;

        function updateExtremes() {
          var inputValue = input.value,
            value = (options.inputDateParser || Date.parse)(inputValue),
            chartAxis = chart.xAxis[0],
            dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis,
            dataMin = dataAxis.dataMin,
            dataMax = dataAxis.dataMax;
          if (value !== input.previousValue) {
            input.previousValue = value;
            if (!isNumber(value)) {
              value = inputValue.split('-');
              value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
            }
            if (isNumber(value)) {
              if (!useUTC) {
                value = value + new Date().getTimezoneOffset() * 60 * 1000;
              }
              if (isMin) {
                if (value > rangeSelector.maxInput.HCTime) {
                  value = undefined;
                } else if (value < dataMin) {
                  value = dataMin;
                }
              } else {
                if (value < rangeSelector.minInput.HCTime) {
                  value = undefined;
                } else if (value > dataMax) {
                  value = dataMax;
                }
              }
              if (value !== undefined) {
                chartAxis.setExtremes(
                  isMin ? value : chartAxis.min,
                  isMin ? chartAxis.max : value,
                  undefined,
                  undefined, {
                    trigger: 'rangeSelectorInput'
                  }
                );
              }
            }
          }
        }
        this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)
          .addClass('highcharts-range-label')
          .attr({
            padding: 2
          })
          .add(inputGroup);
        inputGroup.offset += label.width + 5;
        this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)
          .addClass('highcharts-range-input')
          .attr({
            padding: 2,
            width: options.inputBoxWidth || 90,
            height: options.inputBoxHeight || 17,
            stroke: options.inputBoxBorderColor || '#cccccc',
            'stroke-width': 1,
            'text-align': 'center'
          })
          .on('click', function() {
            rangeSelector.showInput(name);
            rangeSelector[name + 'Input'].focus();
          })
          .add(inputGroup);
        inputGroup.offset += dateBox.width + (isMin ? 10 : 0);
        this[name + 'Input'] = input = createElement('input', {
          name: name,
          className: 'highcharts-range-selector',
          type: 'text'
        }, {
          top: chart.plotTop + 'px'
        }, div);
        label.css(merge(chartStyle, options.labelStyle));
        dateBox.css(merge({
          color: '#333333'
        }, chartStyle, options.inputStyle));
        css(input, extend({
          position: 'absolute',
          border: 0,
          width: '1px',
          height: '1px',
          padding: 0,
          textAlign: 'center',
          fontSize: chartStyle.fontSize,
          fontFamily: chartStyle.fontFamily,
          left: '-9em'
        }, options.inputStyle));
        input.onfocus = function() {
          rangeSelector.showInput(name);
        };
        input.onblur = function() {
          rangeSelector.hideInput(name);
        };
        input.onchange = updateExtremes;
        input.onkeypress = function(event) {
          if (event.keyCode === 13) {
            updateExtremes();
          }
        };
      },
      getPosition: function() {
        var chart = this.chart,
          options = chart.options.rangeSelector,
          buttonTop = pick((options.buttonPosition || {}).y, chart.plotTop - chart.axisOffset[0] - options.height);
        return {
          buttonTop: buttonTop,
          inputTop: buttonTop - 10
        };
      },
      getYTDExtremes: function(dataMax, dataMin, useUTC) {
        var min,
          now = new HCDate(dataMax),
          year = now[HCDate.hcGetFullYear](),
          startOfYear = useUTC ? HCDate.UTC(year, 0, 1) : +new HCDate(year, 0, 1);
        min = Math.max(dataMin || 0, startOfYear);
        now = now.getTime();
        return {
          max: Math.min(dataMax || now, now),
          min: min
        };
      },
      render: function(min, max) {
        var rangeSelector = this,
          chart = rangeSelector.chart,
          renderer = chart.renderer,
          container = chart.container,
          chartOptions = chart.options,
          navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false &&
          chartOptions.navigation && chartOptions.navigation.buttonOptions,
          options = chartOptions.rangeSelector,
          buttons = rangeSelector.buttons,
          lang = defaultOptions.lang,
          div = rangeSelector.div,
          inputGroup = rangeSelector.inputGroup,
          buttonTheme = options.buttonTheme,
          buttonPosition = options.buttonPosition || {},
          inputEnabled = options.inputEnabled,
          states = buttonTheme && buttonTheme.states,
          plotLeft = chart.plotLeft,
          buttonLeft,
          pos = this.getPosition(),
          buttonGroup = rangeSelector.group,
          buttonBBox,
          rendered = rangeSelector.rendered;
        if (options.enabled === false) {
          return;
        }
        if (!rendered) {
          rangeSelector.group = buttonGroup = renderer.g('range-selector-buttons').add();
          rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), 15)
            .css(options.labelStyle)
            .add(buttonGroup);
          buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;
          each(rangeSelector.buttonOptions, function(rangeOptions, i) {
            buttons[i] = renderer.button(
                rangeOptions.text,
                buttonLeft,
                0,
                function() {
                  rangeSelector.clickButton(i);
                  rangeSelector.isActive = true;
                },
                buttonTheme,
                states && states.hover,
                states && states.select,
                states && states.disabled
              )
              .attr({
                'text-align': 'center'
              })
              .add(buttonGroup);
            buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);
          });
          if (inputEnabled !== false) {
            rangeSelector.div = div = createElement('div', null, {
              position: 'relative',
              height: 0,
              zIndex: 1
            });
            container.parentNode.insertBefore(div, container);
            rangeSelector.inputGroup = inputGroup = renderer.g('input-group')
              .add();
            inputGroup.offset = 0;
            rangeSelector.drawInput('min');
            rangeSelector.drawInput('max');
          }
        }
        rangeSelector.updateButtonStates();
        buttonGroup[rendered ? 'animate' : 'attr']({
          translateY: pos.buttonTop
        });
        if (inputEnabled !== false) {
          inputGroup.align(extend({
            y: pos.inputTop,
            width: inputGroup.offset,
            x: navButtonOptions && (pos.inputTop < (navButtonOptions.y || 0) + navButtonOptions.height - chart.spacing[0]) ?
              -40 : 0
          }, options.inputPosition), true, chart.spacingBox);
          if (!defined(inputEnabled)) {
            buttonBBox = buttonGroup.getBBox();
            inputGroup[inputGroup.alignAttr.translateX < buttonBBox.x + buttonBBox.width + 10 ? 'hide' : 'show']();
          }
          rangeSelector.setInputValue('min', min);
          rangeSelector.setInputValue('max', max);
        }
        rangeSelector.rendered = true;
      },
      update: function(options) {
        var chart = this.chart;
        merge(true, chart.options.rangeSelector, options);
        this.destroy();
        this.init(chart);
      },
      destroy: function() {
        var minInput = this.minInput,
          maxInput = this.maxInput,
          key;
        this.unMouseDown();
        this.unResize();
        destroyObjectProperties(this.buttons);
        if (minInput) {
          minInput.onfocus = minInput.onblur = minInput.onchange = null;
        }
        if (maxInput) {
          maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
        }
        for (key in this) {
          if (this[key] && key !== 'chart') {
            if (this[key].destroy) {
              this[key].destroy();
            } else if (this[key].nodeType) {
              discardElement(this[key]);
            }
          }
          if (this[key] !== RangeSelector.prototype[key]) {
            this[key] = null;
          }
        }
      }
    };
    Axis.prototype.toFixedRange = function(pxMin, pxMax, fixedMin, fixedMax) {
      var fixedRange = this.chart && this.chart.fixedRange,
        newMin = pick(fixedMin, this.translate(pxMin, true, !this.horiz)),
        newMax = pick(fixedMax, this.translate(pxMax, true, !this.horiz)),
        changeRatio = fixedRange && (newMax - newMin) / fixedRange;
      if (changeRatio > 0.7 && changeRatio < 1.3) {
        if (fixedMax) {
          newMin = newMax - fixedRange;
        } else {
          newMax = newMin + fixedRange;
        }
      }
      if (!isNumber(newMin)) {
        newMin = newMax = undefined;
      }
      return {
        min: newMin,
        max: newMax
      };
    };
    Axis.prototype.minFromRange = function() {
      var rangeOptions = this.range,
        type = rangeOptions.type,
        timeName = {
          month: 'Month',
          year: 'FullYear'
        } [type],
        min,
        max = this.max,
        dataMin,
        range,
        getTrueRange = function(base, count) {
          var date = new Date(base);
          date['set' + timeName](date['get' + timeName]() + count);
          return date.getTime() - base;
        };
      if (isNumber(rangeOptions)) {
        min = max - rangeOptions;
        range = rangeOptions;
      } else {
        min = max + getTrueRange(max, -rangeOptions.count);
        if (this.chart) {
          this.chart.fixedRange = max - min;
        }
      }
      dataMin = pick(this.dataMin, Number.MIN_VALUE);
      if (!isNumber(min)) {
        min = dataMin;
      }
      if (min <= dataMin) {
        min = dataMin;
        if (range === undefined) {
          range = getTrueRange(min, rangeOptions.count);
        }
        this.newMax = Math.min(min + range, this.dataMax);
      }
      if (!isNumber(max)) {
        min = undefined;
      }
      return min;
    };
    wrap(Chart.prototype, 'init', function(proceed, options, callback) {
      addEvent(this, 'init', function() {
        if (this.options.rangeSelector.enabled) {
          this.rangeSelector = new RangeSelector(this);
        }
      });
      proceed.call(this, options, callback);
    });
    Chart.prototype.callbacks.push(function(chart) {
      var extremes,
        rangeSelector = chart.rangeSelector,
        unbindRender,
        unbindSetExtremes;

      function renderRangeSelector() {
        extremes = chart.xAxis[0].getExtremes();
        if (isNumber(extremes.min)) {
          rangeSelector.render(extremes.min, extremes.max);
        }
      }
      if (rangeSelector) {
        unbindSetExtremes = addEvent(
          chart.xAxis[0],
          'afterSetExtremes',
          function(e) {
            rangeSelector.render(e.min, e.max);
          }
        );
        unbindRender = addEvent(chart, 'redraw', renderRangeSelector);
        renderRangeSelector();
      }
      addEvent(chart, 'destroy', function destroyEvents() {
        if (rangeSelector) {
          unbindRender();
          unbindSetExtremes();
        }
      });
    });
    H.RangeSelector = RangeSelector;
  }(Highcharts));
  (function(H) {
    'use strict';
    var arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      Axis = H.Axis,
      Chart = H.Chart,
      defined = H.defined,
      each = H.each,
      extend = H.extend,
      format = H.format,
      inArray = H.inArray,
      isNumber = H.isNumber,
      isString = H.isString,
      map = H.map,
      merge = H.merge,
      pick = H.pick,
      Point = H.Point,
      Renderer = H.Renderer,
      Series = H.Series,
      splat = H.splat,
      SVGRenderer = H.SVGRenderer,
      VMLRenderer = H.VMLRenderer,
      wrap = H.wrap,
      seriesProto = Series.prototype,
      seriesInit = seriesProto.init,
      seriesProcessData = seriesProto.processData,
      pointTooltipFormatter = Point.prototype.tooltipFormatter;
    H.StockChart = H.stockChart = function(a, b, c) {
      var hasRenderToArg = isString(a) || a.nodeName,
        options = arguments[hasRenderToArg ? 1 : 0],
        seriesOptions = options.series,
        defaultOptions = H.getOptions(),
        opposite,
        navigatorEnabled = pick(
          options.navigator && options.navigator.enabled,
          defaultOptions.navigator.enabled,
          true
        ),
        disableStartOnTick = navigatorEnabled ? {
          startOnTick: false,
          endOnTick: false
        } : null,
        lineOptions = {
          marker: {
            enabled: false,
            radius: 2
          }
        },
        columnOptions = {
          shadow: false,
          borderWidth: 0
        };
      options.xAxis = map(splat(options.xAxis || {}), function(xAxisOptions) {
        return merge({
            minPadding: 0,
            maxPadding: 0,
            ordinal: true,
            title: {
              text: null
            },
            labels: {
              overflow: 'justify'
            },
            showLastLabel: true
          },
          defaultOptions.xAxis,
          xAxisOptions, {
            type: 'datetime',
            categories: null
          },
          disableStartOnTick
        );
      });
      options.yAxis = map(splat(options.yAxis || {}), function(yAxisOptions) {
        opposite = pick(yAxisOptions.opposite, true);
        return merge({
            labels: {
              y: -2
            },
            opposite: opposite,
            showLastLabel: false,
            title: {
              text: null
            }
          },
          defaultOptions.yAxis,
          yAxisOptions
        );
      });
      options.series = null;
      options = merge({
          chart: {
            panning: true,
            pinchType: 'x'
          },
          navigator: {
            enabled: navigatorEnabled
          },
          scrollbar: {
            enabled: pick(defaultOptions.scrollbar.enabled, true)
          },
          rangeSelector: {
            enabled: pick(defaultOptions.rangeSelector.enabled, true)
          },
          title: {
            text: null
          },
          tooltip: {
            shared: true,
            crosshairs: true
          },
          legend: {
            enabled: false
          },
          plotOptions: {
            line: lineOptions,
            spline: lineOptions,
            area: lineOptions,
            areaspline: lineOptions,
            arearange: lineOptions,
            areasplinerange: lineOptions,
            column: columnOptions,
            columnrange: columnOptions,
            candlestick: columnOptions,
            ohlc: columnOptions
          }
        },
        options, {
          isStock: true
        }
      );
      options.series = seriesOptions;
      return hasRenderToArg ?
        new Chart(a, options, c) :
        new Chart(options, b);
    };
    wrap(Axis.prototype, 'autoLabelAlign', function(proceed) {
      var chart = this.chart,
        options = this.options,
        panes = chart._labelPanes = chart._labelPanes || {},
        key,
        labelOptions = this.options.labels;
      if (this.chart.options.isStock && this.coll === 'yAxis') {
        key = options.top + ',' + options.height;
        if (!panes[key] && labelOptions.enabled) {
          if (labelOptions.x === 15) {
            labelOptions.x = 0;
          }
          if (labelOptions.align === undefined) {
            labelOptions.align = 'right';
          }
          panes[key] = 1;
          return 'right';
        }
      }
      return proceed.call(this, [].slice.call(arguments, 1));
    });
    wrap(Axis.prototype, 'getPlotLinePath', function(proceed, value, lineWidth, old, force, translatedValue) {
      var axis = this,
        series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),
        chart = axis.chart,
        renderer = chart.renderer,
        axisLeft = axis.left,
        axisTop = axis.top,
        x1,
        y1,
        x2,
        y2,
        result = [],
        axes = [],
        axes2,
        uniqueAxes,
        transVal;

      function getAxis(coll) {
        var otherColl = coll === 'xAxis' ? 'yAxis' : 'xAxis',
          opt = axis.options[otherColl];
        if (isNumber(opt)) {
          return [chart[otherColl][opt]];
        }
        if (isString(opt)) {
          return [chart.get(opt)];
        }
        return map(series, function(s) {
          return s[otherColl];
        });
      }
      if (axis.coll === 'colorAxis') {
        return proceed.apply(this, [].slice.call(arguments, 1));
      }
      axes = getAxis(axis.coll);
      axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);
      each(axes2, function(A) {
        if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {
          var a = (A.isXAxis ? 'yAxis' : 'xAxis'),
            rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);
          if (axis === rax) {
            axes.push(A);
          }
        }
      });
      uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]];
      each(axes, function(axis2) {
        if (inArray(axis2, uniqueAxes) === -1) {
          uniqueAxes.push(axis2);
        }
      });
      transVal = pick(translatedValue, axis.translate(value, null, null, old));
      if (isNumber(transVal)) {
        if (axis.horiz) {
          each(uniqueAxes, function(axis2) {
            var skip;
            y1 = axis2.pos;
            y2 = y1 + axis2.len;
            x1 = x2 = Math.round(transVal + axis.transB);
            if (x1 < axisLeft || x1 > axisLeft + axis.width) {
              if (force) {
                x1 = x2 = Math.min(Math.max(axisLeft, x1), axisLeft + axis.width);
              } else {
                skip = true;
              }
            }
            if (!skip) {
              result.push('M', x1, y1, 'L', x2, y2);
            }
          });
        } else {
          each(uniqueAxes, function(axis2) {
            var skip;
            x1 = axis2.pos;
            x2 = x1 + axis2.len;
            y1 = y2 = Math.round(axisTop + axis.height - transVal);
            if (y1 < axisTop || y1 > axisTop + axis.height) {
              if (force) {
                y1 = y2 = Math.min(Math.max(axisTop, y1), axis.top + axis.height);
              } else {
                skip = true;
              }
            }
            if (!skip) {
              result.push('M', x1, y1, 'L', x2, y2);
            }
          });
        }
      }
      return result.length > 0 ?
        renderer.crispPolyLine(result, lineWidth || 1) :
        null;
    });
    Axis.prototype.getPlotBandPath = function(from, to) {
      var toPath = this.getPlotLinePath(to, null, null, true),
        path = this.getPlotLinePath(from, null, null, true),
        result = [],
        i;
      if (path && toPath) {
        if (path.toString() === toPath.toString()) {
          result = path;
          result.flat = true;
        } else {
          for (i = 0; i < path.length; i += 6) {
            result.push(
              'M', path[i + 1], path[i + 2],
              'L', path[i + 4], path[i + 5],
              toPath[i + 4], toPath[i + 5],
              toPath[i + 1], toPath[i + 2],
              'z'
            );
          }
        }
      } else {
        result = null;
      }
      return result;
    };
    SVGRenderer.prototype.crispPolyLine = function(points, width) {
      var i;
      for (i = 0; i < points.length; i = i + 6) {
        if (points[i + 1] === points[i + 4]) {
          points[i + 1] = points[i + 4] = Math.round(points[i + 1]) - (width % 2 / 2);
        }
        if (points[i + 2] === points[i + 5]) {
          points[i + 2] = points[i + 5] = Math.round(points[i + 2]) + (width % 2 / 2);
        }
      }
      return points;
    };
    if (Renderer === VMLRenderer) {
      VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;
    }
    wrap(Axis.prototype, 'hideCrosshair', function(proceed, i) {
      proceed.call(this, i);
      if (this.crossLabel) {
        this.crossLabel = this.crossLabel.hide();
      }
    });
    wrap(Axis.prototype, 'drawCrosshair', function(proceed, e, point) {
      proceed.call(this, e, point);
      if (!defined(this.crosshair.label) || !this.crosshair.label.enabled || !this.cross) {
        return;
      }
      var chart = this.chart,
        options = this.options.crosshair.label,
        horiz = this.horiz,
        opposite = this.opposite,
        left = this.left,
        top = this.top,
        crossLabel = this.crossLabel,
        posx,
        posy,
        crossBox,
        formatOption = options.format,
        formatFormat = '',
        limit,
        align,
        tickInside = this.options.tickPosition === 'inside',
        snap = this.crosshair.snap !== false,
        value,
        offset = 0;
      if (!e) {
        e = this.cross && this.cross.e;
      }
      align = (horiz ? 'center' : opposite ?
        (this.labelAlign === 'right' ? 'right' : 'left') :
        (this.labelAlign === 'left' ? 'left' : 'center'));
      if (!crossLabel) {
        crossLabel = this.crossLabel = chart.renderer.label(null, null, null, options.shape || 'callout')
          .addClass('highcharts-crosshair-label' +
            (this.series[0] && ' highcharts-color-' + this.series[0].colorIndex))
          .attr({
            align: options.align || align,
            padding: pick(options.padding, 8),
            r: pick(options.borderRadius, 3),
            zIndex: 2
          })
          .add(this.labelGroup);
        crossLabel
          .attr({
            fill: options.backgroundColor ||
              (this.series[0] && this.series[0].color) || '#666666',
            stroke: options.borderColor || '',
            'stroke-width': options.borderWidth || 0
          })
          .css(extend({
            color: '#ffffff',
            fontWeight: 'normal',
            fontSize: '11px',
            textAlign: 'center'
          }, options.style));
      }
      if (horiz) {
        posx = snap ? point.plotX + left : e.chartX;
        posy = top + (opposite ? 0 : this.height);
      } else {
        posx = opposite ? this.width + left : 0;
        posy = snap ? point.plotY + top : e.chartY;
      }
      if (!formatOption && !options.formatter) {
        if (this.isDatetimeAxis) {
          formatFormat = '%b %d, %Y';
        }
        formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';
      }
      value = snap ? point[this.isXAxis ? 'x' : 'y'] : this.toValue(horiz ? e.chartX : e.chartY);
      crossLabel.attr({
        text: formatOption ? format(formatOption, {
          value: value
        }) : options.formatter.call(this, value),
        x: posx,
        y: posy,
        visibility: 'visible'
      });
      crossBox = crossLabel.getBBox();
      if (horiz) {
        if ((tickInside && !opposite) || (!tickInside && opposite)) {
          posy = crossLabel.y - crossBox.height;
        }
      } else {
        posy = crossLabel.y - (crossBox.height / 2);
      }
      if (horiz) {
        limit = {
          left: left - crossBox.x,
          right: left + this.width - crossBox.x
        };
      } else {
        limit = {
          left: this.labelAlign === 'left' ? left : 0,
          right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth
        };
      }
      if (crossLabel.translateX < limit.left) {
        offset = limit.left - crossLabel.translateX;
      }
      if (crossLabel.translateX + crossBox.width >= limit.right) {
        offset = -(crossLabel.translateX + crossBox.width - limit.right);
      }
      crossLabel.attr({
        x: posx + offset,
        y: posy,
        anchorX: horiz ? posx : (this.opposite ? 0 : chart.chartWidth),
        anchorY: horiz ? (this.opposite ? chart.chartHeight : 0) : posy + crossBox.height / 2
      });
    });
    seriesProto.init = function() {
      seriesInit.apply(this, arguments);
      this.setCompare(this.options.compare);
    };
    seriesProto.setCompare = function(compare) {
      this.modifyValue = (compare === 'value' || compare === 'percent') ? function(value, point) {
        var compareValue = this.compareValue;
        if (value !== undefined && compareValue !== undefined) {
          if (compare === 'value') {
            value -= compareValue;
          } else {
            value = 100 * (value / compareValue) -
              (this.options.compareBase === 100 ? 0 : 100);
          }
          if (point) {
            point.change = value;
          }
          return value;
        }
      } : null;
      this.userOptions.compare = compare;
      if (this.chart.hasRendered) {
        this.isDirty = true;
      }
    };
    seriesProto.processData = function() {
      var series = this,
        i,
        keyIndex = -1,
        processedXData,
        processedYData,
        length,
        compareValue;
      seriesProcessData.apply(this, arguments);
      if (series.xAxis && series.processedYData) {
        processedXData = series.processedXData;
        processedYData = series.processedYData;
        length = processedYData.length;
        if (series.pointArrayMap) {
          keyIndex = inArray('close', series.pointArrayMap);
          if (keyIndex === -1) {
            keyIndex = inArray(series.pointValKey || 'y', series.pointArrayMap);
          }
        }
        for (i = 0; i < length - 1; i++) {
          compareValue = keyIndex > -1 ?
            processedYData[i][keyIndex] :
            processedYData[i];
          if (isNumber(compareValue) && processedXData[i + 1] >= series.xAxis.min && compareValue !== 0) {
            series.compareValue = compareValue;
            break;
          }
        }
      }
    };
    wrap(seriesProto, 'getExtremes', function(proceed) {
      var extremes;
      proceed.apply(this, [].slice.call(arguments, 1));
      if (this.modifyValue) {
        extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];
        this.dataMin = arrayMin(extremes);
        this.dataMax = arrayMax(extremes);
      }
    });
    Axis.prototype.setCompare = function(compare, redraw) {
      if (!this.isXAxis) {
        each(this.series, function(series) {
          series.setCompare(compare);
        });
        if (pick(redraw, true)) {
          this.chart.redraw();
        }
      }
    };
    Point.prototype.tooltipFormatter = function(pointFormat) {
      var point = this;
      pointFormat = pointFormat.replace(
        '{point.change}',
        (point.change > 0 ? '+' : '') +
        H.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))
      );
      return pointTooltipFormatter.apply(this, [pointFormat]);
    };
    wrap(Series.prototype, 'render', function(proceed) {
      if (!(this.chart.is3d && this.chart.is3d()) &&
        !this.chart.polar &&
        this.xAxis &&
        !this.xAxis.isRadial
      ) {
        if (!this.clipBox && this.animate) {
          this.clipBox = merge(this.chart.clipBox);
          this.clipBox.width = this.xAxis.len;
          this.clipBox.height = this.yAxis.len;
        } else if (this.chart[this.sharedClipKey]) {
          this.chart[this.sharedClipKey].attr({
            width: this.xAxis.len,
            height: this.yAxis.len
          });
        } else if (this.clipBox) {
          this.clipBox.width = this.xAxis.len;
          this.clipBox.height = this.yAxis.len;
        }
      }
      proceed.call(this);
    });
  }(Highcharts));
  (function() {
    'use strict';
  }());
  return Highcharts
}));;
/*! RESOURCE: /scripts/highcharts/highcharts-more.src.js */
(function(factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory;
  } else {
    factory(Highcharts);
  }
}(function(Highcharts) {
  (function(H) {
    'use strict';
    var each = H.each,
      extend = H.extend,
      merge = H.merge,
      splat = H.splat;

    function Pane(options, chart, firstAxis) {
      this.init(options, chart, firstAxis);
    }
    extend(Pane.prototype, {
      init: function(options, chart, firstAxis) {
        var pane = this,
          backgroundOption,
          defaultOptions = pane.defaultOptions;
        pane.chart = chart;
        pane.options = options = merge(defaultOptions, chart.angular ? {
          background: {}
        } : undefined, options);
        backgroundOption = options.background;
        if (backgroundOption) {
          each([].concat(splat(backgroundOption)).reverse(), function(config) {
            var mConfig,
              axisUserOptions = firstAxis.userOptions;
            mConfig = merge(pane.defaultBackgroundOptions, config);
            if (config.backgroundColor) {
              mConfig.backgroundColor = config.backgroundColor;
            }
            mConfig.color = mConfig.backgroundColor;
            firstAxis.options.plotBands.unshift(mConfig);
            axisUserOptions.plotBands = axisUserOptions.plotBands || [];
            if (axisUserOptions.plotBands !== firstAxis.options.plotBands) {
              axisUserOptions.plotBands.unshift(mConfig);
            }
          });
        }
      },
      defaultOptions: {
        center: ['50%', '50%'],
        size: '85%',
        startAngle: 0
      },
      defaultBackgroundOptions: {
        className: 'highcharts-pane',
        shape: 'circle',
        borderWidth: 1,
        borderColor: '#cccccc',
        backgroundColor: {
          linearGradient: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 1
          },
          stops: [
            [0, '#ffffff'],
            [1, '#e6e6e6']
          ]
        },
        from: -Number.MAX_VALUE,
        innerRadius: 0,
        to: Number.MAX_VALUE,
        outerRadius: '105%'
      }
    });
    H.Pane = Pane;
  }(Highcharts));
  (function(H) {
    'use strict';
    var Axis = H.Axis,
      CenteredSeriesMixin = H.CenteredSeriesMixin,
      each = H.each,
      extend = H.extend,
      map = H.map,
      merge = H.merge,
      noop = H.noop,
      Pane = H.Pane,
      pick = H.pick,
      pInt = H.pInt,
      Tick = H.Tick,
      splat = H.splat,
      wrap = H.wrap,
      hiddenAxisMixin,
      radialAxisMixin,
      axisProto = Axis.prototype,
      tickProto = Tick.prototype;
    hiddenAxisMixin = {
      getOffset: noop,
      redraw: function() {
        this.isDirty = false;
      },
      render: function() {
        this.isDirty = false;
      },
      setScale: noop,
      setCategories: noop,
      setTitle: noop
    };
    radialAxisMixin = {
      defaultRadialGaugeOptions: {
        labels: {
          align: 'center',
          x: 0,
          y: null
        },
        minorGridLineWidth: 0,
        minorTickInterval: 'auto',
        minorTickLength: 10,
        minorTickPosition: 'inside',
        minorTickWidth: 1,
        tickLength: 10,
        tickPosition: 'inside',
        tickWidth: 2,
        title: {
          rotation: 0
        },
        zIndex: 2
      },
      defaultRadialXOptions: {
        gridLineWidth: 1,
        labels: {
          align: null,
          distance: 15,
          x: 0,
          y: null
        },
        maxPadding: 0,
        minPadding: 0,
        showLastLabel: false,
        tickLength: 0
      },
      defaultRadialYOptions: {
        gridLineInterpolation: 'circle',
        labels: {
          align: 'right',
          x: -3,
          y: -2
        },
        showLastLabel: false,
        title: {
          x: 4,
          text: null,
          rotation: 90
        }
      },
      setOptions: function(userOptions) {
        var options = this.options = merge(
          this.defaultOptions,
          this.defaultRadialOptions,
          userOptions
        );
        if (!options.plotBands) {
          options.plotBands = [];
        }
      },
      getOffset: function() {
        axisProto.getOffset.call(this);
        this.chart.axisOffset[this.side] = 0;
        this.center = this.pane.center = CenteredSeriesMixin.getCenter.call(this.pane);
      },
      getLinePath: function(lineWidth, radius) {
        var center = this.center,
          end,
          chart = this.chart,
          r = pick(radius, center[2] / 2 - this.offset),
          path;
        if (this.isCircular || radius !== undefined) {
          path = this.chart.renderer.symbols.arc(
            this.left + center[0],
            this.top + center[1],
            r,
            r, {
              start: this.startAngleRad,
              end: this.endAngleRad,
              open: true,
              innerR: 0
            }
          );
        } else {
          end = this.postTranslate(this.angleRad, r);
          path = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];
        }
        return path;
      },
      setAxisTranslation: function() {
        axisProto.setAxisTranslation.call(this);
        if (this.center) {
          if (this.isCircular) {
            this.transA = (this.endAngleRad - this.startAngleRad) /
              ((this.max - this.min) || 1);
          } else {
            this.transA = (this.center[2] / 2) / ((this.max - this.min) || 1);
          }
          if (this.isXAxis) {
            this.minPixelPadding = this.transA * this.minPointOffset;
          } else {
            this.minPixelPadding = 0;
          }
        }
      },
      beforeSetTickPositions: function() {
        this.autoConnect = this.isCircular && pick(this.userMax, this.options.max) === undefined &&
          this.endAngleRad - this.startAngleRad === 2 * Math.PI;
        if (this.autoConnect) {
          this.max += (this.categories && 1) || this.pointRange || this.closestPointRange || 0;
        }
      },
      setAxisSize: function() {
        axisProto.setAxisSize.call(this);
        if (this.isRadial) {
          this.center = this.pane.center = CenteredSeriesMixin.getCenter.call(this.pane);
          if (this.isCircular) {
            this.sector = this.endAngleRad - this.startAngleRad;
          }
          this.len = this.width = this.height = this.center[2] * pick(this.sector, 1) / 2;
        }
      },
      getPosition: function(value, length) {
        return this.postTranslate(
          this.isCircular ? this.translate(value) : this.angleRad,
          pick(this.isCircular ? length : this.translate(value), this.center[2] / 2) - this.offset
        );
      },
      postTranslate: function(angle, radius) {
        var chart = this.chart,
          center = this.center;
        angle = this.startAngleRad + angle;
        return {
          x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
          y: chart.plotTop + center[1] + Math.sin(angle) * radius
        };
      },
      getPlotBandPath: function(from, to, options) {
        var center = this.center,
          startAngleRad = this.startAngleRad,
          fullRadius = center[2] / 2,
          radii = [
            pick(options.outerRadius, '100%'),
            options.innerRadius,
            pick(options.thickness, 10)
          ],
          offset = Math.min(this.offset, 0),
          percentRegex = /%$/,
          start,
          end,
          open,
          isCircular = this.isCircular,
          ret;
        if (this.options.gridLineInterpolation === 'polygon') {
          ret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true));
        } else {
          from = Math.max(from, this.min);
          to = Math.min(to, this.max);
          if (!isCircular) {
            radii[0] = this.translate(from);
            radii[1] = this.translate(to);
          }
          radii = map(radii, function(radius) {
            if (percentRegex.test(radius)) {
              radius = (pInt(radius, 10) * fullRadius) / 100;
            }
            return radius;
          });
          if (options.shape === 'circle' || !isCircular) {
            start = -Math.PI / 2;
            end = Math.PI * 1.5;
            open = true;
          } else {
            start = startAngleRad + this.translate(from);
            end = startAngleRad + this.translate(to);
          }
          radii[0] -= offset;
          radii[2] -= offset;
          ret = this.chart.renderer.symbols.arc(
            this.left + center[0],
            this.top + center[1],
            radii[0],
            radii[0], {
              start: Math.min(start, end),
              end: Math.max(start, end),
              innerR: pick(radii[1], radii[0] - radii[2]),
              open: open
            }
          );
        }
        return ret;
      },
      getPlotLinePath: function(value, reverse) {
        var axis = this,
          center = axis.center,
          chart = axis.chart,
          end = axis.getPosition(value),
          xAxis,
          xy,
          tickPositions,
          ret;
        if (axis.isCircular) {
          ret = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];
        } else if (axis.options.gridLineInterpolation === 'circle') {
          value = axis.translate(value);
          if (value) {
            ret = axis.getLinePath(0, value);
          }
        } else {
          each(chart.xAxis, function(a) {
            if (a.pane === axis.pane) {
              xAxis = a;
            }
          });
          ret = [];
          value = axis.translate(value);
          tickPositions = xAxis.tickPositions;
          if (xAxis.autoConnect) {
            tickPositions = tickPositions.concat([tickPositions[0]]);
          }
          if (reverse) {
            tickPositions = [].concat(tickPositions).reverse();
          }
          each(tickPositions, function(pos, i) {
            xy = xAxis.getPosition(pos, value);
            ret.push(i ? 'L' : 'M', xy.x, xy.y);
          });
        }
        return ret;
      },
      getTitlePosition: function() {
        var center = this.center,
          chart = this.chart,
          titleOptions = this.options.title;
        return {
          x: chart.plotLeft + center[0] + (titleOptions.x || 0),
          y: chart.plotTop + center[1] - ({
              high: 0.5,
              middle: 0.25,
              low: 0
            } [titleOptions.align] *
            center[2]) + (titleOptions.y || 0)
        };
      }
    };
    wrap(axisProto, 'init', function(proceed, chart, userOptions) {
      var axis = this,
        angular = chart.angular,
        polar = chart.polar,
        isX = userOptions.isX,
        isHidden = angular && isX,
        isCircular,
        options,
        chartOptions = chart.options,
        paneIndex = userOptions.pane || 0,
        pane,
        paneOptions;
      if (angular) {
        extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);
        isCircular = !isX;
        if (isCircular) {
          this.defaultRadialOptions = this.defaultRadialGaugeOptions;
        }
      } else if (polar) {
        extend(this, radialAxisMixin);
        isCircular = isX;
        this.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge(this.defaultYAxisOptions, this.defaultRadialYOptions);
      }
      if (angular || polar) {
        this.isRadial = true;
        chart.inverted = false;
        chartOptions.chart.zoomType = null;
      } else {
        this.isRadial = false;
      }
      proceed.call(this, chart, userOptions);
      if (!isHidden && (angular || polar)) {
        options = this.options;
        if (!chart.panes) {
          chart.panes = [];
        }
        this.pane = pane = chart.panes[paneIndex] = chart.panes[paneIndex] || new Pane(
          splat(chartOptions.pane)[paneIndex],
          chart,
          axis
        );
        paneOptions = pane.options;
        this.angleRad = (options.angle || 0) * Math.PI / 180;
        this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
        this.endAngleRad = (pick(paneOptions.endAngle, paneOptions.startAngle + 360) - 90) * Math.PI / 180;
        this.offset = options.offset || 0;
        this.isCircular = isCircular;
      }
    });
    wrap(axisProto, 'autoLabelAlign', function(proceed) {
      if (!this.isRadial) {
        return proceed.apply(this, [].slice.call(arguments, 1));
      }
    });
    wrap(tickProto, 'getPosition', function(proceed, horiz, pos, tickmarkOffset, old) {
      var axis = this.axis;
      return axis.getPosition ?
        axis.getPosition(pos) :
        proceed.call(this, horiz, pos, tickmarkOffset, old);
    });
    wrap(tickProto, 'getLabelPosition', function(proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
      var axis = this.axis,
        optionsY = labelOptions.y,
        ret,
        centerSlot = 20,
        align = labelOptions.align,
        angle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360;
      if (axis.isRadial) {
        ret = axis.getPosition(this.pos, (axis.center[2] / 2) + pick(labelOptions.distance, -25));
        if (labelOptions.rotation === 'auto') {
          label.attr({
            rotation: angle
          });
        } else if (optionsY === null) {
          optionsY = axis.chart.renderer.fontMetrics(label.styles.fontSize).b - label.getBBox().height / 2;
        }
        if (align === null) {
          if (axis.isCircular) {
            if (this.label.getBBox().width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
              centerSlot = 0;
            }
            if (angle > centerSlot && angle < 180 - centerSlot) {
              align = 'left';
            } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
              align = 'right';
            } else {
              align = 'center';
            }
          } else {
            align = 'center';
          }
          label.attr({
            align: align
          });
        }
        ret.x += labelOptions.x;
        ret.y += optionsY;
      } else {
        ret = proceed.call(this, x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
      }
      return ret;
    });
    wrap(tickProto, 'getMarkPath', function(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
      var axis = this.axis,
        endPoint,
        ret;
      if (axis.isRadial) {
        endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
        ret = [
          'M',
          x,
          y,
          'L',
          endPoint.x,
          endPoint.y
        ];
      } else {
        ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
      }
      return ret;
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      noop = H.noop,
      pick = H.pick,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('arearange', 'area', {
      lineWidth: 1,
      marker: null,
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      trackByArea: true,
      dataLabels: {
        align: null,
        verticalAlign: null,
        xLow: 0,
        xHigh: 0,
        yLow: 0,
        yHigh: 0
      },
      states: {
        hover: {
          halo: false
        }
      }
    }, {
      pointArrayMap: ['low', 'high'],
      dataLabelCollections: ['dataLabel', 'dataLabelUpper'],
      toYData: function(point) {
        return [point.low, point.high];
      },
      pointValKey: 'low',
      deferTranslatePolar: true,
      highToXY: function(point) {
        var chart = this.chart,
          xy = this.xAxis.postTranslate(point.rectPlotX, this.yAxis.len - point.plotHigh);
        point.plotHighX = xy.x - chart.plotLeft;
        point.plotHigh = xy.y - chart.plotTop;
      },
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          hasModifyValue = !!series.modifyValue;
        seriesTypes.area.prototype.translate.apply(series);
        each(series.points, function(point) {
          var low = point.low,
            high = point.high,
            plotY = point.plotY;
          if (high === null || low === null) {
            point.isNull = true;
          } else {
            point.plotLow = plotY;
            point.plotHigh = yAxis.translate(
              hasModifyValue ? series.modifyValue(high, point) : high,
              0,
              1,
              0,
              1
            );
            if (hasModifyValue) {
              point.yBottom = point.plotHigh;
            }
          }
        });
        if (this.chart.polar) {
          each(this.points, function(point) {
            series.highToXY(point);
          });
        }
      },
      getGraphPath: function(points) {
        var highPoints = [],
          highAreaPoints = [],
          i,
          getGraphPath = seriesTypes.area.prototype.getGraphPath,
          point,
          pointShim,
          linePath,
          lowerPath,
          options = this.options,
          connectEnds = this.chart.polar && options.connectEnds !== false,
          step = options.step,
          higherPath,
          higherAreaPath;
        points = points || this.points;
        i = points.length;
        i = points.length;
        while (i--) {
          point = points[i];
          if (!point.isNull &&
            !connectEnds &&
            (!points[i + 1] || points[i + 1].isNull)
          ) {
            highAreaPoints.push({
              plotX: point.plotX,
              plotY: point.plotY,
              doCurve: false
            });
          }
          pointShim = {
            polarPlotY: point.polarPlotY,
            rectPlotX: point.rectPlotX,
            yBottom: point.yBottom,
            plotX: pick(point.plotHighX, point.plotX),
            plotY: point.plotHigh,
            isNull: point.isNull
          };
          highAreaPoints.push(pointShim);
          highPoints.push(pointShim);
          if (!point.isNull &&
            !connectEnds &&
            (!points[i - 1] || points[i - 1].isNull)
          ) {
            highAreaPoints.push({
              plotX: point.plotX,
              plotY: point.plotY,
              doCurve: false
            });
          }
        }
        lowerPath = getGraphPath.call(this, points);
        if (step) {
          if (step === true) {
            step = 'left';
          }
          options.step = {
            left: 'right',
            center: 'center',
            right: 'left'
          } [step];
        }
        higherPath = getGraphPath.call(this, highPoints);
        higherAreaPath = getGraphPath.call(this, highAreaPoints);
        options.step = step;
        linePath = [].concat(lowerPath, higherPath);
        if (!this.chart.polar && higherAreaPath[0] === 'M') {
          higherAreaPath[0] = 'L';
        }
        this.graphPath = linePath;
        this.areaPath = this.areaPath.concat(lowerPath, higherAreaPath);
        linePath.isArea = true;
        linePath.xMap = lowerPath.xMap;
        this.areaPath.xMap = lowerPath.xMap;
        return linePath;
      },
      drawDataLabels: function() {
        var data = this.data,
          length = data.length,
          i,
          originalDataLabels = [],
          seriesProto = Series.prototype,
          dataLabelOptions = this.options.dataLabels,
          align = dataLabelOptions.align,
          verticalAlign = dataLabelOptions.verticalAlign,
          inside = dataLabelOptions.inside,
          point,
          up,
          inverted = this.chart.inverted;
        if (dataLabelOptions.enabled || this._hasPointLabels) {
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
              point.y = point.high;
              point._plotY = point.plotY;
              point.plotY = point.plotHigh;
              originalDataLabels[i] = point.dataLabel;
              point.dataLabel = point.dataLabelUpper;
              point.below = up;
              if (inverted) {
                if (!align) {
                  dataLabelOptions.align = up ? 'right' : 'left';
                }
              } else {
                if (!verticalAlign) {
                  dataLabelOptions.verticalAlign = up ? 'top' : 'bottom';
                }
              }
              dataLabelOptions.x = dataLabelOptions.xHigh;
              dataLabelOptions.y = dataLabelOptions.yHigh;
            }
          }
          if (seriesProto.drawDataLabels) {
            seriesProto.drawDataLabels.apply(this, arguments);
          }
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
              point.dataLabelUpper = point.dataLabel;
              point.dataLabel = originalDataLabels[i];
              point.y = point.low;
              point.plotY = point._plotY;
              point.below = !up;
              if (inverted) {
                if (!align) {
                  dataLabelOptions.align = up ? 'left' : 'right';
                }
              } else {
                if (!verticalAlign) {
                  dataLabelOptions.verticalAlign = up ? 'bottom' : 'top';
                }
              }
              dataLabelOptions.x = dataLabelOptions.xLow;
              dataLabelOptions.y = dataLabelOptions.yLow;
            }
          }
          if (seriesProto.drawDataLabels) {
            seriesProto.drawDataLabels.apply(this, arguments);
          }
        }
        dataLabelOptions.align = align;
        dataLabelOptions.verticalAlign = verticalAlign;
      },
      alignDataLabel: function() {
        seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);
      },
      setStackedPoints: noop,
      getSymbol: noop,
      drawPoints: noop
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('areasplinerange', 'arearange', null, {
      getPointSpline: seriesTypes.spline.prototype.getPointSpline
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var defaultPlotOptions = H.defaultPlotOptions,
      each = H.each,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    var colProto = seriesTypes.column.prototype;
    seriesType('columnrange', 'arearange', merge(defaultPlotOptions.column, defaultPlotOptions.arearange, {
      lineWidth: 1,
      pointRange: null
    }), {
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          xAxis = series.xAxis,
          startAngleRad = xAxis.startAngleRad,
          start,
          chart = series.chart,
          isRadial = series.xAxis.isRadial,
          plotHigh;
        colProto.translate.apply(series);
        each(series.points, function(point) {
          var shapeArgs = point.shapeArgs,
            minPointLength = series.options.minPointLength,
            heightDifference,
            height,
            y;
          point.plotHigh = plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);
          point.plotLow = point.plotY;
          y = plotHigh;
          height = pick(point.rectPlotY, point.plotY) - plotHigh;
          if (Math.abs(height) < minPointLength) {
            heightDifference = (minPointLength - height);
            height += heightDifference;
            y -= heightDifference / 2;
          } else if (height < 0) {
            height *= -1;
            y -= height;
          }
          if (isRadial) {
            start = point.barX + startAngleRad;
            point.shapeType = 'path';
            point.shapeArgs = {
              d: series.polarArc(y + height, y, start, start + point.pointWidth)
            };
          } else {
            shapeArgs.height = height;
            shapeArgs.y = y;
            point.tooltipPos = chart.inverted ? [
              yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
              xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x -
              shapeArgs.width / 2,
              height
            ] : [
              xAxis.left - chart.plotLeft + shapeArgs.x +
              shapeArgs.width / 2,
              yAxis.pos - chart.plotTop + y + height / 2,
              height
            ];
          }
        });
      },
      directTouch: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      drawGraph: noop,
      crispCol: colProto.crispCol,
      drawPoints: colProto.drawPoints,
      drawTracker: colProto.drawTracker,
      getColumnMetrics: colProto.getColumnMetrics,
      animate: function() {
        return colProto.animate.apply(this, arguments);
      },
      polarArc: function() {
        return colProto.polarArc.apply(this, arguments);
      },
      pointAttribs: colProto.pointAttribs
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      isNumber = H.isNumber,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      Series = H.Series,
      seriesType = H.seriesType,
      TrackerMixin = H.TrackerMixin;
    seriesType('gauge', 'line', {
      dataLabels: {
        enabled: true,
        defer: false,
        y: 15,
        borderRadius: 3,
        crop: false,
        verticalAlign: 'top',
        zIndex: 2,
        borderWidth: 1,
        borderColor: '#cccccc'
      },
      dial: {},
      pivot: {},
      tooltip: {
        headerFormat: ''
      },
      showInLegend: false
    }, {
      angular: true,
      directTouch: true,
      drawGraph: noop,
      fixedBox: true,
      forceDL: true,
      noSharedTooltip: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          options = series.options,
          center = yAxis.center;
        series.generatePoints();
        each(series.points, function(point) {
          var dialOptions = merge(options.dial, point.dial),
            radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) / 200,
            baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) / 100,
            rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) / 100,
            baseWidth = dialOptions.baseWidth || 3,
            topWidth = dialOptions.topWidth || 1,
            overshoot = options.overshoot,
            rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);
          if (isNumber(overshoot)) {
            overshoot = overshoot / 180 * Math.PI;
            rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));
          } else if (options.wrap === false) {
            rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));
          }
          rotation = rotation * 180 / Math.PI;
          point.shapeType = 'path';
          point.shapeArgs = {
            d: dialOptions.path || [
              'M', -rearLength, -baseWidth / 2,
              'L',
              baseLength, -baseWidth / 2,
              radius, -topWidth / 2,
              radius, topWidth / 2,
              baseLength, baseWidth / 2, -rearLength, baseWidth / 2,
              'z'
            ],
            translateX: center[0],
            translateY: center[1],
            rotation: rotation
          };
          point.plotX = center[0];
          point.plotY = center[1];
        });
      },
      drawPoints: function() {
        var series = this,
          center = series.yAxis.center,
          pivot = series.pivot,
          options = series.options,
          pivotOptions = options.pivot,
          renderer = series.chart.renderer;
        each(series.points, function(point) {
          var graphic = point.graphic,
            shapeArgs = point.shapeArgs,
            d = shapeArgs.d,
            dialOptions = merge(options.dial, point.dial);
          if (graphic) {
            graphic.animate(shapeArgs);
            shapeArgs.d = d;
          } else {
            point.graphic = renderer[point.shapeType](shapeArgs)
              .attr({
                rotation: shapeArgs.rotation,
                zIndex: 1
              })
              .addClass('highcharts-dial')
              .add(series.group);
            point.graphic.attr({
              stroke: dialOptions.borderColor || 'none',
              'stroke-width': dialOptions.borderWidth || 0,
              fill: dialOptions.backgroundColor || '#000000'
            });
          }
        });
        if (pivot) {
          pivot.animate({
            translateX: center[0],
            translateY: center[1]
          });
        } else {
          series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))
            .attr({
              zIndex: 2
            })
            .addClass('highcharts-pivot')
            .translate(center[0], center[1])
            .add(series.group);
          series.pivot.attr({
            'stroke-width': pivotOptions.borderWidth || 0,
            stroke: pivotOptions.borderColor || '#cccccc',
            fill: pivotOptions.backgroundColor || '#000000'
          });
        }
      },
      animate: function(init) {
        var series = this;
        if (!init) {
          each(series.points, function(point) {
            var graphic = point.graphic;
            if (graphic) {
              graphic.attr({
                rotation: series.yAxis.startAngleRad * 180 / Math.PI
              });
              graphic.animate({
                rotation: point.shapeArgs.rotation
              }, series.options.animation);
            }
          });
          series.animate = null;
        }
      },
      render: function() {
        this.group = this.plotGroup(
          'group',
          'series',
          this.visible ? 'visible' : 'hidden',
          this.options.zIndex,
          this.chart.seriesGroup
        );
        Series.prototype.render.call(this);
        this.group.clip(this.chart.clipRect);
      },
      setData: function(data, redraw) {
        Series.prototype.setData.call(this, data, false);
        this.processData();
        this.generatePoints();
        if (pick(redraw, true)) {
          this.chart.redraw();
        }
      },
      drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint
    }, {
      setState: function(state) {
        this.state = state;
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      noop = H.noop,
      pick = H.pick,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('boxplot', 'column', {
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>' +
          'Maximum: {point.high}<br/>' +
          'Upper quartile: {point.q3}<br/>' +
          'Median: {point.median}<br/>' +
          'Lower quartile: {point.q1}<br/>' +
          'Minimum: {point.low}<br/>'
      },
      whiskerLength: '50%',
      fillColor: '#ffffff',
      lineWidth: 1,
      medianWidth: 2,
      states: {
        hover: {
          brightness: -0.3
        }
      },
      whiskerWidth: 2
    }, {
      pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],
      toYData: function(point) {
        return [point.low, point.q1, point.median, point.q3, point.high];
      },
      pointValKey: 'high',
      pointAttribs: function(point) {
        var options = this.options,
          color = (point && point.color) || this.color;
        return {
          'fill': point.fillColor || options.fillColor || color,
          'stroke': options.lineColor || color,
          'stroke-width': options.lineWidth || 0
        };
      },
      drawDataLabels: noop,
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          pointArrayMap = series.pointArrayMap;
        seriesTypes.column.prototype.translate.apply(series);
        each(series.points, function(point) {
          each(pointArrayMap, function(key) {
            if (point[key] !== null) {
              point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);
            }
          });
        });
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          options = series.options,
          chart = series.chart,
          renderer = chart.renderer,
          q1Plot,
          q3Plot,
          highPlot,
          lowPlot,
          medianPlot,
          medianPath,
          crispCorr,
          crispX = 0,
          boxPath,
          width,
          left,
          right,
          halfWidth,
          doQuartiles = series.doQuartiles !== false,
          pointWiskerLength,
          whiskerLength = series.options.whiskerLength;
        each(points, function(point) {
          var graphic = point.graphic,
            verb = graphic ? 'animate' : 'attr',
            shapeArgs = point.shapeArgs;
          var boxAttr,
            stemAttr = {},
            whiskersAttr = {},
            medianAttr = {},
            color = point.color || series.color;
          if (point.plotY !== undefined) {
            width = shapeArgs.width;
            left = Math.floor(shapeArgs.x);
            right = left + width;
            halfWidth = Math.round(width / 2);
            q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
            q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
            highPlot = Math.floor(point.highPlot);
            lowPlot = Math.floor(point.lowPlot);
            if (!graphic) {
              point.graphic = graphic = renderer.g('point')
                .add(series.group);
              point.stem = renderer.path()
                .addClass('highcharts-boxplot-stem')
                .add(graphic);
              if (whiskerLength) {
                point.whiskers = renderer.path()
                  .addClass('highcharts-boxplot-whisker')
                  .add(graphic);
              }
              if (doQuartiles) {
                point.box = renderer.path(boxPath)
                  .addClass('highcharts-boxplot-box')
                  .add(graphic);
              }
              point.medianShape = renderer.path(medianPath)
                .addClass('highcharts-boxplot-median')
                .add(graphic);
              stemAttr.stroke = point.stemColor || options.stemColor || color;
              stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);
              stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle;
              point.stem.attr(stemAttr);
              if (whiskerLength) {
                whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color;
                whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
                point.whiskers.attr(whiskersAttr);
              }
              if (doQuartiles) {
                boxAttr = series.pointAttribs(point);
                point.box.attr(boxAttr);
              }
              medianAttr.stroke = point.medianColor || options.medianColor || color;
              medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);
              point.medianShape.attr(medianAttr);
            }
            crispCorr = (point.stem.strokeWidth() % 2) / 2;
            crispX = left + halfWidth + crispCorr;
            point.stem[verb]({
              d: [
                'M',
                crispX, q3Plot,
                'L',
                crispX, highPlot,
                'M',
                crispX, q1Plot,
                'L',
                crispX, lowPlot
              ]
            });
            if (doQuartiles) {
              crispCorr = (point.box.strokeWidth() % 2) / 2;
              q1Plot = Math.floor(q1Plot) + crispCorr;
              q3Plot = Math.floor(q3Plot) + crispCorr;
              left += crispCorr;
              right += crispCorr;
              point.box[verb]({
                d: [
                  'M',
                  left, q3Plot,
                  'L',
                  left, q1Plot,
                  'L',
                  right, q1Plot,
                  'L',
                  right, q3Plot,
                  'L',
                  left, q3Plot,
                  'z'
                ]
              });
            }
            if (whiskerLength) {
              crispCorr = (point.whiskers.strokeWidth() % 2) / 2;
              highPlot = highPlot + crispCorr;
              lowPlot = lowPlot + crispCorr;
              pointWiskerLength = (/%$/).test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
              point.whiskers[verb]({
                d: [
                  'M',
                  crispX - pointWiskerLength,
                  highPlot,
                  'L',
                  crispX + pointWiskerLength,
                  highPlot,
                  'M',
                  crispX - pointWiskerLength,
                  lowPlot,
                  'L',
                  crispX + pointWiskerLength,
                  lowPlot
                ]
              });
            }
            medianPlot = Math.round(point.medianPlot);
            crispCorr = (point.medianShape.strokeWidth() % 2) / 2;
            medianPlot = medianPlot + crispCorr;
            point.medianShape[verb]({
              d: [
                'M',
                left,
                medianPlot,
                'L',
                right,
                medianPlot
              ]
            });
          }
        });
      },
      setStackedPoints: noop
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      noop = H.noop,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('errorbar', 'boxplot', {
      color: '#000000',
      grouping: false,
      linkedTo: ':previous',
      tooltip: {
        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      whiskerWidth: null
    }, {
      type: 'errorbar',
      pointArrayMap: ['low', 'high'],
      toYData: function(point) {
        return [point.low, point.high];
      },
      pointValKey: 'high',
      doQuartiles: false,
      drawDataLabels: seriesTypes.arearange ? function() {
        var valKey = this.pointValKey;
        seriesTypes.arearange.prototype.drawDataLabels.call(this);
        each(this.data, function(point) {
          point.y = point[valKey];
        });
      } : noop,
      getColumnMetrics: function() {
        return (this.linkedParent && this.linkedParent.columnMetrics) ||
          seriesTypes.column.prototype.getColumnMetrics.call(this);
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var correctFloat = H.correctFloat,
      isNumber = H.isNumber,
      noop = H.noop,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('waterfall', 'column', {
      dataLabels: {
        inside: true
      },
      lineWidth: 1,
      lineColor: '#333333',
      dashStyle: 'dot',
      borderColor: '#333333',
      states: {
        hover: {
          lineWidthPlus: 0
        }
      }
    }, {
      pointValKey: 'y',
      translate: function() {
        var series = this,
          options = series.options,
          yAxis = series.yAxis,
          len,
          i,
          points,
          point,
          shapeArgs,
          stack,
          y,
          yValue,
          previousY,
          previousIntermediate,
          range,
          minPointLength = pick(options.minPointLength, 5),
          threshold = options.threshold,
          stacking = options.stacking,
          positiveOffset = 0,
          negativeOffset = 0,
          stackIndicator,
          tooltipY;
        seriesTypes.column.prototype.translate.apply(this);
        previousY = previousIntermediate = threshold;
        points = series.points;
        for (i = 0, len = points.length; i < len; i++) {
          point = points[i];
          yValue = this.processedYData[i];
          shapeArgs = point.shapeArgs;
          stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey];
          stackIndicator = series.getStackIndicator(stackIndicator, point.x);
          range = stack ?
            stack[point.x].points[series.index + ',' + i + ',' + stackIndicator.index] : [0, yValue];
          if (point.isSum) {
            point.y = correctFloat(yValue);
          } else if (point.isIntermediateSum) {
            point.y = correctFloat(yValue - previousIntermediate);
          }
          y = Math.max(previousY, previousY + point.y) + range[0];
          shapeArgs.y = yAxis.toPixels(y, true);
          if (point.isSum) {
            shapeArgs.y = yAxis.toPixels(range[1], true);
            shapeArgs.height = Math.min(yAxis.toPixels(range[0], true), yAxis.len) -
              shapeArgs.y + positiveOffset + negativeOffset;
          } else if (point.isIntermediateSum) {
            shapeArgs.y = yAxis.toPixels(range[1], true);
            shapeArgs.height = Math.min(yAxis.toPixels(previousIntermediate, true), yAxis.len) -
              shapeArgs.y + positiveOffset + negativeOffset;
            previousIntermediate = range[1];
          } else {
            shapeArgs.height = yValue > 0 ?
              yAxis.toPixels(previousY, true) - shapeArgs.y :
              yAxis.toPixels(previousY, true) - yAxis.toPixels(previousY - yValue, true);
            previousY += yValue;
          }
          if (shapeArgs.height < 0) {
            shapeArgs.y += shapeArgs.height;
            shapeArgs.height *= -1;
          }
          point.plotY = shapeArgs.y = Math.round(shapeArgs.y) - (series.borderWidth % 2) / 2;
          shapeArgs.height = Math.max(Math.round(shapeArgs.height), 0.001);
          point.yBottom = shapeArgs.y + shapeArgs.height;
          shapeArgs.y -= negativeOffset;
          if (shapeArgs.height <= minPointLength && !point.isNull) {
            shapeArgs.height = minPointLength;
            if (point.y < 0) {
              negativeOffset -= minPointLength;
            } else {
              positiveOffset += minPointLength;
            }
          }
          shapeArgs.y -= positiveOffset;
          tooltipY = point.plotY - negativeOffset - positiveOffset +
            (point.negative && negativeOffset >= 0 ? shapeArgs.height : 0);
          if (series.chart.inverted) {
            point.tooltipPos[0] = yAxis.len - tooltipY;
          } else {
            point.tooltipPos[1] = tooltipY;
          }
        }
      },
      processData: function(force) {
        var series = this,
          options = series.options,
          yData = series.yData,
          points = series.options.data,
          point,
          dataLength = yData.length,
          threshold = options.threshold || 0,
          subSum,
          sum,
          dataMin,
          dataMax,
          y,
          i;
        sum = subSum = dataMin = dataMax = threshold;
        for (i = 0; i < dataLength; i++) {
          y = yData[i];
          point = points && points[i] ? points[i] : {};
          if (y === 'sum' || point.isSum) {
            yData[i] = correctFloat(sum);
          } else if (y === 'intermediateSum' || point.isIntermediateSum) {
            yData[i] = correctFloat(subSum);
          } else {
            sum += y;
            subSum += y;
          }
          dataMin = Math.min(sum, dataMin);
          dataMax = Math.max(sum, dataMax);
        }
        Series.prototype.processData.call(this, force);
        series.dataMin = dataMin;
        series.dataMax = dataMax;
      },
      toYData: function(pt) {
        if (pt.isSum) {
          return (pt.x === 0 ? null : 'sum');
        }
        if (pt.isIntermediateSum) {
          return (pt.x === 0 ? null : 'intermediateSum');
        }
        return pt.y;
      },
      pointAttribs: function(point, state) {
        var upColor = this.options.upColor,
          attr;
        if (upColor && !point.options.color) {
          point.color = point.y > 0 ? upColor : null;
        }
        attr = seriesTypes.column.prototype.pointAttribs.call(this, point, state);
        delete attr.dashstyle;
        return attr;
      },
      getGraphPath: function() {
        return ['M', 0, 0];
      },
      getCrispPath: function() {
        var data = this.data,
          length = data.length,
          lineWidth = this.graph.strokeWidth() + this.borderWidth,
          normalizer = Math.round(lineWidth) % 2 / 2,
          path = [],
          prevArgs,
          pointArgs,
          i,
          d;
        for (i = 1; i < length; i++) {
          pointArgs = data[i].shapeArgs;
          prevArgs = data[i - 1].shapeArgs;
          d = [
            'M',
            prevArgs.x + prevArgs.width, prevArgs.y + normalizer,
            'L',
            pointArgs.x, prevArgs.y + normalizer
          ];
          if (data[i - 1].y < 0) {
            d[2] += prevArgs.height;
            d[5] += prevArgs.height;
          }
          path = path.concat(d);
        }
        return path;
      },
      drawGraph: function() {
        Series.prototype.drawGraph.call(this);
        this.graph.attr({
          d: this.getCrispPath()
        });
      },
      getExtremes: noop
    }, {
      getClassName: function() {
        var className = Point.prototype.getClassName.call(this);
        if (this.isSum) {
          className += ' highcharts-sum';
        } else if (this.isIntermediateSum) {
          className += ' highcharts-intermediate-sum';
        }
        return className;
      },
      isValid: function() {
        return isNumber(this.y, true) || this.isSum || this.isIntermediateSum;
      }
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var LegendSymbolMixin = H.LegendSymbolMixin,
      noop = H.noop,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('polygon', 'scatter', {
      marker: {
        enabled: false,
        states: {
          hover: {
            enabled: false
          }
        }
      },
      stickyTracking: false,
      tooltip: {
        followPointer: true,
        pointFormat: ''
      },
      trackByArea: true
    }, {
      type: 'polygon',
      getGraphPath: function() {
        var graphPath = Series.prototype.getGraphPath.call(this),
          i = graphPath.length + 1;
        while (i--) {
          if ((i === graphPath.length || graphPath[i] === 'M') && i > 0) {
            graphPath.splice(i, 0, 'z');
          }
        }
        this.areaPath = graphPath;
        return graphPath;
      },
      drawGraph: function() {
        this.options.fillColor = this.color;
        seriesTypes.area.prototype.drawGraph.call(this);
      },
      drawLegendSymbol: LegendSymbolMixin.drawRectangle,
      drawTracker: Series.prototype.drawTracker,
      setStackedPoints: noop
    });
  }(Highcharts));
  (function(H) {
    'use strict';
    var arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      Axis = H.Axis,
      color = H.color,
      each = H.each,
      isNumber = H.isNumber,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      Point = H.Point,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('bubble', 'scatter', {
      dataLabels: {
        formatter: function() {
          return this.point.z;
        },
        inside: true,
        verticalAlign: 'middle'
      },
      marker: {
        lineColor: null,
        lineWidth: 1,
        radius: null,
        states: {
          hover: {
            radiusPlus: 0
          }
        },
        symbol: 'circle'
      },
      minSize: 8,
      maxSize: '20%',
      softThreshold: false,
      states: {
        hover: {
          halo: {
            size: 5
          }
        }
      },
      tooltip: {
        pointFormat: '({point.x}, {point.y}), Size: {point.z}'
      },
      turboThreshold: 0,
      zThreshold: 0,
      zoneAxis: 'z'
    }, {
      pointArrayMap: ['y', 'z'],
      parallelArrays: ['x', 'y', 'z'],
      trackerGroups: ['markerGroup', 'dataLabelsGroup'],
      bubblePadding: true,
      zoneAxis: 'z',
      pointAttribs: function(point, state) {
        var markerOptions = this.options.marker,
          fillOpacity = pick(markerOptions.fillOpacity, 0.5),
          attr = Series.prototype.pointAttribs.call(this, point, state);
        if (fillOpacity !== 1) {
          attr.fill = color(attr.fill).setOpacity(fillOpacity).get('rgba');
        }
        return attr;
      },
      getRadii: function(zMin, zMax, minSize, maxSize) {
        var len,
          i,
          pos,
          zData = this.zData,
          radii = [],
          options = this.options,
          sizeByArea = options.sizeBy !== 'width',
          zThreshold = options.zThreshold,
          zRange = zMax - zMin,
          value,
          radius;
        for (i = 0, len = zData.length; i < len; i++) {
          value = zData[i];
          if (options.sizeByAbsoluteValue && value !== null) {
            value = Math.abs(value - zThreshold);
            zMax = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
            zMin = 0;
          }
          if (value === null) {
            radius = null;
          } else if (value < zMin) {
            radius = minSize / 2 - 1;
          } else {
            pos = zRange > 0 ? (value - zMin) / zRange : 0.5;
            if (sizeByArea && pos >= 0) {
              pos = Math.sqrt(pos);
            }
            radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
          }
          radii.push(radius);
        }
        this.radii = radii;
      },
      animate: function(init) {
        var animation = this.options.animation;
        if (!init) {
          each(this.points, function(point) {
            var graphic = point.graphic,
              animationTarget;
            if (graphic && graphic.width) {
              animationTarget = {
                x: graphic.x,
                y: graphic.y,
                width: graphic.width,
                height: graphic.height
              };
              graphic.attr({
                x: point.plotX,
                y: point.plotY,
                width: 1,
                height: 1
              });
              graphic.animate(animationTarget, animation);
            }
          });
          this.animate = null;
        }
      },
      translate: function() {
        var i,
          data = this.data,
          point,
          radius,
          radii = this.radii;
        seriesTypes.scatter.prototype.translate.call(this);
        i = data.length;
        while (i--) {
          point = data[i];
          radius = radii ? radii[i] : 0;
          if (isNumber(radius) && radius >= this.minPxSize / 2) {
            point.marker = {
              radius: radius,
              width: 2 * radius,
              height: 2 * radius
            };
            point.dlBox = {
              x: point.plotX - radius,
              y: point.plotY - radius,
              width: 2 * radius,
              height: 2 * radius
            };
          } else {
            point.shapeArgs = point.plotY = point.dlBox = undefined;
          }
        }
      },
      alignDataLabel: seriesTypes.column.prototype.alignDataLabel,
      buildKDTree: noop,
      applyZones: noop
    }, {
      haloPath: function(size) {
        return Point.prototype.haloPath.call(
          this,
          size === 0 ? 0 : this.marker.radius + size
        );
      },
      ttBelow: false
    });
    Axis.prototype.beforePadding = function() {
      var axis = this,
        axisLength = this.len,
        chart = this.chart,
        pxMin = 0,
        pxMax = axisLength,
        isXAxis = this.isXAxis,
        dataKey = isXAxis ? 'xData' : 'yData',
        min = this.min,
        extremes = {},
        smallestSize = Math.min(chart.plotWidth, chart.plotHeight),
        zMin = Number.MAX_VALUE,
        zMax = -Number.MAX_VALUE,
        range = this.max - min,
        transA = axisLength / range,
        activeSeries = [];
      each(this.series, function(series) {
        var seriesOptions = series.options,
          zData;
        if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
          axis.allowZoomOutside = true;
          activeSeries.push(series);
          if (isXAxis) {
            each(['minSize', 'maxSize'], function(prop) {
              var length = seriesOptions[prop],
                isPercent = /%$/.test(length);
              length = pInt(length);
              extremes[prop] = isPercent ?
                smallestSize * length / 100 :
                length;
            });
            series.minPxSize = extremes.minSize;
            series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
            zData = series.zData;
            if (zData.length) {
              zMin = pick(seriesOptions.zMin, Math.min(
                zMin,
                Math.max(
                  arrayMin(zData),
                  seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE
                )
              ));
              zMax = pick(seriesOptions.zMax, Math.max(zMax, arrayMax(zData)));
            }
          }
        }
      });
      each(activeSeries, function(series) {
        var data = series[dataKey],
          i = data.length,
          radius;
        if (isXAxis) {
          series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);
        }
        if (range > 0) {
          while (i--) {
            if (isNumber(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.dataMax) {
              radius = series.radii[i];
              pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);
              pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);
            }
          }
        }
      });
      if (activeSeries.length && range > 0 && !this.isLog) {
        pxMax -= axisLength;
        transA *= (axisLength + pxMin - pxMax) / axisLength;
        each([
          ['min', 'userMin', pxMin],
          ['max', 'userMax', pxMax]
        ], function(keys) {
          if (pick(axis.options[keys[0]], axis[keys[1]]) === undefined) {
            axis[keys[0]] += keys[2] / transA;
          }
        });
      }
    };
  }(Highcharts));
  (function(H) {
    'use strict';
    var each = H.each,
      pick = H.pick,
      Pointer = H.Pointer,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      wrap = H.wrap,
      seriesProto = Series.prototype,
      pointerProto = Pointer.prototype,
      colProto;
    seriesProto.searchPointByAngle = function(e) {
      var series = this,
        chart = series.chart,
        xAxis = series.xAxis,
        center = xAxis.pane.center,
        plotX = e.chartX - center[0] - chart.plotLeft,
        plotY = e.chartY - center[1] - chart.plotTop;
      return this.searchKDTree({
        clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))
      });
    };
    wrap(seriesProto, 'buildKDTree', function(proceed) {
      if (this.chart.polar) {
        if (this.kdByAngle) {
          this.searchPoint = this.searchPointByAngle;
        } else {
          this.kdDimensions = 2;
        }
      }
      proceed.apply(this);
    });
    seriesProto.toXY = function(point) {
      var xy,
        chart = this.chart,
        plotX = point.plotX,
        plotY = point.plotY,
        clientX;
      point.rectPlotX = plotX;
      point.rectPlotY = plotY;
      xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);
      point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
      point.plotY = point.polarPlotY = xy.y - chart.plotTop;
      if (this.kdByAngle) {
        clientX = ((plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle) % 360;
        if (clientX < 0) {
          clientX += 360;
        }
        point.clientX = clientX;
      } else {
        point.clientX = point.plotX;
      }
    };
    if (seriesTypes.spline) {
      wrap(seriesTypes.spline.prototype, 'getPointSpline', function(proceed, segment, point, i) {
        var ret,
          smoothing = 1.5,
          denom = smoothing + 1,
          plotX,
          plotY,
          lastPoint,
          nextPoint,
          lastX,
          lastY,
          nextX,
          nextY,
          leftContX,
          leftContY,
          rightContX,
          rightContY,
          distanceLeftControlPoint,
          distanceRightControlPoint,
          leftContAngle,
          rightContAngle,
          jointAngle;
        if (this.chart.polar) {
          plotX = point.plotX;
          plotY = point.plotY;
          lastPoint = segment[i - 1];
          nextPoint = segment[i + 1];
          if (this.connectEnds) {
            if (!lastPoint) {
              lastPoint = segment[segment.length - 2];
            }
            if (!nextPoint) {
              nextPoint = segment[1];
            }
          }
          if (lastPoint && nextPoint) {
            lastX = lastPoint.plotX;
            lastY = lastPoint.plotY;
            nextX = nextPoint.plotX;
            nextY = nextPoint.plotY;
            leftContX = (smoothing * plotX + lastX) / denom;
            leftContY = (smoothing * plotY + lastY) / denom;
            rightContX = (smoothing * plotX + nextX) / denom;
            rightContY = (smoothing * plotY + nextY) / denom;
            distanceLeftControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
            distanceRightControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
            leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
            rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
            jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);
            if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
              jointAngle -= Math.PI;
            }
            leftContX = plotX + Math.cos(jointAngle) * distanceLeftControlPoint;
            leftContY = plotY + Math.sin(jointAngle) * distanceLeftControlPoint;
            rightContX = plotX + Math.cos(Math.PI + jointAngle) * distanceRightControlPoint;
            rightContY = plotY + Math.sin(Math.PI + jointAngle) * distanceRightControlPoint;
            point.rightContX = rightContX;
            point.rightContY = rightContY;
          }
          if (!i) {
            ret = ['M', plotX, plotY];
          } else {
            ret = [
              'C',
              lastPoint.rightContX || lastPoint.plotX,
              lastPoint.rightContY || lastPoint.plotY,
              leftContX || plotX,
              leftContY || plotY,
              plotX,
              plotY
            ];
            lastPoint.rightContX = lastPoint.rightContY = null;
          }
        } else {
          ret = proceed.call(this, segment, point, i);
        }
        return ret;
      });
    }
    wrap(seriesProto, 'translate', function(proceed) {
      var chart = this.chart,
        points,
        i;
      proceed.call(this);
      if (chart.polar) {
        this.kdByAngle = chart.tooltip && chart.tooltip.shared;
        if (!this.preventPostTranslate) {
          points = this.points;
          i = points.length;
          while (i--) {
            this.toXY(points[i]);
          }
        }
      }
    });
    wrap(seriesProto, 'getGraphPath', function(proceed, points) {
      var series = this,
        i,
        firstValid;
      if (this.chart.polar) {
        points = points || this.points;
        for (i = 0; i < points.length; i++) {
          if (!points[i].isNull) {
            firstValid = i;
            break;
          }
        }
        if (this.options.connectEnds !== false && firstValid !== undefined) {
          this.connectEnds = true;
          points.splice(points.length, 0, points[firstValid]);
        }
        each(points, function(point) {
          if (point.polarPlotY === undefined) {
            series.toXY(point);
          }
        });
      }
      return proceed.apply(this, [].slice.call(arguments, 1));
    });

    function polarAnimate(proceed, init) {
      var chart = this.chart,
        animation = this.options.animation,
        group = this.group,
        markerGroup = this.markerGroup,
        center = this.xAxis.center,
        plotLeft = chart.plotLeft,
        plotTop = chart.plotTop,
        attribs;
      if (chart.polar) {
        if (chart.renderer.isSVG) {
          if (animation === true) {
            animation = {};
          }
          if (init) {
            attribs = {
              translateX: center[0] + plotLeft,
              translateY: center[1] + plotTop,
              scaleX: 0.001,
              scaleY: 0.001
            };
            group.attr(attribs);
            if (markerGroup) {
              markerGroup.attr(attribs);
            }
          } else {
            attribs = {
              translateX: plotLeft,
              translateY: plotTop,
              scaleX: 1,
              scaleY: 1
            };
            group.animate(attribs, animation);
            if (markerGroup) {
              markerGroup.animate(attribs, animation);
            }
            this.animate = null;
          }
        }
      } else {
        proceed.call(this, init);
      }
    }
    wrap(seriesProto, 'animate', polarAnimate);
    if (seriesTypes.column) {
      colProto = seriesTypes.column.prototype;
      colProto.polarArc = function(low, high, start, end) {
        var center = this.xAxis.center,
          len = this.yAxis.len;
        return this.chart.renderer.symbols.arc(
          center[0],
          center[1],
          len - high,
          null, {
            start: start,
            end: end,
            innerR: len - pick(low, len)
          }
        );
      };
      wrap(colProto, 'animate', polarAnimate);
      wrap(colProto, 'translate', function(proceed) {
        var xAxis = this.xAxis,
          startAngleRad = xAxis.startAngleRad,
          start,
          points,
          point,
          i;
        this.preventPostTranslate = true;
        proceed.call(this);
        if (xAxis.isRadial) {
          points = this.points;
          i = points.length;
          while (i--) {
            point = points[i];
            start = point.barX + startAngleRad;
            point.shapeType = 'path';
            point.shapeArgs = {
              d: this.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth)
            };
            this.toXY(point);
            point.tooltipPos = [point.plotX, point.plotY];
            point.ttBelow = point.plotY > xAxis.center[1];
          }
        }
      });
      wrap(colProto, 'alignDataLabel', function(proceed, point, dataLabel, options, alignTo, isNew) {
        if (this.chart.polar) {
          var angle = point.rectPlotX / Math.PI * 180,
            align,
            verticalAlign;
          if (options.align === null) {
            if (angle > 20 && angle < 160) {
              align = 'left';
            } else if (angle > 200 && angle < 340) {
              align = 'right';
            } else {
              align = 'center';
            }
            options.align = align;
          }
          if (options.verticalAlign === null) {
            if (angle < 45 || angle > 315) {
              verticalAlign = 'bottom';
            } else if (angle > 135 && angle < 225) {
              verticalAlign = 'top';
            } else {
              verticalAlign = 'middle';
            }
            options.verticalAlign = verticalAlign;
          }
          seriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
        } else {
          proceed.call(this, point, dataLabel, options, alignTo, isNew);
        }
      });
    }
    wrap(pointerProto, 'getCoordinates', function(proceed, e) {
      var chart = this.chart,
        ret = {
          xAxis: [],
          yAxis: []
        };
      if (chart.polar) {
        each(chart.axes, function(axis) {
          var isXAxis = axis.isXAxis,
            center = axis.center,
            x = e.chartX - center[0] - chart.plotLeft,
            y = e.chartY - center[1] - chart.plotTop;
          ret[isXAxis ? 'xAxis' : 'yAxis'].push({
            axis: axis,
            value: axis.translate(
              isXAxis ?
              Math.PI - Math.atan2(x, y) :
              Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)),
              true
            )
          });
        });
      } else {
        ret = proceed.call(this, e);
      }
      return ret;
    });
  }(Highcharts));
}));;
/*! RESOURCE: /scripts/highcharts/modules/exporting.js */
(function(h) {
  "object" === typeof module && module.exports ? module.exports = h : h(Highcharts)
})(function(h) {
  (function(f) {
    var h = f.defaultOptions,
      n = f.doc,
      A = f.Chart,
      u = f.addEvent,
      F = f.removeEvent,
      D = f.fireEvent,
      q = f.createElement,
      B = f.discardElement,
      v = f.css,
      p = f.merge,
      C = f.pick,
      k = f.each,
      r = f.extend,
      G = f.isTouchDevice,
      E = f.win,
      H = f.Renderer.prototype.symbols;
    r(h.lang, {
      printChart: "Print chart",
      downloadPNG: "Download PNG image",
      downloadJPEG: "Download JPEG image",
      downloadPDF: "Download PDF document",
      downloadSVG: "Download SVG vector image",
      contextButtonTitle: "Chart context menu"
    });
    h.navigation = {
      buttonOptions: {
        theme: {},
        symbolSize: 14,
        symbolX: 12.5,
        symbolY: 10.5,
        align: "right",
        buttonSpacing: 3,
        height: 22,
        verticalAlign: "top",
        width: 24
      }
    };
    p(!0, h.navigation, {
      menuStyle: {
        border: "1px solid #999999",
        background: "#ffffff",
        padding: "5px 0"
      },
      menuItemStyle: {
        padding: "0.5em 1em",
        background: "none",
        color: "#333333",
        fontSize: G ? "14px" : "11px",
        transition: "background 250ms, color 250ms"
      },
      menuItemHoverStyle: {
        background: "#335cad",
        color: "#ffffff"
      },
      buttonOptions: {
        symbolFill: "#666666",
        symbolStroke: "#666666",
        symbolStrokeWidth: 3,
        theme: {
          fill: "#ffffff",
          stroke: "none",
          padding: 5
        }
      }
    });
    h.exporting = {
      type: "image/png",
      url: "https://export.highcharts.com/",
      printMaxWidth: 780,
      scale: 2,
      buttons: {
        contextButton: {
          className: "highcharts-contextbutton",
          menuClassName: "highcharts-contextmenu",
          symbol: "menu",
          _titleKey: "contextButtonTitle",
          menuItems: [{
              textKey: "printChart",
              onclick: function() {
                this.print()
              }
            }, {
              separator: !0
            }, {
              textKey: "downloadPNG",
              onclick: function() {
                this.exportChart()
              }
            }, {
              textKey: "downloadJPEG",
              onclick: function() {
                this.exportChart({
                  type: "image/jpeg"
                })
              }
            },
            {
              textKey: "downloadPDF",
              onclick: function() {
                this.exportChart({
                  type: "application/pdf"
                })
              }
            }, {
              textKey: "downloadSVG",
              onclick: function() {
                this.exportChart({
                  type: "image/svg+xml"
                })
              }
            }
          ]
        }
      }
    };
    f.post = function(a, c, e) {
      var b;
      a = q("form", p({
        method: "post",
        action: a,
        enctype: "multipart/form-data"
      }, e), {
        display: "none"
      }, n.body);
      for (b in c) q("input", {
        type: "hidden",
        name: b,
        value: c[b]
      }, null, a);
      a.submit();
      B(a)
    };
    r(A.prototype, {
      sanitizeSVG: function(a, c) {
        if (c && c.exporting && c.exporting.allowHTML) {
          var e = a.match(/<\/svg>(.*?$)/);
          e && (e =
            '\x3cforeignObject x\x3d"0" y\x3d"0" width\x3d"' + c.chart.width + '" height\x3d"' + c.chart.height + '"\x3e\x3cbody xmlns\x3d"http://www.w3.org/1999/xhtml"\x3e' + e[1] + "\x3c/body\x3e\x3c/foreignObject\x3e", a = a.replace("\x3c/svg\x3e", e + "\x3c/svg\x3e"))
        }
        a = a.replace(/zIndex="[^"]+"/g, "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '\x3csvg xmlns:xlink\x3d"http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g,
          " xlink:href\x3d").replace(/\n/, " ").replace(/<\/svg>.*?$/, "\x3c/svg\x3e").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1\x3d"rgb($2)" $1-opacity\x3d"$3"').replace(/&nbsp;/g, "\u00a0").replace(/&shy;/g, "\u00ad");
        return a = a.replace(/<IMG /g, "\x3cimage ").replace(/<(\/?)TITLE>/g, "\x3c$1title\x3e").replace(/height=([^" ]+)/g, 'height\x3d"$1"').replace(/width=([^" ]+)/g, 'width\x3d"$1"').replace(/hc-svg-href="([^"]+)">/g, 'xlink:href\x3d"$1"/\x3e').replace(/ id=([^" >]+)/g, ' id\x3d"$1"').replace(/class=([^" >]+)/g,
          'class\x3d"$1"').replace(/ transform /g, " ").replace(/:(path|rect)/g, "$1").replace(/style="([^"]+)"/g, function(a) {
          return a.toLowerCase()
        })
      },
      getChartHTML: function() {
        return this.container.innerHTML
      },
      getSVG: function(a) {
        var c, e, b, w, m, g = p(this.options, a);
        n.createElementNS || (n.createElementNS = function(a, c) {
          return n.createElement(c)
        });
        e = q("div", null, {
          position: "absolute",
          top: "-9999em",
          width: this.chartWidth + "px",
          height: this.chartHeight + "px"
        }, n.body);
        b = this.renderTo.style.width;
        m = this.renderTo.style.height;
        b = g.exporting.sourceWidth || g.chart.width || /px$/.test(b) && parseInt(b, 10) || 600;
        m = g.exporting.sourceHeight || g.chart.height || /px$/.test(m) && parseInt(m, 10) || 400;
        r(g.chart, {
          animation: !1,
          renderTo: e,
          forExport: !0,
          renderer: "SVGRenderer",
          width: b,
          height: m
        });
        g.exporting.enabled = !1;
        delete g.data;
        g.series = [];
        k(this.series, function(a) {
          w = p(a.userOptions, {
            animation: !1,
            enableMouseTracking: !1,
            showCheckbox: !1,
            visible: a.visible
          });
          w.isInternal || g.series.push(w)
        });
        k(this.axes, function(a) {
          a.userOptions.internalKey = f.uniqueKey()
        });
        c = new f.Chart(g, this.callback);
        a && k(["xAxis", "yAxis", "series"], function(b) {
          var d = {};
          a[b] && (d[b] = a[b], c.update(d))
        });
        k(this.axes, function(a) {
          var b = f.find(c.axes, function(b) {
              return b.options.internalKey === a.userOptions.internalKey
            }),
            d = a.getExtremes(),
            e = d.userMin,
            d = d.userMax;
          !b || void 0 === e && void 0 === d || b.setExtremes(e, d, !0, !1)
        });
        b = c.getChartHTML();
        b = this.sanitizeSVG(b, g);
        g = null;
        c.destroy();
        B(e);
        return b
      },
      getSVGForExport: function(a, c) {
        var e = this.options.exporting;
        return this.getSVG(p({
            chart: {
              borderRadius: 0
            }
          },
          e.chartOptions, c, {
            exporting: {
              sourceWidth: a && a.sourceWidth || e.sourceWidth,
              sourceHeight: a && a.sourceHeight || e.sourceHeight
            }
          }))
      },
      exportChart: function(a, c) {
        c = this.getSVGForExport(a, c);
        a = p(this.options.exporting, a);
        f.post(a.url, {
          filename: a.filename || "chart",
          type: a.type,
          width: a.width || 0,
          scale: a.scale,
          svg: c
        }, a.formAttributes)
      },
      print: function() {
        var a = this,
          c = a.container,
          e = [],
          b = c.parentNode,
          f = n.body,
          m = f.childNodes,
          g = a.options.exporting.printMaxWidth,
          d, t;
        if (!a.isPrinting) {
          a.isPrinting = !0;
          a.pointer.reset(null,
            0);
          D(a, "beforePrint");
          if (t = g && a.chartWidth > g) d = [a.options.chart.width, void 0, !1], a.setSize(g, void 0, !1);
          k(m, function(a, b) {
            1 === a.nodeType && (e[b] = a.style.display, a.style.display = "none")
          });
          f.appendChild(c);
          E.focus();
          E.print();
          setTimeout(function() {
            b.appendChild(c);
            k(m, function(a, b) {
              1 === a.nodeType && (a.style.display = e[b])
            });
            a.isPrinting = !1;
            t && a.setSize.apply(a, d);
            D(a, "afterPrint")
          }, 1E3)
        }
      },
      contextMenu: function(a, c, e, b, f, m, g) {
        var d = this,
          t = d.options.navigation,
          w = d.chartWidth,
          h = d.chartHeight,
          p = "cache-" + a,
          l = d[p],
          x = Math.max(f, m),
          y, z;
        l || (d[p] = l = q("div", {
            className: a
          }, {
            position: "absolute",
            zIndex: 1E3,
            padding: x + "px"
          }, d.container), y = q("div", {
            className: "highcharts-menu"
          }, null, l), v(y, r({
            MozBoxShadow: "3px 3px 10px #888",
            WebkitBoxShadow: "3px 3px 10px #888",
            boxShadow: "3px 3px 10px #888"
          }, t.menuStyle)), z = function() {
            v(l, {
              display: "none"
            });
            g && g.setState(0);
            d.openMenu = !1
          }, u(l, "mouseleave", function() {
            l.hideTimer = setTimeout(z, 500)
          }), u(l, "mouseenter", function() {
            clearTimeout(l.hideTimer)
          }), p = u(n, "mouseup", function(b) {
            d.pointer.inClass(b.target,
              a) || z()
          }), u(d, "destroy", p), k(c, function(a) {
            if (a) {
              var b;
              a.separator ? b = q("hr", null, null, y) : (b = q("div", {
                className: "highcharts-menu-item",
                onclick: function(b) {
                  b && b.stopPropagation();
                  z();
                  a.onclick && a.onclick.apply(d, arguments)
                },
                innerHTML: a.text || d.options.lang[a.textKey]
              }, null, y), b.onmouseover = function() {
                v(this, t.menuItemHoverStyle)
              }, b.onmouseout = function() {
                v(this, t.menuItemStyle)
              }, v(b, r({
                cursor: "pointer"
              }, t.menuItemStyle)));
              d.exportDivElements.push(b)
            }
          }), d.exportDivElements.push(y, l), d.exportMenuWidth =
          l.offsetWidth, d.exportMenuHeight = l.offsetHeight);
        c = {
          display: "block"
        };
        e + d.exportMenuWidth > w ? c.right = w - e - f - x + "px" : c.left = e - x + "px";
        b + m + d.exportMenuHeight > h && "top" !== g.alignOptions.verticalAlign ? c.bottom = h - b - x + "px" : c.top = b + m - x + "px";
        v(l, c);
        d.openMenu = !0
      },
      addButton: function(a) {
        var c = this,
          e = c.renderer,
          b = p(c.options.navigation.buttonOptions, a),
          f = b.onclick,
          m = b.menuItems,
          g, d, h = b.symbolSize || 12;
        c.btnCount || (c.btnCount = 0);
        c.exportDivElements || (c.exportDivElements = [], c.exportSVGElements = []);
        if (!1 !== b.enabled) {
          var k =
            b.theme,
            n = k.states,
            q = n && n.hover,
            n = n && n.select,
            l;
          delete k.states;
          f ? l = function(a) {
            a.stopPropagation();
            f.call(c, a)
          } : m && (l = function() {
            c.contextMenu(d.menuClassName, m, d.translateX, d.translateY, d.width, d.height, d);
            d.setState(2)
          });
          b.text && b.symbol ? k.paddingLeft = C(k.paddingLeft, 25) : b.text || r(k, {
            width: b.width,
            height: b.height,
            padding: 0
          });
          d = e.button(b.text, 0, 0, l, k, q, n).addClass(a.className).attr({
            "stroke-linecap": "round",
            title: c.options.lang[b._titleKey],
            zIndex: 3
          });
          d.menuClassName = a.menuClassName || "highcharts-menu-" +
            c.btnCount++;
          b.symbol && (g = e.symbol(b.symbol, b.symbolX - h / 2, b.symbolY - h / 2, h, h).addClass("highcharts-button-symbol").attr({
            zIndex: 1
          }).add(d), g.attr({
            stroke: b.symbolStroke,
            fill: b.symbolFill,
            "stroke-width": b.symbolStrokeWidth || 1
          }));
          d.add().align(r(b, {
            width: d.width,
            x: C(b.x, c.buttonOffset)
          }), !0, "spacingBox");
          c.buttonOffset += (d.width + b.buttonSpacing) * ("right" === b.align ? -1 : 1);
          c.exportSVGElements.push(d, g)
        }
      },
      destroyExport: function(a) {
        var c = a ? a.target : this;
        a = c.exportSVGElements;
        var e = c.exportDivElements;
        a &&
          (k(a, function(a, e) {
            a && (a.onclick = a.ontouchstart = null, c.exportSVGElements[e] = a.destroy())
          }), a.length = 0);
        e && (k(e, function(a, e) {
          clearTimeout(a.hideTimer);
          F(a, "mouseleave");
          c.exportDivElements[e] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
          B(a)
        }), e.length = 0)
      }
    });
    H.menu = function(a, c, e, b) {
      return ["M", a, c + 2.5, "L", a + e, c + 2.5, "M", a, c + b / 2 + .5, "L", a + e, c + b / 2 + .5, "M", a, c + b - 1.5, "L", a + e, c + b - 1.5]
    };
    A.prototype.renderExporting = function() {
      var a, c = this.options.exporting,
        e = c.buttons,
        b = this.isDirtyExporting || !this.exportSVGElements;
      this.buttonOffset = 0;
      this.isDirtyExporting && this.destroyExport();
      if (b && !1 !== c.enabled) {
        for (a in e) this.addButton(e[a]);
        this.isDirtyExporting = !1
      }
      u(this, "destroy", this.destroyExport)
    };
    A.prototype.callbacks.push(function(a) {
      a.renderExporting();
      u(a, "redraw", a.renderExporting);
      k(["exporting", "navigation"], function(c) {
        a[c] = {
          update: function(e, b) {
            a.isDirtyExporting = !0;
            p(!0, a.options[c], e);
            C(b, !0) && a.redraw()
          }
        }
      })
    })
  })(h)
});;
/*! RESOURCE: /scripts/highcharts/modules/offline-exporting.js */
(function(n) {
  "object" === typeof module && module.exports ? module.exports = n : n(Highcharts)
})(function(n) {
  (function(d) {
    function n(a, d) {
      var c = t.getElementsByTagName("head")[0],
        b = t.createElement("script");
      b.type = "text/javascript";
      b.src = a;
      b.onload = d;
      b.onerror = function() {
        console.error("Error loading script", a)
      };
      c.appendChild(b)
    }
    var C = d.merge,
      e = d.win,
      r = e.navigator,
      t = e.document,
      z = d.each,
      w = e.URL || e.webkitURL || e,
      B = /Edge\/|Trident\/|MSIE /.test(r.userAgent),
      D = /Edge\/\d+/.test(r.userAgent),
      E = B ? 150 : 0;
    d.CanVGRenderer = {};
    d.dataURLtoBlob = function(a) {
      if (e.atob && e.ArrayBuffer && e.Uint8Array && e.Blob && w.createObjectURL) {
        a = a.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
        for (var d = e.atob(a[3]), c = new e.ArrayBuffer(d.length), c = new e.Uint8Array(c), b = 0; b < c.length; ++b) c[b] = d.charCodeAt(b);
        a = new e.Blob([c], {
          type: a[1]
        });
        return w.createObjectURL(a)
      }
    };
    d.downloadURL = function(a, f) {
      var c = t.createElement("a"),
        b;
      if (r.msSaveOrOpenBlob) r.msSaveOrOpenBlob(a, f);
      else {
        if (2E6 < a.length && (a = d.dataURLtoBlob(a), !a)) throw "Data URL length limit reached";
        if (void 0 !== c.download) c.href = a, c.download = f, c.target = "_blank", t.body.appendChild(c), c.click(), t.body.removeChild(c);
        else try {
          if (b = e.open(a, "chart"), void 0 === b || null === b) throw "Failed to open window";
        } catch (u) {
          e.location.href = a
        }
      }
    };
    d.svgToDataUrl = function(a) {
      var d = -1 < r.userAgent.indexOf("WebKit") && 0 > r.userAgent.indexOf("Chrome");
      try {
        if (!d && 0 > r.userAgent.toLowerCase().indexOf("firefox")) return w.createObjectURL(new e.Blob([a], {
          type: "image/svg+xml;charset-utf-16"
        }))
      } catch (c) {}
      return "data:image/svg+xml;charset\x3dUTF-8," +
        encodeURIComponent(a)
    };
    d.imageToDataUrl = function(a, d, c, b, u, l, k, m, p) {
      var g = new e.Image,
        h, f = function() {
          setTimeout(function() {
            var e = t.createElement("canvas"),
              f = e.getContext && e.getContext("2d"),
              x;
            try {
              if (f) {
                e.height = g.height * b;
                e.width = g.width * b;
                f.drawImage(g, 0, 0, e.width, e.height);
                try {
                  x = e.toDataURL(d), u(x, d, c, b)
                } catch (F) {
                  h(a, d, c, b)
                }
              } else k(a, d, c, b)
            } finally {
              p && p(a, d, c, b)
            }
          }, E)
        },
        q = function() {
          m(a, d, c, b);
          p && p(a, d, c, b)
        };
      h = function() {
        g = new e.Image;
        h = l;
        g.crossOrigin = "Anonymous";
        g.onload = f;
        g.onerror = q;
        g.src = a
      };
      g.onload = f;
      g.onerror = q;
      g.src = a
    };
    d.downloadSVGLocal = function(a, f, c, b) {
      function u(b, a) {
        a = new e.jsPDF("l", "pt", [b.width.baseVal.value + 2 * a, b.height.baseVal.value + 2 * a]);
        e.svg2pdf(b, a, {
          removeInvalid: !0
        });
        return a.output("datauristring")
      }

      function l() {
        y.innerHTML = a;
        var e = y.getElementsByTagName("text"),
          g, f = y.getElementsByTagName("svg")[0].style;
        z(e, function(b) {
          z(["font-family", "font-size"], function(a) {
            !b.style[a] && f[a] && (b.style[a] = f[a])
          });
          b.style["font-family"] = b.style["font-family"] && b.style["font-family"].split(" ").splice(-1);
          g = b.getElementsByTagName("title");
          z(g, function(a) {
            b.removeChild(a)
          })
        });
        e = u(y.firstChild, 0);
        try {
          d.downloadURL(e, v), b && b()
        } catch (G) {
          c()
        }
      }
      var k, m, p = !0,
        g, h = f.libURL || d.getOptions().exporting.libURL,
        y = t.createElement("div"),
        q = f.type || "image/png",
        v = (f.filename || "chart") + "." + ("image/svg+xml" === q ? "svg" : q.split("/")[1]),
        A = f.scale || 1,
        h = "/" !== h.slice(-1) ? h + "/" : h;
      if ("image/svg+xml" === q) try {
        r.msSaveOrOpenBlob ? (m = new MSBlobBuilder, m.append(a), k = m.getBlob("image/svg+xml")) : k = d.svgToDataUrl(a), d.downloadURL(k, v),
          b && b()
      } catch (x) {
        c()
      } else "application/pdf" === q ? e.jsPDF && e.svg2pdf ? l() : (p = !0, n(h + "jspdf.js", function() {
        n(h + "svg2pdf.js", function() {
          l()
        })
      })) : (k = d.svgToDataUrl(a), g = function() {
        try {
          w.revokeObjectURL(k)
        } catch (x) {}
      }, d.imageToDataUrl(k, q, {}, A, function(a) {
        try {
          d.downloadURL(a, v), b && b()
        } catch (F) {
          c()
        }
      }, function() {
        var f = t.createElement("canvas"),
          u = f.getContext("2d"),
          l = a.match(/^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/)[1] * A,
          k = a.match(/^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/)[1] * A,
          m = function() {
            u.drawSvg(a, 0, 0,
              l, k);
            try {
              d.downloadURL(r.msSaveOrOpenBlob ? f.msToBlob() : f.toDataURL(q), v), b && b()
            } catch (H) {
              c()
            } finally {
              g()
            }
          };
        f.width = l;
        f.height = k;
        e.canvg ? m() : (p = !0, n(h + "rgbcolor.js", function() {
          n(h + "canvg.js", function() {
            m()
          })
        }))
      }, c, c, function() {
        p && g()
      }))
    };
    d.Chart.prototype.getSVGForLocalExport = function(a, e, c, b) {
      var f = this,
        l, k = 0,
        m, p, g, h, n, q = function(a, d, c) {
          ++k;
          c.imageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", a);
          k === l.length && b(f.sanitizeSVG(m.innerHTML, p))
        };
      d.wrap(d.Chart.prototype, "getChartHTML",
        function(b) {
          var a = b.apply(this, Array.prototype.slice.call(arguments, 1));
          p = this.options;
          m = this.container.cloneNode(!0);
          return a
        });
      f.getSVGForExport(a, e);
      l = m.getElementsByTagName("image");
      try {
        if (l.length)
          for (h = 0, n = l.length; h < n; ++h) g = l[h], d.imageToDataUrl(g.getAttributeNS("http://www.w3.org/1999/xlink", "href"), "image/png", {
            imageElement: g
          }, a.scale, q, c, c, c);
        else b(f.sanitizeSVG(m.innerHTML, p))
      } catch (v) {
        c()
      }
    };
    d.Chart.prototype.exportChartLocal = function(a, e) {
      var c = this,
        b = d.merge(c.options.exporting, a),
        f =
        function() {
          if (!1 === b.fallbackToExportServer)
            if (b.error) b.error(b);
            else throw "Fallback to export server disabled";
          else c.exportChart(b)
        };
      B && ("application/pdf" === b.type || c.container.getElementsByTagName("image").length && "image/svg+xml" !== b.type) || D && "image/svg+xml" !== b.type || "application/pdf" === b.type && c.container.getElementsByTagName("image").length ? f() : c.getSVGForLocalExport(b, e, f, function(a) {
        -1 < a.indexOf("\x3cforeignObject") && "image/svg+xml" !== b.type ? f() : d.downloadSVGLocal(a, b, f)
      })
    };
    C(!0, d.getOptions().exporting, {
      libURL: "https://code.highcharts.com/5.0.7/lib/",
      buttons: {
        contextButton: {
          menuItems: [{
            textKey: "printChart",
            onclick: function() {
              this.print()
            }
          }, {
            separator: !0
          }, {
            textKey: "downloadPNG",
            onclick: function() {
              this.exportChartLocal()
            }
          }, {
            textKey: "downloadJPEG",
            onclick: function() {
              this.exportChartLocal({
                type: "image/jpeg"
              })
            }
          }, {
            textKey: "downloadSVG",
            onclick: function() {
              this.exportChartLocal({
                type: "image/svg+xml"
              })
            }
          }, {
            textKey: "downloadPDF",
            onclick: function() {
              this.exportChartLocal({
                type: "application/pdf"
              })
            }
          }]
        }
      }
    })
  })(n)
});;
/*! RESOURCE: /scripts/highcharts/modules/export-csv.js */
(function(factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory;
  } else {
    factory(Highcharts);
  }
})(function(Highcharts) {
  'use strict';
  var each = Highcharts.each,
    pick = Highcharts.pick,
    seriesTypes = Highcharts.seriesTypes,
    downloadAttrSupported = document.createElement('a').download !== undefined;
  Highcharts.setOptions({
    lang: {
      downloadCSV: 'Download CSV',
      downloadXLS: 'Download XLS',
      viewData: 'View data table'
    }
  });
  Highcharts.Chart.prototype.getDataRows = function() {
    var options = (this.options.exporting || {}).csv || {},
      xAxis = this.xAxis[0],
      rows = {},
      rowArr = [],
      dataRows,
      names = [],
      i,
      x,
      xTitle,
      dateFormat = options.dateFormat || '%Y-%m-%d %H:%M:%S',
      columnHeaderFormatter = options.columnHeaderFormatter || function(item, key, keyLength) {
        if (item instanceof Highcharts.Axis) {
          return (item.options.title && item.options.title.text) ||
            (item.isDatetimeAxis ? 'DateTime' : 'Category');
        }
        return item.name + (keyLength > 1 ? ' (' + key + ')' : '');
      };
    i = 0;
    each(this.series, function(series) {
      var keys = series.options.keys,
        pointArrayMap = keys || series.pointArrayMap || ['y'],
        valueCount = pointArrayMap.length,
        requireSorting = series.requireSorting,
        categoryMap = {},
        j;
      each(pointArrayMap, function(prop) {
        categoryMap[prop] = (series[prop + 'Axis'] && series[prop + 'Axis'].categories) || [];
      });
      if (series.options.includeInCSVExport !== false && series.visible !== false) {
        j = 0;
        while (j < valueCount) {
          names.push(columnHeaderFormatter(series, pointArrayMap[j], pointArrayMap.length));
          j = j + 1;
        }
        each(series.points, function(point, pIdx) {
          var key = requireSorting ? point.x : pIdx,
            prop,
            val;
          j = 0;
          if (!rows[key]) {
            rows[key] = [];
          }
          rows[key].x = point.x;
          if (!series.xAxis || series.exportKey === 'name') {
            rows[key].name = point.name;
          }
          while (j < valueCount) {
            prop = pointArrayMap[j];
            val = point[prop];
            rows[key][i + j] = pick(categoryMap[prop][val], val);
            j = j + 1;
          }
        });
        i = i + j;
      }
    });
    for (x in rows) {
      if (rows.hasOwnProperty(x)) {
        rowArr.push(rows[x]);
      }
    }
    rowArr.sort(function(a, b) {
      return a.x - b.x;
    });
    xTitle = columnHeaderFormatter(xAxis);
    dataRows = [
      [xTitle].concat(names)
    ];
    each(rowArr, function(row) {
      var category = row.name;
      if (!category) {
        if (xAxis.isDatetimeAxis) {
          if (row.x instanceof Date) {
            row.x = row.x.getTime();
          }
          category = Highcharts.dateFormat(dateFormat, row.x);
        } else if (xAxis.categories) {
          category = pick(xAxis.names[row.x], xAxis.categories[row.x], row.x)
        } else {
          category = row.x;
        }
      }
      row.unshift(category);
      dataRows.push(row);
    });
    return dataRows;
  };
  Highcharts.Chart.prototype.getCSV = function(useLocalDecimalPoint) {
    var csv = '',
      rows = this.getDataRows(),
      options = (this.options.exporting || {}).csv || {},
      itemDelimiter = options.itemDelimiter || ',',
      lineDelimiter = options.lineDelimiter || '\n';
    each(rows, function(row, i) {
      var val = '',
        j = row.length,
        n = useLocalDecimalPoint ? (1.1).toLocaleString()[1] : '.';
      while (j--) {
        val = row[j];
        if (typeof val === "string") {
          val = '"' + val + '"';
        }
        if (typeof val === 'number') {
          if (n === ',') {
            val = val.toString().replace(".", ",");
          }
        }
        row[j] = val;
      }
      csv += row.join(itemDelimiter);
      if (i < rows.length - 1) {
        csv += lineDelimiter;
      }
    });
    return csv;
  };
  Highcharts.Chart.prototype.getTable = function(useLocalDecimalPoint) {
    var html = '<table>',
      rows = this.getDataRows();
    each(rows, function(row, i) {
      var tag = i ? 'td' : 'th',
        val,
        j,
        n = useLocalDecimalPoint ? (1.1).toLocaleString()[1] : '.';
      html += '<tr>';
      for (j = 0; j < row.length; j = j + 1) {
        val = row[j];
        if (typeof val === 'number') {
          val = val.toString();
          if (n === ',') {
            val = val.replace('.', n);
          }
          html += '<' + tag + ' class="number">' + val + '</' + tag + '>';
        } else {
          html += '<' + tag + '>' + (val === undefined ? '' : val) + '</' + tag + '>';
        }
      }
      html += '</tr>';
    });
    html += '</table>';
    return html;
  };

  function getContent(chart, href, extension, content, MIME) {
    var a,
      blobObject,
      name,
      options = (chart.options.exporting || {}).csv || {},
      url = options.url || 'http://www.highcharts.com/studies/csv-export/download.php';
    if (chart.options.exporting.filename) {
      name = chart.options.exporting.filename;
    } else if (chart.title) {
      name = chart.title.textStr.replace(/ /g, '-').toLowerCase();
    } else {
      name = 'chart';
    }
    if (window.Blob && window.navigator.msSaveOrOpenBlob) {
      blobObject = new Blob([content]);
      window.navigator.msSaveOrOpenBlob(blobObject, name + '.' + extension);
    } else if (downloadAttrSupported) {
      a = document.createElement('a');
      a.href = href;
      a.target = '_blank';
      a.download = name + '.' + extension;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } else {
      Highcharts.post(url, {
        data: content,
        type: MIME,
        extension: extension
      });
    }
  }
  Highcharts.Chart.prototype.downloadCSV = function() {
    var csv = this.getCSV(true);
    getContent(
      this,
      'data:text/csv,\uFEFF' + csv.replace(/\n/g, '%0A'),
      'csv',
      csv,
      'text/csv'
    );
  };
  Highcharts.Chart.prototype.downloadXLS = function() {
    var uri = 'data:application/vnd.ms-excel;base64,',
      template = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' +
      '<head><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet>' +
      '<x:Name>Ark1</x:Name>' +
      '<x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]-->' +
      '<style>td{border:none;font-family: Calibri, sans-serif;} .number{mso-number-format:"0.00";}</style>' +
      '<meta name=ProgId content=Excel.Sheet>' +
      '<meta charset=UTF-8>' +
      '</head><body>' +
      this.getTable(true) +
      '</body></html>',
      base64 = function(s) {
        return window.btoa(unescape(encodeURIComponent(s)));
      };
    getContent(
      this,
      uri + base64(template),
      'xls',
      template,
      'application/vnd.ms-excel'
    );
  };
  Highcharts.Chart.prototype.viewData = function() {
    if (!this.insertedTable) {
      var div = document.createElement('div');
      div.className = 'highcharts-data-table';
      this.renderTo.parentNode.insertBefore(div, this.renderTo.nextSibling);
      div.innerHTML = this.getTable();
      this.insertedTable = true;
    }
  };
  if (Highcharts.getOptions().exporting) {
    Highcharts.getOptions().exporting.buttons.contextButton.menuItems.push({
      textKey: 'downloadCSV',
      onclick: function() {
        this.downloadCSV();
      }
    }, {
      textKey: 'downloadXLS',
      onclick: function() {
        this.downloadXLS();
      }
    }, {
      textKey: 'viewData',
      onclick: function() {
        this.viewData();
      }
    });
  }
  if (seriesTypes.map) {
    seriesTypes.map.prototype.exportKey = 'name';
  }
  if (seriesTypes.mapbubble) {
    seriesTypes.mapbubble.prototype.exportKey = 'name';
  }
});;
/*! RESOURCE: /scripts/highcharts/modules/accessibility.js */
(function(n) {
  "object" === typeof module && module.exports ? module.exports = n : n(Highcharts)
})(function(n) {
  (function(e) {
    function n(a) {
      return a.replace(/&/g, "\x26amp;").replace(/</g, "\x26lt;").replace(/>/g, "\x26gt;").replace(/"/g, "\x26quot;").replace(/'/g, "\x26#x27;").replace(/\//g, "\x26#x2F;")
    }

    function A(a) {
      for (var b = a.childNodes.length; b--;) a.appendChild(a.childNodes[b])
    }

    function k(a) {
      var b;
      a && a.onclick && (b = l.createEvent("Events"), b.initEvent("click", !0, !1), a.onclick(b))
    }
    var y = e.win,
      l = y.document,
      g = e.each,
      B = e.erase,
      u = e.addEvent,
      C = e.removeEvent,
      w = e.fireEvent,
      D = e.dateFormat,
      v = e.merge,
      r = {
        "default": ["series", "data point", "data points"],
        line: ["line", "data point", "data points"],
        spline: ["line", "data point", "data points"],
        area: ["line", "data point", "data points"],
        areaspline: ["line", "data point", "data points"],
        pie: ["pie", "slice", "slices"],
        column: ["column series", "column", "columns"],
        bar: ["bar series", "bar", "bars"],
        scatter: ["scatter series", "data point", "data points"],
        boxplot: ["boxplot series", "box", "boxes"],
        arearange: ["arearange series", "data point", "data points"],
        areasplinerange: ["areasplinerange series", "data point", "data points"],
        bubble: ["bubble series", "bubble", "bubbles"],
        columnrange: ["columnrange series", "column", "columns"],
        errorbar: ["errorbar series", "errorbar", "errorbars"],
        funnel: ["funnel", "data point", "data points"],
        pyramid: ["pyramid", "data point", "data points"],
        waterfall: ["waterfall series", "column", "columns"],
        map: ["map", "area", "areas"],
        mapline: ["line", "data point", "data points"],
        mappoint: ["point series",
          "data point", "data points"
        ],
        mapbubble: ["bubble series", "bubble", "bubbles"]
      },
      E = {
        boxplot: " Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile and maximum. ",
        arearange: " Arearange charts are line charts displaying a range between a lower and higher value for each point. ",
        areasplinerange: " These charts are line charts displaying a range between a lower and higher value for each point. ",
        bubble: " Bubble charts are scatter charts where each data point also has a size value. ",
        columnrange: " Columnrange charts are column charts displaying a range between a lower and higher value for each point. ",
        errorbar: " Errorbar series are used to display the variability of the data. ",
        funnel: " Funnel charts are used to display reduction of data in stages. ",
        pyramid: " Pyramid charts consist of a single pyramid with item heights corresponding to each point value. ",
        waterfall: " A waterfall chart is a column chart where each column contributes towards a total end value. "
      },
      F = "name id category x value y".split(" "),
      z = "z open high q3 median q1 low close".split(" ");
    e.setOptions({
      accessibility: {
        enabled: !0,
        pointDescriptionThreshold: 30,
        keyboardNavigation: {
          enabled: !0
        }
      }
    });
    e.wrap(e.Series.prototype, "render", function(a) {
      a.apply(this, Array.prototype.slice.call(arguments, 1));
      this.chart.options.accessibility.enabled && this.setA11yDescription()
    });
    e.Series.prototype.setA11yDescription = function() {
      var a = this.chart.options.accessibility,
        b = this.points && this.points.length && this.points[0].graphic &&
        this.points[0].graphic.element,
        d = b && b.parentNode || this.graph && this.graph.element || this.group && this.group.element;
      d && (d.lastChild === b && A(d), this.points && (this.points.length < a.pointDescriptionThreshold || !1 === a.pointDescriptionThreshold) && g(this.points, function(c) {
          c.graphic && (c.graphic.element.setAttribute("role", "img"), c.graphic.element.setAttribute("tabindex", "-1"), c.graphic.element.setAttribute("aria-label", a.pointDescriptionFormatter && a.pointDescriptionFormatter(c) || c.buildPointInfoString()))
        }),
        1 < this.chart.series.length || a.describeSingleSeries) && (d.setAttribute("role", "region"), d.setAttribute("tabindex", "-1"), d.setAttribute("aria-label", a.seriesDescriptionFormatter && a.seriesDescriptionFormatter(this) || this.buildSeriesInfoString()))
    };
    e.Series.prototype.buildSeriesInfoString = function() {
      var a = r[this.type] || r.default,
        b = this.description || this.options.description;
      return (this.name ? this.name + ", " : "") + (1 === this.chart.types.length ? a[0] : "series") + " " + (this.index + 1) + " of " + this.chart.series.length +
        (1 === this.chart.types.length ? " with " : ". " + a[0] + " with ") + (this.points.length + " " + (1 === this.points.length ? a[1] : a[2])) + (b ? ". " + b : "") + (1 < this.chart.yAxis.length && this.yAxis ? ". Y axis, " + this.yAxis.getDescription() : "") + (1 < this.chart.xAxis.length && this.xAxis ? ". X axis, " + this.xAxis.getDescription() : "")
    };
    e.Point.prototype.buildPointInfoString = function() {
      var a = this,
        b = a.series,
        d = b.chart.options.accessibility,
        c = "",
        f = !1,
        x = b.xAxis && b.xAxis.isDatetimeAxis,
        b = x && D(d.pointDateFormatter && d.pointDateFormatter(a) ||
          d.pointDateFormat || e.Tooltip.prototype.getXDateFormat(a, b.chart.options.tooltip, b.xAxis), a.x);
      g(z, function(c) {
        void 0 !== a[c] && (f = !0)
      });
      f ? (x && (c = b), g(F.concat(z), function(b) {
        void 0 === a[b] || x && "x" === b || (c += (c ? ". " : "") + b + ", " + this[b])
      })) : c = (this.name || b || this.category || this.id || "x, " + this.x) + ", " + (void 0 !== this.value ? this.value : this.y);
      return this.index + 1 + ". " + c + "." + (this.description ? " " + this.description : "")
    };
    e.Axis.prototype.getDescription = function() {
      return this.userOptions && this.userOptions.description ||
        this.axisTitle && this.axisTitle.textStr || this.options.id || this.categories && "categories" || "values"
    };
    e.Axis.prototype.panStep = function(a, b) {
      var d = b || 3;
      b = this.getExtremes();
      var c = (b.max - b.min) / d * a,
        d = b.max + c,
        c = b.min + c,
        f = d - c;
      0 > a && c < b.dataMin ? (c = b.dataMin, d = c + f) : 0 < a && d > b.dataMax && (d = b.dataMax, c = d - f);
      this.setExtremes(c, d)
    };
    e.wrap(e.Series.prototype, "init", function(a) {
      a.apply(this, Array.prototype.slice.call(arguments, 1));
      var b = this.chart;
      b.options.accessibility.enabled && (b.types = b.types || [], 0 > b.types.indexOf(this.type) &&
        b.types.push(this.type), u(this, "remove", function() {
          var a = this,
            c = !1;
          g(b.series, function(f) {
            f !== a && 0 > b.types.indexOf(a.type) && (c = !0)
          });
          c || B(b.types, a.type)
        }))
    });
    e.Chart.prototype.getTypeDescription = function() {
      var a = this.types && this.types[0],
        b = this.series[0] && this.series[0].mapTitle;
      if (a) {
        if ("map" === a) return b ? "Map of " + b : "Map of unspecified region.";
        if (1 < this.types.length) return "Combination chart.";
        if (-1 < ["spline", "area", "areaspline"].indexOf(a)) return "Line chart."
      } else return "Empty chart.";
      return a +
        " chart." + (E[a] || "")
    };
    e.Chart.prototype.getAxesDescription = function() {
      var a = this.xAxis.length,
        b = this.yAxis.length,
        d = {},
        c;
      if (a)
        if (d.xAxis = "The chart has " + a + (1 < a ? " X axes" : " X axis") + " displaying ", 2 > a) d.xAxis += this.xAxis[0].getDescription() + ".";
        else {
          for (c = 0; c < a - 1; ++c) d.xAxis += (c ? ", " : "") + this.xAxis[c].getDescription();
          d.xAxis += " and " + this.xAxis[c].getDescription() + "."
        } if (b)
        if (d.yAxis = "The chart has " + b + (1 < b ? " Y axes" : " Y axis") + " displaying ", 2 > b) d.yAxis += this.yAxis[0].getDescription() + ".";
        else {
          for (c =
            0; c < b - 1; ++c) d.yAxis += (c ? ", " : "") + this.yAxis[c].getDescription();
          d.yAxis += " and " + this.yAxis[c].getDescription() + "."
        } return d
    };
    e.Chart.prototype.addAccessibleContextMenuAttribs = function() {
      var a = this.exportDivElements;
      a && (g(a, function(b) {
        "DIV" !== b.tagName || b.children && b.children.length || (b.setAttribute("role", "menuitem"), b.setAttribute("tabindex", -1))
      }), a[0].parentNode.setAttribute("role", "menu"), a[0].parentNode.setAttribute("aria-label", "Chart export"))
    };
    e.Point.prototype.highlight = function() {
      var a =
        this.series.chart;
      this.graphic && this.graphic.element.focus && this.graphic.element.focus();
      this.isNull ? a.tooltip.hide(0) : (this.onMouseOver(), a.tooltip.refresh(a.tooltip.shared ? [this] : this));
      a.highlightedPoint = this;
      return this
    };
    e.Chart.prototype.highlightAdjacentPoint = function(a) {
      var b = this.series,
        d = this.highlightedPoint,
        c = d && d.index || 0;
      if (!b[0] || !b[0].points) return !1;
      if (!d) return b[0].points[0].highlight();
      if (d.series.points[c] !== d)
        for (var f = 0; f < d.series.points.length; ++f)
          if (d.series.points[f] === d) {
            c =
              f;
            break
          } b = b[d.series.index + (a ? 1 : -1)];
      d = d.series.points[c + (a ? 1 : -1)] || b && b.points[a ? 0 : b.points.length - 1];
      return void 0 === d ? !1 : d.isNull && this.options.accessibility.keyboardNavigation && this.options.accessibility.keyboardNavigation.skipNullPoints ? (this.highlightedPoint = d, this.highlightAdjacentPoint(a)) : d.highlight()
    };
    e.Chart.prototype.showExportMenu = function() {
      this.exportSVGElements && this.exportSVGElements[0] && (this.exportSVGElements[0].element.onclick(), this.highlightExportItem(0))
    };
    e.Chart.prototype.highlightExportItem =
      function(a) {
        var b = this.exportDivElements && this.exportDivElements[a],
          d = this.exportDivElements && this.exportDivElements[this.highlightedExportItem];
        if (b && "DIV" === b.tagName && (!b.children || !b.children.length)) {
          b.focus && b.focus();
          if (d && d.onmouseout) d.onmouseout();
          if (b.onmouseover) b.onmouseover();
          this.highlightedExportItem = a;
          return !0
        }
      };
    e.Chart.prototype.highlightRangeSelectorButton = function(a) {
      var b = this.rangeSelector.buttons;
      b[this.highlightedRangeSelectorItemIx] && b[this.highlightedRangeSelectorItemIx].setState(this.oldRangeSelectorItemState ||
        0);
      this.highlightedRangeSelectorItemIx = a;
      return b[a] ? (b[a].element.focus && b[a].element.focus(), this.oldRangeSelectorItemState = b[a].state, b[a].setState(2), !0) : !1
    };
    e.Chart.prototype.highlightLegendItem = function(a) {
      var b = this.legend.allItems;
      b[this.highlightedLegendItemIx] && w(b[this.highlightedLegendItemIx].legendGroup.element, "mouseout");
      this.highlightedLegendItemIx = a;
      return b[a] ? (b[a].legendGroup.element.focus && b[a].legendGroup.element.focus(), w(b[a].legendGroup.element, "mouseover"), !0) : !1
    };
    e.Chart.prototype.hideExportMenu =
      function() {
        var a = this.exportDivElements;
        if (a) {
          g(a, function(b) {
            w(b, "mouseleave")
          });
          if (a[this.highlightedExportItem] && a[this.highlightedExportItem].onmouseout) a[this.highlightedExportItem].onmouseout();
          this.highlightedExportItem = 0;
          this.renderTo.focus()
        }
      };
    e.Chart.prototype.addKeyboardNavEvents = function() {
      function a(c) {
        this.keyCodeMap = c.keyCodeMap;
        this.move = c.move;
        this.validate = c.validate;
        this.init = c.init;
        this.transformTabs = !1 !== c.transformTabs
      }

      function b(b, d) {
        return new a(v({
          keyCodeMap: b,
          move: function(b) {
            c.keyboardNavigationModuleIndex +=
              b;
            var a = c.keyboardNavigationModules[c.keyboardNavigationModuleIndex];
            if (a) {
              if (a.validate && !a.validate()) return this.move(b);
              if (a.init) return a.init(b), !0
            }
            c.keyboardNavigationModuleIndex = 0;
            c.slipNextTab = !0;
            return !1
          }
        }, d))
      }

      function d(b) {
        b = b || y.event;
        var a = c.keyboardNavigationModules[c.keyboardNavigationModuleIndex];
        9 === (b.which || b.keyCode) && c.slipNextTab ? c.slipNextTab = !1 : (c.slipNextTab = !1, a && a.run(b) && b.preventDefault())
      }
      var c = this;
      a.prototype = {
        run: function(c) {
          var b = this,
            a = c.which || c.keyCode,
            f = !1,
            a =
            this.transformTabs && 9 === a ? c.shiftKey ? 37 : 39 : a;
          g(this.keyCodeMap, function(d) {
            -1 < d[0].indexOf(a) && (f = !1 === d[1].call(b, a, c) ? !1 : !0)
          });
          return f
        }
      };
      c.keyboardNavigationModules = [b([
        [
          [37, 39],
          function(b) {
            if (!c.highlightAdjacentPoint(39 === b)) return this.move(39 === b ? 1 : -1)
          }
        ],
        [
          [38, 40],
          function(b) {
            var a;
            if (c.highlightedPoint)
              if ((a = c.series[c.highlightedPoint.series.index + (38 === b ? -1 : 1)]) && a.points[0]) a.points[0].highlight();
              else return this.move(40 === b ? 1 : -1)
          }
        ],
        [
          [13, 32],
          function() {
            c.highlightedPoint && c.highlightedPoint.firePointEvent("click")
          }
        ]
      ], {
        init: function(b) {
          var a = c.series && c.series[c.series.length - 1],
            a = a && a.points && a.points[a.points.length - 1];
          0 > b && a && a.highlight()
        }
      }), b([
        [
          [37, 38],
          function() {
            for (var a = c.highlightedExportItem || 0, b = !0, d = c.series; a--;)
              if (c.highlightExportItem(a)) {
                b = !1;
                break
              } if (b) return c.hideExportMenu(), d && d.length && (a = d[d.length - 1], a.points.length && a.points[a.points.length - 1].highlight()), this.move(-1)
          }
        ],
        [
          [39, 40],
          function() {
            for (var a = !0, b = (c.highlightedExportItem || 0) + 1; b < c.exportDivElements.length; ++b)
              if (c.highlightExportItem(b)) {
                a = !1;
                break
              } if (a) return c.hideExportMenu(), this.move(1)
          }
        ],
        [
          [13, 32],
          function() {
            k(c.exportDivElements[c.highlightedExportItem])
          }
        ]
      ], {
        validate: function() {
          return c.exportChart && !(c.options.exporting && !1 === c.options.exporting.enabled)
        },
        init: function(a) {
          c.highlightedPoint = null;
          c.showExportMenu();
          if (0 > a && c.exportDivElements)
            for (a = c.exportDivElements.length; - 1 < a && !c.highlightExportItem(a); --a);
        }
      }), b([
        [
          [38, 40, 37, 39],
          function(a) {
            c[38 === a || 40 === a ? "yAxis" : "xAxis"][0].panStep(39 > a ? -1 : 1)
          }
        ],
        [
          [9],
          function(a, b) {
            c.mapNavButtons[c.focusedMapNavButtonIx].setState(0);
            if (b.shiftKey && !c.focusedMapNavButtonIx || !b.shiftKey && c.focusedMapNavButtonIx) return c.mapZoom(), this.move(b.shiftKey ? -1 : 1);
            c.focusedMapNavButtonIx += b.shiftKey ? -1 : 1;
            a = c.mapNavButtons[c.focusedMapNavButtonIx];
            a.element.focus && a.element.focus();
            a.setState(2)
          }
        ],
        [
          [13, 32],
          function() {
            k(c.mapNavButtons[c.focusedMapNavButtonIx].element)
          }
        ]
      ], {
        validate: function() {
          return c.mapZoom && c.mapNavButtons && 2 === c.mapNavButtons.length
        },
        transformTabs: !1,
        init: function(a) {
          var b = c.mapNavButtons[0],
            d = c.mapNavButtons[1],
            b = 0 <
            a ? b : d;
          g(c.mapNavButtons, function(a, c) {
            a.element.setAttribute("tabindex", -1);
            a.element.setAttribute("role", "button");
            a.element.setAttribute("aria-label", "Zoom " + (c ? "out" : "") + "chart")
          });
          b.element.focus && b.element.focus();
          b.setState(2);
          c.focusedMapNavButtonIx = 0 < a ? 0 : 1
        }
      }), b([
        [
          [37, 39, 38, 40],
          function(a) {
            a = 37 === a || 38 === a ? -1 : 1;
            if (!c.highlightRangeSelectorButton(c.highlightedRangeSelectorItemIx + a)) return this.move(a)
          }
        ],
        [
          [13, 32],
          function() {
            3 !== c.oldRangeSelectorItemState && k(c.rangeSelector.buttons[c.highlightedRangeSelectorItemIx].element)
          }
        ]
      ], {
        validate: function() {
          return c.rangeSelector && c.rangeSelector.buttons && c.rangeSelector.buttons.length
        },
        init: function(a) {
          g(c.rangeSelector.buttons, function(a) {
            a.element.setAttribute("tabindex", "-1");
            a.element.setAttribute("role", "button");
            a.element.setAttribute("aria-label", "Select range " + (a.text && a.text.textStr))
          });
          c.highlightRangeSelectorButton(0 < a ? 0 : c.rangeSelector.buttons.length - 1)
        }
      }), b([
        [
          [9, 38, 40],
          function(a, b) {
            a = 9 === a && b.shiftKey || 38 === a ? -1 : 1;
            b = c.highlightedInputRangeIx += a;
            if (1 < b || 0 > b) return this.move(a);
            c.rangeSelector[b ? "maxInput" : "minInput"].focus()
          }
        ]
      ], {
        validate: function() {
          return c.rangeSelector && c.rangeSelector.inputGroup && "hidden" !== c.rangeSelector.inputGroup.element.getAttribute("visibility") && !1 !== c.options.rangeSelector.inputEnabled && c.rangeSelector.minInput && c.rangeSelector.maxInput
        },
        transformTabs: !1,
        init: function(a) {
          c.highlightedInputRangeIx = 0 < a ? 0 : 1;
          c.rangeSelector[c.highlightedInputRangeIx ? "maxInput" : "minInput"].focus()
        }
      }), b([
        [
          [37, 39, 38, 40],
          function(a) {
            a = 37 === a || 38 === a ? -1 : 1;
            if (!c.highlightLegendItem(c.highlightedLegendItemIx +
                a)) return this.move(a)
          }
        ],
        [
          [13, 32],
          function() {
            k(c.legend.allItems[c.highlightedLegendItemIx].legendItem.element.parentNode)
          }
        ]
      ], {
        validate: function() {
          return c.legend && c.legend.allItems && !c.colorAxis
        },
        init: function(a) {
          g(c.legend.allItems, function(a) {
            a.legendGroup.element.setAttribute("tabindex", "-1");
            a.legendGroup.element.setAttribute("role", "button");
            a.legendGroup.element.setAttribute("aria-label", "Toggle visibility of series " + a.name)
          });
          c.highlightLegendItem(0 < a ? 0 : c.legend.allItems.length - 1)
        }
      })];
      c.keyboardNavigationModuleIndex =
        0;
      c.renderTo.tabIndex || c.renderTo.setAttribute("tabindex", "0");
      u(c.renderTo, "keydown", d);
      u(c, "destroy", function() {
        C(c.renderTo, "keydown", d)
      })
    };
    e.Chart.prototype.addScreenReaderRegion = function(a) {
      var b = this,
        d = b.series,
        c = b.options,
        e = c.accessibility,
        g = b.screenReaderRegion = l.createElement("div"),
        k = l.createElement("h3"),
        p = l.createElement("a"),
        q = l.createElement("h3"),
        t = {
          position: "absolute",
          left: "-9999px",
          top: "auto",
          width: "1px",
          height: "1px",
          overflow: "hidden"
        },
        h = b.types || [],
        h = (1 === h.length && "pie" === h[0] ||
          "map" === h[0]) && {} || b.getAxesDescription(),
        m = d[0] && r[d[0].type] || r.default;
      g.setAttribute("role", "region");
      g.setAttribute("aria-label", "Chart screen reader information.");
      g.innerHTML = e.screenReaderSectionFormatter && e.screenReaderSectionFormatter(b) || '\x3cdiv tabindex\x3d"0"\x3eUse regions/landmarks to skip ahead to chart' + (1 < d.length ? " and navigate between data series" : "") + ".\x3c/div\x3e\x3ch3\x3eSummary.\x3c/h3\x3e\x3cdiv\x3e" + (c.title.text ? n(c.title.text) : "Chart") + (c.subtitle && c.subtitle.text ? ". " +
        n(c.subtitle.text) : "") + "\x3c/div\x3e\x3ch3\x3eLong description.\x3c/h3\x3e\x3cdiv\x3e" + (c.chart.description || "No description available.") + "\x3c/div\x3e\x3ch3\x3eStructure.\x3c/h3\x3e\x3cdiv\x3eChart type: " + (c.chart.typeDescription || b.getTypeDescription()) + "\x3c/div\x3e" + (1 === d.length ? "\x3cdiv\x3e" + m[0] + " with " + d[0].points.length + " " + (1 === d[0].points.length ? m[1] : m[2]) + ".\x3c/div\x3e" : "") + (h.xAxis ? "\x3cdiv\x3e" + h.xAxis + "\x3c/div\x3e" : "") + (h.yAxis ? "\x3cdiv\x3e" + h.yAxis + "\x3c/div\x3e" : "");
      b.getCSV &&
        (p.innerHTML = "View as data table.", p.href = "#" + a, p.setAttribute("tabindex", "-1"), p.onclick = e.onTableAnchorClick || function() {
          b.viewData();
          l.getElementById(a).focus()
        }, k.appendChild(p), g.appendChild(k));
      q.innerHTML = "Chart graphic.";
      b.renderTo.insertBefore(q, b.renderTo.firstChild);
      b.renderTo.insertBefore(g, b.renderTo.firstChild);
      v(!0, q.style, t);
      v(!0, g.style, t)
    };
    e.Chart.prototype.callbacks.push(function(a) {
      var b = a.options,
        d = b.accessibility;
      if (d.enabled) {
        var c = l.createElementNS("http://www.w3.org/2000/svg",
            "title"),
          f = l.createElementNS("http://www.w3.org/2000/svg", "g"),
          k = a.container.getElementsByTagName("desc")[0],
          r = a.container.getElementsByTagName("text"),
          p = "highcharts-title-" + a.index,
          q = "highcharts-data-table-" + a.index,
          t = b.title.text || "Chart",
          h = b.exporting && b.exporting.csv && b.exporting.csv.columnHeaderFormatter,
          m = [];
        c.textContent = n(t);
        c.id = p;
        k.parentNode.insertBefore(c, k);
        a.renderTo.setAttribute("role", "region");
        a.renderTo.setAttribute("aria-label", t + ". Use up and down arrows to navigate.");
        if (a.exportSVGElements &&
          a.exportSVGElements[0] && a.exportSVGElements[0].element) {
          var u = a.exportSVGElements[0].element.onclick,
            c = a.exportSVGElements[0].element.parentNode;
          a.exportSVGElements[0].element.onclick = function() {
            u.apply(this, Array.prototype.slice.call(arguments));
            a.addAccessibleContextMenuAttribs();
            a.highlightExportItem(0)
          };
          a.exportSVGElements[0].element.setAttribute("role", "button");
          a.exportSVGElements[0].element.setAttribute("aria-label", "View export menu");
          f.appendChild(a.exportSVGElements[0].element);
          f.setAttribute("role",
            "region");
          f.setAttribute("aria-label", "Chart export menu");
          c.appendChild(f)
        }
        a.rangeSelector && g(["minInput", "maxInput"], function(b, c) {
          a.rangeSelector[b] && (a.rangeSelector[b].setAttribute("tabindex", "-1"), a.rangeSelector[b].setAttribute("role", "textbox"), a.rangeSelector[b].setAttribute("aria-label", "Select " + (c ? "end" : "start") + " date."))
        });
        g(r, function(a) {
          a.setAttribute("aria-hidden", "true")
        });
        a.addScreenReaderRegion(q);
        d.keyboardNavigation && a.addKeyboardNavEvents();
        v(!0, b.exporting, {
          csv: {
            columnHeaderFormatter: function(a,
              b, c) {
              var d = m[m.length - 1];
              1 < c && (d && d.text) !== a.name && m.push({
                text: a.name,
                span: c
              });
              return h ? h.call(this, a, b, c) : 1 < c ? b : a.name
            }
          }
        });
        e.wrap(a, "getTable", function(a) {
          return a.apply(this, Array.prototype.slice.call(arguments, 1)).replace("\x3ctable\x3e", '\x3ctable id\x3d"' + q + '" summary\x3d"Table representation of chart"\x3e\x3ccaption\x3e' + t + "\x3c/caption\x3e")
        });
        e.wrap(a, "viewData", function(a) {
          if (!this.insertedTable) {
            a.apply(this, Array.prototype.slice.call(arguments, 1));
            var b = l.getElementById(q),
              c = b.getElementsByTagName("tbody")[0],
              d = c.firstChild.children,
              e = "\x3ctr\x3e\x3ctd\x3e\x3c/td\x3e",
              f, h;
            b.setAttribute("tabindex", "-1");
            g(c.children, function(a) {
              f = a.firstChild;
              h = l.createElement("th");
              h.setAttribute("scope", "row");
              h.innerHTML = f.innerHTML;
              f.parentNode.replaceChild(h, f)
            });
            g(d, function(a) {
              "TH" === a.tagName && a.setAttribute("scope", "col")
            });
            m.length && (g(m, function(a) {
              e += '\x3cth scope\x3d"col" colspan\x3d"' + a.span + '"\x3e' + a.text + "\x3c/th\x3e"
            }), c.insertAdjacentHTML("afterbegin", e))
          }
        })
      }
    })
  })(n)
});;
/*! RESOURCE: /scripts/highcharts/modules/pattern-fill-v2.js */
(function(factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory;
  } else {
    factory(Highcharts);
  }
}(function(Highcharts) {
  'use strict';
  var idCounter = 0,
    wrap = Highcharts.wrap,
    each = Highcharts.each;
  Highcharts.SVGRenderer.prototype.addPattern = function(id, options) {
    var pattern,
      path,
      w = options.width || 10,
      h = options.height || 10,
      ren = this;

    function rect(fill) {
      ren.rect(0, 0, w, h)
        .attr({
          fill: fill
        })
        .add(pattern);
    }
    if (!id) {
      id = 'highcharts-pattern-' + idCounter;
      idCounter += 1;
    }
    pattern = this.createElement('pattern').attr({
      id: id,
      patternUnits: 'userSpaceOnUse',
      width: options.width || 10,
      height: options.height || 10
    }).add(this.defs);
    pattern.id = pattern.element.id;
    if (options.path) {
      path = options.path;
      if (path.fill) {
        rect(path.fill);
      }
      this.createElement('path').attr({
        'd': path.d || path,
        'stroke': path.stroke || options.color || '#343434',
        'stroke-width': path.strokeWidth || 2
      }).add(pattern);
      pattern.color = options.color;
    } else if (options.image) {
      this.image(options.image, 0, 0, options.width, options.height).add(pattern);
    } else if (options.color) {
      rect(options.color);
    }
    if (options.opacity !== undefined) {
      each(pattern.element.children, function(child) {
        child.setAttribute('opacity', options.opacity);
      });
    }
    return pattern;
  };
  if (Highcharts.VMLElement) {
    Highcharts.VMLRenderer.prototype.addPattern = function(id, options) {
      var patterns;
      if (!id) {
        id = 'highcharts-pattern-' + idCounter;
        idCounter += 1;
      }
      patterns = this.patterns || {};
      patterns[id] = options;
      this.patterns = patterns;
    };
    Highcharts.wrap(Highcharts.VMLRenderer.prototype.Element.prototype, 'fillSetter', function(proceed, color, prop, elem) {
      if (typeof color === 'string' && color.substring(0, 5) === 'url(#') {
        var id = color.substring(5, color.length - 1),
          pattern = this.renderer.patterns[id],
          markup;
        if (pattern.image) {
          if (elem.getElementsByTagName('fill').length) {
            elem.removeChild(elem.getElementsByTagName('fill')[0]);
          }
          markup = this.renderer.prepVML(['<', prop, ' type="tile" src="', pattern.image, '" />']);
          elem.appendChild(document.createElement(markup));
          if (elem.parentNode.nodeType === 1) {
            elem.outerHTML = elem.outerHTML;
          }
        } else if (pattern.color) {
          proceed.call(this, pattern.color, prop, elem);
        } else {
          proceed.call(this, '#A0A0A0', prop, elem);
        }
      } else {
        proceed.call(this, color, prop, elem);
      }
    });
  }

  function addPredefinedPatterns(renderer) {
    var colors = Highcharts.getOptions().colors;
    each([
      'M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11',
      'M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9',
      'M 3 0 L 3 10 M 8 0 L 8 10',
      'M 0 3 L 10 3 M 0 8 L 10 8',
      'M 0 3 L 5 3 L 5 0 M 5 10 L 5 7 L 10 7',
      'M 3 3 L 8 3 L 8 8 L 3 8 Z',
      'M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0',
      'M 10 3 L 5 3 L 5 0 M 5 10 L 5 7 L 0 7',
      'M 2 5 L 5 2 L 8 5 L 5 8 Z',
      'M 0 0 L 5 10 L 10 0'
    ], function(pattern, i) {
      renderer.addPattern('highcharts-default-pattern-' + i, {
        path: pattern,
        color: colors[i]
      });
    });
  }
  wrap(Highcharts.Chart.prototype, 'getContainer', function(proceed) {
    proceed.apply(this);
    var chart = this,
      renderer = chart.renderer,
      options = chart.options,
      patterns = options.defs && options.defs.patterns;
    addPredefinedPatterns(renderer);
    if (patterns) {
      each(patterns, function(pattern) {
        renderer.addPattern(pattern.id, pattern);
      });
    }
  });
}));;
/*! RESOURCE: /scripts/highcharts/modules/funnel.js */
(function(c) {
  "object" === typeof module && module.exports ? module.exports = c : c(Highcharts)
})(function(c) {
  (function(c) {
    var n = c.seriesType,
      z = c.seriesTypes,
      F = c.noop,
      G = c.each;
    n("funnel", "pie", {
      animation: !1,
      center: ["50%", "50%"],
      width: "90%",
      neckWidth: "30%",
      height: "100%",
      neckHeight: "25%",
      reversed: !1,
      size: !0,
      dataLabels: {
        connectorWidth: 1
      },
      states: {
        select: {
          color: "#cccccc",
          borderColor: "#000000",
          shadow: !1
        }
      }
    }, {
      animate: F,
      translate: function() {
        var b = function(a, b) {
            return /%$/.test(a) ? b * parseInt(a, 10) / 100 : parseInt(a, 10)
          },
          c = 0,
          e = this.chart,
          d = this.options,
          r = d.reversed,
          H = d.ignoreHiddenPoint,
          t = e.plotWidth,
          e = e.plotHeight,
          p = 0,
          n = d.center,
          f = b(n[0], t),
          q = b(n[1], e),
          z = b(d.width, t),
          h, v, k = b(d.height, e),
          w = b(d.neckWidth, t),
          D = b(d.neckHeight, e),
          x = q - k / 2 + k - D,
          b = this.data,
          A, B, I = "left" === d.dataLabels.position ? 1 : 0,
          C, l, E, u, g, y, m;
        this.getWidthAt = v = function(a) {
          var b = q - k / 2;
          return a > x || k === D ? w : w + (z - w) * (1 - (a - b) / (k - D))
        };
        this.getX = function(a, b) {
          return f + (b ? -1 : 1) * (v(r ? 2 * q - a : a) / 2 + d.dataLabels.distance)
        };
        this.center = [f, q, k];
        this.centerX = f;
        G(b, function(a) {
          H &&
            !1 === a.visible || (c += a.y)
        });
        G(b, function(a) {
          m = null;
          B = c ? a.y / c : 0;
          l = q - k / 2 + p * k;
          g = l + B * k;
          h = v(l);
          C = f - h / 2;
          E = C + h;
          h = v(g);
          u = f - h / 2;
          y = u + h;
          l > x ? (C = u = f - w / 2, E = y = f + w / 2) : g > x && (m = g, h = v(x), u = f - h / 2, y = u + h, g = x);
          r && (l = 2 * q - l, g = 2 * q - g, m = m ? 2 * q - m : null);
          A = ["M", C, l, "L", E, l, y, g];
          m && A.push(y, m, u, m);
          A.push(u, g, "Z");
          a.shapeType = "path";
          a.shapeArgs = {
            d: A
          };
          a.percentage = 100 * B;
          a.plotX = f;
          a.plotY = (l + (m || g)) / 2;
          a.tooltipPos = [f, a.plotY];
          a.slice = F;
          a.half = I;
          H && !1 === a.visible || (p += B)
        })
      },
      drawPoints: z.column.prototype.drawPoints,
      sortByAngle: function(b) {
        b.sort(function(b,
          c) {
          return b.plotY - c.plotY
        })
      },
      drawDataLabels: function() {
        var b = this.data,
          c = this.options.dataLabels.distance,
          e, d, r, n = b.length,
          t, p;
        for (this.center[2] -= 2 * c; n--;) r = b[n], d = (e = r.half) ? 1 : -1, p = r.plotY, t = this.getX(p, e), r.labelPos = [0, p, t + (c - 5) * d, p, t + c * d, p, e ? "right" : "left", 0];
        z.pie.prototype.drawDataLabels.call(this)
      }
    });
    n("pyramid", "funnel", {
      neckWidth: "0%",
      neckHeight: "0%",
      reversed: !0
    })
  })(c)
});;
/*! RESOURCE: /scripts/highcharts/modules/heatmap.js */
(function(n) {
  "object" === typeof module && module.exports ? module.exports = n : n(Highcharts)
})(function(n) {
  (function(c) {
    var k = c.Axis,
      r = c.Chart,
      m = c.color,
      l, e = c.each,
      v = c.extend,
      w = c.isNumber,
      p = c.Legend,
      f = c.LegendSymbolMixin,
      x = c.noop,
      q = c.merge,
      u = c.pick,
      t = c.wrap;
    l = c.ColorAxis = function() {
      this.init.apply(this, arguments)
    };
    v(l.prototype, k.prototype);
    v(l.prototype, {
      defaultColorAxisOptions: {
        lineWidth: 0,
        minPadding: 0,
        maxPadding: 0,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        startOnTick: !0,
        endOnTick: !0,
        offset: 0,
        marker: {
          animation: {
            duration: 50
          },
          width: .01,
          color: "#999999"
        },
        labels: {
          overflow: "justify",
          rotation: 0
        },
        minColor: "#e6ebf5",
        maxColor: "#003399",
        tickLength: 5,
        showInLegend: !0
      },
      keepProps: ["legendGroup", "legendItem", "legendSymbol"].concat(k.prototype.keepProps),
      init: function(a, b) {
        var d = "vertical" !== a.options.legend.layout,
          g;
        this.coll = "colorAxis";
        g = q(this.defaultColorAxisOptions, {
          side: d ? 2 : 1,
          reversed: !d
        }, b, {
          opposite: !d,
          showEmpty: !1,
          title: null
        });
        k.prototype.init.call(this, a, g);
        b.dataClasses && this.initDataClasses(b);
        this.initStops(b);
        this.horiz =
          d;
        this.zoomEnabled = !1;
        this.defaultLegendLength = 200
      },
      tweenColors: function(a, b, d) {
        var g;
        b.rgba.length && a.rgba.length ? (a = a.rgba, b = b.rgba, g = 1 !== b[3] || 1 !== a[3], a = (g ? "rgba(" : "rgb(") + Math.round(b[0] + (a[0] - b[0]) * (1 - d)) + "," + Math.round(b[1] + (a[1] - b[1]) * (1 - d)) + "," + Math.round(b[2] + (a[2] - b[2]) * (1 - d)) + (g ? "," + (b[3] + (a[3] - b[3]) * (1 - d)) : "") + ")") : a = b.input || "none";
        return a
      },
      initDataClasses: function(a) {
        var b = this,
          d = this.chart,
          g, h = 0,
          c = d.options.chart.colorCount,
          y = this.options,
          f = a.dataClasses.length;
        this.dataClasses = g = [];
        this.legendItems = [];
        e(a.dataClasses, function(a, e) {
          a = q(a);
          g.push(a);
          a.color || ("category" === y.dataClassColor ? (e = d.options.colors, c = e.length, a.color = e[h], a.colorIndex = h, h++, h === c && (h = 0)) : a.color = b.tweenColors(m(y.minColor), m(y.maxColor), 2 > f ? .5 : e / (f - 1)))
        })
      },
      initStops: function(a) {
        this.stops = a.stops || [
          [0, this.options.minColor],
          [1, this.options.maxColor]
        ];
        e(this.stops, function(a) {
          a.color = m(a[1])
        })
      },
      setOptions: function(a) {
        k.prototype.setOptions.call(this, a);
        this.options.crosshair = this.options.marker
      },
      setAxisSize: function() {
        var a =
          this.legendSymbol,
          b = this.chart,
          d = b.options.legend || {},
          g, h;
        a ? (this.left = d = a.attr("x"), this.top = g = a.attr("y"), this.width = h = a.attr("width"), this.height = a = a.attr("height"), this.right = b.chartWidth - d - h, this.bottom = b.chartHeight - g - a, this.len = this.horiz ? h : a, this.pos = this.horiz ? d : g) : this.len = (this.horiz ? d.symbolWidth : d.symbolHeight) || this.defaultLegendLength
      },
      toColor: function(a, b) {
        var d = this.stops,
          g, h, c = this.dataClasses,
          e, f;
        if (c)
          for (f = c.length; f--;) {
            if (e = c[f], g = e.from, d = e.to, (void 0 === g || a >= g) && (void 0 ===
                d || a <= d)) {
              h = e.color;
              b && (b.dataClass = f, b.colorIndex = e.colorIndex);
              break
            }
          } else {
            this.isLog && (a = this.val2lin(a));
            a = 1 - (this.max - a) / (this.max - this.min || 1);
            for (f = d.length; f-- && !(a > d[f][0]););
            g = d[f] || d[f + 1];
            d = d[f + 1] || g;
            a = 1 - (d[0] - a) / (d[0] - g[0] || 1);
            h = this.tweenColors(g.color, d.color, a)
          }
        return h
      },
      getOffset: function() {
        var a = this.legendGroup,
          b = this.chart.axisOffset[this.side];
        a && (this.axisParent = a, k.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] =
          b)
      },
      setLegendColor: function() {
        var a, b = this.options,
          d = this.reversed;
        a = d ? 1 : 0;
        d = d ? 0 : 1;
        a = this.horiz ? [a, 0, d, 0] : [0, d, 0, a];
        this.legendColor = {
          linearGradient: {
            x1: a[0],
            y1: a[1],
            x2: a[2],
            y2: a[3]
          },
          stops: b.stops || [
            [0, b.minColor],
            [1, b.maxColor]
          ]
        }
      },
      drawLegendSymbol: function(a, b) {
        var d = a.padding,
          g = a.options,
          h = this.horiz,
          c = u(g.symbolWidth, h ? this.defaultLegendLength : 12),
          f = u(g.symbolHeight, h ? 12 : this.defaultLegendLength),
          e = u(g.labelPadding, h ? 16 : 30),
          g = u(g.itemDistance, 10);
        this.setLegendColor();
        b.legendSymbol = this.chart.renderer.rect(0,
          a.baseline - 11, c, f).attr({
          zIndex: 1
        }).add(b.legendGroup);
        this.legendItemWidth = c + d + (h ? g : e);
        this.legendItemHeight = f + d + (h ? e : 0)
      },
      setState: x,
      visible: !0,
      setVisible: x,
      getSeriesExtremes: function() {
        var a = this.series,
          b = a.length;
        this.dataMin = Infinity;
        for (this.dataMax = -Infinity; b--;) void 0 !== a[b].valueMin && (this.dataMin = Math.min(this.dataMin, a[b].valueMin), this.dataMax = Math.max(this.dataMax, a[b].valueMax))
      },
      drawCrosshair: function(a, b) {
        var d = b && b.plotX,
          c = b && b.plotY,
          h, f = this.pos,
          e = this.len;
        b && (h = this.toPixels(b[b.series.colorKey]),
          h < f ? h = f - 2 : h > f + e && (h = f + e + 2), b.plotX = h, b.plotY = this.len - h, k.prototype.drawCrosshair.call(this, a, b), b.plotX = d, b.plotY = c, this.cross && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.attr({
            fill: this.crosshair.color
          })))
      },
      getPlotLinePath: function(a, b, d, c, h) {
        return w(h) ? this.horiz ? ["M", h - 4, this.top - 6, "L", h + 4, this.top - 6, h, this.top, "Z"] : ["M", this.left, h, "L", this.left - 6, h + 6, this.left - 6, h - 6, "Z"] : k.prototype.getPlotLinePath.call(this, a, b, d, c)
      },
      update: function(a, b) {
        var d = this.chart,
          c = d.legend;
        e(this.series, function(a) {
          a.isDirtyData = !0
        });
        a.dataClasses && c.allItems && (e(c.allItems, function(a) {
          a.isDataClass && a.legendGroup.destroy()
        }), d.isDirtyLegend = !0);
        d.options[this.coll] = q(this.userOptions, a);
        k.prototype.update.call(this, a, b);
        this.legendItem && (this.setLegendColor(), c.colorizeItem(this, !0))
      },
      getDataClassLegendSymbols: function() {
        var a = this,
          b = this.chart,
          d = this.legendItems,
          g = b.options.legend,
          h = g.valueDecimals,
          t = g.valueSuffix || "",
          k;
        d.length || e(this.dataClasses, function(g, p) {
          var l = !0,
            q = g.from,
            m = g.to;
          k = "";
          void 0 === q ? k = "\x3c " : void 0 === m && (k = "\x3e ");
          void 0 !== q && (k += c.numberFormat(q, h) + t);
          void 0 !== q && void 0 !== m && (k += " - ");
          void 0 !== m && (k += c.numberFormat(m, h) + t);
          d.push(v({
            chart: b,
            name: k,
            options: {},
            drawLegendSymbol: f.drawRectangle,
            visible: !0,
            setState: x,
            isDataClass: !0,
            setVisible: function() {
              l = this.visible = !l;
              e(a.series, function(a) {
                e(a.points, function(a) {
                  a.dataClass === p && a.setVisible(l)
                })
              });
              b.legend.colorizeItem(this, l)
            }
          }, g))
        });
        return d
      },
      name: ""
    });
    e(["fill", "stroke"], function(a) {
      c.Fx.prototype[a +
        "Setter"] = function() {
        this.elem.attr(a, l.prototype.tweenColors(m(this.start), m(this.end), this.pos), null, !0)
      }
    });
    t(r.prototype, "getAxes", function(a) {
      var b = this.options.colorAxis;
      a.call(this);
      this.colorAxis = [];
      b && new l(this, b)
    });
    t(p.prototype, "getAllItems", function(a) {
      var b = [],
        d = this.chart.colorAxis[0];
      d && d.options && (d.options.showInLegend && (d.options.dataClasses ? b = b.concat(d.getDataClassLegendSymbols()) : b.push(d)), e(d.series, function(a) {
        a.options.showInLegend = !1
      }));
      return b.concat(a.call(this))
    });
    t(p.prototype,
      "colorizeItem",
      function(a, b, d) {
        a.call(this, b, d);
        d && b.legendColor && b.legendSymbol.attr({
          fill: b.legendColor
        })
      })
  })(n);
  (function(c) {
    var k = c.defined,
      r = c.each,
      m = c.noop,
      l = c.seriesTypes;
    c.colorPointMixin = {
      isValid: function() {
        return null !== this.value
      },
      setVisible: function(c) {
        var e = this,
          k = c ? "show" : "hide";
        r(["graphic", "dataLabel"], function(c) {
          if (e[c]) e[c][k]()
        })
      },
      setState: function(e) {
        c.Point.prototype.setState.call(this, e);
        this.graphic && this.graphic.attr({
          zIndex: "hover" === e ? 1 : 0
        })
      }
    };
    c.colorSeriesMixin = {
      pointArrayMap: ["value"],
      axisTypes: ["xAxis", "yAxis", "colorAxis"],
      optionalAxis: "colorAxis",
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      getSymbol: m,
      parallelArrays: ["x", "y", "value"],
      colorKey: "value",
      pointAttribs: l.column.prototype.pointAttribs,
      translateColors: function() {
        var c = this,
          k = this.options.nullColor,
          l = this.colorAxis,
          m = this.colorKey;
        r(this.data, function(f) {
          var e = f[m];
          if (e = f.options.color || (f.isNull ? k : l && void 0 !== e ? l.toColor(e, f) : f.color || c.color)) f.color = e
        })
      },
      colorAttribs: function(c) {
        var e = {};
        k(c.color) && (e[this.colorProp ||
          "fill"] = c.color);
        return e
      }
    }
  })(n);
  (function(c) {
    var k = c.colorPointMixin,
      r = c.each,
      m = c.merge,
      l = c.noop,
      e = c.pick,
      n = c.Series,
      w = c.seriesType,
      p = c.seriesTypes;
    w("heatmap", "scatter", {
        animation: !1,
        borderWidth: 0,
        nullColor: "#f7f7f7",
        dataLabels: {
          formatter: function() {
            return this.point.value
          },
          inside: !0,
          verticalAlign: "middle",
          crop: !1,
          overflow: !1,
          padding: 0
        },
        marker: null,
        pointRange: null,
        tooltip: {
          pointFormat: "{point.x}, {point.y}: {point.value}\x3cbr/\x3e"
        },
        states: {
          normal: {
            animation: !0
          },
          hover: {
            halo: !1,
            brightness: .2
          }
        }
      },
      m(c.colorSeriesMixin, {
        pointArrayMap: ["y", "value"],
        hasPointSpecificOptions: !0,
        supportsDrilldown: !0,
        getExtremesFromAll: !0,
        directTouch: !0,
        init: function() {
          var c;
          p.scatter.prototype.init.apply(this, arguments);
          c = this.options;
          c.pointRange = e(c.pointRange, c.colsize || 1);
          this.yAxis.axisPointRange = c.rowsize || 1
        },
        translate: function() {
          var c = this.options,
            e = this.xAxis,
            k = this.yAxis,
            l = function(c, a, b) {
              return Math.min(Math.max(a, c), b)
            };
          this.generatePoints();
          r(this.points, function(f) {
            var a = (c.colsize || 1) / 2,
              b = (c.rowsize ||
                1) / 2,
              d = l(Math.round(e.len - e.translate(f.x - a, 0, 1, 0, 1)), -e.len, 2 * e.len),
              a = l(Math.round(e.len - e.translate(f.x + a, 0, 1, 0, 1)), -e.len, 2 * e.len),
              g = l(Math.round(k.translate(f.y - b, 0, 1, 0, 1)), -k.len, 2 * k.len),
              b = l(Math.round(k.translate(f.y + b, 0, 1, 0, 1)), -k.len, 2 * k.len);
            f.plotX = f.clientX = (d + a) / 2;
            f.plotY = (g + b) / 2;
            f.shapeType = "rect";
            f.shapeArgs = {
              x: Math.min(d, a),
              y: Math.min(g, b),
              width: Math.abs(a - d),
              height: Math.abs(b - g)
            }
          });
          this.translateColors()
        },
        drawPoints: function() {
          p.column.prototype.drawPoints.call(this);
          r(this.points,
            function(c) {
              c.graphic.attr(this.colorAttribs(c))
            }, this)
        },
        animate: l,
        getBox: l,
        drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,
        alignDataLabel: p.column.prototype.alignDataLabel,
        getExtremes: function() {
          n.prototype.getExtremes.call(this, this.valueData);
          this.valueMin = this.dataMin;
          this.valueMax = this.dataMax;
          n.prototype.getExtremes.call(this)
        }
      }), k)
  })(n)
});;
/*! RESOURCE: /scripts/highcharts/modules/solid-gauge.js */
(function(l) {
  "object" === typeof module && module.exports ? module.exports = l : l(Highcharts)
})(function(l) {
  (function(f) {
    var l = f.pInt,
      t = f.pick,
      m = f.each,
      v = f.isNumber,
      n;
    n = {
      initDataClasses: function(a) {
        var c = this,
          d = this.chart,
          e, u = 0,
          h = this.options;
        this.dataClasses = e = [];
        m(a.dataClasses, function(g, b) {
          g = f.merge(g);
          e.push(g);
          g.color || ("category" === h.dataClassColor ? (b = d.options.colors, g.color = b[u++], u === b.length && (u = 0)) : g.color = c.tweenColors(f.color(h.minColor), f.color(h.maxColor), b / (a.dataClasses.length - 1)))
        })
      },
      initStops: function(a) {
        this.stops =
          a.stops || [
            [0, this.options.minColor],
            [1, this.options.maxColor]
          ];
        m(this.stops, function(a) {
          a.color = f.color(a[1])
        })
      },
      toColor: function(a, c) {
        var d = this.stops,
          e, f, h = this.dataClasses,
          g, b;
        if (h)
          for (b = h.length; b--;) {
            if (g = h[b], e = g.from, d = g.to, (void 0 === e || a >= e) && (void 0 === d || a <= d)) {
              f = g.color;
              c && (c.dataClass = b);
              break
            }
          } else {
            this.isLog && (a = this.val2lin(a));
            a = 1 - (this.max - a) / (this.max - this.min);
            for (b = d.length; b-- && !(a > d[b][0]););
            e = d[b] || d[b + 1];
            d = d[b + 1] || e;
            a = 1 - (d[0] - a) / (d[0] - e[0] || 1);
            f = this.tweenColors(e.color, d.color,
              a)
          }
        return f
      },
      tweenColors: function(a, c, d) {
        var e;
        c.rgba.length && a.rgba.length ? (a = a.rgba, c = c.rgba, e = 1 !== c[3] || 1 !== a[3], a = (e ? "rgba(" : "rgb(") + Math.round(c[0] + (a[0] - c[0]) * (1 - d)) + "," + Math.round(c[1] + (a[1] - c[1]) * (1 - d)) + "," + Math.round(c[2] + (a[2] - c[2]) * (1 - d)) + (e ? "," + (c[3] + (a[3] - c[3]) * (1 - d)) : "") + ")") : a = c.input || "none";
        return a
      }
    };
    m(["fill", "stroke"], function(a) {
      f.Fx.prototype[a + "Setter"] = function() {
        this.elem.attr(a, n.tweenColors(f.color(this.start), f.color(this.end), this.pos), null, !0)
      }
    });
    f.seriesType("solidgauge",
      "gauge", {
        colorByPoint: !0
      }, {
        translate: function() {
          var a = this.yAxis;
          f.extend(a, n);
          !a.dataClasses && a.options.dataClasses && a.initDataClasses(a.options);
          a.initStops(a.options);
          f.seriesTypes.gauge.prototype.translate.call(this)
        },
        drawPoints: function() {
          var a = this,
            c = a.yAxis,
            d = c.center,
            e = a.options,
            f = a.chart.renderer,
            h = e.overshoot,
            g = v(h) ? h / 180 * Math.PI : 0,
            b;
          v(e.threshold) && (b = c.startAngleRad + c.translate(e.threshold, null, null, null, !0));
          this.thresholdAngleRad = t(b, c.startAngleRad);
          m(a.points, function(b) {
            var h = b.graphic,
              k = c.startAngleRad + c.translate(b.y, null, null, null, !0),
              m = l(t(b.options.radius, e.radius, 100)) * d[2] / 200,
              p = l(t(b.options.innerRadius, e.innerRadius, 60)) * d[2] / 200,
              q = c.toColor(b.y, b),
              r = Math.min(c.startAngleRad, c.endAngleRad),
              n = Math.max(c.startAngleRad, c.endAngleRad);
            "none" === q && (q = b.color || a.color || "none");
            "none" !== q && (b.color = q);
            k = Math.max(r - g, Math.min(n + g, k));
            !1 === e.wrap && (k = Math.max(r, Math.min(n, k)));
            r = Math.min(k, a.thresholdAngleRad);
            k = Math.max(k, a.thresholdAngleRad);
            k - r > 2 * Math.PI && (k = r + 2 * Math.PI);
            b.shapeArgs =
              p = {
                x: d[0],
                y: d[1],
                r: m,
                innerR: p,
                start: r,
                end: k,
                fill: q
              };
            b.startR = m;
            h ? (b = p.d, h.animate(p), b && (p.d = b)) : (b.graphic = f.arc(p).addClass("highcharts-point").attr({
              fill: q,
              "sweep-flag": 0
            }).add(a.group), "square" !== e.linecap && b.graphic.attr({
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }), b.graphic.attr({
              stroke: e.borderColor || "none",
              "stroke-width": e.borderWidth || 0
            }))
          })
        },
        animate: function(a) {
          a || (this.startAngleRad = this.thresholdAngleRad, f.seriesTypes.pie.prototype.animate.call(this, a))
        }
      })
  })(l)
});;
/*! RESOURCE: /scripts/highcharts/modules/map.js */
(function(v) {
  "object" === typeof module && module.exports ? module.exports = v : v(Highcharts)
})(function(v) {
  (function(a) {
    var m = a.Axis,
      n = a.each,
      k = a.pick;
    a = a.wrap;
    a(m.prototype, "getSeriesExtremes", function(a) {
      var d = this.isXAxis,
        t, m, u = [],
        q;
      d && n(this.series, function(a, b) {
        a.useMapGeometry && (u[b] = a.xData, a.xData = [])
      });
      a.call(this);
      d && (t = k(this.dataMin, Number.MAX_VALUE), m = k(this.dataMax, -Number.MAX_VALUE), n(this.series, function(a, b) {
        a.useMapGeometry && (t = Math.min(t, k(a.minX, t)), m = Math.max(m, k(a.maxX, t)), a.xData = u[b],
          q = !0)
      }), q && (this.dataMin = t, this.dataMax = m))
    });
    a(m.prototype, "setAxisTranslation", function(a) {
      var g = this.chart,
        d = g.plotWidth / g.plotHeight,
        g = g.xAxis[0],
        k;
      a.call(this);
      "yAxis" === this.coll && void 0 !== g.transA && n(this.series, function(a) {
        a.preserveAspectRatio && (k = !0)
      });
      if (k && (this.transA = g.transA = Math.min(this.transA, g.transA), a = d / ((g.max - g.min) / (this.max - this.min)), a = 1 > a ? this : g, d = (a.max - a.min) * a.transA, a.pixelPadding = a.len - d, a.minPixelPadding = a.pixelPadding / 2, d = a.fixTo)) {
        d = d[1] - a.toValue(d[0], !0);
        d *= a.transA;
        if (Math.abs(d) > a.minPixelPadding || a.min === a.dataMin && a.max === a.dataMax) d = 0;
        a.minPixelPadding -= d
      }
    });
    a(m.prototype, "render", function(a) {
      a.call(this);
      this.fixTo = null
    })
  })(v);
  (function(a) {
    var m = a.Axis,
      n = a.Chart,
      k = a.color,
      d, g = a.each,
      t = a.extend,
      z = a.isNumber,
      u = a.Legend,
      q = a.LegendSymbolMixin,
      c = a.noop,
      b = a.merge,
      f = a.pick,
      r = a.wrap;
    d = a.ColorAxis = function() {
      this.init.apply(this, arguments)
    };
    t(d.prototype, m.prototype);
    t(d.prototype, {
      defaultColorAxisOptions: {
        lineWidth: 0,
        minPadding: 0,
        maxPadding: 0,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        startOnTick: !0,
        endOnTick: !0,
        offset: 0,
        marker: {
          animation: {
            duration: 50
          },
          width: .01,
          color: "#999999"
        },
        labels: {
          overflow: "justify"
        },
        minColor: "#e6ebf5",
        maxColor: "#003399",
        tickLength: 5,
        showInLegend: !0
      },
      keepProps: ["legendGroup", "legendItem", "legendSymbol"].concat(m.prototype.keepProps),
      init: function(a, e) {
        var l = "vertical" !== a.options.legend.layout,
          c;
        this.coll = "colorAxis";
        c = b(this.defaultColorAxisOptions, {
          side: l ? 2 : 1,
          reversed: !l
        }, e, {
          opposite: !l,
          showEmpty: !1,
          title: null
        });
        m.prototype.init.call(this, a, c);
        e.dataClasses &&
          this.initDataClasses(e);
        this.initStops(e);
        this.horiz = l;
        this.zoomEnabled = !1;
        this.defaultLegendLength = 200
      },
      tweenColors: function(b, a, c) {
        var l;
        a.rgba.length && b.rgba.length ? (b = b.rgba, a = a.rgba, l = 1 !== a[3] || 1 !== b[3], b = (l ? "rgba(" : "rgb(") + Math.round(a[0] + (b[0] - a[0]) * (1 - c)) + "," + Math.round(a[1] + (b[1] - a[1]) * (1 - c)) + "," + Math.round(a[2] + (b[2] - a[2]) * (1 - c)) + (l ? "," + (a[3] + (b[3] - a[3]) * (1 - c)) : "") + ")") : b = a.input || "none";
        return b
      },
      initDataClasses: function(a) {
        var l = this,
          c = this.chart,
          f, h = 0,
          p = c.options.chart.colorCount,
          d = this.options,
          q = a.dataClasses.length;
        this.dataClasses = f = [];
        this.legendItems = [];
        g(a.dataClasses, function(a, e) {
          a = b(a);
          f.push(a);
          a.color || ("category" === d.dataClassColor ? (e = c.options.colors, p = e.length, a.color = e[h], a.colorIndex = h, h++, h === p && (h = 0)) : a.color = l.tweenColors(k(d.minColor), k(d.maxColor), 2 > q ? .5 : e / (q - 1)))
        })
      },
      initStops: function(a) {
        this.stops = a.stops || [
          [0, this.options.minColor],
          [1, this.options.maxColor]
        ];
        g(this.stops, function(a) {
          a.color = k(a[1])
        })
      },
      setOptions: function(a) {
        m.prototype.setOptions.call(this, a);
        this.options.crosshair =
          this.options.marker
      },
      setAxisSize: function() {
        var a = this.legendSymbol,
          b = this.chart,
          c = b.options.legend || {},
          f, h;
        a ? (this.left = c = a.attr("x"), this.top = f = a.attr("y"), this.width = h = a.attr("width"), this.height = a = a.attr("height"), this.right = b.chartWidth - c - h, this.bottom = b.chartHeight - f - a, this.len = this.horiz ? h : a, this.pos = this.horiz ? c : f) : this.len = (this.horiz ? c.symbolWidth : c.symbolHeight) || this.defaultLegendLength
      },
      toColor: function(a, b) {
        var c = this.stops,
          e, h, l = this.dataClasses,
          f, d;
        if (l)
          for (d = l.length; d--;) {
            if (f = l[d],
              e = f.from, c = f.to, (void 0 === e || a >= e) && (void 0 === c || a <= c)) {
              h = f.color;
              b && (b.dataClass = d, b.colorIndex = f.colorIndex);
              break
            }
          } else {
            this.isLog && (a = this.val2lin(a));
            a = 1 - (this.max - a) / (this.max - this.min || 1);
            for (d = c.length; d-- && !(a > c[d][0]););
            e = c[d] || c[d + 1];
            c = c[d + 1] || e;
            a = 1 - (c[0] - a) / (c[0] - e[0] || 1);
            h = this.tweenColors(e.color, c.color, a)
          }
        return h
      },
      getOffset: function() {
        var a = this.legendGroup,
          b = this.chart.axisOffset[this.side];
        a && (this.axisParent = a, m.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft =
          0, this.labelRight = this.width), this.chart.axisOffset[this.side] = b)
      },
      setLegendColor: function() {
        var a, b = this.options,
          c = this.reversed;
        a = c ? 1 : 0;
        c = c ? 0 : 1;
        a = this.horiz ? [a, 0, c, 0] : [0, c, 0, a];
        this.legendColor = {
          linearGradient: {
            x1: a[0],
            y1: a[1],
            x2: a[2],
            y2: a[3]
          },
          stops: b.stops || [
            [0, b.minColor],
            [1, b.maxColor]
          ]
        }
      },
      drawLegendSymbol: function(a, b) {
        var c = a.padding,
          e = a.options,
          h = this.horiz,
          l = f(e.symbolWidth, h ? this.defaultLegendLength : 12),
          d = f(e.symbolHeight, h ? 12 : this.defaultLegendLength),
          g = f(e.labelPadding, h ? 16 : 30),
          e = f(e.itemDistance,
            10);
        this.setLegendColor();
        b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, l, d).attr({
          zIndex: 1
        }).add(b.legendGroup);
        this.legendItemWidth = l + c + (h ? e : g);
        this.legendItemHeight = d + c + (h ? g : 0)
      },
      setState: c,
      visible: !0,
      setVisible: c,
      getSeriesExtremes: function() {
        var a;
        this.series.length && (a = this.series[0], this.dataMin = a.valueMin, this.dataMax = a.valueMax)
      },
      drawCrosshair: function(a, b) {
        var c = b && b.plotX,
          f = b && b.plotY,
          h, e = this.pos,
          l = this.len;
        b && (h = this.toPixels(b[b.series.colorKey]), h < e ? h = e - 2 : h > e + l && (h = e + l + 2), b.plotX =
          h, b.plotY = this.len - h, m.prototype.drawCrosshair.call(this, a, b), b.plotX = c, b.plotY = f, this.cross && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.attr({
            fill: this.crosshair.color
          })))
      },
      getPlotLinePath: function(a, b, c, f, h) {
        return z(h) ? this.horiz ? ["M", h - 4, this.top - 6, "L", h + 4, this.top - 6, h, this.top, "Z"] : ["M", this.left, h, "L", this.left - 6, h + 6, this.left - 6, h - 6, "Z"] : m.prototype.getPlotLinePath.call(this, a, b, c, f)
      },
      update: function(a, c) {
        var f = this.chart,
          e = f.legend;
        g(this.series, function(a) {
          a.isDirtyData = !0
        });
        a.dataClasses && e.allItems && (g(e.allItems, function(a) {
          a.isDataClass && a.legendGroup.destroy()
        }), f.isDirtyLegend = !0);
        f.options[this.coll] = b(this.userOptions, a);
        m.prototype.update.call(this, a, c);
        this.legendItem && (this.setLegendColor(), e.colorizeItem(this, !0))
      },
      getDataClassLegendSymbols: function() {
        var b = this,
          f = this.chart,
          d = this.legendItems,
          r = f.options.legend,
          h = r.valueDecimals,
          p = r.valueSuffix || "",
          w;
        d.length || g(this.dataClasses, function(e, l) {
          var r = !0,
            A = e.from,
            k = e.to;
          w = "";
          void 0 === A ? w = "\x3c " : void 0 ===
            k && (w = "\x3e ");
          void 0 !== A && (w += a.numberFormat(A, h) + p);
          void 0 !== A && void 0 !== k && (w += " - ");
          void 0 !== k && (w += a.numberFormat(k, h) + p);
          d.push(t({
            chart: f,
            name: w,
            options: {},
            drawLegendSymbol: q.drawRectangle,
            visible: !0,
            setState: c,
            isDataClass: !0,
            setVisible: function() {
              r = this.visible = !r;
              g(b.series, function(a) {
                g(a.points, function(a) {
                  a.dataClass === l && a.setVisible(r)
                })
              });
              f.legend.colorizeItem(this, r)
            }
          }, e))
        });
        return d
      },
      name: ""
    });
    g(["fill", "stroke"], function(b) {
      a.Fx.prototype[b + "Setter"] = function() {
        this.elem.attr(b,
          d.prototype.tweenColors(k(this.start), k(this.end), this.pos))
      }
    });
    r(n.prototype, "getAxes", function(a) {
      var b = this.options.colorAxis;
      a.call(this);
      this.colorAxis = [];
      b && new d(this, b)
    });
    r(u.prototype, "getAllItems", function(a) {
      var b = [],
        c = this.chart.colorAxis[0];
      c && c.options && (c.options.showInLegend && (c.options.dataClasses ? b = b.concat(c.getDataClassLegendSymbols()) : b.push(c)), g(c.series, function(a) {
        a.options.showInLegend = !1
      }));
      return b.concat(a.call(this))
    });
    r(u.prototype, "colorizeItem", function(a, b, c) {
      a.call(this,
        b, c);
      c && b.legendColor && b.legendSymbol.attr({
        fill: b.legendColor
      })
    })
  })(v);
  (function(a) {
    var m = a.defined,
      n = a.each,
      k = a.noop,
      d = a.seriesTypes;
    a.colorPointMixin = {
      isValid: function() {
        return null !== this.value
      },
      setVisible: function(a) {
        var d = this,
          g = a ? "show" : "hide";
        n(["graphic", "dataLabel"], function(a) {
          if (d[a]) d[a][g]()
        })
      }
    };
    a.colorSeriesMixin = {
      pointArrayMap: ["value"],
      axisTypes: ["xAxis", "yAxis", "colorAxis"],
      optionalAxis: "colorAxis",
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      getSymbol: k,
      parallelArrays: ["x",
        "y", "value"
      ],
      colorKey: "value",
      pointAttribs: d.column.prototype.pointAttribs,
      translateColors: function() {
        var a = this,
          d = this.options.nullColor,
          k = this.colorAxis,
          m = this.colorKey;
        n(this.data, function(g) {
          var c = g[m];
          if (c = g.options.color || (g.isNull ? d : k && void 0 !== c ? k.toColor(c, g) : g.color || a.color)) g.color = c
        })
      },
      colorAttribs: function(a) {
        var d = {};
        m(a.color) && (d[this.colorProp || "fill"] = a.color);
        return d
      }
    }
  })(v);
  (function(a) {
    function m(a) {
      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(),
        a.cancelBubble = !0)
    }
    var n = a.addEvent,
      k = a.Chart,
      d = a.doc,
      g = a.each,
      t = a.extend,
      z = a.merge,
      u = a.pick;
    a = a.wrap;
    t(k.prototype, {
      renderMapNavigation: function() {
        var a = this,
          c = this.options.mapNavigation,
          b = c.buttons,
          f, d, l, e, g, k = function(b) {
            this.handler.call(a, b);
            m(b)
          };
        if (u(c.enableButtons, c.enabled) && !a.renderer.forExport)
          for (f in a.mapNavButtons = [], b) b.hasOwnProperty(f) && (l = z(c.buttonOptions, b[f]), d = l.theme, d.style = z(l.theme.style, l.style), g = (e = d.states) && e.hover, e = e && e.select, d = a.renderer.button(l.text, 0, 0, k, d,
            g, e, 0, "zoomIn" === f ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation").attr({
            width: l.width,
            height: l.height,
            title: a.options.lang[f],
            padding: l.padding,
            zIndex: 5
          }).add(), d.handler = l.onclick, d.align(t(l, {
            width: d.width,
            height: 2 * d.height
          }), null, l.alignTo), n(d.element, "dblclick", m), a.mapNavButtons.push(d))
      },
      fitToBox: function(a, c) {
        g([
          ["x", "width"],
          ["y", "height"]
        ], function(b) {
          var f = b[0];
          b = b[1];
          a[f] + a[b] > c[f] + c[b] && (a[b] > c[b] ? (a[b] = c[b], a[f] = c[f]) : a[f] = c[f] + c[b] - a[b]);
          a[b] > c[b] && (a[b] = c[b]);
          a[f] <
            c[f] && (a[f] = c[f])
        });
        return a
      },
      mapZoom: function(a, c, b, f, d) {
        var l = this.xAxis[0],
          e = l.max - l.min,
          g = u(c, l.min + e / 2),
          k = e * a,
          e = this.yAxis[0],
          h = e.max - e.min,
          p = u(b, e.min + h / 2),
          h = h * a,
          g = this.fitToBox({
            x: g - k * (f ? (f - l.pos) / l.len : .5),
            y: p - h * (d ? (d - e.pos) / e.len : .5),
            width: k,
            height: h
          }, {
            x: l.dataMin,
            y: e.dataMin,
            width: l.dataMax - l.dataMin,
            height: e.dataMax - e.dataMin
          }),
          k = g.x <= l.dataMin && g.width >= l.dataMax - l.dataMin && g.y <= e.dataMin && g.height >= e.dataMax - e.dataMin;
        f && (l.fixTo = [f - l.pos, c]);
        d && (e.fixTo = [d - e.pos, b]);
        void 0 === a || k ? (l.setExtremes(void 0,
          void 0, !1), e.setExtremes(void 0, void 0, !1)) : (l.setExtremes(g.x, g.x + g.width, !1), e.setExtremes(g.y, g.y + g.height, !1));
        this.redraw()
      }
    });
    a(k.prototype, "render", function(a) {
      var c = this,
        b = c.options.mapNavigation;
      c.renderMapNavigation();
      a.call(c);
      (u(b.enableDoubleClickZoom, b.enabled) || b.enableDoubleClickZoomTo) && n(c.container, "dblclick", function(a) {
        c.pointer.onContainerDblClick(a)
      });
      u(b.enableMouseWheelZoom, b.enabled) && n(c.container, void 0 === d.onmousewheel ? "DOMMouseScroll" : "mousewheel", function(a) {
        c.pointer.onContainerMouseWheel(a);
        m(a);
        return !1
      })
    })
  })(v);
  (function(a) {
    var m = a.extend,
      n = a.pick,
      k = a.Pointer;
    a = a.wrap;
    m(k.prototype, {
      onContainerDblClick: function(a) {
        var d = this.chart;
        a = this.normalize(a);
        d.options.mapNavigation.enableDoubleClickZoomTo ? d.pointer.inClass(a.target, "highcharts-tracker") && d.hoverPoint && d.hoverPoint.zoomTo() : d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(.5, d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY)
      },
      onContainerMouseWheel: function(a) {
        var d = this.chart,
          k;
        a =
          this.normalize(a);
        k = a.detail || -(a.wheelDelta / 120);
        d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(Math.pow(d.options.mapNavigation.mouseWheelSensitivity, k), d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY)
      }
    });
    a(k.prototype, "zoomOption", function(a) {
      var d = this.chart.options.mapNavigation;
      n(d.enableTouchZoom, d.enabled) && (this.chart.options.chart.pinchType = "xy");
      a.apply(this, [].slice.call(arguments, 1))
    });
    a(k.prototype, "pinchTranslate", function(a, g, k, m, n, q,
      c) {
      a.call(this, g, k, m, n, q, c);
      "map" === this.chart.options.chart.type && this.hasZoom && (a = m.scaleX > m.scaleY, this.pinchTranslateDirection(!a, g, k, m, n, q, c, a ? m.scaleX : m.scaleY))
    })
  })(v);
  (function(a) {
    var m = a.color,
      n = a.ColorAxis,
      k = a.colorPointMixin,
      d = a.each,
      g = a.extend,
      t = a.isNumber,
      v = a.map,
      u = a.merge,
      q = a.noop,
      c = a.pick,
      b = a.isArray,
      f = a.Point,
      r = a.Series,
      l = a.seriesType,
      e = a.seriesTypes,
      A = a.splat,
      x = void 0 !== a.doc.documentElement.style.vectorEffect;
    l("map", "scatter", {
      allAreas: !0,
      animation: !1,
      nullColor: "#f7f7f7",
      borderColor: "#cccccc",
      borderWidth: 1,
      marker: null,
      stickyTracking: !1,
      joinBy: "hc-key",
      dataLabels: {
        formatter: function() {
          return this.point.value
        },
        inside: !0,
        verticalAlign: "middle",
        crop: !1,
        overflow: !1,
        padding: 0
      },
      turboThreshold: 0,
      tooltip: {
        followPointer: !0,
        pointFormat: "{point.name}: {point.value}\x3cbr/\x3e"
      },
      states: {
        normal: {
          animation: !0
        },
        hover: {
          brightness: .2,
          halo: null
        },
        select: {
          color: "#cccccc"
        }
      }
    }, u(a.colorSeriesMixin, {
      type: "map",
      supportsDrilldown: !0,
      getExtremesFromAll: !0,
      useMapGeometry: !0,
      forceDL: !0,
      searchPoint: q,
      directTouch: !0,
      preserveAspectRatio: !0,
      pointArrayMap: ["value"],
      getBox: function(b) {
        var h = Number.MAX_VALUE,
          f = -h,
          e = h,
          l = -h,
          g = h,
          k = h,
          r = this.xAxis,
          m = this.yAxis,
          n;
        d(b || [], function(b) {
          if (b.path) {
            "string" === typeof b.path && (b.path = a.splitPath(b.path));
            var d = b.path || [],
              r = d.length,
              p = !1,
              m = -h,
              w = h,
              B = -h,
              x = h,
              q = b.properties;
            if (!b._foundBox) {
              for (; r--;) t(d[r]) && (p ? (m = Math.max(m, d[r]), w = Math.min(w, d[r])) : (B = Math.max(B, d[r]), x = Math.min(x, d[r])), p = !p);
              b._midX = w + (m - w) * (b.middleX || q && q["hc-middle-x"] || .5);
              b._midY = x + (B - x) * (b.middleY || q && q["hc-middle-y"] ||
                .5);
              b._maxX = m;
              b._minX = w;
              b._maxY = B;
              b._minY = x;
              b.labelrank = c(b.labelrank, (m - w) * (B - x));
              b._foundBox = !0
            }
            f = Math.max(f, b._maxX);
            e = Math.min(e, b._minX);
            l = Math.max(l, b._maxY);
            g = Math.min(g, b._minY);
            k = Math.min(b._maxX - b._minX, b._maxY - b._minY, k);
            n = !0
          }
        });
        n && (this.minY = Math.min(g, c(this.minY, h)), this.maxY = Math.max(l, c(this.maxY, -h)), this.minX = Math.min(e, c(this.minX, h)), this.maxX = Math.max(f, c(this.maxX, -h)), r && void 0 === r.options.minRange && (r.minRange = Math.min(5 * k, (this.maxX - this.minX) / 5, r.minRange || h)), m && void 0 ===
          m.options.minRange && (m.minRange = Math.min(5 * k, (this.maxY - this.minY) / 5, m.minRange || h)))
      },
      getExtremes: function() {
        r.prototype.getExtremes.call(this, this.valueData);
        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        this.dataMin = this.minY;
        this.dataMax = this.maxY
      },
      translatePath: function(a) {
        var b = !1,
          h = this.xAxis,
          c = this.yAxis,
          d = h.min,
          f = h.transA,
          h = h.minPixelPadding,
          e = c.min,
          l = c.transA,
          c = c.minPixelPadding,
          k, g = [];
        if (a)
          for (k = a.length; k--;) t(a[k]) ?
            (g[k] = b ? (a[k] - d) * f + h : (a[k] - e) * l + c, b = !b) : g[k] = a[k];
        return g
      },
      setData: function(h, c, f, e) {
        var l = this.options,
          k = this.chart.options.chart,
          g = k && k.map,
          m = l.mapData,
          p = l.joinBy,
          w = null === p,
          x = l.keys || this.pointArrayMap,
          n = [],
          q = {},
          y, z = this.chart.mapTransforms;
        !m && g && (m = "string" === typeof g ? a.maps[g] : g);
        w && (p = "_i");
        p = this.joinBy = A(p);
        p[1] || (p[1] = p[0]);
        h && d(h, function(a, c) {
          var d = 0;
          if (t(a)) h[c] = {
            value: a
          };
          else if (b(a)) {
            h[c] = {};
            !l.keys && a.length > x.length && "string" === typeof a[0] && (h[c]["hc-key"] = a[0], ++d);
            for (var f = 0; f <
              x.length; ++f, ++d) x[f] && (h[c][x[f]] = a[d])
          }
          w && (h[c]._i = c)
        });
        this.getBox(h);
        if (this.chart.mapTransforms = z = k && k.mapTransforms || m && m["hc-transform"] || z)
          for (y in z) z.hasOwnProperty(y) && y.rotation && (y.cosAngle = Math.cos(y.rotation), y.sinAngle = Math.sin(y.rotation));
        if (m) {
          "FeatureCollection" === m.type && (this.mapTitle = m.title, m = a.geojson(m, this.type, this));
          this.mapData = m;
          this.mapMap = {};
          for (y = 0; y < m.length; y++) k = m[y], g = k.properties, k._i = y, p[0] && g && g[p[0]] && (k[p[0]] = g[p[0]]), q[k[p[0]]] = k;
          this.mapMap = q;
          h && p[1] &&
            d(h, function(a) {
              q[a[p[1]]] && n.push(q[a[p[1]]])
            });
          l.allAreas ? (this.getBox(m), h = h || [], p[1] && d(h, function(a) {
            n.push(a[p[1]])
          }), n = "|" + v(n, function(a) {
            return a && a[p[0]]
          }).join("|") + "|", d(m, function(a) {
            p[0] && -1 !== n.indexOf("|" + a[p[0]] + "|") || (h.push(u(a, {
              value: null
            })), e = !1)
          })) : this.getBox(n)
        }
        r.prototype.setData.call(this, h, c, f, e)
      },
      drawGraph: q,
      drawDataLabels: q,
      doFullTranslate: function() {
        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans
      },
      translate: function() {
        var a =
          this,
          b = a.xAxis,
          c = a.yAxis,
          f = a.doFullTranslate();
        a.generatePoints();
        d(a.data, function(h) {
          h.plotX = b.toPixels(h._midX, !0);
          h.plotY = c.toPixels(h._midY, !0);
          f && (h.shapeType = "path", h.shapeArgs = {
            d: a.translatePath(h.path)
          })
        });
        a.translateColors()
      },
      pointAttribs: function(a, b) {
        b = e.column.prototype.pointAttribs.call(this, a, b);
        a.isFading && delete b.fill;
        x ? b["vector-effect"] = "non-scaling-stroke" : b["stroke-width"] = "inherit";
        return b
      },
      drawPoints: function() {
        var a = this,
          b = a.xAxis,
          c = a.yAxis,
          f = a.group,
          l = a.chart,
          k = l.renderer,
          g, m = this.baseTrans;
        a.transformGroup || (a.transformGroup = k.g().attr({
          scaleX: 1,
          scaleY: 1
        }).add(f), a.transformGroup.survive = !0);
        a.doFullTranslate() ? (l.hasRendered && d(a.points, function(b) {
          b.shapeArgs && (b.shapeArgs.fill = a.pointAttribs(b, b.state).fill)
        }), a.group = a.transformGroup, e.column.prototype.drawPoints.apply(a), a.group = f, d(a.points, function(a) {
          a.graphic && (a.name && a.graphic.addClass("highcharts-name-" + a.name.replace(/ /g, "-").toLowerCase()), a.properties && a.properties["hc-key"] && a.graphic.addClass("highcharts-key-" +
            a.properties["hc-key"].toLowerCase()))
        }), this.baseTrans = {
          originX: b.min - b.minPixelPadding / b.transA,
          originY: c.min - c.minPixelPadding / c.transA + (c.reversed ? 0 : c.len / c.transA),
          transAX: b.transA,
          transAY: c.transA
        }, this.transformGroup.animate({
          translateX: 0,
          translateY: 0,
          scaleX: 1,
          scaleY: 1
        })) : (g = b.transA / m.transAX, f = c.transA / m.transAY, b = b.toPixels(m.originX, !0), c = c.toPixels(m.originY, !0), .99 < g && 1.01 > g && .99 < f && 1.01 > f && (f = g = 1, b = Math.round(b), c = Math.round(c)), this.transformGroup.animate({
          translateX: b,
          translateY: c,
          scaleX: g,
          scaleY: f
        }));
        x || a.group.element.setAttribute("stroke-width", a.options[a.pointAttrToOptions && a.pointAttrToOptions["stroke-width"] || "borderWidth"] / (g || 1));
        this.drawMapDataLabels()
      },
      drawMapDataLabels: function() {
        r.prototype.drawDataLabels.call(this);
        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect)
      },
      render: function() {
        var a = this,
          b = r.prototype.render;
        a.chart.renderer.isVML && 3E3 < a.data.length ? setTimeout(function() {
          b.call(a)
        }) : b.call(a)
      },
      animate: function(a) {
        var b = this.options.animation,
          c = this.group,
          h = this.xAxis,
          f = this.yAxis,
          d = h.pos,
          e = f.pos;
        this.chart.renderer.isSVG && (!0 === b && (b = {
          duration: 1E3
        }), a ? c.attr({
          translateX: d + h.len / 2,
          translateY: e + f.len / 2,
          scaleX: .001,
          scaleY: .001
        }) : (c.animate({
          translateX: d,
          translateY: e,
          scaleX: 1,
          scaleY: 1
        }, b), this.animate = null))
      },
      animateDrilldown: function(a) {
        var b = this.chart.plotBox,
          c = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
          f = c.bBox,
          h = this.chart.options.drilldown.animation;
        a || (a = Math.min(f.width / b.width, f.height / b.height), c.shapeArgs = {
          scaleX: a,
          scaleY: a,
          translateX: f.x,
          translateY: f.y
        }, d(this.points, function(a) {
          a.graphic && a.graphic.attr(c.shapeArgs).animate({
            scaleX: 1,
            scaleY: 1,
            translateX: 0,
            translateY: 0
          }, h)
        }), this.animate = null)
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      animateDrillupFrom: function(a) {
        e.column.prototype.animateDrillupFrom.call(this, a)
      },
      animateDrillupTo: function(a) {
        e.column.prototype.animateDrillupTo.call(this, a)
      }
    }), g({
      applyOptions: function(a, b) {
        a = f.prototype.applyOptions.call(this, a, b);
        b = this.series;
        var c =
          b.joinBy;
        b.mapData && ((c = void 0 !== a[c[1]] && b.mapMap[a[c[1]]]) ? (b.xyFromShape && (a.x = c._midX, a.y = c._midY), g(a, c)) : a.value = a.value || null);
        return a
      },
      onMouseOver: function(a) {
        clearTimeout(this.colorInterval);
        if (null !== this.value) f.prototype.onMouseOver.call(this, a);
        else this.series.onMouseOut(a)
      },
      onMouseOut: function() {
        var a = this,
          b = +new Date,
          c = m(this.series.pointAttribs(a).fill),
          d = m(this.series.pointAttribs(a, "hover").fill),
          e = a.series.options.states.normal.animation,
          l = e && (e.duration || 500);
        l && 4 === c.rgba.length &&
          4 === d.rgba.length && "select" !== a.state && (clearTimeout(a.colorInterval), a.colorInterval = setInterval(function() {
            var f = (new Date - b) / l,
              e = a.graphic;
            1 < f && (f = 1);
            e && e.attr("fill", n.prototype.tweenColors.call(0, d, c, f));
            1 <= f && clearTimeout(a.colorInterval)
          }, 13));
        a.isFading = !0;
        f.prototype.onMouseOut.call(a);
        a.isFading = null
      },
      zoomTo: function() {
        var a = this.series;
        a.xAxis.setExtremes(this._minX, this._maxX, !1);
        a.yAxis.setExtremes(this._minY, this._maxY, !1);
        a.chart.redraw()
      }
    }, k))
  })(v);
  (function(a) {
    var m = a.seriesType,
      n = a.seriesTypes;
    m("mapline", "map", {
      lineWidth: 1,
      fillColor: "none"
    }, {
      type: "mapline",
      colorProp: "stroke",
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      },
      pointAttribs: function(a, d) {
        a = n.map.prototype.pointAttribs.call(this, a, d);
        a.fill = this.options.fillColor;
        return a
      },
      drawLegendSymbol: n.line.prototype.drawLegendSymbol
    })
  })(v);
  (function(a) {
    var m = a.merge,
      n = a.Point;
    a = a.seriesType;
    a("mappoint", "scatter", {
      dataLabels: {
        enabled: !0,
        formatter: function() {
          return this.point.name
        },
        crop: !1,
        defer: !1,
        overflow: !1,
        style: {
          color: "#000000"
        }
      }
    }, {
      type: "mappoint",
      forceDL: !0
    }, {
      applyOptions: function(a, d) {
        a = void 0 !== a.lat && void 0 !== a.lon ? m(a, this.series.chart.fromLatLonToPoint(a)) : a;
        return n.prototype.applyOptions.call(this, a, d)
      }
    })
  })(v);
  (function(a) {
    var m = a.merge,
      n = a.Point,
      k = a.seriesType,
      d = a.seriesTypes;
    d.bubble && k("mapbubble", "bubble", {
      animationLimit: 500,
      tooltip: {
        pointFormat: "{point.name}: {point.z}"
      }
    }, {
      xyFromShape: !0,
      type: "mapbubble",
      pointArrayMap: ["z"],
      getMapData: d.map.prototype.getMapData,
      getBox: d.map.prototype.getBox,
      setData: d.map.prototype.setData
    }, {
      applyOptions: function(a, k) {
        return a && void 0 !== a.lat && void 0 !== a.lon ? n.prototype.applyOptions.call(this, m(a, this.series.chart.fromLatLonToPoint(a)), k) : d.map.prototype.pointClass.prototype.applyOptions.call(this, a, k)
      },
      ttBelow: !1
    })
  })(v);
  (function(a) {
    var m = a.colorPointMixin,
      n = a.each,
      k = a.merge,
      d = a.noop,
      g = a.pick,
      t = a.Series,
      v = a.seriesType,
      u = a.seriesTypes;
    v("heatmap", "scatter", {
      animation: !1,
      borderWidth: 0,
      nullColor: "#f7f7f7",
      dataLabels: {
        formatter: function() {
          return this.point.value
        },
        inside: !0,
        verticalAlign: "middle",
        crop: !1,
        overflow: !1,
        padding: 0
      },
      marker: null,
      pointRange: null,
      tooltip: {
        pointFormat: "{point.x}, {point.y}: {point.value}\x3cbr/\x3e"
      },
      states: {
        normal: {
          animation: !0
        },
        hover: {
          halo: !1,
          brightness: .2
        }
      }
    }, k(a.colorSeriesMixin, {
      pointArrayMap: ["y", "value"],
      hasPointSpecificOptions: !0,
      supportsDrilldown: !0,
      getExtremesFromAll: !0,
      directTouch: !0,
      init: function() {
        var a;
        u.scatter.prototype.init.apply(this, arguments);
        a = this.options;
        a.pointRange = g(a.pointRange, a.colsize || 1);
        this.yAxis.axisPointRange =
          a.rowsize || 1
      },
      translate: function() {
        var a = this.options,
          c = this.xAxis,
          b = this.yAxis,
          f = function(a, b, c) {
            return Math.min(Math.max(b, a), c)
          };
        this.generatePoints();
        n(this.points, function(d) {
          var l = (a.colsize || 1) / 2,
            e = (a.rowsize || 1) / 2,
            g = f(Math.round(c.len - c.translate(d.x - l, 0, 1, 0, 1)), -c.len, 2 * c.len),
            l = f(Math.round(c.len - c.translate(d.x + l, 0, 1, 0, 1)), -c.len, 2 * c.len),
            k = f(Math.round(b.translate(d.y - e, 0, 1, 0, 1)), -b.len, 2 * b.len),
            e = f(Math.round(b.translate(d.y + e, 0, 1, 0, 1)), -b.len, 2 * b.len);
          d.plotX = d.clientX = (g + l) / 2;
          d.plotY =
            (k + e) / 2;
          d.shapeType = "rect";
          d.shapeArgs = {
            x: Math.min(g, l),
            y: Math.min(k, e),
            width: Math.abs(l - g),
            height: Math.abs(e - k)
          }
        });
        this.translateColors()
      },
      drawPoints: function() {
        u.column.prototype.drawPoints.call(this);
        n(this.points, function(a) {
          a.graphic.attr(this.colorAttribs(a, a.state))
        }, this)
      },
      animate: d,
      getBox: d,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      alignDataLabel: u.column.prototype.alignDataLabel,
      getExtremes: function() {
        t.prototype.getExtremes.call(this, this.valueData);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        t.prototype.getExtremes.call(this)
      }
    }), m)
  })(v);
  (function(a) {
    function m(a, b) {
      var c, d, l, e = !1,
        g = a.x,
        k = a.y;
      a = 0;
      for (c = b.length - 1; a < b.length; c = a++) d = b[a][1] > k, l = b[c][1] > k, d !== l && g < (b[c][0] - b[a][0]) * (k - b[a][1]) / (b[c][1] - b[a][1]) + b[a][0] && (e = !e);
      return e
    }
    var n = a.Chart,
      k = a.each,
      d = a.extend,
      g = a.error,
      t = a.format,
      v = a.merge,
      u = a.win,
      q = a.wrap;
    n.prototype.transformFromLatLon = function(a, b) {
      if (void 0 === u.proj4) return g(21), {
        x: 0,
        y: null
      };
      a = u.proj4(b.crs, [a.lon, a.lat]);
      var c = b.cosAngle || b.rotation &&
        Math.cos(b.rotation),
        d = b.sinAngle || b.rotation && Math.sin(b.rotation);
      a = b.rotation ? [a[0] * c + a[1] * d, -a[0] * d + a[1] * c] : a;
      return {
        x: ((a[0] - (b.xoffset || 0)) * (b.scale || 1) + (b.xpan || 0)) * (b.jsonres || 1) + (b.jsonmarginX || 0),
        y: (((b.yoffset || 0) - a[1]) * (b.scale || 1) + (b.ypan || 0)) * (b.jsonres || 1) - (b.jsonmarginY || 0)
      }
    };
    n.prototype.transformToLatLon = function(a, b) {
      if (void 0 === u.proj4) g(21);
      else {
        a = {
          x: ((a.x - (b.jsonmarginX || 0)) / (b.jsonres || 1) - (b.xpan || 0)) / (b.scale || 1) + (b.xoffset || 0),
          y: ((-a.y - (b.jsonmarginY || 0)) / (b.jsonres || 1) + (b.ypan ||
            0)) / (b.scale || 1) + (b.yoffset || 0)
        };
        var c = b.cosAngle || b.rotation && Math.cos(b.rotation),
          d = b.sinAngle || b.rotation && Math.sin(b.rotation);
        b = u.proj4(b.crs, "WGS84", b.rotation ? {
          x: a.x * c + a.y * -d,
          y: a.x * d + a.y * c
        } : a);
        return {
          lat: b.y,
          lon: b.x
        }
      }
    };
    n.prototype.fromPointToLatLon = function(a) {
      var b = this.mapTransforms,
        c;
      if (b) {
        for (c in b)
          if (b.hasOwnProperty(c) && b[c].hitZone && m({
              x: a.x,
              y: -a.y
            }, b[c].hitZone.coordinates[0])) return this.transformToLatLon(a, b[c]);
        return this.transformToLatLon(a, b["default"])
      }
      g(22)
    };
    n.prototype.fromLatLonToPoint =
      function(a) {
        var b = this.mapTransforms,
          c, d;
        if (!b) return g(22), {
          x: 0,
          y: null
        };
        for (c in b)
          if (b.hasOwnProperty(c) && b[c].hitZone && (d = this.transformFromLatLon(a, b[c]), m({
              x: d.x,
              y: -d.y
            }, b[c].hitZone.coordinates[0]))) return d;
        return this.transformFromLatLon(a, b["default"])
      };
    a.geojson = function(a, b, f) {
      var c = [],
        l = [],
        e = function(a) {
          var b, c = a.length;
          l.push("M");
          for (b = 0; b < c; b++) 1 === b && l.push("L"), l.push(a[b][0], -a[b][1])
        };
      b = b || "map";
      k(a.features, function(a) {
        var f = a.geometry,
          h = f.type,
          f = f.coordinates;
        a = a.properties;
        var g;
        l = [];
        "map" === b || "mapbubble" === b ? ("Polygon" === h ? (k(f, e), l.push("Z")) : "MultiPolygon" === h && (k(f, function(a) {
          k(a, e)
        }), l.push("Z")), l.length && (g = {
          path: l
        })) : "mapline" === b ? ("LineString" === h ? e(f) : "MultiLineString" === h && k(f, e), l.length && (g = {
          path: l
        })) : "mappoint" === b && "Point" === h && (g = {
          x: f[0],
          y: -f[1]
        });
        g && c.push(d(g, {
          name: a.name || a.NAME,
          properties: a
        }))
      });
      f && a.copyrightShort && (f.chart.mapCredits = t(f.chart.options.credits.mapText, {
        geojson: a
      }), f.chart.mapCreditsFull = t(f.chart.options.credits.mapTextFull, {
        geojson: a
      }));
      return c
    };
    q(n.prototype, "addCredits", function(a, b) {
      b = v(!0, this.options.credits, b);
      this.mapCredits && (b.href = null);
      a.call(this, b);
      this.credits && this.mapCreditsFull && this.credits.attr({
        title: this.mapCreditsFull
      })
    })
  })(v);
  (function(a) {
    function m(a, c, d, l, e, g, k, h) {
      return ["M", a + e, c, "L", a + d - g, c, "C", a + d - g / 2, c, a + d, c + g / 2, a + d, c + g, "L", a + d, c + l - k, "C", a + d, c + l - k / 2, a + d - k / 2, c + l, a + d - k, c + l, "L", a + h, c + l, "C", a + h / 2, c + l, a, c + l - h / 2, a, c + l - h, "L", a, c + e, "C", a, c + e / 2, a + e / 2, c, a + e, c, "Z"]
    }
    var n = a.Chart,
      k = a.defaultOptions,
      d = a.each,
      g = a.extend,
      t = a.merge,
      v = a.pick,
      u = a.Renderer,
      q = a.SVGRenderer,
      c = a.VMLRenderer;
    g(k.lang, {
      zoomIn: "Zoom in",
      zoomOut: "Zoom out"
    });
    k.mapNavigation = {
      buttonOptions: {
        alignTo: "plotBox",
        align: "left",
        verticalAlign: "top",
        x: 0,
        width: 18,
        height: 18,
        padding: 5,
        style: {
          fontSize: "15px",
          fontWeight: "bold"
        },
        theme: {
          "stroke-width": 1,
          "text-align": "center"
        }
      },
      buttons: {
        zoomIn: {
          onclick: function() {
            this.mapZoom(.5)
          },
          text: "+",
          y: 0
        },
        zoomOut: {
          onclick: function() {
            this.mapZoom(2)
          },
          text: "-",
          y: 28
        }
      },
      mouseWheelSensitivity: 1.1
    };
    a.splitPath = function(a) {
      var b;
      a = a.replace(/([A-Za-z])/g, " $1 ");
      a = a.replace(/^\s*/, "").replace(/\s*$/, "");
      a = a.split(/[ ,]+/);
      for (b = 0; b < a.length; b++) /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));
      return a
    };
    a.maps = {};
    q.prototype.symbols.topbutton = function(a, c, d, l, e) {
      return m(a - 1, c - 1, d, l, e.r, e.r, 0, 0)
    };
    q.prototype.symbols.bottombutton = function(a, c, d, l, e) {
      return m(a - 1, c - 1, d, l, 0, 0, e.r, e.r)
    };
    u === c && d(["topbutton", "bottombutton"], function(a) {
      c.prototype.symbols[a] = q.prototype.symbols[a]
    });
    a.Map = a.mapChart = function(b, c, d) {
      var f = "string" ===
        typeof b || b.nodeName,
        e = arguments[f ? 1 : 0],
        g = {
          endOnTick: !1,
          visible: !1,
          minPadding: 0,
          maxPadding: 0,
          startOnTick: !1
        },
        k, h = a.getOptions().credits;
      k = e.series;
      e.series = null;
      e = t({
        chart: {
          panning: "xy",
          type: "map"
        },
        credits: {
          mapText: v(h.mapText, ' \u00a9 \x3ca href\x3d"{geojson.copyrightUrl}"\x3e{geojson.copyrightShort}\x3c/a\x3e'),
          mapTextFull: v(h.mapTextFull, "{geojson.copyright}")
        },
        tooltip: {
          followTouchMove: !1
        },
        xAxis: g,
        yAxis: t(g, {
          reversed: !0
        })
      }, e, {
        chart: {
          inverted: !1,
          alignTicks: !1
        }
      });
      e.series = k;
      return f ? new n(b, e, d) :
        new n(e, c)
    }
  })(v)
});;
/*! RESOURCE: /scripts/highcharts/modules/treemap.js */
(function(q) {
  "object" === typeof module && module.exports ? module.exports = q : q(Highcharts)
})(function(q) {
  (function(g) {
    var q = g.seriesType,
      l = g.seriesTypes,
      E = g.map,
      v = g.merge,
      y = g.extend,
      z = g.noop,
      n = g.each,
      x = g.grep,
      F = g.isNumber,
      A = g.isString,
      k = g.pick,
      r = g.Series,
      G = g.stableSort,
      B = g.Color,
      H = function(a, b, c) {
        var e;
        c = c || this;
        for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a)
      },
      C = function(a, b, c, e) {
        e = e || this;
        a = a || [];
        n(a, function(d, f) {
          c = b.call(e, c, d, f, a)
        });
        return c
      },
      w = function(a, b, c) {
        c = c || this;
        a = b.call(c, a);
        !1 !== a && w(a,
          b, c)
      };
    q("treemap", "scatter", {
      showInLegend: !1,
      marker: !1,
      dataLabels: {
        enabled: !0,
        defer: !1,
        verticalAlign: "middle",
        formatter: function() {
          return this.point.name || this.point.id
        },
        inside: !0
      },
      tooltip: {
        headerFormat: "",
        pointFormat: "\x3cb\x3e{point.name}\x3c/b\x3e: {point.value}\x3c/b\x3e\x3cbr/\x3e"
      },
      layoutAlgorithm: "sliceAndDice",
      layoutStartingDirection: "vertical",
      alternateStartingDirection: !1,
      levelIsConstant: !0,
      drillUpButton: {
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      borderColor: "#e6e6e6",
      borderWidth: 1,
      opacity: .15,
      states: {
        hover: {
          borderColor: "#999999",
          brightness: l.heatmap ? 0 : .1,
          opacity: .75,
          shadow: !1
        }
      }
    }, {
      pointArrayMap: ["value"],
      axisTypes: l.heatmap ? ["xAxis", "yAxis", "colorAxis"] : ["xAxis", "yAxis"],
      optionalAxis: "colorAxis",
      getSymbol: z,
      parallelArrays: ["x", "y", "value", "colorValue"],
      colorKey: "colorValue",
      translateColors: l.heatmap && l.heatmap.prototype.translateColors,
      trackerGroups: ["group", "dataLabelsGroup"],
      getListOfParents: function(a, b) {
        a = C(a, function(a, b, d) {
          b = k(b.parent, "");
          void 0 === a[b] && (a[b] = []);
          a[b].push(d);
          return a
        }, {});
        H(a, function(a, e, d) {
          "" !== e && -1 === g.inArray(e, b) && (n(a, function(a) {
            d[""].push(a)
          }), delete d[e])
        });
        return a
      },
      getTree: function() {
        var a = E(this.data, function(a) {
            return a.id
          }),
          a = this.getListOfParents(this.data, a);
        this.nodeMap = [];
        return this.buildNode("", -1, 0, a, null)
      },
      init: function(a, b) {
        r.prototype.init.call(this, a, b);
        this.options.allowDrillToNode && g.addEvent(this, "click", this.onClickDrillToNode)
      },
      buildNode: function(a, b, c, e, d) {
        var f = this,
          h = [],
          D = f.points[b],
          p;
        n(e[a] || [], function(b) {
          p = f.buildNode(f.points[b].id,
            b, c + 1, e, a);
          h.push(p)
        });
        b = {
          id: a,
          i: b,
          children: h,
          level: c,
          parent: d,
          visible: !1
        };
        f.nodeMap[b.id] = b;
        D && (D.node = b);
        return b
      },
      setTreeValues: function(a) {
        var b = this,
          c = b.options,
          e = 0,
          d = [],
          f, h = b.points[a.i];
        w(b.nodeMap[b.rootNode], function(a) {
          var c = !1,
            d = a.parent;
          a.visible = !0;
          if (d || "" === d) c = b.nodeMap[d];
          return c
        });
        w(b.nodeMap[b.rootNode].children, function(a) {
          var b = !1;
          n(a, function(a) {
            a.visible = !0;
            a.children.length && (b = (b || []).concat(a.children))
          });
          return b
        });
        n(a.children, function(a) {
          a = b.setTreeValues(a);
          d.push(a);
          a.ignore ? w(a.children, function(a) {
            var b = !1;
            n(a, function(a) {
              y(a, {
                ignore: !0,
                isLeaf: !1,
                visible: !1
              });
              a.children.length && (b = (b || []).concat(a.children))
            });
            return b
          }) : e += a.val
        });
        G(d, function(a, b) {
          return a.sortIndex - b.sortIndex
        });
        f = k(h && h.options.value, e);
        h && (h.value = f);
        y(a, {
          children: d,
          childrenTotal: e,
          ignore: !(k(h && h.visible, !0) && 0 < f),
          isLeaf: a.visible && !e,
          levelDynamic: c.levelIsConstant ? a.level : a.level - b.nodeMap[b.rootNode].level,
          name: k(h && h.name, ""),
          sortIndex: k(h && h.sortIndex, -f),
          val: f
        });
        return a
      },
      calculateChildrenAreas: function(a,
        b) {
        var c = this,
          e = c.options,
          d = this.levelMap[a.levelDynamic + 1],
          f = k(c[d && d.layoutAlgorithm] && d.layoutAlgorithm, e.layoutAlgorithm),
          h = e.alternateStartingDirection,
          g = [];
        a = x(a.children, function(a) {
          return !a.ignore
        });
        d && d.layoutStartingDirection && (b.direction = "vertical" === d.layoutStartingDirection ? 0 : 1);
        g = c[f](b, a);
        n(a, function(a, d) {
          d = g[d];
          a.values = v(d, {
            val: a.childrenTotal,
            direction: h ? 1 - b.direction : b.direction
          });
          a.pointValues = v(d, {
            x: d.x / c.axisRatio,
            width: d.width / c.axisRatio
          });
          a.children.length && c.calculateChildrenAreas(a,
            a.values)
        })
      },
      setPointValues: function() {
        var a = this,
          b = a.xAxis,
          c = a.yAxis;
        n(a.points, function(e) {
          var d = e.node,
            f = d.pointValues,
            h, g, p = (a.pointAttribs(e)["stroke-width"] || 0) % 2 / 2;
          f && d.visible ? (d = Math.round(b.translate(f.x, 0, 0, 0, 1)) - p, h = Math.round(b.translate(f.x + f.width, 0, 0, 0, 1)) - p, g = Math.round(c.translate(f.y, 0, 0, 0, 1)) - p, f = Math.round(c.translate(f.y + f.height, 0, 0, 0, 1)) - p, e.shapeType = "rect", e.shapeArgs = {
              x: Math.min(d, h),
              y: Math.min(g, f),
              width: Math.abs(h - d),
              height: Math.abs(f - g)
            }, e.plotX = e.shapeArgs.x + e.shapeArgs.width /
            2, e.plotY = e.shapeArgs.y + e.shapeArgs.height / 2) : (delete e.plotX, delete e.plotY)
        })
      },
      setColorRecursive: function(a, b, c) {
        var e = this,
          d, f;
        a && (d = e.points[a.i], f = e.levelMap[a.levelDynamic], b = k(d && d.options.color, f && f.color, b), c = k(d && d.options.colorIndex, f && f.colorIndex, c), d && (d.color = b, d.colorIndex = c), a.children.length && n(a.children, function(a) {
          e.setColorRecursive(a, b, c)
        }))
      },
      algorithmGroup: function(a, b, c, e) {
        this.height = a;
        this.width = b;
        this.plot = e;
        this.startDirection = this.direction = c;
        this.lH = this.nH = this.lW =
          this.nW = this.total = 0;
        this.elArr = [];
        this.lP = {
          total: 0,
          lH: 0,
          nH: 0,
          lW: 0,
          nW: 0,
          nR: 0,
          lR: 0,
          aspectRatio: function(a, b) {
            return Math.max(a / b, b / a)
          }
        };
        this.addElement = function(a) {
          this.lP.total = this.elArr[this.elArr.length - 1];
          this.total += a;
          0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total /
            this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH));
          this.elArr.push(a)
        };
        this.reset = function() {
          this.lW = this.nW = 0;
          this.elArr = [];
          this.total = 0
        }
      },
      algorithmCalcPoints: function(a, b, c, e) {
        var d, f, h, g, p = c.lW,
          k = c.lH,
          m = c.plot,
          l, t = 0,
          u = c.elArr.length - 1;
        b ? (p = c.nW, k = c.nH) : l = c.elArr[c.elArr.length - 1];
        n(c.elArr, function(a) {
          if (b || t < u) 0 === c.direction ? (d = m.x, f = m.y, h = p, g = a / h) : (d = m.x, f = m.y, g = k, h = a / g),
            e.push({
              x: d,
              y: f,
              width: h,
              height: g
            }), 0 === c.direction ? m.y += g : m.x += h;
          t += 1
        });
        c.reset();
        0 === c.direction ? c.width -= p : c.height -= k;
        m.y = m.parent.y + (m.parent.height - c.height);
        m.x = m.parent.x + (m.parent.width - c.width);
        a && (c.direction = 1 - c.direction);
        b || c.addElement(l)
      },
      algorithmLowAspectRatio: function(a, b, c) {
        var e = [],
          d = this,
          f, g = {
            x: b.x,
            y: b.y,
            parent: b
          },
          k = 0,
          p = c.length - 1,
          l = new this.algorithmGroup(b.height, b.width, b.direction, g);
        n(c, function(c) {
          f = c.val / b.val * b.height * b.width;
          l.addElement(f);
          l.lP.nR > l.lP.lR && d.algorithmCalcPoints(a,
            !1, l, e, g);
          k === p && d.algorithmCalcPoints(a, !0, l, e, g);
          k += 1
        });
        return e
      },
      algorithmFill: function(a, b, c) {
        var e = [],
          d, f = b.direction,
          g = b.x,
          k = b.y,
          l = b.width,
          q = b.height,
          m, r, t, u;
        n(c, function(c) {
          d = c.val / b.val * b.height * b.width;
          m = g;
          r = k;
          0 === f ? (u = q, t = d / u, l -= t, g += t) : (t = l, u = d / t, q -= u, k += u);
          e.push({
            x: m,
            y: r,
            width: t,
            height: u
          });
          a && (f = 1 - f)
        });
        return e
      },
      strip: function(a, b) {
        return this.algorithmLowAspectRatio(!1, a, b)
      },
      squarified: function(a, b) {
        return this.algorithmLowAspectRatio(!0, a, b)
      },
      sliceAndDice: function(a, b) {
        return this.algorithmFill(!0,
          a, b)
      },
      stripes: function(a, b) {
        return this.algorithmFill(!1, a, b)
      },
      translate: function() {
        var a = this.rootNode = k(this.rootNode, this.options.rootId, ""),
          b, c;
        r.prototype.translate.call(this);
        this.levelMap = C(this.options.levels, function(a, b) {
          a[b.level] = b;
          return a
        }, {});
        c = this.tree = this.getTree();
        b = this.nodeMap[a];
        "" === a || b && b.children.length || (this.drillToNode("", !1), a = this.rootNode, b = this.nodeMap[a]);
        this.setTreeValues(c);
        this.axisRatio = this.xAxis.len / this.yAxis.len;
        this.nodeMap[""].pointValues = a = {
          x: 0,
          y: 0,
          width: 100,
          height: 100
        };
        this.nodeMap[""].values = a = v(a, {
          width: a.width * this.axisRatio,
          direction: "vertical" === this.options.layoutStartingDirection ? 0 : 1,
          val: c.val
        });
        this.calculateChildrenAreas(c, a);
        this.colorAxis ? this.translateColors() : this.options.colorByPoint || this.setColorRecursive(this.tree);
        this.options.allowDrillToNode && (b = b.pointValues, this.xAxis.setExtremes(b.x, b.x + b.width, !1), this.yAxis.setExtremes(b.y, b.y + b.height, !1), this.xAxis.setScale(), this.yAxis.setScale());
        this.setPointValues()
      },
      drawDataLabels: function() {
        var a =
          this,
          b = x(a.points, function(a) {
            return a.node.visible
          }),
          c, e;
        n(b, function(b) {
          e = a.levelMap[b.node.levelDynamic];
          c = {
            style: {}
          };
          b.node.isLeaf || (c.enabled = !1);
          e && e.dataLabels && (c = v(c, e.dataLabels), a._hasPointLabels = !0);
          b.shapeArgs && (c.style.width = b.shapeArgs.width, b.dataLabel && b.dataLabel.css({
            width: b.shapeArgs.width + "px"
          }));
          b.dlOptions = v(c, b.options.dataLabels)
        });
        r.prototype.drawDataLabels.call(this)
      },
      alignDataLabel: function(a) {
        l.column.prototype.alignDataLabel.apply(this, arguments);
        a.dataLabel && a.dataLabel.attr({
          zIndex: a.node.zIndex +
            1
        })
      },
      pointAttribs: function(a, b) {
        var c = this.levelMap[a.node.levelDynamic] || {},
          e = this.options,
          d = b && e.states[b] || {},
          f = a.getClassName();
        a = {
          stroke: a.borderColor || c.borderColor || d.borderColor || e.borderColor,
          "stroke-width": k(a.borderWidth, c.borderWidth, d.borderWidth, e.borderWidth),
          dashstyle: a.borderDashStyle || c.borderDashStyle || d.borderDashStyle || e.borderDashStyle,
          fill: a.color || this.color
        }; - 1 !== f.indexOf("highcharts-above-level") ? (a.fill = "none", a["stroke-width"] = 0) : -1 !== f.indexOf("highcharts-internal-node-interactive") ?
          (b = k(d.opacity, e.opacity), a.fill = B(a.fill).setOpacity(b).get(), a.cursor = "pointer") : -1 !== f.indexOf("highcharts-internal-node") ? a.fill = "none" : b && (a.fill = B(a.fill).brighten(d.brightness).get());
        return a
      },
      drawPoints: function() {
        var a = this,
          b = x(a.points, function(a) {
            return a.node.visible
          });
        n(b, function(b) {
          var c = "levelGroup-" + b.node.levelDynamic;
          a[c] || (a[c] = a.chart.renderer.g(c).attr({
            zIndex: 1E3 - b.node.levelDynamic
          }).add(a.group));
          b.group = a[c]
        });
        l.column.prototype.drawPoints.call(this);
        a.options.allowDrillToNode &&
          n(b, function(b) {
            b.graphic && (b.drillId = a.options.interactByLeaf ? a.drillToByLeaf(b) : a.drillToByGroup(b))
          })
      },
      onClickDrillToNode: function(a) {
        var b = (a = a.point) && a.drillId;
        A(b) && (a.setState(""), this.drillToNode(b))
      },
      drillToByGroup: function(a) {
        var b = !1;
        1 !== a.node.level - this.nodeMap[this.rootNode].level || a.node.isLeaf || (b = a.id);
        return b
      },
      drillToByLeaf: function(a) {
        var b = !1;
        if (a.node.parent !== this.rootNode && a.node.isLeaf)
          for (a = a.node; !b;) a = this.nodeMap[a.parent], a.parent === this.rootNode && (b = a.id);
        return b
      },
      drillUp: function() {
        var a = this.nodeMap[this.rootNode];
        a && A(a.parent) && this.drillToNode(a.parent)
      },
      drillToNode: function(a, b) {
        var c = this.nodeMap[a];
        this.rootNode = a;
        "" === a ? this.drillUpButton = this.drillUpButton.destroy() : this.showDrillUpButton(c && c.name || a);
        this.isDirty = !0;
        k(b, !0) && this.chart.redraw()
      },
      showDrillUpButton: function(a) {
        var b = this;
        a = a || "\x3c Back";
        var c = b.options.drillUpButton,
          e, d;
        c.text && (a = c.text);
        this.drillUpButton ? this.drillUpButton.attr({
          text: a
        }).align() : (d = (e = c.theme) && e.states, this.drillUpButton =
          this.chart.renderer.button(a, null, null, function() {
            b.drillUp()
          }, e, d && d.hover, d && d.select).attr({
            align: c.position.align,
            zIndex: 7
          }).add().align(c.position, !1, c.relativeTo || "plotBox"))
      },
      buildKDTree: z,
      drawLegendSymbol: g.LegendSymbolMixin.drawRectangle,
      getExtremes: function() {
        r.prototype.getExtremes.call(this, this.colorValueData);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        r.prototype.getExtremes.call(this)
      },
      getExtremesFromAll: !0,
      bindAxes: function() {
        var a = {
          endOnTick: !1,
          gridLineWidth: 0,
          lineWidth: 0,
          min: 0,
          dataMin: 0,
          minPadding: 0,
          max: 100,
          dataMax: 100,
          maxPadding: 0,
          startOnTick: !1,
          title: null,
          tickPositions: []
        };
        r.prototype.bindAxes.call(this);
        g.extend(this.yAxis.options, a);
        g.extend(this.xAxis.options, a)
      }
    }, {
      getClassName: function() {
        var a = g.Point.prototype.getClassName.call(this),
          b = this.series,
          c = b.options;
        this.node.level <= b.nodeMap[b.rootNode].level ? a += " highcharts-above-level" : this.node.isLeaf || k(c.interactByLeaf, !c.allowDrillToNode) ? this.node.isLeaf || (a += " highcharts-internal-node") : a += " highcharts-internal-node-interactive";
        return a
      },
      isValid: function() {
        return F(this.value)
      },
      setState: function(a) {
        g.Point.prototype.setState.call(this, a);
        this.graphic.attr({
          zIndex: "hover" === a ? 1 : 0
        })
      },
      setVisible: l.pie.prototype.pointClass.prototype.setVisible
    })
  })(q)
});;
/*! RESOURCE: /scripts/highcharts/modules/no-data-to-display.js */
(function(d) {
  "object" === typeof module && module.exports ? module.exports = d : d(Highcharts)
})(function(d) {
  (function(c) {
    function d() {
      return !!this.points.length
    }

    function g() {
      this.hasData() ? this.hideNoData() : this.showNoData()
    }
    var h = c.seriesTypes,
      e = c.Chart.prototype,
      f = c.getOptions(),
      k = c.extend,
      l = c.each;
    k(f.lang, {
      noData: "No data to display"
    });
    f.noData = {
      position: {
        x: 0,
        y: 0,
        align: "center",
        verticalAlign: "middle"
      }
    };
    f.noData.style = {
      fontWeight: "bold",
      fontSize: "12px",
      color: "#666666"
    };
    l(["pie", "gauge", "waterfall", "bubble",
      "treemap"
    ], function(a) {
      h[a] && (h[a].prototype.hasData = d)
    });
    c.Series.prototype.hasData = function() {
      return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin
    };
    e.showNoData = function(a) {
      var b = this.options;
      a = a || b.lang.noData;
      b = b.noData;
      this.noDataLabel || (this.noDataLabel = this.renderer.label(a, 0, 0, null, null, null, b.useHTML, null, "no-data"), this.noDataLabel.attr(b.attr).css(b.style), this.noDataLabel.add(), this.noDataLabel.align(k(this.noDataLabel.getBBox(), b.position), !1, "plotBox"))
    };
    e.hideNoData = function() {
      this.noDataLabel &&
        (this.noDataLabel = this.noDataLabel.destroy())
    };
    e.hasData = function() {
      for (var a = this.series, b = a.length; b--;)
        if (a[b].hasData() && !a[b].options.isInternal) return !0;
      return !1
    };
    e.callbacks.push(function(a) {
      c.addEvent(a, "load", g);
      c.addEvent(a, "redraw", g)
    })
  })(d)
});;
/*! RESOURCE: /scripts/highcharts/proj4.js */
! function(a) {
  if ("object" == typeof exports) module.exports = a();
  else if ("function" == typeof define && define.amd) define(a);
  else {
    var b;
    "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.proj4 = a()
  }
}(function() {
  return function a(b, c, d) {
    function e(g, h) {
      if (!c[g]) {
        if (!b[g]) {
          var i = "function" == typeof require && require;
          if (!h && i) return i(g, !0);
          if (f) return f(g, !0);
          throw new Error("Cannot find module '" + g + "'")
        }
        var j = c[g] = {
          exports: {}
        };
        b[g][0].call(j.exports, function(a) {
          var c = b[g][1][a];
          return e(c ? c : a)
        }, j, j.exports, a, b, c, d)
      }
      return c[g].exports
    }
    for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
    return e
  }({
    1: [function(a, b, c) {
      function Point(a, b, c) {
        if (!(this instanceof Point)) return new Point(a, b, c);
        if (Array.isArray(a)) this.x = a[0], this.y = a[1], this.z = a[2] || 0;
        else if ("object" == typeof a) this.x = a.x, this.y = a.y, this.z = a.z || 0;
        else if ("string" == typeof a && "undefined" == typeof b) {
          var d = a.split(",");
          this.x = parseFloat(d[0], 10), this.y = parseFloat(d[1], 10), this.z = parseFloat(d[2], 10) || 0
        } else this.x = a, this.y = b, this.z = c || 0;
        console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")
      }
      var d = a("mgrs");
      Point.fromMGRS = function(a) {
        return new Point(d.toPoint(a))
      }, Point.prototype.toMGRS = function(a) {
        return d.forward([this.x, this.y], a)
      }, b.exports = Point
    }, {
      mgrs: 67
    }],
    2: [function(a, b, c) {
      function Projection(a, b) {
        if (!(this instanceof Projection)) return new Projection(a);
        b = b || function(a) {
          if (a) throw a
        };
        var c = d(a);
        if ("object" != typeof c) return void b(a);
        var f = g(c),
          h = Projection.projections.get(f.projName);
        h ? (e(this, f), e(this, h), this.init(), b(null, this)) : b(a)
      }
      var d = a("./parseCode"),
        e = a("./extend"),
        f = a("./projections"),
        g = a("./deriveConstants");
      Projection.projections = f, Projection.projections.start(), b.exports = Projection
    }, {
      "./deriveConstants": 33,
      "./extend": 34,
      "./parseCode": 37,
      "./projections": 39
    }],
    3: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d, e, f, g = c.x,
          h = c.y,
          i = c.z || 0;
        for (f = 0; 3 > f; f++)
          if (!b || 2 !== f || void 0 !== c.z) switch (0 === f ? (d = g, e = "x") : 1 === f ? (d = h, e = "y") : (d = i, e = "z"), a.axis[f]) {
            case "e":
              c[e] = d;
              break;
            case "w":
              c[e] = -d;
              break;
            case "n":
              c[e] = d;
              break;
            case "s":
              c[e] = -d;
              break;
            case "u":
              void 0 !== c[e] && (c.z = d);
              break;
            case "d":
              void 0 !== c[e] && (c.z = -d);
              break;
            default:
              return null
          }
        return c
      }
    }, {}],
    4: [function(a, b, c) {
      var d = Math.PI / 2,
        e = a("./sign");
      b.exports = function(a) {
        return Math.abs(a) < d ? a : a - e(a) * Math.PI
      }
    }, {
      "./sign": 21
    }],
    5: [function(a, b, c) {
      var d = 2 * Math.PI,
        e = 3.14159265359,
        f = a("./sign");
      b.exports = function(a) {
        return Math.abs(a) <= e ? a : a - f(a) * d
      }
    }, {
      "./sign": 21
    }],
    6: [function(a, b, c) {
      b.exports = function(a) {
        return Math.abs(a) > 1 && (a = a > 1 ? 1 : -1), Math.asin(a)
      }
    }, {}],
    7: [function(a, b, c) {
      b.exports = function(a) {
        return 1 - .25 * a * (1 + a / 16 * (3 + 1.25 * a))
      }
    }, {}],
    8: [function(a, b, c) {
      b.exports = function(a) {
        return .375 * a * (1 + .25 * a * (1 + .46875 * a))
      }
    }, {}],
    9: [function(a, b, c) {
      b.exports = function(a) {
        return .05859375 * a * a * (1 + .75 * a)
      }
    }, {}],
    10: [function(a, b, c) {
      b.exports = function(a) {
        return a * a * a * (35 / 3072)
      }
    }, {}],
    11: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d = b * c;
        return a / Math.sqrt(1 - d * d)
      }
    }, {}],
    12: [function(a, b, c) {
      b.exports = function(a, b, c, d, e) {
        var f, g;
        f = a / b;
        for (var h = 0; 15 > h; h++)
          if (g = (a - (b * f - c * Math.sin(2 * f) + d * Math.sin(4 * f) - e * Math.sin(6 * f))) / (b - 2 * c * Math.cos(2 * f) + 4 * d * Math.cos(4 * f) - 6 * e * Math.cos(6 * f)), f += g, Math.abs(g) <= 1e-10) return f;
        return NaN
      }
    }, {}],
    13: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b) {
        var c = 1 - (1 - a * a) / (2 * a) * Math.log((1 - a) / (1 + a));
        if (Math.abs(Math.abs(b) - c) < 1e-6) return 0 > b ? -1 * d : d;
        for (var e, f, g, h, i = Math.asin(.5 * b), j = 0; 30 > j; j++)
          if (f = Math.sin(i), g = Math.cos(i), h = a * f, e = Math.pow(1 - h * h, 2) / (2 * g) * (b / (1 - a * a) - f / (1 - h * h) + .5 / a * Math.log((1 - h) / (1 + h))), i += e, Math.abs(e) <= 1e-10) return i;
        return NaN
      }
    }, {}],
    14: [function(a, b, c) {
      b.exports = function(a, b, c, d, e) {
        return a * e - b * Math.sin(2 * e) + c * Math.sin(4 * e) - d * Math.sin(6 * e)
      }
    }, {}],
    15: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d = a * b;
        return c / Math.sqrt(1 - d * d)
      }
    }, {}],
    16: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b) {
        for (var c, e, f = .5 * a, g = d - 2 * Math.atan(b), h = 0; 15 >= h; h++)
          if (c = a * Math.sin(g), e = d - 2 * Math.atan(b * Math.pow((1 - c) / (1 + c), f)) - g, g += e, Math.abs(e) <= 1e-10) return g;
        return -9999
      }
    }, {}],
    17: [function(a, b, c) {
      var d = 1,
        e = .25,
        f = .046875,
        g = .01953125,
        h = .01068115234375,
        i = .75,
        j = .46875,
        k = .013020833333333334,
        l = .007120768229166667,
        m = .3645833333333333,
        n = .005696614583333333,
        o = .3076171875;
      b.exports = function(a) {
        var b = [];
        b[0] = d - a * (e + a * (f + a * (g + a * h))), b[1] = a * (i - a * (f + a * (g + a * h)));
        var c = a * a;
        return b[2] = c * (j - a * (k + a * l)), c *= a, b[3] = c * (m - a * n), b[4] = c * a * o, b
      }
    }, {}],
    18: [function(a, b, c) {
      var d = a("./pj_mlfn"),
        e = 1e-10,
        f = 20;
      b.exports = function(a, b, c) {
        for (var g = 1 / (1 - b), h = a, i = f; i; --i) {
          var j = Math.sin(h),
            k = 1 - b * j * j;
          if (k = (d(h, j, Math.cos(h), c) - a) * (k * Math.sqrt(k)) * g, h -= k, Math.abs(k) < e) return h
        }
        return h
      }
    }, {
      "./pj_mlfn": 19
    }],
    19: [function(a, b, c) {
      b.exports = function(a, b, c, d) {
        return c *= b, b *= b, d[0] * a - c * (d[1] + b * (d[2] + b * (d[3] + b * d[4])))
      }
    }, {}],
    20: [function(a, b, c) {
      b.exports = function(a, b) {
        var c;
        return a > 1e-7 ? (c = a * b, (1 - a * a) * (b / (1 - c * c) - .5 / a * Math.log((1 - c) / (1 + c)))) : 2 * b
      }
    }, {}],
    21: [function(a, b, c) {
      b.exports = function(a) {
        return 0 > a ? -1 : 1
      }
    }, {}],
    22: [function(a, b, c) {
      b.exports = function(a, b) {
        return Math.pow((1 - a) / (1 + a), b)
      }
    }, {}],
    23: [function(a, b, c) {
      b.exports = function(a) {
        var b = {
          x: a[0],
          y: a[1]
        };
        return a.length > 2 && (b.z = a[2]), a.length > 3 && (b.m = a[3]), b
      }
    }, {}],
    24: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b, c) {
        var e = a * c,
          f = .5 * a;
        return e = Math.pow((1 - e) / (1 + e), f), Math.tan(.5 * (d - b)) / e
      }
    }, {}],
    25: [function(a, b, c) {
      c.wgs84 = {
        towgs84: "0,0,0",
        ellipse: "WGS84",
        datumName: "WGS84"
      }, c.ch1903 = {
        towgs84: "674.374,15.056,405.346",
        ellipse: "bessel",
        datumName: "swiss"
      }, c.ggrs87 = {
        towgs84: "-199.87,74.79,246.62",
        ellipse: "GRS80",
        datumName: "Greek_Geodetic_Reference_System_1987"
      }, c.nad83 = {
        towgs84: "0,0,0",
        ellipse: "GRS80",
        datumName: "North_American_Datum_1983"
      }, c.nad27 = {
        nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
        ellipse: "clrk66",
        datumName: "North_American_Datum_1927"
      }, c.potsdam = {
        towgs84: "606.0,23.0,413.0",
        ellipse: "bessel",
        datumName: "Potsdam Rauenberg 1950 DHDN"
      }, c.carthage = {
        towgs84: "-263.0,6.0,431.0",
        ellipse: "clark80",
        datumName: "Carthage 1934 Tunisia"
      }, c.hermannskogel = {
        towgs84: "653.0,-212.0,449.0",
        ellipse: "bessel",
        datumName: "Hermannskogel"
      }, c.ire65 = {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "mod_airy",
        datumName: "Ireland 1965"
      }, c.rassadiran = {
        towgs84: "-133.63,-157.5,-158.62",
        ellipse: "intl",
        datumName: "Rassadiran"
      }, c.nzgd49 = {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
        ellipse: "intl",
        datumName: "New Zealand Geodetic Datum 1949"
      }, c.osgb36 = {
        towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
        ellipse: "airy",
        datumName: "Airy 1830"
      }, c.s_jtsk = {
        towgs84: "589,76,480",
        ellipse: "bessel",
        datumName: "S-JTSK (Ferro)"
      }, c.beduaram = {
        towgs84: "-106,-87,188",
        ellipse: "clrk80",
        datumName: "Beduaram"
      }, c.gunung_segara = {
        towgs84: "-403,684,41",
        ellipse: "bessel",
        datumName: "Gunung Segara Jakarta"
      }, c.rnb72 = {
        towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
        ellipse: "intl",
        datumName: "Reseau National Belge 1972"
      }
    }, {}],
    26: [function(a, b, c) {
      c.MERIT = {
        a: 6378137,
        rf: 298.257,
        ellipseName: "MERIT 1983"
      }, c.SGS85 = {
        a: 6378136,
        rf: 298.257,
        ellipseName: "Soviet Geodetic System 85"
      }, c.GRS80 = {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: "GRS 1980(IUGG, 1980)"
      }, c.IAU76 = {
        a: 6378140,
        rf: 298.257,
        ellipseName: "IAU 1976"
      }, c.airy = {
        a: 6377563.396,
        b: 6356256.91,
        ellipseName: "Airy 1830"
      }, c.APL4 = {
        a: 6378137,
        rf: 298.25,
        ellipseName: "Appl. Physics. 1965"
      }, c.NWL9D = {
        a: 6378145,
        rf: 298.25,
        ellipseName: "Naval Weapons Lab., 1965"
      }, c.mod_airy = {
        a: 6377340.189,
        b: 6356034.446,
        ellipseName: "Modified Airy"
      }, c.andrae = {
        a: 6377104.43,
        rf: 300,
        ellipseName: "Andrae 1876 (Den., Iclnd.)"
      }, c.aust_SA = {
        a: 6378160,
        rf: 298.25,
        ellipseName: "Australian Natl & S. Amer. 1969"
      }, c.GRS67 = {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: "GRS 67(IUGG 1967)"
      }, c.bessel = {
        a: 6377397.155,
        rf: 299.1528128,
        ellipseName: "Bessel 1841"
      }, c.bess_nam = {
        a: 6377483.865,
        rf: 299.1528128,
        ellipseName: "Bessel 1841 (Namibia)"
      }, c.clrk66 = {
        a: 6378206.4,
        b: 6356583.8,
        ellipseName: "Clarke 1866"
      }, c.clrk80 = {
        a: 6378249.145,
        rf: 293.4663,
        ellipseName: "Clarke 1880 mod."
      }, c.clrk58 = {
        a: 6378293.645208759,
        rf: 294.2606763692654,
        ellipseName: "Clarke 1858"
      }, c.CPM = {
        a: 6375738.7,
        rf: 334.29,
        ellipseName: "Comm. des Poids et Mesures 1799"
      }, c.delmbr = {
        a: 6376428,
        rf: 311.5,
        ellipseName: "Delambre 1810 (Belgium)"
      }, c.engelis = {
        a: 6378136.05,
        rf: 298.2566,
        ellipseName: "Engelis 1985"
      }, c.evrst30 = {
        a: 6377276.345,
        rf: 300.8017,
        ellipseName: "Everest 1830"
      }, c.evrst48 = {
        a: 6377304.063,
        rf: 300.8017,
        ellipseName: "Everest 1948"
      }, c.evrst56 = {
        a: 6377301.243,
        rf: 300.8017,
        ellipseName: "Everest 1956"
      }, c.evrst69 = {
        a: 6377295.664,
        rf: 300.8017,
        ellipseName: "Everest 1969"
      }, c.evrstSS = {
        a: 6377298.556,
        rf: 300.8017,
        ellipseName: "Everest (Sabah & Sarawak)"
      }, c.fschr60 = {
        a: 6378166,
        rf: 298.3,
        ellipseName: "Fischer (Mercury Datum) 1960"
      }, c.fschr60m = {
        a: 6378155,
        rf: 298.3,
        ellipseName: "Fischer 1960"
      }, c.fschr68 = {
        a: 6378150,
        rf: 298.3,
        ellipseName: "Fischer 1968"
      }, c.helmert = {
        a: 6378200,
        rf: 298.3,
        ellipseName: "Helmert 1906"
      }, c.hough = {
        a: 6378270,
        rf: 297,
        ellipseName: "Hough"
      }, c.intl = {
        a: 6378388,
        rf: 297,
        ellipseName: "International 1909 (Hayford)"
      }, c.kaula = {
        a: 6378163,
        rf: 298.24,
        ellipseName: "Kaula 1961"
      }, c.lerch = {
        a: 6378139,
        rf: 298.257,
        ellipseName: "Lerch 1979"
      }, c.mprts = {
        a: 6397300,
        rf: 191,
        ellipseName: "Maupertius 1738"
      }, c.new_intl = {
        a: 6378157.5,
        b: 6356772.2,
        ellipseName: "New International 1967"
      }, c.plessis = {
        a: 6376523,
        rf: 6355863,
        ellipseName: "Plessis 1817 (France)"
      }, c.krass = {
        a: 6378245,
        rf: 298.3,
        ellipseName: "Krassovsky, 1942"
      }, c.SEasia = {
        a: 6378155,
        b: 6356773.3205,
        ellipseName: "Southeast Asia"
      }, c.walbeck = {
        a: 6376896,
        b: 6355834.8467,
        ellipseName: "Walbeck"
      }, c.WGS60 = {
        a: 6378165,
        rf: 298.3,
        ellipseName: "WGS 60"
      }, c.WGS66 = {
        a: 6378145,
        rf: 298.25,
        ellipseName: "WGS 66"
      }, c.WGS7 = {
        a: 6378135,
        rf: 298.26,
        ellipseName: "WGS 72"
      }, c.WGS84 = {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
      }, c.sphere = {
        a: 6370997,
        b: 6370997,
        ellipseName: "Normal Sphere (r=6370997)"
      }
    }, {}],
    27: [function(a, b, c) {
      c.greenwich = 0, c.lisbon = -9.131906111111, c.paris = 2.337229166667, c.bogota = -74.080916666667, c.madrid = -3.687938888889, c.rome = 12.452333333333, c.bern = 7.439583333333, c.jakarta = 106.807719444444, c.ferro = -17.666666666667, c.brussels = 4.367975, c.stockholm = 18.058277777778, c.athens = 23.7163375, c.oslo = 10.722916666667
    }, {}],
    28: [function(a, b, c) {
      c.ft = {
        to_meter: .3048
      }, c["us-ft"] = {
        to_meter: 1200 / 3937
      }
    }, {}],
    29: [function(a, b, c) {
      function d(a, b, c) {
        var d;
        return Array.isArray(c) ? (d = g(a, b, c), 3 === c.length ? [d.x, d.y, d.z] : [d.x, d.y]) : g(a, b, c)
      }

      function e(a) {
        return a instanceof f ? a : a.oProj ? a.oProj : f(a)
      }

      function proj4(a, b, c) {
        a = e(a);
        var f, g = !1;
        return "undefined" == typeof b ? (b = a, a = h, g = !0) : ("undefined" != typeof b.x || Array.isArray(b)) && (c = b, b = a, a = h, g = !0), b = e(b), c ? d(a, b, c) : (f = {
          forward: function(c) {
            return d(a, b, c)
          },
          inverse: function(c) {
            return d(b, a, c)
          }
        }, g && (f.oProj = b), f)
      }
      var f = a("./Proj"),
        g = a("./transform"),
        h = f("WGS84");
      b.exports = proj4
    }, {
      "./Proj": 2,
      "./transform": 65
    }],
    30: [function(a, b, c) {
      var d = Math.PI / 2,
        e = 1,
        f = 2,
        g = 3,
        h = 4,
        i = 5,
        j = 484813681109536e-20,
        k = 1.0026,
        l = .3826834323650898,
        m = function(a) {
          return this instanceof m ? (this.datum_type = h, void(a && (a.datumCode && "none" === a.datumCode && (this.datum_type = i), a.datum_params && (this.datum_params = a.datum_params.map(parseFloat), (0 !== this.datum_params[0] || 0 !== this.datum_params[1] || 0 !== this.datum_params[2]) && (this.datum_type = e), this.datum_params.length > 3 && (0 !== this.datum_params[3] || 0 !== this.datum_params[4] || 0 !== this.datum_params[5] || 0 !== this.datum_params[6]) && (this.datum_type = f, this.datum_params[3] *= j, this.datum_params[4] *= j, this.datum_params[5] *= j, this.datum_params[6] = this.datum_params[6] / 1e6 + 1)), this.datum_type = a.grids ? g : this.datum_type, this.a = a.a, this.b = a.b, this.es = a.es, this.ep2 = a.ep2, this.datum_type === g && (this.grids = a.grids)))) : new m(a)
        };
      m.prototype = {
        compare_datums: function(a) {
          return this.datum_type !== a.datum_type ? !1 : this.a !== a.a || Math.abs(this.es - a.es) > 5e-11 ? !1 : this.datum_type === e ? this.datum_params[0] === a.datum_params[0] && this.datum_params[1] === a.datum_params[1] && this.datum_params[2] === a.datum_params[2] : this.datum_type === f ? this.datum_params[0] === a.datum_params[0] && this.datum_params[1] === a.datum_params[1] && this.datum_params[2] === a.datum_params[2] && this.datum_params[3] === a.datum_params[3] && this.datum_params[4] === a.datum_params[4] && this.datum_params[5] === a.datum_params[5] && this.datum_params[6] === a.datum_params[6] : this.datum_type === g || a.datum_type === g ? this.nadgrids === a.nadgrids : !0
        },
        geodetic_to_geocentric: function(a) {
          var b, c, e, f, g, h, i, j = a.x,
            k = a.y,
            l = a.z ? a.z : 0,
            m = 0;
          if (-d > k && k > -1.001 * d) k = -d;
          else if (k > d && 1.001 * d > k) k = d;
          else if (-d > k || k > d) return null;
          return j > Math.PI && (j -= 2 * Math.PI), g = Math.sin(k), i = Math.cos(k), h = g * g, f = this.a / Math.sqrt(1 - this.es * h), b = (f + l) * i * Math.cos(j), c = (f + l) * i * Math.sin(j), e = (f * (1 - this.es) + l) * g, a.x = b, a.y = c, a.z = e, m
        },
        geocentric_to_geodetic: function(a) {
          var b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = 1e-12,
            u = t * t,
            v = 30,
            w = a.x,
            x = a.y,
            y = a.z ? a.z : 0;
          if (o = !1, b = Math.sqrt(w * w + x * x), c = Math.sqrt(w * w + x * x + y * y), b / this.a < t) {
            if (o = !0, q = 0, c / this.a < t) return r = d, void(s = -this.b)
          } else q = Math.atan2(x, w);
          e = y / c, f = b / c, g = 1 / Math.sqrt(1 - this.es * (2 - this.es) * f * f), j = f * (1 - this.es) * g, k = e * g, p = 0;
          do p++, i = this.a / Math.sqrt(1 - this.es * k * k), s = b * j + y * k - i * (1 - this.es * k * k), h = this.es * i / (i + s), g = 1 / Math.sqrt(1 - h * (2 - h) * f * f), l = f * (1 - h) * g, m = e * g, n = m * j - l * k, j = l, k = m; while (n * n > u && v > p);
          return r = Math.atan(m / Math.abs(l)), a.x = q, a.y = r, a.z = s, a
        },
        geocentric_to_geodetic_noniter: function(a) {
          var b, c, e, f, g, h, i, j, m, n, o, p, q, r, s, t, u, v = a.x,
            w = a.y,
            x = a.z ? a.z : 0;
          if (v = parseFloat(v), w = parseFloat(w), x = parseFloat(x), u = !1, 0 !== v) b = Math.atan2(w, v);
          else if (w > 0) b = d;
          else if (0 > w) b = -d;
          else if (u = !0, b = 0, x > 0) c = d;
          else {
            if (!(0 > x)) return c = d, void(e = -this.b);
            c = -d
          }
          return g = v * v + w * w, f = Math.sqrt(g), h = x * k, j = Math.sqrt(h * h + g), n = h / j, p = f / j, o = n * n * n, i = x + this.b * this.ep2 * o, t = f - this.a * this.es * p * p * p, m = Math.sqrt(i * i + t * t), q = i / m, r = t / m, s = this.a / Math.sqrt(1 - this.es * q * q), e = r >= l ? f / r - s : -l >= r ? f / -r - s : x / q + s * (this.es - 1), u === !1 && (c = Math.atan(q / r)), a.x = b, a.y = c, a.z = e, a
        },
        geocentric_to_wgs84: function(a) {
          if (this.datum_type === e) a.x += this.datum_params[0], a.y += this.datum_params[1], a.z += this.datum_params[2];
          else if (this.datum_type === f) {
            var b = this.datum_params[0],
              c = this.datum_params[1],
              d = this.datum_params[2],
              g = this.datum_params[3],
              h = this.datum_params[4],
              i = this.datum_params[5],
              j = this.datum_params[6],
              k = j * (a.x - i * a.y + h * a.z) + b,
              l = j * (i * a.x + a.y - g * a.z) + c,
              m = j * (-h * a.x + g * a.y + a.z) + d;
            a.x = k, a.y = l, a.z = m
          }
        },
        geocentric_from_wgs84: function(a) {
          if (this.datum_type === e) a.x -= this.datum_params[0], a.y -= this.datum_params[1], a.z -= this.datum_params[2];
          else if (this.datum_type === f) {
            var b = this.datum_params[0],
              c = this.datum_params[1],
              d = this.datum_params[2],
              g = this.datum_params[3],
              h = this.datum_params[4],
              i = this.datum_params[5],
              j = this.datum_params[6],
              k = (a.x - b) / j,
              l = (a.y - c) / j,
              m = (a.z - d) / j;
            a.x = k + i * l - h * m, a.y = -i * k + l + g * m, a.z = h * k - g * l + m
          }
        }
      }, b.exports = m
    }, {}],
    31: [function(a, b, c) {
      var d = 1,
        e = 2,
        f = 3,
        g = 5,
        h = 6378137,
        i = .006694379990141316;
      b.exports = function(a, b, c) {
        function j(a) {
          return a === d || a === e
        }
        var k, l, m;
        if (a.compare_datums(b)) return c;
        if (a.datum_type === g || b.datum_type === g) return c;
        var n = a.a,
          o = a.es,
          p = b.a,
          q = b.es,
          r = a.datum_type;
        if (r === f)
          if (0 === this.apply_gridshift(a, 0, c)) a.a = h, a.es = i;
          else {
            if (!a.datum_params) return a.a = n, a.es = a.es, c;
            for (k = 1, l = 0, m = a.datum_params.length; m > l; l++) k *= a.datum_params[l];
            if (0 === k) return a.a = n, a.es = a.es, c;
            r = a.datum_params.length > 3 ? e : d
          } return b.datum_type === f && (b.a = h, b.es = i), (a.es !== b.es || a.a !== b.a || j(r) || j(b.datum_type)) && (a.geodetic_to_geocentric(c), j(a.datum_type) && a.geocentric_to_wgs84(c), j(b.datum_type) && b.geocentric_from_wgs84(c), b.geocentric_to_geodetic(c)), b.datum_type === f && this.apply_gridshift(b, 1, c), a.a = n, a.es = o, b.a = p, b.es = q, c
      }
    }, {}],
    32: [function(a, b, c) {
      function d(a) {
        var b = this;
        if (2 === arguments.length) {
          var c = arguments[1];
          "string" == typeof c ? "+" === c.charAt(0) ? d[a] = f(arguments[1]) : d[a] = g(arguments[1]) : d[a] = c
        } else if (1 === arguments.length) {
          if (Array.isArray(a)) return a.map(function(a) {
            Array.isArray(a) ? d.apply(b, a) : d(a)
          });
          if ("string" == typeof a) {
            if (a in d) return d[a]
          } else "EPSG" in a ? d["EPSG:" + a.EPSG] = a : "ESRI" in a ? d["ESRI:" + a.ESRI] = a : "IAU2000" in a ? d["IAU2000:" + a.IAU2000] = a : console.log(a);
          return
        }
      }
      var e = a("./global"),
        f = a("./projString"),
        g = a("./wkt");
      e(d), b.exports = d
    }, {
      "./global": 35,
      "./projString": 38,
      "./wkt": 66
    }],
    33: [function(a, b, c) {
      var d = a("./constants/Datum"),
        e = a("./constants/Ellipsoid"),
        f = a("./extend"),
        g = a("./datum"),
        h = 1e-10,
        i = .16666666666666666,
        j = .04722222222222222,
        k = .022156084656084655;
      b.exports = function(a) {
        if (a.datumCode && "none" !== a.datumCode) {
          var b = d[a.datumCode];
          b && (a.datum_params = b.towgs84 ? b.towgs84.split(",") : null, a.ellps = b.ellipse, a.datumName = b.datumName ? b.datumName : a.datumCode)
        }
        if (!a.a) {
          var c = e[a.ellps] ? e[a.ellps] : e.WGS84;
          f(a, c)
        }
        return a.rf && !a.b && (a.b = (1 - 1 / a.rf) * a.a), (0 === a.rf || Math.abs(a.a - a.b) < h) && (a.sphere = !0, a.b = a.a), a.a2 = a.a * a.a, a.b2 = a.b * a.b, a.es = (a.a2 - a.b2) / a.a2, a.e = Math.sqrt(a.es), a.R_A && (a.a *= 1 - a.es * (i + a.es * (j + a.es * k)), a.a2 = a.a * a.a, a.b2 = a.b * a.b, a.es = 0), a.ep2 = (a.a2 - a.b2) / a.b2, a.k0 || (a.k0 = 1), a.axis || (a.axis = "enu"), a.datum || (a.datum = g(a)), a
      }
    }, {
      "./constants/Datum": 25,
      "./constants/Ellipsoid": 26,
      "./datum": 30,
      "./extend": 34
    }],
    34: [function(a, b, c) {
      b.exports = function(a, b) {
        a = a || {};
        var c, d;
        if (!b) return a;
        for (d in b) c = b[d], void 0 !== c && (a[d] = c);
        return a
      }
    }, {}],
    35: [function(a, b, c) {
      b.exports = function(a) {
        a("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), a("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), a("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), a.WGS84 = a["EPSG:4326"], a["EPSG:3785"] = a["EPSG:3857"], a.GOOGLE = a["EPSG:3857"], a["EPSG:900913"] = a["EPSG:3857"], a["EPSG:102113"] = a["EPSG:3857"]
      }
    }, {}],
    36: [function(a, b, c) {
      var proj4 = a("./core");
      proj4.defaultDatum = "WGS84", proj4.Proj = a("./Proj"), proj4.WGS84 = new proj4.Proj("WGS84"), proj4.Point = a("./Point"), proj4.toPoint = a("./common/toPoint"), proj4.defs = a("./defs"), proj4.transform = a("./transform"), proj4.mgrs = a("mgrs"), proj4.version = a("../package.json").version, a("./includedProjections")(proj4), b.exports = proj4
    }, {
      "../package.json": 68,
      "./Point": 1,
      "./Proj": 2,
      "./common/toPoint": 23,
      "./core": 29,
      "./defs": 32,
      "./includedProjections": "hTEDpn",
      "./transform": 65,
      mgrs: 67
    }],
    37: [function(a, b, c) {
      function d(a) {
        return "string" == typeof a
      }

      function e(a) {
        return a in i
      }

      function f(a) {
        var b = ["GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS"];
        return b.reduce(function(b, c) {
          return b + 1 + a.indexOf(c)
        }, 0)
      }

      function g(a) {
        return "+" === a[0]
      }

      function h(a) {
        return d(a) ? e(a) ? i[a] : f(a) ? j(a) : g(a) ? k(a) : void 0 : a
      }
      var i = a("./defs"),
        j = a("./wkt"),
        k = a("./projString");
      b.exports = h
    }, {
      "./defs": 32,
      "./projString": 38,
      "./wkt": 66
    }],
    38: [function(a, b, c) {
      var d = .017453292519943295,
        e = a("./constants/PrimeMeridian"),
        f = a("./constants/units");
      b.exports = function(a) {
        var b = {},
          c = {};
        a.split("+").map(function(a) {
          return a.trim()
        }).filter(function(a) {
          return a
        }).forEach(function(a) {
          var b = a.split("=");
          b.push(!0), c[b[0].toLowerCase()] = b[1]
        });
        var g, h, i, j = {
          proj: "projName",
          datum: "datumCode",
          rf: function(a) {
            b.rf = parseFloat(a)
          },
          lat_0: function(a) {
            b.lat0 = a * d
          },
          lat_1: function(a) {
            b.lat1 = a * d
          },
          lat_2: function(a) {
            b.lat2 = a * d
          },
          lat_ts: function(a) {
            b.lat_ts = a * d
          },
          lon_0: function(a) {
            b.long0 = a * d
          },
          lon_1: function(a) {
            b.long1 = a * d
          },
          lon_2: function(a) {
            b.long2 = a * d
          },
          alpha: function(a) {
            b.alpha = parseFloat(a) * d
          },
          lonc: function(a) {
            b.longc = a * d
          },
          x_0: function(a) {
            b.x0 = parseFloat(a)
          },
          y_0: function(a) {
            b.y0 = parseFloat(a)
          },
          k_0: function(a) {
            b.k0 = parseFloat(a)
          },
          k: function(a) {
            b.k0 = parseFloat(a)
          },
          a: function(a) {
            b.a = parseFloat(a)
          },
          b: function(a) {
            b.b = parseFloat(a)
          },
          r_a: function() {
            b.R_A = !0
          },
          zone: function(a) {
            b.zone = parseInt(a, 10)
          },
          south: function() {
            b.utmSouth = !0
          },
          towgs84: function(a) {
            b.datum_params = a.split(",").map(function(a) {
              return parseFloat(a)
            })
          },
          to_meter: function(a) {
            b.to_meter = parseFloat(a)
          },
          units: function(a) {
            b.units = a, f[a] && (b.to_meter = f[a].to_meter)
          },
          from_greenwich: function(a) {
            b.from_greenwich = a * d
          },
          pm: function(a) {
            b.from_greenwich = (e[a] ? e[a] : parseFloat(a)) * d
          },
          nadgrids: function(a) {
            "@null" === a ? b.datumCode = "none" : b.nadgrids = a
          },
          axis: function(a) {
            var c = "ewnsud";
            3 === a.length && -1 !== c.indexOf(a.substr(0, 1)) && -1 !== c.indexOf(a.substr(1, 1)) && -1 !== c.indexOf(a.substr(2, 1)) && (b.axis = a)
          }
        };
        for (g in c) h = c[g], g in j ? (i = j[g], "function" == typeof i ? i(h) : b[i] = h) : b[g] = h;
        return "string" == typeof b.datumCode && "WGS84" !== b.datumCode && (b.datumCode = b.datumCode.toLowerCase()), b
      }
    }, {
      "./constants/PrimeMeridian": 27,
      "./constants/units": 28
    }],
    39: [function(a, b, c) {
      function d(a, b) {
        var c = g.length;
        return a.names ? (g[c] = a, a.names.forEach(function(a) {
          f[a.toLowerCase()] = c
        }), this) : (console.log(b), !0)
      }
      var e = [a("./projections/merc"), a("./projections/longlat")],
        f = {},
        g = [];
      c.add = d, c.get = function(a) {
        if (!a) return !1;
        var b = a.toLowerCase();
        return "undefined" != typeof f[b] && g[f[b]] ? g[f[b]] : void 0
      }, c.start = function() {
        e.forEach(d)
      }
    }, {
      "./projections/longlat": 51,
      "./projections/merc": 52
    }],
    40: [function(a, b, c) {
      var d = 1e-10,
        e = a("../common/msfnz"),
        f = a("../common/qsfnz"),
        g = a("../common/adjust_lon"),
        h = a("../common/asinz");
      c.init = function() {
        Math.abs(this.lat1 + this.lat2) < d || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = e(this.e3, this.sin_po, this.cos_po), this.qs1 = f(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = e(this.e3, this.sin_po, this.cos_po), this.qs2 = f(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = f(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > d ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        this.sin_phi = Math.sin(c), this.cos_phi = Math.cos(c);
        var d = f(this.e3, this.sin_phi, this.cos_phi),
          e = this.a * Math.sqrt(this.c - this.ns0 * d) / this.ns0,
          h = this.ns0 * g(b - this.long0),
          i = e * Math.sin(h) + this.x0,
          j = this.rh - e * Math.cos(h) + this.y0;
        return a.x = i, a.y = j, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, h;
        return a.x -= this.x0, a.y = this.rh - a.y + this.y0, this.ns0 >= 0 ? (b = Math.sqrt(a.x * a.x + a.y * a.y), d = 1) : (b = -Math.sqrt(a.x * a.x + a.y * a.y), d = -1), e = 0, 0 !== b && (e = Math.atan2(d * a.x, d * a.y)), d = b * this.ns0 / this.a, this.sphere ? h = Math.asin((this.c - d * d) / (2 * this.ns0)) : (c = (this.c - d * d) / this.ns0, h = this.phi1z(this.e3, c)), f = g(e / this.ns0 + this.long0), a.x = f, a.y = h, a
      }, c.phi1z = function(a, b) {
        var c, e, f, g, i, j = h(.5 * b);
        if (d > a) return j;
        for (var k = a * a, l = 1; 25 >= l; l++)
          if (c = Math.sin(j), e = Math.cos(j), f = a * c, g = 1 - f * f, i = .5 * g * g / e * (b / (1 - k) - c / g + .5 / a * Math.log((1 - f) / (1 + f))), j += i, Math.abs(i) <= 1e-7) return j;
        return null
      }, c.names = ["Albers_Conic_Equal_Area", "Albers", "aea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/msfnz": 15,
      "../common/qsfnz": 20
    }],
    41: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = Math.PI / 2,
        f = 1e-10,
        g = a("../common/mlfn"),
        h = a("../common/e0fn"),
        i = a("../common/e1fn"),
        j = a("../common/e2fn"),
        k = a("../common/e3fn"),
        l = a("../common/gN"),
        m = a("../common/asinz"),
        n = a("../common/imlfn");
      c.init = function() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0)
      }, c.forward = function(a) {
        var b, c, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H = a.x,
          I = a.y,
          J = Math.sin(a.y),
          K = Math.cos(a.y),
          L = d(H - this.long0);
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= f ? (a.x = this.x0 + this.a * (e - I) * Math.sin(L), a.y = this.y0 - this.a * (e - I) * Math.cos(L), a) : Math.abs(this.sin_p12 + 1) <= f ? (a.x = this.x0 + this.a * (e + I) * Math.sin(L), a.y = this.y0 + this.a * (e + I) * Math.cos(L), a) : (B = this.sin_p12 * J + this.cos_p12 * K * Math.cos(L), z = Math.acos(B), A = z / Math.sin(z), a.x = this.x0 + this.a * A * K * Math.sin(L), a.y = this.y0 + this.a * A * (this.cos_p12 * J - this.sin_p12 * K * Math.cos(L)), a) : (b = h(this.es), c = i(this.es), m = j(this.es), n = k(this.es), Math.abs(this.sin_p12 - 1) <= f ? (o = this.a * g(b, c, m, n, e), p = this.a * g(b, c, m, n, I), a.x = this.x0 + (o - p) * Math.sin(L), a.y = this.y0 - (o - p) * Math.cos(L), a) : Math.abs(this.sin_p12 + 1) <= f ? (o = this.a * g(b, c, m, n, e), p = this.a * g(b, c, m, n, I), a.x = this.x0 + (o + p) * Math.sin(L), a.y = this.y0 + (o + p) * Math.cos(L), a) : (q = J / K, r = l(this.a, this.e, this.sin_p12), s = l(this.a, this.e, J), t = Math.atan((1 - this.es) * q + this.es * r * this.sin_p12 / (s * K)), u = Math.atan2(Math.sin(L), this.cos_p12 * Math.tan(t) - this.sin_p12 * Math.cos(L)), C = 0 === u ? Math.asin(this.cos_p12 * Math.sin(t) - this.sin_p12 * Math.cos(t)) : Math.abs(Math.abs(u) - Math.PI) <= f ? -Math.asin(this.cos_p12 * Math.sin(t) - this.sin_p12 * Math.cos(t)) : Math.asin(Math.sin(L) * Math.cos(t) / Math.sin(u)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), w = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es), x = v * w, y = w * w, D = C * C, E = D * C, F = E * C, G = F * C, z = r * C * (1 - D * y * (1 - y) / 6 + E / 8 * x * (1 - 2 * y) + F / 120 * (y * (4 - 7 * y) - 3 * v * v * (1 - 7 * y)) - G / 48 * x), a.x = this.x0 + z * Math.sin(u), a.y = this.y0 + z * Math.cos(u), a))
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I;
        if (this.sphere) {
          if (b = Math.sqrt(a.x * a.x + a.y * a.y), b > 2 * e * this.a) return;
          return c = b / this.a, o = Math.sin(c), p = Math.cos(c), q = this.long0, Math.abs(b) <= f ? r = this.lat0 : (r = m(p * this.sin_p12 + a.y * o * this.cos_p12 / b), s = Math.abs(this.lat0) - e, q = d(Math.abs(s) <= f ? this.lat0 >= 0 ? this.long0 + Math.atan2(a.x, -a.y) : this.long0 - Math.atan2(-a.x, a.y) : this.long0 + Math.atan2(a.x * o, b * this.cos_p12 * p - a.y * this.sin_p12 * o))), a.x = q, a.y = r, a
        }
        return t = h(this.es), u = i(this.es), v = j(this.es), w = k(this.es), Math.abs(this.sin_p12 - 1) <= f ? (x = this.a * g(t, u, v, w, e), b = Math.sqrt(a.x * a.x + a.y * a.y), y = x - b, r = n(y / this.a, t, u, v, w), q = d(this.long0 + Math.atan2(a.x, -1 * a.y)), a.x = q, a.y = r, a) : Math.abs(this.sin_p12 + 1) <= f ? (x = this.a * g(t, u, v, w, e), b = Math.sqrt(a.x * a.x + a.y * a.y), y = b - x, r = n(y / this.a, t, u, v, w), q = d(this.long0 + Math.atan2(a.x, a.y)), a.x = q, a.y = r, a) : (b = Math.sqrt(a.x * a.x + a.y * a.y), B = Math.atan2(a.x, a.y), z = l(this.a, this.e, this.sin_p12), C = Math.cos(B), D = this.e * this.cos_p12 * C, E = -D * D / (1 - this.es), F = 3 * this.es * (1 - E) * this.sin_p12 * this.cos_p12 * C / (1 - this.es), G = b / z, H = G - E * (1 + E) * Math.pow(G, 3) / 6 - F * (1 + 3 * E) * Math.pow(G, 4) / 24, I = 1 - E * H * H / 2 - G * H * H * H / 6, A = Math.asin(this.sin_p12 * Math.cos(H) + this.cos_p12 * Math.sin(H) * C), q = d(this.long0 + Math.asin(Math.sin(B) * Math.sin(H) / Math.cos(A))), r = Math.atan((1 - this.es * I * this.sin_p12 / Math.sin(A)) * Math.tan(A) / (1 - this.es)), a.x = q, a.y = r, a)
      }, c.names = ["Azimuthal_Equidistant", "aeqd"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/imlfn": 12,
      "../common/mlfn": 14
    }],
    42: [function(a, b, c) {
      var d = a("../common/mlfn"),
        e = a("../common/e0fn"),
        f = a("../common/e1fn"),
        g = a("../common/e2fn"),
        h = a("../common/e3fn"),
        i = a("../common/gN"),
        j = a("../common/adjust_lon"),
        k = a("../common/adjust_lat"),
        l = a("../common/imlfn"),
        m = Math.PI / 2,
        n = 1e-10;
      c.init = function() {
        this.sphere || (this.e0 = e(this.es), this.e1 = f(this.es), this.e2 = g(this.es), this.e3 = h(this.es), this.ml0 = this.a * d(this.e0, this.e1, this.e2, this.e3, this.lat0))
      }, c.forward = function(a) {
        var b, c, e = a.x,
          f = a.y;
        if (e = j(e - this.long0), this.sphere) b = this.a * Math.asin(Math.cos(f) * Math.sin(e)), c = this.a * (Math.atan2(Math.tan(f), Math.cos(e)) - this.lat0);
        else {
          var g = Math.sin(f),
            h = Math.cos(f),
            k = i(this.a, this.e, g),
            l = Math.tan(f) * Math.tan(f),
            m = e * Math.cos(f),
            n = m * m,
            o = this.es * h * h / (1 - this.es),
            p = this.a * d(this.e0, this.e1, this.e2, this.e3, f);
          b = k * m * (1 - n * l * (1 / 6 - (8 - l + 8 * o) * n / 120)), c = p - this.ml0 + k * g / h * n * (.5 + (5 - l + 6 * o) * n / 24)
        }
        return a.x = b + this.x0, a.y = c + this.y0, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, d = a.x / this.a,
          e = a.y / this.a;
        if (this.sphere) {
          var f = e + this.lat0;
          b = Math.asin(Math.sin(f) * Math.cos(d)), c = Math.atan2(Math.tan(d), Math.cos(f))
        } else {
          var g = this.ml0 / this.a + e,
            h = l(g, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(h) - m) <= n) return a.x = this.long0, a.y = m, 0 > e && (a.y *= -1), a;
          var o = i(this.a, this.e, Math.sin(h)),
            p = o * o * o / this.a / this.a * (1 - this.es),
            q = Math.pow(Math.tan(h), 2),
            r = d * this.a / o,
            s = r * r;
          b = h - o * Math.tan(h) / p * r * r * (.5 - (1 + 3 * q) * r * r / 24), c = r * (1 - s * (q / 3 + (1 + 3 * q) * q * s / 15)) / Math.cos(h)
        }
        return a.x = j(c + this.long0), a.y = k(b), a
      }, c.names = ["Cassini", "Cassini_Soldner", "cass"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/imlfn": 12,
      "../common/mlfn": 14
    }],
    43: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/qsfnz"),
        f = a("../common/msfnz"),
        g = a("../common/iqsfnz");
      c.init = function() {
        this.sphere || (this.k0 = f(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)))
      }, c.forward = function(a) {
        var b, c, f = a.x,
          g = a.y,
          h = d(f - this.long0);
        if (this.sphere) b = this.x0 + this.a * h * Math.cos(this.lat_ts), c = this.y0 + this.a * Math.sin(g) / Math.cos(this.lat_ts);
        else {
          var i = e(this.e, Math.sin(g));
          b = this.x0 + this.a * this.k0 * h, c = this.y0 + this.a * i * .5 / this.k0
        }
        return a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c;
        return this.sphere ? (b = d(this.long0 + a.x / this.a / Math.cos(this.lat_ts)), c = Math.asin(a.y / this.a * Math.cos(this.lat_ts))) : (c = g(this.e, 2 * a.y * this.k0 / this.a), b = d(this.long0 + a.x / (this.a * this.k0))), a.x = b, a.y = c, a
      }, c.names = ["cea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/iqsfnz": 13,
      "../common/msfnz": 15,
      "../common/qsfnz": 20
    }],
    44: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/adjust_lat");
      c.init = function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y,
          f = d(b - this.long0),
          g = e(c - this.lat0);
        return a.x = this.x0 + this.a * f * this.rc, a.y = this.y0 + this.a * g, a
      }, c.inverse = function(a) {
        var b = a.x,
          c = a.y;
        return a.x = d(this.long0 + (b - this.x0) / (this.a * this.rc)), a.y = e(this.lat0 + (c - this.y0) / this.a), a
      }, c.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5
    }],
    45: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/msfnz"),
        i = a("../common/mlfn"),
        j = a("../common/adjust_lon"),
        k = a("../common/adjust_lat"),
        l = a("../common/imlfn"),
        m = 1e-10;
      c.init = function() {
        Math.abs(this.lat1 + this.lat2) < m || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = h(this.e, this.sinphi, this.cosphi), this.ml1 = i(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < m ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = h(this.e, this.sinphi, this.cosphi), this.ml2 = i(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = i(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0))
      }, c.forward = function(a) {
        var b, c = a.x,
          d = a.y;
        if (this.sphere) b = this.a * (this.g - d);
        else {
          var e = i(this.e0, this.e1, this.e2, this.e3, d);
          b = this.a * (this.g - e)
        }
        var f = this.ns * j(c - this.long0),
          g = this.x0 + b * Math.sin(f),
          h = this.y0 + this.rh - b * Math.cos(f);
        return a.x = g, a.y = h, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y = this.rh - a.y + this.y0;
        var b, c, d, e;
        this.ns >= 0 ? (c = Math.sqrt(a.x * a.x + a.y * a.y), b = 1) : (c = -Math.sqrt(a.x * a.x + a.y * a.y), b = -1);
        var f = 0;
        if (0 !== c && (f = Math.atan2(b * a.x, b * a.y)), this.sphere) return e = j(this.long0 + f / this.ns), d = k(this.g - c / this.a), a.x = e, a.y = d, a;
        var g = this.g - c / this.a;
        return d = l(g, this.e0, this.e1, this.e2, this.e3), e = j(this.long0 + f / this.ns), a.x = e, a.y = d, a
      }, c.names = ["Equidistant_Conic", "eqdc"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/imlfn": 12,
      "../common/mlfn": 14,
      "../common/msfnz": 15
    }],
    46: [function(a, b, c) {
      var d = Math.PI / 4,
        e = a("../common/srat"),
        f = Math.PI / 2,
        g = 20;
      c.init = function() {
        var a = Math.sin(this.lat0),
          b = Math.cos(this.lat0);
        b *= b, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * a * a), this.C = Math.sqrt(1 + this.es * b * b / (1 - this.es)), this.phic0 = Math.asin(a / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + d) / (Math.pow(Math.tan(.5 * this.lat0 + d), this.C) * e(this.e * a, this.ratexp))
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        return a.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * c + d), this.C) * e(this.e * Math.sin(c), this.ratexp)) - f, a.x = this.C * b, a
      }, c.inverse = function(a) {
        for (var b = 1e-14, c = a.x / this.C, h = a.y, i = Math.pow(Math.tan(.5 * h + d) / this.K, 1 / this.C), j = g; j > 0 && (h = 2 * Math.atan(i * e(this.e * Math.sin(a.y), -.5 * this.e)) - f, !(Math.abs(h - a.y) < b)); --j) a.y = h;
        return j ? (a.x = c, a.y = h, a) : null
      }, c.names = ["gauss"]
    }, {
      "../common/srat": 22
    }],
    47: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = 1e-10,
        f = a("../common/asinz");
      c.init = function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0),
          this.infinity_dist = 1e3 * this.a, this.rc = 1
      }, c.forward = function(a) {
        var b, c, f, g, h, i, j, k, l = a.x,
          m = a.y;
        return f = d(l - this.long0), b = Math.sin(m), c = Math.cos(m), g = Math.cos(f), i = this.sin_p14 * b + this.cos_p14 * c * g, h = 1, i > 0 || Math.abs(i) <= e ? (j = this.x0 + this.a * h * c * Math.sin(f) / i, k = this.y0 + this.a * h * (this.cos_p14 * b - this.sin_p14 * c * g) / i) : (j = this.x0 + this.infinity_dist * c * Math.sin(f), k = this.y0 + this.infinity_dist * (this.cos_p14 * b - this.sin_p14 * c * g)), a.x = j, a.y = k, a
      }, c.inverse = function(a) {
        var b, c, e, g, h, i;
        return a.x = (a.x - this.x0) / this.a, a.y = (a.y - this.y0) / this.a, a.x /= this.k0, a.y /= this.k0, (b = Math.sqrt(a.x * a.x + a.y * a.y)) ? (g = Math.atan2(b, this.rc), c = Math.sin(g), e = Math.cos(g), i = f(e * this.sin_p14 + a.y * c * this.cos_p14 / b), h = Math.atan2(a.x * c, b * this.cos_p14 * e - a.y * this.sin_p14 * c), h = d(this.long0 + h)) : (i = this.phic0, h = 0), a.x = h, a.y = i, a
      }, c.names = ["gnom"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6
    }],
    48: [function(a, b, c) {
      var d = a("../common/adjust_lon");
      c.init = function() {
        this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq
      }, c.forward = function(a) {
        var b, c, e, f, g, h, i, j = a.x,
          k = a.y,
          l = d(j - this.long0);
        return b = Math.pow((1 + this.e * Math.sin(k)) / (1 - this.e * Math.sin(k)), this.alfa * this.e / 2), c = 2 * (Math.atan(this.k * Math.pow(Math.tan(k / 2 + this.s45), this.alfa) / b) - this.s45), e = -l * this.alfa, f = Math.asin(Math.cos(this.ad) * Math.sin(c) + Math.sin(this.ad) * Math.cos(c) * Math.cos(e)), g = Math.asin(Math.cos(c) * Math.sin(e) / Math.cos(f)), h = this.n * g, i = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(f / 2 + this.s45), this.n), a.y = i * Math.cos(h) / 1, a.x = i * Math.sin(h) / 1, this.czech || (a.y *= -1, a.x *= -1), a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, h, i, j = a.x;
        a.x = a.y, a.y = j, this.czech || (a.y *= -1, a.x *= -1), g = Math.sqrt(a.x * a.x + a.y * a.y), f = Math.atan2(a.y, a.x), e = f / Math.sin(this.s0), d = 2 * (Math.atan(Math.pow(this.ro0 / g, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), b = Math.asin(Math.cos(this.ad) * Math.sin(d) - Math.sin(this.ad) * Math.cos(d) * Math.cos(e)), c = Math.asin(Math.cos(d) * Math.sin(e) / Math.cos(b)), a.x = this.long0 - c / this.alfa, h = b, i = 0;
        var k = 0;
        do a.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(b / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.e / 2)) - this.s45), Math.abs(h - a.y) < 1e-10 && (i = 1), h = a.y, k += 1; while (0 === i && 15 > k);
        return k >= 15 ? null : a
      }, c.names = ["Krovak", "krovak"]
    }, {
      "../common/adjust_lon": 5
    }],
    49: [function(a, b, c) {
      var d = Math.PI / 2,
        e = Math.PI / 4,
        f = 1e-10,
        g = a("../common/qsfnz"),
        h = a("../common/adjust_lon");
      c.S_POLE = 1, c.N_POLE = 2, c.EQUIT = 3, c.OBLIQ = 4, c.init = function() {
        var a = Math.abs(this.lat0);
        if (Math.abs(a - d) < f ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(a) < f ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
          var b;
          switch (this.qp = g(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = this.authset(this.es), this.mode) {
            case this.N_POLE:
              this.dd = 1;
              break;
            case this.S_POLE:
              this.dd = 1;
              break;
            case this.EQUIT:
              this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp;
              break;
            case this.OBLIQ:
              this.rq = Math.sqrt(.5 * this.qp), b = Math.sin(this.lat0), this.sinb1 = g(this.e, b) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * b * b) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd
          }
        } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0))
      }, c.forward = function(a) {
        var b, c, i, j, k, l, m, n, o, p, q = a.x,
          r = a.y;
        if (q = h(q - this.long0), this.sphere) {
          if (k = Math.sin(r), p = Math.cos(r), i = Math.cos(q), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (c = this.mode === this.EQUIT ? 1 + p * i : 1 + this.sinph0 * k + this.cosph0 * p * i, f >= c) return null;
            c = Math.sqrt(2 / c), b = c * p * Math.sin(q), c *= this.mode === this.EQUIT ? k : this.cosph0 * k - this.sinph0 * p * i
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (i = -i), Math.abs(r + this.phi0) < f) return null;
            c = e - .5 * r, c = 2 * (this.mode === this.S_POLE ? Math.cos(c) : Math.sin(c)), b = c * Math.sin(q), c *= i
          }
        } else {
          switch (m = 0, n = 0, o = 0, i = Math.cos(q), j = Math.sin(q), k = Math.sin(r), l = g(this.e, k), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = l / this.qp, n = Math.sqrt(1 - m * m)), this.mode) {
            case this.OBLIQ:
              o = 1 + this.sinb1 * m + this.cosb1 * n * i;
              break;
            case this.EQUIT:
              o = 1 + n * i;
              break;
            case this.N_POLE:
              o = d + r, l = this.qp - l;
              break;
            case this.S_POLE:
              o = r - d, l = this.qp + l
          }
          if (Math.abs(o) < f) return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              o = Math.sqrt(2 / o), c = this.mode === this.OBLIQ ? this.ymf * o * (this.cosb1 * m - this.sinb1 * n * i) : (o = Math.sqrt(2 / (1 + n * i))) * m * this.ymf, b = this.xmf * o * n * j;
              break;
            case this.N_POLE:
            case this.S_POLE:
              l >= 0 ? (b = (o = Math.sqrt(l)) * j, c = i * (this.mode === this.S_POLE ? o : -o)) : b = c = 0
          }
        }
        return a.x = this.a * b + this.x0, a.y = this.a * c + this.y0, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, e, g, i, j, k, l = a.x / this.a,
          m = a.y / this.a;
        if (this.sphere) {
          var n, o = 0,
            p = 0;
          if (n = Math.sqrt(l * l + m * m), c = .5 * n, c > 1) return null;
          switch (c = 2 * Math.asin(c), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (p = Math.sin(c), o = Math.cos(c)), this.mode) {
            case this.EQUIT:
              c = Math.abs(n) <= f ? 0 : Math.asin(m * p / n), l *= p, m = o * n;
              break;
            case this.OBLIQ:
              c = Math.abs(n) <= f ? this.phi0 : Math.asin(o * this.sinph0 + m * p * this.cosph0 / n), l *= p * this.cosph0, m = (o - Math.sin(c) * this.sinph0) * n;
              break;
            case this.N_POLE:
              m = -m, c = d - c;
              break;
            case this.S_POLE:
              c -= d
          }
          b = 0 !== m || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(l, m) : 0
        } else {
          if (k = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (l /= this.dd, m *= this.dd, j = Math.sqrt(l * l + m * m), f > j) return a.x = 0, a.y = this.phi0, a;
            g = 2 * Math.asin(.5 * j / this.rq), e = Math.cos(g), l *= g = Math.sin(g), this.mode === this.OBLIQ ? (k = e * this.sinb1 + m * g * this.cosb1 / j, i = this.qp * k, m = j * this.cosb1 * e - m * this.sinb1 * g) : (k = m * g / j, i = this.qp * k, m = j * e)
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (m = -m), i = l * l + m * m, !i) return a.x = 0, a.y = this.phi0, a;
            k = 1 - i / this.qp, this.mode === this.S_POLE && (k = -k)
          }
          b = Math.atan2(l, m), c = this.authlat(Math.asin(k), this.apa)
        }
        return a.x = h(this.long0 + b), a.y = c, a
      }, c.P00 = .3333333333333333, c.P01 = .17222222222222222, c.P02 = .10257936507936508, c.P10 = .06388888888888888, c.P11 = .0664021164021164, c.P20 = .016415012942191543, c.authset = function(a) {
        var b, c = [];
        return c[0] = a * this.P00, b = a * a, c[0] += b * this.P01, c[1] = b * this.P10, b *= a, c[0] += b * this.P02, c[1] += b * this.P11, c[2] = b * this.P20, c
      }, c.authlat = function(a, b) {
        var c = a + a;
        return a + b[0] * Math.sin(c) + b[1] * Math.sin(c + c) + b[2] * Math.sin(c + c + c)
      }, c.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/qsfnz": 20
    }],
    50: [function(a, b, c) {
      var d = 1e-10,
        e = a("../common/msfnz"),
        f = a("../common/tsfnz"),
        g = Math.PI / 2,
        h = a("../common/sign"),
        i = a("../common/adjust_lon"),
        j = a("../common/phi2z");
      c.init = function() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < d)) {
          var a = this.b / this.a;
          this.e = Math.sqrt(1 - a * a);
          var b = Math.sin(this.lat1),
            c = Math.cos(this.lat1),
            g = e(this.e, b, c),
            h = f(this.e, this.lat1, b),
            i = Math.sin(this.lat2),
            j = Math.cos(this.lat2),
            k = e(this.e, i, j),
            l = f(this.e, this.lat2, i),
            m = f(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > d ? this.ns = Math.log(g / k) / Math.log(h / l) : this.ns = b, isNaN(this.ns) && (this.ns = b), this.f0 = g / (this.ns * Math.pow(h, this.ns)), this.rh = this.a * this.f0 * Math.pow(m, this.ns), this.title || (this.title = "Lambert Conformal Conic")
        }
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        Math.abs(2 * Math.abs(c) - Math.PI) <= d && (c = h(c) * (g - 2 * d));
        var e, j, k = Math.abs(Math.abs(c) - g);
        if (k > d) e = f(this.e, c, Math.sin(c)), j = this.a * this.f0 * Math.pow(e, this.ns);
        else {
          if (k = c * this.ns, 0 >= k) return null;
          j = 0
        }
        var l = this.ns * i(b - this.long0);
        return a.x = this.k0 * (j * Math.sin(l)) + this.x0, a.y = this.k0 * (this.rh - j * Math.cos(l)) + this.y0, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, h = (a.x - this.x0) / this.k0,
          k = this.rh - (a.y - this.y0) / this.k0;
        this.ns > 0 ? (b = Math.sqrt(h * h + k * k), c = 1) : (b = -Math.sqrt(h * h + k * k), c = -1);
        var l = 0;
        if (0 !== b && (l = Math.atan2(c * h, c * k)), 0 !== b || this.ns > 0) {
          if (c = 1 / this.ns, d = Math.pow(b / (this.a * this.f0), c), e = j(this.e, d), -9999 === e) return null
        } else e = -g;
        return f = i(l / this.ns + this.long0), a.x = f, a.y = e, a
      }, c.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/sign": 21,
      "../common/tsfnz": 24
    }],
    51: [function(a, b, c) {
      function d(a) {
        return a
      }
      c.init = function() {}, c.forward = d, c.inverse = d, c.names = ["longlat", "identity"]
    }, {}],
    52: [function(a, b, c) {
      var d = a("../common/msfnz"),
        e = Math.PI / 2,
        f = 1e-10,
        g = 57.29577951308232,
        h = a("../common/adjust_lon"),
        i = Math.PI / 4,
        j = a("../common/tsfnz"),
        k = a("../common/phi2z");
      c.init = function() {
        var a = this.b / this.a;
        this.es = 1 - a * a, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = d(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        if (c * g > 90 && -90 > c * g && b * g > 180 && -180 > b * g) return null;
        var d, k;
        if (Math.abs(Math.abs(c) - e) <= f) return null;
        if (this.sphere) d = this.x0 + this.a * this.k0 * h(b - this.long0), k = this.y0 + this.a * this.k0 * Math.log(Math.tan(i + .5 * c));
        else {
          var l = Math.sin(c),
            m = j(this.e, c, l);
          d = this.x0 + this.a * this.k0 * h(b - this.long0), k = this.y0 - this.a * this.k0 * Math.log(m)
        }
        return a.x = d, a.y = k, a
      }, c.inverse = function(a) {
        var b, c, d = a.x - this.x0,
          f = a.y - this.y0;
        if (this.sphere) c = e - 2 * Math.atan(Math.exp(-f / (this.a * this.k0)));
        else {
          var g = Math.exp(-f / (this.a * this.k0));
          if (c = k(this.e, g), -9999 === c) return null
        }
        return b = h(this.long0 + d / (this.a * this.k0)), a.x = b, a.y = c, a
      }, c.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/tsfnz": 24
    }],
    53: [function(a, b, c) {
      var d = a("../common/adjust_lon");
      c.init = function() {}, c.forward = function(a) {
        var b = a.x,
          c = a.y,
          e = d(b - this.long0),
          f = this.x0 + this.a * e,
          g = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + c / 2.5)) * 1.25;
        return a.x = f, a.y = g, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b = d(this.long0 + a.x / this.a),
          c = 2.5 * (Math.atan(Math.exp(.8 * a.y / this.a)) - Math.PI / 4);
        return a.x = b, a.y = c, a
      }, c.names = ["Miller_Cylindrical", "mill"]
    }, {
      "../common/adjust_lon": 5
    }],
    54: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = 1e-10;
      c.init = function() {}, c.forward = function(a) {
        for (var b = a.x, c = a.y, f = d(b - this.long0), g = c, h = Math.PI * Math.sin(c), i = 0; !0; i++) {
          var j = -(g + Math.sin(g) - h) / (1 + Math.cos(g));
          if (g += j, Math.abs(j) < e) break
        }
        g /= 2, Math.PI / 2 - Math.abs(c) < e && (f = 0);
        var k = .900316316158 * this.a * f * Math.cos(g) + this.x0,
          l = 1.4142135623731 * this.a * Math.sin(g) + this.y0;
        return a.x = k, a.y = l, a
      }, c.inverse = function(a) {
        var b, c;
        a.x -= this.x0, a.y -= this.y0, c = a.y / (1.4142135623731 * this.a), Math.abs(c) > .999999999999 && (c = .999999999999), b = Math.asin(c);
        var e = d(this.long0 + a.x / (.900316316158 * this.a * Math.cos(b)));
        e < -Math.PI && (e = -Math.PI), e > Math.PI && (e = Math.PI), c = (2 * b + Math.sin(2 * b)) / Math.PI, Math.abs(c) > 1 && (c = 1);
        var f = Math.asin(c);
        return a.x = e, a.y = f, a
      }, c.names = ["Mollweide", "moll"]
    }, {
      "../common/adjust_lon": 5
    }],
    55: [function(a, b, c) {
      var d = 484813681109536e-20;
      c.iterations = 1, c.init = function() {
        this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013
      }, c.forward = function(a) {
        var b, c = a.x,
          e = a.y,
          f = e - this.lat0,
          g = c - this.long0,
          h = f / d * 1e-5,
          i = g,
          j = 1,
          k = 0;
        for (b = 1; 10 >= b; b++) j *= h, k += this.A[b] * j;
        var l, m, n = k,
          o = i,
          p = 1,
          q = 0,
          r = 0,
          s = 0;
        for (b = 1; 6 >= b; b++) l = p * n - q * o, m = q * n + p * o, p = l, q = m, r = r + this.B_re[b] * p - this.B_im[b] * q, s = s + this.B_im[b] * p + this.B_re[b] * q;
        return a.x = s * this.a + this.x0, a.y = r * this.a + this.y0, a
      }, c.inverse = function(a) {
        var b, c, e, f = a.x,
          g = a.y,
          h = f - this.x0,
          i = g - this.y0,
          j = i / this.a,
          k = h / this.a,
          l = 1,
          m = 0,
          n = 0,
          o = 0;
        for (b = 1; 6 >= b; b++) c = l * j - m * k, e = m * j + l * k, l = c, m = e, n = n + this.C_re[b] * l - this.C_im[b] * m, o = o + this.C_im[b] * l + this.C_re[b] * m;
        for (var p = 0; p < this.iterations; p++) {
          var q, r, s = n,
            t = o,
            u = j,
            v = k;
          for (b = 2; 6 >= b; b++) q = s * n - t * o, r = t * n + s * o, s = q, t = r, u += (b - 1) * (this.B_re[b] * s - this.B_im[b] * t), v += (b - 1) * (this.B_im[b] * s + this.B_re[b] * t);
          s = 1, t = 0;
          var w = this.B_re[1],
            x = this.B_im[1];
          for (b = 2; 6 >= b; b++) q = s * n - t * o, r = t * n + s * o, s = q, t = r, w += b * (this.B_re[b] * s - this.B_im[b] * t), x += b * (this.B_im[b] * s + this.B_re[b] * t);
          var y = w * w + x * x;
          n = (u * w + v * x) / y, o = (v * w - u * x) / y
        }
        var z = n,
          A = o,
          B = 1,
          C = 0;
        for (b = 1; 9 >= b; b++) B *= z, C += this.D[b] * B;
        var D = this.lat0 + C * d * 1e5,
          E = this.long0 + A;
        return a.x = E, a.y = D, a
      }, c.names = ["New_Zealand_Map_Grid", "nzmg"]
    }, {}],
    56: [function(a, b, c) {
      var d = a("../common/tsfnz"),
        e = a("../common/adjust_lon"),
        f = a("../common/phi2z"),
        g = Math.PI / 2,
        h = Math.PI / 4,
        i = 1e-10;
      c.init = function() {
        this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0) && (this.k0 = 1);
        var a = Math.sin(this.lat0),
          b = Math.cos(this.lat0),
          c = this.e * a;
        this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(b, 4)), this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - c * c);
        var f = d(this.e, this.lat0, a),
          g = this.bl / b * Math.sqrt((1 - this.es) / (1 - c * c));
        1 > g * g && (g = 1);
        var h, i;
        if (isNaN(this.longc)) {
          var j = d(this.e, this.lat1, Math.sin(this.lat1)),
            k = d(this.e, this.lat2, Math.sin(this.lat2));
          this.lat0 >= 0 ? this.el = (g + Math.sqrt(g * g - 1)) * Math.pow(f, this.bl) : this.el = (g - Math.sqrt(g * g - 1)) * Math.pow(f, this.bl);
          var l = Math.pow(j, this.bl),
            m = Math.pow(k, this.bl);
          h = this.el / l, i = .5 * (h - 1 / h);
          var n = (this.el * this.el - m * l) / (this.el * this.el + m * l),
            o = (m - l) / (m + l),
            p = e(this.long1 - this.long2);
          this.long0 = .5 * (this.long1 + this.long2) - Math.atan(n * Math.tan(.5 * this.bl * p) / o) / this.bl, this.long0 = e(this.long0);
          var q = e(this.long1 - this.long0);
          this.gamma0 = Math.atan(Math.sin(this.bl * q) / i), this.alpha = Math.asin(g * Math.sin(this.gamma0))
        } else h = this.lat0 >= 0 ? g + Math.sqrt(g * g - 1) : g - Math.sqrt(g * g - 1), this.el = h * Math.pow(f, this.bl), i = .5 * (h - 1 / h), this.gamma0 = Math.asin(Math.sin(this.alpha) / g), this.long0 = this.longc - Math.asin(i * Math.tan(this.gamma0)) / this.bl;
        this.no_off ? this.uc = 0 : this.lat0 >= 0 ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(g * g - 1), Math.cos(this.alpha)) : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(g * g - 1), Math.cos(this.alpha))
      }, c.forward = function(a) {
        var b, c, f, j = a.x,
          k = a.y,
          l = e(j - this.long0);
        if (Math.abs(Math.abs(k) - g) <= i) f = k > 0 ? -1 : 1, c = this.al / this.bl * Math.log(Math.tan(h + f * this.gamma0 * .5)), b = -1 * f * g * this.al / this.bl;
        else {
          var m = d(this.e, k, Math.sin(k)),
            n = this.el / Math.pow(m, this.bl),
            o = .5 * (n - 1 / n),
            p = .5 * (n + 1 / n),
            q = Math.sin(this.bl * l),
            r = (o * Math.sin(this.gamma0) - q * Math.cos(this.gamma0)) / p;
          c = Math.abs(Math.abs(r) - 1) <= i ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - r) / (1 + r)) / this.bl, b = Math.abs(Math.cos(this.bl * l)) <= i ? this.al * this.bl * l : this.al * Math.atan2(o * Math.cos(this.gamma0) + q * Math.sin(this.gamma0), Math.cos(this.bl * l)) / this.bl
        }
        return this.no_rot ? (a.x = this.x0 + b, a.y = this.y0 + c) : (b -= this.uc, a.x = this.x0 + c * Math.cos(this.alpha) + b * Math.sin(this.alpha), a.y = this.y0 + b * Math.cos(this.alpha) - c * Math.sin(this.alpha)), a
      }, c.inverse = function(a) {
        var b, c;
        this.no_rot ? (c = a.y - this.y0, b = a.x - this.x0) : (c = (a.x - this.x0) * Math.cos(this.alpha) - (a.y - this.y0) * Math.sin(this.alpha), b = (a.y - this.y0) * Math.cos(this.alpha) + (a.x - this.x0) * Math.sin(this.alpha), b += this.uc);
        var d = Math.exp(-1 * this.bl * c / this.al),
          h = .5 * (d - 1 / d),
          j = .5 * (d + 1 / d),
          k = Math.sin(this.bl * b / this.al),
          l = (k * Math.cos(this.gamma0) + h * Math.sin(this.gamma0)) / j,
          m = Math.pow(this.el / Math.sqrt((1 + l) / (1 - l)), 1 / this.bl);
        return Math.abs(l - 1) < i ? (a.x = this.long0, a.y = g) : Math.abs(l + 1) < i ? (a.x = this.long0, a.y = -1 * g) : (a.y = f(this.e, m), a.x = e(this.long0 - Math.atan2(h * Math.cos(this.gamma0) - k * Math.sin(this.gamma0), Math.cos(this.bl * b / this.al)) / this.bl)), a
      }, c.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/phi2z": 16,
      "../common/tsfnz": 24
    }],
    57: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/adjust_lon"),
        i = a("../common/adjust_lat"),
        j = a("../common/mlfn"),
        k = 1e-10,
        l = a("../common/gN"),
        m = 20;
      c.init = function() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.ml0 = this.a * j(this.e0, this.e1, this.e2, this.e3, this.lat0)
      }, c.forward = function(a) {
        var b, c, d, e = a.x,
          f = a.y,
          g = h(e - this.long0);
        if (d = g * Math.sin(f), this.sphere) Math.abs(f) <= k ? (b = this.a * g, c = -1 * this.a * this.lat0) : (b = this.a * Math.sin(d) / Math.tan(f), c = this.a * (i(f - this.lat0) + (1 - Math.cos(d)) / Math.tan(f)));
        else if (Math.abs(f) <= k) b = this.a * g, c = -1 * this.ml0;
        else {
          var m = l(this.a, this.e, Math.sin(f)) / Math.tan(f);
          b = m * Math.sin(d), c = this.a * j(this.e0, this.e1, this.e2, this.e3, f) - this.ml0 + m * (1 - Math.cos(d))
        }
        return a.x = b + this.x0, a.y = c + this.y0, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, i, l, n;
        if (d = a.x - this.x0, e = a.y - this.y0, this.sphere)
          if (Math.abs(e + this.a * this.lat0) <= k) b = h(d / this.a + this.long0), c = 0;
          else {
            g = this.lat0 + e / this.a, i = d * d / this.a / this.a + g * g, l = g;
            var o;
            for (f = m; f; --f)
              if (o = Math.tan(l), n = -1 * (g * (l * o + 1) - l - .5 * (l * l + i) * o) / ((l - g) / o - 1), l += n, Math.abs(n) <= k) {
                c = l;
                break
              } b = h(this.long0 + Math.asin(d * Math.tan(l) / this.a) / Math.sin(c))
          }
        else if (Math.abs(e + this.ml0) <= k) c = 0, b = h(this.long0 + d / this.a);
        else {
          g = (this.ml0 + e) / this.a, i = d * d / this.a / this.a + g * g, l = g;
          var p, q, r, s, t;
          for (f = m; f; --f)
            if (t = this.e * Math.sin(l), p = Math.sqrt(1 - t * t) * Math.tan(l), q = this.a * j(this.e0, this.e1, this.e2, this.e3, l), r = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), s = q / this.a, n = (g * (p * s + 1) - s - .5 * p * (s * s + i)) / (this.es * Math.sin(2 * l) * (s * s + i - 2 * g * s) / (4 * p) + (g - s) * (p * r - 2 / Math.sin(2 * l)) - r), l -= n, Math.abs(n) <= k) {
              c = l;
              break
            } p = Math.sqrt(1 - this.es * Math.pow(Math.sin(c), 2)) * Math.tan(c), b = h(this.long0 + Math.asin(d * p / this.a) / Math.sin(c))
        }
        return a.x = b, a.y = c, a
      }, c.names = ["Polyconic", "poly"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/mlfn": 14
    }],
    58: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/adjust_lat"),
        f = a("../common/pj_enfn"),
        g = 20,
        h = a("../common/pj_mlfn"),
        i = a("../common/pj_inv_mlfn"),
        j = Math.PI / 2,
        k = 1e-10,
        l = a("../common/asinz");
      c.init = function() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = f(this.es)
      }, c.forward = function(a) {
        var b, c, e = a.x,
          f = a.y;
        if (e = d(e - this.long0), this.sphere) {
          if (this.m)
            for (var i = this.n * Math.sin(f), j = g; j; --j) {
              var l = (this.m * f + Math.sin(f) - i) / (this.m + Math.cos(f));
              if (f -= l, Math.abs(l) < k) break
            } else f = 1 !== this.n ? Math.asin(this.n * Math.sin(f)) : f;
          b = this.a * this.C_x * e * (this.m + Math.cos(f)), c = this.a * this.C_y * f
        } else {
          var m = Math.sin(f),
            n = Math.cos(f);
          c = this.a * h(f, m, n, this.en), b = this.a * e * n / Math.sqrt(1 - this.es * m * m)
        }
        return a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        var b, c, f, g;
        return a.x -= this.x0, f = a.x / this.a, a.y -= this.y0, b = a.y / this.a, this.sphere ? (b /= this.C_y, f /= this.C_x * (this.m + Math.cos(b)), this.m ? b = l((this.m * b + Math.sin(b)) / this.n) : 1 !== this.n && (b = l(Math.sin(b) / this.n)), f = d(f + this.long0), b = e(b)) : (b = i(a.y / this.a, this.es, this.en), g = Math.abs(b), j > g ? (g = Math.sin(b), c = this.long0 + a.x * Math.sqrt(1 - this.es * g * g) / (this.a * Math.cos(b)), f = d(c)) : j > g - k && (f = this.long0)), a.x = f, a.y = b, a
      }, c.names = ["Sinusoidal", "sinu"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/pj_enfn": 17,
      "../common/pj_inv_mlfn": 18,
      "../common/pj_mlfn": 19
    }],
    59: [function(a, b, c) {
      c.init = function() {
        var a = this.lat0;
        this.lambda0 = this.long0;
        var b = Math.sin(a),
          c = this.a,
          d = this.rf,
          e = 1 / d,
          f = 2 * e - Math.pow(e, 2),
          g = this.e = Math.sqrt(f);
        this.R = this.k0 * c * Math.sqrt(1 - f) / (1 - f * Math.pow(b, 2)), this.alpha = Math.sqrt(1 + f / (1 - f) * Math.pow(Math.cos(a), 4)), this.b0 = Math.asin(b / this.alpha);
        var h = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
          i = Math.log(Math.tan(Math.PI / 4 + a / 2)),
          j = Math.log((1 + g * b) / (1 - g * b));
        this.K = h - this.alpha * i + this.alpha * g / 2 * j
      }, c.forward = function(a) {
        var b = Math.log(Math.tan(Math.PI / 4 - a.y / 2)),
          c = this.e / 2 * Math.log((1 + this.e * Math.sin(a.y)) / (1 - this.e * Math.sin(a.y))),
          d = -this.alpha * (b + c) + this.K,
          e = 2 * (Math.atan(Math.exp(d)) - Math.PI / 4),
          f = this.alpha * (a.x - this.lambda0),
          g = Math.atan(Math.sin(f) / (Math.sin(this.b0) * Math.tan(e) + Math.cos(this.b0) * Math.cos(f))),
          h = Math.asin(Math.cos(this.b0) * Math.sin(e) - Math.sin(this.b0) * Math.cos(e) * Math.cos(f));
        return a.y = this.R / 2 * Math.log((1 + Math.sin(h)) / (1 - Math.sin(h))) + this.y0, a.x = this.R * g + this.x0, a
      }, c.inverse = function(a) {
        for (var b = a.x - this.x0, c = a.y - this.y0, d = b / this.R, e = 2 * (Math.atan(Math.exp(c / this.R)) - Math.PI / 4), f = Math.asin(Math.cos(this.b0) * Math.sin(e) + Math.sin(this.b0) * Math.cos(e) * Math.cos(d)), g = Math.atan(Math.sin(d) / (Math.cos(this.b0) * Math.cos(d) - Math.sin(this.b0) * Math.tan(e))), h = this.lambda0 + g / this.alpha, i = 0, j = f, k = -1e3, l = 0; Math.abs(j - k) > 1e-7;) {
          if (++l > 20) return;
          i = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + f / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(j)) / 2)), k = j, j = 2 * Math.atan(Math.exp(i)) - Math.PI / 2
        }
        return a.x = h, a.y = j, a
      }, c.names = ["somerc"]
    }, {}],
    60: [function(a, b, c) {
      var d = Math.PI / 2,
        e = 1e-10,
        f = a("../common/sign"),
        g = a("../common/msfnz"),
        h = a("../common/tsfnz"),
        i = a("../common/phi2z"),
        j = a("../common/adjust_lon");
      c.ssfn_ = function(a, b, c) {
        return b *= c, Math.tan(.5 * (d + a)) * Math.pow((1 - b) / (1 + b), .5 * c)
      }, c.init = function() {
        this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= e && (this.k0 = .5 * (1 + f(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= e && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= e && (this.k0 = .5 * this.cons * g(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / h(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = g(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - d, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0))
      }, c.forward = function(a) {
        var b, c, f, g, i, k, l = a.x,
          m = a.y,
          n = Math.sin(m),
          o = Math.cos(m),
          p = j(l - this.long0);
        return Math.abs(Math.abs(l - this.long0) - Math.PI) <= e && Math.abs(m + this.lat0) <= e ? (a.x = NaN, a.y = NaN, a) : this.sphere ? (b = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * o * Math.cos(p)), a.x = this.a * b * o * Math.sin(p) + this.x0, a.y = this.a * b * (this.coslat0 * n - this.sinlat0 * o * Math.cos(p)) + this.y0, a) : (c = 2 * Math.atan(this.ssfn_(m, n, this.e)) - d, g = Math.cos(c), f = Math.sin(c), Math.abs(this.coslat0) <= e ? (i = h(this.e, m * this.con, this.con * n), k = 2 * this.a * this.k0 * i / this.cons, a.x = this.x0 + k * Math.sin(l - this.long0), a.y = this.y0 - this.con * k * Math.cos(l - this.long0), a) : (Math.abs(this.sinlat0) < e ? (b = 2 * this.a * this.k0 / (1 + g * Math.cos(p)), a.y = b * f) : (b = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * f + this.cosX0 * g * Math.cos(p))), a.y = b * (this.cosX0 * f - this.sinX0 * g * Math.cos(p)) + this.y0), a.x = b * g * Math.sin(p) + this.x0, a))
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, f, g, h, k = Math.sqrt(a.x * a.x + a.y * a.y);
        if (this.sphere) {
          var l = 2 * Math.atan(k / (.5 * this.a * this.k0));
          return b = this.long0, c = this.lat0, e >= k ? (a.x = b, a.y = c, a) : (c = Math.asin(Math.cos(l) * this.sinlat0 + a.y * Math.sin(l) * this.coslat0 / k), b = j(Math.abs(this.coslat0) < e ? this.lat0 > 0 ? this.long0 + Math.atan2(a.x, -1 * a.y) : this.long0 + Math.atan2(a.x, a.y) : this.long0 + Math.atan2(a.x * Math.sin(l), k * this.coslat0 * Math.cos(l) - a.y * this.sinlat0 * Math.sin(l))), a.x = b, a.y = c, a)
        }
        if (Math.abs(this.coslat0) <= e) {
          if (e >= k) return c = this.lat0, b = this.long0, a.x = b, a.y = c, a;
          a.x *= this.con, a.y *= this.con, f = k * this.cons / (2 * this.a * this.k0), c = this.con * i(this.e, f), b = this.con * j(this.con * this.long0 + Math.atan2(a.x, -1 * a.y))
        } else g = 2 * Math.atan(k * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), b = this.long0, e >= k ? h = this.X0 : (h = Math.asin(Math.cos(g) * this.sinX0 + a.y * Math.sin(g) * this.cosX0 / k), b = j(this.long0 + Math.atan2(a.x * Math.sin(g), k * this.cosX0 * Math.cos(g) - a.y * this.sinX0 * Math.sin(g)))), c = -1 * i(this.e, Math.tan(.5 * (d + h)));
        return a.x = b, a.y = c, a
      }, c.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/sign": 21,
      "../common/tsfnz": 24
    }],
    61: [function(a, b, c) {
      var d = a("./gauss"),
        e = a("../common/adjust_lon");
      c.init = function() {
        d.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"))
      }, c.forward = function(a) {
        var b, c, f, g;
        return a.x = e(a.x - this.long0), d.forward.apply(this, [a]), b = Math.sin(a.y), c = Math.cos(a.y), f = Math.cos(a.x), g = this.k0 * this.R2 / (1 + this.sinc0 * b + this.cosc0 * c * f), a.x = g * c * Math.sin(a.x), a.y = g * (this.cosc0 * b - this.sinc0 * c * f), a.x = this.a * a.x + this.x0, a.y = this.a * a.y + this.y0, a
      }, c.inverse = function(a) {
        var b, c, f, g, h;
        if (a.x = (a.x - this.x0) / this.a, a.y = (a.y - this.y0) / this.a, a.x /= this.k0, a.y /= this.k0, h = Math.sqrt(a.x * a.x + a.y * a.y)) {
          var i = 2 * Math.atan2(h, this.R2);
          b = Math.sin(i), c = Math.cos(i), g = Math.asin(c * this.sinc0 + a.y * b * this.cosc0 / h), f = Math.atan2(a.x * b, h * this.cosc0 * c - a.y * this.sinc0 * b)
        } else g = this.phic0, f = 0;
        return a.x = f, a.y = g, d.inverse.apply(this, [a]), a.x = e(a.x + this.long0), a
      }, c.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative"]
    }, {
      "../common/adjust_lon": 5,
      "./gauss": 46
    }],
    62: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/mlfn"),
        i = a("../common/adjust_lon"),
        j = Math.PI / 2,
        k = 1e-10,
        l = a("../common/sign"),
        m = a("../common/asinz");
      c.init = function() {
        this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.ml0 = this.a * h(this.e0, this.e1, this.e2, this.e3, this.lat0)
      }, c.forward = function(a) {
        var b, c, d, e = a.x,
          f = a.y,
          g = i(e - this.long0),
          j = Math.sin(f),
          k = Math.cos(f);
        if (this.sphere) {
          var l = k * Math.sin(g);
          if (Math.abs(Math.abs(l) - 1) < 1e-10) return 93;
          c = .5 * this.a * this.k0 * Math.log((1 + l) / (1 - l)), b = Math.acos(k * Math.cos(g) / Math.sqrt(1 - l * l)), 0 > f && (b = -b), d = this.a * this.k0 * (b - this.lat0)
        } else {
          var m = k * g,
            n = Math.pow(m, 2),
            o = this.ep2 * Math.pow(k, 2),
            p = Math.tan(f),
            q = Math.pow(p, 2);
          b = 1 - this.es * Math.pow(j, 2);
          var r = this.a / Math.sqrt(b),
            s = this.a * h(this.e0, this.e1, this.e2, this.e3, f);
          c = this.k0 * r * m * (1 + n / 6 * (1 - q + o + n / 20 * (5 - 18 * q + Math.pow(q, 2) + 72 * o - 58 * this.ep2))) + this.x0, d = this.k0 * (s - this.ml0 + r * p * (n * (.5 + n / 24 * (5 - q + 9 * o + 4 * Math.pow(o, 2) + n / 30 * (61 - 58 * q + Math.pow(q, 2) + 600 * o - 330 * this.ep2))))) + this.y0
        }
        return a.x = c, a.y = d, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, h = 6;
        if (this.sphere) {
          var n = Math.exp(a.x / (this.a * this.k0)),
            o = .5 * (n - 1 / n),
            p = this.lat0 + a.y / (this.a * this.k0),
            q = Math.cos(p);
          b = Math.sqrt((1 - q * q) / (1 + o * o)), f = m(b), 0 > p && (f = -f), g = 0 === o && 0 === q ? this.long0 : i(Math.atan2(o, q) + this.long0)
        } else {
          var r = a.x - this.x0,
            s = a.y - this.y0;
          for (b = (this.ml0 + s / this.k0) / this.a, c = b, e = 0; !0 && (d = (b + this.e1 * Math.sin(2 * c) - this.e2 * Math.sin(4 * c) + this.e3 * Math.sin(6 * c)) / this.e0 - c, c += d, !(Math.abs(d) <= k)); e++)
            if (e >= h) return 95;
          if (Math.abs(c) < j) {
            var t = Math.sin(c),
              u = Math.cos(c),
              v = Math.tan(c),
              w = this.ep2 * Math.pow(u, 2),
              x = Math.pow(w, 2),
              y = Math.pow(v, 2),
              z = Math.pow(y, 2);
            b = 1 - this.es * Math.pow(t, 2);
            var A = this.a / Math.sqrt(b),
              B = A * (1 - this.es) / b,
              C = r / (A * this.k0),
              D = Math.pow(C, 2);
            f = c - A * v * D / B * (.5 - D / 24 * (5 + 3 * y + 10 * w - 4 * x - 9 * this.ep2 - D / 30 * (61 + 90 * y + 298 * w + 45 * z - 252 * this.ep2 - 3 * x))), g = i(this.long0 + C * (1 - D / 6 * (1 + 2 * y + w - D / 20 * (5 - 2 * w + 28 * y - 3 * x + 8 * this.ep2 + 24 * z))) / u)
          } else f = j * l(s), g = this.long0
        }
        return a.x = g, a.y = f, a
      }, c.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/mlfn": 14,
      "../common/sign": 21
    }],
    63: [function(a, b, c) {
      var d = .017453292519943295,
        e = a("./tmerc");
      c.dependsOn = "tmerc", c.init = function() {
        this.zone && (this.lat0 = 0, this.long0 = (6 * Math.abs(this.zone) - 183) * d, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, e.init.apply(this), this.forward = e.forward, this.inverse = e.inverse)
      }, c.names = ["Universal Transverse Mercator System", "utm"]
    }, {
      "./tmerc": 62
    }],
    64: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = Math.PI / 2,
        f = 1e-10,
        g = a("../common/asinz");
      c.init = function() {
        this.R = this.a
      }, c.forward = function(a) {
        var b, c, h = a.x,
          i = a.y,
          j = d(h - this.long0);
        Math.abs(i) <= f && (b = this.x0 + this.R * j, c = this.y0);
        var k = g(2 * Math.abs(i / Math.PI));
        (Math.abs(j) <= f || Math.abs(Math.abs(i) - e) <= f) && (b = this.x0, c = i >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * k) : this.y0 + Math.PI * this.R * -Math.tan(.5 * k));
        var l = .5 * Math.abs(Math.PI / j - j / Math.PI),
          m = l * l,
          n = Math.sin(k),
          o = Math.cos(k),
          p = o / (n + o - 1),
          q = p * p,
          r = p * (2 / n - 1),
          s = r * r,
          t = Math.PI * this.R * (l * (p - s) + Math.sqrt(m * (p - s) * (p - s) - (s + m) * (q - s))) / (s + m);
        0 > j && (t = -t), b = this.x0 + t;
        var u = m + p;
        return t = Math.PI * this.R * (r * u - l * Math.sqrt((s + m) * (m + 1) - u * u)) / (s + m), c = i >= 0 ? this.y0 + t : this.y0 - t, a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        var b, c, e, g, h, i, j, k, l, m, n, o, p;
        return a.x -= this.x0, a.y -= this.y0, n = Math.PI * this.R, e = a.x / n, g = a.y / n, h = e * e + g * g, i = -Math.abs(g) * (1 + h), j = i - 2 * g * g + e * e, k = -2 * i + 1 + 2 * g * g + h * h, p = g * g / k + (2 * j * j * j / k / k / k - 9 * i * j / k / k) / 27, l = (i - j * j / 3 / k) / k, m = 2 * Math.sqrt(-l / 3), n = 3 * p / l / m, Math.abs(n) > 1 && (n = n >= 0 ? 1 : -1), o = Math.acos(n) / 3, c = a.y >= 0 ? (-m * Math.cos(o + Math.PI / 3) - j / 3 / k) * Math.PI : -(-m * Math.cos(o + Math.PI / 3) - j / 3 / k) * Math.PI, b = Math.abs(e) < f ? this.long0 : d(this.long0 + Math.PI * (h - 1 + Math.sqrt(1 + 2 * (e * e - g * g) + h * h)) / 2 / e), a.x = b, a.y = c, a
      }, c.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6
    }],
    65: [function(a, b, c) {
      var d = .017453292519943295,
        e = 57.29577951308232,
        f = 1,
        g = 2,
        h = a("./datum_transform"),
        i = a("./adjust_axis"),
        j = a("./Proj"),
        k = a("./common/toPoint");
      b.exports = function l(a, b, c) {
        function m(a, b) {
          return (a.datum.datum_type === f || a.datum.datum_type === g) && "WGS84" !== b.datumCode
        }
        var n;
        return Array.isArray(c) && (c = k(c)), a.datum && b.datum && (m(a, b) || m(b, a)) && (n = new j("WGS84"), l(a, n, c), a = n), "enu" !== a.axis && i(a, !1, c), "longlat" === a.projName ? (c.x *= d, c.y *= d) : (a.to_meter && (c.x *= a.to_meter, c.y *= a.to_meter), a.inverse(c)), a.from_greenwich && (c.x += a.from_greenwich), c = h(a.datum, b.datum, c), b.from_greenwich && (c.x -= b.from_greenwich), "longlat" === b.projName ? (c.x *= e, c.y *= e) : (b.forward(c), b.to_meter && (c.x /= b.to_meter, c.y /= b.to_meter)), "enu" !== b.axis && i(b, !0, c), c
      }
    }, {
      "./Proj": 2,
      "./adjust_axis": 3,
      "./common/toPoint": 23,
      "./datum_transform": 31
    }],
    66: [function(a, b, c) {
      function d(a, b, c) {
        a[b] = c.map(function(a) {
          var b = {};
          return e(a, b), b
        }).reduce(function(a, b) {
          return j(a, b)
        }, {})
      }

      function e(a, b) {
        var c;
        return Array.isArray(a) ? (c = a.shift(), "PARAMETER" === c && (c = a.shift()), 1 === a.length ? Array.isArray(a[0]) ? (b[c] = {}, e(a[0], b[c])) : b[c] = a[0] : a.length ? "TOWGS84" === c ? b[c] = a : (b[c] = {}, ["UNIT", "PRIMEM", "VERT_DATUM"].indexOf(c) > -1 ? (b[c] = {
          name: a[0].toLowerCase(),
          convert: a[1]
        }, 3 === a.length && (b[c].auth = a[2])) : "SPHEROID" === c ? (b[c] = {
          name: a[0],
          a: a[1],
          rf: a[2]
        }, 4 === a.length && (b[c].auth = a[3])) : ["GEOGCS", "GEOCCS", "DATUM", "VERT_CS", "COMPD_CS", "LOCAL_CS", "FITTED_CS", "LOCAL_DATUM"].indexOf(c) > -1 ? (a[0] = ["name", a[0]], d(b, c, a)) : a.every(function(a) {
          return Array.isArray(a)
        }) ? d(b, c, a) : e(a, b[c])) : b[c] = !0, void 0) : void(b[a] = !0)
      }

      function f(a, b) {
        var c = b[0],
          d = b[1];
        !(c in a) && d in a && (a[c] = a[d], 3 === b.length && (a[c] = b[2](a[c])))
      }

      function g(a) {
        return a * i
      }

      function h(a) {
        function b(b) {
          var c = a.to_meter || 1;
          return parseFloat(b, 10) * c
        }
        "GEOGCS" === a.type ? a.projName = "longlat" : "LOCAL_CS" === a.type ? (a.projName = "identity", a.local = !0) : "object" == typeof a.PROJECTION ? a.projName = Object.keys(a.PROJECTION)[0] : a.projName = a.PROJECTION, a.UNIT && (a.units = a.UNIT.name.toLowerCase(), "metre" === a.units && (a.units = "meter"),
          a.UNIT.convert && ("GEOGCS" === a.type ? a.DATUM && a.DATUM.SPHEROID && (a.to_meter = parseFloat(a.UNIT.convert, 10) * a.DATUM.SPHEROID.a) : a.to_meter = parseFloat(a.UNIT.convert, 10))), a.GEOGCS && (a.GEOGCS.DATUM ? a.datumCode = a.GEOGCS.DATUM.name.toLowerCase() : a.datumCode = a.GEOGCS.name.toLowerCase(), "d_" === a.datumCode.slice(0, 2) && (a.datumCode = a.datumCode.slice(2)), ("new_zealand_geodetic_datum_1949" === a.datumCode || "new_zealand_1949" === a.datumCode) && (a.datumCode = "nzgd49"), "wgs_1984" === a.datumCode && ("Mercator_Auxiliary_Sphere" === a.PROJECTION && (a.sphere = !0), a.datumCode = "wgs84"), "_ferro" === a.datumCode.slice(-6) && (a.datumCode = a.datumCode.slice(0, -6)), "_jakarta" === a.datumCode.slice(-8) && (a.datumCode = a.datumCode.slice(0, -8)), ~a.datumCode.indexOf("belge") && (a.datumCode = "rnb72"), a.GEOGCS.DATUM && a.GEOGCS.DATUM.SPHEROID && (a.ellps = a.GEOGCS.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === a.ellps.toLowerCase().slice(0, 13) && (a.ellps = "intl"), a.a = a.GEOGCS.DATUM.SPHEROID.a, a.rf = parseFloat(a.GEOGCS.DATUM.SPHEROID.rf, 10)), ~a.datumCode.indexOf("osgb_1936") && (a.datumCode = "osgb36")), a.b && !isFinite(a.b) && (a.b = a.a);
        var c = function(b) {
            return f(a, b)
          },
          d = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["false_easting", "False_Easting"],
            ["false_northing", "False_Northing"],
            ["central_meridian", "Central_Meridian"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", g],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longc", "longitude_of_center", g],
            ["x0", "false_easting", b],
            ["y0", "false_northing", b],
            ["long0", "central_meridian", g],
            ["lat0", "latitude_of_origin", g],
            ["lat0", "standard_parallel_1", g],
            ["lat1", "standard_parallel_1", g],
            ["lat2", "standard_parallel_2", g],
            ["alpha", "azimuth", g],
            ["srsCode", "name"]
          ];
        d.forEach(c), a.long0 || !a.longc || "Albers_Conic_Equal_Area" !== a.projName && "Lambert_Azimuthal_Equal_Area" !== a.projName || (a.long0 = a.longc), a.lat_ts || !a.lat1 || "Stereographic_South_Pole" !== a.projName && "Polar Stereographic (variant B)" !== a.projName || (a.lat0 = g(a.lat1 > 0 ? 90 : -90), a.lat_ts = a.lat1)
      }
      var i = .017453292519943295,
        j = a("./extend");
      b.exports = function(a, b) {
        var c = JSON.parse(("," + a).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, "")),
          d = c.shift(),
          f = c.shift();
        c.unshift(["name", f]), c.unshift(["type", d]), c.unshift("output");
        var g = {};
        return e(c, g), h(g.output), j(b, g.output)
      }
    }, {
      "./extend": 34
    }],
    67: [function(a, b, c) {
      function d(a) {
        return a * (Math.PI / 180)
      }

      function e(a) {
        return 180 * (a / Math.PI)
      }

      function f(a) {
        var b, c, e, f, g, i, j, k, l, m = a.lat,
          n = a.lon,
          o = 6378137,
          p = .00669438,
          q = .9996,
          r = d(m),
          s = d(n);
        l = Math.floor((n + 180) / 6) + 1, 180 === n && (l = 60), m >= 56 && 64 > m && n >= 3 && 12 > n && (l = 32), m >= 72 && 84 > m && (n >= 0 && 9 > n ? l = 31 : n >= 9 && 21 > n ? l = 33 : n >= 21 && 33 > n ? l = 35 : n >= 33 && 42 > n && (l = 37)), b = 6 * (l - 1) - 180 + 3, k = d(b), c = p / (1 - p), e = o / Math.sqrt(1 - p * Math.sin(r) * Math.sin(r)), f = Math.tan(r) * Math.tan(r), g = c * Math.cos(r) * Math.cos(r), i = Math.cos(r) * (s - k), j = o * ((1 - p / 4 - 3 * p * p / 64 - 5 * p * p * p / 256) * r - (3 * p / 8 + 3 * p * p / 32 + 45 * p * p * p / 1024) * Math.sin(2 * r) + (15 * p * p / 256 + 45 * p * p * p / 1024) * Math.sin(4 * r) - 35 * p * p * p / 3072 * Math.sin(6 * r));
        var t = q * e * (i + (1 - f + g) * i * i * i / 6 + (5 - 18 * f + f * f + 72 * g - 58 * c) * i * i * i * i * i / 120) + 5e5,
          u = q * (j + e * Math.tan(r) * (i * i / 2 + (5 - f + 9 * g + 4 * g * g) * i * i * i * i / 24 + (61 - 58 * f + f * f + 600 * g - 330 * c) * i * i * i * i * i * i / 720));
        return 0 > m && (u += 1e7), {
          northing: Math.round(u),
          easting: Math.round(t),
          zoneNumber: l,
          zoneLetter: h(m)
        }
      }

      function g(a) {
        var b = a.northing,
          c = a.easting,
          d = a.zoneLetter,
          f = a.zoneNumber;
        if (0 > f || f > 60) return null;
        var h, i, j, k, l, m, n, o, p, q, r = .9996,
          s = 6378137,
          t = .00669438,
          u = (1 - Math.sqrt(1 - t)) / (1 + Math.sqrt(1 - t)),
          v = c - 5e5,
          w = b;
        "N" > d && (w -= 1e7), o = 6 * (f - 1) - 180 + 3, h = t / (1 - t), n = w / r, p = n / (s * (1 - t / 4 - 3 * t * t / 64 - 5 * t * t * t / 256)), q = p + (3 * u / 2 - 27 * u * u * u / 32) * Math.sin(2 * p) + (21 * u * u / 16 - 55 * u * u * u * u / 32) * Math.sin(4 * p) + 151 * u * u * u / 96 * Math.sin(6 * p), i = s / Math.sqrt(1 - t * Math.sin(q) * Math.sin(q)), j = Math.tan(q) * Math.tan(q), k = h * Math.cos(q) * Math.cos(q), l = s * (1 - t) / Math.pow(1 - t * Math.sin(q) * Math.sin(q), 1.5), m = v / (i * r);
        var x = q - i * Math.tan(q) / l * (m * m / 2 - (5 + 3 * j + 10 * k - 4 * k * k - 9 * h) * m * m * m * m / 24 + (61 + 90 * j + 298 * k + 45 * j * j - 252 * h - 3 * k * k) * m * m * m * m * m * m / 720);
        x = e(x);
        var y = (m - (1 + 2 * j + k) * m * m * m / 6 + (5 - 2 * k + 28 * j - 3 * k * k + 8 * h + 24 * j * j) * m * m * m * m * m / 120) / Math.cos(q);
        y = o + e(y);
        var z;
        if (a.accuracy) {
          var A = g({
            northing: a.northing + a.accuracy,
            easting: a.easting + a.accuracy,
            zoneLetter: a.zoneLetter,
            zoneNumber: a.zoneNumber
          });
          z = {
            top: A.lat,
            right: A.lon,
            bottom: x,
            left: y
          }
        } else z = {
          lat: x,
          lon: y
        };
        return z
      }

      function h(a) {
        var b = "Z";
        return 84 >= a && a >= 72 ? b = "X" : 72 > a && a >= 64 ? b = "W" : 64 > a && a >= 56 ? b = "V" : 56 > a && a >= 48 ? b = "U" : 48 > a && a >= 40 ? b = "T" : 40 > a && a >= 32 ? b = "S" : 32 > a && a >= 24 ? b = "R" : 24 > a && a >= 16 ? b = "Q" : 16 > a && a >= 8 ? b = "P" : 8 > a && a >= 0 ? b = "N" : 0 > a && a >= -8 ? b = "M" : -8 > a && a >= -16 ? b = "L" : -16 > a && a >= -24 ? b = "K" : -24 > a && a >= -32 ? b = "J" : -32 > a && a >= -40 ? b = "H" : -40 > a && a >= -48 ? b = "G" : -48 > a && a >= -56 ? b = "F" : -56 > a && a >= -64 ? b = "E" : -64 > a && a >= -72 ? b = "D" : -72 > a && a >= -80 && (b = "C"), b
      }

      function i(a, b) {
        var c = "00000" + a.easting,
          d = "00000" + a.northing;
        return a.zoneNumber + a.zoneLetter + j(a.easting, a.northing, a.zoneNumber) + c.substr(c.length - 5, b) + d.substr(d.length - 5, b)
      }

      function j(a, b, c) {
        var d = k(c),
          e = Math.floor(a / 1e5),
          f = Math.floor(b / 1e5) % 20;
        return l(e, f, d)
      }

      function k(a) {
        var b = a % q;
        return 0 === b && (b = q), b
      }

      function l(a, b, c) {
        var d = c - 1,
          e = r.charCodeAt(d),
          f = s.charCodeAt(d),
          g = e + a - 1,
          h = f + b,
          i = !1;
        g > x && (g = g - x + t - 1, i = !0), (g === u || u > e && g > u || (g > u || u > e) && i) && g++, (g === v || v > e && g > v || (g > v || v > e) && i) && (g++, g === u && g++), g > x && (g = g - x + t - 1), h > w ? (h = h - w + t - 1, i = !0) : i = !1, (h === u || u > f && h > u || (h > u || u > f) && i) && h++, (h === v || v > f && h > v || (h > v || v > f) && i) && (h++, h === u && h++), h > w && (h = h - w + t - 1);
        var j = String.fromCharCode(g) + String.fromCharCode(h);
        return j
      }

      function m(a) {
        if (a && 0 === a.length) throw "MGRSPoint coverting from nothing";
        for (var b, c = a.length, d = null, e = "", f = 0; !/[A-Z]/.test(b = a.charAt(f));) {
          if (f >= 2) throw "MGRSPoint bad conversion from: " + a;
          e += b, f++
        }
        var g = parseInt(e, 10);
        if (0 === f || f + 3 > c) throw "MGRSPoint bad conversion from: " + a;
        var h = a.charAt(f++);
        if ("A" >= h || "B" === h || "Y" === h || h >= "Z" || "I" === h || "O" === h) throw "MGRSPoint zone letter " + h + " not handled: " + a;
        d = a.substring(f, f += 2);
        for (var i = k(g), j = n(d.charAt(0), i), l = o(d.charAt(1), i); l < p(h);) l += 2e6;
        var m = c - f;
        if (m % 2 !== 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + a;
        var q, r, s, t, u, v = m / 2,
          w = 0,
          x = 0;
        return v > 0 && (q = 1e5 / Math.pow(10, v), r = a.substring(f, f + v), w = parseFloat(r) * q, s = a.substring(f + v), x = parseFloat(s) * q), t = w + j, u = x + l, {
          easting: t,
          northing: u,
          zoneLetter: h,
          zoneNumber: g,
          accuracy: q
        }
      }

      function n(a, b) {
        for (var c = r.charCodeAt(b - 1), d = 1e5, e = !1; c !== a.charCodeAt(0);) {
          if (c++, c === u && c++, c === v && c++, c > x) {
            if (e) throw "Bad character: " + a;
            c = t, e = !0
          }
          d += 1e5
        }
        return d
      }

      function o(a, b) {
        if (a > "V") throw "MGRSPoint given invalid Northing " + a;
        for (var c = s.charCodeAt(b - 1), d = 0, e = !1; c !== a.charCodeAt(0);) {
          if (c++, c === u && c++, c === v && c++, c > w) {
            if (e) throw "Bad character: " + a;
            c = t, e = !0
          }
          d += 1e5
        }
        return d
      }

      function p(a) {
        var b;
        switch (a) {
          case "C":
            b = 11e5;
            break;
          case "D":
            b = 2e6;
            break;
          case "E":
            b = 28e5;
            break;
          case "F":
            b = 37e5;
            break;
          case "G":
            b = 46e5;
            break;
          case "H":
            b = 55e5;
            break;
          case "J":
            b = 64e5;
            break;
          case "K":
            b = 73e5;
            break;
          case "L":
            b = 82e5;
            break;
          case "M":
            b = 91e5;
            break;
          case "N":
            b = 0;
            break;
          case "P":
            b = 8e5;
            break;
          case "Q":
            b = 17e5;
            break;
          case "R":
            b = 26e5;
            break;
          case "S":
            b = 35e5;
            break;
          case "T":
            b = 44e5;
            break;
          case "U":
            b = 53e5;
            break;
          case "V":
            b = 62e5;
            break;
          case "W":
            b = 7e6;
            break;
          case "X":
            b = 79e5;
            break;
          default:
            b = -1
        }
        if (b >= 0) return b;
        throw "Invalid zone letter: " + a
      }
      var q = 6,
        r = "AJSAJS",
        s = "AFAFAF",
        t = 65,
        u = 73,
        v = 79,
        w = 86,
        x = 90;
      c.forward = function(a, b) {
        return b = b || 5, i(f({
          lat: a[1],
          lon: a[0]
        }), b)
      }, c.inverse = function(a) {
        var b = g(m(a.toUpperCase()));
        return b.lat && b.lon ? [b.lon, b.lat, b.lon, b.lat] : [b.left, b.bottom, b.right, b.top]
      }, c.toPoint = function(a) {
        var b = g(m(a.toUpperCase()));
        return b.lat && b.lon ? [b.lon, b.lat] : [(b.left + b.right) / 2, (b.top + b.bottom) / 2]
      }
    }, {}],
    68: [function(a, b, c) {
      b.exports = {
        name: "proj4",
        version: "2.3.12",
        description: "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
        main: "lib/index.js",
        directories: {
          test: "test",
          doc: "docs"
        },
        scripts: {
          test: "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
        },
        repository: {
          type: "git",
          url: "git://github.com/proj4js/proj4js.git"
        },
        author: "",
        license: "MIT",
        jam: {
          main: "dist/proj4.js",
          include: ["dist/proj4.js", "README.md", "AUTHORS", "LICENSE.md"]
        },
        devDependencies: {
          "grunt-cli": "~0.1.13",
          grunt: "~0.4.2",
          "grunt-contrib-connect": "~0.6.0",
          "grunt-contrib-jshint": "~0.8.0",
          chai: "~1.8.1",
          mocha: "~1.17.1",
          "grunt-mocha-phantomjs": "~0.4.0",
          browserify: "~3.24.5",
          "grunt-browserify": "~1.3.0",
          "grunt-contrib-uglify": "~0.3.2",
          curl: "git://github.com/cujojs/curl.git",
          istanbul: "~0.2.4",
          tin: "~0.4.0"
        },
        dependencies: {
          mgrs: "~0.0.2"
        }
      }
    }, {}],
    "./includedProjections": [function(a, b, c) {
      b.exports = a("hTEDpn")
    }, {}],
    hTEDpn: [function(a, b, c) {
      var d = [a("./lib/projections/tmerc"), a("./lib/projections/utm"), a("./lib/projections/sterea"), a("./lib/projections/stere"), a("./lib/projections/somerc"), a("./lib/projections/omerc"), a("./lib/projections/lcc"), a("./lib/projections/krovak"), a("./lib/projections/cass"), a("./lib/projections/laea"), a("./lib/projections/aea"), a("./lib/projections/gnom"), a("./lib/projections/cea"), a("./lib/projections/eqc"), a("./lib/projections/poly"), a("./lib/projections/nzmg"), a("./lib/projections/mill"), a("./lib/projections/sinu"), a("./lib/projections/moll"), a("./lib/projections/eqdc"), a("./lib/projections/vandg"), a("./lib/projections/aeqd")];
      b.exports = function(proj4) {
        d.forEach(function(a) {
          proj4.Proj.projections.add(a)
        })
      }
    }, {
      "./lib/projections/aea": 40,
      "./lib/projections/aeqd": 41,
      "./lib/projections/cass": 42,
      "./lib/projections/cea": 43,
      "./lib/projections/eqc": 44,
      "./lib/projections/eqdc": 45,
      "./lib/projections/gnom": 47,
      "./lib/projections/krovak": 48,
      "./lib/projections/laea": 49,
      "./lib/projections/lcc": 50,
      "./lib/projections/mill": 53,
      "./lib/projections/moll": 54,
      "./lib/projections/nzmg": 55,
      "./lib/projections/omerc": 56,
      "./lib/projections/poly": 57,
      "./lib/projections/sinu": 58,
      "./lib/projections/somerc": 59,
      "./lib/projections/stere": 60,
      "./lib/projections/sterea": 61,
      "./lib/projections/tmerc": 62,
      "./lib/projections/utm": 63,
      "./lib/projections/vandg": 64
    }]
  }, {}, [36])(36)
});;
(function(H) {
  "use strict";
  var isEdge = navigator.userAgent.indexOf('Edge/') > 0;
  var isMSIE11 = navigator.userAgent.indexOf('Trident/') > 0;
  var isMSBrowser = (window.isMSIE || isMSIE11 || isEdge);
  var plotOptions = H.getOptions().plotOptions;
  plotOptions.series = plotOptions.series || {};
  plotOptions.series.animation = !isMSBrowser;
  var legendOptions = H.getOptions().legend;
  legendOptions.symbolRadius = 0;
  H.SVGRenderer.prototype.getContrast = function(color) {
    color = H.Color(color).rgba;
    return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';
  };
  updateHighchartsWithMethodsFromVersion611(H);
}(Highcharts));

function updateHighchartsWithMethodsFromVersion611(Highcharts) {
  Highcharts.wrap(Highcharts.Axis.prototype, 'getPlotLinePath', function(proceed) {
    var path = proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    if (path) {
      path.flat = false;
    }
    return path;
  });
};
/*! RESOURCE: /scripts/reportcommon/hc_legend_extension.js */
(function extendHCLegend($, Highcharts) {
  var HIDDEN_SERIES = "hidden-series";
  Highcharts.wrap(Highcharts.Legend.prototype, 'init', function replaceDefaultLegendWithStatsTable(proceed, chart) {
    if (chart.options.legend.statsTable && chart.options.legend.statsTable.active)
      chart.options.legend.enabled = false;
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    if (!chart.options.legend.statsTable || !chart.options.legend.statsTable.active)
      return;
    chart.options.legend.height = 100;
    var $container = $(chart.container);
    var maxLegendWidth = chart.options.legend.width ? chart.options.legend.width : chart.options.chart.width - 10;
    var tableWidth = maxLegendWidth - 25;
    var expanded = false;
    var $htmlLegend = $('<div><table style="border-spacing: 0 !important;">' +
        '<thead>' +
        '<tr>' +
        '<th class="number">' +
        '</th>' +
        '<th class="symbol">' +
        '</th>' +
        '<th class="series-name"></th>' +
        '<th class="controls"></th>' +
        '<th class="max">Max</th>' +
        '<th class="min">Min</th>' +
        '<th class="average">Avg</th>' +
        '<th class="total">Total</th>' +
        '</tr>' +
        '</thead>' +
        '<tbody></tbody>' +
        '</table></div>')
      .addClass("stats-table")
      .css("max-width", maxLegendWidth)
      .css("height", chart.options.legend.height)
      .find('table')
      .css("max-width", tableWidth >= 450 ? tableWidth : 450)
      .css("min-width", 450)
      .end();
    var series = chart.series;
    for (var i = series.length - 1; i >= 0; i--) {
      var serie = series[i];
      $('<tr>' +
          '<td class="number"></td>' +
          '<td class="symbol">' +
          '<div class="symbol"></div>' +
          '</td>' +
          '<td class="series-name"></td>' +
          '<td class="controls">' +
          '<button class="hide-others btn btn-default btn-xs">Hide Others</button>' +
          '<button class="hide-self btn btn-default btn-xs">Hide Self</button>' +
          '</td>' +
          '<td class="max">' +
          '</td>' +
          '<td class="min">' +
          '</td>' +
          '<td class="average">' +
          '</td>' +
          '<td class="total">' +
          '</td>' +
          '</tr>')
        .find('td.number')
        .text(series.length - i + '.')
        .end()
        .find('td.series-name')
        .text(serie.name)
        .each(returnGenerateLinkIfDefined(serie))
        .end()
        .find('div.symbol')
        .css('background-color', serie.color)
        .end()
        .find('button.hide-others')
        .on('click', returnHideOtherSeries(serie))
        .end()
        .find('button.hide-self')
        .on('click', returnHideSelf(serie))
        .end()
        .find('td.max')
        .text(serie.options.max)
        .end()
        .find('td.min')
        .text(serie.options.min)
        .end()
        .find('td.average')
        .text(serie.options.average.toFixed(2))
        .end()
        .find('td.total')
        .text(serie.options.total)
        .end()
        .find('td.max, td.min, td.average, td.total')
        .each(returnAppendUnitIfDefined(serie))
        .end()
        .hover(returnHighlightSeries(serie), returnUnhighlightSeries(serie))
        .appendTo($htmlLegend.find('tbody'));
    }
    $container.after($htmlLegend);
  });

  function returnHideSelf(serie) {
    return function hideSelf(event) {
      var $thisRow = $(this).closest('tr');
      event.stopPropagation();
      serie.setVisible();
      if (serie.visible)
        $thisRow.removeClass(HIDDEN_SERIES);
      else
        $thisRow.addClass(HIDDEN_SERIES);
    }
  }

  function returnHideOtherSeries(serie) {
    return function hideOtherSeries(event) {
      event.stopPropagation();
      var series = serie.chart.series;
      var $this = $(this);
      var $thisRow = $(this).closest('tr');
      var $allRows = $this.closest('table').find('tr');
      if (serie.onlyVisible) {
        serie.onlyVisible = false;
        for (var i = 0; i < series.length; i++)
          series[i].setVisible(true, false);
      } else {
        serie.onlyVisible = true;
        for (var i = 0; i < series.length; i++) {
          var possiblyOurSeries = series[i];
          if (possiblyOurSeries !== serie) {
            possiblyOurSeries.setVisible(false, false);
            possiblyOurSeries.onlyVisible = false;
          } else
            possiblyOurSeries.setVisible(true, false);
        }
      }
      serie.chart.redraw();
      if (serie.onlyVisible) {
        $thisRow.removeClass(HIDDEN_SERIES);
        $allRows.not($thisRow).addClass(HIDDEN_SERIES);
      } else
        $allRows.removeClass(HIDDEN_SERIES);
    };
  }

  function returnHighlightSeries(serie) {
    return function higlightSeries() {
      serie.setState("hover");
    };
  }

  function returnUnhighlightSeries(serie) {
    return function higlightSeries() {
      serie.setState("");
    };
  }

  function returnGenerateLinkIfDefined(serie) {
    return function generateLinkIfDefined() {
      if (serie.chart.options.legend.statsTable.seriesLinkGenerator) {
        $(this).wrapInner('<a href="' + serie.chart.options.legend.statsTable.seriesLinkGenerator(serie) + '"></a>');
      }
    };
  }

  function returnAppendUnitIfDefined(serie) {
    return function appendUnitIfDefined() {
      var $this = $(this);
      if (serie.chart.options.legend.statsTable.unit) {
        $this.text($this.text() + serie.chart.options.legend.statsTable.unit);
      }
    };
  }
})(jQuery, Highcharts);;
/*! RESOURCE: /scripts/reportcommon/hc_angular_chart_size_fix.js */
(function(H) {
  H.wrap(H.CenteredSeriesMixin, 'getCenter', function(p) {
    var chart = this.chart;
    var options = this.options;
    var maxSize;
    var center = p.apply(this, Array.prototype.slice.call(arguments, 1));
    if (options.startAngle === -90 && options.startAngle !== 90 && chart.series[0].angular) {
      if (chart.plotWidth > chart.plotHeight) {
        maxSize = chart.plotWidth > chart.plotHeight * 2 ? chart.plotHeight * 2 : chart.plotWidth;
        center[1] = H.relativeLength(options.center[1], maxSize);
        center[2] = H.relativeLength(options.size, maxSize);
      }
    }
    return center;
  });
})(Highcharts);;;