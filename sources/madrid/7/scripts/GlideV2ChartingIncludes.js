/*! RESOURCE: /scripts/GlideV2ChartingIncludes.js */
/*! RESOURCE: /scripts/lib/jquery2_includes.js */
/*! RESOURCE: /scripts/lib/jquery/jquery_clean.js */
(function() {
  if (!window.jQuery)
    return;
  if (!window.$j_glide)
    window.$j = jQuery.noConflict();
  if (window.$j_glide && jQuery != window.$j_glide) {
    if (window.$j_glide)
      jQuery.noConflict(true);
    window.$j = window.$j_glide;
  }
})();;
/*! RESOURCE: /scripts/lib/jquery/jquery-2.2.3.min.js */
/*! jQuery v2.2.3 | (c) jQuery Foundation | jquery.org/license */
! function(a, b) {
  "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = a.document,
    e = c.slice,
    f = c.concat,
    g = c.push,
    h = c.indexOf,
    i = {},
    j = i.toString,
    k = i.hasOwnProperty,
    l = {},
    m = "2.2.3",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return e.call(this)
    },
    get: function(a) {
      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a) {
      return n.each(this, a)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(e.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 > a ? b : 0);
      return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor()
    },
    push: g,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
      if (null != (a = arguments[h]))
        for (b in a) c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray,
    isWindow: function(a) {
      return null != a && a === a.window
    },
    isNumeric: function(a) {
      var b = a && a.toString();
      return !n.isArray(a) && b - parseFloat(b) + 1 >= 0
    },
    isPlainObject: function(a) {
      var b;
      if ("object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;
      if (a.constructor && !k.call(a, "constructor") && !k.call(a.constructor.prototype || {}, "isPrototypeOf")) return !1;
      for (b in a);
      return void 0 === b || k.call(a, b)
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? i[j.call(a)] || "object" : typeof a
    },
    globalEval: function(a) {
      var b, c = eval;
      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = d.createElement("script"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a))
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b) {
      var c, d = 0;
      if (s(a)) {
        for (c = a.length; c > d; d++)
          if (b.call(a[d], d, a[d]) === !1) break
      } else
        for (d in a)
          if (b.call(a[d], d, a[d]) === !1) break;
      return a
    },
    trim: function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : g.call(c, a)), c
    },
    inArray: function(a, b, c) {
      return null == b ? -1 : h.call(b, a, c)
    },
    merge: function(a, b) {
      for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, e, g = 0,
        h = [];
      if (s(a))
        for (d = a.length; d > g; g++) e = b(a[g], g, c), null != e && h.push(e);
      else
        for (g in a) e = b(a[g], g, c), null != e && h.push(e);
      return f.apply([], h)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, d, f;
      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function() {
        return a.apply(b || this, d.concat(e.call(arguments)))
      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0
    },
    now: Date.now,
    support: l
  }), "function" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
    i["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = !!a && "length" in a && a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date,
      v = a.document,
      w = 0,
      x = 0,
      y = ga(),
      z = ga(),
      A = ga(),
      B = function(a, b) {
        return a === b && (l = !0), 0
      },
      C = 1 << 31,
      D = {}.hasOwnProperty,
      E = [],
      F = E.pop,
      G = E.push,
      H = E.push,
      I = E.slice,
      J = function(a, b) {
        for (var c = 0, d = a.length; d > c; c++)
          if (a[c] === b) return c;
        return -1
      },
      K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      L = "[\\x20\\t\\r\\n\\f]",
      M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      N = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + M + "))|)" + L + "*\\]",
      O = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + N + ")*)|.*)\\)|)",
      P = new RegExp(L + "+", "g"),
      Q = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
      R = new RegExp("^" + L + "*," + L + "*"),
      S = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
      T = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
      U = new RegExp(O),
      V = new RegExp("^" + M + "$"),
      W = {
        ID: new RegExp("^#(" + M + ")"),
        CLASS: new RegExp("^\\.(" + M + ")"),
        TAG: new RegExp("^(" + M + "|[*])"),
        ATTR: new RegExp("^" + N),
        PSEUDO: new RegExp("^" + O),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + K + ")$", "i"),
        needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
      },
      X = /^(?:input|select|textarea|button)$/i,
      Y = /^h\d$/i,
      Z = /^[^{]+\{\s*\[native \w/,
      $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      _ = /[+~]/,
      aa = /'|\\/g,
      ba = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
      ca = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
      },
      da = function() {
        m()
      };
    try {
      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType
    } catch (ea) {
      H = {
        apply: E.length ? function(a, b) {
          G.apply(a, I.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function fa(a, b, d, e) {
      var f, h, j, k, l, o, r, s, w = b && b.ownerDocument,
        x = b ? b.nodeType : 9;
      if (d = d || [], "string" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;
      if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {
        if (11 !== x && (o = $.exec(a)))
          if (f = o[1]) {
            if (9 === x) {
              if (!(j = b.getElementById(f))) return d;
              if (j.id === f) return d.push(j), d
            } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d
          } else {
            if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;
            if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d
          } if (c.qsa && !A[a + " "] && (!q || !q.test(a))) {
          if (1 !== x) w = b, s = a;
          else if ("object" !== b.nodeName.toLowerCase()) {
            (k = b.getAttribute("id")) ? k = k.replace(aa, "\\$&"): b.setAttribute("id", k = u), r = g(a), h = r.length, l = V.test(k) ? "#" + k : "[id='" + k + "']";
            while (h--) r[h] = l + " " + qa(r[h]);
            s = r.join(","), w = _.test(a) && oa(b.parentNode) || b
          }
          if (s) try {
            return H.apply(d, w.querySelectorAll(s)), d
          } catch (y) {} finally {
            k === u && b.removeAttribute("id")
          }
        }
      }
      return i(a.replace(Q, "$1"), b, d, e)
    }

    function ga() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function ha(a) {
      return a[u] = !0, a
    }

    function ia(a) {
      var b = n.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode && b.parentNode.removeChild(b), b = null
      }
    }

    function ja(a, b) {
      var c = a.split("|"),
        e = c.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function ka(a, b) {
      var c = b && a,
        d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function la(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c && b.type === a
      }
    }

    function ma(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) && b.type === a
      }
    }

    function na(a) {
      return ha(function(b) {
        return b = +b, ha(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function oa(a) {
      return a && "undefined" != typeof a.getElementsByTagName && a
    }
    c = fa.support = {}, f = fa.isXML = function(a) {
      var b = a && (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, m = fa.setDocument = function(a) {
      var b, e, g = a ? a.ownerDocument || a : v;
      return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ia(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = ia(function(a) {
        return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function(a) {
        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if ("undefined" != typeof b.getElementById && p) {
          var c = b.getElementById(a);
          return c ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(ba, ca);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(ba, ca);
        return function(a) {
          var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
          return c && c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType && d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
        return "undefined" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0
      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function(a) {
        o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
      }), ia(function(a) {
        var b = n.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function(a) {
        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", O)
      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b && b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, B = b ? function(a, b) {
        if (a === b) return l = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return l = !0, 0;
        var c, d = 0,
          e = a.parentNode,
          f = b.parentNode,
          g = [a],
          h = [b];
        if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
        if (e === f) return ka(a, b);
        c = a;
        while (c = c.parentNode) g.unshift(c);
        c = b;
        while (c = c.parentNode) h.unshift(c);
        while (g[d] === h[d]) d++;
        return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0
      }, n) : n
    }, fa.matches = function(a, b) {
      return fa(a, null, null, b)
    }, fa.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try {
        var d = s.call(a, b);
        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
      } catch (e) {}
      return fa(b, n, null, [a]).length > 0
    }, fa.contains = function(a, b) {
      return (a.ownerDocument || a) !== n && m(a), t(a, b)
    }, fa.attr = function(a, b) {
      (a.ownerDocument || a) !== n && m(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
      return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
    }, fa.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, fa.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
        while (b = a[f++]) b === a[f] && (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return k = null, a
    }, e = fa.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = fa.selectors = {
      cacheLength: 50,
      createPseudo: ha,
      match: W,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || "").replace(ba, ca), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fa.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[6] && a[2];
          return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(ba, ca).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName && a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = y[a + " "];
          return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = fa.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(P, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d && 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h && b.nodeName.toLowerCase(),
              s = !i && !h,
              t = !1;
            if (q) {
              if (f) {
                while (p) {
                  m = b;
                  while (m = m[p])
                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
                  o = p = "only" === a && !o && "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g && s) {
                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];
                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                  if (1 === m.nodeType && ++t && m === b) {
                    k[a] = [w, n, t];
                    break
                  }
              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1)
                while (m = ++n && m && m[p] || (t = n = 0) || o.pop())
                  if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;
              return t -= e, t === d || t % d === 0 && t / d >= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error("unsupported pseudo: " + a);
          return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: ha(function(a) {
          var b = [],
            c = [],
            d = h(a.replace(Q, "$1"));
          return d[u] ? ha(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
          }
        }),
        has: ha(function(a) {
          return function(b) {
            return fa(a, b).length > 0
          }
        }),
        contains: ha(function(a) {
          return a = a.replace(ba, ca),
            function(b) {
              return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
            }
        }),
        lang: ha(function(a) {
          return V.test(a || "") || fa.error("unsupported lang: " + a), a = a.replace(ba, ca).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location && a.location.hash;
          return c && c.slice(1) === b.id
        },
        root: function(a) {
          return a === o
        },
        focus: function(a) {
          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && !!a.checked || "option" === b && !!a.selected
        },
        selected: function(a) {
          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType < 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return Y.test(a.nodeName)
        },
        input: function(a) {
          return X.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: na(function() {
          return [0]
        }),
        last: na(function(a, b) {
          return [b - 1]
        }),
        eq: na(function(a, b, c) {
          return [0 > c ? c + b : c]
        }),
        even: na(function(a, b) {
          for (var c = 0; b > c; c += 2) a.push(c);
          return a
        }),
        odd: na(function(a, b) {
          for (var c = 1; b > c; c += 2) a.push(c);
          return a
        }),
        lt: na(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);
          return a
        }),
        gt: na(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = la(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = ma(b);

    function pa() {}
    pa.prototype = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function(a, b) {
      var c, e, f, g, h, i, j, k = z[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(Q, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? fa.error(a) : z(a, i).slice(0)
    };

    function qa(a) {
      for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
      return d
    }

    function ra(a, b, c) {
      var d = b.dir,
        e = c && "parentNode" === d,
        f = x++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j, k = [w, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) && a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];
              if (i[d] = k, k[2] = a(b, c, g)) return !0
            }
      }
    }

    function sa(a) {
      return a.length > 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function ta(a, b, c) {
      for (var d = 0, e = b.length; e > d; d++) fa(a, b[d], c);
      return c
    }

    function ua(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
      return g
    }

    function va(a, b, c, d, e, f) {
      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || ta(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f && b ? p : ua(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c && c(q, r, h, i), d) {
          j = ua(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) && j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
          }
        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r)
      })
    }

    function wa(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ra(function(a) {
          return a === b
        }, h, !0), l = ra(function(a) {
          return J(b, a) > -1
        }, h, !0), m = [function(a, c, d) {
          var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
          return b = null, e
        }]; f > i; i++)
        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];
        else {
          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
            for (e = ++i; f > e; e++)
              if (d.relative[a[e].type]) break;
            return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({
              value: " " === a[i - 2].type ? "*" : ""
            })).replace(Q, "$1"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a))
          }
          m.push(c)
        } return sa(m)
    }

    function xa(a, b) {
      var c = b.length > 0,
        e = a.length > 0,
        f = function(f, g, h, i, k) {
          var l, o, q, r = 0,
            s = "0",
            t = f && [],
            u = [],
            v = j,
            x = f || e && d.find.TAG("*", k),
            y = w += null == v ? 1 : Math.random() || .1,
            z = x.length;
          for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {
            if (e && l) {
              o = 0, g || l.ownerDocument === n || (m(l), h = !p);
              while (q = a[o++])
                if (q(l, g || n, h)) {
                  i.push(l);
                  break
                } k && (w = y)
            }
            c && ((l = !q && l) && r--, f && t.push(l))
          }
          if (r += s, c && s !== r) {
            o = 0;
            while (q = b[o++]) q(t, u, g, h);
            if (f) {
              if (r > 0)
                while (s--) t[s] || u[s] || (u[s] = F.call(i));
              u = ua(u)
            }
            H.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i)
          }
          return k && (w = y, j = v), t
        };
      return c ? ha(f) : f
    }
    return h = fa.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = A[a + " "];
      if (!f) {
        b || (b = g(a)), c = b.length;
        while (c--) f = wa(b[c]), f[u] ? d.push(f) : e.push(f);
        f = A(a, xa(e, d)), f.selector = a
      }
      return f
    }, i = fa.select = function(a, b, e, f) {
      var i, j, k, l, m, n = "function" == typeof a && a,
        o = !f && g(a = n.selector || a);
      if (e = e || [], 1 === o.length) {
        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;
          n && (b = b.parentNode), a = a.slice(j.shift().value.length)
        }
        i = W.needsContext.test(a) ? 0 : j.length;
        while (i--) {
          if (k = j[i], d.relative[l = k.type]) break;
          if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {
            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;
            break
          }
        }
      }
      return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e
    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function(a) {
      return 1 & a.compareDocumentPosition(n.createElement("div"))
    }), ia(function(a) {
      return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
    }) || ja("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes && ia(function(a) {
      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || ja("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), ia(function(a) {
      return null == a.getAttribute("disabled")
    }) || ja(K, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
    }), fa
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = function(a, b, c) {
      var d = [],
        e = void 0 !== c;
      while ((a = a[b]) && 9 !== a.nodeType)
        if (1 === a.nodeType) {
          if (e && n(a).is(c)) break;
          d.push(a)
        } return d
    },
    v = function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
      return c
    },
    w = n.expr.match.needsContext,
    x = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
    y = /^.[^:#\[\.,]*$/;

  function z(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (y.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return h.call(b, a) > -1 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = this.length,
        d = [],
        e = this;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; c > b; b++)
          if (n.contains(e[b], this)) return !0
      }));
      for (b = 0; c > b; b++) n.find(a, e[b], d);
      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d
    },
    filter: function(a) {
      return this.pushStack(z(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(z(this, a || [], !0))
    },
    is: function(a) {
      return !!z(this, "string" == typeof a && w.test(a) ? n(a) : a || [], !1).length
    }
  });
  var A, B = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    C = n.fn.init = function(a, b, c) {
      var e, f;
      if (!a) return this;
      if (c = c || A, "string" == typeof a) {
        if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
        if (e[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b))
            for (e in b) n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);
          return this
        }
        return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  C.prototype = n.fn, A = n(d);
  var D = /^(?:parents|prev(?:Until|All))/,
    E = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.fn.extend({
    has: function(a) {
      var b = n(a, this),
        c = b.length;
      return this.filter(function() {
        for (var a = 0; c > a; a++)
          if (n.contains(this, b[a])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)
        for (c = this[d]; c && c !== b; c = c.parentNode)
          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          } return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function F(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b && 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return u(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return u(a, "parentNode", c)
    },
    next: function(a) {
      return F(a, "nextSibling")
    },
    prev: function(a) {
      return F(a, "previousSibling")
    },
    nextAll: function(a) {
      return u(a, "nextSibling")
    },
    prevAll: function(a) {
      return u(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return u(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return u(a, "previousSibling", c)
    },
    siblings: function(a) {
      return v((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return v(a.firstChild)
    },
    contents: function(a) {
      return a.contentDocument || n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e)
    }
  });
  var G = /\S+/g;

  function H(a) {
    var b = {};
    return n.each(a.match(G) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? H(a) : n.extend({}, a);
    var b, c, d, e, f = [],
      g = [],
      h = -1,
      i = function() {
        for (e = a.once, d = b = !0; g.length; h = -1) {
          c = g.shift();
          while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1)
        }
        a.memory || (c = !1), b = !1, e && (f = c ? [] : "")
      },
      j = {
        add: function() {
          return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {
            n.each(b, function(b, c) {
              n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== n.type(c) && d(c)
            })
          }(arguments), c && !b && i()), this
        },
        remove: function() {
          return n.each(arguments, function(a, b) {
            var c;
            while ((c = n.inArray(b, f, c)) > -1) f.splice(c, 1), h >= c && h--
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, f) > -1 : f.length > 0
        },
        empty: function() {
          return f && (f = []), this
        },
        disable: function() {
          return e = g = [], f = c = "", this
        },
        disabled: function() {
          return !f
        },
        lock: function() {
          return e = g = [], c || (f = c = ""), this
        },
        locked: function() {
          return !!e
        },
        fireWith: function(a, c) {
          return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this
        },
        fire: function() {
          return j.fireWith(this, arguments), this
        },
        fired: function() {
          return !!d
        }
      };
    return j
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) && a[b];
                e[f[1]](function() {
                  var a = g && g.apply(this, arguments);
                  a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h && g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a && a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = e.call(arguments),
        d = c.length,
        f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(d) {
            b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (d > 1)
        for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var I;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler("ready"), n(d).off("ready"))))
    }
  });

  function J() {
    d.removeEventListener("DOMContentLoaded", J), a.removeEventListener("load", J), n.ready()
  }
  n.ready.promise = function(b) {
    return I || (I = n.Deferred(), "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener("DOMContentLoaded", J), a.addEventListener("load", J))), I.promise(b)
  }, n.ready.promise();
  var K = function(a, b, c, d, e, f, g) {
      var h = 0,
        i = a.length,
        j = null == c;
      if ("object" === n.type(c)) {
        e = !0;
        for (h in c) K(a, b, h, c[h], !0, f, g)
      } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
          return j.call(n(a), c)
        })), b))
        for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
      return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
    },
    L = function(a) {
      return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
    };

  function M() {
    this.expando = n.expando + M.uid++
  }
  M.uid = 1, M.prototype = {
    register: function(a, b) {
      var c = b || {};
      return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, {
        value: c,
        writable: !0,
        configurable: !0
      }), a[this.expando]
    },
    cache: function(a) {
      if (!L(a)) return {};
      var b = a[this.expando];
      return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
        value: b,
        configurable: !0
      }))), b
    },
    set: function(a, b, c) {
      var d, e = this.cache(a);
      if ("string" == typeof b) e[b] = c;
      else
        for (d in b) e[d] = b[d];
      return e
    },
    get: function(a, b) {
      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b]
    },
    access: function(a, b, c) {
      var d;
      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)
    },
    remove: function(a, b) {
      var c, d, e, f = a[this.expando];
      if (void 0 !== f) {
        if (void 0 === b) this.register(a);
        else {
          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;
          while (c--) delete f[d[c]]
        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
      }
    },
    hasData: function(a) {
      var b = a[this.expando];
      return void 0 !== b && !n.isEmptyObject(b)
    }
  };
  var N = new M,
    O = new M,
    P = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    Q = /[A-Z]/g;

  function R(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType)
      if (d = "data-" + b.replace(Q, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : P.test(c) ? n.parseJSON(c) : c;
        } catch (e) {}
        O.set(a, b, c)
      } else c = void 0;
    return c
  }
  n.extend({
    hasData: function(a) {
      return O.hasData(a) || N.hasData(a)
    },
    data: function(a, b, c) {
      return O.access(a, b, c)
    },
    removeData: function(a, b) {
      O.remove(a, b)
    },
    _data: function(a, b, c) {
      return N.access(a, b, c)
    },
    _removeData: function(a, b) {
      N.remove(a, b)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f && f.attributes;
      if (void 0 === a) {
        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, "hasDataAttrs"))) {
          c = g.length;
          while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));
          N.set(f, "hasDataAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        O.set(this, a)
      }) : K(this, function(b) {
        var c, d;
        if (f && void 0 === b) {
          if (c = O.get(f, a) || O.get(f, a.replace(Q, "-$&").toLowerCase()), void 0 !== c) return c;
          if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;
          if (c = R(f, d, void 0), void 0 !== c) return c
        } else d = n.camelCase(a), this.each(function() {
          var c = O.get(this, d);
          O.set(this, d, b), a.indexOf("-") > -1 && void 0 !== c && O.set(this, a, b)
        })
      }, null, b, arguments.length > 1, null, !0)
    },
    removeData: function(a) {
      return this.each(function() {
        O.remove(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return N.get(a, c) || N.access(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          N.remove(a, [b + "queue", c])
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a && (b = a, a = void 0), a = a || "fx";
      while (g--) c = N.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    T = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"),
    U = ["Top", "Right", "Bottom", "Left"],
    V = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    };

  function W(a, b, c, d) {
    var e, f = 1,
      g = 20,
      h = d ? function() {
        return d.cur()
      } : function() {
        return n.css(a, b, "")
      },
      i = h(),
      j = c && c[3] || (n.cssNumber[b] ? "" : "px"),
      k = (n.cssNumber[b] || "px" !== j && +i) && T.exec(n.css(a, b));
    if (k && k[3] !== j) {
      j = j || k[3], c = c || [], k = +i || 1;
      do f = f || ".5", k /= f, n.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
    }
    return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
  }
  var X = /^(?:checkbox|radio)$/i,
    Y = /<([\w:-]+)/,
    Z = /^$|\/(?:java|ecma)script/i,
    $ = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
  $.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;

  function _(a, b) {
    var c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c
  }

  function aa(a, b) {
    for (var c = 0, d = a.length; d > c; c++) N.set(a[c], "globalEval", !b || N.get(b[c], "globalEval"))
  }
  var ba = /<|&#?\w+;/;

  function ca(a, b, c, d, e) {
    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++)
      if (f = a[o], f || 0 === f)
        if ("object" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);
        else if (ba.test(f)) {
      g = g || l.appendChild(b.createElement("div")), h = (Y.exec(f) || ["", ""])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];
      while (k--) g = g.lastChild;
      n.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
    } else m.push(b.createTextNode(f));
    l.textContent = "", o = 0;
    while (f = m[o++])
      if (d && n.inArray(f, d) > -1) e && e.push(f);
      else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), "script"), j && aa(g), c) {
      k = 0;
      while (f = g[k++]) Z.test(f.type || "") && c.push(f)
    }
    return l
  }! function() {
    var a = d.createDocumentFragment(),
      b = a.appendChild(d.createElement("div")),
      c = d.createElement("input");
    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
  }();
  var da = /^key/,
    ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    fa = /^([^.]*)(?:\.(.+)|)/;

  function ga() {
    return !0
  }

  function ha() {
    return !1
  }

  function ia() {
    try {
      return d.activeElement
    } catch (a) {}
  }

  function ja(a, b, c, d, e, f) {
    var g, h;
    if ("object" == typeof b) {
      "string" != typeof c && (d = d || c, c = void 0);
      for (h in b) ja(a, h, c, d, b[h], f);
      return a
    }
    if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;
    else if (!e) return a;
    return 1 === f && (g = e, e = function(a) {
      return n().off(a), g.apply(this, arguments)
    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function() {
      n.event.add(this, b, e, d, c)
    })
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = N.get(a);
      if (r) {
        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {
          return "undefined" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0
        }), b = (b || "").match(G) || [""], j = b.length;
        while (j--) h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e && n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0)
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = N.hasData(a) && N.get(a);
      if (r && (i = r.events)) {
        b = (b || "").match(G) || [""], j = b.length;
        while (j--)
          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
            while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o])
          } else
            for (o in i) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(i) && N.remove(a, "handle events")
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, d, f, g, h = [],
        i = e.call(arguments),
        j = (N.get(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) && !a.isPropagationStopped()) {
          a.currentTarget = f.elem, c = 0;
          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch && k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1))
        for (; i !== this; i = i.parentNode || this)
          if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
            for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);
            d.length && g.push({
              elem: i,
              handlers: d
            })
          } return h < b.length && g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, e, f, g = b.button;
        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a
      }
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, e, f = a.type,
        g = a,
        h = this.fixHooks[f];
      h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;
      while (b--) c = e[b], a[c] = g[c];
      return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          return this !== ia() && this.focus ? (this.focus(), !1) : void 0
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === ia() && this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
        }
      }
    }
  }, n.removeEvent = function(a, b, c) {
    a.removeEventListener && a.removeEventListener(b, c)
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    constructor: n.Event,
    isDefaultPrevented: ha,
    isPropagationStopped: ha,
    isImmediatePropagationStopped: ha,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = ga, a && a.preventDefault()
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = ga, a && a.stopPropagation()
    },
    stopImmediatePropagation: function() {
      var a = this.originalEvent;
      this.isImmediatePropagationStopped = ga, a && a.stopImmediatePropagation(), this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d) {
      return ja(this, a, b, c, d)
    },
    one: function(a, b, c, d) {
      return ja(this, a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    }
  });
  var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    la = /<script|<style|<link/i,
    ma = /checked\s*(?:[^=]|=\s*.checked.)/i,
    na = /^true\/(.*)/,
    oa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function pa(a, b) {
    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function qa(a) {
    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
  }

  function ra(a) {
    var b = na.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function sa(a, b) {
    var c, d, e, f, g, h, i, j;
    if (1 === b.nodeType) {
      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {
        delete g.handle, g.events = {};
        for (e in j)
          for (c = 0, d = j[e].length; d > c; c++) n.event.add(b, e, j[e][c])
      }
      O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i))
    }
  }

  function ta(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && X.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
  }

  function ua(a, b, c, d) {
    b = f.apply([], b);
    var e, g, h, i, j, k, m = 0,
      o = a.length,
      p = o - 1,
      q = b[0],
      r = n.isFunction(q);
    if (r || o > 1 && "string" == typeof q && !l.checkClone && ma.test(q)) return a.each(function(e) {
      var f = a.eq(e);
      r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d)
    });
    if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {
      for (h = n.map(_(e, "script"), qa), i = h.length; o > m; m++) j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, "script"))), c.call(a[m], j, m);
      if (i)
        for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) j = h[m], Z.test(j.type || "") && !N.access(j, "globalEval") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, "")))
    }
    return a
  }

  function va(a, b, c) {
    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, "script")), d.parentNode.removeChild(d));
    return a
  }
  n.extend({
    htmlPrefilter: function(a) {
      return a.replace(ka, "<$1></$2>")
    },
    clone: function(a, b, c) {
      var d, e, f, g, h = a.cloneNode(!0),
        i = n.contains(a.ownerDocument, a);
      if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))
        for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) ta(f[d], g[d]);
      if (b)
        if (c)
          for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) sa(f[d], g[d]);
        else sa(a, h);
      return g = _(h, "script"), g.length > 0 && aa(g, !i && _(a, "script")), h
    },
    cleanData: function(a) {
      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++)
        if (L(c)) {
          if (b = c[N.expando]) {
            if (b.events)
              for (d in b.events) e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
            c[N.expando] = void 0
          }
          c[O.expando] && (c[O.expando] = void 0)
        }
    }
  }), n.fn.extend({
    domManip: ua,
    detach: function(a) {
      return va(this, a, !0)
    },
    remove: function(a) {
      return va(this, a)
    },
    text: function(a) {
      return K(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().each(function() {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
        })
      }, null, a, arguments.length)
    },
    append: function() {
      return ua(this, arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = pa(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return ua(this, arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = pa(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return ua(this, arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return ua(this, arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = "");
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return K(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
        if ("string" == typeof a && !la.test(a) && !$[(Y.exec(a) || ["", ""])[1].toLowerCase()]) {
          a = n.htmlPrefilter(a);
          try {
            for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b && this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = [];
      return ua(this, arguments, function(b) {
        var c = this.parentNode;
        n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this))
      }, a)
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());
      return this.pushStack(d)
    }
  });
  var wa, xa = {
    HTML: "block",
    BODY: "block"
  };

  function ya(a, b) {
    var c = n(b.createElement(a)).appendTo(b.body),
      d = n.css(c[0], "display");
    return c.detach(), d
  }

  function za(a) {
    var b = d,
      c = xa[a];
    return c || (c = ya(a, b), "none" !== c && c || (wa = (wa || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c
  }
  var Aa = /^margin/,
    Ba = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"),
    Ca = function(b) {
      var c = b.ownerDocument.defaultView;
      return c && c.opener || (c = a), c.getComputedStyle(b)
    },
    Da = function(a, b, c, d) {
      var e, f, g = {};
      for (f in b) g[f] = a.style[f], a.style[f] = b[f];
      e = c.apply(a, d || []);
      for (f in b) a.style[f] = g[f];
      return e
    },
    Ea = d.documentElement;
  ! function() {
    var b, c, e, f, g = d.createElement("div"),
      h = d.createElement("div");
    if (h.style) {
      h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h);

      function i() {
        h.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", Ea.appendChild(g);
        var d = a.getComputedStyle(h);
        b = "1%" !== d.top, f = "2px" === d.marginLeft, c = "4px" === d.width, h.style.marginRight = "50%", e = "4px" === d.marginRight, Ea.removeChild(g)
      }
      n.extend(l, {
        pixelPosition: function() {
          return i(), b
        },
        boxSizingReliable: function() {
          return null == c && i(), c
        },
        pixelMarginRight: function() {
          return null == c && i(), e
        },
        reliableMarginLeft: function() {
          return null == c && i(), f
        },
        reliableMarginRight: function() {
          var b, c = h.appendChild(d.createElement("div"));
          return c.style.cssText = h.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", h.style.width = "1px", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b
        }
      })
    }
  }();

  function Fa(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + "" : g
  }

  function Ga(a, b) {
    return {
      get: function() {
        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }
  var Ha = /^(none|table(?!-c[ea]).+)/,
    Ia = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Ja = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    Ka = ["Webkit", "O", "Moz", "ms"],
    La = d.createElement("div").style;

  function Ma(a) {
    if (a in La) return a;
    var b = a[0].toUpperCase() + a.slice(1),
      c = Ka.length;
    while (c--)
      if (a = Ka[c] + b, a in La) return a
  }

  function Na(a, b, c) {
    var d = T.exec(b);
    return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
  }

  function Oa(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g
  }

  function Pa(b, c, e) {
    var f = !0,
      g = "width" === c ? b.offsetWidth : b.offsetHeight,
      h = Ca(b),
      i = "border-box" === n.css(b, "boxSizing", !1, h);
    if (d.msFullscreenElement && a.top !== a && b.getClientRects().length && (g = Math.round(100 * b.getBoundingClientRect()[c])), 0 >= g || null == g) {
      if (g = Fa(b, c, h), (0 > g || null == g) && (g = b.style[c]), Ba.test(g)) return g;
      f = i && (l.boxSizingReliable() || g === b.style[c]), g = parseFloat(g) || 0
    }
    return g + Oa(b, c, e || (i ? "border" : "content"), f, h) + "px"
  }

  function Qa(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = N.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && V(d) && (f[g] = N.access(d, "olddisplay", za(d.nodeName)))) : (e = V(d), "none" === c && e || N.set(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = Fa(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function(a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (n.cssNumber[h] ? "" : "px")), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0)
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), "normal" === e && b in Ja && (e = Ja[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? Ha.test(n.css(a, "display")) && 0 === a.offsetWidth ? Da(a, Ia, function() {
          return Pa(a, b, d)
        }) : Pa(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e, f = d && Ca(a),
          g = d && Oa(a, b, d, "border-box" === n.css(a, "boxSizing", !1, f), f);
        return g && (e = T.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g)
      }
    }
  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function(a, b) {
    return b ? (parseFloat(Fa(a, "marginLeft")) || a.getBoundingClientRect().left - Da(a, {
      marginLeft: 0
    }, function() {
      return a.getBoundingClientRect().left
    })) + "px" : void 0
  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function(a, b) {
    return b ? Da(a, {
      display: "inline-block"
    }, Fa, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, Aa.test(a) || (n.cssHooks[a + b].set = Na)
  }), n.fn.extend({
    css: function(a, b) {
      return K(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = Ca(a), e = b.length; e > g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length > 1)
    },
    show: function() {
      return Qa(this, !0)
    },
    hide: function() {
      return Qa(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function Ra(a, b, c, d, e) {
    return new Ra.prototype.init(a, b, c, d, e)
  }
  n.Tween = Ra, Ra.prototype = {
    constructor: Ra,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = Ra.propHooks[this.prop];
      return a && a.get ? a.get(this) : Ra.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = Ra.propHooks[this.prop];
      return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this
    }
  }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit)
      }
    }
  }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    },
    _default: "swing"
  }, n.fx = Ra.prototype.init, n.fx.step = {};
  var Sa, Ta, Ua = /^(?:toggle|show|hide)$/,
    Va = /queueHooks$/;

  function Wa() {
    return a.setTimeout(function() {
      Sa = void 0
    }), Sa = n.now()
  }

  function Xa(a, b) {
    var c, d = 0,
      e = {
        height: a
      };
    for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = U[d], e["margin" + c] = e["padding" + c] = a;
    return b && (e.opacity = e.width = a), e
  }

  function Ya(a, b, c) {
    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners["*"]), f = 0, g = e.length; g > f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function Za(a, b, c) {
    var d, e, f, g, h, i, j, k, l = this,
      m = {},
      o = a.style,
      p = a.nodeType && V(a),
      q = N.get(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, l.always(function() {
      l.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? N.get(a, "olddisplay") || za(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function() {
      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], Ua.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
          if ("show" !== e || !q || void 0 === q[d]) continue;
          p = !0
        }
        m[d] = q && q[d] || n.style(a, d)
      } else j = void 0;
    if (n.isEmptyObject(m)) "inline" === ("none" === j ? za(a.nodeName) : j) && (o.display = j);
    else {
      q ? "hidden" in q && (p = q.hidden) : q = N.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function() {
        n(a).hide()
      }), l.done(function() {
        var b;
        N.remove(a, "fxshow");
        for (b in m) n.style(a, b, m[b])
      });
      for (d in m) g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function $a(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function _a(a, b, c) {
    var d, e, f = 0,
      g = _a.prefilters.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {},
          easing: n.easing._default
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: Sa || Wa(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d > c; c++) j.tweens[c].run(1);
          return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for ($a(k, j.opts.specialEasing); g > f; f++)
      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;
    return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(_a, {
      tweeners: {
        "*": [function(a, b) {
          var c = this.createTween(a, b);
          return W(c.elem, a, T.exec(b), c), c
        }]
      },
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(G);
        for (var c, d = 0, e = a.length; e > d; d++) c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b)
      },
      prefilters: [Za],
      prefilter: function(a, b) {
        b ? _a.prefilters.unshift(a) : _a.prefilters.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a && "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c && b || n.isFunction(a) && a,
        duration: a,
        easing: c && b || b && !n.isFunction(b) && b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(V).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = _a(this, n.extend({}, a), f);
            (e || N.get(this, "finish")) && b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a && a + "queueHooks",
            f = n.timers,
            g = N.get(this);
          if (e) g[e] && g[e].stop && d(g[e]);
          else
            for (e in g) g[e] && g[e].stop && Va.test(e) && d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          !b && c || n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 && (a = a || "fx"), this.each(function() {
          var b, c = N.get(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: Xa("show"),
      slideUp: Xa("hide"),
      slideToggle: Xa("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = 0,
        c = n.timers;
      for (Sa = n.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
      c.length || n.fx.stop(), Sa = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      a.clearInterval(Ta), Ta = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(b, c) {
      return b = n.fx ? n.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
        var e = a.setTimeout(c, b);
        d.stop = function() {
          a.clearTimeout(e)
        }
      })
    },
    function() {
      var a = d.createElement("input"),
        b = d.createElement("select"),
        c = b.appendChild(d.createElement("option"));
      a.type = "checkbox", l.checkOn = "" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement("input"), a.value = "t", a.type = "radio", l.radioValue = "t" === a.value
    }();
  var ab, bb = n.expr.attrHandle;
  n.fn.extend({
    attr: function(a, b) {
      return K(this, n.attr, a, b, arguments.length > 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d))
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c && (a.value = c), b
          }
        }
      }
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b && b.match(G);
      if (f && 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)
    }
  }), ab = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = bb[b] || n.find.attr;
    bb[b] = function(a, b, d) {
      var e, f;
      return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e
    }
  });
  var cb = /^(?:input|select|textarea|button)$/i,
    db = /^(?:a|area)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return K(this, n.prop, a, b, arguments.length > 1)
    },
    removeProp: function(a) {
      return this.each(function() {
        delete this[n.propFix[a] || a]
      })
    }
  }), n.extend({
    prop: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b,
        e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          var b = n.find.attr(a, "tabindex");
          return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }), l.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b && b.parentNode && b.parentNode.selectedIndex, null
    },
    set: function(a) {
      var b = a.parentNode;
      b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  });
  var eb = /[\t\r\n\f]/g;

  function fb(a) {
    return a.getAttribute && a.getAttribute("class") || ""
  }
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h, i = 0;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, fb(this)))
      });
      if ("string" == typeof a && a) {
        b = a.match(G) || [];
        while (c = this[i++])
          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {
            g = 0;
            while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
            h = n.trim(d), e !== h && c.setAttribute("class", h)
          }
      }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h, i = 0;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, fb(this)))
      });
      if (!arguments.length) return this.attr("class", "");
      if ("string" == typeof a && a) {
        b = a.match(G) || [];
        while (c = this[i++])
          if (e = fb(c), d = 1 === c.nodeType && (" " + e + " ").replace(eb, " ")) {
            g = 0;
            while (f = b[g++])
              while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " ");
            h = n.trim(d), e !== h && c.setAttribute("class", h)
          }
      }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function(c) {
        n(this).toggleClass(a.call(this, c, fb(this), b), b)
      }) : this.each(function() {
        var b, d, e, f;
        if ("string" === c) {
          d = 0, e = n(this), f = a.match(G) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else void 0 !== a && "boolean" !== c || (b = fb(this), b && N.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : N.get(this, "__className__") || ""))
      })
    },
    hasClass: function(a) {
      var b, c, d = 0;
      b = " " + a + " ";
      while (c = this[d++])
        if (1 === c.nodeType && (" " + fb(c) + " ").replace(eb, " ").indexOf(b) > -1) return !0;
      return !1
    }
  });
  var gb = /\r/g,
    hb = /[\x20\t\r\n\f]+/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(gb, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.trim(n.text(a)).replace(hb, " ")
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            } return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--) d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);
          return c || (a.selectedIndex = -1), f
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0
      }
    }, l.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  });
  var ib = /^(?:focusinfocus|focusoutblur)$/;
  n.extend(n.event, {
    trigger: function(b, c, e, f) {
      var g, h, i, j, l, m, o, p = [e || d],
        q = k.call(b, "type") ? b.type : b,
        r = k.call(b, "namespace") ? b.namespace.split(".") : [];
      if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(".") > -1 && (r = q.split("."), q = r.shift(), r.sort()), l = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {
        if (!f && !o.noBubble && !n.isWindow(e)) {
          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) p.push(h), i = h;
          i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a)
        }
        g = 0;
        while ((h = p[g++]) && !b.isPropagationStopped()) b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, "events") || {})[b.type] && N.get(h, "handle"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());
        return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result
      }
    },
    simulate: function(a, b, c) {
      var d = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0
      });
      n.event.trigger(d, null, b), d.isDefaultPrevented() && c.preventDefault()
    }
  }), n.fn.extend({
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    }
  }), l.focusin = "onfocusin" in a, l.focusin || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a))
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = N.access(d, b);
        e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = N.access(d, b) - 1;
        e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b))
      }
    }
  });
  var jb = a.location,
    kb = n.now(),
    lb = /\?/;
  n.parseJSON = function(a) {
    return JSON.parse(a + "")
  }, n.parseXML = function(b) {
    var c;
    if (!b || "string" != typeof b) return null;
    try {
      c = (new a.DOMParser).parseFromString(b, "text/xml")
    } catch (d) {
      c = void 0
    }
    return c && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c
  };
  var mb = /#.*$/,
    nb = /([?&])_=[^&]*/,
    ob = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    qb = /^(?:GET|HEAD)$/,
    rb = /^\/\//,
    sb = {},
    tb = {},
    ub = "*/".concat("*"),
    vb = d.createElement("a");
  vb.href = jb.href;

  function wb(a) {
    return function(b, c) {
      "string" != typeof b && (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(G) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function xb(a, b, c, d) {
    var e = {},
      f = a === tb;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] && g("*")
  }

  function yb(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
    return d && n.extend(!0, a, d), a
  }

  function zb(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
    if (d)
      for (e in h)
        if (h[e] && h[e].test(d)) {
          i.unshift(e);
          break
        } if (i[0] in c) f = i[0];
    else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break
        }
        g || (g = e)
      }
      f = f || g
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
  }

  function Ab(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i && i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
            break
          } if (g !== !0)
        if (g && a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: jb.href,
      type: "GET",
      isLocal: pb.test(jb.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": ub,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a)
    },
    ajaxPrefilter: wb(sb),
    ajaxTransport: wb(tb),
    ajax: function(b, c) {
      "object" == typeof b && (c = b, b = void 0), c = c || {};
      var e, f, g, h, i, j, k, l, m = n.ajaxSetup({}, c),
        o = m.context || m,
        p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,
        q = n.Deferred(),
        r = n.Callbacks("once memory"),
        s = m.statusCode || {},
        t = {},
        u = {},
        v = 0,
        w = "canceled",
        x = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === v) {
              if (!h) {
                h = {};
                while (b = ob.exec(g)) h[b[1].toLowerCase()] = b[2]
              }
              b = h[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === v ? g : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return v || (a = u[c] = u[c] || a, t[a] = b), this
          },
          overrideMimeType: function(a) {
            return v || (m.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 > v)
                for (b in a) s[b] = [s[b], a[b]];
              else x.always(a[x.status]);
            return this
          },
          abort: function(a) {
            var b = a || w;
            return e && e.abort(b), z(0, b), this
          }
        };
      if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + "").replace(mb, "").replace(rb, jb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || "*").toLowerCase().match(G) || [""], null == m.crossDomain) {
        j = d.createElement("a");
        try {
          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + "//" + vb.host != j.protocol + "//" + j.host
        } catch (y) {
          m.crossDomain = !0
        }
      }
      if (m.data && m.processData && "string" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;
      k = n.event && m.global, k && 0 === n.active++ && n.event.trigger("ajaxStart"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? "&" : "?") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, "$1_=" + kb++) : f + (lb.test(f) ? "&" : "?") + "_=" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader("If-Modified-Since", n.lastModified[f]), n.etag[f] && x.setRequestHeader("If-None-Match", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader("Content-Type", m.contentType), x.setRequestHeader("Accept", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + ("*" !== m.dataTypes[0] ? ", " + ub + "; q=0.01" : "") : m.accepts["*"]);
      for (l in m.headers) x.setRequestHeader(l, m.headers[l]);
      if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();
      w = "abort";
      for (l in {
          success: 1,
          error: 1,
          complete: 1
        }) x[l](m[l]);
      if (e = xb(tb, m, c, x)) {
        if (x.readyState = 1, k && p.trigger("ajaxSend", [x, m]), 2 === v) return x;
        m.async && m.timeout > 0 && (i = a.setTimeout(function() {
          x.abort("timeout")
        }, m.timeout));
        try {
          v = 1, e.send(t, z)
        } catch (y) {
          if (!(2 > v)) throw y;
          z(-1, y)
        }
      } else z(-1, "No Transport");

      function z(b, c, d, h) {
        var j, l, t, u, w, y = c;
        2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || "", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader("Last-Modified"), w && (n.lastModified[f] = w), w = x.getResponseHeader("etag"), w && (n.etag[f] = w)), 204 === b || "HEAD" === m.type ? y = "nocontent" : 304 === b ? y = "notmodified" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = "error", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + "", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? "ajaxSuccess" : "ajaxError", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger("ajaxComplete", [x, m]), --n.active || n.event.trigger("ajaxStop")))
      }
      return x
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      }, n.isPlainObject(a) && a))
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      var b;
      return n.isFunction(a) ? this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
        var a = this;
        while (a.firstElementChild) a = a.firstElementChild;
        return a
      }).append(this)), this)
    },
    wrapInner: function(a) {
      return n.isFunction(a) ? this.each(function(b) {
        n(this).wrapInner(a.call(this, b))
      }) : this.each(function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return !n.expr.filters.visible(a)
  }, n.expr.filters.visible = function(a) {
    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0
  };
  var Bb = /%20/g,
    Cb = /\[\]$/,
    Db = /\r?\n/g,
    Eb = /^(?:submit|button|image|reset|file)$/i,
    Fb = /^(?:input|select|textarea|keygen)/i;

  function Gb(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || Cb.test(a) ? d(a, e) : Gb(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Gb(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Gb(c, a[c], b, e);
    return d.join("&").replace(Bb, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name && !n(this).is(":disabled") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Db, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(Db, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = function() {
    try {
      return new a.XMLHttpRequest
    } catch (b) {}
  };
  var Hb = {
      0: 200,
      1223: 204
    },
    Ib = n.ajaxSettings.xhr();
  l.cors = !!Ib && "withCredentials" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function(b) {
    var c, d;
    return l.cors || Ib && !b.crossDomain ? {
      send: function(e, f) {
        var g, h = b.xhr();
        if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
          for (g in b.xhrFields) h[g] = b.xhrFields[g];
        b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
        for (g in e) h.setRequestHeader(g, e[g]);
        c = function(a) {
          return function() {
            c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
              binary: h.response
            } : {
              text: h.responseText
            }, h.getAllResponseHeaders()))
          }
        }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
          4 === h.readyState && a.setTimeout(function() {
            c && d()
          })
        }, c = c("abort");
        try {
          h.send(b.hasContent && b.data || null)
        } catch (i) {
          if (c) throw i
        }
      },
      abort: function() {
        c && c()
      }
    } : void 0
  }), n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c;
      return {
        send: function(e, f) {
          b = n("<script>").prop({
            charset: a.scriptCharset,
            src: a.url
          }).on("load error", c = function(a) {
            b.remove(), c = null, a && f("error" === a.type ? 404 : 200, a.type)
          }), d.head.appendChild(b[0])
        },
        abort: function() {
          c && c()
        }
      }
    }
  });
  var Jb = [],
    Kb = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = Jb.pop() || n.expando + "_" + kb++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 && (Kb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Kb.test(b.data) && "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, "$1" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b && (c = b, b = !1), b = b || d;
    var e = x.exec(a),
      f = !c && [];
    return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes))
  };
  var Lb = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a && Lb) return Lb.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
      url: a,
      type: e || "GET",
      dataType: "html",
      data: b
    }).done(function(a) {
      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a)
    }).always(c && function(a, b) {
      g.each(function() {
        c.apply(this, f || [a.responseText, b, a])
      })
    }), this
  }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };

  function Mb(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = this[0],
        e = {
          top: 0,
          left: 0
        },
        f = d && d.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), {
        top: e.top + c.pageYOffset - b.clientTop,
        left: e.left + c.pageXOffset - b.clientLeft
      }) : e
    },
    position: function() {
      if (this[0]) {
        var a, b, c = this[0],
          d = {
            top: 0,
            left: 0
          };
        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - d.top - n.css(c, "marginTop", !0),
          left: b.left - d.left - n.css(c, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent;
        while (a && "static" === n.css(a, "position")) a = a.offsetParent;
        return a || Ea
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(a, b) {
    var c = "pageYOffset" === b;
    n.fn[a] = function(d) {
      return K(this, function(a, d, e) {
        var f = Mb(a);
        return void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
      }, a, d, arguments.length)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = Ga(l.pixelPosition, function(a, c) {
      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length && (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return K(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.extend({
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    },
    size: function() {
      return this.length
    }
  }), n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
    return n
  });
  var Nb = a.jQuery,
    Ob = a.$;
  return n.noConflict = function(b) {
    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n
  }, b || (a.jQuery = a.$ = n), n
});
/*! RESOURCE: /scripts/lib/jquery/jquery_no_conflict.js */
(function() {
  if (window.$j_glide) {
    jQuery.noConflict(true);
    window.jQuery = $j_glide;
  }
  window.$j = window.$j_glide = jQuery.noConflict();
})();;;
/*! RESOURCE: /scripts/reportlibs/json2.js */
if (typeof JSON !== 'object') {
  JSON = {};
}
(function() {
  'use strict';

  function f(n) {
    return n < 10 ? '0' + n : n;
  }
  if (typeof Date.prototype.toJSON !== 'function') {
    Date.prototype.toJSON = function(key) {
      return isFinite(this.valueOf()) ?
        this.getUTCFullYear() + '-' +
        f(this.getUTCMonth() + 1) + '-' +
        f(this.getUTCDate()) + 'T' +
        f(this.getUTCHours()) + ':' +
        f(this.getUTCMinutes()) + ':' +
        f(this.getUTCSeconds()) + 'Z' :
        null;
    };
    String.prototype.toJSON =
      Number.prototype.toJSON =
      Boolean.prototype.toJSON = function(key) {
        return this.valueOf();
      };
  }
  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '\\': '\\\\'
    },
    rep;

  function quote(string) {
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
      var c = meta[a];
      return typeof c === 'string' ?
        c :
        '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
  }

  function str(key, holder) {
    var i,
      k,
      v,
      length,
      mind = gap,
      partial,
      value = holder[key];
    if (value && typeof value === 'object' &&
      typeof value.toJSON === 'function') {
      value = value.toJSON(key);
    }
    if (typeof rep === 'function') {
      value = rep.call(holder, key, value);
    }
    switch (typeof value) {
      case 'string':
        return quote(value);
      case 'number':
        return isFinite(value) ? String(value) : 'null';
      case 'boolean':
      case 'null':
        return String(value);
      case 'object':
        if (!value) {
          return 'null';
        }
        gap += indent;
        partial = [];
        if (Object.prototype.toString.apply(value) === '[object Array]') {
          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || 'null';
          }
          v = partial.length === 0 ?
            '[]' :
            gap ?
            '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
            '[' + partial.join(',') + ']';
          gap = mind;
          return v;
        }
        if (rep && typeof rep === 'object') {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === 'string') {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        } else {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        }
        v = partial.length === 0 ?
          '{}' :
          gap ?
          '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
          '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
  }
  if (typeof JSON.stringify !== 'function') {
    JSON.stringify = function(value, replacer, space) {
      var i;
      gap = '';
      indent = '';
      if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
          indent += ' ';
        }
      } else if (typeof space === 'string') {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
        (typeof replacer !== 'object' ||
          typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
      }
      return str('', {
        '': value
      });
    };
  }
  if (typeof JSON.parse !== 'function') {
    JSON.parse = function(text, reviver) {
      var j;

      function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = walk(value, k);
              if (v !== undefined) {
                value[k] = v;
              } else {
                delete value[k];
              }
            }
          }
        }
        return reviver.call(holder, key, value);
      }
      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
        text = text.replace(cx, function(a) {
          return '\\u' +
            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        });
      }
      if (/^[\],:{}\s]*$/
        .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
          .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
          .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        j = eval('(' + text + ')');
        return typeof reviver === 'function' ?
          walk({
            '': j
          }, '') :
          j;
      }
      throw new SyntaxError('JSON.parse');
    };
  }
}());;
/*! RESOURCE: /scripts/reportlibs/moment.min.js */
! function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.moment = t()
}(this, function() {
  "use strict";

  function e() {
    return Qe.apply(null, arguments)
  }

  function t(e) {
    return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
  }

  function n(e) {
    return null != e && "[object Object]" === Object.prototype.toString.call(e)
  }

  function s(e) {
    return void 0 === e
  }

  function i(e) {
    return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
  }

  function r(e) {
    return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
  }

  function a(e, t) {
    var n, s = [];
    for (n = 0; n < e.length; ++n) s.push(t(e[n], n));
    return s
  }

  function o(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
  }

  function u(e, t) {
    for (var n in t) o(t, n) && (e[n] = t[n]);
    return o(t, "toString") && (e.toString = t.toString), o(t, "valueOf") && (e.valueOf = t.valueOf), e
  }

  function l(e, t, n, s) {
    return ge(e, t, n, s, !0).utc()
  }

  function d(e) {
    return null == e._pf && (e._pf = {
      empty: !1,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: !1,
      invalidMonth: null,
      invalidFormat: !1,
      userInvalidated: !1,
      iso: !1,
      parsedDateParts: [],
      meridiem: null,
      rfc2822: !1,
      weekdayMismatch: !1
    }), e._pf
  }

  function h(e) {
    if (null == e._isValid) {
      var t = d(e),
        n = Xe.call(t.parsedDateParts, function(e) {
          return null != e
        }),
        s = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n);
      if (e._strict && (s = s && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return s;
      e._isValid = s
    }
    return e._isValid
  }

  function c(e) {
    var t = l(NaN);
    return null != e ? u(d(t), e) : d(t).userInvalidated = !0, t
  }

  function f(e, t) {
    var n, i, r;
    if (s(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), s(t._i) || (e._i = t._i), s(t._f) || (e._f = t._f), s(t._l) || (e._l = t._l), s(t._strict) || (e._strict = t._strict), s(t._tzm) || (e._tzm = t._tzm), s(t._isUTC) || (e._isUTC = t._isUTC), s(t._offset) || (e._offset = t._offset), s(t._pf) || (e._pf = d(t)), s(t._locale) || (e._locale = t._locale), Ke.length > 0)
      for (n = 0; n < Ke.length; n++) s(r = t[i = Ke[n]]) || (e[i] = r);
    return e
  }

  function m(t) {
    f(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === et && (et = !0, e.updateOffset(this), et = !1)
  }

  function _(e) {
    return e instanceof m || null != e && null != e._isAMomentObject
  }

  function y(e) {
    return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
  }

  function g(e) {
    var t = +e,
      n = 0;
    return 0 !== t && isFinite(t) && (n = y(t)), n
  }

  function p(e, t, n) {
    var s, i = Math.min(e.length, t.length),
      r = Math.abs(e.length - t.length),
      a = 0;
    for (s = 0; s < i; s++)(n && e[s] !== t[s] || !n && g(e[s]) !== g(t[s])) && a++;
    return a + r
  }

  function w(t) {
    !1 === e.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
  }

  function v(t, n) {
    var s = !0;
    return u(function() {
      if (null != e.deprecationHandler && e.deprecationHandler(null, t), s) {
        for (var i, r = [], a = 0; a < arguments.length; a++) {
          if (i = "", "object" == typeof arguments[a]) {
            i += "\n[" + a + "] ";
            for (var o in arguments[0]) i += o + ": " + arguments[0][o] + ", ";
            i = i.slice(0, -2)
          } else i = arguments[a];
          r.push(i)
        }
        w(t + "\nArguments: " + Array.prototype.slice.call(r).join("") + "\n" + (new Error).stack), s = !1
      }
      return n.apply(this, arguments)
    }, n)
  }

  function M(t, n) {
    null != e.deprecationHandler && e.deprecationHandler(t, n), tt[t] || (w(n), tt[t] = !0)
  }

  function S(e) {
    return e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
  }

  function D(e, t) {
    var s, i = u({}, e);
    for (s in t) o(t, s) && (n(e[s]) && n(t[s]) ? (i[s] = {}, u(i[s], e[s]), u(i[s], t[s])) : null != t[s] ? i[s] = t[s] : delete i[s]);
    for (s in e) o(e, s) && !o(t, s) && n(e[s]) && (i[s] = u({}, i[s]));
    return i
  }

  function k(e) {
    null != e && this.set(e)
  }

  function Y(e, t) {
    var n = e.toLowerCase();
    st[n] = st[n + "s"] = st[t] = e
  }

  function O(e) {
    return "string" == typeof e ? st[e] || st[e.toLowerCase()] : void 0
  }

  function T(e) {
    var t, n, s = {};
    for (n in e) o(e, n) && (t = O(n)) && (s[t] = e[n]);
    return s
  }

  function x(e, t) {
    it[e] = t
  }

  function b(e, t, n) {
    var s = "" + Math.abs(e),
      i = t - s.length;
    return (e >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + s
  }

  function P(e, t, n, s) {
    var i = s;
    "string" == typeof s && (i = function() {
      return this[s]()
    }), e && (ut[e] = i), t && (ut[t[0]] = function() {
      return b(i.apply(this, arguments), t[1], t[2])
    }), n && (ut[n] = function() {
      return this.localeData().ordinal(i.apply(this, arguments), e)
    })
  }

  function W(e) {
    return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "")
  }

  function H(e, t) {
    return e.isValid() ? (t = R(t, e.localeData()), ot[t] = ot[t] || function(e) {
      var t, n, s = e.match(rt);
      for (t = 0, n = s.length; t < n; t++) ut[s[t]] ? s[t] = ut[s[t]] : s[t] = W(s[t]);
      return function(t) {
        var i, r = "";
        for (i = 0; i < n; i++) r += S(s[i]) ? s[i].call(t, e) : s[i];
        return r
      }
    }(t), ot[t](e)) : e.localeData().invalidDate()
  }

  function R(e, t) {
    function n(e) {
      return t.longDateFormat(e) || e
    }
    var s = 5;
    for (at.lastIndex = 0; s >= 0 && at.test(e);) e = e.replace(at, n), at.lastIndex = 0, s -= 1;
    return e
  }

  function C(e, t, n) {
    Yt[e] = S(t) ? t : function(e, s) {
      return e && n ? n : t
    }
  }

  function F(e, t) {
    return o(Yt, e) ? Yt[e](t._strict, t._locale) : new RegExp(function(e) {
      return U(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e, t, n, s, i) {
        return t || n || s || i
      }))
    }(e))
  }

  function U(e) {
    return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
  }

  function L(e, t) {
    var n, s = t;
    for ("string" == typeof e && (e = [e]), i(t) && (s = function(e, n) {
        n[t] = g(e)
      }), n = 0; n < e.length; n++) Ot[e[n]] = s
  }

  function N(e, t) {
    L(e, function(e, n, s, i) {
      s._w = s._w || {}, t(e, s._w, s, i)
    })
  }

  function G(e, t, n) {
    null != t && o(Ot, e) && Ot[e](t, n._a, n, e)
  }

  function V(e) {
    return E(e) ? 366 : 365
  }

  function E(e) {
    return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
  }

  function I(t, n) {
    return function(s) {
      return null != s ? (j(this, t, s), e.updateOffset(this, n), this) : A(this, t)
    }
  }

  function A(e, t) {
    return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
  }

  function j(e, t, n) {
    e.isValid() && !isNaN(n) && ("FullYear" === t && E(e.year()) && 1 === e.month() && 29 === e.date() ? e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), Z(n, e.month())) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
  }

  function Z(e, t) {
    if (isNaN(e) || isNaN(t)) return NaN;
    var n = function(e, t) {
      return (e % t + t) % t
    }(t, 12);
    return e += (t - n) / 12, 1 === n ? E(e) ? 29 : 28 : 31 - n % 7 % 2
  }

  function z(e, t) {
    var n;
    if (!e.isValid()) return e;
    if ("string" == typeof t)
      if (/^\d+$/.test(t)) t = g(t);
      else if (t = e.localeData().monthsParse(t), !i(t)) return e;
    return n = Math.min(e.date(), Z(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
  }

  function $(t) {
    return null != t ? (z(this, t), e.updateOffset(this, !0), this) : A(this, "Month")
  }

  function q() {
    function e(e, t) {
      return t.length - e.length
    }
    var t, n, s = [],
      i = [],
      r = [];
    for (t = 0; t < 12; t++) n = l([2e3, t]), s.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
    for (s.sort(e), i.sort(e), r.sort(e), t = 0; t < 12; t++) s[t] = U(s[t]), i[t] = U(i[t]);
    for (t = 0; t < 24; t++) r[t] = U(r[t]);
    this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i")
  }

  function J(e) {
    var t = new Date(Date.UTC.apply(null, arguments));
    return e < 100 && e >= 0 && isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e), t
  }

  function B(e, t, n) {
    var s = 7 + t - n;
    return -((7 + J(e, 0, s).getUTCDay() - t) % 7) + s - 1
  }

  function Q(e, t, n, s, i) {
    var r, a, o = 1 + 7 * (t - 1) + (7 + n - s) % 7 + B(e, s, i);
    return o <= 0 ? a = V(r = e - 1) + o : o > V(e) ? (r = e + 1, a = o - V(e)) : (r = e, a = o), {
      year: r,
      dayOfYear: a
    }
  }

  function X(e, t, n) {
    var s, i, r = B(e.year(), t, n),
      a = Math.floor((e.dayOfYear() - r - 1) / 7) + 1;
    return a < 1 ? s = a + K(i = e.year() - 1, t, n) : a > K(e.year(), t, n) ? (s = a - K(e.year(), t, n), i = e.year() + 1) : (i = e.year(), s = a), {
      week: s,
      year: i
    }
  }

  function K(e, t, n) {
    var s = B(e, t, n),
      i = B(e + 1, t, n);
    return (V(e) - s + i) / 7
  }

  function ee() {
    function e(e, t) {
      return t.length - e.length
    }
    var t, n, s, i, r, a = [],
      o = [],
      u = [],
      d = [];
    for (t = 0; t < 7; t++) n = l([2e3, 1]).day(t), s = this.weekdaysMin(n, ""), i = this.weekdaysShort(n, ""), r = this.weekdays(n, ""), a.push(s), o.push(i), u.push(r), d.push(s), d.push(i), d.push(r);
    for (a.sort(e), o.sort(e), u.sort(e), d.sort(e), t = 0; t < 7; t++) o[t] = U(o[t]), u[t] = U(u[t]), d[t] = U(d[t]);
    this._weekdaysRegex = new RegExp("^(" + d.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
  }

  function te() {
    return this.hours() % 12 || 12
  }

  function ne(e, t) {
    P(e, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), t)
    })
  }

  function se(e, t) {
    return t._meridiemParse
  }

  function ie(e) {
    return e ? e.toLowerCase().replace("_", "-") : e
  }

  function re(e) {
    var t = null;
    if (!Xt[e] && "undefined" != typeof module && module && module.exports) try {
      t = Jt._abbr;
      require("./locale/" + e), ae(t)
    } catch (e) {}
    return Xt[e]
  }

  function ae(e, t) {
    var n;
    return e && (n = s(t) ? ue(e) : oe(e, t)) && (Jt = n), Jt._abbr
  }

  function oe(e, t) {
    if (null !== t) {
      var n = Qt;
      if (t.abbr = e, null != Xt[e]) M("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = Xt[e]._config;
      else if (null != t.parentLocale) {
        if (null == Xt[t.parentLocale]) return Kt[t.parentLocale] || (Kt[t.parentLocale] = []), Kt[t.parentLocale].push({
          name: e,
          config: t
        }), null;
        n = Xt[t.parentLocale]._config
      }
      return Xt[e] = new k(D(n, t)), Kt[e] && Kt[e].forEach(function(e) {
        oe(e.name, e.config)
      }), ae(e), Xt[e]
    }
    return delete Xt[e], null
  }

  function ue(e) {
    var n;
    if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return Jt;
    if (!t(e)) {
      if (n = re(e)) return n;
      e = [e]
    }
    return function(e) {
      for (var t, n, s, i, r = 0; r < e.length;) {
        for (t = (i = ie(e[r]).split("-")).length, n = (n = ie(e[r + 1])) ? n.split("-") : null; t > 0;) {
          if (s = re(i.slice(0, t).join("-"))) return s;
          if (n && n.length >= t && p(i, n, !0) >= t - 1) break;
          t--
        }
        r++
      }
      return null
    }(e)
  }

  function le(e) {
    var t, n = e._a;
    return n && -2 === d(e).overflow && (t = n[xt] < 0 || n[xt] > 11 ? xt : n[bt] < 1 || n[bt] > Z(n[Tt], n[xt]) ? bt : n[Pt] < 0 || n[Pt] > 24 || 24 === n[Pt] && (0 !== n[Wt] || 0 !== n[Ht] || 0 !== n[Rt]) ? Pt : n[Wt] < 0 || n[Wt] > 59 ? Wt : n[Ht] < 0 || n[Ht] > 59 ? Ht : n[Rt] < 0 || n[Rt] > 999 ? Rt : -1, d(e)._overflowDayOfYear && (t < Tt || t > bt) && (t = bt), d(e)._overflowWeeks && -1 === t && (t = Ct), d(e)._overflowWeekday && -1 === t && (t = Ft), d(e).overflow = t), e
  }

  function de(e, t, n) {
    return null != e ? e : null != t ? t : n
  }

  function he(t) {
    var n, s, i, r, a, o = [];
    if (!t._d) {
      for (i = function(t) {
          var n = new Date(e.now());
          return t._useUTC ? [n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate()] : [n.getFullYear(), n.getMonth(), n.getDate()]
        }(t), t._w && null == t._a[bt] && null == t._a[xt] && function(e) {
          var t, n, s, i, r, a, o, u;
          if (null != (t = e._w).GG || null != t.W || null != t.E) r = 1, a = 4, n = de(t.GG, e._a[Tt], X(pe(), 1, 4).year), s = de(t.W, 1), ((i = de(t.E, 1)) < 1 || i > 7) && (u = !0);
          else {
            r = e._locale._week.dow, a = e._locale._week.doy;
            var l = X(pe(), r, a);
            n = de(t.gg, e._a[Tt], l.year), s = de(t.w, l.week), null != t.d ? ((i = t.d) < 0 || i > 6) && (u = !0) : null != t.e ? (i = t.e + r, (t.e < 0 || t.e > 6) && (u = !0)) : i = r
          }
          s < 1 || s > K(n, r, a) ? d(e)._overflowWeeks = !0 : null != u ? d(e)._overflowWeekday = !0 : (o = Q(n, s, i, r, a), e._a[Tt] = o.year, e._dayOfYear = o.dayOfYear)
        }(t), null != t._dayOfYear && (a = de(t._a[Tt], i[Tt]), (t._dayOfYear > V(a) || 0 === t._dayOfYear) && (d(t)._overflowDayOfYear = !0), s = J(a, 0, t._dayOfYear), t._a[xt] = s.getUTCMonth(), t._a[bt] = s.getUTCDate()), n = 0; n < 3 && null == t._a[n]; ++n) t._a[n] = o[n] = i[n];
      for (; n < 7; n++) t._a[n] = o[n] = null == t._a[n] ? 2 === n ? 1 : 0 : t._a[n];
      24 === t._a[Pt] && 0 === t._a[Wt] && 0 === t._a[Ht] && 0 === t._a[Rt] && (t._nextDay = !0, t._a[Pt] = 0), t._d = (t._useUTC ? J : function(e, t, n, s, i, r, a) {
        var o = new Date(e, t, n, s, i, r, a);
        return e < 100 && e >= 0 && isFinite(o.getFullYear()) && o.setFullYear(e), o
      }).apply(null, o), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[Pt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (d(t).weekdayMismatch = !0)
    }
  }

  function ce(e) {
    var t, n, s, i, r, a, o = e._i,
      u = en.exec(o) || tn.exec(o);
    if (u) {
      for (d(e).iso = !0, t = 0, n = sn.length; t < n; t++)
        if (sn[t][1].exec(u[1])) {
          i = sn[t][0], s = !1 !== sn[t][2];
          break
        } if (null == i) return void(e._isValid = !1);
      if (u[3]) {
        for (t = 0, n = rn.length; t < n; t++)
          if (rn[t][1].exec(u[3])) {
            r = (u[2] || " ") + rn[t][0];
            break
          } if (null == r) return void(e._isValid = !1)
      }
      if (!s && null != r) return void(e._isValid = !1);
      if (u[4]) {
        if (!nn.exec(u[4])) return void(e._isValid = !1);
        a = "Z"
      }
      e._f = i + (r || "") + (a || ""), _e(e)
    } else e._isValid = !1
  }

  function fe(e, t, n, s, i, r) {
    var a = [function(e) {
      var t = parseInt(e, 10); {
        if (t <= 49) return 2e3 + t;
        if (t <= 999) return 1900 + t
      }
      return t
    }(e), Vt.indexOf(t), parseInt(n, 10), parseInt(s, 10), parseInt(i, 10)];
    return r && a.push(parseInt(r, 10)), a
  }

  function me(e) {
    var t = on.exec(function(e) {
      return e.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
    }(e._i));
    if (t) {
      var n = fe(t[4], t[3], t[2], t[5], t[6], t[7]);
      if (! function(e, t, n) {
          if (e && jt.indexOf(e) !== new Date(t[0], t[1], t[2]).getDay()) return d(n).weekdayMismatch = !0, n._isValid = !1, !1;
          return !0
        }(t[1], n, e)) return;
      e._a = n, e._tzm = function(e, t, n) {
        if (e) return un[e];
        if (t) return 0;
        var s = parseInt(n, 10),
          i = s % 100;
        return (s - i) / 100 * 60 + i
      }(t[8], t[9], t[10]), e._d = J.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), d(e).rfc2822 = !0
    } else e._isValid = !1
  }

  function _e(t) {
    if (t._f !== e.ISO_8601)
      if (t._f !== e.RFC_2822) {
        t._a = [], d(t).empty = !0;
        var n, s, i, r, a, o = "" + t._i,
          u = o.length,
          l = 0;
        for (i = R(t._f, t._locale).match(rt) || [], n = 0; n < i.length; n++) r = i[n], (s = (o.match(F(r, t)) || [])[0]) && ((a = o.substr(0, o.indexOf(s))).length > 0 && d(t).unusedInput.push(a), o = o.slice(o.indexOf(s) + s.length), l += s.length), ut[r] ? (s ? d(t).empty = !1 : d(t).unusedTokens.push(r), G(r, s, t)) : t._strict && !s && d(t).unusedTokens.push(r);
        d(t).charsLeftOver = u - l, o.length > 0 && d(t).unusedInput.push(o), t._a[Pt] <= 12 && !0 === d(t).bigHour && t._a[Pt] > 0 && (d(t).bigHour = void 0), d(t).parsedDateParts = t._a.slice(0), d(t).meridiem = t._meridiem, t._a[Pt] = function(e, t, n) {
          var s;
          if (null == n) return t;
          return null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((s = e.isPM(n)) && t < 12 && (t += 12), s || 12 !== t || (t = 0), t) : t
        }(t._locale, t._a[Pt], t._meridiem), he(t), le(t)
      } else me(t);
    else ce(t)
  }

  function ye(o) {
    var l = o._i,
      y = o._f;
    return o._locale = o._locale || ue(o._l), null === l || void 0 === y && "" === l ? c({
      nullInput: !0
    }) : ("string" == typeof l && (o._i = l = o._locale.preparse(l)), _(l) ? new m(le(l)) : (r(l) ? o._d = l : t(y) ? function(e) {
      var t, n, s, i, r;
      if (0 === e._f.length) return d(e).invalidFormat = !0, void(e._d = new Date(NaN));
      for (i = 0; i < e._f.length; i++) r = 0, t = f({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], _e(t), h(t) && (r += d(t).charsLeftOver, r += 10 * d(t).unusedTokens.length, d(t).score = r, (null == s || r < s) && (s = r, n = t));
      u(e, n || t)
    }(o) : y ? _e(o) : function(o) {
      var u = o._i;
      s(u) ? o._d = new Date(e.now()) : r(u) ? o._d = new Date(u.valueOf()) : "string" == typeof u ? function(t) {
        var n = an.exec(t._i);
        null === n ? (ce(t), !1 === t._isValid && (delete t._isValid, me(t), !1 === t._isValid && (delete t._isValid, e.createFromInputFallback(t)))) : t._d = new Date(+n[1])
      }(o) : t(u) ? (o._a = a(u.slice(0), function(e) {
        return parseInt(e, 10)
      }), he(o)) : n(u) ? function(e) {
        if (!e._d) {
          var t = T(e._i);
          e._a = a([t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], function(e) {
            return e && parseInt(e, 10)
          }), he(e)
        }
      }(o) : i(u) ? o._d = new Date(u) : e.createFromInputFallback(o)
    }(o), h(o) || (o._d = null), o))
  }

  function ge(e, s, i, r, a) {
    var o = {};
    return !0 !== i && !1 !== i || (r = i, i = void 0), (n(e) && function(e) {
        if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
        var t;
        for (t in e)
          if (e.hasOwnProperty(t)) return !1;
        return !0
      }(e) || t(e) && 0 === e.length) && (e = void 0), o._isAMomentObject = !0, o._useUTC = o._isUTC = a, o._l = i, o._i = e, o._f = s, o._strict = r,
      function(e) {
        var t = new m(le(ye(e)));
        return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t
      }(o)
  }

  function pe(e, t, n, s) {
    return ge(e, t, n, s, !1)
  }

  function we(e, n) {
    var s, i;
    if (1 === n.length && t(n[0]) && (n = n[0]), !n.length) return pe();
    for (s = n[0], i = 1; i < n.length; ++i) n[i].isValid() && !n[i][e](s) || (s = n[i]);
    return s
  }

  function ve(e) {
    var t = T(e),
      n = t.year || 0,
      s = t.quarter || 0,
      i = t.month || 0,
      r = t.week || 0,
      a = t.day || 0,
      o = t.hour || 0,
      u = t.minute || 0,
      l = t.second || 0,
      d = t.millisecond || 0;
    this._isValid = function(e) {
      for (var t in e)
        if (-1 === Ut.call(hn, t) || null != e[t] && isNaN(e[t])) return !1;
      for (var n = !1, s = 0; s < hn.length; ++s)
        if (e[hn[s]]) {
          if (n) return !1;
          parseFloat(e[hn[s]]) !== g(e[hn[s]]) && (n = !0)
        } return !0
    }(t), this._milliseconds = +d + 1e3 * l + 6e4 * u + 1e3 * o * 60 * 60, this._days = +a + 7 * r, this._months = +i + 3 * s + 12 * n, this._data = {}, this._locale = ue(), this._bubble()
  }

  function Me(e) {
    return e instanceof ve
  }

  function Se(e) {
    return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
  }

  function De(e, t) {
    P(e, 0, 0, function() {
      var e = this.utcOffset(),
        n = "+";
      return e < 0 && (e = -e, n = "-"), n + b(~~(e / 60), 2) + t + b(~~e % 60, 2)
    })
  }

  function ke(e, t) {
    var n = (t || "").match(e);
    if (null === n) return null;
    var s = ((n[n.length - 1] || []) + "").match(cn) || ["-", 0, 0],
      i = 60 * s[1] + g(s[2]);
    return 0 === i ? 0 : "+" === s[0] ? i : -i
  }

  function Ye(t, n) {
    var s, i;
    return n._isUTC ? (s = n.clone(), i = (_(t) || r(t) ? t.valueOf() : pe(t).valueOf()) - s.valueOf(), s._d.setTime(s._d.valueOf() + i), e.updateOffset(s, !1), s) : pe(t).local()
  }

  function Oe(e) {
    return 15 * -Math.round(e._d.getTimezoneOffset() / 15)
  }

  function Te() {
    return !!this.isValid() && (this._isUTC && 0 === this._offset)
  }

  function xe(e, t) {
    var n, s, r, a = e,
      u = null;
    return Me(e) ? a = {
      ms: e._milliseconds,
      d: e._days,
      M: e._months
    } : i(e) ? (a = {}, t ? a[t] = e : a.milliseconds = e) : (u = fn.exec(e)) ? (n = "-" === u[1] ? -1 : 1, a = {
      y: 0,
      d: g(u[bt]) * n,
      h: g(u[Pt]) * n,
      m: g(u[Wt]) * n,
      s: g(u[Ht]) * n,
      ms: g(Se(1e3 * u[Rt])) * n
    }) : (u = mn.exec(e)) ? (n = "-" === u[1] ? -1 : (u[1], 1), a = {
      y: be(u[2], n),
      M: be(u[3], n),
      w: be(u[4], n),
      d: be(u[5], n),
      h: be(u[6], n),
      m: be(u[7], n),
      s: be(u[8], n)
    }) : null == a ? a = {} : "object" == typeof a && ("from" in a || "to" in a) && (r = function(e, t) {
      var n;
      if (!e.isValid() || !t.isValid()) return {
        milliseconds: 0,
        months: 0
      };
      t = Ye(t, e), e.isBefore(t) ? n = Pe(e, t) : ((n = Pe(t, e)).milliseconds = -n.milliseconds, n.months = -n.months);
      return n
    }(pe(a.from), pe(a.to)), (a = {}).ms = r.milliseconds, a.M = r.months), s = new ve(a), Me(e) && o(e, "_locale") && (s._locale = e._locale), s
  }

  function be(e, t) {
    var n = e && parseFloat(e.replace(",", "."));
    return (isNaN(n) ? 0 : n) * t
  }

  function Pe(e, t) {
    var n = {
      milliseconds: 0,
      months: 0
    };
    return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
  }

  function We(e, t) {
    return function(n, s) {
      var i, r;
      return null === s || isNaN(+s) || (M(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), r = n, n = s, s = r), n = "string" == typeof n ? +n : n, i = xe(n, s), He(this, i, e), this
    }
  }

  function He(t, n, s, i) {
    var r = n._milliseconds,
      a = Se(n._days),
      o = Se(n._months);
    t.isValid() && (i = null == i || i, o && z(t, A(t, "Month") + o * s), a && j(t, "Date", A(t, "Date") + a * s), r && t._d.setTime(t._d.valueOf() + r * s), i && e.updateOffset(t, a || o))
  }

  function Re(e, t) {
    var n, s = 12 * (t.year() - e.year()) + (t.month() - e.month()),
      i = e.clone().add(s, "months");
    return n = t - i < 0 ? (t - i) / (i - e.clone().add(s - 1, "months")) : (t - i) / (e.clone().add(s + 1, "months") - i), -(s + n) || 0
  }

  function Ce(e) {
    var t;
    return void 0 === e ? this._locale._abbr : (null != (t = ue(e)) && (this._locale = t), this)
  }

  function Fe() {
    return this._locale
  }

  function Ue(e, t) {
    P(0, [e, e.length], 0, t)
  }

  function Le(e, t, n, s, i) {
    var r;
    return null == e ? X(this, s, i).year : (r = K(e, s, i), t > r && (t = r), function(e, t, n, s, i) {
      var r = Q(e, t, n, s, i),
        a = J(r.year, 0, r.dayOfYear);
      return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this
    }.call(this, e, t, n, s, i))
  }

  function Ne(e, t) {
    t[Rt] = g(1e3 * ("0." + e))
  }

  function Ge(e) {
    return e
  }

  function Ve(e, t, n, s) {
    var i = ue(),
      r = l().set(s, t);
    return i[n](r, e)
  }

  function Ee(e, t, n) {
    if (i(e) && (t = e, e = void 0), e = e || "", null != t) return Ve(e, t, n, "month");
    var s, r = [];
    for (s = 0; s < 12; s++) r[s] = Ve(e, s, n, "month");
    return r
  }

  function Ie(e, t, n, s) {
    "boolean" == typeof e ? (i(t) && (n = t, t = void 0), t = t || "") : (n = t = e, e = !1, i(t) && (n = t, t = void 0), t = t || "");
    var r = ue(),
      a = e ? r._week.dow : 0;
    if (null != n) return Ve(t, (n + a) % 7, s, "day");
    var o, u = [];
    for (o = 0; o < 7; o++) u[o] = Ve(t, (o + a) % 7, s, "day");
    return u
  }

  function Ae(e, t, n, s) {
    var i = xe(t, n);
    return e._milliseconds += s * i._milliseconds, e._days += s * i._days, e._months += s * i._months, e._bubble()
  }

  function je(e) {
    return e < 0 ? Math.floor(e) : Math.ceil(e)
  }

  function Ze(e) {
    return 4800 * e / 146097
  }

  function ze(e) {
    return 146097 * e / 4800
  }

  function $e(e) {
    return function() {
      return this.as(e)
    }
  }

  function qe(e) {
    return function() {
      return this.isValid() ? this._data[e] : NaN
    }
  }

  function Je(e) {
    return (e > 0) - (e < 0) || +e
  }

  function Be() {
    if (!this.isValid()) return this.localeData().invalidDate();
    var e, t, n = An(this._milliseconds) / 1e3,
      s = An(this._days),
      i = An(this._months);
    t = y((e = y(n / 60)) / 60), n %= 60, e %= 60;
    var r = y(i / 12),
      a = i %= 12,
      o = s,
      u = t,
      l = e,
      d = n ? n.toFixed(3).replace(/\.?0+$/, "") : "",
      h = this.asSeconds();
    if (!h) return "P0D";
    var c = h < 0 ? "-" : "",
      f = Je(this._months) !== Je(h) ? "-" : "",
      m = Je(this._days) !== Je(h) ? "-" : "",
      _ = Je(this._milliseconds) !== Je(h) ? "-" : "";
    return c + "P" + (r ? f + r + "Y" : "") + (a ? f + a + "M" : "") + (o ? m + o + "D" : "") + (u || l || d ? "T" : "") + (u ? _ + u + "H" : "") + (l ? _ + l + "M" : "") + (d ? _ + d + "S" : "")
  }
  var Qe, Xe;
  Xe = Array.prototype.some ? Array.prototype.some : function(e) {
    for (var t = Object(this), n = t.length >>> 0, s = 0; s < n; s++)
      if (s in t && e.call(this, t[s], s, t)) return !0;
    return !1
  };
  var Ke = e.momentProperties = [],
    et = !1,
    tt = {};
  e.suppressDeprecationWarnings = !1, e.deprecationHandler = null;
  var nt;
  nt = Object.keys ? Object.keys : function(e) {
    var t, n = [];
    for (t in e) o(e, t) && n.push(t);
    return n
  };
  var st = {},
    it = {},
    rt = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    at = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    ot = {},
    ut = {},
    lt = /\d/,
    dt = /\d\d/,
    ht = /\d{3}/,
    ct = /\d{4}/,
    ft = /[+-]?\d{6}/,
    mt = /\d\d?/,
    _t = /\d\d\d\d?/,
    yt = /\d\d\d\d\d\d?/,
    gt = /\d{1,3}/,
    pt = /\d{1,4}/,
    wt = /[+-]?\d{1,6}/,
    vt = /\d+/,
    Mt = /[+-]?\d+/,
    St = /Z|[+-]\d\d:?\d\d/gi,
    Dt = /Z|[+-]\d\d(?::?\d\d)?/gi,
    kt = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
    Yt = {},
    Ot = {},
    Tt = 0,
    xt = 1,
    bt = 2,
    Pt = 3,
    Wt = 4,
    Ht = 5,
    Rt = 6,
    Ct = 7,
    Ft = 8;
  P("Y", 0, 0, function() {
    var e = this.year();
    return e <= 9999 ? "" + e : "+" + e
  }), P(0, ["YY", 2], 0, function() {
    return this.year() % 100
  }), P(0, ["YYYY", 4], 0, "year"), P(0, ["YYYYY", 5], 0, "year"), P(0, ["YYYYYY", 6, !0], 0, "year"), Y("year", "y"), x("year", 1), C("Y", Mt), C("YY", mt, dt), C("YYYY", pt, ct), C("YYYYY", wt, ft), C("YYYYYY", wt, ft), L(["YYYYY", "YYYYYY"], Tt), L("YYYY", function(t, n) {
    n[Tt] = 2 === t.length ? e.parseTwoDigitYear(t) : g(t)
  }), L("YY", function(t, n) {
    n[Tt] = e.parseTwoDigitYear(t)
  }), L("Y", function(e, t) {
    t[Tt] = parseInt(e, 10)
  }), e.parseTwoDigitYear = function(e) {
    return g(e) + (g(e) > 68 ? 1900 : 2e3)
  };
  var Ut, Lt = I("FullYear", !0);
  Ut = Array.prototype.indexOf ? Array.prototype.indexOf : function(e) {
    var t;
    for (t = 0; t < this.length; ++t)
      if (this[t] === e) return t;
    return -1
  }, P("M", ["MM", 2], "Mo", function() {
    return this.month() + 1
  }), P("MMM", 0, 0, function(e) {
    return this.localeData().monthsShort(this, e)
  }), P("MMMM", 0, 0, function(e) {
    return this.localeData().months(this, e)
  }), Y("month", "M"), x("month", 8), C("M", mt), C("MM", mt, dt), C("MMM", function(e, t) {
    return t.monthsShortRegex(e)
  }), C("MMMM", function(e, t) {
    return t.monthsRegex(e)
  }), L(["M", "MM"], function(e, t) {
    t[xt] = g(e) - 1
  }), L(["MMM", "MMMM"], function(e, t, n, s) {
    var i = n._locale.monthsParse(e, s, n._strict);
    null != i ? t[xt] = i : d(n).invalidMonth = e
  });
  var Nt = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
    Gt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    Vt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    Et = kt,
    It = kt;
  P("w", ["ww", 2], "wo", "week"), P("W", ["WW", 2], "Wo", "isoWeek"), Y("week", "w"), Y("isoWeek", "W"), x("week", 5), x("isoWeek", 5), C("w", mt), C("ww", mt, dt), C("W", mt), C("WW", mt, dt), N(["w", "ww", "W", "WW"], function(e, t, n, s) {
    t[s.substr(0, 1)] = g(e)
  });
  P("d", 0, "do", "day"), P("dd", 0, 0, function(e) {
    return this.localeData().weekdaysMin(this, e)
  }), P("ddd", 0, 0, function(e) {
    return this.localeData().weekdaysShort(this, e)
  }), P("dddd", 0, 0, function(e) {
    return this.localeData().weekdays(this, e)
  }), P("e", 0, 0, "weekday"), P("E", 0, 0, "isoWeekday"), Y("day", "d"), Y("weekday", "e"), Y("isoWeekday", "E"), x("day", 11), x("weekday", 11), x("isoWeekday", 11), C("d", mt), C("e", mt), C("E", mt), C("dd", function(e, t) {
    return t.weekdaysMinRegex(e)
  }), C("ddd", function(e, t) {
    return t.weekdaysShortRegex(e)
  }), C("dddd", function(e, t) {
    return t.weekdaysRegex(e)
  }), N(["dd", "ddd", "dddd"], function(e, t, n, s) {
    var i = n._locale.weekdaysParse(e, s, n._strict);
    null != i ? t.d = i : d(n).invalidWeekday = e
  }), N(["d", "e", "E"], function(e, t, n, s) {
    t[s] = g(e)
  });
  var At = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    jt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    Zt = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
    zt = kt,
    $t = kt,
    qt = kt;
  P("H", ["HH", 2], 0, "hour"), P("h", ["hh", 2], 0, te), P("k", ["kk", 2], 0, function() {
    return this.hours() || 24
  }), P("hmm", 0, 0, function() {
    return "" + te.apply(this) + b(this.minutes(), 2)
  }), P("hmmss", 0, 0, function() {
    return "" + te.apply(this) + b(this.minutes(), 2) + b(this.seconds(), 2)
  }), P("Hmm", 0, 0, function() {
    return "" + this.hours() + b(this.minutes(), 2)
  }), P("Hmmss", 0, 0, function() {
    return "" + this.hours() + b(this.minutes(), 2) + b(this.seconds(), 2)
  }), ne("a", !0), ne("A", !1), Y("hour", "h"), x("hour", 13), C("a", se), C("A", se), C("H", mt), C("h", mt), C("k", mt), C("HH", mt, dt), C("hh", mt, dt), C("kk", mt, dt), C("hmm", _t), C("hmmss", yt), C("Hmm", _t), C("Hmmss", yt), L(["H", "HH"], Pt), L(["k", "kk"], function(e, t, n) {
    var s = g(e);
    t[Pt] = 24 === s ? 0 : s
  }), L(["a", "A"], function(e, t, n) {
    n._isPm = n._locale.isPM(e), n._meridiem = e
  }), L(["h", "hh"], function(e, t, n) {
    t[Pt] = g(e), d(n).bigHour = !0
  }), L("hmm", function(e, t, n) {
    var s = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s)), d(n).bigHour = !0
  }), L("hmmss", function(e, t, n) {
    var s = e.length - 4,
      i = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Ht] = g(e.substr(i)), d(n).bigHour = !0
  }), L("Hmm", function(e, t, n) {
    var s = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s))
  }), L("Hmmss", function(e, t, n) {
    var s = e.length - 4,
      i = e.length - 2;
    t[Pt] = g(e.substr(0, s)), t[Wt] = g(e.substr(s, 2)), t[Ht] = g(e.substr(i))
  });
  var Jt, Bt = I("Hours", !0),
    Qt = {
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      longDateFormat: {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      invalidDate: "Invalid date",
      ordinal: "%d",
      dayOfMonthOrdinalParse: /\d{1,2}/,
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      months: Gt,
      monthsShort: Vt,
      week: {
        dow: 0,
        doy: 6
      },
      weekdays: At,
      weekdaysMin: Zt,
      weekdaysShort: jt,
      meridiemParse: /[ap]\.?m?\.?/i
    },
    Xt = {},
    Kt = {},
    en = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    tn = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    nn = /Z|[+-]\d\d(?::?\d\d)?/,
    sn = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, !1],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
      ["YYYYDDD", /\d{7}/]
    ],
    rn = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ],
    an = /^\/?Date\((\-?\d+)/i,
    on = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
    un = {
      UT: 0,
      GMT: 0,
      EDT: -240,
      EST: -300,
      CDT: -300,
      CST: -360,
      MDT: -360,
      MST: -420,
      PDT: -420,
      PST: -480
    };
  e.createFromInputFallback = v("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e) {
    e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
  }), e.ISO_8601 = function() {}, e.RFC_2822 = function() {};
  var ln = v("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e = pe.apply(null, arguments);
      return this.isValid() && e.isValid() ? e < this ? this : e : c()
    }),
    dn = v("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e = pe.apply(null, arguments);
      return this.isValid() && e.isValid() ? e > this ? this : e : c()
    }),
    hn = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
  De("Z", ":"), De("ZZ", ""), C("Z", Dt), C("ZZ", Dt), L(["Z", "ZZ"], function(e, t, n) {
    n._useUTC = !0, n._tzm = ke(Dt, e)
  });
  var cn = /([\+\-]|\d\d)/gi;
  e.updateOffset = function() {};
  var fn = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
    mn = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  xe.fn = ve.prototype, xe.invalid = function() {
    return xe(NaN)
  };
  var _n = We(1, "add"),
    yn = We(-1, "subtract");
  e.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", e.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  var gn = v("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e) {
    return void 0 === e ? this.localeData() : this.locale(e)
  });
  P(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100
  }), P(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100
  }), Ue("gggg", "weekYear"), Ue("ggggg", "weekYear"), Ue("GGGG", "isoWeekYear"), Ue("GGGGG", "isoWeekYear"), Y("weekYear", "gg"), Y("isoWeekYear", "GG"), x("weekYear", 1), x("isoWeekYear", 1), C("G", Mt), C("g", Mt), C("GG", mt, dt), C("gg", mt, dt), C("GGGG", pt, ct), C("gggg", pt, ct), C("GGGGG", wt, ft), C("ggggg", wt, ft), N(["gggg", "ggggg", "GGGG", "GGGGG"], function(e, t, n, s) {
    t[s.substr(0, 2)] = g(e)
  }), N(["gg", "GG"], function(t, n, s, i) {
    n[i] = e.parseTwoDigitYear(t)
  }), P("Q", 0, "Qo", "quarter"), Y("quarter", "Q"), x("quarter", 7), C("Q", lt), L("Q", function(e, t) {
    t[xt] = 3 * (g(e) - 1)
  }), P("D", ["DD", 2], "Do", "date"), Y("date", "D"), x("date", 9), C("D", mt), C("DD", mt, dt), C("Do", function(e, t) {
    return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
  }), L(["D", "DD"], bt), L("Do", function(e, t) {
    t[bt] = g(e.match(mt)[0])
  });
  var pn = I("Date", !0);
  P("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), Y("dayOfYear", "DDD"), x("dayOfYear", 4), C("DDD", gt), C("DDDD", ht), L(["DDD", "DDDD"], function(e, t, n) {
    n._dayOfYear = g(e)
  }), P("m", ["mm", 2], 0, "minute"), Y("minute", "m"), x("minute", 14), C("m", mt), C("mm", mt, dt), L(["m", "mm"], Wt);
  var wn = I("Minutes", !1);
  P("s", ["ss", 2], 0, "second"), Y("second", "s"), x("second", 15), C("s", mt), C("ss", mt, dt), L(["s", "ss"], Ht);
  var vn = I("Seconds", !1);
  P("S", 0, 0, function() {
    return ~~(this.millisecond() / 100)
  }), P(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10)
  }), P(0, ["SSS", 3], 0, "millisecond"), P(0, ["SSSS", 4], 0, function() {
    return 10 * this.millisecond()
  }), P(0, ["SSSSS", 5], 0, function() {
    return 100 * this.millisecond()
  }), P(0, ["SSSSSS", 6], 0, function() {
    return 1e3 * this.millisecond()
  }), P(0, ["SSSSSSS", 7], 0, function() {
    return 1e4 * this.millisecond()
  }), P(0, ["SSSSSSSS", 8], 0, function() {
    return 1e5 * this.millisecond()
  }), P(0, ["SSSSSSSSS", 9], 0, function() {
    return 1e6 * this.millisecond()
  }), Y("millisecond", "ms"), x("millisecond", 16), C("S", gt, lt), C("SS", gt, dt), C("SSS", gt, ht);
  var Mn;
  for (Mn = "SSSS"; Mn.length <= 9; Mn += "S") C(Mn, vt);
  for (Mn = "S"; Mn.length <= 9; Mn += "S") L(Mn, Ne);
  var Sn = I("Milliseconds", !1);
  P("z", 0, 0, "zoneAbbr"), P("zz", 0, 0, "zoneName");
  var Dn = m.prototype;
  Dn.add = _n, Dn.calendar = function(t, n) {
    var s = t || pe(),
      i = Ye(s, this).startOf("day"),
      r = e.calendarFormat(this, i) || "sameElse",
      a = n && (S(n[r]) ? n[r].call(this, s) : n[r]);
    return this.format(a || this.localeData().calendar(r, this, pe(s)))
  }, Dn.clone = function() {
    return new m(this)
  }, Dn.diff = function(e, t, n) {
    var s, i, r;
    if (!this.isValid()) return NaN;
    if (!(s = Ye(e, this)).isValid()) return NaN;
    switch (i = 6e4 * (s.utcOffset() - this.utcOffset()), t = O(t)) {
      case "year":
        r = Re(this, s) / 12;
        break;
      case "month":
        r = Re(this, s);
        break;
      case "quarter":
        r = Re(this, s) / 3;
        break;
      case "second":
        r = (this - s) / 1e3;
        break;
      case "minute":
        r = (this - s) / 6e4;
        break;
      case "hour":
        r = (this - s) / 36e5;
        break;
      case "day":
        r = (this - s - i) / 864e5;
        break;
      case "week":
        r = (this - s - i) / 6048e5;
        break;
      default:
        r = this - s
    }
    return n ? r : y(r)
  }, Dn.endOf = function(e) {
    return void 0 === (e = O(e)) || "millisecond" === e ? this : ("date" === e && (e = "day"), this.startOf(e).add(1, "isoWeek" === e ? "week" : e).subtract(1, "ms"))
  }, Dn.format = function(t) {
    t || (t = this.isUtc() ? e.defaultFormatUtc : e.defaultFormat);
    var n = H(this, t);
    return this.localeData().postformat(n)
  }, Dn.from = function(e, t) {
    return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? xe({
      to: this,
      from: e
    }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
  }, Dn.fromNow = function(e) {
    return this.from(pe(), e)
  }, Dn.to = function(e, t) {
    return this.isValid() && (_(e) && e.isValid() || pe(e).isValid()) ? xe({
      from: this,
      to: e
    }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
  }, Dn.toNow = function(e) {
    return this.to(pe(), e)
  }, Dn.get = function(e) {
    return e = O(e), S(this[e]) ? this[e]() : this
  }, Dn.invalidAt = function() {
    return d(this).overflow
  }, Dn.isAfter = function(e, t) {
    var n = _(e) ? e : pe(e);
    return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
  }, Dn.isBefore = function(e, t) {
    var n = _(e) ? e : pe(e);
    return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(s(t) ? "millisecond" : t)) ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
  }, Dn.isBetween = function(e, t, n, s) {
    return ("(" === (s = s || "()")[0] ? this.isAfter(e, n) : !this.isBefore(e, n)) && (")" === s[1] ? this.isBefore(t, n) : !this.isAfter(t, n))
  }, Dn.isSame = function(e, t) {
    var n, s = _(e) ? e : pe(e);
    return !(!this.isValid() || !s.isValid()) && ("millisecond" === (t = O(t || "millisecond")) ? this.valueOf() === s.valueOf() : (n = s.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
  }, Dn.isSameOrAfter = function(e, t) {
    return this.isSame(e, t) || this.isAfter(e, t)
  }, Dn.isSameOrBefore = function(e, t) {
    return this.isSame(e, t) || this.isBefore(e, t)
  }, Dn.isValid = function() {
    return h(this)
  }, Dn.lang = gn, Dn.locale = Ce, Dn.localeData = Fe, Dn.max = dn, Dn.min = ln, Dn.parsingFlags = function() {
    return u({}, d(this))
  }, Dn.set = function(e, t) {
    if ("object" == typeof e)
      for (var n = function(e) {
          var t = [];
          for (var n in e) t.push({
            unit: n,
            priority: it[n]
          });
          return t.sort(function(e, t) {
            return e.priority - t.priority
          }), t
        }(e = T(e)), s = 0; s < n.length; s++) this[n[s].unit](e[n[s].unit]);
    else if (e = O(e), S(this[e])) return this[e](t);
    return this
  }, Dn.startOf = function(e) {
    switch (e = O(e)) {
      case "year":
        this.month(0);
      case "quarter":
      case "month":
        this.date(1);
      case "week":
      case "isoWeek":
      case "day":
      case "date":
        this.hours(0);
      case "hour":
        this.minutes(0);
      case "minute":
        this.seconds(0);
      case "second":
        this.milliseconds(0)
    }
    return "week" === e && this.weekday(0), "isoWeek" === e && this.isoWeekday(1), "quarter" === e && this.month(3 * Math.floor(this.month() / 3)), this
  }, Dn.subtract = yn, Dn.toArray = function() {
    return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]
  }, Dn.toObject = function() {
    return {
      years: this.year(),
      months: this.month(),
      date: this.date(),
      hours: this.hours(),
      minutes: this.minutes(),
      seconds: this.seconds(),
      milliseconds: this.milliseconds()
    }
  }, Dn.toDate = function() {
    return new Date(this.valueOf())
  }, Dn.toISOString = function(e) {
    if (!this.isValid()) return null;
    var t = !0 !== e,
      n = t ? this.clone().utc() : this;
    return n.year() < 0 || n.year() > 9999 ? H(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : S(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this._d.valueOf()).toISOString().replace("Z", H(n, "Z")) : H(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
  }, Dn.inspect = function() {
    if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
    var e = "moment",
      t = "";
    this.isLocal() || (e = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t = "Z");
    var n = "[" + e + '("]',
      s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
      i = t + '[")]';
    return this.format(n + s + "-MM-DD[T]HH:mm:ss.SSS" + i)
  }, Dn.toJSON = function() {
    return this.isValid() ? this.toISOString() : null
  }, Dn.toString = function() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
  }, Dn.unix = function() {
    return Math.floor(this.valueOf() / 1e3)
  }, Dn.valueOf = function() {
    return this._d.valueOf() - 6e4 * (this._offset || 0)
  }, Dn.creationData = function() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    }
  }, Dn.year = Lt, Dn.isLeapYear = function() {
    return E(this.year())
  }, Dn.weekYear = function(e) {
    return Le.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
  }, Dn.isoWeekYear = function(e) {
    return Le.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
  }, Dn.quarter = Dn.quarters = function(e) {
    return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
  }, Dn.month = $, Dn.daysInMonth = function() {
    return Z(this.year(), this.month())
  }, Dn.week = Dn.weeks = function(e) {
    var t = this.localeData().week(this);
    return null == e ? t : this.add(7 * (e - t), "d")
  }, Dn.isoWeek = Dn.isoWeeks = function(e) {
    var t = X(this, 1, 4).week;
    return null == e ? t : this.add(7 * (e - t), "d")
  }, Dn.weeksInYear = function() {
    var e = this.localeData()._week;
    return K(this.year(), e.dow, e.doy)
  }, Dn.isoWeeksInYear = function() {
    return K(this.year(), 1, 4)
  }, Dn.date = pn, Dn.day = Dn.days = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return null != e ? (e = function(e, t) {
      return "string" != typeof e ? e : isNaN(e) ? "number" == typeof(e = t.weekdaysParse(e)) ? e : null : parseInt(e, 10)
    }(e, this.localeData()), this.add(e - t, "d")) : t
  }, Dn.weekday = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return null == e ? t : this.add(e - t, "d")
  }, Dn.isoWeekday = function(e) {
    if (!this.isValid()) return null != e ? this : NaN;
    if (null != e) {
      var t = function(e, t) {
        return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
      }(e, this.localeData());
      return this.day(this.day() % 7 ? t : t - 7)
    }
    return this.day() || 7
  }, Dn.dayOfYear = function(e) {
    var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return null == e ? t : this.add(e - t, "d")
  }, Dn.hour = Dn.hours = Bt, Dn.minute = Dn.minutes = wn, Dn.second = Dn.seconds = vn, Dn.millisecond = Dn.milliseconds = Sn, Dn.utcOffset = function(t, n, s) {
    var i, r = this._offset || 0;
    if (!this.isValid()) return null != t ? this : NaN;
    if (null != t) {
      if ("string" == typeof t) {
        if (null === (t = ke(Dt, t))) return this
      } else Math.abs(t) < 16 && !s && (t *= 60);
      return !this._isUTC && n && (i = Oe(this)), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), r !== t && (!n || this._changeInProgress ? He(this, xe(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, e.updateOffset(this, !0), this._changeInProgress = null)), this
    }
    return this._isUTC ? r : Oe(this)
  }, Dn.utc = function(e) {
    return this.utcOffset(0, e)
  }, Dn.local = function(e) {
    return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Oe(this), "m")), this
  }, Dn.parseZone = function() {
    if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
    else if ("string" == typeof this._i) {
      var e = ke(St, this._i);
      null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
    }
    return this
  }, Dn.hasAlignedHourOffset = function(e) {
    return !!this.isValid() && (e = e ? pe(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
  }, Dn.isDST = function() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
  }, Dn.isLocal = function() {
    return !!this.isValid() && !this._isUTC
  }, Dn.isUtcOffset = function() {
    return !!this.isValid() && this._isUTC
  }, Dn.isUtc = Te, Dn.isUTC = Te, Dn.zoneAbbr = function() {
    return this._isUTC ? "UTC" : ""
  }, Dn.zoneName = function() {
    return this._isUTC ? "Coordinated Universal Time" : ""
  }, Dn.dates = v("dates accessor is deprecated. Use date instead.", pn), Dn.months = v("months accessor is deprecated. Use month instead", $), Dn.years = v("years accessor is deprecated. Use year instead", Lt), Dn.zone = v("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(e, t) {
    return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
  }), Dn.isDSTShifted = v("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
    if (!s(this._isDSTShifted)) return this._isDSTShifted;
    var e = {};
    if (f(e, this), (e = ye(e))._a) {
      var t = e._isUTC ? l(e._a) : pe(e._a);
      this._isDSTShifted = this.isValid() && p(e._a, t.toArray()) > 0
    } else this._isDSTShifted = !1;
    return this._isDSTShifted
  });
  var kn = k.prototype;
  kn.calendar = function(e, t, n) {
    var s = this._calendar[e] || this._calendar.sameElse;
    return S(s) ? s.call(t, n) : s
  }, kn.longDateFormat = function(e) {
    var t = this._longDateFormat[e],
      n = this._longDateFormat[e.toUpperCase()];
    return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, function(e) {
      return e.slice(1)
    }), this._longDateFormat[e])
  }, kn.invalidDate = function() {
    return this._invalidDate
  }, kn.ordinal = function(e) {
    return this._ordinal.replace("%d", e)
  }, kn.preparse = Ge, kn.postformat = Ge, kn.relativeTime = function(e, t, n, s) {
    var i = this._relativeTime[n];
    return S(i) ? i(e, t, n, s) : i.replace(/%d/i, e)
  }, kn.pastFuture = function(e, t) {
    var n = this._relativeTime[e > 0 ? "future" : "past"];
    return S(n) ? n(t) : n.replace(/%s/i, t)
  }, kn.set = function(e) {
    var t, n;
    for (n in e) S(t = e[n]) ? this[n] = t : this["_" + n] = t;
    this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
  }, kn.months = function(e, n) {
    return e ? t(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || Nt).test(n) ? "format" : "standalone"][e.month()] : t(this._months) ? this._months : this._months.standalone
  }, kn.monthsShort = function(e, n) {
    return e ? t(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[Nt.test(n) ? "format" : "standalone"][e.month()] : t(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
  }, kn.monthsParse = function(e, t, n) {
    var s, i, r;
    if (this._monthsParseExact) return function(e, t, n) {
      var s, i, r, a = e.toLocaleLowerCase();
      if (!this._monthsParse)
        for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s) r = l([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[s] = this.months(r, "").toLocaleLowerCase();
      return n ? "MMM" === t ? -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : null : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : null : "MMM" === t ? -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : null : -1 !== (i = Ut.call(this._longMonthsParse, a)) ? i : -1 !== (i = Ut.call(this._shortMonthsParse, a)) ? i : null
    }.call(this, e, t, n);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
      if (i = l([2e3, s]), n && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[s] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[s] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[s].test(e)) return s;
      if (n && "MMM" === t && this._shortMonthsParse[s].test(e)) return s;
      if (!n && this._monthsParse[s].test(e)) return s
    }
  }, kn.monthsRegex = function(e) {
    return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (o(this, "_monthsRegex") || (this._monthsRegex = It), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
  }, kn.monthsShortRegex = function(e) {
    return this._monthsParseExact ? (o(this, "_monthsRegex") || q.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (o(this, "_monthsShortRegex") || (this._monthsShortRegex = Et), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
  }, kn.week = function(e) {
    return X(e, this._week.dow, this._week.doy).week
  }, kn.firstDayOfYear = function() {
    return this._week.doy
  }, kn.firstDayOfWeek = function() {
    return this._week.dow
  }, kn.weekdays = function(e, n) {
    return e ? t(this._weekdays) ? this._weekdays[e.day()] : this._weekdays[this._weekdays.isFormat.test(n) ? "format" : "standalone"][e.day()] : t(this._weekdays) ? this._weekdays : this._weekdays.standalone
  }, kn.weekdaysMin = function(e) {
    return e ? this._weekdaysMin[e.day()] : this._weekdaysMin
  }, kn.weekdaysShort = function(e) {
    return e ? this._weekdaysShort[e.day()] : this._weekdaysShort
  }, kn.weekdaysParse = function(e, t, n) {
    var s, i, r;
    if (this._weekdaysParseExact) return function(e, t, n) {
      var s, i, r, a = e.toLocaleLowerCase();
      if (!this._weekdaysParse)
        for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s) r = l([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(r, "").toLocaleLowerCase();
      return n ? "dddd" === t ? -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : null : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : "dddd" === t ? -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : "ddd" === t ? -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : null : -1 !== (i = Ut.call(this._minWeekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._weekdaysParse, a)) ? i : -1 !== (i = Ut.call(this._shortWeekdaysParse, a)) ? i : null
    }.call(this, e, t, n);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
      if (i = l([2e3, 1]).day(s), n && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp("^" + this.weekdays(i, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[s] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[s] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[s] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[s] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[s].test(e)) return s;
      if (n && "ddd" === t && this._shortWeekdaysParse[s].test(e)) return s;
      if (n && "dd" === t && this._minWeekdaysParse[s].test(e)) return s;
      if (!n && this._weekdaysParse[s].test(e)) return s
    }
  }, kn.weekdaysRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (o(this, "_weekdaysRegex") || (this._weekdaysRegex = zt), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
  }, kn.weekdaysShortRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (o(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = $t), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
  }, kn.weekdaysMinRegex = function(e) {
    return this._weekdaysParseExact ? (o(this, "_weekdaysRegex") || ee.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (o(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = qt), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
  }, kn.isPM = function(e) {
    return "p" === (e + "").toLowerCase().charAt(0)
  }, kn.meridiem = function(e, t, n) {
    return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
  }, ae("en", {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(e) {
      var t = e % 10;
      return e + (1 === g(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
    }
  }), e.lang = v("moment.lang is deprecated. Use moment.locale instead.", ae), e.langData = v("moment.langData is deprecated. Use moment.localeData instead.", ue);
  var Yn = Math.abs,
    On = $e("ms"),
    Tn = $e("s"),
    xn = $e("m"),
    bn = $e("h"),
    Pn = $e("d"),
    Wn = $e("w"),
    Hn = $e("M"),
    Rn = $e("y"),
    Cn = qe("milliseconds"),
    Fn = qe("seconds"),
    Un = qe("minutes"),
    Ln = qe("hours"),
    Nn = qe("days"),
    Gn = qe("months"),
    Vn = qe("years"),
    En = Math.round,
    In = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    },
    An = Math.abs,
    jn = ve.prototype;
  return jn.isValid = function() {
      return this._isValid
    }, jn.abs = function() {
      var e = this._data;
      return this._milliseconds = Yn(this._milliseconds), this._days = Yn(this._days), this._months = Yn(this._months), e.milliseconds = Yn(e.milliseconds), e.seconds = Yn(e.seconds), e.minutes = Yn(e.minutes), e.hours = Yn(e.hours), e.months = Yn(e.months), e.years = Yn(e.years), this
    }, jn.add = function(e, t) {
      return Ae(this, e, t, 1)
    }, jn.subtract = function(e, t) {
      return Ae(this, e, t, -1)
    }, jn.as = function(e) {
      if (!this.isValid()) return NaN;
      var t, n, s = this._milliseconds;
      if ("month" === (e = O(e)) || "year" === e) return t = this._days + s / 864e5, n = this._months + Ze(t), "month" === e ? n : n / 12;
      switch (t = this._days + Math.round(ze(this._months)), e) {
        case "week":
          return t / 7 + s / 6048e5;
        case "day":
          return t + s / 864e5;
        case "hour":
          return 24 * t + s / 36e5;
        case "minute":
          return 1440 * t + s / 6e4;
        case "second":
          return 86400 * t + s / 1e3;
        case "millisecond":
          return Math.floor(864e5 * t) + s;
        default:
          throw new Error("Unknown unit " + e)
      }
    }, jn.asMilliseconds = On, jn.asSeconds = Tn, jn.asMinutes = xn, jn.asHours = bn, jn.asDays = Pn, jn.asWeeks = Wn, jn.asMonths = Hn, jn.asYears = Rn, jn.valueOf = function() {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN
    }, jn._bubble = function() {
      var e, t, n, s, i, r = this._milliseconds,
        a = this._days,
        o = this._months,
        u = this._data;
      return r >= 0 && a >= 0 && o >= 0 || r <= 0 && a <= 0 && o <= 0 || (r += 864e5 * je(ze(o) + a), a = 0, o = 0), u.milliseconds = r % 1e3, e = y(r / 1e3), u.seconds = e % 60, t = y(e / 60), u.minutes = t % 60, n = y(t / 60), u.hours = n % 24, a += y(n / 24), i = y(Ze(a)), o += i, a -= je(ze(i)), s = y(o / 12), o %= 12, u.days = a, u.months = o, u.years = s, this
    }, jn.clone = function() {
      return xe(this)
    }, jn.get = function(e) {
      return e = O(e), this.isValid() ? this[e + "s"]() : NaN
    }, jn.milliseconds = Cn, jn.seconds = Fn, jn.minutes = Un, jn.hours = Ln, jn.days = Nn, jn.weeks = function() {
      return y(this.days() / 7)
    }, jn.months = Gn, jn.years = Vn, jn.humanize = function(e) {
      if (!this.isValid()) return this.localeData().invalidDate();
      var t = this.localeData(),
        n = function(e, t, n) {
          var s = xe(e).abs(),
            i = En(s.as("s")),
            r = En(s.as("m")),
            a = En(s.as("h")),
            o = En(s.as("d")),
            u = En(s.as("M")),
            l = En(s.as("y")),
            d = i <= In.ss && ["s", i] || i < In.s && ["ss", i] || r <= 1 && ["m"] || r < In.m && ["mm", r] || a <= 1 && ["h"] || a < In.h && ["hh", a] || o <= 1 && ["d"] || o < In.d && ["dd", o] || u <= 1 && ["M"] || u < In.M && ["MM", u] || l <= 1 && ["y"] || ["yy", l];
          return d[2] = t, d[3] = +e > 0, d[4] = n,
            function(e, t, n, s, i) {
              return i.relativeTime(t || 1, !!n, e, s)
            }.apply(null, d)
        }(this, !e, t);
      return e && (n = t.pastFuture(+this, n)), t.postformat(n)
    }, jn.toISOString = Be, jn.toString = Be, jn.toJSON = Be, jn.locale = Ce, jn.localeData = Fe, jn.toIsoString = v("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Be), jn.lang = gn, P("X", 0, 0, "unix"), P("x", 0, 0, "valueOf"), C("x", Mt), C("X", /[+-]?\d+(\.\d{1,3})?/), L("X", function(e, t, n) {
      n._d = new Date(1e3 * parseFloat(e, 10))
    }), L("x", function(e, t, n) {
      n._d = new Date(g(e))
    }), e.version = "2.20.1",
    function(e) {
      Qe = e
    }(pe), e.fn = Dn, e.min = function() {
      return we("isBefore", [].slice.call(arguments, 0))
    }, e.max = function() {
      return we("isAfter", [].slice.call(arguments, 0))
    }, e.now = function() {
      return Date.now ? Date.now() : +new Date
    }, e.utc = l, e.unix = function(e) {
      return pe(1e3 * e)
    }, e.months = function(e, t) {
      return Ee(e, t, "months")
    }, e.isDate = r, e.locale = ae, e.invalid = c, e.duration = xe, e.isMoment = _, e.weekdays = function(e, t, n) {
      return Ie(e, t, n, "weekdays")
    }, e.parseZone = function() {
      return pe.apply(null, arguments).parseZone()
    }, e.localeData = ue, e.isDuration = Me, e.monthsShort = function(e, t) {
      return Ee(e, t, "monthsShort")
    }, e.weekdaysMin = function(e, t, n) {
      return Ie(e, t, n, "weekdaysMin")
    }, e.defineLocale = oe, e.updateLocale = function(e, t) {
      if (null != t) {
        var n, s, i = Qt;
        null != (s = re(e)) && (i = s._config), (n = new k(t = D(i, t))).parentLocale = Xt[e], Xt[e] = n, ae(e)
      } else null != Xt[e] && (null != Xt[e].parentLocale ? Xt[e] = Xt[e].parentLocale : null != Xt[e] && delete Xt[e]);
      return Xt[e]
    }, e.locales = function() {
      return nt(Xt)
    }, e.weekdaysShort = function(e, t, n) {
      return Ie(e, t, n, "weekdaysShort")
    }, e.normalizeUnits = O, e.relativeTimeRounding = function(e) {
      return void 0 === e ? En : "function" == typeof e && (En = e, !0)
    }, e.relativeTimeThreshold = function(e, t) {
      return void 0 !== In[e] && (void 0 === t ? In[e] : (In[e] = t, "s" === e && (In.ss = t - 1), !0))
    }, e.calendarFormat = function(e, t) {
      var n = e.diff(t, "days", !0);
      return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
    }, e.prototype = Dn, e.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "YYYY-[W]WW",
      MONTH: "YYYY-MM"
    }, e
});
/*! RESOURCE: /scripts/reportlibs/fullcalendar.min.js */
/*!
 * FullCalendar v2.2.7
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2013 Adam Shaw
 * (c) 2015 Tanguy Pruvot
 * The minimized version which we use is based on this customized version
 */
! function(t) {
  "function" == typeof define && define.amd ? define(["jquery", "moment"], t) : t(jQuery, moment)
}(function(t, e) {
  function n(t) {
    i(St, t)
  }

  function i(e) {
    function n(n, s) {
      t.isPlainObject(s) && t.isPlainObject(e[n]) && !r(n) ? e[n] = i({}, e[n], s) : void 0 !== s && (e[n] = s)
    }
    for (var s = 1; s < arguments.length; s++) t.each(arguments[s], n);
    return e
  }

  function r(t) {
    return /(Time|Duration)$/.test(t)
  }

  function s(t) {
    var n = e.localeData || e.langData;
    return n.call(e, t) || n.call(e, "en")
  }

  function o(t, e) {
    e.left && t.css({
      "border-left-width": 1,
      "margin-left": e.left - 1
    }), e.right && t.css({
      "border-right-width": 1,
      "margin-right": e.right - 1
    })
  }

  function a(t) {
    t.css({
      "margin-left": "",
      "margin-right": "",
      "border-left-width": "",
      "border-right-width": ""
    })
  }

  function l() {
    t("body").addClass("fc-not-allowed")
  }

  function d() {
    t("body").removeClass("fc-not-allowed")
  }

  function u(e, n, i) {
    var r = Math.floor(n / e.length),
      s = Math.floor(n - r * (e.length - 1)),
      o = [],
      a = [],
      l = [],
      d = 0;
    c(e), e.each(function(n, i) {
      var u = n === e.length - 1 ? s : r,
        c = t(i).outerHeight(!0);
      u > c ? (o.push(i), a.push(c), l.push(t(i).height())) : d += c
    }), i && (n -= d, r = Math.floor(n / o.length), s = Math.floor(n - r * (o.length - 1))), t(o).each(function(e, n) {
      var i = e === o.length - 1 ? s : r,
        d = a[e],
        u = l[e],
        c = i - (d - u);
      i > d && t(n).height(c)
    })
  }

  function c(t) {
    t.height("")
  }

  function h(e) {
    var n = 0;
    return e.find("> *").each(function(e, i) {
      var r = t(i).outerWidth();
      r > n && (n = r)
    }), n++, e.width(n), n
  }

  function f(t, e) {
    return t.height(e).addClass("fc-scroller"), t[0].scrollHeight - 1 > t[0].clientHeight ? !0 : (g(t), !1)
  }

  function g(t) {
    t.height("").removeClass("fc-scroller")
  }

  function p(e) {
    var n = e.css("position"),
      i = e.parents().filter(function() {
        var e = t(this);
        return /(auto|scroll)/.test(e.css("overflow") + e.css("overflow-y") + e.css("overflow-x"))
      }).eq(0);
    return "fixed" !== n && i.length ? i : t(e[0].ownerDocument || document)
  }

  function m(t) {
    var e = t.offset().left,
      n = e + t.width(),
      i = t.children(),
      r = i.offset().left,
      s = r + i.outerWidth();
    return {
      left: r - e,
      right: n - s
    }
  }

  function v(t) {
    return 1 == t.which && !t.ctrlKey
  }

  function y(t, e) {
    var n, i, r, s, o = t.start,
      a = t.end,
      l = e.start,
      d = e.end;
    return a > l && d > o ? (o >= l ? (n = o.clone(), r = !0) : (n = l.clone(), r = !1), d >= a ? (i = a.clone(), s = !0) : (i = d.clone(), s = !1), {
      start: n,
      end: i,
      isStart: r,
      isEnd: s
    }) : void 0
  }

  function w(t, e) {
    if (t = t || {}, void 0 !== t[e]) return t[e];
    for (var n, i = e.split(/(?=[A-Z])/), r = i.length - 1; r >= 0; r--)
      if (n = t[i[r].toLowerCase()], void 0 !== n) return n;
    return t["default"]
  }

  function b(t, n) {
    return e.duration({
      days: t.clone().stripTime().diff(n.clone().stripTime(), "days"),
      ms: t.time() - n.time()
    })
  }

  function S(t, n) {
    return e.duration({
      days: t.clone().stripTime().diff(n.clone().stripTime(), "days")
    })
  }

  function E(t, e) {
    var n, i, r;
    for (n = 0; n < Nt.length && (i = Nt[n], r = C(i, t, e), !(r >= 1 && L(r))); n++);
    return i
  }

  function C(t, n, i) {
    return null != i ? i.diff(n, t, !0) : e.isDuration(n) ? n.as(t) : n.end.diff(n.start, t, !0)
  }

  function D(t) {
    return "[object Date]" === Object.prototype.toString.call(t) || t instanceof Date
  }

  function T(t) {
    return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(t)
  }

  function k(t) {
    var e = function() {};
    return e.prototype = t, new e
  }

  function H(t, e) {
    for (var n in t) R(t, n) && (e[n] = t[n])
  }

  function x(t, e) {
    var n, i, r = ["constructor", "toString", "valueOf"];
    for (n = 0; n < r.length; n++) i = r[n], t[i] !== Object.prototype[i] && (e[i] = t[i])
  }

  function R(t, e) {
    return Vt.call(t, e)
  }

  function M(e) {
    return /undefined|null|boolean|number|string/.test(t.type(e))
  }

  function F(e, n, i) {
    if (t.isFunction(e) && (e = [e]), e) {
      var r, s;
      for (r = 0; r < e.length; r++) s = e[r].apply(n, i) || s;
      return s
    }
  }

  function G() {
    for (var t = 0; t < arguments.length; t++)
      if (void 0 !== arguments[t]) return arguments[t]
  }

  function N(t) {
    return (t + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#039;").replace(/"/g, "&quot;").replace(/\n/g, "<br />")
  }

  function V(t) {
    return t.replace(/&.*?;/g, "")
  }

  function Y(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
  }

  function z(t, e) {
    return t - e
  }

  function L(t) {
    return t % 1 === 0
  }

  function _(t, e) {
    var n, i, r, s, o = function() {
      var a = +new Date - s;
      e > a && a > 0 ? n = setTimeout(o, e - a) : (n = null, t.apply(r, i), n || (r = i = null))
    };
    return function() {
      r = this, i = arguments, s = +new Date, n || (n = setTimeout(o, e))
    }
  }

  function P(n, i, r) {
    var s, o, a, l, d = n[0],
      u = 1 == n.length && "string" == typeof d;
    return e.isMoment(d) ? (l = e.apply(null, n), O(d, l)) : D(d) || void 0 === d ? l = e.apply(null, n) : (s = !1, o = !1, u ? Yt.test(d) ? (d += "-01", n = [d], s = !0, o = !0) : (a = zt.exec(d)) && (s = !a[5], o = !0) : t.isArray(d) && (o = !0), l = i || s ? e.utc.apply(e, n) : e.apply(null, n), s ? (l._ambigTime = !0, l._ambigZone = !0) : r && (o ? l._ambigZone = !0 : u && l.zone(d))), l._fullCalendar = !0, l
  }

  function A(t, n) {
    var i, r, s = !1,
      o = !1,
      a = t.length,
      l = [];
    for (i = 0; a > i; i++) r = t[i], e.isMoment(r) || (r = Dt.moment.parseZone(r)), s = s || r._ambigTime, o = o || r._ambigZone, l.push(r);
    for (i = 0; a > i; i++) r = l[i], n || !s || r._ambigTime ? o && !r._ambigZone && (l[i] = r.clone().stripZone()) : l[i] = r.clone().stripTime();
    return l
  }

  function O(t, e) {
    t._ambigTime ? e._ambigTime = !0 : e._ambigTime && (e._ambigTime = !1), t._ambigZone ? e._ambigZone = !0 : e._ambigZone && (e._ambigZone = !1)
  }

  function B(t, e) {
    t.year(e[0] || 0).month(e[1] || 0).date(e[2] || 0).hours(e[3] || 0).minutes(e[4] || 0).seconds(e[5] || 0).milliseconds(e[6] || 0)
  }

  function W(t, e) {
    return _t.format.call(t, e)
  }

  function I(t, e) {
    return Z(t, q(e))
  }

  function Z(t, e) {
    var n, i = "";
    for (n = 0; n < e.length; n++) i += j(t, e[n]);
    return i
  }

  function j(t, e) {
    var n, i;
    return "string" == typeof e ? e : (n = e.token) ? Pt[n] ? Pt[n](t) : W(t, n) : e.maybe && (i = Z(t, e.maybe), i.match(/[1-9]/)) ? i : ""
  }

  function X(t, e, n, i, r) {
    var s;
    return t = Dt.moment.parseZone(t), e = Dt.moment.parseZone(e), s = (t.localeData || t.lang).call(t), n = s.longDateFormat(n) || n, i = i || " - ", U(t, e, q(n), i, r)
  }

  function U(t, e, n, i, r) {
    var s, o, a, l, d = "",
      u = "",
      c = "",
      h = "",
      f = "";
    for (o = 0; o < n.length && (s = $(t, e, n[o]), s !== !1); o++) d += s;
    for (a = n.length - 1; a > o && (s = $(t, e, n[a]), s !== !1); a--) u = s + u;
    for (l = o; a >= l; l++) c += j(t, n[l]), h += j(e, n[l]);
    return (c || h) && (f = r ? h + i + c : c + i + h), d + f + u
  }

  function $(t, e, n) {
    var i, r;
    return "string" == typeof n ? n : (i = n.token) && (r = At[i.charAt(0)], r && t.isSame(e, r)) ? W(t, i) : !1
  }

  function q(t) {
    return t in Ot ? Ot[t] : Ot[t] = K(t)
  }

  function K(t) {
    for (var e, n = [], i = /\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g; e = i.exec(t);) e[1] ? n.push(e[1]) : e[2] ? n.push({
      maybe: K(e[2])
    }) : e[3] ? n.push({
      token: e[3]
    }) : e[5] && n.push(e[5]);
    return n
  }

  function Q() {}

  function J(t, e) {
    return t || e ? t && e ? t.grid === e.grid && t.row === e.row && t.col === e.col : !1 : !0
  }

  function tt(t) {
    var e = nt(t);
    return "background" === e || "inverse-background" === e
  }

  function et(t) {
    return "inverse-background" === nt(t)
  }

  function nt(t) {
    return G((t.source || {}).rendering, t.rendering)
  }

  function it(t) {
    var e, n, i = {};
    for (e = 0; e < t.length; e++) n = t[e], (i[n._id] || (i[n._id] = [])).push(n);
    return i
  }

  function rt(t, e) {
    return t.eventStartMS - e.eventStartMS
  }

  function st(t, e) {
    return t.eventStartMS - e.eventStartMS || e.eventDurationMS - t.eventDurationMS || e.event.allDay - t.event.allDay || (t.event.title || "").localeCompare(e.event.title)
  }

  function ot(n) {
    var i, r, s, o, a = Dt.dataAttrPrefix;
    return a && (a += "-"), i = n.data(a + "event") || null, i && (i = "object" == typeof i ? t.extend({}, i) : {}, r = i.start, null == r && (r = i.time), s = i.duration, o = i.stick, delete i.start, delete i.time, delete i.duration, delete i.stick), null == r && (r = n.data(a + "start")), null == r && (r = n.data(a + "time")), null == s && (s = n.data(a + "duration")), null == o && (o = n.data(a + "stick")), r = null != r ? e.duration(r) : null, s = null != s ? e.duration(s) : null, o = Boolean(o), {
      eventProps: i,
      startTime: r,
      duration: s,
      stick: o
    }
  }

  function at(t, e) {
    var n, i;
    for (n = 0; n < e.length; n++)
      if (i = e[n], i.leftCol <= t.rightCol && i.rightCol >= t.leftCol) return !0;
    return !1
  }

  function lt(t, e) {
    return t.leftCol - e.leftCol
  }

  function dt(t) {
    var e, n, i;
    if (t.sort(st), e = ut(t), ct(e), n = e[0]) {
      for (i = 0; i < n.length; i++) ht(n[i]);
      for (i = 0; i < n.length; i++) ft(n[i], 0, 0)
    }
  }

  function ut(t) {
    var e, n, i, r = [];
    for (e = 0; e < t.length; e++) {
      for (n = t[e], i = 0; i < r.length && gt(n, r[i]).length; i++);
      n.level = i, (r[i] || (r[i] = [])).push(n)
    }
    return r
  }

  function ct(t) {
    var e, n, i, r, s;
    for (e = 0; e < t.length; e++)
      for (n = t[e], i = 0; i < n.length; i++)
        for (r = n[i], r.forwardSegs = [], s = e + 1; s < t.length; s++) gt(r, t[s], r.forwardSegs)
  }

  function ht(t) {
    var e, n, i = t.forwardSegs,
      r = 0;
    if (void 0 === t.forwardPressure) {
      for (e = 0; e < i.length; e++) n = i[e], ht(n), r = Math.max(r, 1 + n.forwardPressure);
      t.forwardPressure = r
    }
  }

  function ft(t, e, n) {
    var i, r = t.forwardSegs;
    if (void 0 === t.forwardCoord)
      for (r.length ? (r.sort(mt), ft(r[0], e + 1, n), t.forwardCoord = r[0].backwardCoord) : t.forwardCoord = 1, t.backwardCoord = t.forwardCoord - (t.forwardCoord - n) / (e + 1), i = 0; i < r.length; i++) ft(r[i], 0, t.forwardCoord)
  }

  function gt(t, e, n) {
    n = n || [];
    for (var i = 0; i < e.length; i++) pt(t, e[i]) && n.push(e[i]);
    return n
  }

  function pt(t, e) {
    return t.bottom > e.top && t.top < e.bottom
  }

  function mt(t, e) {
    return e.forwardPressure - t.forwardPressure || (t.backwardCoord || 0) - (e.backwardCoord || 0) || st(t, e)
  }

  function vt(n, r) {
    function o(t) {
      return (t.locale || t.lang).call(t, Q.lang).humanize()
    }

    function a(t) {
      it ? u() && (v(), c(t)) : l()
    }

    function l() {
      rt = Q.theme ? "ui" : "fc", n.addClass("fc"), Q.isRTL ? n.addClass("fc-rtl") : n.addClass("fc-ltr"), Q.theme ? n.addClass("ui-widget") : n.addClass("fc-unthemed"), it = t("<div class='fc-view-container'/>").prependTo(n), et = new yt(q, Q), nt = et.render(), nt && n.prepend(nt), c(Q.defaultView), Q.handleWindowResize && (at = _(w, Q.windowResizeDelay), t(window).resize(at))
    }

    function d() {
      st && st.destroyView(), et.destroy(), it.remove(), n.removeClass("fc fc-ltr fc-rtl fc-unthemed ui-widget"), t(window).unbind("resize", at)
    }

    function u() {
      return n.is(":visible")
    }

    function c(e) {
      ft++, st && e && st.type !== e && (et.deactivateButton(st.type), I(), st.start && st.destroyView(), st.el.remove(), st = null), !st && e && (st = h(e), st.el = t("<div class='fc-view fc-" + e + "-view' />").appendTo(it), et.activateButton(e)), st && (lt = st.massageCurrentDate(lt), st.start && lt.isWithin(st.intervalStart, st.intervalEnd) || u() && (I(), st.start && st.destroyView(), st.setDate(lt), st.renderView(), Z(), R(), M(), D())), Z(), ft--
    }

    function h(t) {
      var e = f(t);
      return new e["class"](q, e.options, t)
    }

    function f(n) {
      function i(e) {
        "function" == typeof e ? s = e : "object" == typeof e && t.extend(r, e)
      }
      var r, s, a, l, d, u = Q.defaultButtonText || {},
        c = Q.buttonText || {},
        h = Q.views || {},
        f = n,
        g = [],
        p = !1;
      if (ht[n]) return ht[n];
      for (; f && !s;) r = {}, i(Tt[f]), i(h[f]), g.unshift(r), f = r.type;
      return g.unshift({}), r = t.extend.apply(t, g), s ? (a = r.duration || s.duration, a && (a = e.duration(a), l = E(a), p = 1 === a.as(l)), p && h[l] && (r = t.extend({}, h[l], r)), d = c[n] || (p ? c[l] : null) || u[n] || (p ? u[l] : null) || r.buttonText || s.buttonText || (a ? o(a) : null) || n, ht[n] = {
        "class": s,
        options: r,
        buttonText: d
      }) : void 0
    }

    function g(t) {
      return Boolean(f(t))
    }

    function p(t) {
      var e = f(t);
      return e ? e.buttonText : void 0
    }

    function m(t) {
      return u() ? (t && y(), ft++, st.updateSize(!0), ft--, !0) : void 0
    }

    function v() {
      u() && y()
    }

    function y() {
      ot = "number" == typeof Q.contentHeight ? Q.contentHeight : "number" == typeof Q.height ? Q.height - (nt ? nt.outerHeight(!0) : 0) : Math.round(it.width() / Math.max(Q.aspectRatio, .5))
    }

    function w(t) {
      !ft && t.target === window && st.start && m(!0) && st.trigger("windowResize", ct)
    }

    function b() {
      C(), T()
    }

    function S() {
      u() && (I(), st.destroyViewEvents(), st.renderViewEvents(gt), Z())
    }

    function C() {
      I(), st.destroyViewEvents(), Z()
    }

    function D() {
      !Q.lazyFetching || dt(st.start, st.end) ? T() : S()
    }

    function T() {
      ut(st.start, st.end)
    }

    function H(t) {
      gt = t, S()
    }

    function x() {
      S()
    }

    function R() {
      et.updateTitle(st.title)
    }

    function M() {
      var t = q.getNow();
      t.isWithin(st.intervalStart, st.intervalEnd) ? et.disableButton("today") : et.enableButton("today")
    }

    function F(t, e) {
      t = q.moment(t), e = e ? q.moment(e) : t.hasTime() ? t.clone().add(q.defaultTimedEventDuration) : t.clone().add(q.defaultAllDayEventDuration), st.select({
        start: t,
        end: e
      })
    }

    function G() {
      st && st.unselect()
    }

    function N() {
      lt = st.computePrevDate(lt), c()
    }

    function V() {
      lt = st.computeNextDate(lt), c()
    }

    function z() {
      lt.add(-1, "years"), c()
    }

    function L() {
      lt.add(1, "years"), c()
    }

    function P() {
      lt = q.getNow(), c()
    }

    function A(t) {
      lt = q.moment(t), c()
    }

    function O(t) {
      lt.add(e.duration(t)), c()
    }

    function B(t, e) {
      var n, i;
      e && g(e) || (e = e || "day", n = et.getViewsWithButtons().join(" "), i = n.match(new RegExp("\\w+" + Y(e))), i || (i = n.match(/\w+Day/)), e = i ? i[0] : "agendaDay"), lt = t, c(e)
    }

    function W() {
      return lt.clone()
    }

    function I() {
      it.css({
        width: "100%",
        height: it.height(),
        overflow: "hidden"
      })
    }

    function Z() {
      it.css({
        width: "",
        height: "",
        overflow: ""
      })
    }

    function j() {
      return q
    }

    function X() {
      return st
    }

    function U(t, e) {
      return void 0 === e ? Q[t] : void(("height" == t || "contentHeight" == t || "aspectRatio" == t) && (Q[t] = e, m(!0)))
    }

    function $(t, e) {
      return Q[t] ? Q[t].apply(e || ct, Array.prototype.slice.call(arguments, 2)) : void 0
    }
    var q = this;
    r = r || {};
    var K, Q = i({}, St, r);
    K = Q.lang in kt ? kt[Q.lang] : kt[St.lang], K && (Q = i({}, St, K, r)), Q.isRTL && (Q = i({}, St, Ct, K || {}, r)), q.options = Q, q.render = a, q.destroy = d, q.refetchEvents = b, q.reportEvents = H, q.reportEventChange = x, q.rerenderEvents = S, q.changeView = c, q.select = F, q.unselect = G, q.prev = N, q.next = V, q.prevYear = z, q.nextYear = L, q.today = P, q.gotoDate = A, q.incrementDate = O, q.zoomTo = B, q.getDate = W, q.getCalendar = j, q.getView = X, q.option = U, q.trigger = $, q.isValidViewType = g, q.getViewButtonText = p;
    var J = k(s(Q.lang));
    if (Q.monthNames && (J._months = Q.monthNames), Q.monthNamesShort && (J._monthsShort = Q.monthNamesShort), Q.dayNames && (J._weekdays = Q.dayNames), Q.dayNamesShort && (J._weekdaysShort = Q.dayNamesShort), null != Q.firstDay) {
      var tt = k(J._week);
      tt.dow = Q.firstDay, J._week = tt
    }
    q.defaultAllDayEventDuration = e.duration(Q.defaultAllDayEventDuration), q.defaultTimedEventDuration = e.duration(Q.defaultTimedEventDuration), q.moment = function() {
      var t;
      return "local" === Q.timezone ? (t = Dt.moment.apply(null, arguments), t.hasTime() && t.local()) : t = "UTC" === Q.timezone ? Dt.moment.utc.apply(null, arguments) : Dt.moment.parseZone.apply(null, arguments), "_locale" in t ? t._locale = J : t._lang = J, t
    }, q.getIsAmbigTimezone = function() {
      return "local" !== Q.timezone && "UTC" !== Q.timezone
    }, q.rezoneDate = function(t) {
      return q.moment(t.toArray())
    }, q.getNow = function() {
      var t = Q.now;
      return "function" == typeof t && (t = t()), q.moment(t)
    }, q.calculateWeekNumber = function(t) {
      var e = Q.weekNumberCalculation;
      return "function" == typeof e ? e(t) : "local" === e ? t.week() : "ISO" === e.toUpperCase() ? t.isoWeek() : void 0
    }, q.getEventEnd = function(t) {
      return t.end ? t.end.clone() : q.getDefaultEventEnd(t.allDay, t.start)
    }, q.getDefaultEventEnd = function(t, e) {
      var n = e.clone();
      return t ? n.stripTime().add(q.defaultAllDayEventDuration) : n.add(q.defaultTimedEventDuration), q.getIsAmbigTimezone() && n.stripZone(), n
    }, wt.call(q, Q);
    var et, nt, it, rt, st, ot, at, lt, dt = q.isFetchNeeded,
      ut = q.fetchEvents,
      ct = n[0],
      ht = {},
      ft = 0,
      gt = [];
    lt = null != Q.defaultDate ? q.moment(Q.defaultDate) : q.getNow(), q.getSuggestedViewHeight = function() {
      return void 0 === ot && v(), ot
    }, q.isHeightAuto = function() {
      return "auto" === Q.contentHeight || "auto" === Q.height
    }
  }

  function yt(e, n) {
    function i() {
      var e = n.header;
      return f = n.theme ? "ui" : "fc", e ? g = t("<div class='fc-toolbar'/>").append(s("left")).append(s("right")).append(s("center")).append('<div class="fc-clear"/>') : void 0
    }

    function r() {
      g.remove()
    }

    function s(i) {
      var r = t('<div class="fc-' + i + '"/>'),
        s = n.header[i];
      return s && t.each(s.split(" "), function(i) {
        var s, o = t(),
          a = !0;
        t.each(this.split(","), function(i, r) {
          var s, l, d, u, c, h, g, m, v;
          "title" == r ? (o = o.add(t("<h2>&nbsp;</h2>")), a = !1) : (e[r] ? s = function() {
            e[r]()
          } : e.isValidViewType(r) && (s = function() {
            e.changeView(r)
          }, p.push(r), c = e.getViewButtonText(r)), s && (l = w(n.themeButtonIcons, r), d = w(n.buttonIcons, r), u = w(n.defaultButtonText, r), h = w(n.buttonText, r), g = c || h ? N(c || h) : l && n.theme ? "<span class='ui-icon ui-icon-" + l + "'></span>" : d && !n.theme ? "<span class='fc-icon fc-icon-" + d + "'></span>" : N(u || r), m = ["fc-" + r + "-button", f + "-button", f + "-state-default"], v = t('<button type="button" class="' + m.join(" ") + '">' + g + "</button>").click(function() {
            v.hasClass(f + "-state-disabled") || (s(), (v.hasClass(f + "-state-active") || v.hasClass(f + "-state-disabled")) && v.removeClass(f + "-state-hover"))
          }).mousedown(function() {
            v.not("." + f + "-state-active").not("." + f + "-state-disabled").addClass(f + "-state-down")
          }).mouseup(function() {
            v.removeClass(f + "-state-down")
          }).hover(function() {
            v.not("." + f + "-state-active").not("." + f + "-state-disabled").addClass(f + "-state-hover")
          }, function() {
            v.removeClass(f + "-state-hover").removeClass(f + "-state-down")
          }), o = o.add(v)))
        }), a && o.first().addClass(f + "-corner-left").end().last().addClass(f + "-corner-right").end(), o.length > 1 ? (s = t("<div/>"), a && s.addClass("fc-button-group"), s.append(o), r.append(s)) : r.append(o)
      }), r
    }

    function o(t) {
      g.find("h2").text(t)
    }

    function a(t) {
      g.find(".fc-" + t + "-button").addClass(f + "-state-active")
    }

    function l(t) {
      g.find(".fc-" + t + "-button").removeClass(f + "-state-active")
    }

    function d(t) {
      g.find(".fc-" + t + "-button").attr("disabled", "disabled").addClass(f + "-state-disabled")
    }

    function u(t) {
      g.find(".fc-" + t + "-button").removeAttr("disabled").removeClass(f + "-state-disabled")
    }

    function c() {
      return p
    }
    var h = this;
    h.render = i, h.destroy = r, h.updateTitle = o, h.activateButton = a, h.deactivateButton = l, h.disableButton = d, h.enableButton = u, h.getViewsWithButtons = c;
    var f, g = t(),
      p = []
  }

  function wt(n) {
    function i(t, e) {
      return !B || t.clone().stripZone() < B.clone().stripZone() || e.clone().stripZone() > W.clone().stripZone()
    }

    function r(t, e) {
      B = t, W = e, Q = [];
      var n = ++$,
        i = U.length;
      q = i;
      for (var r = 0; i > r; r++) s(U[r], n)
    }

    function s(e, n) {
      o(e, function(i) {
        var r, s, o, a = t.isArray(e.events);
        if (n == $) {
          if (i)
            for (r = 0; r < i.length; r++) s = i[r], o = a ? s : E(s, e), o && Q.push.apply(Q, H(o));
          q--, q || j(Q)
        }
      })
    }

    function o(e, i) {
      var r, s, a = Dt.sourceFetchers;
      for (r = 0; r < a.length; r++) {
        if (s = a[r].call(O, e, B.clone(), W.clone(), n.timezone, i), s === !0) return;
        if ("object" == typeof s) return void o(s, i)
      }
      var l = e.events;
      if (l) t.isFunction(l) ? (y(), l.call(O, B.clone(), W.clone(), n.timezone, function(t) {
        i(t), w()
      })) : t.isArray(l) ? i(l) : i();
      else {
        var d = e.url;
        if (d) {
          var u, c = e.success,
            h = e.error,
            f = e.complete;
          u = t.isFunction(e.data) ? e.data() : e.data;
          var g = t.extend({}, u || {}),
            p = G(e.startParam, n.startParam),
            m = G(e.endParam, n.endParam),
            v = G(e.timezoneParam, n.timezoneParam);
          p && (g[p] = B.format()), m && (g[m] = W.format()), n.timezone && "local" != n.timezone && (g[v] = n.timezone), y(), t.ajax(t.extend({}, Qt, e, {
            data: g,
            success: function(e) {
              e = e || [];
              var n = F(c, this, arguments);
              t.isArray(n) && (e = n), i(e)
            },
            error: function() {
              F(h, this, arguments), i()
            },
            complete: function() {
              F(f, this, arguments), w()
            }
          }))
        } else i()
      }
    }

    function a(t) {
      var e = l(t);
      e && (U.push(e), q++, s(e, $))
    }

    function l(e) {
      var n, i, r = Dt.sourceNormalizers;
      if (t.isFunction(e) || t.isArray(e) ? n = {
          events: e
        } : "string" == typeof e ? n = {
          url: e
        } : "object" == typeof e && (n = t.extend({}, e)), n) {
        for (n.className ? "string" == typeof n.className && (n.className = n.className.split(/\s+/)) : n.className = [], t.isArray(n.events) && (n.origArray = n.events, n.events = t.map(n.events, function(t) {
            return E(t, n)
          })), i = 0; i < r.length; i++) r[i].call(O, n);
        return n
      }
    }

    function d(e) {
      U = t.grep(U, function(t) {
        return !u(t, e)
      }), Q = t.grep(Q, function(t) {
        return !u(t.source, e)
      }), j(Q)
    }

    function u(t, e) {
      return t && e && c(t) == c(e)
    }

    function c(t) {
      return ("object" == typeof t ? t.origArray || t.googleCalendarId || t.url || t.events : null) || t
    }

    function h(t) {
      t.start = O.moment(t.start), t.end ? t.end = O.moment(t.end) : t.end = null, x(t, f(t)), j(Q)
    }

    function f(e) {
      var n = {};
      return t.each(e, function(t, e) {
        g(t) && void 0 !== e && M(e) && (n[t] = e)
      }), n
    }

    function g(t) {
      return !/^_|^(id|allDay|start|end)$/.test(t)
    }

    function p(t, e) {
      var n, i, r, s = E(t);
      if (s) {
        for (n = H(s), i = 0; i < n.length; i++) r = n[i], r.source || (e && (X.events.push(r), r.source = X), Q.push(r));
        return j(Q), n
      }
      return []
    }

    function m(e) {
      var n, i;
      for (null == e ? e = function() {
          return !0
        } : t.isFunction(e) || (n = e + "", e = function(t) {
          return t._id == n
        }), Q = t.grep(Q, e, !0), i = 0; i < U.length; i++) t.isArray(U[i].events) && (U[i].events = t.grep(U[i].events, e, !0));
      j(Q)
    }

    function v(e) {
      return t.isFunction(e) ? t.grep(Q, e) : null != e ? (e += "", t.grep(Q, function(t) {
        return t._id == e
      })) : Q
    }

    function y() {
      K++ || I("loading", null, !0, Z())
    }

    function w() {
      --K || I("loading", null, !1, Z())
    }

    function E(i, r) {
      var s, o, a, l = {};
      if (n.eventDataTransform && (i = n.eventDataTransform(i)), r && r.eventDataTransform && (i = r.eventDataTransform(i)), t.extend(l, i), r && (l.source = r), l._id = i._id || (void 0 === i.id ? "_fc" + Jt++ : i.id + ""), i.className ? "string" == typeof i.className ? l.className = i.className.split(/\s+/) : l.className = i.className : l.className = [], s = i.start || i.date, o = i.end, T(s) && (s = e.duration(s)), T(o) && (o = e.duration(o)), i.dow || e.isDuration(s) || e.isDuration(o)) l.start = s ? e.duration(s) : null, l.end = o ? e.duration(o) : null, l._recurring = !0;
      else {
        if (s && (s = O.moment(s), !s.isValid())) return !1;
        o && (o = O.moment(o), o.isValid() || (o = null)), a = i.allDay, void 0 === a && (a = G(r ? r.allDayDefault : void 0, n.allDayDefault)), C(s, o, a, l)
      }
      return l
    }

    function C(t, e, n, i) {
      i.start = t, i.end = e, i.allDay = n, D(i), bt(i)
    }

    function D(t) {
      null == t.allDay && (t.allDay = !(t.start.hasTime() || t.end && t.end.hasTime())), t.allDay ? (t.start.stripTime(), t.end && t.end.stripTime()) : (t.start.hasTime() || (t.start = O.rezoneDate(t.start)), t.end && !t.end.hasTime() && (t.end = O.rezoneDate(t.end))), t.end && !t.end.isAfter(t.start) && (t.end = null), t.end || (n.forceEventDuration ? t.end = O.getDefaultEventEnd(t.allDay, t.start) : t.end = null)
    }

    function k(t) {
      var e;
      return t.end || (e = t.allDay, null == e && (e = !t.start.hasTime()), t = {
        start: t.start,
        end: O.getDefaultEventEnd(e, t.start)
      }), t
    }

    function H(e, n, i) {
      var r, s, o, a, l, d, u, c, h, f = [];
      if (n = n || B, i = i || W, e)
        if (e._recurring) {
          if (s = e.dow)
            for (r = {}, o = 0; o < s.length; o++) r[s[o]] = !0;
          for (a = n.clone().stripTime(); a.isBefore(i);)(!r || r[a.day()]) && (l = e.start, d = e.end, u = a.clone(), c = null, l && (u = u.time(l)), d && (c = a.clone().time(d)), h = t.extend({}, e), C(u, c, !l && !d, h), f.push(h)), a.add(1, "days")
        } else f.push(e);
      return f
    }

    function x(e, n) {
      var i, r, s, o, a = {};
      return n = n || {}, n.start || (n.start = e.start.clone()), void 0 === n.end && (n.end = e.end ? e.end.clone() : null), null == n.allDay && (n.allDay = e.allDay), D(n), i = null !== e._end && null === n.end, r = n.allDay ? S(n.start, e._start) : b(n.start, e._start), !i && n.end && (s = b(n.end, n.start).subtract(b(e._end || O.getDefaultEventEnd(e._allDay, e._start), e._start))), t.each(n, function(t, e) {
        g(t) && void 0 !== e && (a[t] = e)
      }), o = R(v(e._id), i, n.allDay, r, s, a), {
        dateDelta: r,
        durationDelta: s,
        undo: o
      }
    }

    function R(e, n, i, r, s, o) {
      var a = O.getIsAmbigTimezone(),
        l = [];
      return r && !r.valueOf() && (r = null), s && !s.valueOf() && (s = null), t.each(e, function(e, d) {
          var u, c;
          u = {
            start: d.start.clone(),
            end: d.end ? d.end.clone() : null,
            allDay: d.allDay
          }, t.each(o, function(t) {
            u[t] = d[t]
          }), c = {
            start: d._start,
            end: d._end,
            allDay: d._allDay
          }, n && (c.end = null), c.allDay = i, D(c), r && (c.start.add(r), c.end && c.end.add(r)), s && (c.end || (c.end = O.getDefaultEventEnd(c.allDay, c.start)), c.end.add(s)), a && !c.allDay && (r || s) && (c.start.stripZone(), c.end && c.end.stripZone()), t.extend(d, o, c), bt(d), l.push(function() {
            t.extend(d, u), bt(d)
          })
        }),
        function() {
          for (var t = 0; t < l.length; t++) l[t]()
        }
    }

    function N() {
      var e, i = n.businessHours,
        r = {
          className: "fc-nonbusiness",
          start: "09:00",
          end: "17:00",
          dow: [1, 2, 3, 4, 5],
          rendering: "inverse-background"
        },
        s = O.getView();
      return i && (e = "object" == typeof i ? t.extend({}, r, i) : r), e ? H(E(e), s.start, s.end) : []
    }

    function V(t, e) {
      var i = e.source || {},
        r = G(e.constraint, i.constraint, n.eventConstraint),
        s = G(e.overlap, i.overlap, n.eventOverlap);
      return t = k(t), L(t, r, s, e)
    }

    function Y(t) {
      return L(t, n.selectConstraint, n.selectOverlap)
    }

    function z(e, n) {
      var i, r;
      return n && (i = t.extend({}, n, e), r = H(E(i))[0]), r ? V(e, r) : (e = k(e), Y(e))
    }

    function L(t, e, n, i) {
      var r, s, o, a, l;
      if (t = {
          start: t.start.clone().stripZone(),
          end: t.end.clone().stripZone()
        }, null != e) {
        for (r = _(e), s = !1, o = 0; o < r.length; o++)
          if (P(r[o], t)) {
            s = !0;
            break
          } if (!s) return !1
      }
      for (o = 0; o < Q.length; o++)
        if (a = Q[o], (!i || i._id !== a._id) && A(a, t)) {
          if (n === !1) return !1;
          if ("function" == typeof n && !n(a, i)) return !1;
          if (i) {
            if (l = G(a.overlap, (a.source || {}).overlap), l === !1) return !1;
            if ("function" == typeof l && !l(i, a)) return !1
          }
        } return !0
    }

    function _(t) {
      return "businessHours" === t ? N() : "object" == typeof t ? H(E(t)) : v(t)
    }

    function P(t, e) {
      var n = t.start.clone().stripZone(),
        i = O.getEventEnd(t).stripZone();
      return e.start >= n && e.end <= i
    }

    function A(t, e) {
      var n = t.start.clone().stripZone(),
        i = O.getEventEnd(t).stripZone();
      return e.start < i && e.end > n
    }
    var O = this;
    O.isFetchNeeded = i, O.fetchEvents = r, O.addEventSource = a, O.removeEventSource = d, O.updateEvent = h, O.renderEvent = p, O.removeEvents = m, O.clientEvents = v, O.mutateEvent = x, O.normalizeEventDateProps = D, O.ensureVisibleEventRange = k;
    var B, W, I = O.trigger,
      Z = O.getView,
      j = O.reportEvents,
      X = {
        events: []
      },
      U = [X],
      $ = 0,
      q = 0,
      K = 0,
      Q = [];
    t.each((n.events ? [n.events] : []).concat(n.eventSources || []), function(t, e) {
      var n = l(e);
      n && U.push(n)
    }), O.getBusinessHoursEvents = N, O.isEventRangeAllowed = V, O.isSelectionRangeAllowed = Y, O.isExternalDropRangeAllowed = z
  }

  function bt(t) {
    t._allDay = t.allDay, t._start = t.start.clone(), t._end = t.end ? t.end.clone() : null
  }
  var St = {
      titleRangeSeparator: "  ",
      monthYearFormat: "MMMM YYYY",
      defaultTimedEventDuration: "02:00:00",
      defaultAllDayEventDuration: {
        days: 1
      },
      forceEventDuration: !1,
      nextDayThreshold: "09:00:00",
      defaultView: "month",
      aspectRatio: 1.35,
      header: {
        left: "title",
        center: "",
        right: "today prev,next"
      },
      weekends: !0,
      weekNumbers: !1,
      weekNumberTitle: "W",
      weekNumberCalculation: "local",
      lazyFetching: !0,
      startParam: "start",
      endParam: "end",
      timezoneParam: "timezone",
      timezone: !1,
      minDate: null,
      maxDate: null,
      firstDay: 0,
      yearTitleFormat: "YYYY",
      yearFormat: "YYYY",
      isRTL: !1,
      defaultButtonText: {
        prev: "prev",
        next: "next",
        prevYear: "prev year",
        nextYear: "next year",
        today: "today",
        year: "year",
        month: "month",
        week: "week",
        day: "day"
      },
      buttonIcons: {
        prev: "left-single-arrow",
        next: "right-single-arrow",
        prevYear: "left-double-arrow",
        nextYear: "right-double-arrow"
      },
      theme: !1,
      themeButtonIcons: {
        prev: "circle-triangle-w",
        next: "circle-triangle-e",
        prevYear: "seek-prev",
        nextYear: "seek-next"
      },
      dragOpacity: .75,
      dragRevertDuration: 500,
      dragScroll: !0,
      unselectAuto: !0,
      dropAccept: "*",
      eventLimit: !1,
      eventLimitText: "more",
      eventLimitClick: "popover",
      dayPopoverFormat: "LL",
      handleWindowResize: !0,
      windowResizeDelay: 200
    },
    Et = {
      dayPopoverFormat: "dddd, MMMM D"
    },
    Ct = {
      header: {
        left: "next,prev today",
        center: "",
        right: "title"
      },
      buttonIcons: {
        prev: "right-single-arrow",
        next: "left-single-arrow",
        prevYear: "right-double-arrow",
        nextYear: "left-double-arrow"
      },
      themeButtonIcons: {
        prev: "circle-triangle-e",
        next: "circle-triangle-w",
        nextYear: "seek-prev",
        prevYear: "seek-next"
      }
    },
    Dt = t.fullCalendar = {
      version: "2.2.7"
    },
    Tt = Dt.views = {};
  t.fn.fullCalendar = function(e) {
    var n = Array.prototype.slice.call(arguments, 1),
      i = this;
    return this.each(function(r, s) {
      var o, a = t(s),
        l = a.data("fullCalendar");
      "string" == typeof e ? l && t.isFunction(l[e]) && (o = l[e].apply(l, n), r || (i = o), "destroy" === e && a.removeData("fullCalendar")) : l || (l = new vt(a, e), a.data("fullCalendar", l), l.render())
    }), i
  };
  var kt = Dt.langs = {};
  Dt.datepickerLang = function(e, n, i) {
    var r = kt[e] || (kt[e] = {});
    r.isRTL = i.isRTL, r.weekNumberTitle = i.weekHeader, t.each(Ht, function(t, e) {
      r[t] = e(i)
    }), t.datepicker && (t.datepicker.regional[n] = t.datepicker.regional[e] = i, t.datepicker.regional.en = t.datepicker.regional[""], t.datepicker.setDefaults(i))
  }, Dt.lang = function(e, n) {
    var r, o;
    r = kt[e] || (kt[e] = {}), n && i(r, n), o = s(e), t.each(xt, function(t, e) {
      void 0 === r[t] && (r[t] = e(o, r))
    }), St.lang = e
  };
  var Ht = {
      defaultButtonText: function(t) {
        return {
          prev: V(t.prevText),
          next: V(t.nextText),
          today: V(t.currentText)
        }
      },
      monthYearFormat: function(t) {
        return t.showMonthAfterYear ? "YYYY[" + t.yearSuffix + "] MMMM" : "MMMM YYYY[" + t.yearSuffix + "]"
      }
    },
    xt = {
      dayOfMonthFormat: function(t, e) {
        var n = t.longDateFormat("l");
        return n = n.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, ""), e.isRTL ? n += " ddd" : n = "ddd " + n, n
      },
      smallTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "a")
      },
      extraSmallTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "t")
      },
      noMeridiemTimeFormat: function(t) {
        return t.longDateFormat("LT").replace(/\s*a$/i, "")
      }
    };
  Dt.lang("en", Et), Dt.intersectionToSeg = y, Dt.applyAll = F, Dt.debounce = _;
  var Rt, Mt, Ft, Gt = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"],
    Nt = ["year", "month", "week", "day", "hour", "minute", "second", "millisecond"],
    Vt = {}.hasOwnProperty,
    Yt = /^\s*\d{4}-\d\d$/,
    zt = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/,
    Lt = e.fn,
    _t = t.extend({}, Lt);
  Dt.moment = function() {
    return P(arguments)
  }, Dt.moment.utc = function() {
    var t = P(arguments, !0);
    return t.hasTime() && t.utc(), t
  }, Dt.moment.parseZone = function() {
    return P(arguments, !0, !0)
  }, Lt.clone = function() {
    var t = _t.clone.apply(this, arguments);
    return O(this, t), this._fullCalendar && (t._fullCalendar = !0), t
  }, Lt.time = function(t) {
    if (!this._fullCalendar) return _t.time.apply(this, arguments);
    if (null == t) return e.duration({
      hours: this.hours(),
      minutes: this.minutes(),
      seconds: this.seconds(),
      milliseconds: this.milliseconds()
    });
    this._ambigTime = !1, e.isDuration(t) || e.isMoment(t) || (t = e.duration(t));
    var n = 0;
    return e.isDuration(t) && (n = 24 * Math.floor(t.asDays())), this.hours(n + t.hours()).minutes(t.minutes()).seconds(t.seconds()).milliseconds(t.milliseconds())
  }, Lt.stripTime = function() {
    var t;
    return this._ambigTime || (t = this.toArray(), this.utc(), Mt(this, t.slice(0, 3)), this._ambigTime = !0, this._ambigZone = !0), this
  }, Lt.hasTime = function() {
    return !this._ambigTime
  }, Lt.stripZone = function() {
    var t, e;
    return this._ambigZone || (t = this.toArray(), e = this._ambigTime, this.utc(), Mt(this, t), this._ambigTime = e || !1, this._ambigZone = !0), this
  }, Lt.hasZone = function() {
    return !this._ambigZone
  }, Lt.local = function() {
    var t = this.toArray(),
      e = this._ambigZone;
    return _t.local.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, e && Ft(this, t), this
  }, Lt.utc = function() {
    return _t.utc.apply(this, arguments), this._ambigTime = !1, this._ambigZone = !1, this
  }, t.each(["zone", "utcOffset"], function(t, e) {
    _t[e] && (Lt[e] = function(t) {
      return null != t && (this._ambigTime = !1, this._ambigZone = !1), _t[e].apply(this, arguments)
    })
  }), Lt.format = function() {
    return this._fullCalendar && arguments[0] ? I(this, arguments[0]) : this._ambigTime ? W(this, "YYYY-MM-DD") : this._ambigZone ? W(this, "YYYY-MM-DD[T]HH:mm:ss") : _t.format.apply(this, arguments)
  }, Lt.toISOString = function() {
    return this._ambigTime ? W(this, "YYYY-MM-DD") : this._ambigZone ? W(this, "YYYY-MM-DD[T]HH:mm:ss") : _t.toISOString.apply(this, arguments)
  }, Lt.isWithin = function(t, e) {
    var n = A([this, t, e]);
    return n[0] >= n[1] && n[0] < n[2]
  }, Lt.isSame = function(t, e) {
    var n;
    return this._fullCalendar ? e ? (n = A([this, t], !0), _t.isSame.call(n[0], n[1], e)) : (t = Dt.moment.parseZone(t), _t.isSame.call(this, t) && Boolean(this._ambigTime) === Boolean(t._ambigTime) && Boolean(this._ambigZone) === Boolean(t._ambigZone)) : _t.isSame.apply(this, arguments)
  }, t.each(["isBefore", "isAfter"], function(t, e) {
    Lt[e] = function(t, n) {
      var i;
      return this._fullCalendar ? (i = A([this, t]), _t[e].call(i[0], i[1], n)) : _t[e].apply(this, arguments)
    }
  }), Rt = "_d" in e() && "updateOffset" in e, Mt = Rt ? function(t, n) {
    t._d.setTime(Date.UTC.apply(Date, n)), e.updateOffset(t, !1)
  } : B, Ft = Rt ? function(t, n) {
    t._d.setTime(+new Date(n[0] || 0, n[1] || 0, n[2] || 0, n[3] || 0, n[4] || 0, n[5] || 0, n[6] || 0)), e.updateOffset(t, !1)
  } : B;
  var Pt = {
    t: function(t) {
      return W(t, "a").charAt(0)
    },
    T: function(t) {
      return W(t, "A").charAt(0)
    }
  };
  Dt.formatRange = X;
  var At = {
      Y: "year",
      M: "month",
      D: "day",
      d: "day",
      A: "second",
      a: "second",
      T: "second",
      t: "second",
      H: "second",
      h: "second",
      m: "second",
      s: "second"
    },
    Ot = {};
  Dt.Class = Q, Q.extend = function(t) {
    var e, n = this;
    return t = t || {}, R(t, "constructor") && (e = t.constructor), "function" != typeof e && (e = t.constructor = function() {
      n.apply(this, arguments)
    }), e.prototype = k(n.prototype), H(t, e.prototype), x(t, e.prototype), H(n, e), e
  }, Q.mixin = function(t) {
    H(t.prototype || t, this.prototype)
  };
  var Bt = Q.extend({
      isHidden: !0,
      options: null,
      el: null,
      documentMousedownProxy: null,
      margin: 10,
      constructor: function(t) {
        this.options = t || {}
      },
      show: function() {
        this.isHidden && (this.el || this.render(), this.el.show(), this.position(), this.isHidden = !1, this.trigger("show"))
      },
      hide: function() {
        this.isHidden || (this.el.hide(), this.isHidden = !0, this.trigger("hide"))
      },
      render: function() {
        var e = this,
          n = this.options;
        this.el = t('<div class="fc-popover"/>').addClass(n.className || "").css({
          top: 0,
          left: 0
        }).append(n.content).appendTo(n.parentEl), this.el.on("click", ".fc-close", function() {
          e.hide()
        }), n.autoHide && t(document).on("mousedown", this.documentMousedownProxy = t.proxy(this, "documentMousedown"))
      },
      documentMousedown: function(e) {
        this.el && !t(e.target).closest(this.el).length && this.hide()
      },
      destroy: function() {
        this.hide(), this.el && (this.el.remove(), this.el = null), t(document).off("mousedown", this.documentMousedownProxy)
      },
      position: function() {
        var e, n, i, r, s, o = this.options,
          a = this.el.offsetParent().offset(),
          l = this.el.outerWidth(),
          d = (this.el.outerHeight(), t(window)),
          u = p(this.el);
        r = o.top || 0, s = void 0 !== o.left ? o.left : void 0 !== o.right ? o.right - l : 0, u.is(window) || u.is(document) ? (u = d, e = 0, n = 0) : (i = u.offset(), e = i.top, n = i.left), e += d.scrollTop(), n += d.scrollLeft(), o.viewportConstrain !== !1 && (s = Math.min(s, n + u.outerWidth() - l - this.margin), s = Math.max(s, n + this.margin)), this.el.css({
          top: r - a.top,
          left: s - a.left
        })
      },
      trigger: function(t) {
        this.options[t] && this.options[t].apply(this, Array.prototype.slice.call(arguments, 1))
      }
    }),
    Wt = Q.extend({
      grid: null,
      rowCoords: null,
      colCoords: null,
      containerEl: null,
      minX: null,
      maxX: null,
      minY: null,
      maxY: null,
      constructor: function(t) {
        this.grid = t
      },
      build: function() {
        this.rowCoords = this.grid.computeRowCoords(), this.colCoords = this.grid.computeColCoords(), this.computeBounds()
      },
      clear: function() {
        this.rowCoords = null, this.colCoords = null
      },
      getCell: function(e, n) {
        var i, r, s = this.rowCoords,
          o = this.colCoords,
          a = null,
          l = null,
          d = null,
          u = this.inBounds(e, n);
        if (!u && "year" == this.grid.view.name) return t.each(this.grid.view.dayGrids, function(t, i) {
          var r = i.coordMap;
          return r.computeBounds(), r.inBounds(e, n) ? (r.build(), d = r.getCell(e, n), !1) : void 0
        }), d;
        for (i = 0; i < s.length; i++)
          if (r = s[i], n >= r.top && n < r.bottom) {
            a = i;
            break
          } for (i = 0; i < o.length; i++)
          if (r = o[i], e >= r.left && e < r.right) {
            l = i;
            break
          } return null !== a && null !== l ? (d = this.grid.getCell(a, l), d.grid = this.grid, d) : null
      },
      computeBounds: function() {
        var t;
        this.containerEl && (t = this.containerEl.offset(), this.minX = t.left, this.maxX = t.left + this.containerEl.outerWidth(), this.minY = t.top, this.maxY = t.top + this.containerEl.outerHeight())
      },
      inBounds: function(t, e) {
        return this.containerEl ? t >= this.minX && t < this.maxX && e >= this.minY && e < this.maxY : !0
      }
    }),
    It = Q.extend({
      coordMaps: null,
      constructor: function(t) {
        this.coordMaps = t
      },
      build: function() {
        var t, e = this.coordMaps;
        for (t = 0; t < e.length; t++) e[t].build()
      },
      getCell: function(t, e) {
        var n, i = this.coordMaps,
          r = null;
        for (n = 0; n < i.length && !r; n++) r = i[n].getCell(t, e);
        return r
      },
      clear: function() {
        var t, e = this.coordMaps;
        for (t = 0; t < e.length; t++) e[t].clear()
      }
    }),
    Zt = Q.extend({
      coordMap: null,
      options: null,
      isListening: !1,
      isDragging: !1,
      origCell: null,
      cell: null,
      mouseX0: null,
      mouseY0: null,
      mousemoveProxy: null,
      mouseupProxy: null,
      scrollEl: null,
      scrollBounds: null,
      scrollTopVel: null,
      scrollLeftVel: null,
      scrollIntervalId: null,
      scrollHandlerProxy: null,
      scrollSensitivity: 30,
      scrollSpeed: 200,
      scrollIntervalMs: 50,
      constructor: function(t, e) {
        this.coordMap = t, this.options = e || {}
      },
      mousedown: function(t) {
        v(t) && (t.preventDefault(), this.startListening(t), this.options.distance || this.startDrag(t))
      },
      startListening: function(e) {
        var n, i;
        this.isListening || (e && this.options.scroll && (n = p(t(e.target)), n.is(window) || n.is(document) || (this.scrollEl = n, this.scrollHandlerProxy = _(t.proxy(this, "scrollHandler"), 100), this.scrollEl.on("scroll", this.scrollHandlerProxy))), this.computeCoords(), e && (i = this.getCell(e), this.origCell = i, this.mouseX0 = e.pageX, this.mouseY0 = e.pageY), t(document).on("mousemove", this.mousemoveProxy = t.proxy(this, "mousemove")).on("mouseup", this.mouseupProxy = t.proxy(this, "mouseup")).on("selectstart", this.preventDefault), this.isListening = !0, this.trigger("listenStart", e))
      },
      computeCoords: function() {
        this.coordMap.build(), this.computeScrollBounds()
      },
      mousemove: function(t) {
        var e, n;
        this.isDragging || (e = this.options.distance || 1, n = Math.pow(t.pageX - this.mouseX0, 2) + Math.pow(t.pageY - this.mouseY0, 2), n >= e * e && this.startDrag(t)), this.isDragging && this.drag(t)
      },
      startDrag: function(t) {
        var e;
        this.isListening || this.startListening(), this.isDragging || (this.isDragging = !0, this.trigger("dragStart", t), e = this.getCell(t), e && this.cellOver(e))
      },
      drag: function(t) {
        var e;
        this.isDragging && (e = this.getCell(t), J(e, this.cell) || (this.cell && this.cellOut(), e && this.cellOver(e)), this.dragScroll(t))
      },
      cellOver: function(t) {
        this.cell = t, this.trigger("cellOver", t, J(t, this.origCell))
      },
      cellOut: function() {
        this.cell && (this.trigger("cellOut", this.cell), this.cell = null)
      },
      mouseup: function(t) {
        this.stopDrag(t), this.stopListening(t)
      },
      stopDrag: function(t) {
        this.isDragging && (this.stopScrolling(), this.trigger("dragStop", t), this.isDragging = !1)
      },
      stopListening: function(e) {
        this.isListening && (this.scrollEl && (this.scrollEl.off("scroll", this.scrollHandlerProxy), this.scrollHandlerProxy = null), t(document).off("mousemove", this.mousemoveProxy).off("mouseup", this.mouseupProxy).off("selectstart", this.preventDefault), this.mousemoveProxy = null, this.mouseupProxy = null, this.isListening = !1, this.trigger("listenStop", e), this.origCell = this.cell = null, this.coordMap.clear())
      },
      getCell: function(t) {
        return this.coordMap.getCell(t.pageX, t.pageY)
      },
      trigger: function(t) {
        this.options[t] && this.options[t].apply(this, Array.prototype.slice.call(arguments, 1))
      },
      preventDefault: function(t) {
        t.preventDefault()
      },
      computeScrollBounds: function() {
        var t, e = this.scrollEl;
        e && (t = e.offset(), this.scrollBounds = {
          top: t.top,
          left: t.left,
          bottom: t.top + e.outerHeight(),
          right: t.left + e.outerWidth()
        })
      },
      dragScroll: function(t) {
        var e, n, i, r, s = this.scrollSensitivity,
          o = this.scrollBounds,
          a = 0,
          l = 0;
        o && (e = (s - (t.pageY - o.top)) / s, n = (s - (o.bottom - t.pageY)) / s, i = (s - (t.pageX - o.left)) / s, r = (s - (o.right - t.pageX)) / s, e >= 0 && 1 >= e ? a = e * this.scrollSpeed * -1 : n >= 0 && 1 >= n && (a = n * this.scrollSpeed), i >= 0 && 1 >= i ? l = i * this.scrollSpeed * -1 : r >= 0 && 1 >= r && (l = r * this.scrollSpeed)), this.setScrollVel(a, l)
      },
      setScrollVel: function(e, n) {
        this.scrollTopVel = e, this.scrollLeftVel = n, this.constrainScrollVel(), !this.scrollTopVel && !this.scrollLeftVel || this.scrollIntervalId || (this.scrollIntervalId = setInterval(t.proxy(this, "scrollIntervalFunc"), this.scrollIntervalMs))
      },
      constrainScrollVel: function() {
        var t = this.scrollEl;
        this.scrollTopVel < 0 ? t.scrollTop() <= 0 && (this.scrollTopVel = 0) : this.scrollTopVel > 0 && t.scrollTop() + t[0].clientHeight >= t[0].scrollHeight && (this.scrollTopVel = 0), this.scrollLeftVel < 0 ? t.scrollLeft() <= 0 && (this.scrollLeftVel = 0) : this.scrollLeftVel > 0 && t.scrollLeft() + t[0].clientWidth >= t[0].scrollWidth && (this.scrollLeftVel = 0)
      },
      scrollIntervalFunc: function() {
        var t = this.scrollEl,
          e = this.scrollIntervalMs / 1e3;
        this.scrollTopVel && t.scrollTop(t.scrollTop() + this.scrollTopVel * e), this.scrollLeftVel && t.scrollLeft(t.scrollLeft() + this.scrollLeftVel * e), this.constrainScrollVel(), this.scrollTopVel || this.scrollLeftVel || this.stopScrolling()
      },
      stopScrolling: function() {
        this.scrollIntervalId && (clearInterval(this.scrollIntervalId), this.scrollIntervalId = null, this.computeCoords())
      },
      scrollHandler: function() {
        this.scrollIntervalId || this.computeCoords()
      }
    }),
    jt = Q.extend({
      options: null,
      sourceEl: null,
      el: null,
      parentEl: null,
      top0: null,
      left0: null,
      mouseY0: null,
      mouseX0: null,
      topDelta: null,
      leftDelta: null,
      mousemoveProxy: null,
      isFollowing: !1,
      isHidden: !1,
      isAnimating: !1,
      constructor: function(e, n) {
        this.options = n = n || {}, this.sourceEl = e, this.parentEl = n.parentEl ? t(n.parentEl) : e.parent()
      },
      start: function(e) {
        this.isFollowing || (this.isFollowing = !0, this.mouseY0 = e.pageY, this.mouseX0 = e.pageX, this.topDelta = 0, this.leftDelta = 0, this.isHidden || this.updatePosition(), t(document).on("mousemove", this.mousemoveProxy = t.proxy(this, "mousemove")))
      },
      stop: function(e, n) {
        function i() {
          this.isAnimating = !1, r.destroyEl(), this.top0 = this.left0 = null, n && n()
        }
        var r = this,
          s = this.options.revertDuration;
        this.isFollowing && !this.isAnimating && (this.isFollowing = !1, t(document).off("mousemove", this.mousemoveProxy), e && s && !this.isHidden ? (this.isAnimating = !0, this.el.animate({
          top: this.top0,
          left: this.left0
        }, {
          duration: s,
          complete: i
        })) : i())
      },
      getEl: function() {
        var t = this.el;
        return t || (this.sourceEl.width(), t = this.el = this.sourceEl.clone().css({
          position: "absolute",
          visibility: "",
          display: this.isHidden ? "none" : "",
          margin: 0,
          right: "auto",
          bottom: "auto",
          width: this.sourceEl.width(),
          height: this.sourceEl.height(),
          opacity: this.options.opacity || "",
          zIndex: this.options.zIndex
        }).appendTo(this.parentEl)), t
      },
      destroyEl: function() {
        this.el && (this.el.remove(), this.el = null)
      },
      updatePosition: function() {
        var t, e;
        this.getEl(), null === this.top0 && (this.sourceEl.width(), t = this.sourceEl.offset(), e = this.el.offsetParent().offset(), this.top0 = t.top - e.top, this.left0 = t.left - e.left), this.el.css({
          top: this.top0 + this.topDelta,
          left: this.left0 + this.leftDelta
        })
      },
      mousemove: function(t) {
        this.topDelta = t.pageY - this.mouseY0, this.leftDelta = t.pageX - this.mouseX0, this.isHidden || this.updatePosition()
      },
      hide: function() {
        this.isHidden || (this.isHidden = !0, this.el && this.el.hide())
      },
      show: function() {
        this.isHidden && (this.isHidden = !1, this.updatePosition(), this.getEl().show())
      }
    }),
    Xt = Q.extend({
      view: null,
      isRTL: null,
      cellHtml: "<td/>",
      constructor: function(t) {
        this.view = t, this.isRTL = t.opt("isRTL")
      },
      rowHtml: function(t, e) {
        var n, i, r = this.getHtmlRenderer("cell", t),
          s = "";
        for (e = e || 0, n = 0; n < this.colCnt; n++) i = this.getCell(e, n), s += r(i);
        return s = this.bookendCells(s, t, e), "<tr>" + s + "</tr>"
      },
      bookendCells: function(t, e, n) {
        var i = this.getHtmlRenderer("intro", e)(n || 0, this),
          r = this.getHtmlRenderer("outro", e)(n || 0, this),
          s = this.isRTL ? r : i,
          o = this.isRTL ? i : r;
        return "string" == typeof t ? s + t + o : t.prepend(s).append(o)
      },
      getHtmlRenderer: function(t, e) {
        var n, i, r, s, o = this.view;
        return n = t + "Html", e && (i = e + Y(t) + "Html"), i && (s = o[i]) ? r = o : i && (s = this[i]) ? r = this : (s = o[n]) ? r = o : (s = this[n]) && (r = this), "function" == typeof s ? function() {
          return s.apply(r, arguments) || ""
        } : function() {
          return s || ""
        }
      }
    }),
    Ut = Dt.Grid = Xt.extend({
      start: null,
      end: null,
      rowCnt: 0,
      colCnt: 0,
      rowData: null,
      colData: null,
      el: null,
      coordMap: null,
      elsByFill: null,
      documentDragStartProxy: null,
      colHeadFormat: null,
      eventTimeFormat: null,
      displayEventEnd: null,
      constructor: function() {
        Xt.apply(this, arguments), this.coordMap = new Wt(this), this.elsByFill = {}, this.documentDragStartProxy = t.proxy(this, "documentDragStart")
      },
      render: function() {
        this.bindHandlers()
      },
      destroy: function() {
        this.unbindHandlers()
      },
      computeColHeadFormat: function() {},
      computeEventTimeFormat: function() {
        return this.view.opt("smallTimeFormat")
      },
      computeDisplayEventEnd: function() {
        return !1
      },
      setRange: function(t) {
        var e = this.view;
        this.start = t.start.clone(), this.end = t.end.clone(), this.rowData = [], this.colData = [], this.updateCells(), this.colHeadFormat = e.opt("columnFormat") || this.computeColHeadFormat(), this.eventTimeFormat = e.opt("timeFormat") || this.computeEventTimeFormat(), this.displayEventEnd = e.opt("displayEventEnd"), null == this.displayEventEnd && (this.displayEventEnd = this.computeDisplayEventEnd())
      },
      updateCells: function() {},
      rangeToSegs: function(t) {},
      getCell: function(e, n) {
        var i;
        return null == n && ("number" == typeof e ? (n = e % this.colCnt, e = Math.floor(e / this.colCnt)) : (n = e.col, e = e.row)), i = {
          row: e,
          col: n
        }, t.extend(i, this.getRowData(e), this.getColData(n)), t.extend(i, this.computeCellRange(i)), i
      },
      computeCellRange: function(t) {},
      getRowData: function(t) {
        return this.rowData[t] || {}
      },
      getColData: function(t) {
        return this.colData[t] || {}
      },
      getRowEl: function(t) {},
      getColEl: function(t) {},
      getCellDayEl: function(t) {
        return this.getColEl(t.col) || this.getRowEl(t.row)
      },
      computeRowCoords: function() {
        var t, e, n, i = [];
        for (t = 0; t < this.rowCnt; t++) e = this.getRowEl(t), n = {
          top: e.offset().top
        }, t > 0 && (i[t - 1].bottom = n.top), i.push(n);
        return n.bottom = n.top + e.outerHeight(), i
      },
      computeColCoords: function() {
        var t, e, n, i = [];
        for (t = 0; t < this.colCnt; t++) e = this.getColEl(t), n = {
          left: e.offset().left
        }, t > 0 && (i[t - 1].right = n.left), i.push(n);
        return n.right = n.left + e.outerWidth(), i
      },
      bindHandlers: function() {
        var e = this;
        this.el.on("mousedown", function(n) {
          t(n.target).is(".fc-event-container *, .fc-more") || t(n.target).closest(".fc-popover").length || e.dayMousedown(n)
        }), this.bindSegHandlers(), t(document).on("dragstart", this.documentDragStartProxy)
      },
      unbindHandlers: function() {
        t(document).off("dragstart", this.documentDragStartProxy)
      },
      dayMousedown: function(t) {
        var e, n, i = this,
          r = this.view,
          s = r.opt("selectable"),
          o = new Zt(this.coordMap, {
            scroll: r.opt("dragScroll"),
            dragStart: function() {
              r.unselect()
            },
            cellOver: function(t, r) {
              var a = o.origCell;
              a && (e = r ? t : null, s && (n = i.computeSelection(a, t), n ? i.renderSelection(n) : l()))
            },
            cellOut: function(t) {
              e = null, n = null, i.destroySelection(), d()
            },
            listenStop: function(t) {
              e && r.trigger("dayClick", i.getCellDayEl(e), e.start, t), n && r.reportSelection(n, t), d()
            }
          });
        o.mousedown(t)
      },
      renderRangeHelper: function(t, e) {
        var n;
        n = e ? k(e.event) : {}, n.start = t.start.clone(), n.end = t.end ? t.end.clone() : null, n.allDay = null, this.view.calendar.normalizeEventDateProps(n), n.className = (n.className || []).concat("fc-helper"), e || (n.editable = !1), this.renderHelper(n, e)
      },
      renderHelper: function(t, e) {},
      destroyHelper: function() {},
      renderSelection: function(t) {
        "year" != this.view.name || t.rendered || (this.view.destroySelection(), t.rendered = !0, this.view.renderSelection(t, this)), this.renderHighlight(t)
      },
      destroySelection: function() {
        this.destroyHighlight()
      },
      computeSelection: function(t, e) {
        var n, i = [t.start, t.end, e.start, e.end];
        return i.sort(z), n = {
          start: i[0].clone(),
          end: i[3].clone()
        }, this.view.calendar.isSelectionRangeAllowed(n) ? n : null
      },
      renderHighlight: function(t) {
        this.renderFill("highlight", this.rangeToSegs(t))
      },
      destroyHighlight: function() {
        this.destroyFill("highlight")
      },
      highlightSegClasses: function() {
        return ["fc-highlight"]
      },
      renderFill: function(t, e) {},
      destroyFill: function(t) {
        var e = this.elsByFill[t];
        e && (e.remove(), delete this.elsByFill[t])
      },
      renderFillSegEls: function(e, n) {
        var i, r = this,
          s = this[e + "SegEl"],
          o = "",
          a = [];
        if (n.length) {
          for (i = 0; i < n.length; i++) o += this.fillSegHtml(e, n[i]);
          t(o).each(function(e, i) {
            var o = n[e],
              l = t(i);
            s && (l = s.call(r, o, l)), l && (l = t(l), l.is(r.fillSegTag) && (o.el = l, a.push(o)))
          })
        }
        return a
      },
      fillSegTag: "div",
      fillSegHtml: function(t, e) {
        var n = this[t + "SegClasses"],
          i = this[t + "SegStyles"],
          r = n ? n.call(this, e) : [],
          s = i ? i.call(this, e) : "";
        return "<" + this.fillSegTag + (r.length ? ' class="' + r.join(" ") + '"' : "") + (s ? ' style="' + s + '"' : "") + " />"
      },
      headHtml: function() {
        return '<div class="fc-row ' + this.view.widgetHeaderClass + '"><table><thead>' + this.rowHtml("head") + "</thead></table></div>"
      },
      headCellHtml: function(t) {
        var e = this.view,
          n = t.start;
        return '<th class="fc-day-header ' + e.widgetHeaderClass + " fc-" + Gt[n.day()] + '">' + N(n.format(this.colHeadFormat)) + "</th>"
      },
      bgCellHtml: function(t) {
        var e = this.view,
          n = t.start,
          i = this.getDayClasses(n);
        return i.unshift("fc-day", e.widgetContentClass), '<td class="' + i.join(" ") + '" data-date="' + n.format("YYYY-MM-DD") + '"></td>'
      },
      getDayClasses: function(t) {
        var e = this.view,
          n = e.calendar.getNow().stripTime(),
          i = ["fc-" + Gt[t.day()]];
        return "month" === e.name && t.month() != e.intervalStart.month() && i.push("fc-other-month"), t.isSame(n, "day") ? i.push("fc-today", e.highlightStateClass) : n > t ? i.push("fc-past") : i.push("fc-future"), i
      }
    });
  Ut.mixin({
    mousedOverSeg: null,
    isDraggingSeg: !1,
    isResizingSeg: !1,
    segs: null,
    renderEvents: function(t) {
      var e, n, i = this.eventsToSegs(t),
        r = [],
        s = [];
      for (e = 0; e < i.length; e++) n = i[e], tt(n.event) ? r.push(n) : s.push(n);
      r = this.renderBgSegs(r) || r, s = this.renderFgSegs(s) || s, this.segs = r.concat(s)
    },
    destroyEvents: function() {
      this.triggerSegMouseout(), this.destroyFgSegs(), this.destroyBgSegs(), this.segs = null
    },
    getEventSegs: function() {
      return this.segs || []
    },
    renderFgSegs: function(t) {},
    destroyFgSegs: function() {},
    renderFgSegEls: function(e, n) {
      var i, r = this.view,
        s = "",
        o = [];
      if (e.length) {
        for (i = 0; i < e.length; i++) s += this.fgSegHtml(e[i], n);
        t(s).each(function(n, i) {
          var s = e[n],
            a = r.resolveEventEl(s.event, t(i));
          a && (a.data("fc-seg", s), s.el = a, o.push(s))
        })
      }
      return o
    },
    fgSegHtml: function(t, e) {},
    renderBgSegs: function(t) {
      return this.renderFill("bgEvent", t)
    },
    destroyBgSegs: function() {
      this.destroyFill("bgEvent")
    },
    bgEventSegEl: function(t, e) {
      return this.view.resolveEventEl(t.event, e)
    },
    bgEventSegClasses: function(t) {
      var e = t.event,
        n = e.source || {};
      return ["fc-bgevent"].concat(e.className, n.className || [])
    },
    bgEventSegStyles: function(t) {
      var e = this.view,
        n = t.event,
        i = n.source || {},
        r = n.color,
        s = i.color,
        o = e.opt("eventColor"),
        a = n.backgroundColor || r || i.backgroundColor || s || e.opt("eventBackgroundColor") || o;
      return a ? "background-color:" + a : ""
    },
    businessHoursSegClasses: function(t) {
      return ["fc-nonbusiness", "fc-bgevent"]
    },
    bindSegHandlers: function() {
      var e = this,
        n = this.view;
      t.each({
        mouseenter: function(t, n) {
          e.triggerSegMouseover(t, n)
        },
        mouseleave: function(t, n) {
          e.triggerSegMouseout(t, n)
        },
        click: function(t, e) {
          return n.trigger("eventClick", this, t.event, e)
        },
        mousedown: function(i, r) {
          t(r.target).is(".fc-resizer") && n.isEventResizable(i.event) ? e.segResizeMousedown(i, r) : n.isEventDraggable(i.event) && e.segDragMousedown(i, r)
        }
      }, function(n, i) {
        e.el.on(n, ".fc-event-container > *", function(n) {
          var r = t(this).data("fc-seg");
          return !r || e.isDraggingSeg || e.isResizingSeg ? void 0 : i.call(this, r, n)
        })
      })
    },
    triggerSegMouseover: function(t, e) {
      this.mousedOverSeg || (this.mousedOverSeg = t, this.view.trigger("eventMouseover", t.el[0], t.event, e))
    },
    triggerSegMouseout: function(t, e) {
      e = e || {}, this.mousedOverSeg && (t = t || this.mousedOverSeg, this.mousedOverSeg = null, this.view.trigger("eventMouseout", t.el[0], t.event, e))
    },
    segDragMousedown: function(e, n) {
      var i, r = this,
        s = this.view,
        o = e.el,
        a = e.event;
      if ("year" == s.name) {
        var u = t(o).closest("td.fc-year-monthly-td"),
          c = u.closest("table").find(".fc-year-monthly-td"),
          h = c.index(u);
        s.dayGrid = s.dayGrids[h]
      }
      var f = new jt(e.el, {
          parentEl: s.el,
          opacity: s.opt("dragOpacity"),
          revertDuration: s.opt("dragRevertDuration"),
          zIndex: 2
        }),
        g = new Zt(s.coordMap, {
          distance: 5,
          scroll: s.opt("dragScroll"),
          listenStart: function(t) {
            f.hide(), f.start(t)
          },
          dragStart: function(t) {
            r.triggerSegMouseout(e, t), r.isDraggingSeg = !0, s.hideEvent(a), s.trigger("eventDragStart", o[0], a, t, {})
          },
          cellOver: function(t, n) {
            var o = e.cell || g.origCell;
            i = r.computeEventDrop(o, t, a), i ? (s.renderDrag(i, e) ? f.hide() : f.show(), n && (i = null)) : (f.show(), l())
          },
          cellOut: function() {
            i = null, s.destroyDrag(), f.show(), d()
          },
          dragStop: function(t) {
            f.stop(!i, function() {
              r.isDraggingSeg = !1, s.destroyDrag(), s.showEvent(a), s.trigger("eventDragStop", o[0], a, t, {}), i && s.reportEventDrop(a, i, o, t)
            }), d()
          },
          listenStop: function() {
            f.stop()
          }
        });
      g.mousedown(n)
    },
    computeEventDrop: function(t, e, n) {
      var i, r, s, o, a, l = t.start,
        d = e.start;
      return l.hasTime() === d.hasTime() ? (i = b(d, l), r = n.start.clone().add(i), s = null === n.end ? null : n.end.clone().add(i), o = n.allDay) : (r = d.clone(), s = null, o = !d.hasTime()), a = {
        start: r,
        end: s,
        allDay: o
      }, this.view.calendar.isEventRangeAllowed(a, n) ? a : null
    },
    documentDragStart: function(e, n) {
      var i, r, s = this.view;
      s.opt("droppable") && (i = t(e.target), r = s.opt("dropAccept"), (t.isFunction(r) ? r.call(i[0], i) : i.is(r)) && this.startExternalDrag(i, e, n))
    },
    startExternalDrag: function(e, n, i) {
      var r, s, o = this,
        a = ot(e);
      r = new Zt(this.coordMap, {
        cellOver: function(t) {
          s = o.computeExternalDrop(t, a), s ? o.renderDrag(s) : l()
        },
        cellOut: function() {
          s = null, o.destroyDrag(), d()
        }
      }), t(document).one("dragstop", function(t, n) {
        o.destroyDrag(), d(), s && o.view.reportExternalDrop(a, s, e, t, n)
      }), r.startDrag(n)
    },
    computeExternalDrop: function(t, e) {
      var n = {
        start: t.start.clone(),
        end: null
      };
      return e.startTime && !n.start.hasTime() && n.start.time(e.startTime), e.duration && (n.end = n.start.clone().add(e.duration)), this.view.calendar.isExternalDropRangeAllowed(n, e.eventProps) ? n : null
    },
    renderDrag: function(t, e) {},
    destroyDrag: function() {},
    segResizeMousedown: function(e, n) {
      function i() {
        o.destroyEventResize(), a.showEvent(h), d()
      }
      var r, s, o = this,
        a = this.view,
        u = a.calendar,
        c = e.el,
        h = e.event,
        f = h.start,
        g = u.getEventEnd(h);
      s = new Zt(this.coordMap, {
        distance: 5,
        scroll: a.opt("dragScroll"),
        dragStart: function(t) {
          o.triggerSegMouseout(e, t), o.isResizingSeg = !0, a.trigger("eventResizeStart", c[0], h, t, {})
        },
        cellOver: function(n) {
          r = n.end, r.isAfter(f) || (r = f.clone().add(b(n.end, n.start))), r.isSame(g) ? r = null : u.isEventRangeAllowed({
            start: f,
            end: r
          }, h) ? (o.renderEventResize({
            start: f,
            end: r
          }, e), "year" == a.name && t.each(a.dayGrids, function(t, n) {
            n !== o && (n.destroyEventResize(), n.renderEventResize({
              start: f,
              end: r
            }, e))
          }), a.hideEvent(h)) : (r = null, l())
        },
        cellOut: function() {
          r = null, i()
        },
        dragStop: function(t) {
          o.isResizingSeg = !1, i(), a.trigger("eventResizeStop", c[0], h, t, {}), r && a.reportEventResize(h, r, c, t)
        }
      }), s.mousedown(n)
    },
    renderEventResize: function(t, e) {},
    destroyEventResize: function() {},
    getEventTimeText: function(t, e) {
      return e = e || this.eventTimeFormat, t.end && this.displayEventEnd ? this.view.formatRange(t, e) : t.start.format(e)
    },
    getSegClasses: function(t, e, n) {
      var i = t.event,
        r = ["fc-event", t.isStart ? "fc-start" : "fc-not-start", t.isEnd ? "fc-end" : "fc-not-end"].concat(i.className, i.source ? i.source.className : []);
      return e && r.push("fc-draggable"), n && r.push("fc-resizable"), r
    },
    getEventSkinCss: function(t) {
      var e = this.view,
        n = t.source || {},
        i = t.color,
        r = n.color,
        s = e.opt("eventColor"),
        o = t.backgroundColor || i || n.backgroundColor || r || e.opt("eventBackgroundColor") || s,
        a = t.borderColor || i || n.borderColor || r || e.opt("eventBorderColor") || s,
        l = t.textColor || n.textColor || e.opt("eventTextColor"),
        d = [];
      return o && d.push("background-color:" + o), a && d.push("border-color:" + a), l && d.push("color:" + l), d.join(";")
    },
    eventsToSegs: function(t, e) {
      var n, i = this.eventsToRanges(t),
        r = [];
      for (n = 0; n < i.length; n++) r.push.apply(r, this.eventRangeToSegs(i[n], e));
      return r
    },
    eventsToRanges: function(e) {
      var n = this,
        i = it(e),
        r = [];
      return t.each(i, function(t, e) {
        e.length && r.push.apply(r, et(e[0]) ? n.eventsToInverseRanges(e) : n.eventsToNormalRanges(e))
      }), r
    },
    eventsToNormalRanges: function(t) {
      var e, n, i, r, s = this.view.calendar,
        o = [];
      for (e = 0; e < t.length; e++) n = t[e], i = n.start.clone().stripZone(), r = s.getEventEnd(n).stripZone(), o.push({
        event: n,
        start: i,
        end: r,
        eventStartMS: +i,
        eventDurationMS: r - i
      });
      return o
    },
    eventsToInverseRanges: function(t) {
      var e, n, i = this.view,
        r = i.start.clone().stripZone(),
        s = i.end.clone().stripZone(),
        o = this.eventsToNormalRanges(t),
        a = [],
        l = t[0],
        d = r;
      for (o.sort(rt), e = 0; e < o.length; e++) n = o[e], n.start > d && a.push({
        event: l,
        start: d,
        end: n.start
      }), d = n.end;
      return s > d && a.push({
        event: l,
        start: d,
        end: s
      }), a
    },
    eventRangeToSegs: function(t, e) {
      var n, i, r;
      for (n = e ? e(t) : this.rangeToSegs(t), i = 0; i < n.length; i++) r = n[i], r.event = t.event, r.eventStartMS = t.eventStartMS, r.eventDurationMS = t.eventDurationMS;
      return n
    }
  }), Dt.compareSegs = st, Dt.dataAttrPrefix = "";
  var $t = Ut.extend({
    numbersVisible: !1,
    bottomCoordPadding: 0,
    breakOnWeeks: null,
    cellDates: null,
    dayToCellOffsets: null,
    rowEls: null,
    dayEls: null,
    helperEls: null,
    render: function(t) {
      var e, n, i, r = this.view,
        s = this.rowCnt,
        o = this.colCnt,
        a = s * o,
        l = "";
      for (e = 0; s > e; e++) l += this.dayRowHtml(e, t);
      for (this.el.html(l), this.rowEls = this.el.find(".fc-row"), this.dayEls = this.el.find(".fc-day"), n = 0; a > n; n++) i = this.getCell(n), r.trigger("dayRender", null, i.start, this.dayEls.eq(n));
      Ut.prototype.render.call(this)
    },
    destroy: function() {
      this.destroySegPopover(), Ut.prototype.destroy.call(this)
    },
    dayRowHtml: function(t, e) {
      var n = this.view,
        i = ["fc-row", "fc-week", n.widgetContentClass];
      return e && i.push("fc-rigid"), '<div class="' + i.join(" ") + '"><div class="fc-bg"><table>' + this.rowHtml("day", t) + '</table></div><div class="fc-content-skeleton"><table>' + (this.numbersVisible ? "<thead>" + this.rowHtml("number", t) + "</thead>" : "") + "</table></div></div>"
    },
    dayCellHtml: function(t) {
      return this.bgCellHtml(t)
    },
    computeColHeadFormat: function() {
      return this.rowCnt > 1 ? "ddd" : this.colCnt > 1 ? this.view.opt("dayOfMonthFormat") : "dddd"
    },
    computeEventTimeFormat: function() {
      return this.view.opt("extraSmallTimeFormat")
    },
    computeDisplayEventEnd: function() {
      return 1 == this.colCnt
    },
    updateCells: function() {
      var t, e, n, i;
      if (this.updateCellDates(), t = this.cellDates, this.breakOnWeeks) {
        for (e = t[0].day(), i = 1; i < t.length && t[i].day() != e; i++);
        n = Math.ceil(t.length / i)
      } else n = 1, i = t.length;
      this.rowCnt = n, this.colCnt = i
    },
    updateCellDates: function() {
      for (var t = this.view, e = this.start.clone(), n = [], i = -1, r = []; e.isBefore(this.end);) t.isHiddenDay(e) ? r.push(i + .5) : (i++, r.push(i), n.push(e.clone())), e.add(1, "days");
      this.cellDates = n, this.dayToCellOffsets = r
    },
    computeCellRange: function(t) {
      var e = this.colCnt,
        n = t.row * e + (this.isRTL ? e - t.col - 1 : t.col),
        i = this.cellDates[n].clone(),
        r = i.clone().add(1, "day");
      return {
        start: i,
        end: r
      }
    },
    getRowEl: function(t) {
      return this.rowEls.eq(t)
    },
    getColEl: function(t) {
      return this.dayEls.eq(t)
    },
    getCellDayEl: function(t) {
      return this.dayEls.eq(t.row * this.colCnt + t.col)
    },
    computeRowCoords: function() {
      var t = Ut.prototype.computeRowCoords.call(this);
      return t[t.length - 1].bottom += this.bottomCoordPadding, t
    },
    rangeToSegs: function(t) {
      var e, n, i, r, s, o, a, l, d, u, c = this.isRTL,
        h = this.rowCnt,
        f = this.colCnt,
        g = [];
      for (t = this.view.computeDayRange(t), e = this.dateToCellOffset(t.start), n = this.dateToCellOffset(t.end.subtract(1, "days")), i = 0; h > i; i++) r = i * f, s = r + f - 1, l = Math.max(r, e), d = Math.min(s, n), l = Math.ceil(l), d = Math.floor(d), d >= l && (o = l === e, a = d === n, l -= r, d -= r, u = {
        row: i,
        isStart: o,
        isEnd: a
      }, c ? (u.leftCol = f - d - 1, u.rightCol = f - l - 1) : (u.leftCol = l, u.rightCol = d), g.push(u));
      return g
    },
    dateToCellOffset: function(t) {
      var e = this.dayToCellOffsets,
        n = t.diff(this.start, "days");
      return 0 > n ? e[0] - 1 : n >= e.length ? e[e.length - 1] + 1 : e[n]
    },
    renderDrag: function(t, e) {
      var n;
      return this.renderHighlight(this.view.calendar.ensureVisibleEventRange(t)), e && !e.el.closest(this.view.el).length ? (this.renderRangeHelper(t, e), n = this.view.opt("dragOpacity"), void 0 !== n && this.helperEls.css("opacity", n), !0) : void 0
    },
    destroyDrag: function() {
      this.destroyHighlight(), this.destroyHelper()
    },
    renderEventResize: function(t, e) {
      this.renderHighlight(t), this.renderRangeHelper(t, e)
    },
    destroyEventResize: function() {
      this.destroyHighlight(), this.destroyHelper()
    },
    renderHelper: function(e, n) {
      var i, r = [],
        s = this.eventsToSegs([e]);
      s = this.renderFgSegEls(s), i = this.renderSegRows(s), this.rowEls.each(function(e, s) {
        var o, a = t(s),
          l = t('<div class="fc-helper-skeleton"><table/></div>');
        o = n && n.row === e ? n.el.position().top : a.find(".fc-content-skeleton tbody").position().top, l.css("top", o).find("table").append(i[e].tbodyEl), a.append(l), r.push(l[0])
      }), this.helperEls = t(r)
    },
    destroyHelper: function() {
      this.helperEls && (this.helperEls.remove(), this.helperEls = null)
    },
    fillSegTag: "td",
    renderFill: function(e, n) {
      var i, r, s, o = [];
      for (n = this.renderFillSegEls(e, n), i = 0; i < n.length; i++) r = n[i], s = this.renderFillRow(e, r), this.rowEls.eq(r.row).append(s), o.push(s[0]);
      return this.elsByFill[e] = t(o), n
    },
    renderFillRow: function(e, n) {
      var i, r, s = this.colCnt,
        o = n.leftCol,
        a = n.rightCol + 1;
      return i = t('<div class="fc-' + e.toLowerCase() + '-skeleton"><table><tr/></table></div>'), r = i.find("tr"), o > 0 && r.append('<td colspan="' + o + '"/>'), r.append(n.el.attr("colspan", a - o)), s > a && r.append('<td colspan="' + (s - a) + '"/>'), this.bookendCells(r, e), i
    }
  });
  $t.mixin({
    rowStructs: null,
    destroyEvents: function() {
      this.destroySegPopover(), Ut.prototype.destroyEvents.apply(this, arguments)
    },
    getEventSegs: function() {
      return Ut.prototype.getEventSegs.call(this).concat(this.popoverSegs || [])
    },
    renderBgSegs: function(e) {
      var n = t.grep(e, function(t) {
        return t.event.allDay
      });
      return Ut.prototype.renderBgSegs.call(this, n)
    },
    renderFgSegs: function(e) {
      var n;
      return e = this.renderFgSegEls(e), n = this.rowStructs = this.renderSegRows(e), this.rowEls.each(function(e, i) {
        e < n.length && t(i).find(".fc-content-skeleton > table").append(n[e].tbodyEl)
      }), e
    },
    destroyFgSegs: function() {
      for (var t, e = this.rowStructs || []; t = e.pop();) t.tbodyEl.remove();
      this.rowStructs = null
    },
    renderSegRows: function(t) {
      var e, n, i = [];
      for (e = this.groupSegRows(t), n = 0; n < e.length; n++) i.push(this.renderSegRow(n, e[n]));
      return i
    },
    fgSegHtml: function(t, e) {
      var n, i = this.view,
        r = t.event,
        s = i.isEventDraggable(r),
        o = !e && r.allDay && t.isEnd && i.isEventResizable(r),
        a = this.getSegClasses(t, s, o),
        l = this.getEventSkinCss(r),
        d = "";
      return a.unshift("fc-day-grid-event"), !r.allDay && t.isStart && (d = '<span class="fc-time">' + N(this.getEventTimeText(r)) + "</span>"), n = '<span class="fc-title">' + (N(r.title || "") || "&nbsp;") + "</span>", '<a class="' + a.join(" ") + '"' + (r.url ? ' href="' + N(r.url) + '"' : "") + (l ? ' style="' + l + '"' : "") + '><div class="fc-content">' + (this.isRTL ? n + " " + d : d + " " + n) + "</div>" + (o ? '<div class="fc-resizer"/>' : "") + "</a>"
    },
    renderSegRow: function(e, n) {
      function i(e) {
        for (; e > o;) u = (v[r - 1] || [])[o], u ? u.attr("rowspan", parseInt(u.attr("rowspan") || 1, 10) + 1) : (u = t("<td/>"), a.append(u)), m[r][o] = u, v[r][o] = u, o++
      }
      var r, s, o, a, l, d, u, c = this.colCnt,
        h = this.buildSegLevels(n),
        f = Math.max(1, h.length),
        g = t("<tbody/>"),
        p = [],
        m = [],
        v = [];
      for (r = 0; f > r; r++) {
        if (s = h[r], o = 0, a = t("<tr/>"), p.push([]), m.push([]), v.push([]), s)
          for (l = 0; l < s.length; l++) {
            for (d = s[l], i(d.leftCol), u = t('<td class="fc-event-container"/>').append(d.el), d.leftCol != d.rightCol ? u.attr("colspan", d.rightCol - d.leftCol + 1) : v[r][o] = u; o <= d.rightCol;) m[r][o] = u, p[r][o] = d, o++;
            a.append(u)
          }
        i(c), this.bookendCells(a, "eventSkeleton"), g.append(a)
      }
      return {
        row: e,
        tbodyEl: g,
        cellMatrix: m,
        segMatrix: p,
        segLevels: h,
        segs: n
      }
    },
    buildSegLevels: function(t) {
      var e, n, i, r = [];
      for (t.sort(st), e = 0; e < t.length; e++) {
        for (n = t[e], i = 0; i < r.length && at(n, r[i]); i++);
        n.level = i, (r[i] || (r[i] = [])).push(n)
      }
      for (i = 0; i < r.length; i++) r[i].sort(lt);
      return r
    },
    groupSegRows: function(t) {
      var e, n = [];
      for (e = 0; e < this.rowCnt; e++) n.push([]);
      for (e = 0; e < t.length; e++) n[t[e].row].push(t[e]);
      return n
    }
  }), $t.mixin({
    segPopover: null,
    popoverSegs: null,
    destroySegPopover: function() {
      this.segPopover && this.segPopover.hide()
    },
    limitRows: function(t) {
      var e, n, i = this.rowStructs || [];
      for (e = 0; e < i.length; e++) this.unlimitRow(e), n = t ? "number" == typeof t ? t : this.computeRowLevelLimit(e) : !1, n !== !1 && this.limitRow(e, n)
    },
    computeRowLevelLimit: function(t) {
      var e, n, i = this.rowEls.eq(t),
        r = i.height(),
        s = this.rowStructs[t].tbodyEl.children();
      for (e = 0; e < s.length; e++)
        if (n = s.eq(e).removeClass("fc-limited"), n.position().top + n.outerHeight() > r) return e;
      return !1
    },
    limitRow: function(e, n) {
      function i(i) {
        for (; i > C;) r = b.getCell(e, C), u = b.getCellSegs(r, n), u.length && (f = o[n - 1][C], w = b.renderMoreLink(r, u), y = t("<div/>").append(w), f.append(y), E.push(y[0])), C++
      }
      var r, s, o, a, l, d, u, c, h, f, g, p, m, v, y, w, b = this,
        S = this.rowStructs[e],
        E = [],
        C = 0;
      if (n && n < S.segLevels.length) {
        for (s = S.segLevels[n - 1], o = S.cellMatrix, a = S.tbodyEl.children().slice(n).addClass("fc-limited").get(), l = 0; l < s.length; l++) {
          for (d = s[l], i(d.leftCol), h = [], c = 0; C <= d.rightCol;) r = this.getCell(e, C), u = this.getCellSegs(r, n), h.push(u), c += u.length, C++;
          if (c) {
            for (f = o[n - 1][d.leftCol], g = f.attr("rowspan") || 1, p = [], m = 0; m < h.length; m++) v = t('<td class="fc-more-cell"/>').attr("rowspan", g), u = h[m], r = this.getCell(e, d.leftCol + m), w = this.renderMoreLink(r, [d].concat(u)), y = t("<div/>").append(w), v.append(y), p.push(v[0]), E.push(v[0]);
            f.addClass("fc-limited").after(t(p)), a.push(f[0])
          }
        }
        i(this.colCnt), S.moreEls = t(E), S.limitedEls = t(a)
      }
    },
    unlimitRow: function(t) {
      var e = this.rowStructs[t];
      e.moreEls && (e.moreEls.remove(), e.moreEls = null), e.limitedEls && (e.limitedEls.removeClass("fc-limited"), e.limitedEls = null)
    },
    renderMoreLink: function(e, n) {
      var i = this,
        r = this.view;
      return t('<a class="fc-more"/>').text(this.getMoreLinkText(n.length)).on("click", function(s) {
        var o = r.opt("eventLimitClick"),
          a = e.start,
          l = t(this),
          d = i.getCellDayEl(e),
          u = i.getCellSegs(e),
          c = i.resliceDaySegs(u, a),
          h = i.resliceDaySegs(n, a);
        "function" == typeof o && (o = r.trigger("eventLimitClick", null, {
          date: a,
          dayEl: d,
          moreEl: l,
          segs: c,
          hiddenSegs: h
        }, s)), "popover" === o ? i.showSegPopover(e, l, c) : "string" == typeof o && r.calendar.zoomTo(a, o)
      })
    },
    showSegPopover: function(t, e, n) {
      var i, r, s = this,
        o = this.view,
        a = e.parent();
      i = 1 == this.rowCnt ? o.el : this.rowEls.eq(t.row), r = {
        className: "fc-more-popover",
        content: this.renderSegPopoverContent(t, n),
        parentEl: this.el,
        top: i.offset().top,
        autoHide: !0,
        viewportConstrain: o.opt("popoverViewportConstrain"),
        hide: function() {
          s.segPopover.destroy(), s.segPopover = null, s.popoverSegs = null
        }
      }, this.isRTL ? r.right = a.offset().left + a.outerWidth() + 1 : r.left = a.offset().left - 1, this.segPopover = new Bt(r), this.segPopover.show()
    },
    renderSegPopoverContent: function(e, n) {
      var i, r = this.view,
        s = r.opt("theme"),
        o = e.start.format(r.opt("dayPopoverFormat")),
        a = t('<div class="fc-header ' + r.widgetHeaderClass + '"><span class="fc-close ' + (s ? "ui-icon ui-icon-closethick" : "fc-icon fc-icon-x") + '"></span><span class="fc-title">' + N(o) + '</span><div class="fc-clear"/></div><div class="fc-body ' + r.widgetContentClass + '"><div class="fc-event-container"></div></div>'),
        l = a.find(".fc-event-container");
      for (n = this.renderFgSegEls(n, !0), this.popoverSegs = n, i = 0; i < n.length; i++) n[i].cell = e, l.append(n[i].el);
      return a
    },
    resliceDaySegs: function(e, n) {
      var i = t.map(e, function(t) {
          return t.event
        }),
        r = n.clone().stripTime(),
        s = r.clone().add(1, "days"),
        o = {
          start: r,
          end: s
        };
      return e = this.eventsToSegs(i, function(t) {
        var e = y(t, o);
        return e ? [e] : []
      }), e.sort(st), e
    },
    getMoreLinkText: function(t) {
      var e = this.view.opt("eventLimitText");
      return "function" == typeof e ? e(t) : "+" + t + " " + e
    },
    getCellSegs: function(t, e) {
      for (var n, i = this.rowStructs[t.row].segMatrix, r = e || 0, s = []; r < i.length;) n = i[r][t.col], n && s.push(n), r++;
      return s
    }
  });
  var qt = Ut.extend({
    slotDuration: null,
    snapDuration: null,
    minTime: null,
    maxTime: null,
    axisFormat: null,
    dayEls: null,
    slatEls: null,
    slatTops: null,
    helperEl: null,
    businessHourSegs: null,
    constructor: function() {
      Ut.apply(this, arguments), this.processOptions()
    },
    render: function() {
      this.el.html(this.renderHtml()), this.dayEls = this.el.find(".fc-day"), this.slatEls = this.el.find(".fc-slats tr"), this.computeSlatTops(), this.renderBusinessHours(), Ut.prototype.render.call(this)
    },
    renderBusinessHours: function() {
      var t = this.view.calendar.getBusinessHoursEvents();
      this.businessHourSegs = this.renderFill("businessHours", this.eventsToSegs(t), "bgevent")
    },
    renderHtml: function() {
      return '<div class="fc-bg"><table>' + this.rowHtml("slotBg") + '</table></div><div class="fc-slats"><table>' + this.slatRowHtml() + "</table></div>"
    },
    slotBgCellHtml: function(t) {
      return this.bgCellHtml(t)
    },
    slatRowHtml: function() {
      for (var t, n, i, r = this.view, s = this.isRTL, o = "", a = this.slotDuration.asMinutes() % 15 === 0, l = e.duration(+this.minTime); l < this.maxTime;) t = this.start.clone().time(l), n = t.minutes(), i = '<td class="fc-axis fc-time ' + r.widgetContentClass + '" ' + r.axisStyleAttr() + ">" + (a && n ? "" : "<span>" + N(t.format(this.axisFormat)) + "</span>") + "</td>", o += "<tr " + (n ? 'class="fc-minor"' : "") + ">" + (s ? "" : i) + '<td class="' + r.widgetContentClass + '"/>' + (s ? i : "") + "</tr>", l.add(this.slotDuration);
      return o
    },
    processOptions: function() {
      var t = this.view,
        n = t.opt("slotDuration"),
        i = t.opt("snapDuration");
      n = e.duration(n), i = i ? e.duration(i) : n, this.slotDuration = n, this.snapDuration = i, this.minTime = e.duration(t.opt("minTime")), this.maxTime = e.duration(t.opt("maxTime")), this.axisFormat = t.opt("axisFormat") || t.opt("smallTimeFormat")
    },
    computeColHeadFormat: function() {
      return this.colCnt > 1 ? this.view.opt("dayOfMonthFormat") : "dddd";
    },
    computeEventTimeFormat: function() {
      return this.view.opt("noMeridiemTimeFormat")
    },
    computeDisplayEventEnd: function() {
      return !0
    },
    updateCells: function() {
      var t, e = this.view,
        n = [];
      for (t = this.start.clone(); t.isBefore(this.end);) n.push({
        day: t.clone()
      }), t.add(1, "day"), t = e.skipHiddenDays(t);
      this.isRTL && n.reverse(), this.colData = n, this.colCnt = n.length, this.rowCnt = Math.ceil((this.maxTime - this.minTime) / this.snapDuration)
    },
    computeCellRange: function(t) {
      var e = this.computeSnapTime(t.row),
        n = this.view.calendar.rezoneDate(t.day).time(e),
        i = n.clone().add(this.snapDuration);
      return {
        start: n,
        end: i
      }
    },
    getColEl: function(t) {
      return this.dayEls.eq(t)
    },
    computeSnapTime: function(t) {
      return e.duration(this.minTime + this.snapDuration * t)
    },
    rangeToSegs: function(t) {
      var e, n, i, r, s = this.colCnt,
        o = [];
      for (t = {
          start: t.start.clone().stripZone(),
          end: t.end.clone().stripZone()
        }, n = 0; s > n; n++) i = this.colData[n].day, r = {
        start: i.clone().time(this.minTime),
        end: i.clone().time(this.maxTime)
      }, e = y(t, r), e && (e.col = n, o.push(e));
      return o
    },
    resize: function() {
      this.computeSlatTops(), this.updateSegVerticals()
    },
    computeRowCoords: function() {
      var t, e, n = this.el.offset().top,
        i = [];
      for (t = 0; t < this.rowCnt; t++) e = {
        top: n + this.computeTimeTop(this.computeSnapTime(t))
      }, t > 0 && (i[t - 1].bottom = e.top), i.push(e);
      return e.bottom = e.top + this.computeTimeTop(this.computeSnapTime(t)), i
    },
    computeDateTop: function(t, n) {
      return this.computeTimeTop(e.duration(t.clone().stripZone() - n.clone().stripTime()))
    },
    computeTimeTop: function(t) {
      var e, n, i, r, s = (t - this.minTime) / this.slotDuration;
      return s = Math.max(0, s), s = Math.min(this.slatEls.length, s), e = Math.floor(s), n = s - e, i = this.slatTops[e], n ? (r = this.slatTops[e + 1], i + (r - i) * n) : i
    },
    computeSlatTops: function() {
      var e, n = [];
      this.slatEls.each(function(i, r) {
        e = t(r).position().top, n.push(e)
      }), n.push(e + this.slatEls.last().outerHeight()), this.slatTops = n
    },
    renderDrag: function(t, e) {
      var n;
      return e ? (this.renderRangeHelper(t, e), n = this.view.opt("dragOpacity"), void 0 !== n && this.helperEl.css("opacity", n), !0) : void this.renderHighlight(this.view.calendar.ensureVisibleEventRange(t))
    },
    destroyDrag: function() {
      this.destroyHelper(), this.destroyHighlight()
    },
    renderEventResize: function(t, e) {
      this.renderRangeHelper(t, e)
    },
    destroyEventResize: function() {
      this.destroyHelper()
    },
    renderHelper: function(e, n) {
      var i, r, s, o, a = this.eventsToSegs([e]);
      for (a = this.renderFgSegEls(a), i = this.renderSegTable(a), r = 0; r < a.length; r++) s = a[r], n && n.col === s.col && (o = n.el, s.el.css({
        left: o.css("left"),
        right: o.css("right"),
        "margin-left": o.css("margin-left"),
        "margin-right": o.css("margin-right")
      }));
      this.helperEl = t('<div class="fc-helper-skeleton"/>').append(i).appendTo(this.el)
    },
    destroyHelper: function() {
      this.helperEl && (this.helperEl.remove(), this.helperEl = null)
    },
    renderSelection: function(t) {
      this.view.opt("selectHelper") ? this.renderRangeHelper(t) : this.renderHighlight(t)
    },
    destroySelection: function() {
      this.destroyHelper(), this.destroyHighlight()
    },
    renderFill: function(e, n, i) {
      var r, s, o, a, l, d, u, c, h, f;
      if (n.length) {
        for (n = this.renderFillSegEls(e, n), r = this.groupSegCols(n), i = i || e.toLowerCase(), s = t('<div class="fc-' + i + '-skeleton"><table><tr/></table></div>'), o = s.find("tr"), a = 0; a < r.length; a++)
          if (l = r[a], d = t("<td/>").appendTo(o), l.length)
            for (u = t('<div class="fc-' + i + '-container"/>').appendTo(d), c = this.colData[a].day, h = 0; h < l.length; h++) f = l[h], u.append(f.el.css({
              top: this.computeDateTop(f.start, c),
              bottom: -this.computeDateTop(f.end, c)
            }));
        this.bookendCells(o, e), this.el.append(s), this.elsByFill[e] = s
      }
      return n
    }
  });
  qt.mixin({
    eventSkeletonEl: null,
    renderFgSegs: function(e) {
      return e = this.renderFgSegEls(e), this.el.append(this.eventSkeletonEl = t('<div class="fc-content-skeleton"/>').append(this.renderSegTable(e))), e
    },
    destroyFgSegs: function(t) {
      this.eventSkeletonEl && (this.eventSkeletonEl.remove(), this.eventSkeletonEl = null)
    },
    renderSegTable: function(e) {
      var n, i, r, s, o, a, l = t("<table><tr/></table>"),
        d = l.find("tr");
      for (n = this.groupSegCols(e), this.computeSegVerticals(e), s = 0; s < n.length; s++) {
        for (o = n[s], dt(o), a = t('<div class="fc-event-container"/>'), i = 0; i < o.length; i++) r = o[i], r.el.css(this.generateSegPositionCss(r)), r.bottom - r.top < 30 && r.el.addClass("fc-short"), a.append(r.el);
        d.append(t("<td/>").append(a))
      }
      return this.bookendCells(d, "eventSkeleton"), l
    },
    updateSegVerticals: function() {
      var t, e = (this.segs || []).concat(this.businessHourSegs || []);
      for (this.computeSegVerticals(e), t = 0; t < e.length; t++) e[t].el.css(this.generateSegVerticalCss(e[t]))
    },
    computeSegVerticals: function(t) {
      var e, n;
      for (e = 0; e < t.length; e++) n = t[e], n.top = this.computeDateTop(n.start, n.start), n.bottom = this.computeDateTop(n.end, n.start)
    },
    fgSegHtml: function(t, e) {
      var n, i, r, s = this.view,
        o = t.event,
        a = s.isEventDraggable(o),
        l = !e && t.isEnd && s.isEventResizable(o),
        d = this.getSegClasses(t, a, l),
        u = this.getEventSkinCss(o);
      return d.unshift("fc-time-grid-event"), s.isMultiDayEvent(o) ? (t.isStart || t.isEnd) && (n = this.getEventTimeText(t), i = this.getEventTimeText(t, "LT"), r = this.getEventTimeText({
        start: t.start
      })) : (n = this.getEventTimeText(o), i = this.getEventTimeText(o, "LT"), r = this.getEventTimeText({
        start: o.start
      })), '<a class="' + d.join(" ") + '"' + (o.url ? ' href="' + N(o.url) + '"' : "") + (u ? ' style="' + u + '"' : "") + '><div class="fc-content">' + (n ? '<div class="fc-time" data-start="' + N(r) + '" data-full="' + N(i) + '"><span>' + N(n) + "</span></div>" : "") + (o.title ? '<div class="fc-title">' + N(o.title) + "</div>" : "") + '</div><div class="fc-bg"/>' + (l ? '<div class="fc-resizer"/>' : "") + "</a>"
    },
    generateSegPositionCss: function(t) {
      var e, n, i = this.view.opt("slotEventOverlap"),
        r = t.backwardCoord,
        s = t.forwardCoord,
        o = this.generateSegVerticalCss(t);
      return i && (s = Math.min(1, r + 2 * (s - r))), this.isRTL ? (e = 1 - s, n = r) : (e = r, n = 1 - s), o.zIndex = t.level + 1, o.left = 100 * e + "%", o.right = 100 * n + "%", i && t.forwardPressure && (o[this.isRTL ? "marginLeft" : "marginRight"] = 20), o
    },
    generateSegVerticalCss: function(t) {
      return {
        top: t.top,
        bottom: -t.bottom
      }
    },
    groupSegCols: function(t) {
      var e, n = [];
      for (e = 0; e < this.colCnt; e++) n.push([]);
      for (e = 0; e < t.length; e++) n[t[e].col].push(t[e]);
      return n
    }
  });
  var Kt = Dt.View = Q.extend({
    type: null,
    name: null,
    title: null,
    calendar: null,
    options: null,
    coordMap: null,
    el: null,
    start: null,
    end: null,
    intervalStart: null,
    intervalEnd: null,
    intervalDuration: null,
    intervalUnit: null,
    isSelected: !1,
    scrollerEl: null,
    scrollTop: null,
    widgetHeaderClass: null,
    widgetContentClass: null,
    highlightStateClass: null,
    nextDayThreshold: null,
    isHiddenDayHash: null,
    documentMousedownProxy: null,
    constructor: function(n, i, r) {
      this.calendar = n, this.options = i, this.type = this.name = r, this.nextDayThreshold = e.duration(this.opt("nextDayThreshold")), this.initTheming(), this.initHiddenDays(), this.documentMousedownProxy = t.proxy(this, "documentMousedown"), this.initialize()
    },
    initialize: function() {},
    opt: function(e) {
      var n;
      return n = this.options[e], void 0 !== n ? n : (n = this.calendar.options[e], t.isPlainObject(n) && !r(e) ? w(n, this.type) : n)
    },
    trigger: function(t, e) {
      var n = this.calendar;
      return n.trigger.apply(n, [t, e || this].concat(Array.prototype.slice.call(arguments, 2), [this]))
    },
    setDate: function(t) {
      this.setRange(this.computeRange(t))
    },
    setRange: function(e) {
      t.extend(this, e), this.updateTitle()
    },
    computeRange: function(t) {
      var n, i, r = e.duration(this.opt("duration") || this.constructor.duration || {
          days: 1
        }),
        s = E(r),
        o = t.clone().startOf(s),
        a = o.clone().add(r);
      return /year|month|week|day/.test(s) ? (o.stripTime(), a.stripTime()) : (o.hasTime() || (o = this.calendar.rezoneDate(o)), a.hasTime() || (a = this.calendar.rezoneDate(a))), n = o.clone(), n = this.skipHiddenDays(n), i = a.clone(), i = this.skipHiddenDays(i, -1, !0), {
        intervalDuration: r,
        intervalUnit: s,
        intervalStart: o,
        intervalEnd: a,
        start: n,
        end: i
      }
    },
    computePrevDate: function(t) {
      return this.massageCurrentDate(t.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1)
    },
    computeNextDate: function(t) {
      return this.massageCurrentDate(t.clone().startOf(this.intervalUnit).add(this.intervalDuration))
    },
    massageCurrentDate: function(t, n) {
      return this.intervalDuration <= e.duration({
        days: 1
      }) && this.isHiddenDay(t) && (t = this.skipHiddenDays(t, n), t.startOf("day")), t
    },
    updateTitle: function() {
      this.title = this.computeTitle()
    },
    computeTitle: function() {
      return this.formatRange({
        start: this.intervalStart,
        end: this.intervalEnd
      }, this.opt("titleFormat") || this.computeTitleFormat(), this.opt("titleRangeSeparator"))
    },
    computeTitleFormat: function() {
      return "year" == this.intervalUnit ? "YYYY" : "month" == this.intervalUnit ? this.opt("monthYearFormat") : this.intervalDuration.as("days") > 1 ? "ll" : "LL"
    },
    formatRange: function(t, e, n) {
      var i = t.end;
      return i.hasTime() || (i = i.clone().subtract(1)), X(t.start, i, e, n, this.opt("isRTL"))
    },
    renderView: function() {
      this.render(), this.updateSize(), this.initializeScroll(), this.trigger("viewRender", this, this, this.el), t(document).on("mousedown", this.documentMousedownProxy)
    },
    render: function() {},
    destroyView: function() {
      this.unselect(), this.destroyViewEvents(), this.destroy(), this.trigger("viewDestroy", this, this, this.el), t(document).off("mousedown", this.documentMousedownProxy)
    },
    destroy: function() {
      this.el.empty()
    },
    initTheming: function() {
      var t = this.opt("theme") ? "ui" : "fc";
      this.widgetHeaderClass = t + "-widget-header", this.widgetContentClass = t + "-widget-content", this.highlightStateClass = t + "-state-highlight"
    },
    updateSize: function(t) {
      t && this.recordScroll(), this.updateHeight(), this.updateWidth()
    },
    updateWidth: function() {},
    updateHeight: function() {
      var t = this.calendar;
      this.setHeight(t.getSuggestedViewHeight(), t.isHeightAuto())
    },
    setHeight: function(t, e) {},
    computeScrollerHeight: function(t, e) {
      var n, i;
      return e = e || this.scrollerEl, n = this.el.add(e), n.css({
        position: "relative",
        left: -1
      }), i = this.el.outerHeight() - e.height(), n.css({
        position: "",
        left: ""
      }), t - i
    },
    initializeScroll: function() {},
    recordScroll: function() {
      this.scrollerEl && (this.scrollTop = this.scrollerEl.scrollTop())
    },
    restoreScroll: function() {
      null !== this.scrollTop && this.scrollerEl.scrollTop(this.scrollTop)
    },
    renderViewEvents: function(t) {
      this.renderEvents(t), this.eventSegEach(function(t) {
        this.trigger("eventAfterRender", t.event, t.event, t.el)
      }), this.trigger("eventAfterAllRender")
    },
    renderEvents: function() {},
    destroyViewEvents: function() {
      this.eventSegEach(function(t) {
        this.trigger("eventDestroy", t.event, t.event, t.el)
      }), this.destroyEvents()
    },
    destroyEvents: function() {},
    resolveEventEl: function(e, n) {
      var i = this.trigger("eventRender", e, e, n);
      return i === !1 ? n = null : i && i !== !0 && (n = t(i)), n
    },
    showEvent: function(t) {
      this.eventSegEach(function(t) {
        t.el.css("visibility", "")
      }, t)
    },
    hideEvent: function(t) {
      this.eventSegEach(function(t) {
        t.el.css("visibility", "hidden")
      }, t)
    },
    eventSegEach: function(t, e) {
      var n, i = this.getEventSegs();
      for (n = 0; n < i.length; n++) e && i[n].event._id !== e._id || t.call(this, i[n])
    },
    getEventSegs: function() {
      return []
    },
    isEventDraggable: function(t) {
      var e = t.source || {};
      return G(t.startEditable, e.startEditable, this.opt("eventStartEditable"), t.editable, e.editable, this.opt("editable"))
    },
    reportEventDrop: function(t, e, n, i) {
      var r = this.calendar,
        s = r.mutateEvent(t, e),
        o = function() {
          s.undo(), r.reportEventChange()
        };
      this.triggerEventDrop(t, s.dateDelta, o, n, i), r.reportEventChange()
    },
    triggerEventDrop: function(t, e, n, i, r) {
      this.trigger("eventDrop", i[0], t, e, n, r, {})
    },
    reportExternalDrop: function(e, n, i, r, s) {
      var o, a, l = e.eventProps;
      l && (o = t.extend({}, l, n), a = this.calendar.renderEvent(o, e.stick)[0]), this.triggerExternalDrop(a, n, i, r, s)
    },
    triggerExternalDrop: function(t, e, n, i, r) {
      this.trigger("drop", n[0], e.start, i, r), t && this.trigger("eventReceive", null, t)
    },
    renderDrag: function(t, e) {},
    destroyDrag: function() {},
    isEventResizable: function(t) {
      var e = t.source || {};
      return G(t.durationEditable, e.durationEditable, this.opt("eventDurationEditable"), t.editable, e.editable, this.opt("editable"))
    },
    reportEventResize: function(t, e, n, i) {
      var r = this.calendar,
        s = r.mutateEvent(t, {
          end: e
        }),
        o = function() {
          s.undo(), r.reportEventChange()
        };
      this.triggerEventResize(t, s.durationDelta, o, n, i), r.reportEventChange()
    },
    triggerEventResize: function(t, e, n, i, r) {
      this.trigger("eventResize", i[0], t, e, n, r, {})
    },
    select: function(t, e) {
      this.unselect(e), this.renderSelection(t), this.reportSelection(t, e)
    },
    renderSelection: function(t) {},
    reportSelection: function(t, e) {
      this.isSelected = !0, this.trigger("select", null, t.start, t.end, e)
    },
    unselect: function(t) {
      this.isSelected && (this.isSelected = !1, this.destroySelection(), this.trigger("unselect", null, t))
    },
    destroySelection: function() {},
    documentMousedown: function(e) {
      var n;
      this.isSelected && this.opt("unselectAuto") && v(e) && (n = this.opt("unselectCancel"), n && t(e.target).closest(n).length || this.unselect(e))
    },
    initHiddenDays: function() {
      var e, n = this.opt("hiddenDays") || [],
        i = [],
        r = 0;
      for (this.opt("weekends") === !1 && n.push(0, 6), e = 0; 7 > e; e++)(i[e] = -1 !== t.inArray(e, n)) || r++;
      if (!r) throw "invalid hiddenDays";
      this.isHiddenDayHash = i
    },
    isHiddenDay: function(t) {
      return e.isMoment(t) && (t = t.day()), this.isHiddenDayHash[t]
    },
    skipHiddenDays: function(t, e, n) {
      var i = t.clone();
      for (e = e || 1; this.isHiddenDayHash[(i.day() + (n ? e : 0) + 7) % 7];) i.add(e, "days");
      return i
    },
    computeDayRange: function(t) {
      var e, n = t.start.clone().stripTime(),
        i = t.end,
        r = null;
      return i && (r = i.clone().stripTime(), e = +i.time(), e && e >= this.nextDayThreshold && r.add(1, "days")), (!i || n >= r) && (r = n.clone().add(1, "days")), {
        start: n,
        end: r
      }
    },
    isMultiDayEvent: function(t) {
      var e = this.computeDayRange(t);
      return e.end.diff(e.start, "days") > 1
    }
  });
  Dt.sourceNormalizers = [], Dt.sourceFetchers = [];
  var Qt = {
      dataType: "json",
      cache: !1
    },
    Jt = 1,
    te = Tt.basic = Kt.extend({
      dayGrid: null,
      dayNumbersVisible: !1,
      weekNumbersVisible: !1,
      weekNumberWidth: null,
      headRowEl: null,
      initialize: function() {
        this.dayGrid = new $t(this), this.coordMap = this.dayGrid.coordMap
      },
      setRange: function(t) {
        Kt.prototype.setRange.call(this, t), this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit), this.dayGrid.setRange(t)
      },
      computeRange: function(t) {
        var e = Kt.prototype.computeRange.call(this, t);
        return /year|month/.test(e.intervalUnit) && (e.start.startOf("week"), e.start = this.skipHiddenDays(e.start), e.end.weekday() && (e.end.add(1, "week").startOf("week"), e.end = this.skipHiddenDays(e.end, -1, !0))), e
      },
      render: function() {
        this.dayNumbersVisible = this.dayGrid.rowCnt > 1, this.weekNumbersVisible = this.opt("weekNumbers"), this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible, this.el.addClass("fc-basic-view").html(this.renderHtml()), this.headRowEl = this.el.find("thead .fc-row"), this.scrollerEl = this.el.find(".fc-day-grid-container"), this.dayGrid.coordMap.containerEl = this.scrollerEl, this.dayGrid.el = this.el.find(".fc-day-grid"), this.dayGrid.render(this.hasRigidRows())
      },
      destroy: function() {
        this.dayGrid.destroy(), Kt.prototype.destroy.call(this)
      },
      renderHtml: function() {
        return '<table><thead><tr><td class="' + this.widgetHeaderClass + '">' + this.dayGrid.headHtml() + '</td></tr></thead><tbody><tr><td class="' + this.widgetContentClass + '"><div class="fc-day-grid-container"><div class="fc-day-grid"/></div></td></tr></tbody></table>'
      },
      headIntroHtml: function() {
        return this.weekNumbersVisible ? '<th class="fc-week-number ' + this.widgetHeaderClass + '" ' + this.weekNumberStyleAttr() + "><span>" + N(this.opt("weekNumberTitle")) + "</span></th>" : void 0
      },
      numberIntroHtml: function(t) {
        return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + "><span>" + this.calendar.calculateWeekNumber(this.dayGrid.getCell(t, 0).start) + "</span></td>" : void 0
      },
      dayIntroHtml: function() {
        return this.weekNumbersVisible ? '<td class="fc-week-number ' + this.widgetContentClass + '" ' + this.weekNumberStyleAttr() + "></td>" : void 0
      },
      introHtml: function() {
        return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + "></td>" : void 0
      },
      numberCellHtml: function(t) {
        var e, n = t.start;
        return this.dayNumbersVisible ? (e = this.dayGrid.getDayClasses(n), e.unshift("fc-day-number"), '<td class="' + e.join(" ") + '" data-date="' + n.format() + '">' + n.date() + "</td>") : "<td/>"
      },
      weekNumberStyleAttr: function() {
        return null !== this.weekNumberWidth ? 'style="width:' + this.weekNumberWidth + 'px"' : ""
      },
      hasRigidRows: function() {
        var t = this.opt("eventLimit");
        return t && "number" != typeof t
      },
      updateWidth: function() {
        this.weekNumbersVisible && (this.weekNumberWidth = h(this.el.find(".fc-week-number")))
      },
      setHeight: function(t, e) {
        var n, i = this.opt("eventLimit");
        g(this.scrollerEl), a(this.headRowEl), this.dayGrid.destroySegPopover(), i && "number" == typeof i && this.dayGrid.limitRows(i), n = this.computeScrollerHeight(t), this.setGridHeight(n, e), i && "number" != typeof i && this.dayGrid.limitRows(i), !e && f(this.scrollerEl, n) && (o(this.headRowEl, m(this.scrollerEl)), n = this.computeScrollerHeight(t), this.scrollerEl.height(n), this.restoreScroll())
      },
      setGridHeight: function(t, e) {
        e ? c(this.dayGrid.rowEls) : u(this.dayGrid.rowEls, t, !0)
      },
      renderEvents: function(t) {
        this.dayGrid.renderEvents(t), this.updateHeight()
      },
      getEventSegs: function() {
        return this.dayGrid.getEventSegs()
      },
      destroyEvents: function() {
        this.recordScroll(), this.dayGrid.destroyEvents()
      },
      renderDrag: function(t, e) {
        return this.dayGrid.renderDrag(t, e)
      },
      destroyDrag: function() {
        this.dayGrid.destroyDrag()
      },
      renderSelection: function(t) {
        this.dayGrid.renderSelection(t)
      },
      destroySelection: function() {
        this.dayGrid.destroySelection()
      }
    });
  n({
    fixedWeekCount: !0
  });
  var ee = Tt.month = te.extend({
    computeRange: function(t) {
      var e, n = te.prototype.computeRange.call(this, t);
      return this.isFixedWeeks() && (e = Math.ceil(n.end.diff(n.start, "weeks", !0)), n.end.add(6 - e, "weeks")), n
    },
    setGridHeight: function(t, e) {
      e = e || "variable" === this.opt("weekMode"), e && (t *= this.rowCnt / 6), u(this.dayGrid.rowEls, t, !e)
    },
    isFixedWeeks: function() {
      var t = this.opt("weekMode");
      return t ? "fixed" === t : this.opt("fixedWeekCount")
    }
  });
  ee.duration = {
    months: 1
  }, Tt.basicWeek = {
    type: "basic",
    duration: {
      weeks: 1
    }
  }, Tt.basicDay = {
    type: "basic",
    duration: {
      days: 1
    }
  }, n({
    allDaySlot: !0,
    allDayText: "all-day",
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    minTime: "00:00:00",
    maxTime: "24:00:00",
    slotEventOverlap: !0
  });
  var ne = 5;
  Tt.agenda = Kt.extend({
    timeGrid: null,
    dayGrid: null,
    axisWidth: null,
    noScrollRowEls: null,
    bottomRuleEl: null,
    bottomRuleHeight: null,
    initialize: function() {
      this.timeGrid = new qt(this), this.opt("allDaySlot") ? (this.dayGrid = new $t(this), this.coordMap = new It([this.dayGrid.coordMap, this.timeGrid.coordMap])) : this.coordMap = this.timeGrid.coordMap
    },
    setRange: function(t) {
      Kt.prototype.setRange.call(this, t), this.timeGrid.setRange(t), this.dayGrid && this.dayGrid.setRange(t)
    },
    render: function() {
      this.el.addClass("fc-agenda-view").html(this.renderHtml()), this.scrollerEl = this.el.find(".fc-time-grid-container"), this.timeGrid.coordMap.containerEl = this.scrollerEl, this.timeGrid.el = this.el.find(".fc-time-grid"), this.timeGrid.render(), this.bottomRuleEl = t('<hr class="' + this.widgetHeaderClass + '"/>').appendTo(this.timeGrid.el), this.dayGrid && (this.dayGrid.el = this.el.find(".fc-day-grid"), this.dayGrid.render(), this.dayGrid.bottomCoordPadding = this.dayGrid.el.next("hr").outerHeight()), this.noScrollRowEls = this.el.find(".fc-row:not(.fc-scroller *)")
    },
    destroy: function() {
      this.timeGrid.destroy(), this.dayGrid && this.dayGrid.destroy(), Kt.prototype.destroy.call(this)
    },
    renderHtml: function() {
      return '<table><thead><tr><td class="' + this.widgetHeaderClass + '">' + this.timeGrid.headHtml() + '</td></tr></thead><tbody><tr><td class="' + this.widgetContentClass + '">' + (this.dayGrid ? '<div class="fc-day-grid"/><hr class="' + this.widgetHeaderClass + '"/>' : "") + '<div class="fc-time-grid-container"><div class="fc-time-grid"/></div></td></tr></tbody></table>'
    },
    headIntroHtml: function() {
      var t, e, n, i;
      return this.opt("weekNumbers") ? (t = this.timeGrid.getCell(0).start, e = this.calendar.calculateWeekNumber(t), n = this.opt("weekNumberTitle"), i = this.opt("isRTL") ? e + n : n + e, '<th class="fc-axis fc-week-number ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + "><span>" + N(i) + "</span></th>") : '<th class="fc-axis ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + "></th>"
    },
    dayIntroHtml: function() {
      return '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + "><span>" + (this.opt("allDayHtml") || N(this.opt("allDayText"))) + "</span></td>"
    },
    slotBgIntroHtml: function() {
      return '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + "></td>"
    },
    introHtml: function() {
      return '<td class="fc-axis" ' + this.axisStyleAttr() + "></td>"
    },
    axisStyleAttr: function() {
      return null !== this.axisWidth ? 'style="width:' + this.axisWidth + 'px"' : ""
    },
    updateSize: function(t) {
      t && this.timeGrid.resize(), Kt.prototype.updateSize.call(this, t)
    },
    updateWidth: function() {
      this.axisWidth = h(this.el.find(".fc-axis"))
    },
    setHeight: function(t, e) {
      var n, i;
      null === this.bottomRuleHeight && (this.bottomRuleHeight = this.bottomRuleEl.outerHeight()), this.bottomRuleEl.hide(), this.scrollerEl.css("overflow", ""), g(this.scrollerEl), a(this.noScrollRowEls), this.dayGrid && (this.dayGrid.destroySegPopover(), n = this.opt("eventLimit"), n && "number" != typeof n && (n = ne), n && this.dayGrid.limitRows(n)), e || (i = this.computeScrollerHeight(t), f(this.scrollerEl, i) ? (o(this.noScrollRowEls, m(this.scrollerEl)), i = this.computeScrollerHeight(t), this.scrollerEl.height(i), this.restoreScroll()) : (this.scrollerEl.height(i).css("overflow", "hidden"), this.bottomRuleEl.show()))
    },
    initializeScroll: function() {
      function t() {
        n.scrollerEl.scrollTop(r)
      }
      var n = this,
        i = e.duration(this.opt("scrollTime")),
        r = this.timeGrid.computeTimeTop(i);
      r = Math.ceil(r), r && r++, t(), setTimeout(t, 0)
    },
    renderEvents: function(t) {
      var e, n, i = [],
        r = [],
        s = [];
      for (n = 0; n < t.length; n++) t[n].allDay ? i.push(t[n]) : r.push(t[n]);
      e = this.timeGrid.renderEvents(r), this.dayGrid && (s = this.dayGrid.renderEvents(i)), this.updateHeight()
    },
    getEventSegs: function() {
      return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : [])
    },
    destroyEvents: function() {
      this.recordScroll(), this.timeGrid.destroyEvents(), this.dayGrid && this.dayGrid.destroyEvents()
    },
    renderDrag: function(t, e) {
      return t.start.hasTime() ? this.timeGrid.renderDrag(t, e) : this.dayGrid ? this.dayGrid.renderDrag(t, e) : void 0
    },
    destroyDrag: function() {
      this.timeGrid.destroyDrag(), this.dayGrid && this.dayGrid.destroyDrag()
    },
    renderSelection: function(t) {
      t.start.hasTime() || t.end.hasTime() ? this.timeGrid.renderSelection(t) : this.dayGrid && this.dayGrid.renderSelection(t)
    },
    destroySelection: function() {
      this.timeGrid.destroySelection(), this.dayGrid && this.dayGrid.destroySelection()
    }
  }), Tt.agendaWeek = {
    type: "agenda",
    duration: {
      weeks: 1
    }
  }, Tt.agendaDay = {
    type: "agenda",
    duration: {
      days: 1
    }
  }, n({
    yearColumns: 2,
    fixedWeekCount: 5
  }), Tt.year = Kt.extend({
    dayNumbersVisible: !0,
    weekNumbersVisible: !1,
    weekNumberWidth: null,
    table: null,
    body: null,
    bodyRows: null,
    subTables: null,
    bodyCells: null,
    daySegmentContainer: null,
    colCnt: null,
    rowCnt: null,
    dayGrids: [],
    rtl: null,
    dis: null,
    dit: null,
    firstDay: 0,
    firstMonth: null,
    lastMonth: null,
    yearColumns: 2,
    nbMonths: null,
    hiddenMonths: [],
    nwe: null,
    tm: null,
    colFormat: null,
    dayGrid: null,
    coordMap: null,
    otherMonthDays: [],
    rowsForMonth: [],
    initialize: function() {
      this.updateOptions(), this.dayGrid = new $t(this), this.dayGrids[0] = this.dayGrid, this.coordMap = this.dayGrid.coordMap
    },
    updateOptions: function() {
      this.rtl = this.opt("isRTL"), this.rtl ? (this.dis = -1, this.dit = this.colCnt - 1) : (this.dis = 1, this.dit = 0), this.firstDay = parseInt(this.opt("firstDay"), 10), this.firstMonth = parseInt(this.opt("firstMonth"), 10) || 0, this.lastMonth = this.opt("lastMonth") || this.firstMonth + 12, this.hiddenMonths = this.opt("hiddenMonths") || [], this.yearColumns = parseInt(this.opt("yearColumns"), 10) || 2, this.colFormat = this.opt("columnFormat"), this.weekNumbersVisible = this.opt("weekNumbers"), this.nwe = this.opt("weekends") ? 0 : 1, this.tm = this.opt("theme") ? "ui" : "fc", this.nbMonths = this.lastMonth - this.firstMonth, this.lastMonth = this.lastMonth % 12, this.lang = this.opt("lang")
    },
    computeTitle: function() {
      if (null !== this.opt("yearTitleFormat")) {
        var t = this.intervalStart.locale(this.lang).format(this.opt("yearTitleFormat")),
          e = this.intervalStart.clone().add(this.nbMonths - 1, "months");
        return e.year() != this.intervalStart.year() && (t += this.intervalEnd.format(" - YYYY")), t
      }
      return this.formatRange({
        start: this.intervalStart,
        end: this.intervalEnd
      }, this.opt("titleFormat") || this.computeTitleFormat(), this.opt("titleRangeSeparator"))
    },
    render: function(t) {
      var e = Math.floor(this.intervalStart.month() / this.nbMonths) * this.nbMonths;
      !e && this.firstMonth > 0 && !this.opt("lastMonth") && (e = (this.firstMonth + e) % 12), this.intervalStart = Dt.moment([this.intervalStart.year(), e, 1]), this.intervalEnd = this.intervalStart.clone().add(this.nbMonths, "months").add(-15, "minutes"), this.start = this.intervalStart.clone(), this.start = this.skipHiddenDays(this.start), this.start.startOf("week"), this.start = this.skipHiddenDays(this.start), this.end = this.intervalEnd.clone(), this.end = this.skipHiddenDays(this.end, -1, !0), this.end.add((7 - this.end.weekday()) % 7, "days"), this.end = this.skipHiddenDays(this.end, -1, !0);
      var n = parseInt(this.opt("yearColumns"), 10),
        i = this.opt("weekends") ? 7 : 5;
      this.renderYear(n, i, !0)
    },
    renderYear: function(t, e, n) {
      this.colCnt = e;
      var i = !this.table;
      i || (this.destroyEvents(), this.table.remove()), this.buildSkeleton(this.yearColumns, n), this.buildDayGrids(), this.updateCells()
    },
    setRange: function(t) {
      Kt.prototype.setRange.call(this, t)
    },
    computeRange: function(t) {
      this.constructor.duration = {
        months: this.nbMonths || 12
      };
      var e = Kt.prototype.computeRange.call(this, t);
      return /year|month/.test(e.intervalUnit) && (e.start.startOf("week"), e.start = this.skipHiddenDays(e.start), e.end.weekday() && (e.end.add(1, "week").startOf("week"), e.end = this.skipHiddenDays(e.end, -1, !0))), e
    },
    buildSkeleton: function(e, n) {
      var i, r, s, o, a = 0,
        l = 0,
        d = this.intervalStart.year(),
        u = this.tm + "-widget-header",
        c = this.opt("dayNamesShort"),
        h = this.opt("monthNames");
      for (this.rowCnt = 0, o = '<table class="fc-year-main-table fc-border-separate" style="width:100%;"><tr>', o += '<td class="fc-year-month-border fc-first"></td>', r = 0; r < this.nbMonths; r++) {
        var f = this.intervalStart.month() + r,
          g = -1 != t.inArray(f % 12, this.hiddenMonths),
          p = g ? "display:none;" : "",
          m = Dt.moment([d + f / 12, f % 12, 1]).locale(this.lang),
          v = h[r % 12],
          y = m.format("YYYYMM");
        if (s = m.year(), this.firstMonth + this.nbMonths > 12 && (v = v + " " + s), r % e === 0 && r > 0 && !g && (l++, o += '<td class="fc-year-month-border fc-last"></td></tr><tr><td class="fc-year-month-border fc-first"></td>'), e > r % e && r % e > 0 && !g && (o += '<td class="fc-year-month-separator"></td>'), o += '<td class="fc-year-monthly-td" style="' + p + '">', o += '<div class="fc-year-monthly-name' + (0 === l ? " fc-first" : "") + '"><a name="' + y + '" data-year="' + s + '" data-month="' + f + '" href="#">' + N(v) + "</a></div>", o += '<div class="fc-row ' + u + '">', o += '<table class="fc-year-month-header"><thead><tr class="fc-year-week-days">', 0 == this.opt("isRTL"))
          for (o += this.headIntroHtml(), i = this.firstDay; i < this.colCnt + this.firstDay; i++) o += '<th class="fc-day-header fc-year-weekly-head fc-' + Gt[i % 7] + " " + u + '">' + c[i % 7] + "</th>";
        else {
          for (i = this.colCnt + this.firstDay - 1; i > this.firstDay - 1; i--) o += '<th class="fc-day-header fc-year-weekly-head fc-' + Gt[i % 7] + " " + u + '">' + c[i % 7] + "</th>";
          o += this.headIntroHtml()
        }
        o += "</tr><tr></tr></thead></table>", o += "</div>", o += '<div class="fc-day-grid-container"><div class="fc-day-grid">', o += "</div></div>", o += '<div class="fc-year-monthly-footer"></div>', o += "</td>", g && a++
      }
      o += '<td class="fc-year-month-border fc-last"></td>', o += "</tr></table>", this.table = t(o).appendTo(this.el), this.bodyRows = this.table.find(".fc-day-grid .fc-week"), this.bodyCells = this.bodyRows.find("td.fc-day"), this.bodyFirstCells = this.bodyCells.filter(":first-child"), this.subTables = this.table.find("td.fc-year-monthly-td"), this.head = this.table.find("thead"), this.head.find("tr.fc-year-week-days th.fc-year-weekly-head:first").addClass("fc-first"), this.head.find("tr.fc-year-week-days th.fc-year-weekly-head:last").addClass("fc-last"), this.table.find(".fc-year-monthly-name a").click(this.calendar, function(e) {
        e.data.changeView("month"), e.data.gotoDate([t(this).attr("data-year"), t(this).attr("data-month"), 1])
      }), this.dayBind(this.bodyCells), this.daySegmentContainer = t('<div style="position:absolute;z-index:8;top:0;left:0;"/>').appendTo(this.table)
    },
    buildDayGrids: function() {
      for (var e = this, n = [], i = 0; i < this.nbMonths; i++) n.push(i + this.intervalStart.month());
      var r = e.intervalStart.clone();
      this.firstDay;
      e.dayGrids = [], t.each(n, function(t, n) {
        var i = new $t(e),
          s = e.tableByOffset(t),
          o = r.clone().add(t, "months");
        i.headRowEl = s.find(".fc-row:first"), i.scrollerEl = s.find(".fc-day-grid-container"), i.coordMap.containerEl = i.scrollerEl, i.el = s.find(".fc-day-grid"), i.offset = t, i.rowData = [], i.colData = [];
        var a = e.computeMonthRange(o);
        i.start = a.start, i.end = a.end, i.breakOnWeeks = !0, i.updateCells(), e.dayNumbersVisible = i.rowCnt > 1, i.numbersVisible = e.dayNumbersVisible || e.weekNumbersVisible, $t.prototype.render.call(i, e.hasRigidRows()), e.dayGrids.push(i)
      }), e.dayGrid = e.dayGrids[0], e.coordMap = e.dayGrid.coordMap
    },
    isFixedWeeks: function() {
      var t = this.opt("weekMode");
      return t ? "fixed" === t : this.opt("fixedWeekCount")
    },
    computeMonthRange: function(t) {
      var e = this.firstDay;
      this.constructor.duration = {
        months: 1
      };
      var n = Kt.prototype.computeRange.call(this, t);
      if (/year|month/.test(n.intervalUnit)) {
        n.start.startOf("week"), n.start = this.skipHiddenDays(n.start), n.start.day(e), n.end.day(e), n.start.date() > 1 && n.start.date() <= 7 && n.start.subtract(7, "days");
        var i = Math.ceil(n.end.diff(n.start, "weeks", !0));
        5 === this.isFixedWeeks() ? 4 == i && n.end.add(1, "weeks") : this.isFixedWeeks() && 6 >= i && n.end.add(6 - i, "weeks")
      }
      return n
    },
    destroy: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroy()
      }), Kt.prototype.destroy.call(this)
    },
    updateCells: function() {
      var n = this;
      this.subTables.find(".fc-week:first").addClass("fc-first"), this.subTables.find(".fc-week:last").addClass("fc-last"), this.subTables.find(".fc-bg").find("td.fc-day:last").addClass("fc-last"), this.subTables.each(function(i, r) {
        n.curYear || (n.curYear = n.intervalStart);
        var s = n.curYear.clone(),
          o = (i + n.intervalStart.month()) % 12;
        s = n.dayGrids[i].start;
        var a = 0;
        t(r).find(".fc-bg").find("td.fc-day:first").addClass("fc-first"), n.otherMonthDays[o] = [0, 0, 0, 0], t(r).find(".fc-content-skeleton tr").each(function(n, r) {
          t(r).find("td").not(".fc-week-number").each(function(n, r) {
            var s = t(r),
              o = e(s.attr("data-date"));
            o.month() != i ? (s.addClass("fc-other-month"), o.month() == i ? s.addClass("fc-prev-month") : s.addClass("fc-next-month")) : a = o
          })
        })
      }), n.bodyRows.filter(".fc-year-have-event").removeClass("fc-year-have-event")
    },
    headIntroHtml: function() {
      var t = null != this.opt("weekNumberTitle") ? this.opt("weekNumberTitle").substring(0, 1) : "";
      return this.weekNumbersVisible ? '<th class="fc-week-number-head ' + this.widgetHeaderClass + '"><span>' + N(t) + "</span></th>" : ""
    },
    numberIntroHtml: function(t, e) {
      if (this.weekNumbersVisible) {
        e = e || this.dayGrid;
        var n;
        return n = 0 == this.opt("isRTL") ? this.calendar.calculateWeekNumber(e.getCell(t, 0).start) : this.calendar.calculateWeekNumber(e.getCell(t, 6).start), '<td class="fc-week-number" ' + this.weekNumberStyleAttr("") + "><span>" + n + "</span></td>"
      }
      return ""
    },
    dayIntroHtml: function() {
      return this.weekNumbersVisible ? '<td class="fc-week-number ' + this.widgetContentClass + '" ' + this.weekNumberStyleAttr("") + "></td>" : ""
    },
    introHtml: function() {
      return this.weekNumbersVisible ? '<td class="fc-week-number" ' + this.weekNumberStyleAttr("") + "></td>" : ""
    },
    weekNumberStyleAttr: function() {
      var t = "";
      return null !== this.weekNumberWidth && (t = 'style="width:' + this.weekNumberWidth + 'px;"'), t
    },
    numberCellHtml: function(t) {
      if (!this.dayNumbersVisible) return "<td/>";
      var e = t.start,
        n = this.dayGrid.getDayClasses(e);
      return n.unshift("fc-day-number"), '<td class="' + n.join(" ") + '" data-date="' + e.format() + '">' + e.date() + "</td>"
    },
    hasRigidRows: function() {
      var t = this.opt("eventLimit");
      return t && "number" != typeof t
    },
    cellsForMonth: function(t) {
      return this.rowsForMonth[t] * (this.nwe ? 5 : 7)
    },
    addDays: function(t, e) {
      t.add(e, "days")
    },
    skipWeekend: function(t, e, n) {
      for (e = e || 1; !t.day() || n && 1 == t.day() || !n && 6 == t.day();) this.addDays(t, e);
      return t
    },
    daysInMonth: function(t, e) {
      return Dt.moment([t, e, 0]).date()
    },
    dateInMonth: function(t, e) {
      return t.month() == e % 12
    },
    rowToGridOffset: function(t) {
      for (var e = 0, n = this.firstMonth; n < this.lastMonth; n++)
        if (e += this.rowsForMonth[n], e > t) return n - this.firstMonth;
      return -1
    },
    rowToGridRow: function(t) {
      for (var e = 0, n = this.firstMonth; n < this.lastMonth; n++)
        if (e += this.rowsForMonth[n], e > t) return t - (e - this.rowsForMonth[n]);
      return -1
    },
    tableByOffset: function(e) {
      return t(this.subTables[e])
    },
    setGridHeight: function(e, n, i) {
      return "undefined" != typeof i ? void(n ? c(i.rowEls) : u(i.rowEls, e, !0)) : void t.each(this.dayGrids, function(t, i) {
        n ? c(i.rowEls) : u(i.rowEls, e, !0)
      })
    },
    computeScrollerHeight: function(t, e) {
      var n, i;
      e = e || this.scrollerEl;
      var r = e.closest(".fc-year-monthly-td");
      return n = r.add(e), n.css({
        position: "relative",
        left: -1
      }), i = r.outerHeight() - e.height(), n.css({
        position: "",
        left: ""
      }), t - i
    },
    setHeight: function(e, n) {
      var i, r = this,
        s = this.opt("eventLimit");
      t.each(this.dayGrids, function(t, l) {
        l.el.length > 0 && (g(l.scrollerEl), a(l.headRowEl), l.destroySegPopover(), s && "number" == typeof s && l.limitRows(s), i || (i = r.computeScrollerHeight(e, l.scrollerEl)), r.setGridHeight(i, n, l), s && "number" != typeof s && l.limitRows(s), !n && f(l.scrollerEl, i) && (o(l.headRowEl, m(l.scrollerEl)),
          i = r.computeScrollerHeight(e, l.scrollerEl), l.scrollerEl.height(i), r.restoreScroll()))
      })
    },
    updateWidth: function() {
      this.weekNumbersVisible && (this.weekNumberWidth = h(this.el.find(".fc-week-number")), this.weekNumberWidth && this.el.find(".fc-week-number-head").width(this.weekNumberWidth + 2))
    },
    updateHeight: function() {
      var t = this.calendar;
      if (this.yearColumns > 0) {
        var e = t.getSuggestedViewHeight() * (1.1 / (.01 + this.yearColumns));
        this.setHeight(e, t.isHeightAuto())
      }
    },
    dayBind: function(t) {
      t.click(this.dayClick)
    },
    dayClick: function(e) {
      if (!this.opt("selectable")) {
        var n = this.className.match(/fc\-day\-(\d+)\-(\d+)\-(\d+)/),
          i = new Date(n[1], n[2] - 1, n[3]);
        t.trigger("dayClick", this, Dt.moment(i), !0, e)
      }
    },
    renderEvents: function(e) {
      t.each(this.dayGrids, function(t, n) {
        n.renderEvents(e)
      }), this.updateHeight()
    },
    getEventSegs: function() {
      var e = [];
      return t.each(this.dayGrids, function(t, n) {
        for (var i = n.getEventSegs(), r = 0; r < i.length; r++) e.push(i[r])
      }), e
    },
    destroyEvents: function() {
      this.recordScroll(), t.each(this.dayGrids, function(t, e) {
        e.destroyEvents()
      })
    },
    renderDrag: function(e, n) {
      var i = !1;
      return t.each(this.dayGrids, function(t, i) {
        i.renderDrag(e, n)
      }), i
    },
    destroyDrag: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroyDrag()
      })
    },
    renderSelection: function(e, n) {
      t.each(this.dayGrids, function(t, i) {
        i !== n && (i.start <= e.end || i.end >= e.start) && i.renderSelection(e)
      })
    },
    destroySelection: function() {
      t.each(this.dayGrids, function(t, e) {
        e.destroySelection()
      })
    }
  })
});
/*! RESOURCE: /scripts/reportcommon/report_includes_hardcoded_defaults.js */
var chartHelpers = window.chartHelpers || {};
chartHelpers.i18n = chartHelpers.i18n || {};
chartHelpers.i18n.building = 'Building chart, please wait...';
chartHelpers.i18n.total = 'Total';
chartHelpers.i18n.maxCells = 'The size of the pivot table is too big. Use filters to reduce it or switch to a modern browser.';
chartHelpers.i18n.chartGenerationError = 'An error occurred while generating chart. Please try again later.';
chartHelpers.i18n.showAsHeatmap = 'Show data as a heatmap visualization';
chartHelpers.i18n.showAsMarkers = 'Show data using latitude and longitude';
chartHelpers.i18n.highlightBasedOn = 'Highlight based on:';
chartHelpers.i18n.isRTL = false;
chartHelpers.i18n.weekNumberTitle = 'Week';
chartHelpers.i18n.weekNumberTitleShort = 'W';
chartHelpers.i18n.seeMoreEvents = 'See {0} more events';
chartHelpers.i18n.viewEventsInList = 'View {0} events in a list';
chartHelpers.i18n.viewAllEventsInList = 'View all events in a list';
chartHelpers.i18n.viewAllRecords = 'View all records';
chartHelpers.i18n.none = 'None';
chartHelpers.i18n.plusMany = '+ many';
chartHelpers.i18n.plusMore = '+ {0} more';
chartHelpers.i18n.buttonText = {
  prevYear: '',
  nextYear: '',
  today: 'today',
  year: 'year',
  month: 'month',
  week: 'week',
  day: 'day'
};
chartHelpers.i18n.allDayHtml = 'all-day';
chartHelpers.i18n.daysNames = [
  'Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday'
];
chartHelpers.i18n.dayNamesShort = [
  'Sun',
  'Mon',
  'Tue',
  'Wed',
  'Thu',
  'Fri',
  'Sat'
];
chartHelpers.i18n.monthNames = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December'
];
chartHelpers.i18n.monthNamesShort = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
];
chartHelpers.i18n.none = '-- None --';
chartHelpers.i18n.groupBy = 'Group by';
chartHelpers.i18n.groupByTitle = 'Select a different group by field';
chartHelpers.i18n.stackBy = 'Stacked by';
chartHelpers.i18n.stackByTitle = 'Select a different stacked by field';
chartHelpers.i18n.saveAsJpg = 'Save as JPEG';
chartHelpers.i18n.saveAsPng = 'Save as PNG';
chartHelpers.device = {};
chartHelpers.device.type = 'doctype';
chartHelpers.systemParams = {
  firstDay: 1,
  defaultDate: '2017-01-01',
  maxEventsDisplayedPerCell: 3,
  maxMoreEventsPerDay: 30,
  defaultEventDuration: '01:00:00',
  maxDaysBack: 30,
  enablePreviewOnHover: false,
  isCalendarV2Enabled: true,
  fixedHeaders: true,
  slotEventOverlap: false
};;
/*! RESOURCE: /scripts/reportcommon/chart-helpers.js */
var chartHelpers = window.chartHelpers || {};
chartHelpers.objectSize = function objectSize(obj) {
  var size = 0;
  var key;
  for (key in obj)
    if (obj.hasOwnProperty(key))
      size++;
  return size;
};
chartHelpers.compareByProperty = function compareByProperty(property, desc) {
  return function propertyCompare(a, b) {
    if (a[property] > b[property])
      return desc ? -1 : 1;
    if (a[property] < b[property])
      return desc ? 1 : -1;
    return 0;
  };
};
chartHelpers.evaluateColorRules = function evaluateColorRules(score, rules) {
  if (typeof score !== 'undefined' && score !== null && score !== '' && rules) {
    rules.sort(chartHelpers.compareByProperty('ruleOrder', true));
    var operate = {
      '<': function lessThan(x, y) {
        return x < y;
      },
      '<=': function lessThanEqual(x, y) {
        return x <= y;
      },
      '=': function Equal(x, y) {
        return x === y;
      },
      '>=': function greaterThanEqual(x, y) {
        return x >= y;
      },
      '>': function greaterThan(x, y) {
        return x > y;
      },
      between: function between(x, y, z) {
        return x > y && x < z;
      }
    };
    for (var i = 0; i < rules.length; i++)
      if (operate[rules[i].operator](score, rules[i].value1, rules[i].value2))
        return {
          color: rules[i].color,
          bgColor: rules[i].bgColor
        };
  }
  return '';
};
chartHelpers.hexEncode = function(utf8String) {
  var hex;
  var i;
  var result = '';
  for (i = 0; i < utf8String.length; i++) {
    hex = utf8String.charCodeAt(i).toString(16);
    result += '\\u' + ('000' + hex).slice(-4);
  }
  return result;
};;
/*! RESOURCE: /scripts/reportcommon/display_grid.js */
function checkAndEnableDisplayGrid(chartData, args) {
  args.otherDisplay = 'Other';
  args.otherDisplayMore = '(more...)';
  if ('report_properties' in chartData) {
    args.otherDisplay = chartData.report_properties.other_display;
    args.otherDisplayMore = chartData.report_properties.other_display_more;
  }
  var $gridTable = getGridTable(args);
  var hasData = (chartData.series[0].xvalues && chartData.series[0].xvalues.length) || args.chart_type === 'solid_gauge' || args.chart_type === 'angular_gauge';
  if ($gridTable.length && hasData) {
    $gridTable.attr({
      tabindex: '0',
    });
    $gridTable.html('<thead>' +
      '<tr class="header display_grid_header">' +
      '</tr>' +
      '</thead>' +
      '<tbody class="display_grid_body"/>');
    enableDisplayGrid($gridTable, chartData, args);
  } else
    $gridTable.empty();
}

function enableDisplayGrid($gridTable, chartData, args) {
  if (args.chart_type === 'box' || args.chart_type === 'tbox')
    createBoxDisplayGrid($gridTable, chartData);
  else if (args.chart_type === 'control')
    showControlDisplayGrid($gridTable, chartData);
  else if (args.chart_type === 'solid_gauge' || args.chart_type === 'angular_gauge')
    createGaugeDisplayGrid($gridTable, chartData);
  else
    showDisplayGrid($gridTable, chartData, isTwoLevelDisplayGrid(args), args);
  if (args.display_grid)
    $gridTable.show();
  else
    $gridTable.hide();
  addAccessibility($gridTable, chartData, args);
}

function showDisplayGrid($gridTable, chartData, hasStacking, args) {
  var otherKey = 'zzyynomatchaabb';
  var $gridTableBody = getGridTableBody($gridTable);
  var yDispValsExist = false;
  if (chartData.series.length) {
    var seriesData = chartData.series[0];
    if ('ydisplayvalues' in seriesData && seriesData.ydisplayvalues !== '')
      yDispValsExist = true;
    var trClass = 'odd';
    var omitOther = false;
    if ('display_grid_xvalues' in seriesData)
      omitOther = true;
    if (seriesData.xvalues !== undefined && seriesData.xvalues.length) {
      createBasicDisplayGridHeader($gridTable, seriesData, chartData.report_properties.percents_from_count, hasStacking);
      var multipleOther = false;
      for (var j = 0; j < seriesData.xvalues.length; j++) {
        var value = seriesData.xvalues[j];
        if (value === otherKey && omitOther)
          if (j === seriesData.xvalues.length - 1)
            break;
        if (value === args.otherDisplay && j < seriesData.xvalues.length - 1)
          multipleOther = true;
        if (value === otherKey) {
          if (multipleOther)
            value = args.otherDisplay + ' ' + args.otherDisplayMore;
          else
            value = args.otherDisplay;
        }
        if (yDispValsExist)
          var yVal = seriesData.ydisplayvalues[j];
        else
          yVal = seriesData.yvalues[j];
        if (yVal) {
          var row = createRowForGrid(trClass, value, yVal, seriesData.percentages[j], hasStacking);
          if (trClass === 'odd')
            trClass = 'even';
          else
            trClass = 'odd';
          $gridTableBody.append(row);
        }
      }
      if ('display_grid_xvalues' in seriesData) {
        var additionalGridYDispValsExist = false;
        if ('display_grid_ydisplayvalues' in seriesData)
          additionalGridYDispValsExist = true;
        for (j = 0; j < seriesData.display_grid_xvalues.length; j++) {
          value = seriesData.display_grid_xvalues[j];
          yVal = null;
          if (additionalGridYDispValsExist)
            yVal = seriesData.display_grid_ydisplayvalues[j];
          else
            yVal = seriesData.display_grid_yvalues[j];
          if (yVal) {
            row = createRowForGrid(trClass, value, yVal, seriesData.display_grid_percents[j], hasStacking);
            if (trClass === 'odd')
              trClass = 'even';
            else
              trClass = 'odd';
            $gridTableBody.append(row);
          }
        }
      }
      if (hasStacking)
        createTwoLevelDisplayGridTable(chartData, args, $gridTableBody);
      displayGridTotal($gridTableBody, seriesData.display_grid_total, seriesData.total_label, hasStacking);
    }
  }
}

function addAccessibility($gridTable, chartData, args) {
  if (window.g_accessibility === 'true' || window.g_accessibility === true) {
    var $displayGridToggle = getGridExpandAnchor(args);
    var id = $gridTable.attr('id');
    if ($displayGridToggle.length)
      $displayGridToggle.remove();
    $displayGridToggle = jQuery('<a tabindex="0" id="expand.' + id + '" aria-expanded="false" role="button" class="grid-toggle" onkeypress="javascript: if(event.keyCode == 32) toggleDisplayGrid(\'' + id + '\', this);" onclick="toggleDisplayGrid(\'' + id + '\', this)">' +
      '<img title="Chart data" src="images/section_hide.gifx" alt="Chart data" width="16px" />' +
      '</a>');
    $gridTable.before($displayGridToggle);
    if (args.display_grid) {
      $displayGridToggle.attr('aria-expanded', true);
      $displayGridToggle.children().attr('src', 'images/section_reveal.gifx');
    }
    $gridTable.prepend('<caption><b></b></caption>');
    $gridTable.find('caption b').text(chartData.series[0].display_grid_title);
  }
}

function createTwoLevelDisplayGridTable(chartData, args, $body) {
  var additionalGridValuesExist = false;
  var seriesData = chartData.series[0];
  var subSeriesData = chartData.series[0].sub_series;
  if (subSeriesData && subSeriesData[0]) {
    createSecondLevelHeader($body, seriesData, chartData.report_properties.percents_from_count);
    if ('display_grid_xvalues' in seriesData && 'dispGridSubSeries' in seriesData)
      additionalGridValuesExist = true;
    var isDuration = false;
    if (('yaxis_duration' in seriesData) && (seriesData.yaxis_duration))
      isDuration = true;
    createSecondLevelDisplayGrid(seriesData.xvalues, subSeriesData, isDuration, $body, args, additionalGridValuesExist);
    if (additionalGridValuesExist) {
      var dispGridSubSeries = chartData.series[0].dispGridSubSeries;
      createSecondLevelDisplayGrid(seriesData.display_grid_xvalues, dispGridSubSeries, isDuration, $body, args, additionalGridValuesExist);
    }
  }
}

function createSecondLevelDisplayGrid(xValues, subSeriesData, isDuration, $body, args, additionalGridValuesExist) {
  var otherKey = 'zzyynomatchaabb';
  var trClass = 'even';
  var multipleOther = false;
  for (var i = 0; i < subSeriesData.length; i++) {
    var firstLevelXVal = xValues[i];
    if (additionalGridValuesExist && firstLevelXVal === otherKey) {
      continue;
    }
    if (!additionalGridValuesExist) {
      if (firstLevelXVal === args.otherDisplay && i < xValues.length - 1)
        multipleOther = true;
      if (firstLevelXVal === otherKey) {
        if (multipleOther)
          firstLevelXVal = args.otherDisplay + ' ' + args.otherDisplayMore;
        else
          firstLevelXVal = args.otherDisplay;
      }
    }
    var curSubSeries = subSeriesData[i];
    if (curSubSeries) {
      var curSubSeriesHasYDispVals = false;
      if ('ydisplayvalues' in curSubSeries && curSubSeries.ydisplayvalues !== '')
        curSubSeriesHasYDispVals = true;
      for (var j = 0; j < curSubSeries.xvalues.length; j++) {
        var row = document.createElement('tr');
        row.className = trClass;
        var chartClass = 'chart';
        if (j === (curSubSeries.xvalues.length - 1))
          chartClass = 'chart-spacer';
        if (j === 0)
          row.appendChild(createDisplayGridHeaderCell('chart-spacer', firstLevelXVal, null, null, null, curSubSeries.xvalues.length));
        xValue = curSubSeries.xvalues[j].displayValue;
        if (xValue === undefined)
          xValue = curSubSeries.xvalues[j];
        row.appendChild(createDisplayGridCell(chartClass, xValue));
        if (curSubSeriesHasYDispVals)
          row.appendChild(createDisplayGridCell(chartClass, curSubSeries.ydisplayvalues[j], 'right'));
        else
          row.appendChild(createDisplayGridCell(chartClass, curSubSeries.yvalues[j], 'right'));
        row.appendChild(createDisplayGridCell(chartClass, curSubSeries.percentages[j] + '%', 'right'));
        if (trClass === 'odd')
          trClass = 'even';
        else
          trClass = 'odd';
        $body.append(row);
      }
    }
    trClass = 'even';
  }
}

function createBasicDisplayGridHeader($table, series, computePercent, hasStacking) {
  var $header = getGridTableHeader($table);
  var totals = '';
  var colSpan = 1;
  if (hasStacking) {
    totals = ' ' + series.totals_label;
    colSpan = 2;
  }
  $header.append(createDisplayGridHeaderCell('chart', series.group_by_label + totals, null, true, colSpan))
    .append(createDisplayGridHeaderCell('chart', series.yTitle + totals, 'right', true));
  var percentLabel = series.percentage_label + series.aggregate_label;
  if (computePercent || isPieType(series.series_plot_type))
    percentLabel = series.percentage_label + series.table_display_plural;
  $header.append(createDisplayGridHeaderCell('chart', percentLabel, 'right', true));
  series.completePercentLabel = percentLabel;
}

function createSecondLevelHeader($body, series) {
  var $secondHeader = jQuery('<tr class="header display_grid_header"/>');
  $body.append($secondHeader);
  $secondHeader.append(createDisplayGridHeaderCell('chart', series.group_by_label, null, true))
    .append(createDisplayGridHeaderCell('chart', series.second_group_by_label, null, true))
    .append(createDisplayGridHeaderCell('chart', series.yTitle, 'right', true))
    .append(createDisplayGridHeaderCell('chart', series.completePercentLabel, 'right', true));
}

function createBoxDisplayGrid($gridTable, chartData) {
  if (chartData.series.length > 0) {
    var $gridTableBody = getGridTableBody($gridTable);
    var seriesData = chartData.series[0];
    var trClass = 'odd';
    var $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.group_by_label, null, true))
      .append(createDisplayGridHeaderCell('chart', seriesData.mean_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.minimum_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.first_quartile_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.median_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.third_quartile_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.maximum_label, 'right', true));
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      var row = document.createElement('tr');
      row.className = trClass;
      var value = seriesData.xvalues[j];
      var style = 'chart';
      var groupByStyle = 'chart';
      row.appendChild(createDisplayGridHeaderCell(groupByStyle, value));
      row.appendChild(createDisplayGridCell(style, seriesData.ydisplayvalues[j], 'right'));
      var boxDisplayVals = seriesData.boxdisplayvalues[j];
      for (var k = 0; k < 5; k++)
        row.appendChild(createDisplayGridCell(style, boxDisplayVals[k], 'right'));
      if (trClass === 'odd')
        trClass = 'even';
      else
        trClass = 'odd';
      $gridTableBody.append(row);
    }
  }
}

function showControlDisplayGrid($gridTable, chartData) {
  var $gridTableBody = getGridTableBody($gridTable);
  var isDuration = false;
  if (chartData.series.length > 0) {
    var seriesData = chartData.series[0];
    if (('yaxis_duration' in seriesData) && (seriesData.yaxis_duration))
      isDuration = true;
    var $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.group_by_label + ' ' + seriesData.per + ' ' + seriesData.trend, null, true))
      .append(createDisplayGridHeaderCell('chart', seriesData.aggregate_label + ' ' + seriesData.data_points_label, 'right', true))
      .append(createDisplayGridHeaderCell('chart', seriesData.aggregate_label + ' ' + seriesData.trend_line_label, 'right', true));
    var trClass = 'odd';
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      row = document.createElement('tr');
      row.className = trClass;
      var style = 'chart';
      row.appendChild(createDisplayGridCell(style, seriesData.xvalues[j]));
      row.appendChild(createDisplayGridCell(style, seriesData.ydisplayvalues[j], 'right'));
      row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.trenddisplayvalues[j] : seriesData.trendvalues[j], 'right'));
      $gridTableBody.append(row);
      if (trClass === 'odd')
        trClass = 'even';
      else
        trClass = 'odd';
    }
    var row = document.createElement('tr');
    row.className = 'header display_grid_header';
    row.appendChild(createDisplayGridHeaderCell(style, 'Control Values'));
    row.appendChild(createDisplayGridHeaderCell(style, seriesData.aggregate_label, 'right'));
    row.appendChild(createDisplayGridHeaderCell(style, ''));
    $gridTableBody.append(row);
    var standDev = seriesData.standard_deviation_label;
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, '-3 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[0] : seriesData.controlvalues[0], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'even';
    row.appendChild(createDisplayGridCell(style, '-2 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[1] : seriesData.controlvalues[1], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, seriesData.mean_label));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[2] : seriesData.controlvalues[2], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'even';
    row.appendChild(createDisplayGridCell(style, '+2 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[3] : seriesData.controlvalues[3], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    $gridTableBody.append(row);
    row = document.createElement('tr');
    row.className = 'odd';
    row.appendChild(createDisplayGridCell(style, '+3 ' + standDev));
    row.appendChild(createDisplayGridCell(style, isDuration === true ? seriesData.controldisplayvalues[4] : seriesData.controlvalues[4], 'right'));
    row.appendChild(createDisplayGridCell(style, ''));
    $gridTableBody.append(row);
  }
}

function createGaugeDisplayGrid($gridTable, chartData) {
  if (chartData.series.length) {
    var seriesData = chartData.series[0];
    var $gridTableBody = getGridTableBody($gridTable);
    var yDispValsExist;
    var $header = getGridTableHeader($gridTable);
    $header.append(createDisplayGridHeaderCell('chart', seriesData.yTitle, 'center', true));
    if ('ydisplayvalues' in seriesData && seriesData.ydisplayvalues !== '')
      yDispValsExist = true;
    var row = document.createElement('tr');
    row.className = 'odd';
    var style = 'chart';
    var value;
    if (yDispValsExist)
      value = seriesData.ydisplayvalues;
    else
      value = seriesData.yvalues;
    row.appendChild(createDisplayGridCell(style, value, 'center'));
    $gridTableBody.append(row);
  }
}

function displayGridTotal($body, total, totalLabel, hasStacking) {
  var $totalRow = jQuery('<tr class="display-grid-total-row" />');
  $body.append($totalRow);
  var colSpan = 1;
  if (hasStacking)
    colSpan = 2;
  $totalRow.append(createDisplayGridHeaderCell('chart_total', totalLabel, null, null, colSpan))
    .append(createDisplayGridCell('chart_total', total, 'right'))
    .append(createDisplayGridCell('chart_total', '100%', 'right'));
}

function createRowForGrid(trClass, xVal, yVal, percent, hasStacking) {
  var row = document.createElement('tr');
  row.className = trClass;
  var style = 'chart';
  var groupByStyle = 'chart';
  var colSpan = 1;
  if (hasStacking) {
    xVal += ' Total';
    style = 'chart_subtotal';
    groupByStyle = 'chart_subtotal_text';
    colSpan = 2;
  }
  row.appendChild(createDisplayGridHeaderCell(groupByStyle, xVal, null, null, colSpan));
  row.appendChild(createDisplayGridCell(style, yVal, 'right'));
  if (percent && percent !== '')
    row.appendChild(createDisplayGridCell(style, percent + '%', 'right'));
  else
    row.appendChild(createDisplayGridCell(style, 'N/A', 'right'));
  return row;
}

function createDisplayGridHeaderCell(cssClass, value, alignment, isHead, colSpan, rowSpan) {
  var gridCell = document.createElement('th');
  var scope = 'row';
  if (isHead) {
    scope = 'col';
  }
  gridCell.setAttribute('scope', scope);
  createDisplayGridCellCommon(gridCell, cssClass, value, alignment, colSpan, rowSpan);
  return gridCell;
}

function createDisplayGridCell(cssClass, value, alignment) {
  var gridCell = document.createElement('td');
  createDisplayGridCellCommon(gridCell, cssClass, value, alignment);
  return gridCell;
}

function createDisplayGridCellCommon(gridCell, cssClass, value, alignment, colSpan, rowSpan) {
  gridCell.className = cssClass;
  gridCell.style.textAlign = 'left';
  if (alignment)
    gridCell.style.textAlign = alignment;
  if (colSpan)
    gridCell.setAttribute('colspan', colSpan);
  if (rowSpan)
    gridCell.setAttribute('rowspan', rowSpan);
  gridCell.appendChild(document.createTextNode(value));
}

function isDisplayGridApplicable(chartType) {
  if (chartType === 'bar' || chartType === 'horizontal_bar' || isPieType(chartType) || chartType === 'line_bar' || chartType === 'line' || chartType === 'step_line' || chartType === 'area' || chartType === 'spline' || chartType === 'availability' || chartType === 'pareto' || chartType === 'trend' || chartType === 'map' || chartType === 'solid_gauge' ||
    chartType === 'angular_gauge')
    return true;
  return false;
}

function getGridTable(args) {
  return jQuery('#display-grid-table-' + args.report_uuid);
}

function getGridTableHeader($table) {
  return $table.find('.display_grid_header');
}

function getGridTableBody($table) {
  return $table.children('.display_grid_body');
}

function getGridExpandAnchor(args) {
  return jQuery('#expand\\.display_grid_table' + args.report_uuid);
}

function isTwoLevelDisplayGrid(args) {
  if ((args.stacked_field !== '' && isBarType(args.chart_type)))
    return true;
  if (args.group_by !== '' && (args.chart_type === 'trend' || args.chart_type === 'line' || args.chart_type === 'step_line' || args.chart_type === 'area' || args.chart_type === 'spline' || args.chart_type === 'line_bar'))
    return true;
  return false;
}

function toggleDisplayGrid(name, anchor) {
  var el = jQuery('#' + name);
  if (!el)
    return;
  var anchorEl = jQuery(anchor);
  if (anchorEl.attr('aria-expanded') === 'true') {
    el.hide();
    anchorEl.children().attr('src', 'images/section_hide.gifx');
    anchorEl.attr('aria-expanded', false);
  } else {
    el.show();
    anchorEl.children().attr('src', 'images/section_reveal.gifx');
    anchorEl.attr('aria-expanded', true);
  }
};
/*! RESOURCE: /scripts/reportcommon/additional_groupby.js */
function hasAdditionalGroupBy(type) {
  return !(type === 'hist' || type === 'pivot' || type === 'heatmap' || type === 'pivot_v2' || type === 'calendar' || type === 'control' || type === 'availability' || type === 'angular_gauge' || type === 'solid_gauge' || type === 'gauge' || type === 'single_score' || type === 'map');
}

function checkAndEnableInteractiveFilters(chartData, args) {
  var isMultiSeries = false;
  if ('report_properties' in chartData)
    isMultiSeries = chartData.series.length > 1;
  var $interactiveContainer = jQuery('#interactive-container-' + args.report_uuid);
  var msgIntoAdditionalGroupByPopup = document.getElementById('msg_additional_group_by');
  if (isMultiSeries) {
    if ($interactiveContainer.length)
      $interactiveContainer.hide();
    if (msgIntoAdditionalGroupByPopup)
      msgIntoAdditionalGroupByPopup.show();
  } else {
    if (msgIntoAdditionalGroupByPopup)
      msgIntoAdditionalGroupByPopup.hide();
    if ($interactiveContainer.length)
      constructInteractiveFilters(chartData.series[0].additional_groupby, args, $interactiveContainer);
  }
}

function constructInteractiveFilters(additionalGroupBy, args, $interactiveContainer) {
  var $stackBySelect;
  $interactiveContainer.append(
    '<div class="additional-groupby-label">' +
    '<label for="additional-groupby-' + args.report_uuid + '" id="additional-groupby-label" title="' + window.chartHelpers.i18n.groupByTitle + '">' +
    window.chartHelpers.i18n.groupBy +
    '</label>' +
    '</div>');
  var $groupByContainer = jQuery('<div class="additional-groupby-select"/>');
  $interactiveContainer.append($groupByContainer);
  var $groupBySelect = jQuery('<select id="additional-groupby-' + args.report_uuid + '" name="additional-groupby" class="interactive"/>');
  createAdditionalOptions($groupBySelect, additionalGroupBy.list, additionalGroupBy.original_group_by, additionalGroupBy.original_stack_by, args.group_by, hasNone(args.chart_type));
  if (isBarType(args.chart_type)) {
    var originalGroupBy = additionalGroupBy.original_group_by_can_be_stacked ? additionalGroupBy.original_group_by : null;
    $stackBySelect = jQuery('<select id="additional-stackby-' + args.report_uuid + '" name="additional-stackby" class="interactive"/>');
    createAdditionalOptions($stackBySelect, additionalGroupBy.stackby_list, additionalGroupBy.original_stack_by, originalGroupBy, args.stacked_field, true);
  }
  $groupBySelect.change(function groupBySelectChangeCallback() {
    applyExecutiveReport(args.report_id, $groupBySelect, $stackBySelect, JSON.parse(args.chart_params).interactive_filter);
  });
  $groupByContainer.append($groupBySelect);
  if ($stackBySelect) {
    $interactiveContainer.append(
      '<div class="additional-stackby-label">' +
      '<label for="additional-stackby-' + args.report_uuid + '" id="additional-stackby-label" title="' + window.chartHelpers.i18n.stackByTitle + '">' +
      window.chartHelpers.i18n.stackBy +
      '</label>' +
      '</div>');
    var $stackByContainer = jQuery('<div class="additional-groupby-select"/>');
    $interactiveContainer.append($stackByContainer);
    $stackBySelect.change(function stackBySelectChangeCallback() {
      applyExecutiveReport(args.report_id, $groupBySelect, $stackBySelect, JSON.parse(args.chart_params).interactive_filter);
    });
    $stackByContainer.append($stackBySelect);
  }
}

function createAdditionalOptions($select, choices, originalGrouping, otherGrouping, selectedValue, hasNoneOption) {
  var option;
  if (hasNoneOption) {
    option = new Option(window.chartHelpers.i18n.none, '');
    $select.append(jQuery(option));
  }
  if (originalGrouping) {
    option = new Option(originalGrouping.label, originalGrouping.value);
    $select.append(jQuery(option));
  }
  for (var i = 0; i < choices.length; ++i) {
    option = new Option(choices[i].label, choices[i].value);
    $select.append(jQuery(option));
  }
  if (otherGrouping && !$select.children('option[value=\'' + otherGrouping.value + '\']').length) {
    option = new Option(otherGrouping.label, otherGrouping.value);
    $select.append(jQuery(option));
  }
  if (selectedValue === 'variables')
    $select.val($select.children()[0].value);
  else
    $select.val(selectedValue);
}

function hasNone(type) {
  return type === 'list' || type === 'bubble' || type === 'trend' || type === 'line' || type === 'step_line' || type === 'line_bar' || type === 'area' || type === 'spline';
};
/*! RESOURCE: /scripts/reportcommon/buildhcoptions.js */
function hc_configureChartProportions(chartType, chartData, hcOptions, isGauge, isUI) {
  hc_configureLegendAlignment(chartType, chartData.report_properties, hcOptions, isGauge, isUI);
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.plotOptions.column = {};
    var closestPointRange = hc_differenceOfClosestStringDateTimesInSeries(chartData.series[0].xvalues);
    if (closestPointRange !== 0)
      hcOptions.plotOptions.column.pointRange = closestPointRange;
  }
}

function hc_configureLegendAlignment(chartType, reportProperties, hcOptions, isGauge, isUI) {
  var legendVerticalAlign = reportProperties.legend_vertical_alignment;
  var legendHorizontalAlign = reportProperties.legend_horizontal_alignment;
  var legendItemsLeftAlign = reportProperties.legend_items_left_align;
  var hasLegend = hcOptions.legend.enabled;
  var titleVerticalAlign = reportProperties.title_vertical_alignment;
  var showChartTitle = !reportProperties.custom_chart_title_position && (reportProperties.show_chart_title === 'always' || (!isGauge && reportProperties.show_chart_title === 'report'));
  var titleSize = Number(reportProperties.chart_title_size);
  var chartWidth = Number(hcOptions.chart.width);
  var chartHeight = Number(hcOptions.chart.height);
  if (hasLegend) {
    if (legendHorizontalAlign === "right") {
      if (legendVerticalAlign === "top") {
        hcOptions.legend.y = 25;
      } else if (legendVerticalAlign === "bottom") {
        hcOptions.legend.maxHeight = chartHeight - 70;
      } else if (legendVerticalAlign === "middle") {
        hcOptions.legend.maxHeight = chartHeight - 100;
      }
    } else if (legendHorizontalAlign === "center") {
      if (legendItemsLeftAlign || chartType === 'heatmap' || chartType === 'map')
        hcOptions.legend.width = chartWidth - 20;
      if (isUI)
        hcOptions.legend.maxHeight = chartHeight / 6;
      if (chartType === 'heatmap' || chartType === 'map') {
        hcOptions.legend.symbolWidth = hcOptions.legend.width - 10;
        hcOptions.legend.maxHeight = '';
      }
      if (legendVerticalAlign === "top") {
        hcOptions.legend.y = -2;
        if (showChartTitle && titleVerticalAlign === "top")
          hcOptions.legend.y = titleSize + 10;
      }
    }
    if (legendVerticalAlign === "bottom" && showChartTitle && titleVerticalAlign === "bottom") {
      hcOptions.legend.y = 0 - (titleSize + 10);
    }
  }
  if ((!hasLegend || (legendHorizontalAlign !== "center" || legendVerticalAlign !== "bottom")) &&
    showChartTitle && titleVerticalAlign === "bottom" && chartType !== "solid_gauge") {
    if (chartType === 'pie' || chartType === 'donut' || chartType === 'semi_donut' || chartType === "angular_gauge")
      hcOptions.chart.marginBottom = titleSize;
    else if (chartType === "funnel" || chartType === "pyramid")
      hcOptions.chart.marginBottom = titleSize + 40;
    else
      hcOptions.chart.marginBottom = titleSize + 75;
  }
}

function hc_setLegendLabelFormatter(hcOptions, isUI, isPercent) {
  var isCentered = (hcOptions.legend.align === 'center');
  if (isUI) {
    if (isCentered && isPercent) {
      hcOptions.legend.labelFormatter = hc_legendLabelPercentFormatter;
    } else if (!isCentered) {
      if (isPercent) {
        hcOptions.legend.labelFormatter = hc_legendLabelShortenedPercentFormatter;
      } else {
        hcOptions.legend.labelFormatter = hc_legendLabelShortenedFormatter;
      }
    }
  } else {
    if (isCentered) {
      if (isPercent) {
        hcOptions.legend.labelFormatter = 'hc_legendLabelPercentFormatter';
      }
    } else {
      if (isPercent) {
        hcOptions.legend.labelFormatter = 'hc_legendLabelShortenedPercentFormatter';
      } else {
        hcOptions.legend.labelFormatter = 'hc_legendLabelShortenedFormatter';
      }
    }
  }
}

function hc_generateChartOptions(chartType, chartData, aggType, stackedField, chartHeight, chartWidth, chartSize, isRtl) {
  var hcOptions = {};
  var chartProps = hc_initDefaultChartOptions(hcOptions, chartData, chartType, chartSize, false, false, '', aggType, stackedField, false, chartHeight, chartWidth, isRtl);
  hc_sanitizeXValues(chartData, chartProps);
  hc_setLegendLabelFormatter(hcOptions, false, false);
  if (chartType == 'bubble') {
    hcOptions.series = hc_createBubbleSeriesData(chartData, chartProps, true);
    hcOptions.xAxis = chartData.series[0].xAxis;
    hcOptions.yAxis = chartData.series[0].yAxis;
    hc_addBubbleChartOptions(hcOptions, true, chartData.series[0].legend.enabled);
  } else if (chartType == 'heatmap') {
    var curSeries = hc_createHeatmapSeriesData(chartData, chartProps, true);
    hcOptions.series.push(curSeries);
    hc_addHeatmapChartOptions(hcOptions, chartProps, true, chartData, curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, true);
    hc_addHeatmapAxisCategories(hcOptions, chartData);
  } else if (chartType == 'pie' || chartType == 'semi_donut' || chartType == 'donut') {
    hc_addPieChartOptions(hcOptions, chartProps, false, chartType == 'semi_donut');
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    if (chartType == 'semi_donut' || chartType == 'donut') {
      curSeries.innerSize = (100 - chartProps.report_properties.donut_width_percent) + "%";
      if (chartProps.report_properties.show_chart_total)
        hc_addTotal(hcOptions, chartProps, curSeries, chartData);
    }
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'funnel') {
    hc_addFunnelChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'pyramid') {
    hc_addPyramidChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == "angular_gauge" || chartType == "solid_gauge") {
    hc_addGaugeChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'bar' || chartType == 'horizontal_bar') {
    if (stackedField == '')
      hc_addBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    else
      hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
    var series;
    series = hc_createMultipleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series = series;
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'hist') {
    hc_addHistogramOptions(hcOptions, chartProps, chartData, false);
    var curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(curSeries);
  } else if (chartType == 'pareto') {
    hc_addBarChartOptions(hcOptions, chartProps, chartData, 'column', false);
    var series0 = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(series0);
    var cumulative_series = hc_createParetoCumulSeries(hcOptions, chartProps, series0, false);
    hcOptions.series.push(cumulative_series);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'control') {
    hc_addControlChartOptions(hcOptions, chartProps, chartData, false);
    hcOptions.series = hc_createControlSeriesData(hcOptions, chartData, chartProps, false);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'box' || chartType == 'tbox') {
    hc_addBoxChartOptions(hcOptions, chartProps, chartData, false);
    var boxSeries = hc_createBoxPlotData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(boxSeries);
    var meanSeries = hc_createBoxMeanData(hcOptions, chartData, chartProps, false);
    hcOptions.series.push(meanSeries);
  } else if (chartType == 'trend') {
    var curSeries;
    if ('sub_series' in chartData.series[0]) {
      hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
      hcOptions.series = hc_createMultipleSeriesData(hcOptions, chartData, chartProps, false);
    } else {
      hc_addBarChartOptions(hcOptions, chartProps, chartData, hc_getHighChartsType(chartType), false);
      curSeries = hc_createSingleSeriesData(hcOptions, chartData, chartProps, false);
      hcOptions.series.push(curSeries);
    }
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (isLineType(chartType) || chartType == 'availability') {
    if (chartType == 'availability')
      hc_addAvailChartOptions(hcOptions, chartProps, chartData, false);
    else
      hc_addLineChartOptions(hcOptions, chartProps, chartData, false, chartType);
    hcOptions.series = hc_createLineSeriesData(hcOptions, chartData, chartProps, false);
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, false);
  } else if (chartType == 'map') {
    hc_addMapChartOptions(hcOptions, chartProps, false, chartData);
    var curSeries = hc_createMapSeriesData(hcOptions, chartData, chartProps, true);
    hcOptions.series = curSeries;
    hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, true);
    hc_updateDataLabelOptionsGeographical(hcOptions, chartData, chartType);
    hc_updateMapVisualizationOptions(hcOptions, chartData, chartProps);
  }
  hc_configureChartProportions(chartType, chartData, hcOptions, false, false);
  return hcOptions;
}

function hc_updateMapVisualizationOptions(hcOptions, chartData, chartProps) {
  var chartSerieProps;
  if (chartData.report_properties_series == undefined)
    chartSerieProps = chartProps;
  else
    chartSerieProps = chartData.report_properties_series[0];
  var mapVisualizationProperties = {}
  if ('report_drilldown' in chartSerieProps)
    mapVisualizationProperties.report_drilldown = chartSerieProps.report_drilldown;
  if ('report_id' in chartSerieProps)
    mapVisualizationProperties.report_id = chartSerieProps.report_id;
  if ('report_drilldown_zoom' in chartSerieProps)
    mapVisualizationProperties.report_drilldown_zoom = chartSerieProps.report_drilldown_zoom;
  if ('report_drilldown_map' in chartSerieProps)
    mapVisualizationProperties.report_drilldown_map = chartSerieProps.report_drilldown_map;
  if ('sysparm_full_query' in chartSerieProps)
    mapVisualizationProperties.full_query = chartSerieProps.sysparm_full_query;
  mapVisualizationProperties.show_data_label = chartSerieProps.show_chart_data_label;
  mapVisualizationProperties.show_geographical_label = chartSerieProps.show_geographical_label;
  hcOptions.mapVisualization = mapVisualizationProperties;
}

function isLineType(type) {
  return (type == 'line' || type == 'area' || type == 'spline' || type == 'line_bar' || type == 'step_line');
}

function hc_getHighChartsType(snType, lineType) {
  if (snType == 'bar' || snType == 'trend')
    return 'column';
  else if (snType == 'horizontal_bar')
    return 'bar';
  else if (snType == 'pie')
    return 'pie';
  else if (snType == 'semi_donut')
    return 'pie';
  else if (snType == 'donut')
    return 'pie';
  else if (snType == 'funnel')
    return 'funnel';
  else if (snType == 'pyramid')
    return 'funnel';
  else if (snType == 'box')
    return 'boxplot';
  else if (snType == 'spline')
    return 'spline';
  else if (snType == 'area')
    return 'area';
  else if (snType == 'line_bar')
    return 'column';
  else if (snType == 'line' || snType == 'step_line')
    return 'line';
  else if (snType == 'heatmap')
    return 'heatmap';
  else if (snType == 'angular_gauge')
    return 'gauge';
  else if (snType == 'solid_gauge')
    return 'solidgauge'
  else if (snType == 'bubble')
    return 'bubble'
  else if (snType == 'map')
    return 'map'
  else
    return '';
}

function hc_setupChartProperties(hcOptions, chartData, chartType, chartSize, isGauge, isPub, aggType, stackedField) {
  var chartProps = {};
  chartProps.defaultFontFamily = 'Arial';
  chartProps.fontSize = '10pt';
  chartProps.otherDisplay = 'Other';
  chartProps.otherDisplayMore = '(more...)';
  chartProps.report_properties = {};
  if ('report_properties' in chartData) {
    chartProps.report_properties = chartData.report_properties;
    if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
      chartProps.defaultFontFamily = chartProps.report_properties.font_family;
    if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
      chartProps.fontSize = chartProps.report_properties.font_size;
    chartProps.otherDisplay = chartProps.report_properties.other_display;
    chartProps.otherDisplayMore = chartProps.report_properties.other_display_more;
  }
  chartProps.isGauge = isGauge;
  chartProps.isPub = isPub;
  chartProps.origXValues = [];
  chartProps.xValues = [];
  chartProps.maxAllowedLabelLen = 20;
  chartProps.grayColor = '#666666';
  chartProps.blackColor = '#000';
  chartProps.aggType = aggType;
  chartProps.stackedField = stackedField;
  chartProps.otherKey = 'zzyynomatchaabb';
  chartProps.chartType = chartType;
  chartProps.chartSize = chartSize;
  chartProps.titleMargin = 50;
  return chartProps;
}

function hc_sanitizeXValues(chartData, chartProps) {
  if (!chartData.series || !chartData.series[0].xvalues)
    return;
  chartProps.origXValues = chartData.series[0].xvalues;
  if ('truncate_x_axis_labels' in chartProps.report_properties && chartProps.report_properties.truncate_x_axis_labels) {
    var removeLeading = false;
    if ('xaxis_labels_remove_leading' in chartProps.report_properties && chartProps.report_properties.xaxis_labels_remove_leading)
      removeLeading = true;
    for (var i = 0; i < chartProps.origXValues.length; i++) {
      if (chartProps.origXValues[i].length > chartProps.maxAllowedLabelLen) {
        if (removeLeading)
          chartProps.xValues.push('...' + chartProps.origXValues[i].substring(chartProps.origXValues[i].length - chartProps.maxAllowedLabelLen + 3));
        else
          chartProps.xValues.push(chartProps.origXValues[i].substring(0, chartProps.maxAllowedLabelLen - 3) + '...');
      } else
        chartProps.xValues.push(chartProps.origXValues[i]);
    }
  } else {
    for (var i = 0; i < chartProps.origXValues.length; i++)
      chartProps.xValues.push(chartProps.origXValues[i]);
  }
  var indx = hc_isPresentInArray(chartProps.origXValues, chartProps.otherKey);
  if (indx >= 0) {
    var indx2 = hc_isPresentInArray(chartProps.origXValues, chartProps.otherDisplay);
    if (indx2 >= 0)
      chartProps.xValues[indx] = chartProps.otherDisplay + ' ' + chartProps.otherDisplayMore;
    else
      chartProps.xValues[indx] = chartProps.otherDisplay;
  }
}

function hc_sanitizeCategoryValues(hcOptions, chartProps) {
  if (hcOptions.xAxis.categories)
    hcOptions.xAxis.categories = hc_sanitizeAxisCategoriesValues(hcOptions.xAxis.categories, chartProps);
  if (hcOptions.yAxis[0].categories)
    hcOptions.yAxis[0].categories = hc_sanitizeAxisCategoriesValues(hcOptions.yAxis[0].categories, chartProps);
}

function hc_sanitizeAxisCategoriesValues(categories, chartProps) {
  if (!categories)
    return;
  var newValues = [];
  var origValues = categories;
  if ('truncate_x_axis_labels' in chartProps.report_properties && chartProps.report_properties.truncate_x_axis_labels) {
    var removeLeading = false;
    if ('xaxis_labels_remove_leading' in chartProps.report_properties && chartProps.report_properties.xaxis_labels_remove_leading)
      removeLeading = true;
    for (var i = 0; i < origValues.length; i++) {
      if (origValues[i].length > chartProps.maxAllowedLabelLen) {
        if (removeLeading)
          newValues.push('...' + origValues[i].substring(origValues[i].length - chartProps.maxAllowedLabelLen + 3));
        else
          newValues.push(origValues[i].substring(0, chartProps.maxAllowedLabelLen - 3) + '...');
      } else
        newValues.push(origValues[i]);
    }
  } else {
    for (var i = 0; i < origValues.length; i++)
      newValues.push(origValues[i]);
  }
  var indx = hc_isPresentInArray(origValues, chartProps.otherKey);
  if (indx >= 0) {
    var indx2 = hc_isPresentInArray(origValues, chartProps.otherDisplay);
    if (indx2 >= 0)
      newValues[indx] = chartProps.otherDisplay + ' ' + chartProps.otherDisplayMore;
    else
      newValues[indx] = chartProps.otherDisplay;
  }
  return newValues;
}

function hc_initDefaultChartOptions(hcOptions, chartData, chartType, chartSize, isGauge, isPub, containerId, aggType, stackedField, isUI, chartHeight, chartWidth, isRtl) {
  hcOptions.chart = {};
  if (containerId != '') {
    hcOptions.chart.renderTo = containerId;
  }
  if (!isUI) {
    hcOptions.chart.height = chartHeight;
    hcOptions.chart.width = chartWidth;
  } else {
    var isCustomChartSize = chartData.report_properties && chartData.report_properties.custom_chart_size;
    hc_setHeightWidthChart(hcOptions, chartData, chartSize, isGauge, containerId, isCustomChartSize, chartHeight, chartWidth);
  }
  hcOptions.lang = hcOptions.lang || {};
  hcOptions.lang.noData = chartData.noDataToDisplayMsg;
  hc_setI18nTranslations(hcOptions, chartData.report_properties.translation);
  hcOptions.credits = {};
  hcOptions.credits.enabled = false;
  hcOptions.legend = {};
  var isMultiSeries = chartData.series.length > 1;
  if (!isMultiSeries && (chartType == 'bar' || chartType == 'horizontal_bar') && (stackedField === '') || chartType === 'angular_gauge' ||
    chartType === 'solid_gauge' || chartType === 'box' || chartType === 'tbox' || chartType === 'hist' || chartType === 'pareto')
    hcOptions.legend.enabled = false;
  else
    hcOptions.legend.enabled = chartData.report_properties.show_legend;
  hcOptions.legend.verticalAlign = chartData.report_properties.legend_vertical_alignment;
  hcOptions.legend.align = chartData.report_properties.legend_horizontal_alignment;
  if (hcOptions.legend.align === 'left' || hcOptions.legend.align === 'right') {
    hcOptions.legend.layout = 'vertical';
  }
  hcOptions.legend.itemStyle = {};
  hcOptions.legend.itemStyle.fontFamily = 'Arial';
  hcOptions.legend.backgroundColor = chartData.report_properties.legend_background_color_value;
  if (chartData.report_properties.show_legend_border === true) {
    hcOptions.legend.borderWidth = chartData.report_properties.legend_border_width;
    hcOptions.legend.borderRadius = chartData.report_properties.legend_border_radius;
    hcOptions.legend.borderColor = chartData.report_properties.legend_border_color_value;
  }
  hcOptions.tooltip = {};
  hcOptions.tooltip.style = {};
  hcOptions.tooltip.style.fontFamily = 'Arial';
  hcOptions.tooltip.style.fontSize = '10pt';
  if (isRtl) {
    hcOptions.tooltip.useHTML = true;
    hcOptions.legend.useHTML = true;
  }
  hcOptions.title = {};
  if (!chartData.report_properties.custom_chart_title_position) {
    if (chartData.report_properties.title_vertical_alignment !== 'top')
      hcOptions.title.verticalAlign = chartData.report_properties.title_vertical_alignment;
    if (hcOptions.title.verticalAlign === 'bottom')
      hcOptions.title.y = 0;
    hcOptions.title.align = chartData.report_properties.title_horizontal_alignment;
    if (hcOptions.title.align === 'right' && chartData.report_properties.title_vertical_alignment === 'top')
      hcOptions.title.x = -40;
  } else {
    hcOptions.title.x = chartData.report_properties.chart_title_x_position;
    hcOptions.title.y = chartData.report_properties.chart_title_y_position;
  }
  hcOptions.title.style = {};
  hcOptions.title.style.color = chartData.report_properties.chart_title_color_value;
  hcOptions.title.style.fontFamily = 'Arial';
  hcOptions.title.style.fontSize = chartData.report_properties.chart_title_size + 'px';
  if ('report_properties' in chartData) {
    if ('font_family' in chartData.report_properties && chartData.report_properties.font_family != '') {
      hcOptions.legend.itemStyle.fontFamily = chartData.report_properties.font_family;
      hcOptions.title.style.fontFamily = chartData.report_properties.font_family;
      hcOptions.tooltip.style.fontFamily = chartData.report_properties.font_family;
    }
    if ('font_size' in chartData.report_properties && chartData.report_properties.font_size != '') {
      hcOptions.tooltip.style.fontSize = chartData.report_properties.font_size;
    }
  }
  hcOptions.chart.backgroundColor = chartData.report_properties.chart_background_color_value;
  if (chartData.report_properties.show_chart_border === true) {
    hcOptions.chart.borderWidth = chartData.report_properties.chart_border_width;
    hcOptions.chart.borderRadius = chartData.report_properties.chart_border_radius;
    hcOptions.chart.borderColor = chartData.report_properties.chart_border_color_value;
  }
  hcOptions.chart.style = {};
  hcOptions.chart.style.margin = "0 auto";
  if (chartData.report_properties.show_chart_title === 'always' || (!isGauge && chartData.report_properties.show_chart_title === 'report')) {
    var title = chartData.title;
    if (chartData.report_properties.chart_title)
      title = chartData.report_properties.chart_title;
    if (isUI)
      title = title ? escapeHTML(title) : '';
    hcOptions.title.text = title;
  } else {
    hcOptions.title = {};
    hcOptions.title.text = '';
  }
  hcOptions.series = [];
  return hc_setupChartProperties(hcOptions, chartData, chartType, chartSize, isGauge, isPub, aggType, stackedField);
}

function escapeHTML(html) {
  if (html)
    return html.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return html;
}

function hc_setHeightWidthChart(hcOptions, chartData, chartSize, isGauge, containerId, customChartSize, chartHeight, chartWidth) {
  var containerDimensions = {};
  var ie_dynamic_sizing;
  if (typeof chartData !== 'undefined' && chartData.report_properties)
    ie_dynamic_sizing = chartData.report_properties.ie_dynamic_sizing;
  if ((window.SNC && window.SNC.canvas) || !isGauge || !(window.isMSIE || window.isMSIE11) || ie_dynamic_sizing)
    containerDimensions = hc_getDimensions(containerId);
  if (containerDimensions.height && containerDimensions.height > 50)
    hcOptions.chart.height = containerDimensions.height;
  else if (chartHeight != undefined && chartHeight != '' && customChartSize)
    hcOptions.chart.height = chartHeight;
  else {
    hcOptions.chart.height = '375';
    if (chartSize == 'large')
      hcOptions.chart.height = '550';
    else if (chartSize == 'medium')
      hcOptions.chart.height = '450';
  }
  if (containerDimensions.width)
    hcOptions.chart.width = containerDimensions.width;
  else if (chartWidth != undefined && chartWidth != '' && customChartSize)
    hcOptions.chart.width = chartWidth;
  else {
    hcOptions.chart.width = '450';
    if (chartSize == 'large')
      hcOptions.chart.width = '750';
    else if (chartSize == 'medium')
      hcOptions.chart.width = '600';
  }
}

function hc_setI18nTranslations(hcOptions, i18n) {
  var lang = hcOptions.lang;
  lang.months = [i18n.month.january, i18n.month.february, i18n.month.march, i18n.month.april, i18n.month.may, i18n.month.june, i18n.month.july, i18n.month.august, i18n.month.september, i18n.month.october, i18n.month.november, i18n.month.december];
  lang.weekdays = [i18n.weekdays.sunday, i18n.weekdays.monday, i18n.weekdays.tuesday, i18n.weekdays.wednesday, i18n.weekdays.thursday, i18n.weekdays.friday, i18n.weekdays.saturday];
  lang.shortMonths = [i18n.month.shortName.january, i18n.month.shortName.february, i18n.month.shortName.march, i18n.month.shortName.april, i18n.month.shortName.may, i18n.month.shortName.june, i18n.month.shortName.july, i18n.month.shortName.august, i18n.month.shortName.september, i18n.month.shortName.october, i18n.month.shortName.november, i18n.month.shortName.december];
  lang.exportButtonTitle = i18n.exportButtonTitle;
  lang.printButtonTitle = i18n.printButtonTitle;
  lang.rangeSelectorFrom = i18n.rangeSelectorFrom;
  lang.rangeSelectorTo = i18n.rangeSelectorTo;
  lang.rangeSelectorZoom = i18n.rangeSelectorZoom;
  lang.downloadPNG = i18n.downloadPNG;
  lang.downloadJPEG = i18n.downloadJPEG;
  lang.downloadPDF = i18n.downloadPDF;
  lang.downloadSVG = i18n.downloadSVG;
  lang.printChart = i18n.printChart;
  lang.resetZoom = i18n.resetZoom;
  lang.resetZoomTitle = i18n.resetZoomTitle;
  lang.thousandsSep = i18n.thousandsSep;
  lang.decimalPoint = i18n.decimalPoint;
  lang.contextButtonTitle = i18n.contextButtonTitle;
  lang.days = i18n.days;
  lang.hours = i18n.hours;
  lang.minutes = i18n.minutes;
  lang.seconds = i18n.seconds;
}

function hc_getDimensions(containerId, isResize) {
  var containerHeight, containerWidth;
  var mustSubtractChildren = false;
  var isInCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  var $container = jQuery("#" + containerId);
  var $parent = isInCanvas && containerId.indexOf("preview") == -1 ? $container.closest('.grid-widget-content') : $container.parent().parent();
  if ($parent.is("rendered_body"))
    $parent = $parent.parent();
  if (!isResize && $container.height() > 25)
    containerHeight = $container.height();
  else {
    containerHeight = $parent.height();
    mustSubtractChildren = true;
  }
  if (!isResize && $container.width() !== 0)
    containerWidth = $container.width();
  else {
    containerWidth = $parent.width();
  }
  if (mustSubtractChildren) {
    if (window.g_accessibility === "true" || window.g_accessibility === true)
      containerHeight -= 22;
    var children = $container.siblings();
    for (var i = 0; i < children.length; i++) {
      if (children[i].className.indexOf('gauge-size-handle') > -1 || children[i].className.indexOf('timingDiv') > -1)
        containerHeight -= children[i].offsetHeight;
    }
  }
  return {
    height: containerHeight,
    width: containerWidth
  };
}

function hc_saveChart(inputType, outputType, inputData) {
  var ONE_MB = 1048576;
  if (inputData.length > ONE_MB) {
    var errDlg = new GlideDialogWindow('glide_alert_standard');
    errDlg.setTitle(new GwtMessage().getMessage('Error'));
    errDlg.setPreference('warning', true);
    errDlg.setPreference('title', new GwtMessage().getMessage('Chart data too large to be saved'));
    errDlg.setPreference('invokePromptCallBack', function() {
      this.destroy();
    });
    errDlg.render();
    return;
  }
  var dialog = new GwtPollDialog(inputType, inputData, 0, '', outputType);
  dialog.execute();
}

function hc_addHeatmapChartOptions(hcOptions, chartProps, isUI, chartData, curSeries) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.heatmap = {};
  hcOptions.plotOptions.heatmap.cursor = 'pointer';
  if (chartData.report_properties.use_color_heatmap === true) {
    hcOptions.colorAxis = {};
    hcOptions.colorAxis.min = chartData.series[0].min_value;
    hcOptions.colorAxis.max = chartData.series[0].max_value;
    hcOptions.colorAxis.minColor = chartData.report_properties.axis_min_color;
    hcOptions.colorAxis.maxColor = chartData.report_properties.axis_max_color;
  } else {
    hcOptions.legend.enabled = false;
  }
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHeatmapTooltip;
    hcOptions.plotOptions.heatmap.point = {};
    hcOptions.plotOptions.heatmap.point.events = {};
    hcOptions.plotOptions.heatmap.point.events.click = hc_dataPointClicked;
  }
}

function hc_addMapChartOptions(hcOptions, chartProps, isUI, chartData) {
  hcOptions.mapNavigation = {};
  hcOptions.mapNavigation.enabled = true;
  hcOptions.mapNavigation.enableMouseWheelZoom = false;
  hcOptions.plotOptions = {};
  var useLatLon = chartData.report_properties_series[0].map_source.use_lat_lon;
  if (!useLatLon && chartData.report_properties.use_color_heatmap === true) {
    hcOptions.colorAxis = {};
    hcOptions.colorAxis.min = parseInt(chartData.series[0].ymin);
    hcOptions.colorAxis.max = parseInt(chartData.series[0].ymax);
    hcOptions.colorAxis.minColor = chartData.report_properties.axis_min_color;
    hcOptions.colorAxis.maxColor = chartData.report_properties.axis_max_color;
  } else
    hcOptions.legend.enabled = false;
  if (isUI) {
    hcOptions.title.align = chartData.report_properties.title_horizontal_alignment;
    if (hcOptions.title.align === 'right' && chartData.report_properties.title_vertical_alignment === 'top')
      hcOptions.title.x = -80;
    var hasLegend = hcOptions.legend.enabled;
    var legendHorizontalAlign = chartData.report_properties.legend_horizontal_alignment;
    if (hasLegend) {
      if (legendHorizontalAlign === "left") {
        if (!hcOptions.mapNavigation.buttonOptions)
          hcOptions.mapNavigation.buttonOptions = {};
        hcOptions.mapNavigation.buttonOptions.x = 70;
        hcOptions.mapNavigation.buttonOptions.y = -30;
      }
    }
    hcOptions.tooltip.formatter = hc_formatMapTooltip;
    hcOptions.plotOptions.series = {};
    hcOptions.plotOptions.series.point = {};
    hcOptions.plotOptions.series.point.events = {};
    hcOptions.plotOptions.series.point.events.click = hc_dataPointClicked;
    hcOptions.plotOptions.series.point.dataLabels = {};
    hcOptions.plotOptions.series.point.dataLabels.allowOverlap = true;
    hcOptions.plotOptions.series.animation = false;
  }
}

function drillDownButton(event, exactPoint) {
  if (this.series.length > 0 && this.series[0].data.length > 0) {
    var point = this.series[0].data[0];
    var reportDrilldown = point.report_drilldown;
    var element = event.srcElement;
    if (!element)
      element = event.target;
    var content = jQuery(element).closest(".report_content");
    if (reportDrilldown) {
      var mapParams = '&sysparm_report_map_exact_points=' + exactPoint;
      var actualMap = point.report_drilldown_map;
      if (actualMap)
        mapParams += "&sysparm_report_map_parent=" + actualMap;
      drillReport(content.parent(), reportDrilldown, '', mapParams);
    }
  }
  return;
}

function hc_addBubbleChartOptions(hcOptions, isUI, isLegendEnabled) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.bubble = {};
  hcOptions.plotOptions.bubble.cursor = 'pointer';
  hcOptions.plotOptions.bubble.minSize = 8;
  hcOptions.plotOptions.bubble.maxSize = 70;
  if (isLegendEnabled == false)
    hcOptions.legend.enabled = false;
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHeatmapTooltip;
    hcOptions.plotOptions.bubble.point = {};
    hcOptions.plotOptions.bubble.point.events = {};
    hcOptions.plotOptions.bubble.point.events.click = hc_dataPointClicked;
  }
}

function hc_addPieChartOptions(hcOptions, chartProps, isUI, isSemiDonut, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.pie = {};
  if (isPublisher)
    hcOptions.plotOptions.pie.allowPointSelect = true,
    hcOptions.plotOptions.pie.cursor = 'pointer';
  hcOptions.plotOptions.pie.size = '90%';
  if (isSemiDonut) {
    hcOptions.plotOptions.pie.startAngle = -90;
    hcOptions.plotOptions.pie.endAngle = 90;
    hcOptions.plotOptions.pie.center = ["50%", "75%"];
  }
  hcOptions.plotOptions.pie.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.pie.point = {};
    hcOptions.plotOptions.pie.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.pie.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.pie.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.pie.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.pie.point.events.click = hc_dataPointClicked;
  }
}

function hc_addFunnelChartOptions(hcOptions, chartProps, isUI, chartData, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.funnel = {};
  if (isPublisher)
    hcOptions.plotOptions.funnel.allowPointSelect = true
  hcOptions.plotOptions.funnel.cursor = 'pointer';
  hcOptions.plotOptions.funnel.size = '90%';
  hcOptions.plotOptions.funnel.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.funnel.point = {};
    hcOptions.plotOptions.funnel.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.funnel.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.funnel.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.funnel.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.funnel.point.events.click = hc_dataPointClicked;
  }
  hcOptions.plotOptions.series = {};
  if (chartProps.report_properties.funnel_neck_percent)
    hcOptions.plotOptions.series.neckHeight = chartProps.report_properties.funnel_neck_percent + "%";
}

function hc_addPyramidChartOptions(hcOptions, chartProps, isUI, chartData, isPublisher) {
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.funnel = {};
  if (isPublisher)
    hcOptions.plotOptions.funnel.allowPointSelect = true;
  hcOptions.plotOptions.funnel.cursor = 'pointer';
  hcOptions.plotOptions.funnel.size = '90%';
  hcOptions.plotOptions.funnel.showInLegend = true;
  hc_setLegendLabelFormatter(hcOptions, isUI, true);
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatPie;
    hcOptions.plotOptions.funnel.point = {};
    hcOptions.plotOptions.funnel.point.events = {};
    if (isPublisher) {
      hcOptions.plotOptions.funnel.point.events.select = hc_dataPointSelected;
      hcOptions.plotOptions.funnel.point.events.unselect = hc_dataPointUnselected;
      hcOptions.plotOptions.funnel.point.events.legendItemClick = hc_dataPointLegendClick;
    } else
      hcOptions.plotOptions.funnel.point.events.click = hc_dataPointClicked;
  }
  hcOptions.plotOptions.series = {};
  hcOptions.plotOptions.series.neckHeight = "0%";
  hcOptions.plotOptions.series.neckWidth = "0%";
  hcOptions.plotOptions.funnel.reversed = true;
}

function hc_addGaugeChartOptions(hcOptions, chartProps, chartData, chartType, isUI) {
  hcOptions.chart.type = chartType;
  hcOptions.pane = {};
  var yAxis = {};
  hcOptions.plotOptions = {};
  var value = parseFloat(chartData.series[0].yvalues[0]);
  var min = 0;
  var max = 0;
  if (!chartProps.report_properties.gauge_autoscale && chartProps.report_properties.from)
    min = parseInt(chartProps.report_properties.from);
  else if (value < 0)
    min = value * 1.5;
  if (!chartProps.report_properties.gauge_autoscale && chartProps.report_properties.to)
    max = parseInt(chartProps.report_properties.to);
  else if (value == 0)
    max = 10;
  else if (value > 0)
    max = value * 1.5;
  var lower = null;
  var upper = null;
  if (chartProps.report_properties.lower_limit || chartProps.report_properties.lower_limit === 0 || chartProps.report_properties.lower_limit === '0')
    lower = parseInt(chartProps.report_properties.lower_limit);
  if (chartProps.report_properties.upper_limit || chartProps.report_properties.upper_limit === 0 || chartProps.report_properties.upper_limit === '0')
    upper = parseInt(chartProps.report_properties.upper_limit);
  if (lower !== null && upper !== null) {
    if (lower < min && lower <= 0)
      min = lower * 1.5;
    if (upper > max && upper >= 0)
      max = upper * 1.5;
    var total = max - min;
    var middleColor = '#ffca1f';
    var topColor;
    var bottomColor;
    if (chartProps.report_properties.direction == 'maximize') {
      topColor = '#4bd762';
      bottomColor = '#ff402c';
    } else {
      topColor = '#ff402c';
      bottomColor = '#4bd762';
    }
    if (chartType == 'solidgauge') {
      yAxis.stops = [];
      if (chartProps.report_properties.direction == 'maximize') {
        yAxis.stops.push([(lower - min) / total, bottomColor]);
        yAxis.stops.push([(upper - min) / total, middleColor]);
        yAxis.stops.push([1, topColor]);
      } else {
        yAxis.stops.push([0, bottomColor]);
        yAxis.stops.push([(lower - min) / total, middleColor]);
        yAxis.stops.push([(upper - min) / total, topColor]);
      }
    } else {
      yAxis.plotBands = [];
      yAxis.plotBands.push({
        from: min,
        to: lower,
        color: bottomColor
      });
      yAxis.plotBands.push({
        from: lower,
        to: upper,
        color: middleColor
      });
      yAxis.plotBands.push({
        from: upper,
        to: max,
        color: topColor
      });
    }
  } else {
    if (chartType == 'solidgauge') {
      yAxis.stops = [];
      color = chartData.series[0].colors[0];
      yAxis.stops.push([0, color]);
      yAxis.stops.push([1, color]);
    }
  }
  yAxis.min = min;
  yAxis.max = max;
  if (chartType == "solidgauge") {
    hcOptions.pane.size = "100%";
    hcOptions.pane.center = ['50%', '50%'];
    hcOptions.pane.startAngle = -90;
    hcOptions.pane.endAngle = 90;
    hcOptions.pane.background = {};
    hcOptions.pane.background.innerRadius = "60%";
    hcOptions.pane.background.outerRadius = "100%";
    hcOptions.pane.background.shape = "arc";
    hcOptions.pane.background.backgroundColor = "#EEE";
    hcOptions.tooltip = {};
    hcOptions.tooltip.enabled = false;
    yAxis.tickWidth = 0;
    yAxis.lineWidth = 0;
    yAxis.minorTickInterval = null;
    yAxis.tickPositions = [min, max];
    yAxis.labels = {};
    yAxis.labels.y = 14;
    if (!hcOptions.plotOptions.solidgauge)
      hcOptions.plotOptions.solidgauge = {};
    hcOptions.plotOptions.solidgauge.point = {};
    hcOptions.plotOptions.solidgauge.point.events = {};
    hcOptions.plotOptions.solidgauge.point.events.click = hc_dataPointClicked;
  } else {
    hcOptions.chart.plotBackgroundColor = '#ffffff';
    hcOptions.chart.plotBackgroundImage = null;
    hcOptions.chart.plotBorderWidth = 0;
    hcOptions.chart.plotShadow = false;
    hcOptions.pane.startAngle = -150;
    hcOptions.pane.endAngle = 150;
    if (!hcOptions.plotOptions.gauge)
      hcOptions.plotOptions.gauge = {};
    hcOptions.plotOptions.gauge.point = {};
    hcOptions.plotOptions.gauge.point.events = {};
    hcOptions.plotOptions.gauge.point.events.click = hc_dataPointClicked;
    hcOptions.plotOptions.gauge.wrap = false;
    hcOptions.pane.background = [];
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '109%'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '107%'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff'
    });
    hcOptions.pane.background.push({
      backgroundColor: '#ffffff',
      borderWidth: 0,
      outerRadius: '105%',
      innerRadius: '103%'
    });
    yAxis.minorTickWidth = 1;
    yAxis.minorTickLength = 10;
    yAxis.minorTickPosition = 'inside';
    yAxis.tickPixelInterval = 30;
    yAxis.tickWidth = 2;
    yAxis.tickPosition = 'inside';
    yAxis.tickLength = 10;
    yAxis.labels = {};
    yAxis.labels.step = 2;
    yAxis.labels.rotation = 'auto';
    if (lower !== null && upper !== null) {
      yAxis.minorTickColor = '#ffffff';
      yAxis.tickColor = '#ffffff';
    } else {
      yAxis.minorTickColor = '#828890';
      yAxis.tickColor = '#828890';
    }
  }
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addBarChartOptions(hcOptions, chartProps, chartData, barType, isUI) {
  hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI);
  hcOptions.plotOptions.series.minPointLength = 2;
  if (chartData.series.length === 1)
    hc_addYAxisMax(chartProps, hcOptions, chartData, chartProps.chartType);
  if (isUI)
    hcOptions.tooltip.formatter = hc_formatToolTip;
}

function hc_updateDataLabelOptionsGeographical(hcOptions, chartData, chartType) {
  if ('map' === chartType) {
    if (hcOptions.series[0].dataLabels == null)
      hcOptions.series[0].dataLabels = {};
    hcOptions.series[0].dataLabels.enabled = true;
    hcOptions.series[0].dataLabels.color = '#000';
    hcOptions.series[0].dataLabels.show_geographical_label = chartData.report_properties_series[0].show_geographical_label;;
    hcOptions.series[0].dataLabels.show_data_label = chartData.report_properties_series[0].show_chart_data_label;
    hcOptions.series[0].dataLabels.formatter = hc_formatMapDataLabels;
  }
}

function hc_addDataLabelOptions(hcOptions, chartProps, chartData, chartType, isUI) {
  var dataLabelColor = '#606060';
  if (chartData.report_properties_series != undefined && chartData.report_properties_series[0].show_chart_data_label === true) {
    if ('pie' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = true;
      hcOptions.plotOptions.pie.dataLabels.softConnector = false;
      hcOptions.plotOptions.pie.dataLabels.distance = 15;
      hcOptions.plotOptions.pie.dataLabels.style = {};
      hcOptions.plotOptions.pie.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.pie.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.pie.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.pie.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.pie.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('semi_donut' === chartType || 'donut' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = true;
      hcOptions.plotOptions.pie.dataLabels.softConnector = false;
      hcOptions.plotOptions.pie.dataLabels.distance = 15;
      hcOptions.plotOptions.pie.dataLabels.style = {};
      hcOptions.plotOptions.pie.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.pie.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.pie.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.pie.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.pie.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.pie.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.pie.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('funnel' === chartType || 'pyramid' === chartType) {
      hcOptions.plotOptions.funnel.dataLabels = {};
      hcOptions.plotOptions.funnel.dataLabels.enabled = true;
      hcOptions.plotOptions.funnel.dataLabels.softConnector = false;
      hcOptions.plotOptions.funnel.dataLabels.distance = 15;
      hcOptions.plotOptions.funnel.dataLabels.style = {};
      hcOptions.plotOptions.funnel.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.funnel.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.funnel.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.funnel.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.funnel.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.funnel.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.funnel.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.funnel.dataLabels.formatter = hc_formatNameValueLabel;
      else
        hcOptions.plotOptions.funnel.dataLabels.formatter = 'hc_formatNameValueLabel';
    } else if ('control' === chartType) {
      if (hcOptions.plotOptions == null)
        hcOptions.plotOptions = {};
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = true;
      hcOptions.plotOptions.series.dataLabels.softConnector = false;
      hcOptions.plotOptions.series.dataLabels.distance = 15;
      hcOptions.plotOptions.series.dataLabels.style = {};
      hcOptions.plotOptions.series.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.series.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.series.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fontWeight = 'normal';
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.series.dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.plotOptions.series.dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('bar' === chartType || 'horizontal_bar' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = true;
      hcOptions.plotOptions.series.dataLabels.softConnector = false;
      hcOptions.plotOptions.series.dataLabels.distance = 15;
      hcOptions.plotOptions.series.dataLabels.style = {};
      hcOptions.plotOptions.series.dataLabels.style.fontFamily = 'Arial';
      hcOptions.plotOptions.series.dataLabels.style.fontSize = '10pt';
      hcOptions.plotOptions.series.dataLabels.style.color = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fill = dataLabelColor;
      hcOptions.plotOptions.series.dataLabels.style.fontWeight = 'normal';
      hc_setDataLabelPositionProperties(hcOptions, chartData);
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.plotOptions.series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.plotOptions.series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.plotOptions.series.dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.plotOptions.series.dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('pareto' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[1].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = true;
      hcOptions.series[0].dataLabels.softConnector = false;
      hcOptions.series[0].dataLabels.distance = 15;
      hcOptions.series[0].dataLabels.style = {};
      hcOptions.series[0].dataLabels.style.fontFamily = 'Arial';
      hcOptions.series[0].dataLabels.style.fontSize = '10pt';
      hcOptions.series[0].dataLabels.style.color = dataLabelColor;
      hcOptions.series[0].dataLabels.style.fill = dataLabelColor;
      hcOptions.series[0].dataLabels.style.fontWeight = 'normal';
      hc_setDataLabelPositionProperties(hcOptions, chartData);
      if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
        hcOptions.series[0].dataLabels.style.fontFamily = chartProps.report_properties.font_family;
      if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
        hcOptions.series[0].dataLabels.style.fontSize = chartProps.report_properties.font_size;
      if (isUI)
        hcOptions.series[0].dataLabels.formatter = hc_formatValueLabel;
      else
        hcOptions.series[0].dataLabels.formatter = 'hc_formatValueLabel';
    } else if ('trend' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      for (i = 0; i < hcOptions.series.length; i++) {
        hcOptions.series[i].dataLabels = {};
        hcOptions.series[i].dataLabels.enabled = true;
        hcOptions.series[i].dataLabels.softConnector = false;
        hcOptions.series[i].dataLabels.distance = 15;
        hcOptions.series[i].dataLabels.inside = false;
        hcOptions.series[i].dataLabels.style = {};
        hcOptions.series[i].dataLabels.style.fontFamily = 'Arial';
        hcOptions.series[i].dataLabels.style.fontSize = '10pt';
        hcOptions.series[i].dataLabels.style.color = dataLabelColor;
        hcOptions.series[i].dataLabels.style.fill = dataLabelColor;
        hcOptions.series[i].dataLabels.style.fontWeight = 'normal';
        if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
          hcOptions.series[i].dataLabels.style.fontFamily = chartProps.report_properties.font_family;
        if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
          hcOptions.series[i].dataLabels.style.fontSize = chartProps.report_properties.font_size;
        if (isUI)
          hcOptions.series[i].dataLabels.formatter = hc_formatValueLabel;
        else
          hcOptions.series[i].dataLabels.formatter = 'hc_formatValueLabel';
      }
      hc_setDataLabelPositionProperties(hcOptions, chartData);
    } else if ('gauge' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
      hcOptions.series[0].dataLabels.borderWidth = 0;
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('angular_gauge' === chartType) {
      if (hcOptions.plotOptions.gauge == null)
        hcOptions.plotOptions.gauge = {};
      if (hcOptions.plotOptions.gauge.dataLabels == null)
        hcOptions.plotOptions.gauge.dataLabels = {};
      hcOptions.plotOptions.gauge.dataLabels.enabled = true;
      hcOptions.plotOptions.gauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.gauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.gauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if ('solid_gauge' === chartType) {
      if (hcOptions.plotOptions.solidgauge == null)
        hcOptions.plotOptions.solidgauge = {};
      if (hcOptions.plotOptions.solidgauge.dataLabels == null)
        hcOptions.plotOptions.solidgauge.dataLabels = {};
      hcOptions.plotOptions.solidgauge.dataLabels.enabled = true;
      hcOptions.plotOptions.solidgauge.dataLabels.y = -35;
      hcOptions.plotOptions.solidgauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.solidgauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.solidgauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if (isLineType(chartType)) {
      hcOptions.series.forEach(function(series) {
        series.dataLabels = series.dataLabels || {};
        series.dataLabels.enabled = series.dataLabels.enabled || false;
        series.dataLabels.softConnector = false;
        series.dataLabels.distance = 15;
        series.dataLabels.style = {};
        series.dataLabels.style.fontFamily = 'Arial';
        series.dataLabels.style.fontSize = '10pt';
        series.dataLabels.style.color = dataLabelColor;
        series.dataLabels.style.fill = dataLabelColor;
        series.dataLabels.style.fontWeight = 'normal';
        if ('font_family' in chartProps.report_properties && chartProps.report_properties.font_family != '')
          series.dataLabels.style.fontFamily = chartProps.report_properties.font_family;
        if ('font_size' in chartProps.report_properties && chartProps.report_properties.font_size != '')
          series.dataLabels.style.fontSize = chartProps.report_properties.font_size;
        if (chartType == 'line_bar')
          hc_setDataLabelPositionProperties(hcOptions, chartData);
        if (isUI)
          series.dataLabels.formatter = hc_formatValueLabel;
        else
          series.dataLabels.formatter = 'hc_formatValueLabel';
      });
    } else if ('heatmap' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '{point.value_display}';
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('map' === chartType) {}
  } else {
    if ('pie' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = false;
    } else if ('heatmap' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '{point.value}';
      hcOptions.series[0].dataLabels.enabled = false;
      hcOptions.series[0].dataLabels.color = 'black';
      hcOptions.series[0].dataLabels.style = {};
      hcOptions.series[0].dataLabels.style.textShadow = 'none';
      hcOptions.series[0].dataLabels.style.HcTextStroke = null;
    } else if ('semi_donut' === chartType || 'donut' === chartType) {
      if (hcOptions.plotOptions.pie == null)
        hcOptions.plotOptions.pie = {};
      hcOptions.plotOptions.pie.dataLabels = {};
      hcOptions.plotOptions.pie.dataLabels.enabled = false;
    } else if ('funnel' === chartType || 'pyramid' === chartType) {
      if (hcOptions.plotOptions.funnel == null)
        hcOptions.plotOptions.funnel = {};
      hcOptions.plotOptions.funnel.dataLabels = {};
      hcOptions.plotOptions.funnel.dataLabels.enabled = false;
    } else if ('control' === chartType) {
      if (hcOptions.plotOptions == null)
        hcOptions.plotOptions = {};
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('bar' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('pareto' === chartType) {
      if (hcOptions.plotOptions.series == null)
        hcOptions.plotOptions.series = {};
      hcOptions.plotOptions.series.dataLabels = {};
      hcOptions.plotOptions.series.dataLabels.enabled = false;
    } else if ('column' === chartType) {
      if (hcOptions.plotOptions.column == null)
        hcOptions.plotOptions.column = {};
      hcOptions.plotOptions.column.dataLabels = {};
      hcOptions.plotOptions.column.dataLabels.enabled = false;
    } else if ('gauge' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
      hcOptions.series[0].dataLabels.borderWidth = 0;
      hcOptions.series[0].dataLabels.enabled = true;
    } else if ('angular_gauge' === chartType) {
      if (hcOptions.plotOptions.gauge == null)
        hcOptions.plotOptions.gauge = {};
      if (hcOptions.plotOptions.gauge.dataLabels == null)
        hcOptions.plotOptions.gauge.dataLabels = {};
      hcOptions.plotOptions.gauge.dataLabels.enabled = true;
      hcOptions.plotOptions.gauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.gauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.gauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if ('solid_gauge' === chartType) {
      if (hcOptions.plotOptions.solidgauge == null)
        hcOptions.plotOptions.solidgauge = {};
      if (hcOptions.plotOptions.solidgauge.dataLabels == null)
        hcOptions.plotOptions.solidgauge.dataLabels = {};
      hcOptions.plotOptions.solidgauge.dataLabels.enabled = true;
      hcOptions.plotOptions.solidgauge.dataLabels.y = -35;
      hcOptions.plotOptions.solidgauge.dataLabels.useHTML = true;
      hcOptions.plotOptions.solidgauge.dataLabels.borderWidth = 0;
      hcOptions.plotOptions.solidgauge.dataLabels.format = '<div style="text-align:center"><span style="font-family:Arial;font-size:25px;color:black">{point.displayvalue}</span><br/>';
    } else if (isLineType(chartType)) {
      if (hcOptions.series[0] == null)
        hcOptions.series[0] = {};
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = false;
    } else if ('map' === chartType) {
      hcOptions.series[0].dataLabels = {};
      hcOptions.series[0].dataLabels.enabled = false;
    }
  }
  if (!isUI) {
    if (hcOptions.plotOptions == null)
      hcOptions.plotOptions = {};
    if (hcOptions.plotOptions.series == null)
      hcOptions.plotOptions.series = {};
  }
}

function hc_addStackedBarChartOptions(hcOptions, chartProps, chartData, barType, isUI, serieProps) {
  hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI);
  if (chartData.series.length === 1 && chartProps.aggType === 'COUNT')
    hc_addYAxisMax(chartProps, hcOptions, chartData, chartProps.chartType);
  if (isUI) {
    hcOptions.tooltip.shared = false;
    hcOptions.tooltip.formatter = hc_formatStackedBarToolTip;
    if (hcOptions.chart.width)
      hcOptions.tooltip.style = {
        width: hcOptions.chart.width / 2
      };
    hcOptions.tooltip.followPointer = true;
    hcOptions.tooltip.positioner = function(labelWidth, labelHeight, point) {
      return tooltipPositioner(labelWidth, labelHeight, point, this.chart);
    }
  }
}

function tooltipPositioner(labelWidth, labelHeight, point, chart) {
  var tooltipX, tooltipY;
  if (point.plotX + labelWidth > chart.plotWidth) {
    tooltipX = point.plotX + chart.plotLeft - labelWidth - 20;
  } else {
    tooltipX = point.plotX + chart.plotLeft + 20;
  }
  tooltipY = point.plotY + chart.plotTop - 20;
  return {
    x: tooltipX,
    y: tooltipY
  };
}

function hc_addLineChartOptions(hcOptions, chartProps, chartData, isUI, chartType) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  hcOptions.plotOptions = {};
  for (i = 0; i < chartData.series.length; i++) {
    var seriesChartType = chartData.series[i].series_plot_type;
    if (seriesChartType === 'line' || seriesChartType === 'step_line') {
      hc_setZoomTypeForSlowMetric(chartData, hcOptions);
      hcOptions.chart.type = 'line';
    } else if (seriesChartType === 'area')
      hcOptions.chart.type = 'area';
    else if (seriesChartType === 'line_bar') {
      hcOptions.chart.type = 'column';
      hc_setZoomTypeForSlowMetric(chartData, hcOptions);
      hc_addSummaryDataToLegendForSlowMetric(chartData, hcOptions, isUI);
    } else if (seriesChartType === 'spline')
      hcOptions.chart.type = 'spline';
    if (isUI) {
      if (hcOptions.tooltip === undefined)
        hcOptions.tooltip = {};
      hcOptions.tooltip.shared = false;
      hcOptions.tooltip.formatter = hc_formatGeneralLineBarToolTip;
      hcOptions.plotOptions[hcOptions.chart.type] = {};
      hcOptions.plotOptions[hcOptions.chart.type].point = hcOptions.plotOptions[hcOptions.chart.type].point || {};
      hcOptions.plotOptions[hcOptions.chart.type].point.events = hcOptions.plotOptions[hcOptions.chart.type].events || {};
      hcOptions.plotOptions[hcOptions.chart.type].point.events.click = hc_dataPointClicked;
    }
  }
}

function hc_addAvailChartOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (hcOptions.tooltip == undefined)
    hcOptions.tooltip = {};
  if ('sub_series' in chartData.series[0]) {
    if (isUI)
      hcOptions.tooltip.formatter = hc_formatStackedBarToolTip;
  } else {
    hcOptions.legend.enabled = false;
    if (isUI)
      hcOptions.tooltip.formatter = hc_formatToolTip;
  }
  hcOptions.yAxis[0].min = 0;
  hcOptions.yAxis[0].max = 100;
  hcOptions.yAxis[0].tickInterval = 10;
}

function hc_addHistogramOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addBarChartOptions(hcOptions, chartProps, chartData, 'column', isUI);
  hcOptions.plotOptions.column.pointPadding = 0;
  hcOptions.plotOptions.column.groupPadding = 0;
  hcOptions.plotOptions.column.borderWidth = 0.5;
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatHistToolTip;
    hcOptions.plotOptions.column.point = {};
    hcOptions.plotOptions.column.point.events = {};
    hcOptions.plotOptions.column.point.events.click = '';
  }
  hcOptions.legend.enabled = false;
}

function hc_addCommonBarChartOptions(hcOptions, chartProps, chartData, barType, isUI) {
  hcOptions.chart.type = barType;
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hcOptions.plotOptions = {};
  hcOptions.plotOptions.series = {};
  if (barType == 'column') {
    hc_addSlantLabelOptions(hcOptions, chartProps, true);
    hcOptions.plotOptions.column = {};
    hcOptions.plotOptions.column.groupPadding = 0;
    if ('bar_spacing' in chartProps.report_properties)
      hcOptions.plotOptions.column.pointPadding = chartProps.report_properties.bar_spacing;
    if (isUI) {
      hcOptions.plotOptions.column = hcOptions.plotOptions.column || {};
      hcOptions.plotOptions.column.point = hcOptions.plotOptions.column.point || {};
      hcOptions.plotOptions.column.point.events = hcOptions.plotOptions.column.point.events || {};
      hcOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
    }
  } else if (barType == 'bar') {
    hc_addSlantLabelOptions(hcOptions, chartProps, false);
    hcOptions.xAxis.labels.y = 0;
    hcOptions.plotOptions.bar = {};
    hcOptions.plotOptions.bar.groupPadding = 0;
    if ('bar_spacing' in chartProps.report_properties)
      hcOptions.plotOptions.bar.pointPadding = chartProps.report_properties.bar_spacing;
    if (isUI) {
      hcOptions.plotOptions.bar.point = hcOptions.plotOptions.bar.point || {};
      hcOptions.plotOptions.bar.point.events = hcOptions.plotOptions.bar.point.events || {};
      hcOptions.plotOptions.bar.point.events.click = hc_dataPointClicked;
    }
  }
  if (isUI) {
    hcOptions.tooltip.formatter = hc_formatToolTip;
    hcOptions.plotOptions.column = hcOptions.plotOptions.column || {};
    hcOptions.plotOptions.column.point = hcOptions.plotOptions.column.point || {};
    hcOptions.plotOptions.column.point.events = hcOptions.plotOptions.column.point.events || {};
    hcOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
  }
}

function hc_getXAxisLabelStyle(chartProps, isUI) {
  return hc_getAxisLabelStyle(chartProps.report_properties.x_axis_label_color_value, chartProps.report_properties.x_axis_label_size,
    chartProps.report_properties.x_axis_label_bold, chartProps.defaultFontFamily, isUI);
}

function hc_getYAxisLabelStyle(chartProps, isUI) {
  return hc_getAxisLabelStyle(chartProps.report_properties.y_axis_label_color_value, chartProps.report_properties.y_axis_label_size,
    chartProps.report_properties.y_axis_label_bold, chartProps.defaultFontFamily, isUI);
}

function hc_getAxisLabelStyle(axis_label_color_value, axis_label_size, axis_label_bold, fontFamily, isUI) {
  var style = {};
  style.fontFamily = fontFamily;
  style.color = axis_label_color_value;
  style.fontSize = axis_label_size + 'px';
  if (axis_label_bold)
    style.fontWeight = 'bold';
  if (isUI && window.isMSIE) {
    style.backgroundColor = '#fff';
  }
  return style;
}

function unescapeHtmlInput(input) {
  var el = document.createElement('div');
  el.innerHTML = input;
  return el.childNodes.length === 0 ? "" : el.childNodes[0].nodeValue;
}

function hc_axisTitleDisplayText(axisTitle, isUI) {
  if (isUI) {
    var axisLabel = document.createElement('tspan');
    axisLabel.textContent = unescapeHtmlInput(axisTitle);
    axisLabel.setAttribute('title', unescapeHtmlInput(axisTitle));
    return axisLabel.outerHTML;
  } else
    return '<tspan  title="' + axisTitle + '">' + axisTitle + '</tspan>';
}

function hc_buildAxisTitle(axisTitleText, axisTitleBold, axisTitleSize, axisTitleColor, fontFamily, width, isUI) {
  var title = {
    text: axisTitleText,
    useHTML: "true",
    style: {
      fontFamily: fontFamily,
      fontWeight: axisTitleBold ? "bold" : "normal",
      fontSize: axisTitleSize + "px",
      color: axisTitleColor,
      maxWidth: width ? (width - 80) + "px" : "300px",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      "-o-text-overflow": "ellipsis",
      "-ms-text-overflow": "ellipsis",
      "-moz-text-overflow": "ellipsis",
      "white-space": "nowrap",
      "word-wrap": "normal",
      "position": "relative"
    }
  }
  return title;
}

function hc_addHeatmapAxisCategories(hcOptions, chartData) {
  hcOptions.xAxis = {};
  hcOptions.xAxis.categories = fetchAxisCategory(chartData.series[0].xAxisCategories);
  hcOptions.xAxis.title = null;
  hcOptions.xAxis.labels = {};
  hcOptions.xAxis.labels.rotation = -45;
  var yAxis = {};
  yAxis.categories = fetchAxisCategory(chartData.series[0].yAxisCategories);
  yAxis.title = null;
  if (hcOptions.yAxis != undefined)
    yAxis.max = hcOptions.yAxis[0].categories.length - 1;
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addBubbleAxisCategories(hcOptions, chartData) {
  hcOptions.xAxis = {};
  hcOptions.xAxis.title = {};
  hcOptions.xAxis.title.text = chartData.series[0].xAxis;
  hcOptions.yAxis = {};
  hcOptions.yAxis.title = {};
  hcOptions.yAxis.title.text = chartData.series[0].yAxis;
}

function getCategoriesFromJSONArray(category) {
  return category.fieldValues[0].value;
}

function fetchAxisCategory(categories) {
  axisCategories = [];
  if (categories) {
    for (var i = 0; i < categories.length; i++) {
      axisCategories.push(categories[i].fieldValues[0].value)
    }
  }
  return axisCategories;
}

function hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI) {
  var label_style = hc_getXAxisLabelStyle(chartProps, isUI);
  hcOptions.xAxis = {};
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.xAxis.type = 'datetime';
  } else {
    hcOptions.xAxis.categories = [];
    hcOptions.xAxis.categories = chartProps.xValues;
  }
  hcOptions.xAxis.labels = {};
  hcOptions.xAxis.labels.style = label_style;
  hcOptions.xAxis.opposite = chartProps.report_properties.x_axis_opposite;
  hcOptions.xAxis.title = {};
  var xTitleText = chartProps.report_properties.x_axis_title;
  xTitleText = xTitleText === '' || xTitleText === undefined ? '' : xTitleText;
  hcOptions.xAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(xTitleText, isUI), chartProps.report_properties.x_axis_title_bold,
    chartProps.report_properties.x_axis_title_size, chartProps.report_properties.x_axis_title_color_value,
    chartProps.defaultFontFamily, hcOptions.chart.width, isUI);
  if (chartProps.report_properties.x_axis_display_grid) {
    hcOptions.xAxis.gridLineWidth = chartProps.report_properties.x_axis_grid_width;
    hcOptions.xAxis.gridLineColor = chartProps.report_properties.x_axis_grid_color_value;
    if (chartProps.report_properties.x_axis_grid_dotted)
      hcOptions.xAxis.gridLineDashStyle = 'dot';
  } else {
    hcOptions.xAxis.gridLineWidth = 0;
  }
  var yAxis = {};
  yAxis.labels = {};
  yAxis.labels.style = hc_getYAxisLabelStyle(chartProps, isUI);
  if (chartProps.report_properties.y_axis_display_grid) {
    yAxis.gridLineWidth = chartProps.report_properties.y_axis_grid_width;
    yAxis.gridLineColor = chartProps.report_properties.y_axis_grid_color_value;
    if (chartProps.report_properties.y_axis_grid_dotted)
      yAxis.gridLineDashStyle = 'dot';
  } else {
    yAxis.gridLineWidth = 0;
  }
  yAxis.title = {};
  yAxis.title.margin = 20;
  yAxis.opposite = chartProps.report_properties.y_axis_opposite;
  yAxis.title.useHTML = true;
  yAxis.title.style = {};
  var yTitleText = chartProps.report_properties.y_axis_title;
  yTitleText = yTitleText === '' || yTitleText === undefined ? chartData.series[0].yTitle : yTitleText;
  yAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(yTitleText, isUI), chartProps.report_properties.y_axis_title_bold,
    chartProps.report_properties.y_axis_title_size, chartProps.report_properties.y_axis_title_color_value,
    chartProps.defaultFontFamily, hcOptions.chart.height, isUI);
  if (isUI && window.isMSIE) {
    yAxis.title.style.backgroundColor = '#ffffff';
  }
  if (chartProps.aggType == 'COUNT')
    yAxis.allowDecimals = false;
  hcOptions.yAxis = [];
  hcOptions.yAxis.push(yAxis);
}

function hc_addSlantLabelOptions(hcOptions, chartProps, xaxis) {
  var minLabelsToSlant = 5;
  if ('slant_axis_labels' in chartProps.report_properties)
    minLabelsToSlant = chartProps.report_properties.slant_axis_labels;
  if (chartProps.xValues.length >= minLabelsToSlant) {
    hcOptions.xAxis.labels.rotation = -45;
    hcOptions.xAxis.labels.align = hcOptions.xAxis.opposite ? 'left' : 'right';
  }
  if (!xaxis) {
    hcOptions.yAxis[0].labels.rotation = -45;
    hcOptions.yAxis[0].labels.align = hcOptions.yAxis[0].opposite ? 'left' : 'right';
  }
}

function hc_addParetoChartOptions(hcOptions, chartProps, total, isUI) {
  var bar_yAxis = hcOptions.yAxis;
  bar_yAxis.lineWidth = 1;
  hcOptions.yAxis = bar_yAxis;
  var percent_axis = {};
  percent_axis.title = {};
  if (isUI)
    percent_axis.title.margin = 20;
  percent_axis.title.style = {};
  percent_axis.title.text = "Percent";
  percent_axis.title.style.color = chartProps.blackColor;
  percent_axis.title.style.fontFamily = chartProps.defaultFontFamily;
  percent_axis.title.style.fontSize = chartProps.fontSize;
  if (isUI && window.isMSIE) {
    percent_axis.title.style.backgroundColor = '#ffffff';
  }
  percent_axis.alignTicks = false;
  percent_axis.gridLineWidth = 0;
  percent_axis.lineColor = '#999';
  percent_axis.lineWidth = 1;
  percent_axis.tickColor = '#666';
  percent_axis.tickWidth = 1;
  percent_axis.tickLength = 3;
  percent_axis.tickInterval = parseFloat(total) / 10;
  percent_axis.endOnTick = false;
  percent_axis.opposite = true;
  percent_axis.linkedTo = 0;
  percent_axis.labels = {};
  if (isUI) {
    percent_axis.labels.formatter = function() {
      var pcnt = Highcharts.numberFormat((this.value / parseFloat(total) * 100), 0, '.');
      return pcnt + '%';
    }
  } else {
    percent_axis.labels.formatter = 'hc_formatParetoAxisLabels_' + total + '_';
  }
  percent_axis.labels.style = hc_getYAxisLabelStyle(chartProps, isUI);
  percent_axis.plotLines = [];
  var percent_plot = {};
  percent_plot.color = 'blue';
  percent_plot.width = 2;
  percent_plot.value = 0.80 * total;
  percent_axis.plotLines.push(percent_plot);
  hcOptions.yAxis.push(percent_axis);
  hcOptions.legend.enabled = false;
}

function hc_addControlChartOptions(hcOptions, chartProps, chartData, isUI) {
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (isUI) {
    hcOptions.plotOptions = {};
    hcOptions.plotOptions.line = {};
    hcOptions.plotOptions.line.point = {};
    hcOptions.plotOptions.line.point.events = {};
    hcOptions.plotOptions.line.point.events.click = hc_dataPointClicked;
    hcOptions.tooltip.formatter = hc_formatControlToolTip;
  }
}

function hc_addBoxChartOptions(hcOptions, chartProps, chartData, isUI) {
  hcOptions.chart.type = 'boxplot';
  hcOptions.legend.enabled = false;
  hc_addXYChartOptions(hcOptions, chartProps, chartData, isUI);
  hc_addSlantLabelOptions(hcOptions, chartProps, true);
  if (isUI)
    hcOptions.tooltip.followPointer = true;
}

function hc_addYAxisMax(chartProps, hcOptions, chartData, chartType) {
  if (chartType == 'pareto')
    return;
  var seriesData = chartData.series[0];
  if (chartData.report_properties_series != undefined && chartData.report_properties_series[0].bar_unstack === true) {
    hcOptions.yAxis[0].startOnTick = true;
    hcOptions.yAxis[0].endOnTick = true;
  } else {
    if ((chartData.report_properties_series[0].y_axis_to === undefined ||
        chartData.report_properties_series[0].y_axis_to === '') &&
      seriesData.ymax !== undefined && seriesData.ymax !== '')
      hcOptions.yAxis[0].max = parseFloat(seriesData.ymax);
  }
}

function hc_addYAxisMaxSeries(seriesProps, hcOptions, seriesData, iSerie) {
  if (seriesData.series_plot_type == 'pareto')
    return;
  if (hcOptions.yAxis[iSerie] == undefined)
    return;
  if (seriesProps.bar_unstack != undefined && seriesProps.bar_unstack === true) {
    hcOptions.yAxis[iSerie].startOnTick = true;
    hcOptions.yAxis[iSerie].endOnTick = true;
  }
  if (seriesProps.y_axis_from !== undefined && seriesProps.y_axis_from !== '')
    hcOptions.yAxis[iSerie].min = seriesProps.y_axis_from;
  if (seriesProps.y_axis_to !== undefined && seriesProps.y_axis_to !== '')
    hcOptions.yAxis[iSerie].max = seriesProps.y_axis_to;
}

function hc_addYAxisIfNedded(hcOptions, chartProps, chartPropsSerie, seriesData, isUI, iSerie) {
  if (chartPropsSerie == null)
    return;
  if (chartPropsSerie.show_y_axis == true) {
    var yAxis = JSON.parse(JSON.stringify(hcOptions.yAxis[0]));
    yAxis.title = hc_buildAxisTitle(hc_axisTitleDisplayText(chartPropsSerie.y_axis_title, isUI), chartProps.report_properties.y_axis_title_bold,
      chartProps.report_properties.y_axis_title_size, chartProps.report_properties.y_axis_title_color_value,
      chartProps.defaultFontFamily, hcOptions.chart.height, isUI);
    yAxis.min = null;
    yAxis.max = null;
    yAxis.opposite = true;
    yAxis.showEmpty = true;
    var color = seriesData.colors != undefined ? seriesData.colors[0] : '';
    if (yAxis.labels == undefined)
      yAxis.labels = {};
    yAxis.labels.formatter = null;
    if (yAxis.title.style == undefined)
      yAxis.title.style = {};
    if (chartPropsSerie.y_axis_from != undefined && chartPropsSerie.y_axis_from != '')
      yAxis.min = chartPropsSerie.y_axis_from;
    if (chartPropsSerie.y_axis_to != undefined && chartPropsSerie.y_axis_to != '')
      yAxis.max = chartPropsSerie.y_axis_to;
    hcOptions.yAxis.push(yAxis);
    return hcOptions.yAxis.length - 1;
  } else
    return 0;
}

function hc_createMultipleSeriesData(hcOptions, chartData, chartProps, isUI) {
  var series = [];
  if (isUI && isAccessibilityPatternsEnabled())
    hc_enableAccessibility(hcOptions, chartData, chartProps.chartType);
  var showYAxis;
  var yAxisProps = {};
  for (var i = 0; i < chartData.series.length; i++) {
    var yAxisIndex = 0;
    var seriesData = chartData.series[i];
    var seriesName = seriesData.series_name;
    var chartPropsSerie;
    if (!chartData.report_properties_series)
      chartPropsSerie = chartProps;
    else
      chartPropsSerie = chartData.report_properties_series[i];
    if (i > 0)
      yAxisIndex = hc_addYAxisIfNedded(hcOptions, chartProps, chartPropsSerie, seriesData, isUI, i);
    yAxisProps[i] = yAxisIndex;
    if ('sub_series' in seriesData) {
      var stackedSeries = hc_createStackedSeriesData(hcOptions, seriesData, chartProps, isUI, chartPropsSerie, i, yAxisIndex, chartData.series.length > 1);
      for (j = 0; j < stackedSeries.length; j++) {
        stackedSeries[j]['zIndex'] = 999 - i;
        hc_addYAxisMaxSeries(chartPropsSerie, hcOptions, seriesData, stackedSeries[j]['yAxis']);
      }
      series.push.apply(series, stackedSeries);
    } else {
      if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
        var iYAxis = i;
        if (hcOptions.yAxis[i] == undefined)
          iYAxis = 0;
        if (hcOptions.yAxis[iYAxis].labels != undefined) {
          if (isUI)
            hcOptions.yAxis[iYAxis].labels.formatter = hc_formatDurationLabel;
          else
            hcOptions.yAxis[iYAxis].labels.formatter = 'hc_formatDurationLabel';
        }
      }
      var serie = {};
      var yMin = 0;
      serie['name'] = seriesName;
      serie['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartPropsSerie.bar_unstack);
      serie['data'] = [];
      serie['zIndex'] = 999 - i;
      serie['stack'] = seriesName;
      serie['yAxis'] = 0;
      if (chartPropsSerie.show_y_axis === true)
        serie['yAxis'] = yAxisIndex;
      hc_addYAxisMaxSeries(chartPropsSerie, hcOptions, seriesData, serie['yAxis']);
      hc_seriesStyle(serie['type'], chartPropsSerie, serie, seriesData, isUI, i, false);
      var firstColor;
      for (var j = 0; j < seriesData.xvalues.length; j++) {
        if (j == 0)
          firstColor = seriesData.colors[0];
        var dataPoint = hc_createSingleSeriesDataPt(chartProps, j, seriesData, isUI, chartPropsSerie, firstColor, hcOptions);
        serie.data.push(dataPoint);
        if (dataPoint['y'] && dataPoint['y'] < yMin)
          yMin = dataPoint['y'];
      }
      serie['color'] = firstColor;
      if (isLineType(seriesData.series_plot_type) && (chartPropsSerie.y_axis_from === undefined ||
          chartPropsSerie.y_axis_from === '') &&
        (!hcOptions.yAxis[yAxisProps[i]].min || yMin < hcOptions.yAxis[yAxisProps[i]].min)) {
        hcOptions.yAxis[yAxisProps[i]].min = yMin;
      }
      if ("step_line" == seriesData.series_plot_type)
        serie['step'] = "center";
      series.push(serie);
    }
  }
  return series;
}

function hc_createHeatmapSeriesData(chartData, chartProps, isUI) {
  var chartPropsSerie = chartData.report_properties_series[0];
  var seriesData = chartData.series[0];
  var series = {};
  series['name'] = seriesData.series_name;
  series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
  series['data'] = [];
  for (var j = 0; j < seriesData.series.data.length; j++) {
    var dataPoint = hc_createHeatmapSeriesDataPt(chartProps, j, seriesData, chartPropsSerie, isUI);
    series.data.push(dataPoint);
  }
  series['borderWidth'] = 0.5;
  series['borderColor'] = chartData.report_properties.axis_max_color;
  return series;
}

function hc_createMapSeriesData(hcOptions, chartData, chartProps, isUI) {
  var series;
  var mapData = chartData.report_properties_series[0].map_source;
  var map = JSON.parse(mapData.map_json);
  var isGeographicalMap = mapData.is_geographical_map;
  if (isGeographicalMap) {
    var useLatLon = mapData.use_lat_lon;
    if (useLatLon)
      series = hc_createMapSeriesDataLatLon(chartData, chartProps, map, isUI);
    else
      series = hc_createMapSeriesDataHcKey(hcOptions, chartData, chartProps, map, isUI);
  } else {
    series = hc_createMapSeriesDataHcKeyNonGeographical(chartData, chartProps, map, isUI);
  }
  return series;
}

function hc_createMapSeriesDataLatLon(chartData, chartProps, map, isUI) {
  var series = [];
  var serie = {};
  serie['mapData'] = map;
  serie['name'] = 'Basemap';
  serie['borderColor'] = '#C2C2C2';
  serie['showInLegend'] = false;
  series.push(serie);
  serie = {};
  serie['name'] = 'Separators';
  serie['type'] = 'mapline';
  serie['data'] = Highcharts.geojson(map, 'mapline');
  serie['color'] = '#C2C2C2';
  serie['showInLegend'] = false;
  serie['enableMouseTracking'] = false;
  series.push(serie);
  var dataArray = [];
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name;
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  serie = {};
  serie['name'] = seriesName;
  serie['type'] = 'mappoint';
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    dataArray.push(data);
  }
  serie['data'] = dataArray;
  series.push(serie);
  return series;
}

function hc_createMapSeriesDataHcKey(hcOptions, chartData, chartProps, map, isUI) {
  var dataArray = [];
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name;
  var series = [];
  var serie = {};
  serie['mapData'] = map;
  serie['name'] = seriesName;
  serie['showInLegend'] = false;
  var joinBy = chartData.report_properties_series[0].map_source.join_by_column;
  serie['joinBy'] = [joinBy, 'name'];
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationHcKeyPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    if (data['name'] !== '')
      dataArray.push(data);
  }
  serie['data'] = dataArray;
  if (serie['data'].length == 0)
    hcOptions.legend.enabled = false;
  series.push(serie);
  return series;
}

function hc_createMapSeriesDataHcKeyNonGeographical(chartData, chartProps, map, isUI) {
  var series = [];
  var serie = {};
  serie['type'] = 'map';
  serie['showInLegend'] = false;
  var joinBy = chartData.report_properties_series[0].map_source.join_by_column;
  serie['joinBy'] = [joinBy, 'name'];
  serie['mapData'] = map;
  var chartPropsSerie;
  if (chartData.report_properties_series == undefined)
    chartPropsSerie = chartProps;
  else
    chartPropsSerie = chartData.report_properties_series[0];
  var dataArray = [];
  var seriesData = chartData.series[0];
  for (var j = 0; j < seriesData.xvalues.length; j++) {
    var data = hc_createSingleSeriesDataLocationHcKeyPt(chartProps, j, seriesData, isUI, chartPropsSerie);
    dataArray.push(data);
  }
  serie['data'] = dataArray;
  series.push(serie);
  return series;
}

function hc_createBubbleSeriesData(chartData, chartProps, isUI) {
  var chartPropsSerie = chartData.report_properties_series[0];
  var seriesData = chartData.series[0];
  var bubbleSeriesData = [];
  for (var i = 0; i < seriesData.series.length; i++) {
    var series = {};
    series['name'] = seriesData.series[i].name;
    series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
    series['data'] = [];
    for (var j = 0; j < seriesData.series[i].data.length; j++) {
      var dataPoint = hc_createBubbleSeriesDataPt(chartProps, j, seriesData.series[i].data, chartPropsSerie, isUI, seriesData.table_name);
      series.data.push(dataPoint);
    }
    bubbleSeriesData.push(series);
  }
  return bubbleSeriesData;
}

function hc_uniqueId() {
  var randomLetters = 6;
  var letters = '';
  for (var i = 0; i < randomLetters; i++)
    letters += String.fromCharCode(Math.floor(Math.random() * 26) + 97);
  var k = Math.floor(Math.random() * 1000000);
  return Date.now() + '-' + letters + '-' + k;
}

function getPatterns(uniqueId) {
  var colors = Highcharts.getOptions().colors;
  var id = uniqueId || hc_uniqueId();
  return [
    'M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11',
    'M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9',
    'M 3 0 L 3 10 M 8 0 L 8 10',
    'M 0 3 L 10 3 M 0 8 L 10 8',
    'M 0 3 L 5 3 L 5 0 M 5 10 L 5 7 L 10 7',
    'M 3 3 L 8 3 L 8 8 L 3 8 Z',
    'M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0',
    'M 10 3 L 5 3 L 5 0 M 5 10 L 5 7 L 0 7',
    'M 2 5 L 5 2 L 8 5 L 5 8 Z',
    'M 0 0 L 5 10 L 10 0',
  ].map(function eachPattern(pattern, i) {
    return {
      id: 'highcharts-custom-pattern-' + id + '-' + i,
      width: 10,
      height: 10,
      path: {
        d: pattern,
      },
      color: colors[i],
    };
  });
}

function getDashStyles() {
  return [
    'Solid',
    'ShortDash',
    'ShortDot',
    'ShortDashDot',
    'ShortDashDotDot',
    'Dot',
    'Dash',
    'LongDash',
    'DashDot',
    'LongDashDot',
    'LongDashDotDot'
  ];
}

function hc_enableAccessibility(hcOptions, chartData, chartType) {
  chartData.series.forEach(function a11ySeries(serie, i) {
    chartData.series[i].colors.forEach(function a11yColor(color, j) {
      if (isLineType(chartType) && chartType !== 'line_bar' && chartType !== 'area')
        chartData.series[i].colors[j] = '#000';
      else
        chartData.series[i].colors[j] = {
          pattern: getPatterns()[j % 10]
        };
    });
  });
}

function hc_createSingleSeriesData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  if (isUI && isAccessibilityPatternsEnabled())
    hc_enableAccessibility(hcOptions, chartData, chartProps.chartType);
  var chartPropSerie = chartData.report_properties_series[0];
  var seriesName = seriesData.series_name;
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var series = {};
  var yMin = 0;
  series['name'] = seriesName;
  series['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartData.report_properties.bar_unstack);
  series['data'] = [];
  if (chartProps.chartType == 'angular_gauge' || chartProps.chartType == 'solid_gauge') {
    var point = {};
    point.y = parseFloat(seriesData.yvalues);
    point.y_tooltip = seriesData.ydisplayvalues;
    point.displayvalue = seriesData.ydisplayvalues;
    point.table = seriesData.table_name;
    point.click_url_info = chartPropSerie.filter;
    if ('list_ui_view_name' in chartPropSerie)
      point['list_ui_view_name'] = chartPropSerie.list_ui_view_name;
    if ('report_drilldown' in chartPropSerie)
      point['report_drilldown'] = chartPropSerie.report_drilldown;
    if ('drill_open_new_win' in chartProps.report_properties)
      point['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      point['widget_navigation'] = chartProps.report_properties.widget_navigation;
      point['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
    series.data.push(point);
    return series;
  }
  if (isLineType(seriesData.series_plot_type))
    series['color'] = seriesData.colors[0];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = hc_createSingleSeriesDataPt(chartProps, j, seriesData, isUI, chartPropSerie, undefined, hcOptions);
    series.data.push(dataPoint);
    if (dataPoint['y'] && dataPoint['y'] < yMin)
      yMin = dataPoint['y'];
  }
  if (isLineType(chartProps.chartType) && (chartProps.report_properties.y_axis_from === undefined ||
      chartProps.report_properties.y_axis_from === ''))
    hcOptions.yAxis[0].min = yMin;
  if (chartProps.chartType == 'donut' || chartProps.chartType == 'semi_donut') {
    series['total'] = seriesData.display_human_readable_total;
    series['total_value'] = seriesData.display_grid_total;
  }
  return series;
}

function hc_hasAxes(chartType) {
  return !(chartType === 'angular_gauge' || chartType === 'solid_gauge' || chartType === 'pie' ||
    chartType === 'solid_gauge' || chartType === 'funnel' || chartType === 'donut' ||
    chartType === 'semi_donut' || chartType === 'pyramid');
}

function hc_createStackedSeriesData(hcOptions, seriesData, chartProps, isUI, chartPropsSerie, serieIndex, yAxisIndex, isMultiseries) {
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType) && (yAxisIndex == 0 || (yAxisIndex > 0 && chartPropsSerie.show_y_axis == true))) {
    if (hcOptions.yAxis[yAxisIndex] == undefined) {
      hcOptions.yAxis[yAxisIndex] = {};
      hcOptions.yAxis[yAxisIndex].labels = {};
    }
    if (isUI)
      hcOptions.yAxis[yAxisIndex].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[yAxisIndex].labels.formatter = 'hc_formatDurationLabel';
  }
  var x2Vals = seriesData.x2values;
  var x2Colors = seriesData.colors;
  var subSeriesList = seriesData.sub_series;
  var subSeriesDataArray = [];
  for (var j = 0; j < seriesData.xvalues.length; j++)
    subSeriesDataArray.push(subSeriesList[j]);
  var series = [];
  var yMin = 0;
  var isSlowMetricTable = hc_isSlowMetricChart(hcOptions, seriesData);
  hcOptions.yAxis[yAxisIndex].reversedStacks = chartPropsSerie.bar_unstack || false;
  for (var i = 0; i < x2Vals.length; i++) {
    var subseries = {};
    subseries.name = x2Vals[i].displayValue;
    if (chartProps.report_properties != undefined && isMultiseries)
      subseries.name = '[' + seriesData.series_name + '] ' + subseries.name;
    subseries.data = [];
    subseries['type'] = hc_getHighChartsType(seriesData.series_plot_type, chartPropsSerie.bar_unstack);
    subseries['legend_label_max_length'] = chartPropsSerie.legend_label_max_size;
    subseries['id'] = seriesData.series_name;
    subseries['stack'] = seriesData.series_name;
    subseries['yAxis'] = yAxisIndex;
    if (isUI && isAccessibilityPatternsEnabled())
      subseries['dashStyle'] = getDashStyles()[i % x2Vals.length];
    if (chartPropsSerie.show_y_axis === true)
      subseries['yAxis'] = yAxisIndex;
    hc_seriesStyle(subseries['type'], chartPropsSerie, subseries, seriesData, isUI, serieIndex, true);
    hc_addPropsForDataLabelsTruncation(subseries, chartPropsSerie);
    var dataExistsForX2Val = false;
    var categoryIndx;
    var max = Number.MIN_VALUE;
    var min = Number.MAX_VALUE;
    var total = 0;
    var count = 0;
    for (var j = 0; j < seriesData.xvalues.length; j++) {
      var subSeriesData = subSeriesDataArray[j];
      categoryIndx = j;
      var dataPoint = hc_initStackedSeriesDataPoint(i, j, x2Vals, x2Colors, chartProps, seriesData.table_name, seriesData.table_display_plural, isUI, chartPropsSerie, seriesData, categoryIndx);
      var dataFilled = false;
      if (subSeriesData && subSeriesData.xvalues) {
        for (var k = 0; k < subSeriesData.xvalues.length; k++) {
          if (x2Vals[i].value == subSeriesData.xvalues[k].value ||
            x2Vals[i].value == subSeriesData.xvalues[k]
          ) {
            dataExistsForX2Val = true;
            dataFilled = true;
            hc_fillStackedSeriesDataPoint(dataPoint, k, subSeriesData, chartProps, isUI, chartPropsSerie, categoryIndx, isSlowMetricTable, chartProps.xValues[j]);
            break;
          }
        }
      }
      if (!isSlowMetricTable || dataFilled) {
        subseries.data.push(dataPoint);
        if (isSlowMetricTable && dataPoint['y']) {
          max = Math.max(max, dataPoint['y']);
          min = Math.min(min, dataPoint['y']);
          total += dataPoint['y'];
          count++;
        }
      }
      if (dataPoint['y'] && dataPoint['y'] < yMin)
        yMin = dataPoint['y'];
    }
    if (isSlowMetricTable) {
      subseries.max = max;
      subseries.min = min;
      subseries.total = total;
      subseries.average = total / count;
    }
    if (seriesData.series_plot_type === 'step_line')
      subseries.step = 'center';
    if (dataExistsForX2Val) {
      subseries.color = x2Colors[i];
      series.push(subseries);
    }
  }
  if (isLineType(seriesData.series_plot_type) && (chartPropsSerie.y_axis_from === undefined || chartPropsSerie.y_axis_from === ''))
    hcOptions.yAxis[yAxisIndex].min = yMin;
  if (isSlowMetricTable) {
    series.sort(function(x, y) {
      return x.total - y.total;
    });
  }
  return series;
}

function hc_seriesStyle(type, chartPropsSerie, serie, seriesData, isUI, i, stacked) {
  if ('column' === type || 'bar' === type) {
    if (chartPropsSerie.bar_unstack === true)
      serie.stacking = '';
    else
      serie.stacking = 'normal';
  }
  if ('line' === type || 'area' === type || 'spline' === type) {
    var showMarker = chartPropsSerie.show_marker;
    serie.marker = {};
    serie.marker.enabled = showMarker
  }
  serie.color = seriesData.colors[i];
  if ('column' === type || 'bar' === type || isLineType(type) || 'trend' === type) {
    var dataLabelColor = '#606060';
    if (chartPropsSerie.show_chart_data_label === true) {
      serie.dataLabels = {};
      serie.dataLabels.enabled = true;
      serie.dataLabels.softConnector = false;
      serie.dataLabels.distance = 15;
      serie.dataLabels.style = {};
      serie.dataLabels.style.fontFamily = 'Arial';
      serie.dataLabels.style.fontSize = '10pt';
      serie.dataLabels.style.color = dataLabelColor;
      serie.dataLabels.style.fill = dataLabelColor;
      serie.dataLabels.style.fontWeight = 'normal';
      serie.dataLabels.inside = false;
      if (serie.sub_series != undefined)
        serie.dataLabels.inside = true;
      if ('font_family' in chartPropsSerie && chartPropsSerie.font_family != '')
        serie.dataLabels.style.fontFamily = chartPropsSerie.font_family;
      if ('font_size' in chartPropsSerie && chartPropsSerie.font_size != '')
        serie.dataLabels.style.fontSize = chartPropsSerie.font_size;
      if (isUI)
        serie.dataLabels.formatter = hc_formatValueLabel;
      else
        serie.dataLabels.formatter = 'hc_formatValueLabel';
    } else {
      serie.dataLabels = {};
      serie.dataLabels.enabled = false;
    }
  }
  if (isUI) {
    if (isLineType(type) || 'column' === type || 'bar' === type || 'horizontal_bar' === type) {
      serie.tooltip = {};
      if (stacked)
        serie.tooltip.tooltipText = 'stacked';
      else
        serie.tooltip.tooltipText = 'non-stacked';
    }
  }
}

function hc_createParetoCumulSeries(hcOptions, chartProps, series0, isUI) {
  var total = 0;
  var cumulative_totals = [];
  var cumulative_percent = [];
  for (var i = 0; i < series0.data.length; i++) {
    total = parseFloat(total) + parseFloat(series0.data[i].y);
    cumulative_totals.push(total);
  }
  var cuml_percent = 0;
  for (var i = 0; i < series0.data.length; i++) {
    var percent = parseFloat(series0.data[i].y) / parseFloat(total) * 100;
    cuml_percent = parseFloat(cuml_percent) + parseFloat(percent);
    var s = cuml_percent.toString();
    var k = s.indexOf('.');
    if (k >= 0) {
      var sub = s.substring(0, k);
      var rem = s.substring(k + 1);
      if (rem.length > 2) {
        sub += '.';
        for (var j = 0; j < 2; j++)
          sub += rem[j];
      } else
        sub += '.' + rem;
      cumulative_percent.push(sub);
    } else
      cumulative_percent.push(s);
  }
  var cumulative_series = {};
  cumulative_series.type = 'line';
  cumulative_series.name = 'pareto_series';
  cumulative_series.data = [];
  for (var i = 0; i < cumulative_totals.length; i++) {
    var dataPoint = {};
    dataPoint['y'] = cumulative_totals[i];
    dataPoint['percent'] = cumulative_percent[i];
    cumulative_series.data.push(dataPoint);
  }
  hc_addParetoChartOptions(hcOptions, chartProps, total, isUI);
  return cumulative_series;
}

function hc_createSingleSeriesDataPt(chartProps, indx, seriesData, isUI, chartSerieProps, color, hcOptions) {
  var yVal;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = seriesData.xvalues[indx];
  if (chartProps.origXValues[indx] == chartProps.otherKey)
    dataPoint['name'] = chartProps.xValues[indx];
  if (seriesData.yvalues[indx] !== undefined && seriesData.yvalues[indx])
    yVal = parseFloat(seriesData.yvalues[indx]);
  else
    yVal = null;
  var dataPointName = dataPoint['name'];
  if (dataPointName.length > chartProps.maxAllowedLabelLen) {
    dataPointName = dataPointName.substring(0, chartProps.maxAllowedLabelLen - 3) + '...';
  }
  if (hc_isSlowMetricChart(hcOptions, seriesData))
    dataPoint['x'] = hc_convertDateTimeFormatToUnixTime(seriesData.xvalues[indx]);
  else
    dataPoint['x'] = indx;
  dataPoint['y'] = yVal;
  if (!isLineType(seriesData.series_plot_type))
    dataPoint['color'] = seriesData.colors[indx];
  else
    dataPoint['color'] = color;
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  dataPoint['valid'] = (seriesData.valids != undefined ? (seriesData.valids[indx] === "true") : true);
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if (chartProps.chartType == 'hist') {
      dataPoint['tt_label_min'] = chartProps.report_properties.hist_min;
      dataPoint['tt_label_max'] = chartProps.report_properties.hist_max;
      dataPoint['tt_label_cnt'] = chartProps.report_properties.hist_count;
    }
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    generateSeriesUrlInfo(dataPoint, indx, dataPoint['isOther'], seriesData, chartSerieProps, undefined, chartProps, seriesData['table_name']);
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  } else if (chartProps.chartType == 'pie' || chartProps.chartType == 'semi_donut' || chartProps.chartType == 'donut' ||
    chartProps.chartType == 'funnel' || chartProps.chartType == 'pyramid') {
    if ('percentages' in seriesData)
      dataPoint['percent'] = seriesData.percentages[indx];
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function isVariablesGroupby(groupby) {
  return groupby && groupby.startsWith('variables.');
}

function removeNonConditionTerms(filter) {
  var ignoreExpressions = [/^\s*$/, /^ORDERBY/, /^ORDERBYDESC/, /^GROUPBY/, /^TRENDBY/];
  if (!filter)
    return "";
  var terms = filter.split('^');
  var validTerms = [];
  for (var i = 0; i < terms.length; i++) {
    if (isToBeIgnored(terms[i], ignoreExpressions))
      continue;
    validTerms.push(terms[i]);
  }
  var validFilter = validTerms.join('^');
  if (validFilter && validFilter.endsWith('^EQ'))
    validFilter = validFilter.substring(0, validFilter.length - 3);
  return validFilter;
}

function isToBeIgnored(value, ignoreExpressions) {
  for (i = 0; i < ignoreExpressions.length; i++) {
    if (ignoreExpressions[i].test(value))
      return true;
  }
  return false;
}

function combineQueries(filter, aggregateQuery) {
  if (!filter)
    return aggregateQuery;
  if (!aggregateQuery)
    return filter;
  var filterQueries = filter.split('^NQ');
  for (var i = 0; i < filterQueries.length; i++)
    filterQueries[i] += "^" + aggregateQuery;
  return filterQueries.join("^NQ");
}

function generateSeriesUrlInfo(dataPoint, indx, isOther, seriesData, chartSerieProps, aggregateQueryPerSeries, chartProps, tableName) {
  if (isOther) {
    dataPoint['click_url_info'] = generateOtherUrlInfo(indx, chartProps, tableName, chartSerieProps);
    return;
  }
  var categoryItemCondition = '';
  if (isVariablesGroupby(chartSerieProps.groupby) && chartSerieProps.sc_groupby_item_id)
    categoryItemCondition = "^cat_item=" + chartSerieProps.sc_groupby_item_id;
  if (!categoryItemCondition && chartSerieProps.stackby &&
    isVariablesGroupby(chartSerieProps.stackby) && chartSerieProps.sc_stackby_item_id) {
    categoryItemCondition = "^cat_item=" + chartSerieProps.sc_stackby_item_id;
  }
  var aggregateQuery = aggregateQueryPerSeries ? seriesData[indx].aggregate_query : seriesData.aggregate_query[indx];
  var filter = removeNonConditionTerms(chartSerieProps.filter);
  dataPoint['click_url_info'] = combineQueries(combineQueries(filter, categoryItemCondition), aggregateQuery);
  var publisherFilter = removeNonConditionTerms(chartProps.report_properties.publisher_filter);
  dataPoint['publisher_filter'] = combineQueries(combineQueries(publisherFilter, categoryItemCondition), aggregateQuery);
}

function generateOtherUrlInfo(indx, chartProps, tableName, chartSerieProps) {
  var urlObj = {};
  var urlString = 'report_viewer.do?';
  var pagenum = parseInt(chartProps.page_num) + 1;
  if (chartSerieProps.report_id) {
    urlObj = {
      "jvar_report_id": [chartSerieProps.report_id],
      "sysparm_other_series": [chartSerieProps.report_id],
      "sysparm_page_num": [pagenum],
    };
    if (chartProps.interactive_report)
      urlObj.sysparm_interactive_report = chartProps.interactive_report;
  } else {
    var reportProps = chartProps.report_properties;
    if (reportProps) {
      urlObj = {
        "sysparm_bar_unstack": [chartSerieProps.bar_unstack],
        "sysparm_show_chart_total": [reportProps.show_chart_total],
        "sysparm_show_other": [chartProps.show_other],
        "sysparm_lower_limit": [reportProps.lower_limit],
        "sysparm_title": [chartProps.title],
        "sysparm_table": [tableName],
        "sysparm_compute_percent": [reportProps.percents_from_count],
        "sysparm_custom_chart_size": [reportProps.custom_chart_size],
        "sysparm_color_palette": [chartSerieProps.color_palette],
        "sysparm_gauge_autoscale": [reportProps.gauge_autoscale],
        "sysparm_aggregate": [chartProps.aggType],
        "sysparm_show_marker": [chartSerieProps.show_marker],
        "sysparm_show_chart_data_label": [reportProps.show_chart_data_label],
        "sysparm_page_num": [pagenum],
        "sysparm_type": [chartProps.chartType],
        "sysparm_chart_size": [chartProps.chartSize],
        "sysparm_direction": [reportProps.direction],
        "sysparm_field": [chartSerieProps.groupby],
        "sysparm_set_color": [chartSerieProps.set_color],
        "sysparm_funnel_neck_percent": [reportProps.funnel_neck_percent],
        "sysparm_from": [reportProps.from],
        "sysparm_donut_width_percent": [reportProps.donut_width_percent],
        "sysparm_others": [chartProps.other_threshold],
        "sysparm_chart_color": [chartSerieProps.color],
        "sysparm_display_grid": [chartProps.display_grid],
        "sysparm_to": [reportProps.to],
        "sysparm_upper_limit": [reportProps.upper_limit],
        "sysparm_box_field": [chartProps.box_field],
        "sysparm_query": [chartProps.filter_with_orderby],
        "sysparm_sumfield": [chartProps.agg_field],
        "sysparm_stack_field": [chartProps.stack_field],
        "sysparm_trend_field": [chartProps.trend_field],
        "sysparm_trend_interval": [chartProps.trend_interval],
        "sysparm_chart_colors": [chartProps.colors]
      };
      if (reportProps.custom_chart_size) {
        urlObj.sysparm_custom_chart_height = chartProps.chart_height;
        urlObj.sysparm_custom_chart_width = chartProps.chart_width;
      }
    }
  }
  return urlString + jQuery.param(urlObj, true);
}

function hc_createSingleSeriesDataLocationPt(chartProps, indx, seriesData, isUI, chartSerieProps) {
  if (typeof seriesData.locations[indx] === 'undefined')
    return;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = seriesData.locations[indx].city;
  dataPoint['street'] = seriesData.locations[indx].street;
  dataPoint['city'] = seriesData.locations[indx].city;
  dataPoint['state'] = seriesData.locations[indx].state;
  dataPoint['country'] = seriesData.locations[indx].country;
  dataPoint['lat'] = seriesData.locations[indx].latitude;
  dataPoint['lon'] = seriesData.locations[indx].longitude;
  dataPoint['valid'] = (seriesData.valids != undefined ? (seriesData.valids[indx] === "true") : true);
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    if ('click_url_info' in seriesData && seriesData.click_url_info[indx])
      dataPoint['click_url_info'] = seriesData.click_url_info[indx];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    if ('report_drilldown_zoom' in chartSerieProps)
      dataPoint['report_drilldown_zoom'] = chartSerieProps.report_drilldown_zoom;
    if ('report_drilldown_map' in chartSerieProps)
      dataPoint['report_drilldown_map'] = chartSerieProps.report_drilldown_map;
    dataPoint['isLatLon'] = true;
    dataPoint['show_data_label'] = chartSerieProps.show_chart_data_label;
    dataPoint['show_geographical_label'] = chartSerieProps.show_geographical_label;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function hc_createSingleSeriesDataLocationHcKeyPt(chartProps, indx, seriesData, isUI, chartSerieProps) {
  if (typeof seriesData.locations[indx] === 'undefined')
    return;
  var dataPoint = {};
  dataPoint['name'] = seriesData.locations[indx].name;
  dataPoint['y_tooltip'] = seriesData.ydisplayvalues[indx];
  dataPoint['value'] = seriesData.yvalues[indx];
  dataPoint['display_value'] = seriesData.ydisplayvalues[indx];
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (chartProps.origXValues[indx] == chartProps.otherKey)
      dataPoint['isOther'] = true;
    else
      dataPoint['isOther'] = false;
    if ('percents_from_count' in chartProps.report_properties && chartProps.report_properties.percents_from_count)
      dataPoint['percent_count'] = true;
    else
      dataPoint['percent_count'] = false;
    if ('percentages' in seriesData && seriesData.percentages[indx])
      dataPoint['percent'] = seriesData.percentages[indx];
    if ('click_url_info' in seriesData && seriesData.click_url_info[indx])
      dataPoint['click_url_info'] = seriesData.click_url_info[indx];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    if ('report_drilldown_zoom' in chartSerieProps)
      dataPoint['report_drilldown_zoom'] = chartSerieProps.report_drilldown_zoom;
    if ('report_drilldown_map' in chartSerieProps)
      dataPoint['report_drilldown_map'] = chartSerieProps.report_drilldown_map;
    dataPoint['isLatLon'] = false;
    dataPoint['show_data_label'] = chartSerieProps.show_chart_data_label;
    dataPoint['show_geographical_label'] = chartSerieProps.show_geographical_label;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  return dataPoint;
}

function hc_createHeatmapSeriesDataPt(chartProps, indx, seriesData, chartSerieProps, isUI) {
  var xIndex = 0,
    yIndex = 1,
    valueIndex = 2,
    displayValueIndex = 3,
    tooltipIndex = 4,
    clickUrlIndex = 5;
  var val;
  var dataPoint = {};
  dataPoint['legend_label_max_length'] = chartProps.report_properties.legend_label_max_size;
  dataPoint['name'] = chartProps.origXValues[indx];
  dataPoint['x'] = seriesData.series.data[indx][xIndex];
  dataPoint['y'] = seriesData.series.data[indx][yIndex];
  if (seriesData.series.data[indx][valueIndex] === null)
    val = 0;
  else
    val = parseFloat(seriesData.series.data[indx][valueIndex]);
  dataPoint['value'] = val;
  if (seriesData.series.data[indx][displayValueIndex])
    dataPoint['value_display'] = seriesData.series.data[indx][displayValueIndex];
  else
    dataPoint['value_display'] = '0';
  if (dataPoint['value_display'] === '0' && chartProps.report_properties.show_zero === false)
    dataPoint['value_display'] = '';
  if (isUI) {
    dataPoint['table'] = seriesData.table_name;
    dataPoint['isOther'] = false;
    dataPoint['percent_count'] = false;
    if (seriesData.series.data[indx][clickUrlIndex]) {
      dataPoint['click_url_info'] = generateHeatMapClickUrl(seriesData, indx, clickUrlIndex);
    }
    if (seriesData.series.data[indx][tooltipIndex])
      dataPoint['value_tooltip'] = seriesData.series.data[indx][tooltipIndex];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
  }
  hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
  return dataPoint;
}

function generateHeatMapClickUrl(seriesData, indx, clickUrlIndex) {
  var showOther = seriesData.sysparm_show_other;
  var xAxisCategoryCount = seriesData.xAxisCategories.length;
  var aggregateQuery = seriesData.series.data[indx][clickUrlIndex];
  var filter = removeNonConditionTerms(seriesData.filter);
  if (showOther && (indx + 1) % xAxisCategoryCount === 0 && seriesData.otherQuery) {
    aggregateQuery = aggregateQuery + "^" + seriesData.otherQuery;
  }
  return combineQueries(filter, aggregateQuery);
}

function hc_createBubbleSeriesDataPt(chartProps, indx, seriesData, chartSerieProps, isUI, table_name) {
  var dataPoint = {};
  dataPoint['name'] = chartProps.origXValues[indx];
  dataPoint['x'] = seriesData[indx]['x'];
  dataPoint['y'] = seriesData[indx]['y'];
  dataPoint['z'] = seriesData[indx]['z'];
  dataPoint['value_display'] = seriesData[indx]['value_display'];
  if (isUI) {
    dataPoint['table'] = table_name;
    generateSeriesUrlInfo(dataPoint, indx, false, seriesData, chartSerieProps, true, chartProps, dataPoint['table']);
    dataPoint['value_tooltip'] = seriesData[indx]['value_tooltip'];
    if ('list_ui_view_name' in chartSerieProps)
      dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
    if ('report_drilldown' in chartSerieProps)
      dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  return dataPoint;
}

function hc_initStackedSeriesDataPoint(indx, indx2, x2Vals, x2Colors, chartProps, tblName, tblDispPlural, isUI, serieProps, seriesData, categoryIndx) {
  var dataPoint = {};
  if (categoryIndx != undefined)
    dataPoint['x'] = categoryIndx;
  dataPoint['y'] = serieProps.use_null ? null : 0;
  dataPoint['name'] = x2Vals[indx].displayValue;
  dataPoint['color'] = x2Colors[indx];
  dataPoint['table'] = tblName;
  dataPoint['table_display_plural'] = tblDispPlural;
  dataPoint['isOther'] = false;
  if (chartProps.origXValues[indx2] == chartProps.otherKey)
    dataPoint['isOther'] = true;
  dataPoint['valid'] = false;
  hc_addPropsForDataLabelsTruncation(dataPoint, serieProps);
  return dataPoint;
}

function hc_fillStackedSeriesDataPoint(dataPoint, indx, subSeriesData, chartProps, isUI, chartPropsSerie, categoryIndx, isSlowMetricTable, datetime) {
  dataPoint['valid'] = true;
  if ('percents_from_count' in chartPropsSerie && chartPropsSerie.percents_from_count)
    dataPoint['percent_count'] = true;
  else
    dataPoint['percent_count'] = false;
  if (categoryIndx != undefined)
    dataPoint['x'] = categoryIndx;
  dataPoint['y'] = subSeriesData.yvalues[indx] ? parseFloat(subSeriesData.yvalues[indx]) : null;
  dataPoint['y_tooltip'] = subSeriesData.ydisplayvalues[indx];
  dataPoint['percent'] = subSeriesData.percentages[indx];
  if (isUI) {
    if (dataPoint['isOther'] || (subSeriesData.aggregate_query && subSeriesData.aggregate_query[indx]))
      generateSeriesUrlInfo(dataPoint, indx, dataPoint['isOther'], subSeriesData, chartPropsSerie, undefined, chartProps, dataPoint['table']);
    dataPoint['list_ui_view_name'] = chartPropsSerie.list_ui_view_name;
    dataPoint['report_drilldown'] = chartPropsSerie.report_drilldown;
    dataPoint['drill_open_new_win'] = false;
    if ('drill_open_new_win' in chartProps.report_properties)
      dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
    if ('widget_navigation' in chartProps.report_properties) {
      dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
      dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
    }
  }
  if (isSlowMetricTable) {
    dataPoint['x'] = hc_convertDateTimeFormatToUnixTime(datetime);
  }
}

function hc_createLineSeriesData(hcOptions, chartData, chartProps, isUI) {
  return hc_createMultipleSeriesData(hcOptions, chartData, chartProps, isUI);
}

function hc_createControlSeriesData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var chartSerieProps = chartData.report_properties_series[0];
  var series = [];
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var dataPtSeries = {};
  dataPtSeries.name = 'Data Points';
  dataPtSeries.color = 'black';
  dataPtSeries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = {};
    dataPoint['y'] = seriesData.yvalues[j] ? parseFloat(seriesData.yvalues[j]) : null;
    dataPoint['y_tooltip'] = seriesData.ydisplayvalues[j];
    dataPoint['table'] = seriesData.table_name;
    dataPoint['table_display_plural'] = seriesData.table_display_plural;
    if (isUI) {
      if ('aggregate_query' in seriesData)
        generateSeriesUrlInfo(dataPoint, j, false, seriesData, chartSerieProps, false, chartProps);
      if ('list_ui_view_name' in chartSerieProps)
        dataPoint['list_ui_view_name'] = chartSerieProps.list_ui_view_name;
      if ('report_drilldown' in chartSerieProps)
        dataPoint['report_drilldown'] = chartSerieProps.report_drilldown;
      dataPoint['drill_open_new_win'] = false;
      if ('drill_open_new_win' in chartProps.report_properties)
        dataPoint['drill_open_new_win'] = chartProps.report_properties.drill_open_new_win;
      if ('widget_navigation' in chartProps.report_properties) {
        dataPoint['widget_navigation'] = chartProps.report_properties.widget_navigation;
        dataPoint['widget_navigation_tooltip_text'] = chartProps.report_properties.translation.click_to_open;
      }
    }
    hc_addPropsForDataLabelsTruncation(dataPoint, chartProps.report_properties);
    dataPtSeries.data.push(dataPoint);
  }
  series.push(dataPtSeries);
  var trendLineSeries = {};
  trendLineSeries.name = 'Trend Line';
  if (isUI && isAccessibilityPatternsEnabled()) {
    trendLineSeries.dashStyle = 'LongDashDot'
    trendLineSeries.color = '#000';
  } else
    trendLineSeries.color = 'yellow';
  trendLineSeries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPt = {};
    var y = parseFloat(seriesData.trendvalues[j]);
    dataPt.y = y;
    dataPt.y_tooltip = seriesData.trenddisplayvalues[j];
    hc_addPropsForDataLabelsTruncation(dataPt, chartProps.report_properties);
    trendLineSeries.data.push(dataPt);
  }
  series.push(trendLineSeries);
  var controlVals = seriesData.controlvalues;
  var displayVals = [];
  displayVals.push(seriesData.controldisplayvalues[0]);
  displayVals.push(seriesData.controldisplayvalues[1]);
  displayVals.push(seriesData.controldisplayvalues[2]);
  displayVals.push(seriesData.controldisplayvalues[3]);
  displayVals.push(seriesData.controldisplayvalues[4]);
  series.push(hc_createControlPlotLine('-3Z', 'red', parseFloat(controlVals[0]), displayVals[0], chartProps, isUI));
  series.push(hc_createControlPlotLine('-2Z', 'green', parseFloat(controlVals[1]), displayVals[1], chartProps, isUI));
  series.push(hc_createControlPlotLine('Mean', 'blue', parseFloat(controlVals[2]), displayVals[2], chartProps, isUI));
  series.push(hc_createControlPlotLine('+2Z', 'green', parseFloat(controlVals[3]), displayVals[3], chartProps, isUI));
  series.push(hc_createControlPlotLine('+3Z', 'red', parseFloat(controlVals[4]), displayVals[4], chartProps, isUI));
  return series;
}

function hc_createControlPlotLine(label, color, val, disp, chartProps, isUI) {
  var series = {};
  series.name = label;
  if (isUI && isAccessibilityPatternsEnabled()) {
    if (color === 'red')
      series.dashStyle = 'Dot';
    else if (color === 'green')
      series.dashStyle = 'ShortDash';
    else
      series.dashStyle = 'Dash';
    series.color = '#000';
  } else
    series.color = color;
  series.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPt = {};
    dataPt.y = val;
    dataPt.y_tooltip = disp;
    dataPt.marker = {};
    dataPt.marker.enabled = false;
    hc_addPropsForDataLabelsTruncation(dataPt, chartProps.report_properties);
    series.data.push(dataPt);
  }
  return series;
}

function hc_createBoxPlotData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name + ':box';
  if (('yaxis_duration' in seriesData) && seriesData.yaxis_duration && hc_hasAxes(chartProps.chartType)) {
    if (isUI)
      hcOptions.yAxis[0].labels.formatter = hc_formatDurationLabel;
    else
      hcOptions.yAxis[0].labels.formatter = 'hc_formatDurationLabel';
  }
  var boxseries = {};
  boxseries.name = seriesName;
  if ('box_color' in chartProps.report_properties)
    boxseries.color = chartProps.report_properties.box_color;
  boxseries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var boxValArray = [];
    var boxDisplayValArray = [];
    boxDisplayValArray = seriesData.boxdisplayvalues[j];
    if (isUI)
      boxValArray = seriesData.boxvalues[j].split(',');
    else
      boxValArray = hc_strToArray(seriesData.boxvalues[j], ',');
    var boxVals = {};
    boxVals.low = parseFloat(boxValArray[0]);
    boxVals.q1 = parseFloat(boxValArray[1]);
    boxVals.median = parseFloat(boxValArray[2]);
    boxVals.q3 = parseFloat(boxValArray[3]);
    boxVals.high = parseFloat(boxValArray[4]);
    boxVals.low_display = boxDisplayValArray[0];
    boxVals.q1_display = boxDisplayValArray[1];
    boxVals.median_display = boxDisplayValArray[2];
    boxVals.q3_display = boxDisplayValArray[3];
    boxVals.high_display = boxDisplayValArray[4];
    boxseries.data.push(boxVals);
  }
  if (isUI) {
    boxseries.tooltip = {};
    boxseries.tooltip.pointFormat = '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>' +
      chartProps.report_properties.box_max + ': {point.high_display}<br/>' +
      chartProps.report_properties.box_q3 + ': {point.q3_display}<br/>' +
      chartProps.report_properties.box_median + ': {point.median_display}<br/>' +
      chartProps.report_properties.box_q1 + ': {point.q1_display}<br/>' +
      chartProps.report_properties.box_min + ': {point.low_display}<br/>';
  }
  return boxseries;
}

function hc_createBoxMeanData(hcOptions, chartData, chartProps, isUI) {
  var seriesData = chartData.series[0];
  var seriesName = seriesData.series_name + ':mean';
  var meanseries = {};
  meanseries.name = seriesName;
  meanseries.type = 'scatter';
  if ('box_mean_color' in chartProps.report_properties)
    meanseries.color = chartProps.report_properties.box_mean_color;
  meanseries.data = [];
  for (var j = 0; j < chartProps.xValues.length; j++) {
    var dataPoint = [];
    dataPoint.push(j);
    dataPoint.push(parseFloat(seriesData.yvalues[j]));
    meanseries.data.push(dataPoint);
  }
  if (isUI) {
    meanseries.tooltip = {};
    meanseries.tooltip.pointFormat = chartProps.report_properties.box_mean + ': {point.y}';
  }
  return meanseries;
}

function hc_isPresentInArray(arr, key) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === key)
      return i;
  }
  return -1;
}

function hc_strToArray(str, delim) {
  var arr = [];
  var indx = str.indexOf(delim);
  while (indx >= 0) {
    var elem = str.substring(0, indx);
    arr.push(elem);
    str = str.substring(indx + 1);
    indx = str.indexOf(delim);
  }
  str = str.trim();
  if (str.length > 0)
    arr.push(str);
  return arr;
}

function hc_dataPointSelected(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  if (typeof this.publisher_filter === 'undefined' || event.accumulate === 'preventDataPointSelect' || isFilterAlreadyPublished(gridWindow))
    return;
  var queryCondition = this.publisher_filter.replace('^', '^EQ^');
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + queryCondition;
  var filterMessage = hc_interactiveFilterMessage(uniqueId, this.table, queryCondition);
  filterMessage.sliced = true;
  if (gridWindow.queryCondition) {
    var oldUniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + gridWindow.queryCondition;
    delete gridWindow.interactiveFilters[oldUniqueId];
  }
  gridWindow.queryCondition = queryCondition;
  gridWindow.interactiveFilters[uniqueId] = filterMessage;
  initializeInteractiveChartStack(oldUniqueId, filterMessage, gridWindow);
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters, gridWindow._dashboardMessageHandler);
}

function hc_dataPointUnselected(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  if (typeof this.publisher_filter === 'undefined' || (typeof event.accumulate === 'undefined' && event.type === 'unselect') ||
    isFilterAlreadyPublished(gridWindow))
    return;
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  var queryCondition = this.publisher_filter.replace('^', '^EQ^');
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id) + queryCondition;
  delete gridWindow.interactiveFilters[uniqueId];
  popFromInteractiveChartStack();
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters, gridWindow._dashboardMessageHandler);
}

function hc_FilterPublisher(reportId, filter, dashboardMessageHandler) {
  var filterMessages = [];
  for (var key in filter) {
    filterMessages.push(filter[key]);
  }
  var handler = dashboardMessageHandler || new DashboardMessageHandler(reportId);
  var isInCanvas = window.SNC && SNC.canvas && SNC.canvas.interactiveFilters && SNC.canvas.isGridCanvasActive;
  if (filterMessages.length > 0) {
    if (isInCanvas)
      SNC.canvas.interactiveFilters.addFilterToDefaultValues(reportId, filterMessages);
    handler.publishMessage(filterMessages);
  } else {
    if (isInCanvas)
      SNC.canvas.interactiveFilters.removeFilterFromDefaultValues(reportId);
    handler.removeFilter();
  }
};

function hc_dataPointPublishFilter(reportId, filter, dashboardMessageHandler) {
  var currentFilterPublishedTime = Date.now();
  if (isRenderedInCanvas()) {
    SNC.canvas.chartsActingAsFilters = SNC.canvas.chartsActingAsFilters || {};
    SNC.canvas.chartsActingAsFilters.lastPublishTime = SNC.canvas.chartsActingAsFilters.currentPublishTime || currentFilterPublishedTime;
    SNC.canvas.chartsActingAsFilters.currentPublishTime = currentFilterPublishedTime;
    SNC.canvas.chartsActingAsFilters.previousId = SNC.canvas.chartsActingAsFilters.currentId || null;
    SNC.canvas.chartsActingAsFilters.currentId = reportId || null;
  }
  hc_FilterPublisher(reportId, filter, dashboardMessageHandler);
}

function hc_interactiveFilterMessage(uniqueId, table, filter) {
  var filter_message = {};
  filter_message.id = uniqueId;
  filter_message.table = table;
  filter_message.filter = filter;
  return filter_message;
}

function hc_dataPointLegendClick(event) {
  var gridWindow = getGridWindow(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  gridWindow.interactiveFilters = gridWindow.interactiveFilters || {};
  var uniqueId = getDashboardMessageHandlerId(this.series.chart.userOptions.publisher_id, this.series.chart.userOptions.report_id);
  var filtersFromLegend = {};
  if (gridWindow.filtersFromLegend)
    filtersFromLegend = gridWindow.filtersFromLegend;
  var selected = jQuery.grep(this.series.points, function(obj) {
    if (event.target == obj && obj.visible)
      filtersFromLegend[obj.publisher_filter] = obj.publisher_filter;
    return event.target == obj ? !obj.visible : obj.visible
  });
  if (selected.length == this.series.points.length) {
    delete gridWindow.interactiveFilters[uniqueId];
    delete gridWindow.filtersFromLegend;
  } else {
    var queryArr = jQuery.map(selected, function(val, index) {
      return val.publisher_filter;
    });
    var queryCondition = queryArr.join('^NQ');
    var filterMessage = hc_interactiveFilterMessage(uniqueId, this.table, queryCondition);
    filterMessage.isFromLegend = true;
    gridWindow.interactiveFilters[uniqueId] = filterMessage;
    gridWindow.filtersFromLegend = filtersFromLegend;
  }
  hc_dataPointPublishFilter(this.series.chart.userOptions.report_id, gridWindow.interactiveFilters);
}

function getDashboardMessageHandlerId(publisherId, reportId) {
  var dashboardMesssageHandlerId = '';
  if (typeof glideGrid != "undefined") {
    var gridWindow = glideGrid.getWindowByGaugeId(publisherId);
    if (typeof gridWindow != 'undefined' && gridWindow != null && gridWindow)
      dashboardMesssageHandlerId = publisherId;
    else
      dashboardMesssageHandlerId = reportId;
  } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
    var gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
    if (typeof gridWindow != 'undefined' && gridWindow != null && gridWindow)
      dashboardMesssageHandlerId = reportId;
    else
      dashboardMesssageHandlerId = publisherId;
  }
  return dashboardMesssageHandlerId;
}

function getGridWindow(publisherId, reportId) {
  var gridWindow;
  if (typeof glideGrid != "undefined") {
    gridWindow = glideGrid.getWindowByGaugeId(publisherId);
    if (typeof gridWindow === 'undefined' || gridWindow == null) {
      gridWindow = glideGrid.getWindowByGaugeId(reportId);
    }
  } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
    gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
  } else {
    gridWindow = glideGrid.getWindowByGaugeId(reportId);
  }
  return gridWindow;
}

function hc_dataPointClicked(event) {
  var point = event.point || event.target;
  if (!point || point.valid === false || typeof point.click_url_info === "undefined")
    return;
  var openNewTab;
  if (event.ctrlKey || event.metaKey)
    openNewTab = true;
  if (point.widget_navigation && point.widget_navigation.length) {
    var widgetNav = point.widget_navigation[0];
    window.open(widgetNav.value, openNewTab ? '_blank' : '_self');
  } else if (point.isOther)
    openUrl(event, point.click_url_info);
  else {
    var element = event.srcElement || event.target;
    if (event.target && event.target.graphic)
      element = event.target.graphic.element;
    var hcKey = '';
    if (typeof point.isLatLon !== 'undefined' && !point.isLatLon)
      hcKey = point.properties['hc-key'];
    generateDataPointClickUrl(event, element, point.report_drilldown, point.table, point.click_url_info, point.list_ui_view_name, point.drill_open_new_win, point.isOther,
      (point.report_drilldown_zoom ? hcKey : null), point.report_drilldown_map, point.show_data_label, point.show_geographical_label);
  }
}

function hc_formatToolTip() {
  var tt = '';
  var parenthesisOpen = false;
  if (typeof this.point.valid == 'undefined' || this.point.valid === true) {
    if (this.series.name == 'pareto_series')
      tt = this.point.percent + '%';
    else {
      tt = this.x + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
      parenthesisOpen = true;
    }
    if (this.point.percent_count)
      tt += ' of ' + this.point.table_display_plural;
    if (parenthesisOpen)
      tt += ')';
    if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
      tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
    return tt;
  }
  return false;
}

function hc_formatGeneralLineBarToolTip(event) {
  var typeTooltip = this.series.options.tooltip.tooltipText;
  if ('stacked' === typeTooltip) {
    if (this.point.valid) {
      var xValue = this.x;
      if (hc_isSlowMetricChart(this.series.chart.options))
        xValue = hc_formatDatetimeString(this.x);
      var tt = xValue + ', ' + this.point.name + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
      if (this.point.percent_count)
        tt += ' of ' + this.point.table_display_plural + ')';
      else
        tt += ')';
      if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
        tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
      return tt;
    }
    return false;
  } else {
    var tt = '';
    var parenthesisOpen = false;
    if (typeof this.point.valid == 'undefined' || this.point.valid === true) {
      if (this.series.name == 'pareto_series')
        tt = this.point.percent + '%';
      else {
        var xValue = this.x;
        if (hc_isSlowMetricChart(this.series.chart.options))
          xValue = hc_formatDatetimeString(this.x);
        tt = xValue + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
        parenthesisOpen = true;
      }
      if (this.point.percent_count)
        tt += ' of ' + this.point.table_display_plural;
      if (parenthesisOpen)
        tt += ')';
      if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
        tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
      return tt;
    }
    return false;
  }
}

function hc_formatPie() {
  var tt = this.key + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%)';
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatHeatmapTooltip() {
  var tt = '<b>' + this.point.value_tooltip + '</b>';
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatMapTooltip() {
  var tt = this.point.name + (this.point.y_tooltip != '' ? ':' + this.point.y_tooltip : '');
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatMapDataLabels() {
  var showGeoLabel = this.point.series.chart.series[0].options.dataLabels.show_geographical_label;
  var showDataLabel = this.point.series.chart.series[0].options.dataLabels.show_data_label;
  var name = this.point.name;
  var value = this.point.y_tooltip;
  var out = '';
  if (showDataLabel && showGeoLabel)
    out = value !== undefined && value != '' ? name + ':' + value : name;
  else if (showDataLabel && !showGeoLabel)
    out = value;
  else if (!showDataLabel && showGeoLabel)
    out = name;
  return out;
}

function hc_formatStackedBarToolTip() {
  if (this.point.valid) {
    var tt = this.x + ', ' + this.point.name + ' = ' + this.point.y_tooltip + '<br/>(' + this.point.percent + '%';
    if (this.point.percent_count)
      tt += ' of ' + this.point.table_display_plural + ')';
    else
      tt += ')';
    if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
      tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
    return tt;
  }
  return false;
}

function hc_formatHistToolTip() {
  var rangevals = this.x.split(':');
  var tt = this.point.tt_label_min + ' = ' + rangevals[0] + '<br/>' +
    this.point.tt_label_max + ' = ' + rangevals[1] + '<br/>' +
    this.point.tt_label_cnt + ' = ' + this.y;
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_formatControlToolTip() {
  var tt = this.x + ' = ' + this.point.y_tooltip;
  if (this.point.widget_navigation && this.point.widget_navigation.length && this.point.widget_navigation[0].value.length)
    tt += '<br/>' + this.point.widget_navigation_tooltip_text + ' ' + this.point.widget_navigation[0].label;
  return tt;
}

function hc_addPropsForDataLabelsTruncation(dataPoint, reportProperties) {
  dataPoint.data_label_max_length = reportProperties.data_label_max_size;
  if ('truncate_data_labels' in reportProperties)
    dataPoint.truncate_data_labels = reportProperties.truncate_data_labels;
  if ('data_labels_remove_leading' in reportProperties)
    dataPoint.data_labels_remove_leading = reportProperties.data_labels_remove_leading;
}

function hc_addTotal(hcOptions, chartProps, series, chartData) {
  if (!series.data.length) {
    return;
  }
  hcOptions.subtitle = {};
  hcOptions.subtitle.verticalAlign = 'middle';
  hcOptions.subtitle.align = 'center';
  hcOptions.subtitle.style = {};
  hcOptions.subtitle.style.fontFamily = 'Arial';
  hcOptions.subtitle.style.color = '#000';
  hcOptions.subtitle.style['text-align'] = 'center';
  var titleVerticalAlign = chartData.report_properties.title_vertical_alignment;
  var titleSize = chartData.report_properties.chart_title_size;
  var fontHelper;
  if (hcOptions.chart.width < hcOptions.chart.height)
    fontHelper = hcOptions.chart.width;
  else
    fontHelper = hcOptions.chart.height;
  var fontSize = fontHelper / 15;
  var durationSubFontSize = parseInt(fontHelper / 20);
  hcOptions.subtitle.style.fontSize = parseInt(fontSize) + "pt";
  var yPos = 0;
  if ("yaxis_duration" in chartData.series[0] && chartData.series[0].yaxis_duration) {
    hcOptions.subtitle.useHTML = true;
    hcOptions.subtitle.style['line-height'] = parseInt(fontSize / 1.2) + "pt";
    var days = 'Days';
    var hours = 'Hours';
    var minutes = 'Minutes';
    var seconds = 'Seconds';
    var translation = chartData.report_properties.translation;
    if (translation != undefined) {
      days = translation.days;
      hours = translation.hours;
      minutes = translation.minutes;
      seconds = translation.seconds;
    }
    series.total = series.total.replace(days, days + "<br/><span style='font-size:" + durationSubFontSize + "pt;'>")
      .replace(" " + hours + " ", "h:").replace(" " + minutes + " ", "m:").replace(" " + seconds, "s") +
      "</span>";
    if (chartProps.chartType == 'donut') {
      if (hcOptions.title.text === '') {
        yPos = 0 - fontSize * (.5 + fontSize / 200);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 2 - fontSize * (fontSize / 100);
      } else if (titleVerticalAlign === 'bottom') {
        yPos = 0 - (titleSize / 2 + fontSize * (fontSize / 100));
      }
    } else {
      if (hcOptions.title.text === '') {
        yPos = fontSize * 1.55;
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 3 + fontSize * 1.55;
      } else if (titleVerticalAlign === 'bottom') {
        yPos = (fontSize * 1.55 + 11) - (titleSize / 1.4);
      }
    }
  } else {
    series.total = "<span title=" + series.total_value + ">" + series.total + "</span>";
    if (chartProps.chartType == 'donut') {
      if (hcOptions.title.text === '') {
        yPos = 0 - fontSize * (.2 + fontSize / 200);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 2 + fontSize * (.35 - fontSize / 100);
      } else if (titleVerticalAlign === 'bottom') {
        yPos = 0 - (titleSize / 2.5 + fontSize * (fontSize / 150));
      }
    } else {
      if (hcOptions.title.text === '') {
        yPos = fontSize * (2.3 + fontSize / 400);
      } else if (titleVerticalAlign === 'top') {
        yPos = titleSize / 4 + fontSize * 2.55;
      } else if (titleVerticalAlign === 'bottom') {
        yPos = fontSize * (2.8 - fontSize / 400) - titleSize / 1.4;
      }
    }
  }
  hcOptions.subtitle.useHTML = true;
  hcOptions.subtitle.text = series.total;
  hcOptions.subtitle.y = yPos;
  hcOptions.legend.enabled = false;
}

function clickOnABreadcrumb(reportId, containerId, jsonProperties) {
  var decodedJsonProperties = decodeURIComponent(jsonProperties);
  var jsonProperties = JSON.parse(decodedJsonProperties);
  var content = jQuery("#" + containerId);
  var mapParams = '';
  var map;
  var contParams = 0;
  for (var i = 0; i < jsonProperties.length; i++) {
    var jsonProp = jsonProperties[i];
    if (jsonProp.key === 'report_map')
      map = jsonProp.value;
  }
  mapParams += "&sysparm_report_map_parent=" + map;
  drillReport(content.parent().parent(), reportId, '', mapParams);
}

function hc_isSlowMetricChart(hcOptions, seriesData) {
  if (hcOptions && hcOptions.chart && hcOptions.chart.isChartingSlowMetricTable !== undefined)
    return hcOptions.chart.isChartingSlowMetricTable;
  if (seriesData && seriesData.table_name && seriesData.xvalues && seriesData.xvalues[0] &&
    seriesData.table_name.indexOf('v_rrd') === 0 &&
    /(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)/.test(seriesData.xvalues[0])) {
    hcOptions.chart.isChartingSlowMetricTable = true;
    return true;
  } else
    hcOptions.chart.isChartingSlowMetricTable = false;
  return false;
}

function hc_convertDateTimeFormatToUnixTime(datetime) {
  var dateAndTimes = /(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d)/.exec(datetime);
  dateAndTimes.shift();
  for (var i = 0; i < dateAndTimes.length; i++) {
    dateAndTimes[i] = parseInt(dateAndTimes[i], 10);
  }
  return Date.UTC(dateAndTimes[0], dateAndTimes[1] - 1, dateAndTimes[2], dateAndTimes[3], dateAndTimes[4], dateAndTimes[5]);
}

function hc_setZoomTypeForSlowMetric(chartData, hcOptions) {
  if (hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.chart.zoomType = 'x';
  }
}

function hc_formatDatetimeString(x) {
  var xValue = (new Date(x)).toUTCString();
  xValue = xValue.substring(0, xValue.length - 4);
  return xValue
}

function hc_addSummaryDataToLegendForSlowMetric(chartData, hcOptions, isUI) {
  if (isUI && !(window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils) && hc_isSlowMetricChart(hcOptions, chartData.series[0])) {
    hcOptions.legend.statsTable = {
      active: true,
      seriesLinkGenerator: function linkSeriesInLegendToPattern(serie) {
        try {
          var patternSysId = /pattern=(\w*)/.exec(serie.userOptions.data[0].click_url_info)[1];
          var patternType = serie.userOptions.data[0].table.split("_").pop();
          return "sys_" + patternType + "_pattern.do?sys_id=" + patternSysId;
        } catch (e) {
          return "";
        }
      }
    };
    if (chartData.title.indexOf("Time") >= 0)
      hcOptions.legend.statsTable.unit = 'ms';
    hcOptions.chart.height -= 120;
  }
}

function hc_differenceOfClosestStringDateTimesInSeries(xValues) {
  var previousValue = hc_convertDateTimeFormatToUnixTime(xValues[0]);
  var smallestDifference = Number.MAX_VALUE;
  var currentValue, currentDifference;
  for (var i = 1; i < xValues.length; i++) {
    currentValue = hc_convertDateTimeFormatToUnixTime(xValues[i]);
    currentDifference = currentValue - previousValue;
    if (currentDifference < smallestDifference)
      smallestDifference = currentDifference;
    previousValue = currentValue;
  }
  if (smallestDifference === Number.MAX_VALUE)
    return 0;
  return smallestDifference;
}

function hc_disableTurboThreshold(hcOptions) {
  var threshold = 0;
  if (typeof hcOptions !== 'undefined' && typeof hcOptions.series !== 'undefined') {
    for (var i = 0; i < hcOptions.series.length; i++)
      hcOptions.series[i].turboThreshold = threshold;
  }
}

function hc_setDataLabelPositionProperties(hcOptions, chartData) {
  var hcOptionSeriesCount = 0;
  var numberOfDatasets = chartData.series.length;
  for (var datasetIndex = 0; datasetIndex < numberOfDatasets; datasetIndex++) {
    var dataset = chartData.series[datasetIndex];
    var numberOfHcSeriesPerDataset = 1;
    if ('sub_series' in dataset)
      numberOfHcSeriesPerDataset = dataset.x2values.length;
    for (var j = 0; j < numberOfHcSeriesPerDataset; j++) {
      if (chartData.report_properties_series[datasetIndex].show_chart_data_label) {
        hcOptions.series[j + hcOptionSeriesCount].dataLabels.enabled = true;
        if (chartData.report_properties_series[datasetIndex].show_data_label_position_middle) {
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.verticalAlign = 'middle';
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.inside = true;
        } else
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.inside = false;
        if (chartData.report_properties_series[datasetIndex].allow_data_label_overlap)
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.allowOverlap = true;
        else
          hcOptions.series[j + hcOptionSeriesCount].dataLabels.allowOverlap = false;
      } else
        hcOptions.series[j + hcOptionSeriesCount].dataLabels.enabled = false;
    }
    hcOptionSeriesCount += numberOfHcSeriesPerDataset;
  }
}

function isAccessibilityPatternsEnabled() {
  return window.g_accessibility_visual_patterns === 'true' || window.g_accessibility_visual_patterns === true;
}

function getOldFilterIndexFromStack(oldUniqueId) {
  var oldItemIndex = -1;
  if (window.SNC && SNC.interactiveChart && oldUniqueId && SNC.interactiveChart.length) {
    for (var index = 0, len = SNC.interactiveChart.length; index < len; index++) {
      if (SNC.interactiveChart[index].id === oldUniqueId) {
        oldItemIndex = index;
        break;
      }
    }
  }
  return oldItemIndex;
}

function initializeInteractiveChartStack(oldUniqueId, filterMessage, gridWindow) {
  window.SNC = window.SNC || {};
  SNC.interactiveChart = SNC.interactiveChart || [];
  var oldItemIndex = gridWindow.queryCondition && getOldFilterIndexFromStack(oldUniqueId);
  if (oldItemIndex > -1)
    SNC.interactiveChart[oldItemIndex] = filterMessage;
  else
    SNC.interactiveChart.push(filterMessage);
  subscribeToDashboardTabChange(gridWindow);
}

function subscribeToDashboardTabChange(gridWindow) {
  if (gridWindow && window.SNC && window.SNC.canvas && window.SNC.canvas.eventbus && !gridWindow.hasNotSubscribedToTabSwitch) {
    gridWindow.hasNotSubscribedToTabSwitch = true;
    window.SNC.canvas.eventbus.subscribe('dashboards:switchTab', function onTabChangeHandler() {
      if (SNC.canvas.canvasUtils.clearAllWidgetsCache)
        SNC.canvas.canvasUtils.clearAllWidgetsCache();
      window.SNC.canvas.eventbus.unsubscribe('dashboards:switchTab', onTabChangeHandler);
    });
  }
}

function popFromInteractiveChartStack() {
  if (window.SNC && SNC.interactiveChart && SNC.interactiveChart.length)
    SNC.interactiveChart.pop();
}

function isFilterAlreadyPublished(gridWindow) {
  var isFilterPublished = false;
  if (gridWindow) {
    var isBothPublisherNSubscriber = gridWindow.preferences.can_publish && gridWindow.preferences.can_subscribe;
    var allConsumedFilter = gridWindow.consumed;
    var interactiveFilters = gridWindow.interactiveFilters || {};
    if (isBothPublisherNSubscriber && allConsumedFilter && Array.isArray(allConsumedFilter)) {
      var allConsumedFilterFlattend = [].concat.apply([], allConsumedFilter);
      for (var index = 0, len = allConsumedFilterFlattend.length; index < len; index++) {
        var item = allConsumedFilterFlattend[index];
        if (interactiveFilters[item.id]) {
          isFilterPublished = true;
          break;
        }
      }
    }
  }
  return isFilterPublished;
};
/*! RESOURCE: /scripts/reportcommon/customvisuals/multilevel-pivot.js */
var MultilevelPivot = function MultilevelPivot(reportUUID, runType, options, notSaveStatistics) {
  'use strict';
  var self = this;
  if (!options) {
    options = window.g_report_params[reportUUID];
    options.is_report_source_filter_already_combined = true;
  }
  options.not_save_statistics = notSaveStatistics;
  createReportTemplate(reportUUID, options);
  this.containerId = 'chart-container-' + reportUUID;
  this.showZero = options.show_zero;
  this.pivotExpanded = options.pivot_expanded !== 'false' && options.pivot_expanded !== false;
  this.displayRowLines = options.display_row_lines !== 'false' && options.display_row_lines !== false;
  this.displayColumnLines = options.display_column_lines !== 'false' && options.display_column_lines !== false;
  this.fixedHeaders = window.chartHelpers.systemParams.fixedHeaders;
  this.table = options.table;
  this.$table = jQuery('<table id="pivot_table" class="pivot-2-levels table" cellspacing="0" cellpadding="0" tabindex="0" role="grid" />');
  this.listUIViewName = '';
  this.isBuilder = jQuery('#reportform_control').length || (typeof gReport !== 'undefined' && gReport && gReport.isDesigner);
  this.isDesigner = (typeof gReport !== 'undefined' && gReport && gReport.isDesigner);
  this.isOldBuilder = jQuery('#reportform_control').length;
  this.isCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  this.options = options;
  this.title = options.title;
  var leftMostRowSpan = [];
  var leftMostRowValue = [];
  var showMessage = function showMessage(msg, level) {
    if (level === 'FAILURE')
      jQuery('#' + self.containerId).html('<div class="pivot-error">ERROR: ' + msg + '</div>');
    else
      jQuery('#' + self.containerId).before('<div class="pivot-infomessage">' + msg + '</div>');
  };
  this.init = function init() {
    self.runPivot(options, runType);
    self.eventHandlers();
  };
  this.runPivot = function runPivot() {
    self.startTime = new Date().getTime();
    var processor = (runType === 'run') ? 'PivotRunProcessor' : 'PivotRunPublishedProcessor';
    jQuery.ajax({
      method: 'POST',
      url: '/xmlhttp.do',
      dataType: 'xml',
      headers: {
        'X-UserToken': window.g_ck
      },
      data: {
        sysparm_processor: processor,
        sysparm_scope: 'global',
        is_portal: options.is_portal,
        sysparm_timer: new Date().getTime(),
        sysparm_request_params: JSON.stringify(self.buildRequestParams(options))
      }
    }).done(function doneCb(xml) {
      self.processResponse(xml);
    }).fail(function failCb(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
  };
  this.processResponse = function processResponse(response) {
    if (!response)
      showError(self.containerId, 'No response from the server');
    else {
      var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
      if (resp.STATUS === 'SUCCESS')
        try {
          response = JSON.parse(resp.RESPONSE_DATA);
          if (response.widget_navigation && response.widget_navigation.length)
            this.widgetNav = response.widget_navigation[0];
          self.reportDrilldown = response.report_drilldown;
          self.renderTable(response);
          if (self.isBuilder && response.drill_message)
            showMessage(response.drill_message);
          if (response.message)
            showMessage(response.message, 'INFO');
          if (self.fixedHeaders)
            self.fixateHeader();
        } catch (err) {
          showMessage(chartHelpers.i18n.chartGenerationError, 'FAILURE');
          throw new Error(err);
        }
      else {
        jQuery('#' + self.containerId).empty();
        showMessage(resp.RESPONSE_DATA, resp.STATUS);
      }
    }
    var now = new Date().getTime();
    var elapsedTime = (now - self.startTime) / 1000;
    console.log('Time taken to render report: ' + elapsedTime);
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
  };
  this.reduceAxisCategories = function reduceAxisCategories(categories, sortKey) {
    var uniqueAxisCategories = {};
    for (var i = 0; i < categories.length; i++) {
      if (!uniqueAxisCategories.hasOwnProperty(categories[i][sortKey])) {
        var record = {};
        record.count = 1;
        record.value = categories[i].value;
        uniqueAxisCategories[categories[i][sortKey]] = record;
      } else
        uniqueAxisCategories[categories[i][sortKey]].count += 1;
    }
    return uniqueAxisCategories;
  };
  this.renderTable = function renderTable(response) {
    var aggregateFunction = response.aggregate.function;
    var titleProps;
    var showTitle = true;
    var config = self.options;
    var $container = jQuery('#' + self.containerId);
    var $table = self.$table;
    var $caption = jQuery('<caption class="sr-only"/>');
    var $row = jQuery('<tr role="row" />');
    var $yLabelsRow = jQuery('<tr class="y-labels-row header-row" role="row"/>');
    var yLastColSpan = 1;
    var xLastRowSpan = 1;
    var headerRows = [];
    var data = response.series.data;
    var xCategories = response.xAxisCategories;
    var yCategories = response.yAxisCategories;
    var xCategorySortKey = xCategories[0].fieldValues[0].hasOwnProperty('sys_id') ? 'sys_id' : 'value';
    var yCategorySortKey = yCategories[0].fieldValues[0].hasOwnProperty('sys_id') ? 'sys_id' : 'value';
    var subtotals = response.subtotals;
    self.listUIViewName = response.list_ui_view_name;
    self.drillOpenNewWin = response.drill_open_new_win;
    var xLevel = xCategories[0].fieldValues.length;
    var yLevel = yCategories[0].fieldValues.length;
    var yTopmostCategories = [];
    var xTopmostCategories = [];
    var nextBlocked = 0;
    $caption.text(config.chart_title || config.title);
    $table.append($caption);
    for (var i = 0; i < xLevel; i++)
      headerRows.push(jQuery('<tr class="header-row" role="row"/>'));
    for (i = 0; i < yCategories.length; i++)
      yTopmostCategories[i] = yCategories[i].fieldValues[0];
    for (i = 0; i < xCategories.length; i++)
      xTopmostCategories[i] = xCategories[i].fieldValues[0];
    var yTopmostUniqueCategories = this.reduceAxisCategories(yTopmostCategories, yCategorySortKey);
    var xTopmostUniqueCategories = this.reduceAxisCategories(xTopmostCategories, xCategorySortKey);
    if (yLevel === 1)
      yLastColSpan = 2;
    if (xLevel === 1)
      xLastRowSpan = 2;
    for (i = 0; i < yCategories.length; i++) {
      for (var j = 0; j <= xCategories.length; j++)
        if (j < xCategories.length) {
          var dataPoint = data[(xCategories.length * i) + j];
          var cellQueryParts = [];
          var dataPointValue = dataPoint[0];
          if (dataPointValue || (dataPointValue === 0 && (aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))) {
            var xCategoryQuery = response.otherQuery && !xCategories[j].categoryQuery ? response.otherQuery : xCategories[j].categoryQuery;
            cellQueryParts = [xCategoryQuery, yCategories[i].categoryQuery, response.filter];
          }
          if (dataPointValue === null && self.showZero && dataPoint[1] === '0')
            dataPointValue = 0;
          var colorStyle = chartHelpers.evaluateColorRules(dataPointValue, response.rules);
          var $td = jQuery('<td/>');
          if (colorStyle && colorStyle.color)
            $td.css('color', colorStyle.color);
          if (colorStyle && colorStyle.bgColor)
            $td.css('background-color', colorStyle.bgColor);
          $td.appendTo($row).html(self.generateCell(dataPoint[1], cellQueryParts, dataPoint[2], aggregateFunction));
        } else {
          var yAggregateQueryParts = [yCategories[i].categoryQuery];
          if (!response.sysparm_show_other && response.otherQuery)
            yAggregateQueryParts.push(response.otherQuery);
          yAggregateQueryParts.push(response.filter);
          jQuery('<td class="aggregate-right"/>').appendTo($row).html(self.generateCell(yCategories[i].aggregatedValue, yAggregateQueryParts, yCategories[i].tooltipText));
        }
      for (var k = yLevel - 1; k >= 0; k--)
        if (k === 0)
          if (nextBlocked === 0) {
            if (subtotals) {
              $row.addClass('below-subtotals');
              leftMostRowSpan.push(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count);
              leftMostRowValue.push(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].value);
            } else
              jQuery('<td/>', {
                class: 'y-axis-category-field-leftmost header-left',
                scope: 'row',
                role: 'rowheader',
                colspan: yLastColSpan,
                rowspan: yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count
              }).prependTo($row).text(yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].value);
            nextBlocked = yTopmostUniqueCategories[yCategories[i].fieldValues[k][yCategorySortKey]].count - 1;
          } else
            nextBlocked--;
      else
      if (k === yLevel - 1)
        jQuery('<td/>', {
          scope: 'row',
          colspan: 2,
          role: 'rowheader',
          class: 'y-axis-category-field header-left'
        }).prependTo($row).text(yCategories[i].fieldValues[k].value);
      else
        jQuery('<td/>', {
          scope: 'row',
          class: 'y-axis-category-field header-left',
          role: 'rowheader'
        }).prependTo($row).text(yCategories[i].fieldValues[k].value);
      if (!self.pivotExpanded && subtotals)
        $row.css('display', 'none');
      $table.append($row.addClass('content-row'));
      $row = jQuery('<tr role="row"/>');
    }
    for (i = 0; i <= xCategories.length; i++)
      if (i < xCategories.length) {
        xCategoryQuery = response.otherQuery && !xCategories[i].categoryQuery ? response.otherQuery : xCategories[i].categoryQuery;
        var $content = self.generateCell(xCategories[i].aggregatedValue, [xCategoryQuery, response.filter], xCategories[i].tooltipText);
        $row.addClass('totals');
        jQuery('<td class="aggregate-bottom"/>').appendTo($row).html($content);
        for (j = 0; j < xLevel; j++)
          if (typeof xCategories[i].fieldValues[j] !== 'undefined')
            if (j === 0) {
              if (nextBlocked === 0) {
                jQuery('<th/>', {
                  rowspan: xLastRowSpan,
                  scope: 'col',
                  role: 'columnheader',
                  colspan: xTopmostUniqueCategories[xCategories[i].fieldValues[j][xCategorySortKey]].count
                }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
                nextBlocked = xTopmostUniqueCategories[xCategories[i].fieldValues[j][xCategorySortKey]].count - 1;
              } else
                nextBlocked--;
            } else if (j === xLevel - 2)
          jQuery('<th/>', {
            class: 'x-axis-category-field',
            scope: 'col',
            role: 'columnheader'
          }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
        else
          jQuery('<th/>', {
            rowspan: 2,
            class: 'x-axis-category-field',
            scope: 'col',
            role: 'columnheader'
          }).appendTo(headerRows[j]).text(xCategories[i].fieldValues[j].value);
        else
          headerRows[0].find('th:nth-child(' + chartHelpers.objectSize(xTopmostUniqueCategories) + ')').attr('rowspan', xLevel + 1);
      } else {
        var grantTotalQueryParts = !response.sysparm_show_other && response.otherQuery ? [response.otherQuery, response.filter] : [response.filter];
        $content = self.generateCell(response.aggregate.grandAggregate, grantTotalQueryParts, response.aggregate.tooltipText);
        jQuery('<td class="grand"/>').appendTo($row).html($content);
        $row.prepend('<td colspan="' + (yLevel + 1) + '" class="header-left">' + response.aggregate.functionLabel + '</td>');
        headerRows[0].append('<th class="aggregate-right" scope="col" role="columnheader" rowspan="' + (xLevel + 1) + '"> ' + response.aggregate.functionLabel + ' </th>');
      }
    for (i = 0; i < xLevel; i++) {
      for (k = yLevel - 1; k >= 0; k--)
        if (i === xLevel - 1) {
          jQuery('<th/>', {
            class: 'y-axis-category header-left'
          }).prependTo($yLabelsRow).text(yCategories[0].fieldValues[k].field);
          headerRows[i + 1] = $yLabelsRow;
        }
      jQuery('<th/>', {
        class: 'x-axis-category'
      }).prependTo(headerRows[i]).text(xCategories[0].fieldValues[i].field);
      if (i === 0) {
        var aggregateFieldDisplayValue = '';
        var pointerButton = '';
        if (response.aggregate.aggregateFieldDisplayValue)
          aggregateFieldDisplayValue = response.aggregate.aggregateFieldDisplayValue;
        if (subtotals)
          pointerButton = '<a href="#" class="collapse-all ' + (self.pivotExpanded ? 'expanded' : '') + '"/>';
        headerRows[0].prepend('<th class="top-left-hole" colspan="' + yLevel + '" rowspan="' + xLevel + '">' + pointerButton + aggregateFieldDisplayValue + '</th>');
      }
      if (i === xLevel - 1)
        $yLabelsRow.append('<th/>');
    }
    $table.append($row);
    for (j = xLevel; j >= 0; j--)
      $table.prepend(headerRows[j]);
    if (subtotals)
      self.generateSubtotals($table, subtotals, yLevel, xCategories, aggregateFunction);
    $container.empty().html('<div class="pivot-wrap"/>').find('.pivot-wrap').append($table);
    if (config.show_chart_title === 'never' || (!config.title && !config.chart_title) || (config.show_chart_title === 'report' && !self.isBuilder))
      showTitle = false;
    if (showTitle) {
      if (config.chart_title)
        config.title = config.chart_title;
      titleProps = {
        title: config.title,
        chart_title_size: config.chart_title_size,
        chart_title_x_position: config.chart_title_x_position,
        chart_title_y_position: config.chart_title_y_position,
        title_horizontal_alignment: config.title_horizontal_alignment,
        title_vertical_alignment: config.title_vertical_alignment
      };
      if (response.chart_title_color)
        titleProps.chart_title_color = response.chart_title_color;
      self.generateTitle(titleProps);
    }
    var isServicePortal = jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
    var tip = $container.find('td a');
    if (tip.tooltip && !isServicePortal)
      tip.attr('data-placement', 'bottom').attr('data-container', 'body').tooltip().hideFix();
    if (!self.displayRowLines)
      jQuery('#pivot_table td').addClass('pivot-2-td-border-top-none');
    if (self.displayColumnLines)
      jQuery('#pivot_table td').addClass('pivot-2-td-border-left');
  };
  this.generateTitle = function generateTitle(titleProps) {
    var defaultFontSize = 14;
    var titleSelector = 'pivot_title';
    var $container = jQuery('#' + this.containerId).find('.pivot-wrap');
    var $titleEl = jQuery('<div class="' + titleSelector + '"/>').text(titleProps.title);
    if (titleProps.chart_title_color)
      $titleEl.css('color', titleProps.chart_title_color);
    if (titleProps.chart_title_size)
      $titleEl.css('font-size', titleProps.chart_title_size + 'px');
    if (titleProps.title_horizontal_alignment)
      $titleEl.css('text-align', titleProps.title_horizontal_alignment);
    if (!titleProps.custom_chart_title_position)
      switch (titleProps.title_vertical_alignment) {
        case 'top':
          $container.prepend($titleEl);
          break;
        case 'middle':
          $titleEl.css({
            position: 'absolute',
            width: '100%',
            top: '50%',
            'margin-top': -(titleProps.chart_title_size / 2) || -(defaultFontSize / 2)
          });
          $container.prepend($titleEl);
          break;
        case 'bottom':
          $container.append($titleEl);
          break;
      }
    else {
      $titleEl.css({
        position: 'absolute',
        top: titleProps.chart_title_y_position,
        left: titleProps.chart_title_x_position
      });
      $container.css({
        paddingTop: (titleProps.chart_title_size + 20) || (20 + defaultFontSize)
      });
      $container.prepend($titleEl);
    }
  };
  this.generateCell = function generateCell(displayValue, cellQueryParts, message, aggregateFunction) {
    var cellQuery = this.combineQueries(cellQueryParts);
    var encodedCellQuery = encodeURIComponent(cellQuery);
    var $content = jQuery('').html('&nbsp;');
    var hrefVal = '';
    if (displayValue)
      hrefVal = getListURL(self.table, cellQuery, self.listUiViewName);
    if (aggregateFunction) {
      if (displayValue && (displayValue !== '0' || (displayValue === '0' &&
          (self.showZero === 'true' || self.showZero === true || aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))))
        if (cellQuery)
          $content = jQuery('<a/>', {
            href: hrefVal,
            rel: encodedCellQuery,
            class: 'datapoint',
            title: message
          }).text(displayValue);
        else
          $content = jQuery('<span title="' + message + '"/>').text(displayValue);
    } else
    if (displayValue)
      $content = jQuery('<a/>', {
        href: hrefVal,
        rel: encodedCellQuery,
        class: 'datapoint',
        title: message
      }).text(displayValue);
    return $content;
  };
  this.generateSubtotals = function generateSubtotals($table, subtotals, yLevel, xCategories, aggregateFunction) {
    $table.find('.below-subtotals').before('<tr role="row" class="subtotals ' + (self.pivotExpanded ? 'expanded' : '') + '"/>');
    $table.find('.subtotals').each(function eachCb(key) {
      var $currRow = jQuery(this);
      var totalCols = yLevel + xCategories.length + 1;
      var subtotalsData = subtotals.series.data;
      var subtotalsAgg = subtotals.yAxisCategories;
      for (var i = 0; i < totalCols; i++)
        if (i === 0) {
          var rowSpan;
          if (self.pivotExpanded) {
            rowSpan = leftMostRowSpan[key] + 1;
            $currRow.addClass('expanded');
          } else
            rowSpan = 1;
          $currRow.append('<td class="leftmost-cell" rowspan="' + rowSpan + '" scope="row" role="rowheader" data-mergerows="' + (leftMostRowSpan[key] + 1) + '"><a href="#" class="subcollapse"/>' + leftMostRowValue[key] + '</td>');
        } else if (i === 1)
        $currRow.append('<td class="subtotals-empty">' + chartHelpers.i18n.total + '</td> <td class="subtotals-empty"/>');
      else if (i > 1 && i < yLevel)
        $currRow.append('<td class="subtotals-empty"/>');
      else if (i === totalCols - 1)
        jQuery('<td class="aggregate-right"/>').appendTo($currRow).html(self.generateCell(subtotalsAgg[key].aggregatedValue, [subtotalsAgg[key].categoryQuery, subtotals.filter], subtotalsAgg[key].tooltipText));
      else {
        var currSubtotal = (xCategories.length * key) + (i - yLevel);
        var cellQueryParts = [];
        if (subtotalsData[currSubtotal][0] || (subtotalsData[currSubtotal][0] === 0 && (aggregateFunction === 'AVG' || aggregateFunction === 'SUM'))) {
          var xCategoryQuery = subtotals.otherQuery && !xCategories[i - yLevel].categoryQuery ? subtotals.otherQuery : xCategories[i - yLevel].categoryQuery;
          cellQueryParts = [xCategoryQuery, subtotalsAgg[key].categoryQuery, subtotals.filter];
        }
        jQuery('<td/>').appendTo($currRow).html(self.generateCell(subtotalsData[currSubtotal][1], cellQueryParts, subtotalsData[currSubtotal][2], aggregateFunction));
      }
    });
  };
  this.fixateHeader = function fixateHeader() {
    var $scrollContainer;
    var $table = self.$table;
    var tableOffset = $table.position().top;
    var offsetDiff = 0;
    var offsetFetched = false;
    var $fixedHeader = jQuery('<table class="fixed-header pivot-2-levels table"/>').insertBefore($table).html(self.getSizedHeaders(true));
    if (self.isDesigner) {
      $scrollContainer = jQuery('#main-content');
      tableOffset = $table.offset().top - $scrollContainer.offset().top;
      offsetDiff = tableOffset - $table.position().top;
    } else if (self.isOldBuilder)
      $scrollContainer = jQuery(document);
    else if (self.isCanvas)
      $scrollContainer = jQuery('#' + this.containerId).closest('.grid-widget-content');
    else
      $scrollContainer = jQuery('#' + this.containerId).closest('.widget_body');
    $scrollContainer.scroll(function scrollCb() {
      if (!offsetFetched && self.isOldBuilder) {
        tableOffset = $table.offset().top;
        offsetDiff = tableOffset - $table.position().top;
        offsetFetched = true;
      }
      var offset = jQuery(this).scrollTop() - offsetDiff;
      if (self.isDesigner)
        offset -= jQuery('#condition-builder-wrap form').height();
      if (offset >= tableOffset - offsetDiff)
        $fixedHeader.css({
          top: offset,
          display: 'table'
        });
      else if (offset < tableOffset - offsetDiff)
        $fixedHeader.hide();
    });
  };
  this.getSizedHeaders = function getSizedHeaders(createHeader) {
    var $headerRows = self.$table.find('.header-row');
    var $clonedHeaderRows = createHeader ? $headerRows.clone() : jQuery('#' + self.containerId).find('.fixed-header .header-row');
    $headerRows.each(function eachRowCb(i) {
      var $children = $headerRows.eq(i).children();
      var $clonedChildren = $clonedHeaderRows.eq(i).children();
      $children.each(function eachChildCb(j) {
        $clonedChildren.eq(j).css('min-width', $children.eq(j).outerWidth());
      });
    });
    return $clonedHeaderRows;
  };
  this.buildRequestParams = function buildRequestParams(params) {
    return {
      sysparm_table: params.table,
      sysparm_x_axis_category_fields: params.x_axis_category_fields != null ? params.x_axis_category_fields.trim().split(/[\s,]+/) : '',
      sysparm_y_axis_category_fields: params.y_axis_category_fields != null ? params.y_axis_category_fields.trim().split(/[\s,]+/) : '',
      sysparm_aggregate: params.aggregate,
      sysparm_show_other: params.show_other,
      sysparm_others: params.other_threshold,
      sysparm_chart_title_color: params.chart_title_color,
      sysparm_sumfield: params.agg_field,
      sysparm_query: params.filter,
      sysparm_report_id: params.report_id,
      sysparm_list_ui_view: params.list_ui_view,
      sysparm_interactive_report: params.interactive_report,
      sysparm_report_drilldown: params.report_drilldown,
      sysparm_homepage_sysid: params.homepage_sysid,
      sysparm_decimal_precision: params.decimal_precision,
      sysparm_report_source_id: params.report_source_id,
      sysparm_is_report_source_filter_already_combined: params.is_report_source_filter_already_combined,
      sysparm_is_published: params.is_published,
      sysparm_not_save_statistics: params.not_save_statistics,
      sysparm_set_redirect: params.set_redirect
    };
  };
  this.eventHandlers = function eventHandlers() {
    var $container = jQuery('#' + self.containerId);
    $container.on('click', '.subtotals .subcollapse', function subcollapseClickCb(ev) {
      ev.preventDefault();
      var $parentRow = jQuery(this).closest('.subtotals');
      var $parentCell = jQuery(this).closest('td');
      var $subRows = $parentRow.nextUntil('.subtotals,.totals');
      if ($parentCell.attr('rowspan') > 1) {
        $parentCell.attr('rowspan', 1);
        $parentRow.removeClass('expanded');
        $subRows.hide();
      } else {
        $parentCell.attr('rowspan', $parentCell.data('mergerows'));
        $parentRow.addClass('expanded');
        $subRows.show();
      }
      if (self.fixedHeaders)
        self.getSizedHeaders(false);
    });
    $container.on('click', '.collapse-all', function collapseCb(ev) {
      ev.preventDefault();
      var $contentRows = $container.find('.content-row');
      var $el = jQuery(this);
      if ($el.is('.expanded')) {
        $container.find('.subtotals.expanded').each(function eachCb() {
          jQuery(this).removeClass('expanded');
          jQuery(this).find('.leftmost-cell').attr('rowspan', 1);
        });
        $el.closest('.pivot-wrap').find('.collapse-all').removeClass('expanded');
        $contentRows.hide();
      } else {
        $container.find('.subtotals:not(.expanded)').each(function eachCb() {
          jQuery(this).addClass('expanded');
          var $cell = jQuery(this).find('.leftmost-cell');
          $cell.attr('rowspan', $cell.data('mergerows'));
        });
        $el.closest('.pivot-wrap').find('.collapse-all').addClass('expanded');
        $contentRows.show();
      }
      if (self.fixedHeaders)
        self.getSizedHeaders(false);
    });
    $container.on('click', '.datapoint', function dataPointClickCb(ev) {
      ev.preventDefault();
      var openNewTab;
      if (ev.ctrlKey || ev.metaKey)
        openNewTab = true;
      if (self.widgetNav)
        window.open(self.widgetNav.value, openNewTab ? '_blank' : '_self');
      else
        generateDataPointClickUrl(ev, '#' + self.containerId, self.reportDrilldown, self.table, decodeURIComponent(jQuery(this).attr('rel')), self.listUIViewName, self.drillOpenNewWin);
    });
  };
  this.combineQueries = function combineQueries(queryParts) {
    if (typeof queryParts === 'string')
      return queryParts;
    queryParts = queryParts.filter(function filterCb(el) {
      return el;
    });
    if (!queryParts.length)
      return '';
    return queryParts.reduce(function reduceCb(acc, curr) {
      var accParts = acc.split('^NQ');
      var currParts = curr.split('^NQ');
      var finalParts = [];
      for (var i = 0; i < accParts.length; i++)
        for (var j = 0; j < currParts.length; j++)
          finalParts[(i * currParts.length) + j] = accParts[i] + '^' + currParts[j];
      return finalParts.join('^NQ');
    });
  };
  this.init();
};;
/*! RESOURCE: /scripts/reportcommon/customvisuals/single-score.js */
function SingleScore(reportUUID, runType, config) {
  'use strict';
  var self = this;
  if (!config) {
    config = window.g_report_params[reportUUID];
    config.is_report_source_filter_already_combined = true;
  }
  createReportTemplate(reportUUID, config);
  this.containerId = 'chart-container-' + reportUUID;
  this.msgContainerId = 'msg-container-' + reportUUID;
  this.$container = jQuery('#' + this.containerId);
  this.$wrap = this.$container;
  this.config = config;
  this.title = config.title;
  this.is_portal = config.is_portal;
  this.isServicePortal = jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
  this.reportId = config.report_id;
  this.table = config.table;
  this.condition = config.filter;
  this.minMargin = 5;
  this.maxFontSize = 200;
  this.minWrapHeight = 64;
  this.listUIViewName = '';
  this.relativeFontSize = 0.7;
  this.real_time = config.real_time;
  if (top.g_ambClient || (top.amb && top.amb.getClient()))
    this.amb = top.g_ambClient || top.amb.getClient();
  this._channelListener = null;
  this.$el = jQuery('<span/>');
  this.rootReportElementClass = '.sysparm_root_report_id';
  this.defaults = {
    value: '0',
    chart_background_color: '#fff',
    displayvalue: 'No value',
    color: '#000',
    displayValueChars: 0
  };
  this.isBuilder = (reportUUID === 'builder');
  (function fetchData() {
    self.unsubscribeListener(self);
    var processor = (runType === 'run') ? 'SingleScoreRunProcessor' : 'SingleScoreRunPublishedProcessor';
    jQuery.ajax({
      method: 'POST',
      url: '/xmlhttp.do',
      dataType: 'xml',
      headers: {
        'X-UserToken': window.g_ck
      },
      data: {
        sysparm_processor: processor,
        sysparm_scope: 'global',
        is_portal: self.is_portal,
        sysparm_timer: new Date().getTime(),
        sysparm_request_params: JSON.stringify(self.buildRequestParams(config))
      }
    }).done(function doneCb(xml) {
      self.render(xml);
    }).fail(function failCb(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
    self.eventHandlers();
  }());
}
SingleScore.prototype.unsubscribeListener = function unsubscribeListener() {
  var self = this;
  if (top.SNC && top.SNC.channelListeners) {
    self._channelListener = top.SNC.channelListeners[self.reportId];
    if (self._channelListener) {
      self._channelListener.unsubscribe();
      delete top.SNC.channelListeners[self.reportId];
    }
  }
};
SingleScore.prototype.shouldShowTitle = function shouldShowTitle() {
  if (this.config.show_chart_title === 'never' || (!this.config.title && !this.config.chart_title) || (this.config.show_chart_title === 'report' && this.isBuilder === false))
    return false;
  return true;
};
SingleScore.prototype.render = function render(response) {
  var self = this;
  var config = self.config;
  var responseData;
  if (!response) {
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
    showError(self.containerId, 'No response from the server');
    return;
  }
  var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
  if (resp.STATUS === 'SUCCESS') {
    try {
      var contentEl;
      var respData = JSON.parse(resp.RESPONSE_DATA);
      var hrefVal;
      var titleProps;
      if (self.isBuilder && respData.drill_message)
        showInfo(self.msgContainerId, respData.drill_message);
      this.reportDrilldown = respData.report_drilldown;
      if (respData.widget_navigation && respData.widget_navigation.length)
        this.widgetNav = respData.widget_navigation;
      self.listUIViewName = respData.list_ui_view_name;
      self.drillOpenNewWin = respData.drill_open_new_win;
      responseData = jQuery.extend({}, self.defaults, respData);
      var evaluatedColor = self.evaluateColor(responseData.value, responseData.rules, responseData.color);
      hrefVal = getListURL(self.table, responseData.filter);
      var encodedClickUrlInfo = encodeURIComponent(responseData.filter);
      contentEl = '<a id="' + self.reportId + '" style="color:' + evaluatedColor + '" href="' + hrefVal + '" rel="' + encodedClickUrlInfo + '">' + responseData.displayvalue + '</a>';
      self.$container.html('<div class="single-score" aria-live="polite"/>').find('.single-score').html(self.$el.html(contentEl));
      if (!window.isMSIE9) {
        jQuery(window).on('beforeunload', self.unsubscribeListener.bind(self));
        self.registerWatcher(responseData);
      }
      if (responseData.tooltip) {
        self.$el.attr('title', responseData.tooltip);
        if (!self.isServicePortal && self.$el.tooltip)
          self.$el.attr('data-container', 'body').attr('data-placement', 'bottom').tooltip().hideFix();
      }
      if (!(window.SNC && window.SNC.canvas && window.SNC.canvas.layoutJson && window.SNC.canvas.layoutJson.isConverting))
        self.updateSize();
      if (self.shouldShowTitle()) {
        if (config.chart_title)
          config.title = config.chart_title;
        titleProps = {
          title: config.title,
          chart_title_size: config.chart_title_size,
          chart_title_x_position: config.chart_title_x_position,
          chart_title_y_position: config.chart_title_y_position,
          title_horizontal_alignment: config.title_horizontal_alignment,
          title_vertical_alignment: config.title_vertical_alignment
        };
        if (responseData.chart_title_color)
          titleProps.chart_title_color = responseData.chart_title_color;
        self.generateTitle(titleProps);
        self.updateSize();
      }
    } catch (error) {
      console.log(error);
      showError(self.containerId, 'An error occured while generating chart.');
    }
  } else
    self.showMessage(resp.RESPONSE_DATA, resp.STATUS);
  hideReportIsLoading(findGridWindowFromElementID(self.containerId));
};
SingleScore.prototype.evaluateColor = function evaluateColor(score, rules, defaultColor) {
  if (rules) {
    var colorStyle = chartHelpers.evaluateColorRules(score, rules);
    if (colorStyle.color)
      return colorStyle.color;
  }
  return defaultColor;
};
SingleScore.prototype.base64Encode = function base64Encode(queryString) {
  try {
    return btoa(queryString);
  } catch (error) {
    if (window.DOMException && error instanceof window.DOMException && error.name === 'InvalidCharacterError')
      return btoa(chartHelpers.hexEncode(queryString));
    throw error;
  }
}
SingleScore.prototype.registerWatcher = function registerWatcher(singleScoreResponse) {
  var self = this;
  if (self.is_portal && top.SNC && top.SNC.channelListeners) {
    try {
      var base64EncodeQuery = self.base64Encode(self.condition);
      var channelId = '/rw/count/' + self.table + '/' + base64EncodeQuery.replace(/=/g, '-');
      self._channelListener = top.SNC.channelListeners[self.reportId];
      if (self._channelListener) {
        self._channelListener.unsubscribe();
        delete top.SNC.channelListeners[self.reportId];
      }
      if (self.real_time === 'true' && self.amb && self.amb.getChannel(channelId)) {
        self._channelListener = self.amb.getChannel(channelId);
        self._channelListener.subscribe(function subscribeCb(channelData) {
          self.updateScore(channelData, singleScoreResponse);
        });
        top.SNC.channelListeners[self.reportId] = self._channelListener;
      }
    } catch (error) {}
  }
};
SingleScore.prototype.updateSize = function updateSize() {
  var self = this;
  var wrapHeight;
  var wrapWidth;
  var $widgetBody;
  var fontSize = self.maxFontSize;
  var $widgetContent;
  var titleHeight = 0;
  var isCanvas = window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
  self.$container.css({
    margin: '0'
  });
  if (!self.is_portal) {
    if (self.$wrap.closest('td').length)
      $widgetBody = self.$wrap.closest('td');
    else
      $widgetBody = jQuery('body');
    self.$container.css({
      padding: '10px 0'
    });
    wrapHeight = 100;
    wrapWidth = $widgetBody.width() || 100;
  } else if (isCanvas && self.containerId.indexOf('preview') === -1) {
    $widgetContent = self.$container.closest('.grid-widget-content');
    wrapHeight = $widgetContent.height();
    wrapWidth = $widgetContent.width() - (this.minMargin * 2);
    titleHeight = $widgetContent.find('.singlescore_title').height() || 0;
  } else if (isCanvas && self.containerId.indexOf('preview') >= -1) {
    $widgetContent = self.$container.closest('.widget-preview');
    wrapHeight = $widgetContent.height();
    wrapWidth = $widgetContent.width();
    titleHeight = $widgetContent.find('.singlescore_title').height() || 0;
  } else {
    $widgetBody = self.$wrap.closest('.widget_body');
    if (jQuery('.home_preview ' + self.$containerId).length) {
      self.$container = jQuery('.home_preview #' + self.containerId);
      self.$wrap = self.$container.closest('.single-score-wrap');
      $widgetBody = jQuery('.home_preview');
    }
    wrapHeight = $widgetBody.height();
    wrapWidth = $widgetBody.width() - (this.minMargin * 2);
    if (wrapWidth < 0)
      wrapWidth = 150;
    if (wrapHeight < self.minWrapHeight)
      wrapHeight = self.minWrapHeight;
  }
  wrapHeight -= titleHeight;
  self.$el.css({
    'font-size': fontSize
  });
  while (self.$container.find('span').width() > wrapWidth && fontSize > 15) {
    fontSize -= 5;
    self.$el.css('font-size', fontSize);
  }
  fontSize = self.checkHeight(fontSize, wrapHeight);
  self.$el.css('font-size', fontSize);
  if (!isCanvas) {
    self.$container.css('margin-top', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10) - this.minMargin));
    self.$container.css('margin-bottom', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10) - this.minMargin));
  } else {
    self.$container.css('margin-top', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10)));
    self.$container.css('margin-bottom', self.getMinMargin(parseInt((wrapHeight - fontSize) / 2, 10)));
  }
  self.$container.css({
    'margin-left': this.minMargin + 'px',
    'margin-right': this.minMargin + 'px',
  });
};
SingleScore.prototype.updateScore = function updateScore(channelData, singleScoreResponse) {
  var self = this;
  try {
    var $element = jQuery('#' + self.reportId);
    var $parent = $element.closest('span');
    var score = singleScoreResponse.value * 1;
    if (typeof channelData.data.count !== 'undefined' && typeof score === 'number') {
      score += (channelData.data.count * 1);
      if (score < 0)
        score = 0;
      var localizedScore = score.toLocaleString();
      if (window.isMSIE10)
        localizedScore = localizedScore.substring(0, localizedScore.indexOf('.'));
      if ($parent.attr('data-original-title'))
        $parent.attr('data-original-title', $parent.attr('data-original-title').replace(singleScoreResponse.displayvalue, localizedScore));
      $element.text(localizedScore);
      $element.css('color', self.evaluateColor(score, singleScoreResponse.rules, singleScoreResponse.color));
      if (singleScoreResponse.displayValueChars !== singleScoreResponse.displayvalue.length) {
        self.updateSize();
        singleScoreResponse.displayValueChars = singleScoreResponse.displayvalue.length;
      }
      singleScoreResponse.value = score;
      singleScoreResponse.displayvalue = localizedScore;
    }
  } catch (error) {
    console.log(error);
    showError(SingleScore.containerId, 'An error occured while generating chart.');
  }
};
SingleScore.prototype.generateTitle = function generateTitle(titleProps) {
  var defaultFontSize = 14;
  var $container = jQuery('#' + this.containerId).find('.single-score');
  var $titleEl = jQuery('<div class="singlescore_title"/>')
    .text(titleProps.title)
    .attr('title', titleProps.title);
  if ($titleEl.tooltip && !this.isServicePortal)
    $titleEl
    .attr('data-container', 'body')
    .attr('data-placement', 'top')
    .tooltip()
    .hideFix();
  if (titleProps.chart_title_color)
    $titleEl.css('color', titleProps.chart_title_color);
  if (titleProps.chart_title_size)
    $titleEl.css('font-size', titleProps.chart_title_size + 'px');
  if (titleProps.title_horizontal_alignment)
    $titleEl.css('text-align', titleProps.title_horizontal_alignment);
  if (!titleProps.custom_chart_title_position)
    switch (titleProps.title_vertical_alignment) {
      case 'top':
        $container.prepend($titleEl);
        break;
      case 'middle':
        $titleEl.css({
          position: 'absolute',
          width: '100%',
          top: '50%',
          'margin-top': -(titleProps.chart_title_size / 2) || -(defaultFontSize / 2)
        });
        $container.prepend($titleEl);
        break;
      case 'bottom':
        $container.append($titleEl);
        break;
    }
  else {
    $titleEl.css({
      position: 'absolute',
      top: titleProps.chart_title_y_position,
      left: titleProps.chart_title_x_position
    });
    $container.css({
      paddingTop: (titleProps.chart_title_size + 20) || (20 + defaultFontSize)
    });
    $container.prepend($titleEl);
  }
};
SingleScore.prototype.getMinMargin = function getMinMargin(val) {
  return (val < this.minMargin) ? this.minMargin : val;
};
SingleScore.prototype.checkHeight = function checkHeight(fontSize, height) {
  return ((fontSize + (2 * this.minMargin)) > height) ? parseInt(this.relativeFontSize * height, 10) : fontSize;
};
SingleScore.prototype.buildRequestParams = function buildRequestParams(params) {
  return {
    sysparm_table: params.table,
    sysparm_aggregate: params.aggregate,
    sysparm_sumfield: params.agg_field,
    sysparm_query: params.filter,
    sysparm_interactive_report: params.interactive_report,
    sysparm_report_drilldown: params.report_drilldown,
    sysparm_report_id: params.report_id,
    sysparm_score_color: params.score_color,
    sysparm_chart_title_color: params.chart_title_color,
    sysparm_homepage_sysid: params.homepage_sysid,
    sysparm_chart_background_color: params.chart_background_color,
    sysparm_list_ui_view: params.list_ui_view,
    sysparm_decimal_precision: params.decimal_precision,
    sysparm_report_source_id: params.report_source_id,
    sysparm_is_report_source_filter_already_combined: params.is_report_source_filter_already_combined,
    sysparm_show_zero: params.show_zero,
    sysparm_is_published: params.is_published,
    sysparm_set_redirect: params.set_redirect
  };
};
SingleScore.prototype.showMessage = function showMessage(msg, level) {
  var self = this;
  if (level === 'FAILURE')
    jQuery('#' + self.containerId).html('<div class="single-score-error">ERROR: ' + msg + '</div>');
  else
    jQuery('#' + self.containerId).html('<div>' + msg + '</div>');
};
SingleScore.prototype.resizeHandlers = function resizeHandlers(data) {
  if (data.action === 'resize')
    this.updateSize();
};
SingleScore.prototype.eventHandlers = function eventHandlers() {
  var self = this;
  this.$container.on('click', 'a', function clickCb(ev) {
    ev.preventDefault();
    var openNewTab;
    if (ev.ctrlKey || ev.metaKey)
      openNewTab = true;
    if (self.widgetNav)
      window.open(self.widgetNav, openNewTab ? '_blank' : '_self');
    else {
      var drillDownUrl = jQuery(this).attr('rel');
      drillDownUrl = decodeURIComponent(drillDownUrl);
      generateDataPointClickUrl(ev, '#' + self.containerId, self.reportDrilldown, self.table, drillDownUrl, self.listUIViewName, self.drillOpenNewWin);
    }
  });
  if (jQuery && window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && self.containerId.indexOf('preview') === -1) {
    var rootReportId = self.$container.closest('.grid-stack-item').find(self.rootReportElementClass).first().val();
    var uuid = self.$container.closest('.grid-stack-item').attr('data-uuid');
    if (uuid) {
      window.SNC.reportResizingFunctions = window.SNC.reportResizingFunctions || {};
      SNC.canvas.eventbus.subscribe(uuid, this.resizeHandlers.bind(this));
      SNC.reportResizingFunctions[uuid] = this.resizeHandlers;
    }
    window.SNC.reportResizingTimeouts = window.SNC.reportResizingTimeouts || {};
    window.addEventListener('resize', function resizeCb() {
      if (SNC.reportResizingTimeouts[rootReportId])
        clearTimeout(SNC.reportResizingTimeouts[rootReportId]);
      SNC.reportResizingTimeouts[rootReportId] = setTimeout(function resizingTimeoutCb() {
        self.updateSize();
      }, 250);
    }, false);
  }
};;
/*! RESOURCE: /scripts/reportcommon/customvisuals/calendar.js */
var Calendar = function Calendar(reportUUID, runType, reportParams) {
  'use strict';
  var Moment = moment;
  if (!reportParams) {
    reportParams = window.g_report_params[reportUUID];
    reportParams.is_report_source_filter_already_combined = true;
  }
  createReportTemplate(reportUUID, reportParams);
  this.combinedFilter = reportParams.filter;
  this.containerId = 'chart-container-' + reportUUID;
  this.startTime = new Date().getTime();
  var self = this;

  function showMessage(msg, level) {
    if (level === 'FAILURE')
      jQuery('#' + self.containerId).siblings('.report-message').addClass('pivot-error').text(msg);
    else
      jQuery('#' + self.containerId).siblings('.report-message').text(msg);
  }
  this.init = function init() {
    showReportIsLoading(findGridWindowFromElementID(self.containerId));
    self.runCalendar(reportParams, runType);
  };
  this.runCalendar = function runCalendar() {
    self.reportId = reportParams.report_id || 'calendar';
    window.calendarReport = window.calendarReport || {};
    window.calendarReport[self.reportId] = window.calendarReport[self.reportId] || {};
    reportParams.styleField = reportParams.styleField || window.calendarReport[self.reportId].highlight || reportParams.calstyle;
    var defaultDateOverride = null;
    if (reportParams.year || reportParams.month || reportParams.day)
      defaultDateOverride = moment({
        year: reportParams.year,
        month: reportParams.month,
        day: reportParams.day
      }).format('YYYY-MM-DD');
    if (reportParams.calview === 'week')
      reportParams.calview = 'agendaWeek';
    else if (reportParams.calview === 'day')
      reportParams.calview = 'agendaDay';
    var calWidth = jQuery('#' + self.containerId).width();
    var yearCols = 2;
    if (calWidth < 640)
      yearCols = 1;
    else if (calWidth > 1280)
      yearCols = 3;
    jQuery('#' + self.containerId).empty().fullCalendar('destroy');
    jQuery('#' + self.containerId).fullCalendar({
      theme: false,
      buttonText: chartHelpers.i18n.buttonText,
      dayNames: chartHelpers.i18n.daysNames,
      dayNamesShort: chartHelpers.i18n.dayNamesShort,
      monthNames: chartHelpers.i18n.monthNames,
      monthNamesShort: chartHelpers.i18n.monthNamesShort,
      allDayHtml: chartHelpers.i18n.allDayHtml,
      weekNumberTitle: chartHelpers.i18n.weekNumberTitleShort,
      weekNumberCalculation: window.chartHelpers.systemParams.firstDay === 0 ? 'local' : 'ISO',
      isRTL: chartHelpers.i18n.isRTL,
      buttonIcons: {
        prev: 'left-single-arrow',
        next: 'right-single-arrow',
        prevYear: 'left-double-arrow',
        nextYear: 'right-double-arrow'
      },
      fixedWeekCount: true,
      timeFormat: 'H:mm',
      slotLabelFormat: 'H:mm',
      axisFormat: 'H:mm',
      firstDay: window.chartHelpers.systemParams.firstDay,
      defaultDate: window.calendarReport[self.reportId].start || defaultDateOverride || window.chartHelpers.systemParams.defaultDate,
      defaultView: window.calendarReport[self.reportId].view || reportParams.calview || 'month',
      defaultTimedEventDuration: window.chartHelpers.systemParams.defaultEventDuration,
      yearColumns: yearCols,
      slotEventOverlap: window.chartHelpers.systemParams.slotEventOverlap ? true : false,
      lazyFetching: false,
      height: 'auto',
      contentHeight: 'auto',
      eventLimit: parseInt(window.chartHelpers.systemParams.maxEventsDisplayedPerCell, 10) + 1,
      nextDayThreshold: '00:00:00',
      eventLimitText: function eventLimitText(amountOfEvents) {
        if (amountOfEvents <= parseInt(window.chartHelpers.systemParams.maxMoreEventsPerDay, 10))
          return chartHelpers.i18n.plusMore.format(amountOfEvents);
        return chartHelpers.i18n.plusMany;
      },
      eventLimitClick: function eventLimitClick(cellInfo, jsEvent) {
        setTimeout(function timeoutCb() {
          jQuery('#' + self.containerId).find('.fc-close').attr('tabindex', 0);
        }, 500);
        if (cellInfo.date && cellInfo.hiddenSegs && cellInfo.hiddenSegs.length > parseInt(window.chartHelpers.systemParams.maxMoreEventsPerDay, 10)) {
          var selectedDate = moment(cellInfo.date).format('YYYY-MM-DD');
          self.drillViewToList({
            data: {
              startDate: selectedDate,
              endDate: selectedDate
            }
          });
          return false;
        }
        return 'popover';
      },
      views: {
        month: {
          weekNumbers: true
        },
        year: {
          weekNumbers: true
        }
      },
      header: {
        left: 'agendaDay,agendaWeek,month,year',
        center: 'title',
        right: 'today prevYear,prev,next,nextYear'
      },
      eventDataTransform: function(event) {
        var view = jQuery('#' + self.containerId).fullCalendar('getView');
        if (view.name === 'agendaDay') {
          if (event.start && event.end) {
            var viewStartMoment = new Moment(view.intervalStart.toISOString());
            var viewEndMoment = new Moment(view.intervalEnd.toISOString());
            if ((viewStartMoment.isSame(event.start) || viewStartMoment.isAfter(event.start)) &&
              (viewEndMoment.isBefore(event.end) || viewEndMoment.isSame(event.end)))
              event.allDay = true;
          }
        } else if (view.name === 'agendaWeek')
          if (event.start && event.end) {
            var eventStartMoment = new Moment(event.start);
            var eventEndMoment = new Moment(event.end);
            var hoursDiff = eventEndMoment.diff(eventStartMoment, 'hours');
            var startOfDayOfEventStartMoment = new Moment(event.start).startOf('day');
            if (hoursDiff >= 24 &&
              ((startOfDayOfEventStartMoment).isSame(eventStartMoment) ||
                eventEndMoment.diff(startOfDayOfEventStartMoment, 'day') >= 2))
              event.allDay = true;
          }
        return event;
      },
      eventMouseover: function eventMouseover(event, jsEvent, view) {
        if (window.chartHelpers.systemParams.enablePreviewOnHover && window.chartHelpers.systemParams.enablePreviewOnHover !== 'false')
          popRecordDiv(jsEvent, reportParams.table, event.id);
      },
      eventMouseout: function eventMouseout(event, jsEvent, view) {
        if (window.chartHelpers.systemParams.enablePreviewOnHover && window.chartHelpers.systemParams.enablePreviewOnHover !== 'false')
          lockPopup(jsEvent);
      },
      viewRender: function viewRender(view, element) {
        jQuery('#' + self.containerId).siblings('.report-message').text(chartHelpers.i18n.building);
      },
      eventAfterAllRender: function eventAfterAllRender(view) {
        var start = new Moment(view.intervalStart.toISOString());
        if (start.isValid())
          window.calendarReport[self.reportId] = {
            view: view.name,
            start: start.format('YYYY-MM-DD'),
            highlight: reportParams.styleField
          };
        var viewStart = new Moment(view.start.toISOString());
        if (viewStart.isValid()) {
          var dateAfterLastDateInView = new Moment(view.end.toISOString());
          var viewEnd = dateAfterLastDateInView.subtract(1, 'day');
          self.buildDrillViewToListLink(viewStart.format('YYYY-MM-DD'), viewEnd.format('YYYY-MM-DD'));
        }
        jQuery('#' + self.containerId).siblings('.report-message').empty();
        if (window.g_accessibility === 'true' || window.g_accessibility === true)
          self.enableAccessibility();
      },
      eventSources: [{
        allDayDefault: false,
        backgroundColor: 'white',
        borderColor: 'lightgrey',
        textColor: 'black',
        editable: false,
        events: function events(start, end, timezone, fullCalendarCallback) {
          var processor = runType === 'run' ? 'CalendarRunProcessor' : 'CalendarRunPublishedProcessor';
          jQuery.ajax({
            method: 'POST',
            url: '/xmlhttp.do',
            dataType: 'xml',
            headers: {
              'X-UserToken': window.g_ck
            },
            data: {
              sysparm_processor: processor,
              sysparm_scope: 'global',
              is_portal: reportParams.is_portal,
              start_date: start.format('YYYY-MM-DD').toString(),
              end_date: end.format('YYYY-MM-DD').toString(),
              style_field: reportParams.styleField,
              sysparm_timer: new Date().getTime(),
              sysparm_request_params: JSON.stringify(self.buildRequestParams(reportParams))
            }
          }).done(function doneCb(xml) {
            self.processResponse(xml, fullCalendarCallback);
          }).fail(function failCb(jqXHR, textStatus, error) {
            console.log(textStatus, error);
          });
        }
      }],
      dayClick: function dayClick(date, jsEvent, view) {
        jQuery('#' + self.containerId).fullCalendar('changeView', 'agendaDay');
        jQuery('#' + self.containerId).fullCalendar('gotoDate', date);
      }
    });
  };
  this.buildDrillViewToListLink = function buildDrillViewToListLink(startDateString, endDateString) {
    var $drillToListLink = jQuery('#' + self.containerId + ' #drillViewToList');
    if (!$drillToListLink.length) {
      $drillToListLink = jQuery('<a/>', {
        id: 'drillViewToList',
        class: 'all-records-link',
        target: '_blank'
      }).text(chartHelpers.i18n.viewAllRecords);
      jQuery('#' + self.containerId + ' .highlight-wrap').append($drillToListLink);
    }
    $drillToListLink.attr('href', self.buildDrillViewToListUrl(startDateString, endDateString));
  };
  this.buildDrillViewToListUrl = function buildDrillViewToListUrl(startDate, endDate) {
    var calField = reportParams.cal_field;
    var query = '';
    if (self.combinedFilter)
      query += self.combinedFilter + '^';
    var minutesToSubtract = moment.duration(window.chartHelpers.systemParams.defaultEventDuration, 'HH:mm:ss').asMinutes();
    query += calField + '>=javascript:gs.dateAdd(\'minute\', -' + minutesToSubtract + ', gs.dateGenerate(\'' + startDate + '\',\'start\'))^' + calField + '<=javascript:gs.dateGenerate(\'' + endDate + '\',\'end\')';
    var isStartField = calField.indexOf('_start', calField.length - '_start'.length) !== -1 || calField.indexOf('start_') === 0 || calField.indexOf('_start_') !== -1 || calField === 'start';
    if (isStartField) {
      var calEndField = calField.replace(/start/g, 'end');
      var hasEndField = true;
      if (typeof Table !== 'undefined') {
        var calendarTable = Table.get(reportParams.table);
        if (calendarTable)
          var element = calendarTable.getElement(calEndField);
        if (!element)
          hasEndField = false;
      }
      if (hasEndField) {
        var firstDateBeforeStart = new Moment(startDate).subtract(parseInt(window.chartHelpers.systemParams.maxDaysBack, 10), 'day').format('YYYY-MM-DD');
        query += '^NQ';
        if (self.combinedFilter)
          query += self.combinedFilter + '^';
        query += calField + '>=javascript:gs.dateGenerate(\'' + firstDateBeforeStart + '\',\'start\')^' +
          calField + '<=javascript:gs.dateGenerate(\'' + endDate + '\',\'end\')^' +
          calEndField + '>=javascript:gs.dateGenerate(\'' + startDate + '\',\'start\')^EQ';
      }
    }
    return reportParams.table + '_list.do?sysparm_query=' + encodeURIComponent(query);
  };
  this.drillViewToList = function drillViewToList(event) {
    var startDate = event.data.startDate;
    var endDate = event.data.endDate;
    var drillViewToListUrl = self.buildDrillViewToListUrl(startDate, endDate);
    window.open(drillViewToListUrl, '_blank');
  };
  this.processResponse = function processResponse(response, fullcalendarCallback) {
    if (!response)
      showError(self.containerId, 'No response from the server');
    else {
      var resp = JSON.parse(jQuery(response).find('RESPONSE').text());
      if (resp.STATUS === 'SUCCESS')
        try {
          var responseData = resp.RESPONSE_DATA;
          self.combinedFilter = responseData.filterQuery;
          self.populateStyleFields(responseData.styleFields);
          fullcalendarCallback(responseData.calendarEvents);
          if (responseData.message)
            showMessage(responseData.message, 'INFO');
        } catch (err) {
          showMessage(chartHelpers.i18n.chartGenerationError, 'FAILURE');
          console.log(err);
        }
      else {
        fullcalendarCallback([]);
        showMessage(resp.RESPONSE_DATA, resp.STATUS);
      }
    }
    hideReportIsLoading(findGridWindowFromElementID(self.containerId));
    var now = new Date().getTime();
    var elapsedTime = (now - self.startTime) / 1000;
    console.log('Time taken to render report: ' + elapsedTime);
  };
  this.populateStyleFields = function populateStyleFields(styleFields, args) {
    if (jQuery('#' + self.containerId + ' .highlight-dropdown').length)
      return;
    var $highlightWrap = jQuery('#' + self.containerId).append('<div class="highlight-wrap"/>');
    if (styleFields && styleFields.length) {
      var highlightOptions;
      var selectedOption = '';
      for (var i = 0; i < styleFields.length; i++) {
        if (i === 0)
          highlightOptions += '<option value="">' + chartHelpers.i18n.none + '</option>';
        if (reportParams.styleField)
          if (styleFields[i].name === reportParams.styleField)
            highlightOptions += '<option selected="selected" value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
          else
            highlightOptions += '<option value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
        else
          highlightOptions += '<option  value="' + styleFields[i].name + '" >' + styleFields[i].label + '</option>';
      }
      $highlightWrap.find('.highlight-wrap')
        .append(jQuery('<label for="highlight_field" />').text(chartHelpers.i18n.highlightBasedOn)).append(jQuery('<select id="highlight_field" class="highlight-dropdown form-control"/>')
          .html(highlightOptions));
      jQuery('#' + self.containerId + ' .highlight-dropdown').on('change', function changeCb() {
        reportParams.styleField = this.value;
        jQuery('#' + self.containerId).fullCalendar('refetchEvents');
      });
    }
  };
  this.enableAccessibility = function enableAccessibility() {
    jQuery('#' + self.containerId).find('table').attr('role', 'grid').find('tr')
      .attr('role', 'row')
      .find('.fc-more')
      .attr('tabindex', 0);
    jQuery('#' + self.containerId).find('thead th').attr({
      role: 'columnheader',
      scope: 'col'
    });
    jQuery('#' + self.containerId).find('tbody td').attr({
      role: 'gridcell'
    });
  };
  this.buildRequestParams = function buildRequestParams() {
    return {
      sysparm_cal_field: reportParams.cal_field,
      sysparm_table: reportParams.table,
      sysparm_report_id: reportParams.report_id,
      sysparm_report_source_id: reportParams.report_source_id,
      sysparm_is_report_source_filter_already_combined: reportParams.is_report_source_filter_already_combined,
      sysparm_query: reportParams.filter,
      sysparm_list_ui_view: reportParams.list_ui_view,
      sysparm_homepage_sysid: reportParams.homepage_sysid,
      sysparm_is_published: reportParams.is_published
    };
  };
  this.init();
};
String.prototype.format = function formatString() {
  var args = arguments;
  return this.replace(/\{(\d+)\}/g, function replaceCb() {
    return args[arguments[1]];
  });
};;
/*! RESOURCE: /scripts/reportcommon/hcformatterfuncs.js */
function hc_legendLabelShortenedFormatter() {
  var legendLabelMaxLength = (this.userOptions !== undefined && this.userOptions.legend_label_max_length !== undefined) ? this.userOptions.legend_label_max_length : 30;
  return this.name.length > legendLabelMaxLength ? this.name.substring(0, legendLabelMaxLength) + '...' : this.name;
}

function hc_legendLabelPercentFormatter() {
  return this.name + ' = ' + this.y_tooltip + ' (' + this.percent + '%)';
}

function hc_legendLabelShortenedPercentFormatter() {
  var shortenedLabel = this.name.length > this.options.legend_label_max_length ? this.name.substring(0, this.options.legend_label_max_length) + '...' : this.name;
  return shortenedLabel + ' = ' + this.y_tooltip + ' (' + this.percent + '%)';
}

function hc_formatNameValueLabel() {
  var label = this.point.name + ' = ' + ((typeof this.point.y_tooltip !== 'undefined') ? this.point.y_tooltip : this.point.y);
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  return label;
}

function hc_formatParetoAxisLabels() {
  var total = 1.0;
  var pcnt = Highcharts.numberFormat(((this.value / parseFloat(total)) * 100), 0, '.');
  return pcnt + '%';
}

function hc_formatValueLabel() {
  var label = ((typeof this.point.y_tooltip !== 'undefined') ? this.point.y_tooltip : this.point.y);
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  if (label)
    return label;
  return undefined;
}

function hc_formatParetoLabelLine() {
  var label = this.point.percent + '%';
  var labelMaxLength = (this.point.data_label_max_length !== undefined) ? this.point.data_label_max_length : 16;
  var truncateLabels = (this.point.truncate_data_labels !== undefined) ? this.point.truncate_data_labels : 'false';
  var removeLeading = (this.point.data_labels_remove_leading !== undefined) ? this.point.data_labels_remove_leading : 'false';
  if (truncateLabels === true && label.length > labelMaxLength)
    label = (removeLeading === true) ? label = '...' + label.substring(label.length - labelMaxLength) : label.substring(0, labelMaxLength) + '...';
  return label;
}

function hc_formatDurationLabel() {
  var secs = this.value;
  var prepend = '';
  if (secs < 0)
    prepend = '-';
  if (secs < 0)
    secs *= -1;
  var days = Math.floor(secs / 86400);
  var hours = Math.floor((secs % 86400) / 3600);
  var mins = Math.floor(((secs % 86400) % 3600) / 60);
  secs = ((secs % 86400) % 3600) % 60;
  var i18n = this.chart.options.lang;
  if (days > 0)
    return prepend + days + ' ' + i18n.days.toLowerCase() + ' ' + hours + ' ' + i18n.hours.toLowerCase() + ' ' + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  if (hours > 0)
    return prepend + hours + ' ' + i18n.hours.toLowerCase() + ' ' + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  if (mins > 0)
    return prepend + mins + ' ' + i18n.minutes.toLowerCase() + ' ' + secs + ' ' + i18n.seconds.toLowerCase();
  return prepend + secs + ' ' + i18n.seconds.toLowerCase();
};
/*! RESOURCE: /scripts/interactive_reports.js */
function getListURL(table, urlInfo, viewName) {
  var url = {};
  url.endpoint = '/' + table + '_list.do';
  url.params = {};
  if (urlInfo)
    url.params.sysparm_query = urlInfo;
  if (viewName)
    url.params.sysparm_view = viewName;
  return generateWholeUrl(url);
}

function generateWholeUrl(url) {
  if (!jQuery.isEmptyObject(url.params))
    return url.endpoint + '?' + Object.keys(url.params).map(function mapFunction(key) {
      return key + '=' + encodeURIComponent(url.params[key]).replace(/%40/gi, '@').replace(/%3A/gi, ':');
    }).join('&');
  return url.endpoint;
}

function drillReport(targetSpan, reportDrillId, newQuery, extraParams) {
  var interactiveReport = {};
  var url = {};
  url.params = {};
  interactiveReport.additional_query = newQuery;
  url.endpoint = '/report_viewer.do';
  var $publicPage = jQuery('#public-page');
  if ($publicPage.length && $publicPage.val() === 'true')
    url.endpoint = '/report_viewer_published.do';
  url.params.jvar_report_id = reportDrillId;
  url.params.sysparm_interactive_report = JSON.stringify(interactiveReport);
  if (extraParams)
    url.endpoint = url.endpoint + '?' + extraParams;
  reportReplace(targetSpan, url, true);
}

function drillList(targetSpan, table, newQuery, listView) {
  var url = {};
  url.endpoint = '/report_viewer.do';
  url.params = {
    sysparm_type: 'list',
    sysparm_query: newQuery,
    sysparm_view: listView,
    sysparm_table: table
  };
  reportReplace(targetSpan, url);
}

function embedReportById(targetSpan, reportId) {
  embedReportByParams(targetSpan, {
    jvar_report_id: reportId
  });
}

function isServicePortal() {
  return jQuery('html').attr('ng-app') === 'ng_spd' || (window.NOW && window.NOW.hasOwnProperty('sp'));
}

function embedReportByParams(targetSpan, params) {
  var url = {};
  url.params = {};
  url.endpoint = '/report_viewer.do';
  if (!isServicePortal())
    url.params.sysparm_inline_embed = 'true';
  if (params)
    for (var key in params)
      if (typeof params[key] !== 'undefined')
        url.params[key] = params[key].toString() || '';
  reportReplace(targetSpan, url);
}

function reportReplace(targetSpan, url, stick) {
  if (!targetSpan)
    throw new Error('Report replace called, but the element to replace was not found!');
  CustomEvent.fireTop('request_start', document);
  url.params = url.params || {};
  url.params.sysparm_nostack = 'true';
  url.params['ni.nolog.x_referer'] = 'ignore';
  url.params.x_referer = buildReferringURL();
  var isPortal = targetSpan.find('.jvar_is_portal').first();
  var rootReportId;
  if (isPortal.length && isPortal.val() === 'true')
    url.params.jvar_is_portal = 'true';
  if (isServicePortal())
    url.params.jvar_is_portal = 'true';
  if (window.isEmbeddedReport === 'true')
    window.location.href = generateWholeUrl(url);
  else {
    if (window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && SNC.reportResizingFunctions) {
      rootReportId = targetSpan.find('.sysparm_root_report_id').first().val();
      var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(rootReportId);
      if (uuid && SNC.reportResizingFunctions[uuid])
        SNC.canvas.eventbus.unsubscribe(uuid, SNC.reportResizingFunctions[uuid]);
    }
    url.params.sysparm_direct = 'true';
    if (window.isInlineEmbed) {
      rootReportId = targetSpan.find('.sysparm_root_report_id').first().val();
      url.params.sysparm_inline_embed = window.isInlineEmbed[rootReportId];
    }
    showReportIsLoading(findGridWindowFromElement(targetSpan), targetSpan, stick);
    url.params.sysparm_processor = '';
    url.params.sysparm_scope = 'global';
    url.params.jvar_report_id = url.params.jvar_report_id || '';
    url.params.sysparm_interactive_report = url.params.sysparm_interactive_report || '';
    jQuery.ajax({
      method: 'POST',
      url: url.endpoint,
      dataType: 'text',
      data: url.params
    }).done(function doneAjax(xml) {
      reportReplaceCallback(xml, targetSpan);
    }).fail(function failedAjax(jqXHR, textStatus, error) {
      console.log(textStatus, error);
    });
  }
}

function evaluateScriptTags(htmlNode) {
  var arr = htmlNode.getElementsByTagName('script');
  try {
    for (var n = 0; n < arr.length; n++) {
      if (arr[n].type !== 'application/xml' && arr[n].innerHTML)
        eval(arr[n].innerHTML);
    }
  } catch (error) {
    throw new Error(error);
  }
}

function reportReplaceCallback(html, targetSpan) {
  var scrollTop;
  if (window.isMSIE)
    scrollTop = document.body.scrollTop;
  var isList = html.indexOf('chart_type = "list"') > -1;
  if (isRenderedInCanvas()) {
    html += ' <div class="end-of-widget"></div>';
    updateWidgetCacheInCanvas(html, targetSpan);
  }
  if (isList && isServicePortal())
    html = '<div style="margin:20px 10px;">List chart is not supported in Service Portal widgets. Please use Simple List widget instead.</div>';
  if (targetSpan[0])
    targetSpan[0].innerHTML = html;
  var htmlNode = document.createElement('div');
  htmlNode.innerHTML = html;
  if (isList && !isServicePortal())
    html.evalScripts();
  else
    evaluateScriptTags(htmlNode);
  CustomEvent.fireTop('request_complete', document);
  CustomEvent.fire('partial.page.reload', targetSpan);
  if (window.isMSIE)
    document.body.scrollTop = scrollTop;
}

function generateDataPointClickUrl(event, element, reportDrilldown, table, clickUrlInfo, listUiViewName, drillOpenNewWin, isOther, mapKey, actualMap, showDataLabel, showGeographicalLabel) {
  var clickUrl;
  if (typeof jQuery !== 'undefined') {
    var content = jQuery(element).closest('.report_content');
    if (content.length && reportDrilldown) {
      var mapParams = '';
      if (mapKey)
        mapParams = 'sysparm_report_map_key=' + mapKey;
      if (actualMap)
        mapParams += '&sysparm_report_map_parent=' + actualMap;
      if (showDataLabel)
        mapParams += '&sysparm_show_chart_data_label=' + showDataLabel;
      if (showGeographicalLabel)
        mapParams += '&sysparm_show_geographical_label=' + showGeographicalLabel;
      drillReport(content.parent(), reportDrilldown, clickUrlInfo, mapParams);
      return;
    }
    clickUrl = getListURL(table, clickUrlInfo, listUiViewName);
  }
  clickUrl = getListURL(table, clickUrlInfo, listUiViewName);
  if (isServicePortal())
    clickUrl = addNavToUrl(clickUrl);
  openUrl(event, clickUrl, drillOpenNewWin, isOther);
}

function addNavToUrl(url) {
  return '/nav_to.do?uri=' + encodeURIComponent(url);
}

function openUrl(event, clickUrl, drillOpenNewWin, isOther) {
  if (('metaKey' in event && event.metaKey) || event.ctrlKey)
    window.open(clickUrl);
  else if (isServicePortal())
    top.location.href = clickUrl;
  else if (drillOpenNewWin && !isOther)
    window.open(clickUrl);
  else if (clickUrl)
    window.location.href = clickUrl;
}

function applyExecutiveReport(reportId, groupEl, stackEl, filter) {
  var $groupEl = jQuery(groupEl);
  var $stackEl = jQuery(stackEl);
  var target = $groupEl.closest('.report_content');
  if (target.length)
    target = target.parent();
  var interactiveReport = {};
  interactiveReport.groupby = $groupEl.val();
  if (filter)
    interactiveReport.additional_query = filter;
  if ($stackEl)
    interactiveReport.stackby = $stackEl.val();
  var gaugeId = $groupEl.closest('.sysparm_gauge_id');
  var gridWindow;
  if (typeof glideGrid !== 'undefined' && target && target.length)
    gridWindow = glideGrid.getWindow(target.closest('[dragpart]').first().attr('dragpart'));
  else if (gaugeId)
    gridWindow = _getGridWindow(gaugeId.value, reportId);
  if (gridWindow && gridWindow.getDashboardMessageHandler() !== undefined)
    interactiveReport.additional_filters = gridWindow.getDashboardMessageHandler().getCurrentFilters();
  interactiveReport = JSON.stringify(interactiveReport);
  var interactiveReportEl = jQuery('#sysparm_interactive_report')[0];
  if (((typeof runReport === 'function' && interactiveReportEl) || (typeof gReport !== 'undefined' && gReport.isDesigner)) && !filter) {
    if (typeof runReport === 'function') {
      interactiveReportEl.value = interactiveReport;
      runReport(false);
    } else
      NOW.CustomEvent.fire('reportDesigner:runInteractiveReport', interactiveReport);
  } else {
    var $publicPage = jQuery('#public-page');
    var url = {
      endpoint: $publicPage.length && $publicPage.val() === 'true' ? '/report_viewer_published.do' : '/report_viewer.do',
      params: {
        jvar_report_id: reportId,
        sysparm_interactive_report: interactiveReport
      }
    };
    reportReplace(target, url);
  }
}

function initializeInteractionOnGauge(reportId, rootReportId, gaugeId, homepageFilters, chartType, aggregateType) {
  if (!gaugeId)
    return;
  var gridWindow = _getGridWindow(gaugeId, rootReportId);
  if (typeof gridWindow === 'undefined' || !gridWindow)
    return;
  var realTime = chartType === 'single_score' && aggregateType === 'COUNT';
  if (realTime) {
    gridWindow.setPreference('can_real_time', 'true');
    if (window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.appProperties.sysparm_media !== 'print') {
      var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(reportId);
      SNC.canvas.canvasUtils.displayRealTimeIndicator(uuid, gridWindow.getPreference('real_time') === 'true');
    }
  }
  gridWindow.setPreference('can_subscribe', 'true');
  var supportedPublisherChartTypes = ['pie', 'donut', 'semi_donut', 'funnel', 'pyramid', 'map'];
  if (supportedPublisherChartTypes.indexOf(chartType) > -1)
    gridWindow.setPreference('can_publish', 'true');
  else
    gridWindow.removePreference('can_publish');
  if (gridWindow.getDashboardMessageHandler() !== undefined) {
    gridWindow.getDashboardMessageHandler().setCurrentFilters(homepageFilters);
    gridWindow.overwriteRefresh(function overwriteRefreshCallback() {
      updateReportInGauge(gridWindow, true, reportId);
    });
    var updateReportFn = updateReportInGauge.bind(null, gridWindow, false, reportId);
    var updateReportWithDelay = debounceHandler(updateReportFn, 600, false);
    var updateReportNow = debounceHandler(updateReportFn, 0, true);
    gridWindow.getDashboardMessageHandler().setCallback(function getDashboardMessageHandlerCallback() {
      var target = getTargetFromGridWindow(gridWindow);
      if (isRenderedInCanvas())
        showCanvasStyleLoading(target);
      applyInteractiveFiltersToReport(updateReportWithDelay, updateReportNow);
    });
  } else
    gridWindow.overwriteRefresh(function overwriteRefreshSimpleCallback() {
      simpleReportRefresh(gaugeId, rootReportId);
    });
}

function _getGridWindow(gaugeId, reportId) {
  var gridWindow;
  if (typeof glideGrid !== 'undefined') {
    gridWindow = glideGrid.getWindowByGaugeId(gaugeId);
    if (typeof gridWindow === 'undefined')
      gridWindow = glideGrid.getWindowByGaugeId(reportId);
  } else if (window.SNC && window.SNC.canvas && window.SNC.canvas.canvasUtils) {
    gridWindow = SNC.canvas.canvasUtils.getGlideWindow(gaugeId);
    if (typeof gridWindow === 'undefined')
      gridWindow = SNC.canvas.canvasUtils.getGlideWindow(reportId);
  }
  return gridWindow;
}

function updateReportInGauge(gridWindow, refresh, reportId) {
  var interactiveReport = {};
  if (gridWindow)
    interactiveReport.additional_filters = getAdditionalFilter(gridWindow);
  if (refresh && gridWindow && gridWindow.consumed)
    interactiveReport.additional_filters = gridWindow.consumed;
  updateAdditionalReportConfig(gridWindow, reportId, interactiveReport, refresh);
  if (gridWindow) {
    gridWindow.consumed = gridWindow.consumed || {};
    gridWindow.consumed = interactiveReport.additional_filters;
  }
  var target;
  target = getTargetFromGridWindow(gridWindow);
  if (target && target.length) {
    if (refresh) {
      reportId = target.find('.sysparm_root_report_id').first().val();
    } else {
      var filter = target.find('.sysparm_interactive_filter').first().val();
      if (typeof filter !== 'undefined' && filter)
        interactiveReport.additional_query = filter;
      var groupEl = gel('additional_groupby_' + reportId);
      var stackEl = gel('additional_stackby_' + reportId);
      if (groupEl)
        interactiveReport.groupby = groupEl.value;
      if (stackEl)
        interactiveReport.stackby = stackEl.value;
    }
  }
  var url = {
    endpoint: '/report_viewer.do',
    params: {
      jvar_report_id: reportId,
      jvar_real_time: gridWindow && gridWindow.getPreference('real_time') && gridWindow.getPreference('can_real_time'),
      sysparm_interactive_report: JSON.stringify(interactiveReport)
    }
  };
  reportReplace(target, url);
  if (!isRenderedInCanvas())
    showFilterIndicator(target, gridWindow);
}

function simpleReportRefresh(gaugeId, reportId) {
  var gridWindow = _getGridWindow(gaugeId, reportId);
  if (typeof gridWindow !== 'undefined' && gridWindow) {
    if (typeof jQuery !== 'undefined')
      showReportIsLoading(gridWindow);
    gridWindow.render();
  }
}

function isRenderedInCanvas() {
  return window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive;
}

function findGridWindowFromElementID(id) {
  if (typeof jQuery === 'undefined')
    return null;
  if (typeof glideGrid !== 'undefined')
    return glideGrid.getWindow(jQuery(document).find('#' + id).closest('[dragpart]').first()
      .attr('dragpart'));
  return null;
}

function findGridWindowFromElement(target) {
  if (typeof jQuery === 'undefined')
    return null;
  if (typeof glideGrid !== 'undefined')
    return glideGrid.getWindow(target.closest('[dragpart]').first().attr('dragpart'));
  return null;
}

function showReportIsLoading(gridWindow, targetSpan, stick) {
  var reportContent;
  var loadingMsg = window.GwtMessage ? new GwtMessage().getMessage('Loading report...') : 'Loading report...';
  if (isServicePortal() || isRenderedInCanvas()) {
    showCanvasStyleLoading(targetSpan);
    return;
  }
  if (!gridWindow) {
    if (targetSpan && targetSpan.length > 0)
      reportContent = targetSpan[0];
    if (!reportContent)
      reportContent = document.querySelector('.report_content .chart-container');
    if (!reportContent)
      reportContent = document.querySelector('.report_content');
    if (reportContent)
      reportContent.textContent = loadingMsg;
    return;
  }
  gridWindow.showLoading(loadingMsg, stick);
}

function hideReportIsLoading(gridWindow) {
  if (typeof gridWindow === 'undefined' || !gridWindow)
    return;
  gridWindow.hideLoading();
}

function showFilterIndicator(target, gridWindow) {
  var isFilterSelected = gridWindow.getDashboardMessageHandler().getCurrentFilters().length > 0;
  var isSubscribedAndOptedForFilterIndication = gridWindow.getPreference('can_subscribe') && typeof gridWindow.getPreference('filter_indicator') === 'undefined' ? false : gridWindow.getPreference('filter_indicator');
  var condition = isFilterSelected && (isSubscribedAndOptedForFilterIndication === 'true');
  var filterIndicatorPlaceholder = jQuery('#filter-indicator-' + gridWindow.id);
  if (condition)
    filterIndicatorPlaceholder.addClass('active');
  else
    filterIndicatorPlaceholder.removeClass('active');
}

function buildReferringURL() {
  var path = location.pathname;
  var args = location.search;
  if (path.substring(path.length - 1) === '/') {
    if (args)
      return args;
    return '';
  }
  return path.substring(path.lastIndexOf('/') + 1) + args;
}

function updateAdditionalReportConfig(gridWindow, reportId, interactiveReport, refresh) {
  var isBothPublisherNSubscriber = gridWindow && gridWindow.preferences.can_publish && gridWindow.preferences.can_subscribe;
  if (isBothPublisherNSubscriber) {
    var allFilters = isRenderedInCanvas() ? SNC.canvas.interactiveFilters.getDefaultValues() : getAllFiltersForHomePage();
    if (gridWindow.filtersFromLegend)
      interactiveReport.filtersFromLegend = gridWindow.filtersFromLegend;
    var otherFilterCount = 0;
    for (var key in allFilters) {
      if (allFilters.hasOwnProperty(key)) {
        var filter = allFilters[key];
        Array.isArray(filter) && filter.forEach(function(item) {
          if (item.sliced)
            otherFilterCount++;
        });
        if (key == reportId) {
          Array.isArray(filter) && filter.forEach(function(item) {
            if (item.sliced) {
              interactiveReport.selectedPoint = item.filter;
              otherFilterCount--;
            }
          });
        }
      }
    }
    if ((!refresh && isFilterValidForRemoval(gridWindow)) || (refresh && otherFilterCount === 0))
      removeSelfPublishedFilter(interactiveReport, reportId);
  }
}

function getAllFiltersForHomePage() {
  var draggables = glideGrid && glideGrid._getDraggables();
  var allFilters = {};
  for (var i = 0; i < draggables.length; i++) {
    var current = draggables[i];
    if (current && current.gWindow && current.gWindow.getDashboardMessageHandler() &&
      !jQuery.isEmptyObject(current.gWindow.getDashboardMessageHandler()._filters)) {
      var keys = Object.keys(current.gWindow.getDashboardMessageHandler()._filters);
      keys.forEach(function(item) {
        allFilters[item] = current.gWindow.getDashboardMessageHandler()._filters[item];
      });
    }
  }
  return allFilters;
}

function removeSelfPublishedFilter(interactiveReport, reportId) {
  var hasAdditionalFilter = interactiveReport.additional_filters && interactiveReport.additional_filters.length && interactiveReport.selectedPoint;
  if (hasAdditionalFilter || interactiveReport.filtersFromLegend) {
    var newFilter = [];
    interactiveReport.additional_filters.forEach(function(filter) {
      var isCascadingFilter = !Array.isArray(filter);
      if (!isCascadingFilter) {
        filter.forEach(function(childFilter) {
          if (childFilter.id && childFilter.id.substring(0, reportId.length) != reportId) {
            newFilter.push(filter);
          } else if (!childFilter.id) {
            newFilter.push(filter);
          }
        });
      } else {
        newFilter.push(filter);
      }
    });
    interactiveReport.additional_filters = newFilter;
  }
}

function showCanvasStyleLoading(target) {
  jQuery(target).find('.report_content').replaceWith('<div class="spinner-container"><div class="icon icon-loading"></div></div>');
}

function debounceHandler(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this,
      args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}

function getTargetFromGridWindow(gridWindow) {
  var target;
  if (typeof jQuery !== 'undefined' && gridWindow) {
    if (isRenderedInCanvas())
      target = jQuery(SNC.canvas.canvasUtils.getWidgetContainer(gridWindow.getID()));
    else
      target = jQuery(gridWindow.body);
  }
  return target;
}

function applyInteractiveFiltersToReport(updateReportWithDelay, updateReportNow) {
  if (!(window.SNC && SNC.canvas && SNC.canvas.chartsActingAsFilters && SNC.canvas.chartsActingAsFilters.lastPublishTime)) {
    updateReportNow();
    return;
  }
  var isFirstFilterPublished = SNC.canvas.chartsActingAsFilters.previousId == null;
  if (isFirstFilterPublished) {
    updateReportWithDelay();
    return;
  }
  var currentTime = Date.now();
  var isFilterPublishedQuickly = (currentTime - SNC.canvas.chartsActingAsFilters.lastPublishTime) < 600;
  var isNewFilterPublishedAfterDelay = (currentTime - SNC.canvas.chartsActingAsFilters.lastPublishTime) > 1000;
  var isFilterFromSameReport = SNC.canvas.chartsActingAsFilters.currentId === SNC.canvas.chartsActingAsFilters.previousId;
  var isFilterFromOneReport = ((isFilterPublishedQuickly || isNewFilterPublishedAfterDelay) && isFilterFromSameReport);
  if (isFilterFromOneReport)
    updateReportWithDelay();
  else
    updateReportNow();
}

function updateWidgetCacheInCanvas(html, targetSpan) {
  try {
    if (SNC.canvas.canvasUtils.updateWidgetCache && typeof SNC.canvas.canvasUtils.updateWidgetCache === "function" && isOnlyInteractiveFilterApplied())
      SNC.canvas.canvasUtils.updateWidgetCache(html, targetSpan);
  } catch (error) {
    if (SNC.canvas.canvasUtils.clearAllWidgetsCache)
      SNC.canvas.canvasUtils.clearAllWidgetsCache();
  }
}

function isOnlyInteractiveFilterApplied() {
  var allFilters = window.SNC && SNC.canvas && SNC.canvas.interactiveFilters && SNC.canvas.interactiveFilters.getDefaultValues();
  var isOnlyInteractiveFilter = true;
  for (var key in allFilters) {
    if (allFilters.hasOwnProperty(key)) {
      var filter = allFilters[key];
      if (Array.isArray(filter) && filter.length) {
        for (var index = 0, len = filter.length; index < len; index++) {
          var item = filter[index];
          if (item.sliced || item.isFromLegend) {
            isOnlyInteractiveFilter = false;
            break;
          }
        }
      }
    }
  }
  return isOnlyInteractiveFilter;
}

function isFilterValidForRemoval(gridWindow) {
  var isValidForRemoval = false;
  if (gridWindow) {
    var isBothPublisherNSubscriber = gridWindow.preferences.can_publish && gridWindow.preferences.can_subscribe;
    var interactiveFilters = gridWindow.interactiveFilters || {};
    var lastItemFromActiveFilterStack = window.SNC && SNC.interactiveChart && SNC.interactiveChart.length && SNC.interactiveChart[SNC.interactiveChart.length - 1];
    if (isBothPublisherNSubscriber && lastItemFromActiveFilterStack && interactiveFilters[lastItemFromActiveFilterStack.id])
      isValidForRemoval = true;
    else if (gridWindow.filtersFromLegend && !(hasBothLegendAndSlicedFilter(interactiveFilters)))
      isValidForRemoval = true;
  }
  return isValidForRemoval;
}

function getAllFiltersFromInteractiveUtil() {
  var allFilters = isRenderedInCanvas() ? SNC.canvas.interactiveFilters.getDefaultValues() : getAllFiltersForHomePage();
  var newFilter = [];
  for (var key in allFilters)
    newFilter.push(allFilters[key]);
  return newFilter;
}

function getAdditionalFilter(gridWindow) {
  var isBothPublisherNSubscriber = gridWindow && gridWindow.preferences.can_publish && gridWindow.preferences.can_subscribe;
  return isBothPublisherNSubscriber ? getAllFiltersFromInteractiveUtil() : gridWindow.getDashboardMessageHandler().getCurrentFilters();
}

function hasBothLegendAndSlicedFilter(interactiveFilters) {
  var fCount = 0;
  var filter;
  if (interactiveFilters) {
    for (var key in interactiveFilters) {
      if (interactiveFilters.hasOwnProperty(key)) {
        filter = interactiveFilters[key];
        if (filter.sliced || filter.isFromLegend)
          fCount++
      }
    }
  }
  return (fCount >= 2);
};
/*! RESOURCE: /scripts/reportcommon/GlideReportChartAjax.js */
var stopWatch;

function runEmbeddedReport(msg_container_id, chart_container_id, title, display_grid, other_threshold, show_empty, table, group_by, filter, aggregate, agg_field, chart_type,
  stack_field, box_field, trend_field, trend_interval, compute_percent, show_other, use_color_palette, chart_size, funnel_neck_percent, donut_width_percent,
  gauge_autoscale, from, to, upper_limit, lower_limit, direction, chart_title, show_chart_title,
  chart_title_size, chart_title_color, custom_chart_title_position, chart_title_x_position, chart_title_y_position,
  title_horizontal_alignment, title_vertical_alignment, legend_horizontal_alignment, legend_vertical_alignment, report_id, show_chart_data_label,
  show_chart_border, chart_border_width, chart_border_radius, chart_border_color, chart_background_color, legend_border_width, legend_border_radius,
  legend_border_color, legend_background_color, show_legend, show_legend_border, chart_height, chart_width, custom_chart_size, report_source_id, bar_unstack, x_axis_title, x_axis_title_size, x_axis_title_color, x_axis_title_bold, x_axis_opposite, x_axis_grid_width, x_axis_grid_color, x_axis_display_grid, x_axis_grid_dotted, x_axis_label_size, x_axis_label_color, x_axis_label_bold, y_axis_title, y_axis_title_size, y_axis_title_color, y_axis_title_bold, y_axis_opposite, y_axis_grid_width, y_axis_grid_color, y_axis_display_grid, y_axis_grid_dotted, y_axis_from, y_axis_to, y_axis_label_size, y_axis_label_color, y_axis_label_bold, show_marker, sc_groupby_item_id, sc_groupby_variable_id, sc_stackby_item_id, sc_stackby_variable_id, list_ui_view, report_drilldown, show_chart_total, use_color_heatmap, axis_max_color, axis_min_color, ct_row, ct_column, show_zero, score_color, interactive_report, set_color, color, colors, color_palette, other_series, report_map
) {
  var params = {};
  params.title = title;
  params.display_grid = display_grid;
  params.other_threshold = other_threshold;
  params.show_empty = show_empty;
  params.table = table;
  params.group_by = group_by;
  params.filter = filter;
  params.aggregate = aggregate;
  params.agg_field = agg_field;
  params.chart_type = chart_type;
  params.stack_field = stack_field;
  params.box_field = box_field;
  params.trend_field = trend_field;
  params.trend_interval = trend_interval;
  params.compute_percent = compute_percent;
  params.show_other = show_other;
  params.chart_size = chart_size;
  params.funnel_neck_percent = funnel_neck_percent;
  params.donut_width_percent = donut_width_percent;
  params.gauge_autoscale = gauge_autoscale;
  params.from = from;
  params.to = to;
  params.upper_limit = upper_limit;
  params.lower_limit = lower_limit;
  params.direction = direction;
  params.chart_title = chart_title;
  params.show_chart_title = show_chart_title;
  params.chart_title_size = chart_title_size;
  params.chart_title_color = chart_title_color;
  params.custom_chart_title_position = custom_chart_title_position;
  params.chart_title_x_position = chart_title_x_position;
  params.chart_title_y_position = chart_title_y_position;
  params.title_horizontal_alignment = title_horizontal_alignment;
  params.title_vertical_alignment = title_vertical_alignment;
  params.legend_horizontal_alignment = legend_horizontal_alignment;
  params.legend_vertical_alignment = legend_vertical_alignment;
  params.report_id = report_id;
  params.show_chart_data_label = show_chart_data_label;
  params.show_chart_border = show_chart_border;
  params.chart_border_width = chart_border_width;
  params.chart_border_radius = chart_border_radius;
  params.chart_border_color = chart_border_color;
  params.chart_background_color = chart_background_color;
  params.legend_border_width = legend_border_width;
  params.legend_border_radius = legend_border_radius;
  params.legend_border_color = legend_border_color;
  params.legend_background_color = legend_background_color;
  params.show_legend = show_legend;
  params.show_legend_border = show_legend_border;
  params.chart_height = chart_height;
  params.chart_width = chart_width;
  params.custom_chart_size = custom_chart_size;
  params.report_source_id = report_source_id;
  params.bar_unstack = bar_unstack;
  params.x_axis_title = x_axis_title;
  params.x_axis_title_size = x_axis_title_size;
  params.x_axis_title_color = x_axis_title_color;
  params.x_axis_title_bold = x_axis_title_bold;
  params.x_axis_opposite = x_axis_opposite;
  params.x_axis_grid_width = x_axis_grid_width;
  params.x_axis_grid_color = x_axis_grid_color;
  params.x_axis_display_grid = x_axis_display_grid;
  params.x_axis_grid_dotted = x_axis_grid_dotted;
  params.x_axis_label_size = x_axis_label_size;
  params.x_axis_label_color = x_axis_label_color;
  params.x_axis_label_bold = x_axis_label_bold;
  params.y_axis_title = y_axis_title;
  params.y_axis_title_size = y_axis_title_size;
  params.y_axis_title_color = y_axis_title_color;
  params.y_axis_title_bold = y_axis_title_bold;
  params.y_axis_opposite = y_axis_opposite;
  params.y_axis_grid_width = y_axis_grid_width;
  params.y_axis_grid_color = y_axis_grid_color;
  params.y_axis_display_grid = y_axis_display_grid;
  params.y_axis_grid_dotted = y_axis_grid_dotted;
  params.y_axis_from = y_axis_from;
  params.y_axis_to = y_axis_to;
  params.y_axis_label_size = y_axis_label_size;
  params.y_axis_label_color = y_axis_label_color;
  params.y_axis_label_bold = y_axis_label_bold;
  params.show_marker = show_marker;
  params.sc_groupby_item_id = sc_groupby_item_id;
  params.sc_groupby_variable_id = sc_groupby_variable_id;
  params.sc_stackby_item_id = sc_stackby_item_id;
  params.sc_stackby_variable_id = sc_stackby_variable_id;
  params.list_ui_view = list_ui_view;
  params.report_drilldown = report_drilldown;
  params.show_chart_total = show_chart_total;
  params.use_color_heatmap = use_color_heatmap;
  params.axis_max_color = axis_max_color;
  params.axis_min_color = axis_min_color;
  params.ct_row = ct_row;
  params.ct_column = ct_column;
  params.show_zero = show_zero;
  params.score_color = score_color;
  params.interactive_report = interactive_report;
  params.set_color = set_color;
  params.color = color;
  params.colors = colors;
  params.color_palette = color_palette;
  params.other_series = other_series;
  params.report_map = report_map;
  runReportAsGauge(params, chart_container_id, msg_container_id, "false", "false", null, true);
}

function runReportAsGauge(params, chartContainerId, msgContainerId, isGauge, isGaugePreview, maxCancelationRetries, noRetry) {
  var startTime = new Date().getTime();
  setupSeries(params);
  if (isGaugePreview == "true")
    params.gauge_preview = true;
  var pageNum = document.getElementById('sysparm_page_num_' + params.report_id);
  if (pageNum && pageNum.value)
    params.page_num = pageNum.value;
  else
    params.page_num = 0;
  if (isGauge === "true" || isGauge === true)
    isGauge = true;
  else
    isGauge = false;
  var additionalArgs = constructAdditionalArgs(params, chartContainerId, msgContainerId, isGauge, startTime);
  generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, 0, noRetry);
}

function constructAdditionalArgs(params, chartContainerId, msgContainerId, isGauge, startTime) {
  var additionalArgs = {};
  additionalArgs.chart_container_id = chartContainerId;
  additionalArgs.msg_container_id = msgContainerId;
  additionalArgs.chart_type = params.series[0].plot_type;
  additionalArgs.agg_type = params.series[0].aggregate_type;
  additionalArgs.chart_size = params.chart_size;
  additionalArgs.chart_height = params.chart_height;
  additionalArgs.chart_width = params.chart_width;
  additionalArgs.start_time = startTime;
  additionalArgs.compute_percent = params.compute_percent;
  additionalArgs.group_by = params.series[0].groupby;
  additionalArgs.stacked_field = '';
  if (isBarType(additionalArgs.chart_type))
    additionalArgs.stacked_field = params.series[0].stacked_field;
  additionalArgs.display_grid = false;
  if (params.display_grid === "true" || params.display_grid === true)
    additionalArgs.display_grid = true;
  additionalArgs.isGauge = isGauge;
  if (additionalArgs.isGauge) {
    additionalArgs.gauge_id = params.gauge_id;
    additionalArgs.gauge_preview = params.gauge_preview;
  }
  additionalArgs.chart_params = JSON.stringify(params);
  additionalArgs.report_id = params.report_id;
  additionalArgs.source_type = params.source_type;
  if (params.report_uuid)
    additionalArgs.report_uuid = params.report_uuid;
  additionalArgs.publisher_filter = params.publisher_filter;
  return additionalArgs;
}

function isHighChartsSupportedType(chart_type) {
  return chart_type == 'bar' || chart_type == 'horizontal_bar' || isPieType(chart_type) || chart_type == 'pareto' || chart_type == 'hist' || chart_type == 'trend' ||
    chart_type == 'box' || chart_type == 'line' || chart_type == 'step_line' || chart_type == 'area' || chart_type == 'spline' || chart_type == 'line_bar' || chart_type == 'control' || chart_type == 'availability' ||
    chart_type == 'tbox' || isGaugeType(chart_type) || chart_type == 'heatmap' || chart_type == 'bubble' || chart_type == 'map';
}

function runReportFromBuilder(reportUUID, fixedSize, params, maxCancelationRetries, noRetry) {
  if (!params)
    params = window.g_report_params[reportUUID];
  if (!params.report_uuid)
    params.report_uuid = reportUUID;
  createReportTemplate(reportUUID, params, fixedSize);
  runReportAsGauge(params, "chart-container-" + reportUUID, "msg-container-" + reportUUID, "false", "false", maxCancelationRetries, noRetry);
}

function createReportTemplate(reportUUID, params, fixedSize) {
  var $reportContainer = jQuery('#report-container-' + reportUUID);
  $reportContainer.empty();
  $reportContainer.append(jQuery("<div class='gauge-size-handle report_breadcrumbs' />"));
  var $msgContainer = jQuery('<div class="report-message gauge-size-handle" id="msg-container-' + reportUUID + '"/>');
  var containerClass = "chart-container"
  if (isScrollableType(params.chart_type))
    containerClass += " scrollable";
  var $chartContainer = jQuery('<div class="' + containerClass + '" id="chart-container-' + reportUUID + '">Loading report...</div>');
  if (fixedSize) {
    var chartHeight = 550;
    var chartWidth = 750;
    var customChartSize = params.custom_chart_size;
    var customChartHeight = params.chart_height;
    var customChartWidth = params.chart_width;
    var chartSize = params.chart_size;
    if (customChartSize === 'true' && customChartHeight !== 'null' && customChartHeight !== '')
      chartHeight = customChartHeight;
    else if (chartSize === 'medium')
      chartHeight = 450;
    else if (chartSize === 'small')
      chartHeight = 375;
    if (customChartSize === 'true' && customChartWidth !== 'null' && customChartWidth !== '')
      chartWidth = customChartWidth;
    else if (chartSize === 'medium')
      chartWidth = 600;
    else if (chartSize === 'small')
      chartWidth = 450;
    $chartContainer.height(chartHeight).width(chartWidth);
  }
  $reportContainer.append($msgContainer);
  $reportContainer.append($chartContainer);
  if ((!params.page_num || params.page_num == "0") && params.additional_groupby && hasAdditionalGroupBy(params.chart_type)) {
    $reportContainer.append(jQuery('<div id="interactive-container-' + reportUUID + '" class="interactive_container gauge-size-handle" style="text-align: center; padding-top: 5px;"/>'));
  }
  if ((params.display_grid === "true" || params.display_grid === true || window.g_accessibility === "true" || window.g_accessibility === true) && isDisplayGridApplicable(params.chart_type)) {
    $reportContainer.append(jQuery('<div class="display-grid-container">' +
      '<table id="display-grid-table-' + reportUUID + '" align="center" border="0" cellpadding="0" cellspacing="0" class="chart_legend" style="margin-top: 5px; display:none; border-collapse: collapse !important;" />' +
      '</div>'));
  }
}

function isScrollableType(type) {
  return "pivot_v2" == type || "calendar" == type;
}

function generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, cancelledCount, noRetry) {
  maxCancelationRetries = parseInt(maxCancelationRetries) || 15;
  cancelledCount = parseInt(cancelledCount) || 0;
  if (cancelledCount == 0) {
    params.sysparm_request_params = JSON.stringify(params);
    params.sysparm_timer = new Date().getTime();
    if ('chartOnForm' in params)
      params.sysparm_chartonform = true;
    params.sysparm_processor = 'ChartDataProcessor';
    params.sysparm_scope = 'global';
    params.sysparm_want_session_messages = true;
  }
  var config = {
    method: 'POST',
    url: 'xmlhttp.do',
    data: $j.param(params),
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    dataType: 'xml'
  };
  $j.ajax(config).then(function successCallback(response) {
    if (!response || (response.getElementById('transaction_canceled_island') && response.getElementById('transaction_canceled_island').getAttribute('transaction_canceled') === 'true')) {
      var cancelledMsg = response ? response.getElementById('transaction_canceled_island').getAttribute('cancel_message') : '';
      cancelledMsg = cancelledMsg.toLowerCase();
      if (cancelledCount > maxCancelationRetries) {
        if (window.console)
          console.log('Transaction has been cancelled ' + maxCancelationRetries + ' times and stop retrying');
        if (chartContainerId)
          document.getElementById(chartContainerId).innerHTML = cancelledMsg;
      } else {
        if (cancelledMsg && cancelledMsg.indexOf('maximum execution time exceeded') !== -1 && chartContainerId)
          document.getElementById(chartContainerId).innerHTML = cancelledMsg;
        else
        if (!noRetry)
          setTimeout(function() {
            generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, ++cancelledCount, noRetry)
          }, 500);
      }
    } else
      getChartDataDone(response, additionalArgs);
  }, function errorCallback(response) {
    if (!noRetry)
      setTimeout(function() {
        generateChart(params, additionalArgs, chartContainerId, maxCancelationRetries, ++cancelledCount, noRetry)
      }, 500);
  });
}

function getReportParams(chartonform, type) {
  var config = getReportConfig(chartonform, type);
  config.show_empty = getReportParamValue('sysparm_show_empty', chartonform);
  var pageNum = document.getElementById('sysparm_page_num_' + config.report_id);
  if (pageNum && pageNum.value)
    config.page_num = pageNum.value;
  return config;
}

function getReportConfig(chartonform, type) {
  var params = {};
  params.sysparm_report_designer_builder = 'true';
  params.sysparm_is_published = getReportParamValue('sysparm_is_published', chartonform);
  if (type === 'list') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_field = getReportParamValue('sysparm_field', chartonform);
    params.sysparm_field_list = getReportParamValue('sysparm_field_list', chartonform);
    params.sysparm_full_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_additional_groupby = getReportParamValue('sysparm_additional_groupby', chartonform);
    params.sysparm_interactive_report = getReportParamValue('sysparm_interactive_report', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    params.sysparm_view = getReportParamValue('sysparm_view', chartonform);
    return params
  } else if (type === 'pivot') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_ct_row = getReportParamValue('sysparm_ct_row', chartonform);
    params.sysparm_ct_column = getReportParamValue('sysparm_ct_column', chartonform);
    params.sysparm_sumfield = getReportParamValue('sysparm_sumfield', chartonform);
    params.sysparm_aggregate = getReportParamValue('sysparm_aggregate', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_title = getReportParamValue('sysparm_title', chartonform);
    params.sysparm_others = getReportParamValue('sysparm_others', chartonform);
    params.sysparm_show_other = getReportParamValue('sysparm_show_other', chartonform);
    params.sysparm_list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.sysparm_report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    return params
  } else if (type === 'calendar') {
    params.sysparm_type = type;
    params.sysparm_table = getReportParamValue('sysparm_table', chartonform);
    params.sysparm_field = getReportParamValue('sysparm_field', chartonform);
    params.sysparm_cal_field = getReportParamValue('sysparm_cal_field', chartonform);
    params.sysparm_query = getReportParamValue('sysparm_query', chartonform);
    params.sysparm_list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.sysparm_report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.sysparm_report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    return params
  } else {
    params.table = getReportParamValue('sysparm_table', chartonform);
    params.report_id = (typeof additionalArgs === 'undefined' ? '' : additionalArgs.report_id);
    if (params.report_id === '')
      params.report_id = getReportParamValue('sysparm_report_id', chartonform);
    params.title = getReportParamValue('sysparm_title', chartonform);
    params.display_grid = getReportParamValue('sysparm_display_grid', chartonform);
    params.other_threshold = getReportParamValue('sysparm_others', chartonform);
    params.compute_percent = getReportParamValue('sysparm_compute_percent', chartonform);
    params.chart_size = getReportParamValue('sysparm_chart_size', chartonform);
    params.custom_chart_size = getReportParamValue('sysparm_custom_chart_size', chartonform);
    params.chart_height = getReportParamValue('sysparm_custom_chart_height', chartonform);
    params.chart_width = getReportParamValue('sysparm_custom_chart_width', chartonform);
    params.show_other = getReportParamValue('sysparm_show_other', chartonform);
    params.chart_type = getReportParamValue('sysparm_type', chartonform);
    params.group_by = getReportParamValue('sysparm_field', chartonform);
    params.filter = getReportParamValue('sysparm_query', chartonform);
    params.aggregate = getReportParamValue('sysparm_aggregate', chartonform);
    params.agg_field = getReportParamValue('sysparm_sumfield', chartonform);
    params.stack_field = getReportParamValue('sysparm_stack_field', chartonform);
    params.box_field = getReportParamValue('sysparm_box_field', chartonform);
    params.trend_field = getReportParamValue('sysparm_trend_field', chartonform);
    params.trend_interval = getReportParamValue('sysparm_trend_interval', chartonform);
    params.funnel_neck_percent = getReportParamValue('sysparm_funnel_neck_percent', chartonform);
    params.donut_width_percent = getReportParamValue('sysparm_donut_width_percent', chartonform);
    params.gauge_autoscale = getReportParamValue('sysparm_gauge_autoscale', chartonform);
    params.from = getReportParamValue('sysparm_from', chartonform);
    params.to = getReportParamValue('sysparm_to', chartonform);
    params.upper_limit = getReportParamValue('sysparm_upper_limit', chartonform);
    params.lower_limit = getReportParamValue('sysparm_lower_limit', chartonform);
    params.direction = getReportParamValue('sysparm_direction', chartonform);
    params.chart_title = getReportParamValue('sysparm_chart_title', chartonform);
    params.show_chart_title = getReportParamValue('sysparm_show_chart_title', chartonform);
    params.chart_title_size = getReportParamValue('sysparm_chart_title_size', chartonform);
    params.chart_title_color = getReportParamValue('sysparm_chart_title_color', chartonform);
    params.custom_chart_title_position = getReportParamValue('sysparm_custom_chart_title_position', chartonform);
    params.chart_title_x_position = getReportParamValue('sysparm_chart_title_x_position', chartonform);
    params.chart_title_y_position = getReportParamValue('sysparm_chart_title_y_position', chartonform);
    params.show_chart_border = getReportParamValue('sysparm_show_chart_border', chartonform);
    params.title_horizontal_alignment = getReportParamValue('sysparm_title_horizontal_alignment', chartonform);
    params.title_vertical_alignment = getReportParamValue('sysparm_title_vertical_alignment', chartonform);
    params.legend_horizontal_alignment = getReportParamValue('sysparm_legend_horizontal_alignment', chartonform);
    params.legend_vertical_alignment = getReportParamValue('sysparm_legend_vertical_alignment', chartonform);
    params.chart_border_width = getReportParamValue('sysparm_chart_border_width', chartonform);
    params.chart_border_radius = getReportParamValue('sysparm_chart_border_radius', chartonform);
    params.chart_border_color = getReportParamValue('sysparm_chart_border_color', chartonform);
    params.score_color = getReportParamValue('sysparm_score_color', chartonform);
    params.chart_background_color = getReportParamValue('sysparm_chart_background_color', chartonform);
    params.legend_border_width = getReportParamValue('sysparm_legend_border_width', chartonform);
    params.legend_border_radius = getReportParamValue('sysparm_legend_border_radius', chartonform);
    params.legend_border_color = getReportParamValue('sysparm_legend_border_color', chartonform);
    params.legend_background_color = getReportParamValue('sysparm_legend_background_color', chartonform);
    params.legend_items_left_align = getReportParamValue('sysparm_legend_items_left_align', chartonform);
    params.show_legend = getReportParamValue('sysparm_show_legend', chartonform);
    params.show_legend_border = getReportParamValue('sysparm_show_legend_border', chartonform);
    params.show_chart_data_label = getReportParamValue('sysparm_show_chart_data_label', chartonform);
    params.show_data_label_position_middle = getReportParamValue('sysparm_show_data_label_position_middle', chartonform);
    params.allow_data_label_overlap = getReportParamValue('sysparm_allow_data_label_overlap', chartonform);
    params.show_geographical_label = getReportParamValue('sysparm_show_geographical_label', chartonform);
    params.show_zero = getReportParamValue('sysparm_show_zero', chartonform);
    params.show_marker = getReportParamValue('sysparm_show_marker', chartonform);
    params.bar_unstack = getReportParamValue('sysparm_bar_unstack', chartonform);
    params.x_axis_title = getReportParamValue('sysparm_x_axis_title', chartonform);
    params.x_axis_title_size = getReportParamValue('sysparm_x_axis_title_size', chartonform);
    params.x_axis_title_color = getReportParamValue('sysparm_x_axis_title_color', chartonform);
    params.x_axis_title_bold = getReportParamValue('sysparm_x_axis_title_bold', chartonform);
    params.x_axis_opposite = getReportParamValue('sysparm_x_axis_opposite', chartonform);
    params.x_axis_grid_width = getReportParamValue('sysparm_x_axis_grid_width', chartonform);
    params.x_axis_grid_color = getReportParamValue('sysparm_x_axis_grid_color', chartonform);
    params.x_axis_display_grid = getReportParamValue('sysparm_x_axis_display_grid', chartonform);
    params.x_axis_grid_dotted = getReportParamValue('sysparm_x_axis_grid_dotted', chartonform);
    params.x_axis_label_size = getReportParamValue('sysparm_x_axis_label_size', chartonform);
    params.x_axis_label_color = getReportParamValue('sysparm_x_axis_label_color', chartonform);
    params.x_axis_label_bold = getReportParamValue('sysparm_x_axis_label_bold', chartonform);
    params.y_axis_title = getReportParamValue('sysparm_y_axis_title', chartonform);
    params.y_axis_title_size = getReportParamValue('sysparm_y_axis_title_size', chartonform);
    params.y_axis_title_color = getReportParamValue('sysparm_y_axis_title_color', chartonform);
    params.y_axis_title_bold = getReportParamValue('sysparm_y_axis_title_bold', chartonform);
    params.y_axis_opposite = getReportParamValue('sysparm_y_axis_opposite', chartonform);
    params.y_axis_grid_width = getReportParamValue('sysparm_y_axis_grid_width', chartonform);
    params.y_axis_grid_color = getReportParamValue('sysparm_y_axis_grid_color', chartonform);
    params.y_axis_display_grid = getReportParamValue('sysparm_y_axis_display_grid', chartonform);
    params.y_axis_grid_dotted = getReportParamValue('sysparm_y_axis_grid_dotted', chartonform);
    params.y_axis_from = getReportParamValue('sysparm_y_axis_from', chartonform);
    params.y_axis_to = getReportParamValue('sysparm_y_axis_to', chartonform);
    params.y_axis_label_size = getReportParamValue('sysparm_y_axis_label_size', chartonform);
    params.y_axis_label_color = getReportParamValue('sysparm_y_axis_label_color', chartonform);
    params.y_axis_label_bold = getReportParamValue('sysparm_y_axis_label_bold', chartonform);
    params.report_source_id = getReportParamValue('sysparm_report_source_id', chartonform);
    params.sc_groupby_item_id = getReportParamValue('sysparm_sc_groupby_item_id', chartonform);
    params.sc_groupby_variable_id = getReportParamValue('sysparm_sc_groupby_variable_id', chartonform);
    params.sc_stackby_item_id = getReportParamValue('sysparm_sc_stackby_item_id', chartonform);
    params.sc_stackby_variable_id = getReportParamValue('sysparm_sc_stackby_variable_id', chartonform);
    params.list_ui_view = getReportParamValue('sysparm_list_ui_view', chartonform);
    params.report_drilldown = getReportParamValue('sysparm_report_drilldown', chartonform);
    params.show_chart_total = getReportParamValue('sysparm_show_chart_total', chartonform);
    params.use_color_heatmap = getReportParamValue('sysparm_use_color_heatmap_map', chartonform);
    params.axis_max_color = getReportParamValue('sysparm_axis_max_color', chartonform);
    params.axis_min_color = getReportParamValue('sysparm_axis_min_color', chartonform);
    params.ct_column = getReportParamValue('sysparm_ct_column', chartonform);
    params.ct_row = getReportParamValue('sysparm_ct_row', chartonform);
    params.interactive_report = getReportParamValue('sysparm_interactive_report', chartonform);
    params.set_color = getReportParamValue('sysparm_set_color', chartonform);
    params.color = getReportParamValue('sysparm_chart_color', chartonform);
    params.colors = getReportParamValue('sysparm_chart_colors', chartonform);
    params.color_palette = getReportParamValue('sysparm_color_palette', chartonform);
    params.decimal_precision = getReportParamValue('sysparm_decimal_precision', chartonform);
    params.show_empty = true;
    params.other_series = '';
    params.report_map = getReportParamValue('sysparm_report_map', chartonform);
    params.report_map_source = getReportParamValue('sysparm_report_map_source', chartonform);
    params.additional_groupby = getReportParamValue('sysparm_additional_groupby', chartonform);
    params.original_groupby = getReportParamValue('sysparm_field', chartonform);
    params.original_stackby = getReportParamValue('sysparm_stack_field', chartonform);
    params.is_published = params.sysparm_is_published;
    params.use_null_in_trend = getReportParamValue('sysparm_use_null_in_trend', chartonform);
    params.series_name_text = getReportParamValue('sysparm_series_name_text', chartonform);
    params.x_axis_category_fields = getReportParamValue('sysparm_x_axis_category_fields', chartonform);
    params.y_axis_category_fields = getReportParamValue('sysparm_y_axis_category_fields', chartonform);
    params.pivot_expanded = getReportParamValue('sysparm_pivot_expanded', chartonform);
    params.display_row_lines = getReportParamValue('sysparm_display_row_lines', chartonform);
    params.display_column_lines = getReportParamValue('sysparm_display_column_lines', chartonform);
    params.cal_field = getReportParamValue('sysparm_cal_field', chartonform);
    params.source_type = getReportParamValue('sysparm_source_type', chartonform);
    params.custom_config = getReportParamValue('sysparm_custom_config', chartonform);
    params.start_time = getReportParamValue('sysparm_start_time', chartonform);
    params.end_time = getReportParamValue('sysparm_end_time', chartonform);
    params.pa_indicator = getReportParamValue('sysparm_pa_indicator', chartonform);
    params.pa_breakdown = getReportParamValue('sysparm_pa_breakdown', chartonform);
    params.pa_element = getReportParamValue('sysparm_pa_element', chartonform);
    params.pa_breakdown_level2 = getReportParamValue('sysparm_pa_breakdown_level2', chartonform);
    params.pa_element_level2 = getReportParamValue('sysparm_pa_element_level2', chartonform);
    params.pa_aggregate = getReportParamValue('sysparm_pa_aggregate', chartonform);
    return setupSeries(params);
  }
}

function getReportParamValue(name, chartonform) {
  var fullName = name;
  if (chartonform)
    fullName += chartonform;
  var element = document.getElementById(fullName);
  if (element)
    return element.value;
  return '';
}

function setupSeries(params) {
  if (params.chart_type == 'line' || params.chart_type == 'area' || params.chart_type == 'spline' ||
    params.chart_type == 'line_bar' || params.chart_type == 'step_line')
    params.other_threshold = -1;
  params.series = new Array();
  var curSeries = {};
  var interactiveReport = {};
  if (params.interactive_report) {
    try {
      interactiveReport = JSON.parse(params.interactive_report);
    } catch (err) {
      console.log("unable to parse interactive reports JSON definition")
    }
  }
  curSeries.table = params.table;
  curSeries.report_source_id = params.report_source_id;
  if (interactiveReport.groupby || interactiveReport.groupby === '')
    curSeries.groupby = interactiveReport.groupby;
  else
    curSeries.groupby = params.group_by;
  curSeries.location = params.location;
  curSeries.report_map_source = params.report_map_source;
  curSeries.report_map = params.report_map;
  curSeries.sc_groupby_item_id = params.sc_groupby_item_id;
  curSeries.sc_groupby_variable_id = params.sc_groupby_variable_id;
  curSeries.sc_stackby_item_id = params.sc_stackby_item_id;
  curSeries.sc_stackby_variable_id = params.sc_stackby_variable_id;
  curSeries.filter = params.filter;
  curSeries.interactive_report = params.interactive_report;
  curSeries.plot_type = params.chart_type;
  if (curSeries.plot_type == 'pareto')
    curSeries.aggregate_type = 'COUNT';
  else {
    curSeries.aggregate_type = params.aggregate;
    if (params.aggregate != 'COUNT')
      curSeries.aggregate_field = params.agg_field;
  }
  if (isBarType(curSeries.plot_type)) {
    if (interactiveReport.stackby === '' || interactiveReport.stackby)
      curSeries.stacked_field = interactiveReport.stackby;
    else
      curSeries.stacked_field = params.stack_field;
  } else if (curSeries.plot_type == 'hist') {
    curSeries.hist_field = params.box_field;
  } else if (curSeries.plot_type == 'box') {
    curSeries.box_field = params.box_field;
  } else if (curSeries.plot_type == 'trend' || curSeries.plot_type == 'line' || curSeries.plot_type == 'area' || curSeries.plot_type == 'spline' || curSeries.plot_type == 'line_bar' ||
    curSeries.plot_type == 'control' || curSeries.plot_type == 'availability' ||
    curSeries.plot_type == 'tbox' || curSeries.plot_type == 'step_line') {
    curSeries.trend_field = params.trend_field;
    curSeries.trend_interval = params.trend_interval;
  } else if (curSeries.plot_type == 'heatmap' || curSeries.plot_type == 'bubble') {
    curSeries.ct_row = params.ct_row;
    curSeries.ct_column = params.ct_column;
  } else if (curSeries.plot_type == 'map')
    curSeries.show_geographical_label = params.show_geographical_label;
  curSeries.show_chart_data_label = params.show_chart_data_label;
  curSeries.show_data_label_position_middle = params.show_data_label_position_middle;
  curSeries.allow_data_label_overlap = params.allow_data_label_overlap;
  curSeries.show_marker = params.show_marker;
  curSeries.bar_unstack = params.bar_unstack;
  curSeries.list_ui_view = params.list_ui_view;
  curSeries.set_color = params.set_color;
  curSeries.color = params.color;
  curSeries.colors = params.colors;
  curSeries.color_palette = params.color_palette;
  curSeries.show_y_axis = params.show_y_axis;
  curSeries.y_axis_from = params.y_axis_from;
  curSeries.y_axis_to = params.y_axis_to;
  curSeries.y_axis_title = params.y_axis_title;
  curSeries.series_name_text = params.series_name_text;
  curSeries.source_type = params.source_type;
  curSeries.custom_config = params.custom_config;
  curSeries.use_null_in_trend = params.use_null_in_trend;
  params.series.push(curSeries);
  return params;
}

function getChartDataDone(response, args) {
  var chartDataResponse = response.getElementsByTagName('CHART_DATA_RESPONSE');
  if (!response || !chartDataResponse) {
    showError(args['msg_container_id'], "No response from the server");
  } else {
    var resp = JSON.parse(getTextValue((chartDataResponse)[0]));
    processChartDataResponse(resp, args);
  }
  var now = new Date().getTime();
  var elapsedTime = (now - args['start_time']) / 1000;
  console.log('Time taken to render chart: ' + elapsedTime);
}

function processChartDataResponse(resp, args) {
  if (resp.STATUS == 'SUCCESS') {
    var mychart;
    if ('chartOnForm' in args)
      mychart = new GlideReportChart(args['chart_container_id'], args['msg_container_id'], args['isGauge'], args['chart_size'],
        args['chart_type'], args['report_id'], args['chart_params'], args['chart_height'], args['chart_width'], args['source_type']);
    else
      mychart = new GlideReportChart(args['chart_container_id'], args['msg_container_id'], args['isGauge'], args['chart_size'],
        args['chart_type'], args['report_id'], args['chart_params'], args['chart_height'], args['chart_width'], args['source_type']);
    if ('isPub' in args && args.isPub) {
      mychart.setPub(args.isPub);
    } else
      mychart.setPub(false);
    var chart_data = JSON.parse(resp.CHART_DATA);
    if (!renderChart(mychart, chart_data, args, interval)) {
      var interval = setInterval(function() {
        if (renderChart(mychart, chart_data, args, interval)) {
          clearInterval(interval);
        }
      }, 1000);
    }
  } else if (resp.STATUS == 'INFO') {
    showInfo(args['chart_container_id'], resp.INFO_MESSAGE);
    document.getElementById(args['msg_container_id']).innerHTML = '';
  } else {
    showError(args['chart_container_id'], resp.ERROR_MESSAGE);
    document.getElementById(args['msg_container_id']).innerHTML = '';
  }
}

function renderChart(mychart, chart_data, args, interval) {
  if (jQuery("#" + args['chart_container_id']).is(":visible")) {
    if (args['source_type'] === 'metricbase') {
      var chartParams;
      if (mychart.chartParams)
        chartParams = JSON.parse(mychart.chartParams);
      mychart.buildMetricBase(chart_data, chartParams);
    } else {
      chart_data.report_properties.publisher_id = args['publisher_id'];
      chart_data.report_properties.report_id = args['report_id'];
      chart_data.report_properties.publisher_filter = args['publisher_filter'];
      checkAndEnableInteractiveFilters(chart_data, args);
      mychart.buildGroupChartForSingleSeries(chart_data, args['stacked_field'], args['agg_type'], args['source_type']);
      checkAndEnableDisplayGrid(chart_data, args);
    }
    return true;
  } else
    return false;
}

function isBarType(chart_type) {
  return chart_type === 'bar' || chart_type === 'horizontal_bar';
}

function isPieType(chart_type) {
  return (chart_type === 'pie' || chart_type === 'funnel' || chart_type === 'semi_donut' || chart_type === 'pyramid' || chart_type === 'donut');
}

function isGaugeType(chartType) {
  return (chartType === 'angular_gauge' || chartType === 'solid_gauge');
}

function formatDuration(secs) {
  var days = Math.floor(secs / 86400);
  var hours = Math.floor((secs % 86400) / 3600);
  var mins = Math.floor(((secs % 86400) % 3600) / 60);
  var secs = ((secs % 86400) % 3600) % 60;
  if (days > 0)
    return days + ' days ' + hours + ' hours ' + mins + ' minutes ' + secs + ' seconds';
  if (hours > 0)
    return hours + ' hours ' + mins + ' minutes ' + secs + ' seconds';
  if (mins > 0)
    return mins + ' minutes ' + secs + ' seconds';
  return secs + ' seconds';
}

function showError(container, errorMsg) {
  document.getElementById(container).innerHTML = '<div style="text-align:center;color:red">' + 'ERROR: ' + errorMsg + '</div>';
}

function showInfo(container, infoMsg) {
  document.getElementById(container).innerHTML = '<div style="text-align:center;color:black">' + infoMsg + '</div>';
};
/*! RESOURCE: /scripts/reportcommon/GlideReportChart.js */
var GlideReportChart = function GlideReportChart() {
  this.initialize.apply(this, arguments);
};
GlideReportChart.prototype = {
  initialize: function initialize(elemId1, elemId2, isGauge, chartSize, chartType, reportId, chartParams, chartHeight, chartWidth, sourceType) {
    this.chartContainerId = elemId1;
    this.msgContainerId = elemId2;
    this.isGauge = isGauge;
    this.chartSize = chartSize;
    this.chartHeight = chartHeight;
    this.chartWidth = chartWidth;
    this.chartOptions = {};
    this.chartingEngine = 'Highcharts';
    this.chartType = chartType;
    this.reportId = reportId;
    this.chartParams = chartParams;
    this.isPub = false;
    this.sourceType = sourceType;
    this.titleMargin = 50;
  },
  setPub: function setPub(isPub) {
    this.isPub = isPub;
  },
  showError: function showError(errorMsg) {
    document.getElementById(this.chartContainerId).innerHTML = '<div style="text-align:center;color:red">ERROR: ' + errorMsg + '</div>';
  },
  showWarning: function showWarning(warnMsg) {
    document.getElementById(this.msgContainerId).innerHTML = '<div style="text-align:center;color:black">WARNING: ' + warnMsg + '</div>';
  },
  showMessage: function showMessage(msg) {
    document.getElementById(this.msgContainerId).innerHTML = '<div style="text-align:center;color:black">' + msg + '</div>';
  },
  setRenderTo: function setRenderTo(elem) {
    this.chartOptions.renderTo = elem;
  },
  initDefaultChartOptions: function initDefaultChartOptions(chartData, aggType, stackedField) {
    var isRtl = (jQuery('html').hasClass('rtl') || jQuery('html').attr('dir') === 'rtl');
    var chartOptionsProps = hc_initDefaultChartOptions(this.chartOptions, chartData, this.chartType, this.chartSize, this.isGauge, this.isPub, this.chartContainerId, aggType, stackedField, true, this.chartHeight, this.chartWidth, isRtl) || {};
    var chartParamsObj = JSON.parse(this.chartParams);
    chartOptionsProps.other_threshold = chartParamsObj.other_threshold;
    chartOptionsProps.display_grid = chartParamsObj.display_grid;
    chartOptionsProps.show_other = chartParamsObj.show_other;
    chartOptionsProps.interactive_report = chartParamsObj.interactive_report;
    chartOptionsProps.page_num = chartParamsObj.page_num ? chartParamsObj.page_num : 0;
    chartOptionsProps.box_field = chartParamsObj.box_field;
    chartOptionsProps.filter_with_orderby = chartParamsObj.filter;
    chartOptionsProps.agg_field = chartParamsObj.agg_field;
    chartOptionsProps.other_series = chartParamsObj.other_series;
    chartOptionsProps.stack_field = chartParamsObj.stack_field;
    chartOptionsProps.box_field = chartParamsObj.box_field;
    chartOptionsProps.trend_field = chartParamsObj.trend_field;
    chartOptionsProps.trend_interval = chartParamsObj.trend_interval;
    chartOptionsProps.colors = chartParamsObj.colors;
    chartOptionsProps.sourceType = this.sourceType;
    return chartOptionsProps;
  },
  createBreadcrumbsMapChart: function createBreadcrumbsMapChart(reportId, containerId, breadcrumbs) {
    if (reportId) {
      var breadcrumbsContainer = jQuery('#' + containerId).siblings('.report_breadcrumbs')[0];
      if (breadcrumbsContainer) {
        var ol = document.createElement('ol');
        ol.className = 'breadcrumb';
        ol.style.marginBottom = '0';
        for (i = 0; i < breadcrumbs.length; i++) {
          var breadcrumb = breadcrumbs[i];
          var li = document.createElement('li');
          var text = document.createTextNode(breadcrumb.name);
          if (i === breadcrumbs.length - 1) {
            li.className = 'active';
            li.appendChild(text);
          } else {
            var a = document.createElement('a');
            a.setAttribute('href', 'javascript:void(0)');
            a.setAttribute('onclick', 'clickOnABreadcrumb(\'' + reportId + '\',\'' + containerId + '\',\'' + encodeURIComponent(JSON.stringify(breadcrumb.params)) + '\')');
            a.appendChild(text);
            li.appendChild(a);
          }
          ol.appendChild(li);
        }
        breadcrumbsContainer.appendChild(ol);
      }
    }
  },
  buildMetricBase: function buildMetricBase(chartData, chartParams) {
    this.showMessage('');
    this.chartOptions = chartData;
    if (this.chartContainerId)
      this.chartOptions.chart.renderTo = this.chartContainerId;
    hc_setHeightWidthChart(this.chartOptions, chartData, this.chartSize, this.isGauge, this.chartContainerId, chartParams.custom_chart_size, this.chartHeight, this.chartWidth);
    var props = {};
    props.sourceType = this.sourceType;
    props.display_grid = JSON.parse(this.chartParams).display_grid;
    props.isGauge = this.isGauge;
    props.isPub = this.isPub;
    var hcWrapper = new GlideHCWrapper(this.chartOptions, chartData, props, this.reportId, this.chartParams, this.chartSize, this.sourceType);
    hcWrapper.createMetricBase(chartParams, this.chartType);
  },
  buildGroupChartForSingleSeries: function buildGroupChartForSingleSeries(chartData, stackedField, aggType, sourceType) {
    this.showMessage('');
    if ('additional_msg' in chartData)
      this.showMessage(chartData.additional_msg);
    if ('additional_msg' in chartData.report_properties_series[0])
      this.showMessage(chartData.report_properties_series[0].additional_msg);
    if ('additional_msg' in chartData.report_properties_series[0])
      this.showMessage(chartData.report_properties_series[0].additional_msg);
    if (this.chartType !== 'heatmap' && 'warning' in chartData.series[0])
      this.showWarning(chartData.series[0].warning);
    if (this.chartingEngine === 'Highcharts') {
      if (this.chartType === 'map') {
        var reportId = this.reportId;
        var containerId = this.chartContainerId;
        var breadcrumbs = chartData.report_properties_series[0].breadcrumbs;
        this.createBreadcrumbsMapChart(reportId, containerId, breadcrumbs);
      }
      var props = this.initDefaultChartOptions(chartData, aggType, stackedField);
      var hcWrapper = new GlideHCWrapper(this.chartOptions, chartData, props, this.reportId, this.chartParams, this.chartSize, sourceType);
      hc_setLegendLabelFormatter(this.chartOptions, true, false);
      if (this.isBarType(this.chartType)) {
        if (stackedField === '')
          hcWrapper.createBarChart(this.chartType);
        else
          hcWrapper.createStackedBarChart(this.chartType);
      } else if (this.chartType === 'pie' || this.chartType === 'semi_donut' || this.chartType === 'donut')
        hcWrapper.createPieChart(this.chartType);
      else if (this.chartType === 'funnel')
        hcWrapper.createFunnelChart(this.chartType);
      else if (this.chartType === 'heatmap')
        hcWrapper.createHeatmapChart(this.chartType);
      else if (this.chartType === 'map')
        hcWrapper.createMapChart(this.chartType);
      else if (this.chartType === 'bubble')
        hcWrapper.createBubbleChart(this.chartType);
      else if (this.chartType === 'pyramid')
        hcWrapper.createPyramidChart(this.chartType);
      else if (this.chartType === 'hist')
        hcWrapper.createHistogramChart(this.chartType);
      else if (this.chartType === 'pareto')
        hcWrapper.createParetoChart(this.chartType);
      else if (this.chartType === 'box' || this.chartType === 'tbox')
        hcWrapper.createBoxChart(this.chartType);
      else if (this.chartType === 'trend')
        hcWrapper.createTrendChart(this.chartType);
      else if (isLineType(this.chartType))
        hcWrapper.createLineChart(this.chartType);
      else if (this.chartType === 'control')
        hcWrapper.createControlChart(this.chartType);
      else if (this.chartType === 'availability')
        hcWrapper.createAvailChart(this.chartType);
      else if (this.chartType === 'angular_gauge' || this.chartType === 'solid_gauge')
        hcWrapper.createGaugeChart(this.chartType);
    }
  },
  isBarType: function isBarType(type) {
    if (type === 'bar' || type === 'horizontal_bar')
      return true;
    return false;
  },
  isLineType: function isLineType(type) {
    return (type === 'line' || type === 'area' || type === 'spline' || type === 'line_bar' || type === 'step_line');
  },
  type: 'GlideReportChart'
};;
/*! RESOURCE: /scripts/reportcommon/GlideHCWrapper.js */
var GlideHCWrapper = function GlideHCWrapper() {
  this.initialize.apply(this, arguments);
};
GlideHCWrapper.prototype = {
  initialize: function initialize(defaultChartOptions, data, chartProps, reportId, chartParams, chartSize, sourceType) {
    this.chartOptions = defaultChartOptions;
    this.chartData = data;
    this.chartProps = chartProps;
    this.chartSize = chartSize;
    this.chartPropsSeries = data.report_properties_series;
    this.isReportViewer = window.location.pathname.indexOf('report_viewer.do') !== -1;
    this.defaultFontFamily = 'Helvetica';
    this.otherDisplay = 'Other';
    this.otherDisplayMore = '(more...)';
    this.isGauge = chartProps.isGauge;
    this.origXValues = [];
    this.xValues = [];
    this.maxAllowedLabelLen = 20;
    this.grayColor = '#666';
    this.blackColor = '#000';
    this.aggType = chartProps.aggType;
    this.otherKey = 'zzyynomatchaabb';
    this.chartType = chartProps.chartType;
    this.report_properties = {};
    if (chartProps.isPub) {
      this.chartOptions.exporting = {};
      this.chartOptions.exporting.enabled = false;
    } else
      this.setupExportOptions(reportId, chartParams, chartProps.isGauge);
    if (sourceType !== 'metricbase') {
      this.report_properties = {};
      if ('report_properties' in data) {
        this.report_properties = data.report_properties;
        if ('font_family' in this.report_properties && this.report_properties.font_family !== '')
          this.defaultFontFamily = this.report_properties.font_family;
        this.otherDisplay = this.report_properties.other_display;
        this.otherDisplayMore = this.report_properties.other_display_more;
      }
      this.chartOptions.publisher_id = this.chartData.report_properties.publisher_id;
      this.chartOptions.report_id = this.chartData.report_properties.report_id;
      this.isPublisher = false;
      var gridWindow = '';
      if (typeof glideGrid !== 'undefined') {
        gridWindow = glideGrid.getWindowByGaugeId(this.chartOptions.publisher_id);
        if (typeof gridWindow === 'undefined' || !gridWindow)
          gridWindow = glideGrid.getWindowByGaugeId(this.chartOptions.report_id);
      } else if (window.SNC && SNC.canvas && SNC.canvas.canvasUtils && SNC.canvas.isGridCanvasActive) {
        gridWindow = SNC.canvas.canvasUtils.getGlideWindow(this.chartOptions.report_id);
        if (!gridWindow)
          gridWindow = SNC.canvas.canvasUtils.getGlideWindow(this.chartOptions.publisher_id);
      }
      if (typeof gridWindow !== 'undefined' && gridWindow) {
        var publisherWidget = gridWindow.getPreference('publisher_widget');
        this.isPublisher = publisherWidget === 'true';
      }
    }
    this.chartOptions.credits = {
      enabled: false
    };
  },
  setupExportOptions: function setupExportOptions(reportId, chartParams, isGauge) {
    if (!this.chartData.series.length || (this.chartData.series[0].xvalues && !this.chartData.series[0].xvalues.length)) {
      this.chartOptions.exporting = false;
      return;
    }
    this.chartOptions.exporting = {};
    this.chartOptions.exporting.enabled = !(typeof chartHelpers !== 'undefined' && chartHelpers && chartHelpers.device) ||
      (chartHelpers.device.type !== 'mobile' && chartHelpers.device.type !== 'm' && chartHelpers.device.type !== 'tablet');
    this.chartOptions.exporting.reportId = reportId;
    this.chartOptions.exporting.isGauge = isGauge;
    var jsonParameters = JSON.parse(chartParams);
    jsonParameters.is_gauge = isGauge;
    this.chartOptions.exporting.params = JSON.stringify(jsonParameters);
    this.chartOptions.exporting.buttons = {
      contextButton: {
        align: 'right',
        x: 0,
        y: -2,
        theme: {
          stroke: 'silver'
        },
        menuItems: []
      }
    };
    var oldFirefox = false;
    if (window.isFirefox && this.getVersion('firefox') < '40')
      oldFirefox = true;
    var oldChrome = false;
    if (window.isChrome && this.getVersion('chrome') < '64')
      oldChrome = true;
    var isEdge = this.isBrowser('edge');
    var oldBrowser = window.isMSIE9 || window.isMSIE10 || oldFirefox || oldChrome || isEdge;
    this.chartOptions.exporting.downloadMsg = chartHelpers.i18n.downloadComplete;
    var self = this;
    var item1 = {};
    var item2 = {};
    item1.text = chartHelpers.i18n.saveAsPng;
    item2.text = chartHelpers.i18n.saveAsJpg;
    if (oldBrowser)
      this.chartOptions.exporting.enabled = false;
    item1.onclick = function() {
      self.saveChartClientSide('png', this)
    };
    item2.onclick = function() {
      self.saveChartClientSide('jpg', this)
    };
    this.chartOptions.exporting.buttons.contextButton.menuItems.push(item1);
    this.chartOptions.exporting.buttons.contextButton.menuItems.push(item2);
  },
  getVersion: function(browser) {
    var userAgent = navigator.userAgent.toLowerCase()
    userAgent = userAgent.substring(userAgent.indexOf(browser + '/') + (browser === 'firefox' ? 8 : 7));
    userAgent = userAgent.substring(0, userAgent.indexOf('.'));
    var version = userAgent;
    return version;
  },
  isBrowser: function(browser) {
    var userAgent = navigator.userAgent.toLowerCase()
    return userAgent.indexOf(browser.toLowerCase()) > 0;
  },
  saveChartClientSide: function(type, obj) {
    if (typeof obj.options.exporting == '')
      obj.options.exporting = {};
    obj.options.exporting.fallbackToExportServer = false;
    obj.options.exporting.type = 'image/' + type;
    var titleReport = obj.options.title.text;
    if (titleReport) {
      titleReport = titleReport.length > 100 ? titleReport.substring(0, 100) : titleReport;
      titleReport = titleReport.replace(/\s+/g, "_");
      obj.options.exporting.filename = titleReport;
    }
    var expParams = JSON.parse(obj.options.exporting.params);
    var widthTmp = obj.options.chart.width;
    var heightTmp = obj.options.chart.height;
    obj.options.chart.width = expParams.chart_width;
    obj.options.chart.height = expParams.chart_height;
    obj.exportChartLocal();
    obj.options.chart.width = widthTmp;
    obj.options.chart.height = heightTmp;
    this.showMessage(obj.options.exporting.downloadMsg, 'info', 8000);
  },
  showMessage: function showMessage(message, type, timeInMiliSeconds) {
    if (message) {
      var span = document.createElement('span');
      span.setAttribute('data-type', (type ? type : this.msgType.type_default));
      span.setAttribute('data-text', message);
      span.setAttribute('data-duration', (timeInMiliSeconds ? timeInMiliSeconds : '5000'));
      if (typeof GlideUI !== 'undefined')
        GlideUI.get().fire(new GlideUINotification({
          xml: span
        }));
    }
  },
  saveChartServerSide: function(type, obj) {
    var reportDetails = {};
    reportDetails['report_id'] = obj.options.exporting.reportId;
    reportDetails['is_gauge'] = obj.options.exporting.isGauge;
    var chartExportParams = obj.options.exporting.params;
    obj.options.exporting.fallbackToExportServer = true;
    if (chartExportParams === '')
      hc_saveChart('report_id', 'hcexport_' + type, JSON.stringify(reportDetails));
    else
      hc_saveChart('report_params', 'hcexport_' + type, chartExportParams);
  },
  createHeatmapChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var curSeries = hc_createHeatmapSeriesData(this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_addHeatmapChartOptions(this.chartOptions, this.chartProps, true, this.chartData, curSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_addHeatmapAxisCategories(this.chartOptions, this.chartData);
    hc_sanitizeCategoryValues(this.chartOptions, this.chartProps);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createMapChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addMapChartOptions(this.chartOptions, this.chartProps, true, this.chartData);
    var curSeries = hc_createMapSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series = curSeries;
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_updateDataLabelOptionsGeographical(this.chartOptions, this.chartData, this.chartType);
    hc_updateMapVisualizationOptions(this.chartOptions, this.chartData, this.chartProps);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart(true);
  },
  createBubbleChart: function(chartType) {
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createBubbleSeriesData(this.chartData, this.chartProps, true);
    this.chartOptions.xAxis = this.chartData.series[0].xAxis;
    this.chartOptions.yAxis = this.chartData.series[0].yAxis;
    hc_addBubbleChartOptions(this.chartOptions, true, this.chartData.series[0].legend.enabled);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createBarChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBarChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createMultipleSeriesData(this.chartOptions, this.chartData, this.chartProps, true, this.chartPropsSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createMetricBase: function(chartParams, chartType) {
    if (chartParams.show_chart_title === 'never' || (this.isGauge && chartParams.show_chart_title === 'report')) {
      this.chartOptions.title = {};
      this.chartOptions.title.text = '';
    }
    hc_configureLegendAlignment(chartType, chartParams, this.chartOptions, false, true);
    hc_setLegendLabelFormatter(this.chartOptions, true, false);
    this.chartOptions.series.forEach(function(series) {
      series.dataLabels = series.dataLabels || {};
      series.dataLabels.formatter = hc_formatValueLabel;
    });
    this.renderChart();
  },
  createStackedBarChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addStackedBarChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true, this.chartPropsSeries);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createMultipleSeriesData(this.chartOptions, this.chartData, this.chartProps, true, this.chartPropsSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, 'trend', true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createPieChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addPieChartOptions(this.chartOptions, this.chartProps, true, chartType == "semi_donut", this.isPublisher);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    if (chartType == "semi_donut" || chartType == "donut") {
      curSeries.innerSize = (100 - this.chartProps.report_properties.donut_width_percent) + "%";
      if (this.chartProps.report_properties.show_chart_total)
        hc_addTotal(this.chartOptions, this.chartProps, curSeries, this.chartData);
    }
    this.chartOptions.series.push(curSeries);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createFunnelChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addFunnelChartOptions(this.chartOptions, this.chartProps, true, this.chartData, this.isPublisher);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createPyramidChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addXYChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_addPyramidChartOptions(this.chartOptions, this.chartProps, true, this.chartData, this.isPublisher);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createGaugeChart: function(chartType) {
    hc_addGaugeChartOptions(this.chartOptions, this.chartProps, this.chartData, this.getHighChartsType(this.chartData.series[0].series_plot_type), true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var curSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(curSeries);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, 'gauge', true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createHistogramChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addHistogramOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var histogramSeries = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(histogramSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createBoxChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBoxChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    var boxSeries = hc_createBoxPlotData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(boxSeries);
    var meanSeries = hc_createBoxMeanData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(meanSeries);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createParetoChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addBarChartOptions(this.chartOptions, this.chartProps, this.chartData, 'column', true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.plotOptions.column.point = {};
    this.chartOptions.plotOptions.column.point.events = {};
    this.chartOptions.plotOptions.column.point.events.click = hc_dataPointClicked;
    var series0 = hc_createSingleSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    this.chartOptions.series.push(series0);
    var cumulative_series = hc_createParetoCumulSeries(this.chartOptions, this.chartProps, series0, true);
    this.chartOptions.series.push(cumulative_series);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createTrendChart: function(chartType) {
    if ('sub_series' in this.chartData.series[0])
      this.createStackedBarChart();
    else
      this.createBarChart('trend');
  },
  createLineChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addLineChartOptions(this.chartOptions, this.chartProps, this.chartData, true, chartType);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createLineSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createAvailChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_addAvailChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    this.chartOptions.series = hc_createLineSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  createControlChart: function(chartType) {
    hc_sanitizeXValues(this.chartData, this.chartProps);
    hc_configureChartProportions(chartType, this.chartData, this.chartOptions, false, true);
    hc_addControlChartOptions(this.chartOptions, this.chartProps, this.chartData, true);
    this.chartOptions.series = hc_createControlSeriesData(this.chartOptions, this.chartData, this.chartProps, true);
    hc_addDataLabelOptions(this.chartOptions, this.chartProps, this.chartData, chartType, true);
    hc_disableTurboThreshold(this.chartOptions);
    this.renderChart();
  },
  renderChart: function renderChart(isMap) {
    var chart;
    var chartData = this.chartData;
    var chartType = this.chartProps.chartType;
    var self = this;
    if (typeof isMap === 'undefined' || isMap !== true) {
      this.setAnimation(chartData);
      this.setBoost(chartData);
      chart = new Highcharts.Chart(this.chartOptions);
    } else
      chart = new Highcharts.Map(this.chartOptions, function(chart) {
        var reportId = self.chartOptions.mapVisualization.report_id;
        if (reportId) {
          var iconHeatmap = '/images/icons/button-heatmap.png';
          var iconHeatmapActive = '/images/icons/button-heatmap-selected.png';
          var iconMarker = '/images/icons/button-pin.png';
          var iconMarkerActive = '/images/icons/button-pin-selected.png';
          var heatmapImg;
          var markerImg;
          var isLastLevel = chartData.report_properties_series[0].map_source.is_map_source_last_level;
          var containsLatLonLevel = chartData.report_properties_series[0].map_source.map_source_contains_lat_lon_level;
          var showPinLocations = containsLatLonLevel && !isLastLevel;
          var useLatLon = chartData.report_properties_series[0].map_source.use_lat_lon;
          if (showPinLocations && !chart.options.chart.forExport) {
            if (!useLatLon) {
              heatmapImg = chart.renderer.image(iconHeatmapActive, chart.chartWidth - 85, 10, 20, 20);
              markerImg = chart.renderer.image(iconMarker, chart.chartWidth - 60, 10, 20, 20);
            } else {
              heatmapImg = chart.renderer.image(iconHeatmap, chart.chartWidth - 85, 10, 20, 20);
              markerImg = chart.renderer.image(iconMarkerActive, chart.chartWidth - 60, 10, 20, 20);
            }
            heatmapImg.add();
            heatmapImg.css({
              cursor: 'pointer'
            });
            heatmapImg.attr({
              title: chartHelpers.i18n.showAsHeatmap,
              class: 'hc-image'
            });
            heatmapImg.on('click', function clickHeatmapImg(ev) {
              heatmapImg.attr({
                href: iconHeatmapActive
              });
              markerImg.attr({
                href: iconMarker
              });
              self.onClickCustomButton(ev, 'heatmap', reportId);
            });
            markerImg.add();
            markerImg.css({
              cursor: 'pointer'
            });
            markerImg.attr({
              title: chartHelpers.i18n.showAsMarkers,
              class: 'hc-image'
            });
            markerImg.on('click', function clickMarkerImg(ev) {
              markerImg.attr({
                href: iconMarkerActive
              });
              heatmapImg.attr({
                href: iconHeatmap
              });
              self.onClickCustomButton(ev, 'marker', reportId);
            });
          }
        }
      });
    var chartsWithDataTable = ['control', 'heatmap', 'bubble', 'tbox', 'box', 'hist'];
    var containerId = this.chartOptions.chart.renderTo;
    var shouldDisplayGridMetricbase = self.chartProps.sourceType === 'metricbase' && self.chartProps.display_grid;
    if (((window.g_accessibility === 'true' || window.g_accessibility === true) && chartsWithDataTable.indexOf(chartType) > -1) || shouldDisplayGridMetricbase === true || shouldDisplayGridMetricbase === 'true') {
      chart.viewData();
      jQuery('#' + containerId).siblings('.highcharts-data-table').find('table').attr('tabindex', 0);
    }
    jQuery('#' + containerId + '>div[role=region] h3,#' + containerId + '> h3, #' + containerId + '>div[role=region]>div[tabindex=0]').remove();
    if (chart.exportSVGElements && chart.exportSVGElements[0])
      chart.exportSVGElements[0].toFront();
    var isCanvas = window.SNC && window.SNC.canvas && SNC.canvas.canvasUtils;
    var rootReportId;
    if (this.isReportViewer || (isCanvas && containerId.indexOf('preview') === -1)) {
      if (isCanvas) {
        rootReportId = jQuery('#' + containerId).closest('.grid-stack-item').find('.sysparm_root_report_id').first().val();
        var uuid = SNC.canvas.canvasUtils.getUuidFromSysId(rootReportId);
        if (uuid) {
          window.SNC.reportResizingFunctions = window.SNC.reportResizingFunctions || {};
          SNC.canvas.eventbus.subscribe(uuid, this.resizeChartFromCanvas.bind(this));
          SNC.reportResizingFunctions[uuid] = this.resizeChartFromCanvas;
        }
      } else
        rootReportId = jQuery('#' + containerId).parent().parent().find('.sysparm_root_report_id').first().val();
      window.SNC = window.SNC || {};
      window.SNC.reportResizingTimeouts = window.SNC.reportResizingTimeouts || {};
      window.addEventListener('resize', function() {
        if (SNC.reportResizingTimeouts[rootReportId])
          clearTimeout(SNC.reportResizingTimeouts[rootReportId]);
        SNC.reportResizingTimeouts[rootReportId] = setTimeout(function() {
          var containerDimensions = hc_getDimensions(containerId, true);
          chart.setSize(containerDimensions.width, containerDimensions.height);
        }, 250);
      }, false);
    }
    this.applyPreviousStateForInteractiveFilter(chart);
  },
  setAnimation: function(chartData) {
    this.chartOptions.plotOptions = this.chartOptions.plotOptions || {};
    this.chartOptions.plotOptions.series = this.chartOptions.plotOptions.series || {};
    if (chartData.report_properties) {
      this.chartOptions.plotOptions.series.animation = chartData.report_properties.chart_animation;
      this.chartOptions.chart.animation = chartData.report_properties.chart_animation;
    }
    var isEdge = this.isBrowser('edge');
    var isMSIE11 = this.isBrowser('trident');
    if (window.isMSIE || isMSIE11 || isEdge) {
      this.chartOptions.plotOptions.series.animation = false;
      this.chartOptions.chart.animation = false;
    }
  },
  setBoost: function(chartData) {
    this.chartOptions.plotOptions = this.chartOptions.plotOptions || {};
    this.chartOptions.plotOptions.series = this.chartOptions.plotOptions.series || {};
    this.chartOptions.boost = {};
    this.chartOptions.boost.enabled = chartData.report_properties && chartData.report_properties.chart_boost_enabled ? chartData.report_properties.chart_boost_enabled : false;
    if (chartData.report_properties && chartData.report_properties.chart_boost)
      this.chartOptions.plotOptions.series.boostThreshold = chartData.report_properties.chart_boost;
  },
  applyPreviousStateForInteractiveFilter: function(chart) {
    var isChartFilterable = this.chartProps.chartType == 'pie' || this.chartProps.chartType == 'semi_donut' || this.chartProps.chartType == 'donut' ||
      this.chartProps.chartType == 'funnel' || this.chartProps.chartType == 'pyramid';
    if (isChartFilterable) {
      if (this.chartProps.interactive_report) {
        var interActiveReport = JSON.parse(this.chartProps.interactive_report);
        var selectedPointUrl = interActiveReport.selectedPoint || "";
        var filtersFromLegend = interActiveReport.filtersFromLegend || {};
        chart.series[0].data.forEach(function(dataPoint) {
          if (dataPoint['publisher_filter']) {
            var url = dataPoint['publisher_filter'].replace("^", "^EQ^");
            if (url === selectedPointUrl)
              dataPoint.select('select', 'preventDataPointSelect');
            url = dataPoint['publisher_filter'];
            if (filtersFromLegend[url])
              dataPoint.setVisible(false);
          }
        });
      }
    }
  },
  resizeChartFromCanvas: function resizeChartFromCanvas(data) {
    if (data.action === 'resize') {
      var containerId = this.chartOptions.chart.renderTo;
      var chart = jQuery('#' + containerId).highcharts();
      if (chart) {
        var containerDimensions = hc_getDimensions(containerId, true);
        chart.setSize(containerDimensions.width, containerDimensions.height);
      }
    }
  },
  onClickCustomButton: function onClickCustomButton(event, button, reportId) {
    if (typeof this.chartOptions.mapVisualization !== 'undefined') {
      var mapVis = this.chartOptions.mapVisualization;
      var fullQuery = mapVis.full_query;
      var showDataLabel = mapVis.show_data_label;
      var showGeographicalLabel = mapVis.show_geographical_label;
      var mapParams = '';
      var element = event.srcElement;
      if (!element)
        element = event.target;
      var content = jQuery(element).closest(".report_content");
      if (reportId) {
        var actualMap = mapVis.report_drilldown_map;
        if (actualMap)
          mapParams += "sysparm_report_map_parent=" + actualMap;
        if (showDataLabel)
          mapParams += "&sysparm_show_chart_data_label=" + showDataLabel;
        if (showGeographicalLabel)
          mapParams += "&sysparm_show_geographical_label=" + showGeographicalLabel;
        if (fullQuery)
          mapParams += "&sysparm_full_query_map=" + fullQuery;
        if (button === 'heatmap')
          mapParams += '&sysparm_report_map_exact_points=false';
        else
          mapParams += '&sysparm_report_map_exact_points=true';
        drillReport(content.parent(), reportId, '', mapParams);
      }
    }
  },
  getHighChartsType: function getHighChartsType(snType) {
    if (snType == 'bar' || snType == 'trend')
      return 'column';
    else if (snType == 'horizontal_bar')
      return 'bar';
    else if (snType == 'pie')
      return 'pie';
    else if (snType == 'semi_donut')
      return 'pie';
    else if (snType == 'donut')
      return 'pie';
    else if (snType == 'funnel')
      return 'funnel';
    else if (snType == 'pyramid')
      return 'funnel';
    else if (snType == 'box')
      return 'boxplot';
    else if (snType == 'angular_gauge')
      return 'gauge';
    else if (snType == 'solid_gauge')
      return 'solidgauge';
    else if (snType == 'heatmap')
      return 'heatmap';
    else if (snType == 'bubble')
      return 'bubble';
    else
      return "";
  },
  type: "GlideHCWrapper"
};;
/*! RESOURCE: /scripts/glide-highcharts.js */
/*! RESOURCE: /scripts/highcharts/highstock.js */
(function(V, L) {
  "object" === typeof module && module.exports ? module.exports = V.document ? L(V) : L : V.Highcharts = L(V)
})("undefined" !== typeof window ? window : this, function(V) {
  var L = function() {
    var a = "undefined" === typeof V ? window : V,
      B = a.document,
      C = a.navigator && a.navigator.userAgent || "",
      G = B && B.createElementNS && !!B.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
      p = /(edge|msie|trident)/i.test(C) && !a.opera,
      m = -1 !== C.indexOf("Firefox"),
      g = -1 !== C.indexOf("Chrome"),
      v = m && 4 > parseInt(C.split("Firefox/")[1],
        10);
    return a.Highcharts ? a.Highcharts.error(16, !0) : {
      product: "Highstock",
      version: "6.1.0",
      deg2rad: 2 * Math.PI / 360,
      doc: B,
      hasBidiBug: v,
      hasTouch: B && void 0 !== B.documentElement.ontouchstart,
      isMS: p,
      isWebKit: -1 !== C.indexOf("AppleWebKit"),
      isFirefox: m,
      isChrome: g,
      isSafari: !g && -1 !== C.indexOf("Safari"),
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(C),
      SVG_NS: "http://www.w3.org/2000/svg",
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: G,
      win: a,
      marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      noop: function() {},
      charts: []
    }
  }();
  (function(a) {
    a.timers = [];
    var B = a.charts,
      C = a.doc,
      G = a.win;
    a.error = function(p, m) {
      p = a.isNumber(p) ? "Highcharts error #" + p + ": www.highcharts.com/errors/" + p : p;
      if (m) throw Error(p);
      G.console && console.log(p)
    };
    a.Fx = function(a, m, g) {
      this.options = m;
      this.elem = a;
      this.prop = g
    };
    a.Fx.prototype = {
      dSetter: function() {
        var a = this.paths[0],
          m = this.paths[1],
          g = [],
          v = this.now,
          z = a.length,
          u;
        if (1 === v) g = this.toD;
        else if (z === m.length && 1 > v)
          for (; z--;) u = parseFloat(a[z]), g[z] = isNaN(u) ? m[z] : v * parseFloat(m[z] - u) + u;
        else g = m;
        this.elem.attr("d",
          g, null, !0)
      },
      update: function() {
        var a = this.elem,
          m = this.prop,
          g = this.now,
          v = this.options.step;
        if (this[m + "Setter"]) this[m + "Setter"]();
        else a.attr ? a.element && a.attr(m, g, null, !0) : a.style[m] = g + this.unit;
        v && v.call(a, g, this)
      },
      run: function(p, m, g) {
        var v = this,
          z = v.options,
          u = function(a) {
            return u.stopped ? !1 : v.step(a)
          },
          y = G.requestAnimationFrame || function(a) {
            setTimeout(a, 13)
          },
          l = function() {
            for (var b = 0; b < a.timers.length; b++) a.timers[b]() || a.timers.splice(b--, 1);
            a.timers.length && y(l)
          };
        p !== m || this.elem["forceAnimate:" +
          this.prop] ? (this.startTime = +new Date, this.start = p, this.end = m, this.unit = g, this.now = this.start, this.pos = 0, u.elem = this.elem, u.prop = this.prop, u() && 1 === a.timers.push(u) && y(l)) : (delete z.curAnim[this.prop], z.complete && 0 === a.keys(z.curAnim).length && z.complete.call(this.elem))
      },
      step: function(p) {
        var m = +new Date,
          g, v = this.options,
          z = this.elem,
          u = v.complete,
          y = v.duration,
          l = v.curAnim;
        z.attr && !z.element ? p = !1 : p || m >= y + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), g = l[this.prop] = !0, a.objectEach(l, function(a) {
          !0 !==
            a && (g = !1)
        }), g && u && u.call(z), p = !1) : (this.pos = v.easing((m - this.startTime) / y), this.now = this.start + (this.end - this.start) * this.pos, this.update(), p = !0);
        return p
      },
      initPath: function(p, m, g) {
        function v(a) {
          var b, f;
          for (c = a.length; c--;) b = "M" === a[c] || "L" === a[c], f = /[a-zA-Z]/.test(a[c + 3]), b && f && a.splice(c + 1, 0, a[c + 1], a[c + 2], a[c + 1], a[c + 2])
        }

        function z(a, b) {
          for (; a.length < n;) {
            a[0] = b[n - a.length];
            var f = a.slice(0, t);
            [].splice.apply(a, [0, 0].concat(f));
            h && (f = a.slice(a.length - t), [].splice.apply(a, [a.length, 0].concat(f)), c--)
          }
          a[0] =
            "M"
        }

        function u(a, b) {
          for (var c = (n - a.length) / t; 0 < c && c--;) f = a.slice().splice(a.length / w - t, t * w), f[0] = b[n - t - c * t], e && (f[t - 6] = f[t - 2], f[t - 5] = f[t - 1]), [].splice.apply(a, [a.length / w, 0].concat(f)), h && c--
        }
        m = m || "";
        var y, l = p.startX,
          b = p.endX,
          e = -1 < m.indexOf("C"),
          t = e ? 7 : 3,
          n, f, c;
        m = m.split(" ");
        g = g.slice();
        var h = p.isArea,
          w = h ? 2 : 1,
          D;
        e && (v(m), v(g));
        if (l && b) {
          for (c = 0; c < l.length; c++)
            if (l[c] === b[0]) {
              y = c;
              break
            } else if (l[0] === b[b.length - l.length + c]) {
            y = c;
            D = !0;
            break
          }
          void 0 === y && (m = [])
        }
        m.length && a.isNumber(y) && (n = g.length + y * w * t,
          D ? (z(m, g), u(g, m)) : (z(g, m), u(m, g)));
        return [m, g]
      }
    };
    a.Fx.prototype.fillSetter = a.Fx.prototype.strokeSetter = function() {
      this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0)
    };
    a.merge = function() {
      var p, m = arguments,
        g, v = {},
        z = function(g, y) {
          "object" !== typeof g && (g = {});
          a.objectEach(y, function(l, b) {
            !a.isObject(l, !0) || a.isClass(l) || a.isDOMElement(l) ? g[b] = y[b] : g[b] = z(g[b] || {}, l)
          });
          return g
        };
      !0 === m[0] && (v = m[1], m = Array.prototype.slice.call(m, 2));
      g = m.length;
      for (p = 0; p < g; p++) v = z(v,
        m[p]);
      return v
    };
    a.pInt = function(a, m) {
      return parseInt(a, m || 10)
    };
    a.isString = function(a) {
      return "string" === typeof a
    };
    a.isArray = function(a) {
      a = Object.prototype.toString.call(a);
      return "[object Array]" === a || "[object Array Iterator]" === a
    };
    a.isObject = function(p, m) {
      return !!p && "object" === typeof p && (!m || !a.isArray(p))
    };
    a.isDOMElement = function(p) {
      return a.isObject(p) && "number" === typeof p.nodeType
    };
    a.isClass = function(p) {
      var m = p && p.constructor;
      return !(!a.isObject(p, !0) || a.isDOMElement(p) || !m || !m.name || "Object" ===
        m.name)
    };
    a.isNumber = function(a) {
      return "number" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a
    };
    a.erase = function(a, m) {
      for (var g = a.length; g--;)
        if (a[g] === m) {
          a.splice(g, 1);
          break
        }
    };
    a.defined = function(a) {
      return void 0 !== a && null !== a
    };
    a.attr = function(p, m, g) {
      var v;
      a.isString(m) ? a.defined(g) ? p.setAttribute(m, g) : p && p.getAttribute && ((v = p.getAttribute(m)) || "class" !== m || (v = p.getAttribute(m + "Name"))) : a.defined(m) && a.isObject(m) && a.objectEach(m, function(a, g) {
        p.setAttribute(g, a)
      });
      return v
    };
    a.splat = function(p) {
      return a.isArray(p) ?
        p : [p]
    };
    a.syncTimeout = function(a, m, g) {
      if (m) return setTimeout(a, m, g);
      a.call(0, g)
    };
    a.clearTimeout = function(p) {
      a.defined(p) && clearTimeout(p)
    };
    a.extend = function(a, m) {
      var g;
      a || (a = {});
      for (g in m) a[g] = m[g];
      return a
    };
    a.pick = function() {
      var a = arguments,
        m, g, v = a.length;
      for (m = 0; m < v; m++)
        if (g = a[m], void 0 !== g && null !== g) return g
    };
    a.css = function(p, m) {
      a.isMS && !a.svg && m && void 0 !== m.opacity && (m.filter = "alpha(opacity\x3d" + 100 * m.opacity + ")");
      a.extend(p.style, m)
    };
    a.createElement = function(p, m, g, v, z) {
      p = C.createElement(p);
      var u =
        a.css;
      m && a.extend(p, m);
      z && u(p, {
        padding: 0,
        border: "none",
        margin: 0
      });
      g && u(p, g);
      v && v.appendChild(p);
      return p
    };
    a.extendClass = function(p, m) {
      var g = function() {};
      g.prototype = new p;
      a.extend(g.prototype, m);
      return g
    };
    a.pad = function(a, m, g) {
      return Array((m || 2) + 1 - String(a).replace("-", "").length).join(g || 0) + a
    };
    a.relativeLength = function(a, m, g) {
      return /%$/.test(a) ? m * parseFloat(a) / 100 + (g || 0) : parseFloat(a)
    };
    a.wrap = function(a, m, g) {
      var v = a[m];
      a[m] = function() {
        var a = Array.prototype.slice.call(arguments),
          u = arguments,
          y = this;
        y.proceed = function() {
          v.apply(y, arguments.length ? arguments : u)
        };
        a.unshift(v);
        a = g.apply(this, a);
        y.proceed = null;
        return a
      }
    };
    a.formatSingle = function(p, m, g) {
      var v = /\.([0-9])/,
        z = a.defaultOptions.lang;
      /f$/.test(p) ? (g = (g = p.match(v)) ? g[1] : -1, null !== m && (m = a.numberFormat(m, g, z.decimalPoint, -1 < p.indexOf(",") ? z.thousandsSep : ""))) : m = (g || a.time).dateFormat(p, m);
      return m
    };
    a.format = function(p, m, g) {
      for (var v = "{", z = !1, u, y, l, b, e = [], t; p;) {
        v = p.indexOf(v);
        if (-1 === v) break;
        u = p.slice(0, v);
        if (z) {
          u = u.split(":");
          y = u.shift().split(".");
          b = y.length;
          t = m;
          for (l = 0; l < b; l++) t && (t = t[y[l]]);
          u.length && (t = a.formatSingle(u.join(":"), t, g));
          e.push(t)
        } else e.push(u);
        p = p.slice(v + 1);
        v = (z = !z) ? "}" : "{"
      }
      e.push(p);
      return e.join("")
    };
    a.getMagnitude = function(a) {
      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10))
    };
    a.normalizeTickInterval = function(p, m, g, v, z) {
      var u, y = p;
      g = a.pick(g, 1);
      u = p / g;
      m || (m = z ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === v && (1 === g ? m = a.grep(m, function(a) {
        return 0 === a % 1
      }) : .1 >= g && (m = [1 / g])));
      for (v = 0; v < m.length && !(y = m[v], z && y * g >= p ||
          !z && u <= (m[v] + (m[v + 1] || m[v])) / 2); v++);
      return y = a.correctFloat(y * g, -Math.round(Math.log(.001) / Math.LN10))
    };
    a.stableSort = function(a, m) {
      var g = a.length,
        v, z;
      for (z = 0; z < g; z++) a[z].safeI = z;
      a.sort(function(a, g) {
        v = m(a, g);
        return 0 === v ? a.safeI - g.safeI : v
      });
      for (z = 0; z < g; z++) delete a[z].safeI
    };
    a.arrayMin = function(a) {
      for (var m = a.length, g = a[0]; m--;) a[m] < g && (g = a[m]);
      return g
    };
    a.arrayMax = function(a) {
      for (var m = a.length, g = a[0]; m--;) a[m] > g && (g = a[m]);
      return g
    };
    a.destroyObjectProperties = function(p, m) {
      a.objectEach(p, function(a,
        v) {
        a && a !== m && a.destroy && a.destroy();
        delete p[v]
      })
    };
    a.discardElement = function(p) {
      var m = a.garbageBin;
      m || (m = a.createElement("div"));
      p && m.appendChild(p);
      m.innerHTML = ""
    };
    a.correctFloat = function(a, m) {
      return parseFloat(a.toPrecision(m || 14))
    };
    a.setAnimation = function(p, m) {
      m.renderer.globalAnimation = a.pick(p, m.options.chart.animation, !0)
    };
    a.animObject = function(p) {
      return a.isObject(p) ? a.merge(p) : {
        duration: p ? 500 : 0
      }
    };
    a.timeUnits = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    };
    a.numberFormat = function(p, m, g, v) {
      p = +p || 0;
      m = +m;
      var z = a.defaultOptions.lang,
        u = (p.toString().split(".")[1] || "").split("e")[0].length,
        y, l, b = p.toString().split("e"); - 1 === m ? m = Math.min(u, 20) : a.isNumber(m) ? m && b[1] && 0 > b[1] && (y = m + +b[1], 0 <= y ? (b[0] = (+b[0]).toExponential(y).split("e")[0], m = y) : (b[0] = b[0].split(".")[0] || 0, p = 20 > m ? (b[0] * Math.pow(10, b[1])).toFixed(m) : 0, b[1] = 0)) : m = 2;
      l = (Math.abs(b[1] ? b[0] : p) + Math.pow(10, -Math.max(m, u) - 1)).toFixed(m);
      u = String(a.pInt(l));
      y = 3 < u.length ? u.length % 3 : 0;
      g = a.pick(g,
        z.decimalPoint);
      v = a.pick(v, z.thousandsSep);
      p = (0 > p ? "-" : "") + (y ? u.substr(0, y) + v : "");
      p += u.substr(y).replace(/(\d{3})(?=\d)/g, "$1" + v);
      m && (p += g + l.slice(-m));
      b[1] && 0 !== +p && (p += "e" + b[1]);
      return p
    };
    Math.easeInOutSine = function(a) {
      return -.5 * (Math.cos(Math.PI * a) - 1)
    };
    a.getStyle = function(p, m, g) {
      if ("width" === m) return Math.min(p.offsetWidth, p.scrollWidth) - a.getStyle(p, "padding-left") - a.getStyle(p, "padding-right");
      if ("height" === m) return Math.min(p.offsetHeight, p.scrollHeight) - a.getStyle(p, "padding-top") - a.getStyle(p,
        "padding-bottom");
      G.getComputedStyle || a.error(27, !0);
      if (p = G.getComputedStyle(p, void 0)) p = p.getPropertyValue(m), a.pick(g, "opacity" !== m) && (p = a.pInt(p));
      return p
    };
    a.inArray = function(p, m, g) {
      return (a.indexOfPolyfill || Array.prototype.indexOf).call(m, p, g)
    };
    a.grep = function(p, m) {
      return (a.filterPolyfill || Array.prototype.filter).call(p, m)
    };
    a.find = Array.prototype.find ? function(a, m) {
      return a.find(m)
    } : function(a, m) {
      var g, v = a.length;
      for (g = 0; g < v; g++)
        if (m(a[g], g)) return a[g]
    };
    a.some = function(p, m, g) {
      return (a.somePolyfill ||
        Array.prototype.some).call(p, m, g)
    };
    a.map = function(a, m) {
      for (var g = [], v = 0, z = a.length; v < z; v++) g[v] = m.call(a[v], a[v], v, a);
      return g
    };
    a.keys = function(p) {
      return (a.keysPolyfill || Object.keys).call(void 0, p)
    };
    a.reduce = function(p, m, g) {
      return (a.reducePolyfill || Array.prototype.reduce).call(p, m, g)
    };
    a.offset = function(a) {
      var m = C.documentElement;
      a = a.parentElement ? a.getBoundingClientRect() : {
        top: 0,
        left: 0
      };
      return {
        top: a.top + (G.pageYOffset || m.scrollTop) - (m.clientTop || 0),
        left: a.left + (G.pageXOffset || m.scrollLeft) - (m.clientLeft ||
          0)
      }
    };
    a.stop = function(p, m) {
      for (var g = a.timers.length; g--;) a.timers[g].elem !== p || m && m !== a.timers[g].prop || (a.timers[g].stopped = !0)
    };
    a.each = function(p, m, g) {
      return (a.forEachPolyfill || Array.prototype.forEach).call(p, m, g)
    };
    a.objectEach = function(a, m, g) {
      for (var v in a) a.hasOwnProperty(v) && m.call(g || a[v], a[v], v, a)
    };
    a.addEvent = function(p, m, g) {
      var v, z = p.addEventListener || a.addEventListenerPolyfill;
      v = "function" === typeof p && p.prototype ? p.prototype.protoEvents = p.prototype.protoEvents || {} : p.hcEvents = p.hcEvents || {};
      z && z.call(p, m, g, !1);
      v[m] || (v[m] = []);
      v[m].push(g);
      return function() {
        a.removeEvent(p, m, g)
      }
    };
    a.removeEvent = function(p, m, g) {
      function v(l, b) {
        var e = p.removeEventListener || a.removeEventListenerPolyfill;
        e && e.call(p, l, b, !1)
      }

      function z(l) {
        var b, e;
        p.nodeName && (m ? (b = {}, b[m] = !0) : b = l, a.objectEach(b, function(a, b) {
          if (l[b])
            for (e = l[b].length; e--;) v(b, l[b][e])
        }))
      }
      var u, y;
      a.each(["protoEvents", "hcEvents"], function(l) {
        var b = p[l];
        b && (m ? (u = b[m] || [], g ? (y = a.inArray(g, u), -1 < y && (u.splice(y, 1), b[m] = u), v(m, g)) : (z(b), b[m] = [])) : (z(b), p[l] = {}))
      })
    };
    a.fireEvent = function(p, m, g, v) {
      var z, u, y, l, b;
      g = g || {};
      C.createEvent && (p.dispatchEvent || p.fireEvent) ? (z = C.createEvent("Events"), z.initEvent(m, !0, !0), a.extend(z, g), p.dispatchEvent ? p.dispatchEvent(z) : p.fireEvent(m, z)) : a.each(["protoEvents", "hcEvents"], function(e) {
        if (p[e])
          for (u = p[e][m] || [], y = u.length, g.target || a.extend(g, {
              preventDefault: function() {
                g.defaultPrevented = !0
              },
              target: p,
              type: m
            }), l = 0; l < y; l++)(b = u[l]) && !1 === b.call(p, g) && g.preventDefault()
      });
      v && !g.defaultPrevented && v.call(p,
        g)
    };
    a.animate = function(p, m, g) {
      var v, z = "",
        u, y, l;
      a.isObject(g) || (l = arguments, g = {
        duration: l[2],
        easing: l[3],
        complete: l[4]
      });
      a.isNumber(g.duration) || (g.duration = 400);
      g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
      g.curAnim = a.merge(m);
      a.objectEach(m, function(b, e) {
        a.stop(p, e);
        y = new a.Fx(p, g, e);
        u = null;
        "d" === e ? (y.paths = y.initPath(p, p.d, m.d), y.toD = m.d, v = 0, u = 1) : p.attr ? v = p.attr(e) : (v = parseFloat(a.getStyle(p, e)) || 0, "opacity" !== e && (z = "px"));
        u || (u = b);
        u && u.match && u.match("px") &&
          (u = u.replace(/px/g, ""));
        y.run(v, u, z)
      })
    };
    a.seriesType = function(p, m, g, v, z) {
      var u = a.getOptions(),
        y = a.seriesTypes;
      u.plotOptions[p] = a.merge(u.plotOptions[m], g);
      y[p] = a.extendClass(y[m] || function() {}, v);
      y[p].prototype.type = p;
      z && (y[p].prototype.pointClass = a.extendClass(a.Point, z));
      return y[p]
    };
    a.uniqueKey = function() {
      var a = Math.random().toString(36).substring(2, 9),
        m = 0;
      return function() {
        return "highcharts-" + a + "-" + m++
      }
    }();
    G.jQuery && (G.jQuery.fn.highcharts = function() {
      var p = [].slice.call(arguments);
      if (this[0]) return p[0] ?
        (new(a[a.isString(p[0]) ? p.shift() : "Chart"])(this[0], p[0], p[1]), this) : B[a.attr(this[0], "data-highcharts-chart")]
    })
  })(L);
  (function(a) {
    var B = a.each,
      C = a.isNumber,
      G = a.map,
      p = a.merge,
      m = a.pInt;
    a.Color = function(g) {
      if (!(this instanceof a.Color)) return new a.Color(g);
      this.init(g)
    };
    a.Color.prototype = {
      parsers: [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function(a) {
          return [m(a[1]), m(a[2]), m(a[3]), parseFloat(a[4], 10)]
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function(a) {
          return [m(a[1]), m(a[2]), m(a[3]), 1]
        }
      }],
      names: {
        none: "rgba(255,255,255,0)",
        white: "#ffffff",
        black: "#000000"
      },
      init: function(g) {
        var m, z, u, y;
        if ((this.input = g = this.names[g && g.toLowerCase ? g.toLowerCase() : ""] || g) && g.stops) this.stops = G(g.stops, function(l) {
          return new a.Color(l[1])
        });
        else if (g && g.charAt && "#" === g.charAt() && (m = g.length, g = parseInt(g.substr(1), 16), 7 === m ? z = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === m && (z = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1])), !z)
          for (u = this.parsers.length; u-- &&
            !z;) y = this.parsers[u], (m = y.regex.exec(g)) && (z = y.parse(m));
        this.rgba = z || []
      },
      get: function(a) {
        var g = this.input,
          m = this.rgba,
          u;
        this.stops ? (u = p(g), u.stops = [].concat(u.stops), B(this.stops, function(g, l) {
          u.stops[l] = [u.stops[l][0], g.get(a)]
        })) : u = m && C(m[0]) ? "rgb" === a || !a && 1 === m[3] ? "rgb(" + m[0] + "," + m[1] + "," + m[2] + ")" : "a" === a ? m[3] : "rgba(" + m.join(",") + ")" : g;
        return u
      },
      brighten: function(a) {
        var g, z = this.rgba;
        if (this.stops) B(this.stops, function(g) {
          g.brighten(a)
        });
        else if (C(a) && 0 !== a)
          for (g = 0; 3 > g; g++) z[g] += m(255 * a), 0 >
            z[g] && (z[g] = 0), 255 < z[g] && (z[g] = 255);
        return this
      },
      setOpacity: function(a) {
        this.rgba[3] = a;
        return this
      },
      tweenTo: function(a, m) {
        var g = this.rgba,
          u = a.rgba;
        u.length && g && g.length ? (a = 1 !== u[3] || 1 !== g[3], m = (a ? "rgba(" : "rgb(") + Math.round(u[0] + (g[0] - u[0]) * (1 - m)) + "," + Math.round(u[1] + (g[1] - u[1]) * (1 - m)) + "," + Math.round(u[2] + (g[2] - u[2]) * (1 - m)) + (a ? "," + (u[3] + (g[3] - u[3]) * (1 - m)) : "") + ")") : m = a.input || "none";
        return m
      }
    };
    a.color = function(g) {
      return new a.Color(g)
    }
  })(L);
  (function(a) {
    var B, C, G = a.addEvent,
      p = a.animate,
      m = a.attr,
      g = a.charts,
      v = a.color,
      z = a.css,
      u = a.createElement,
      y = a.defined,
      l = a.deg2rad,
      b = a.destroyObjectProperties,
      e = a.doc,
      t = a.each,
      n = a.extend,
      f = a.erase,
      c = a.grep,
      h = a.hasTouch,
      w = a.inArray,
      D = a.isArray,
      r = a.isFirefox,
      J = a.isMS,
      q = a.isObject,
      F = a.isString,
      x = a.isWebKit,
      K = a.merge,
      d = a.noop,
      H = a.objectEach,
      E = a.pick,
      k = a.pInt,
      A = a.removeEvent,
      P = a.stop,
      R = a.svg,
      I = a.SVG_NS,
      Q = a.symbolSizes,
      N = a.win;
    B = a.SVGElement = function() {
      return this
    };
    n(B.prototype, {
      opacity: 1,
      SVG_NS: I,
      textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "),
      init: function(a, k) {
        this.element = "span" === k ? u(k) : e.createElementNS(this.SVG_NS, k);
        this.renderer = a
      },
      animate: function(k, d, A) {
        d = a.animObject(E(d, this.renderer.globalAnimation, !0));
        0 !== d.duration ? (A && (d.complete = A), p(this, k, d)) : (this.attr(k, null, A), d.step && d.step.call(this));
        return this
      },
      complexColor: function(k, d, A) {
        var M = this.renderer,
          b, f, c, h, I, x, n, r, e, w, E, q = [],
          l;
        a.fireEvent(this.renderer, "complexColor", {
          args: arguments
        }, function() {
          k.radialGradient ? f = "radialGradient" : k.linearGradient && (f = "linearGradient");
          f && (c = k[f], I = M.gradients, n = k.stops, w = A.radialReference, D(c) && (k[f] = c = {
            x1: c[0],
            y1: c[1],
            x2: c[2],
            y2: c[3],
            gradientUnits: "userSpaceOnUse"
          }), "radialGradient" === f && w && !y(c.gradientUnits) && (h = c, c = K(c, M.getRadialAttr(w, h), {
            gradientUnits: "userSpaceOnUse"
          })), H(c, function(a, k) {
            "id" !== k && q.push(k, a)
          }), H(n, function(a) {
            q.push(a)
          }), q = q.join(","), I[q] ? E = I[q].attr("id") : (c.id = E = a.uniqueKey(), I[q] = x = M.createElement(f).attr(c).add(M.defs), x.radAttr = h, x.stops = [], t(n, function(k) {
            0 === k[1].indexOf("rgba") ? (b = a.color(k[1]),
              r = b.get("rgb"), e = b.get("a")) : (r = k[1], e = 1);
            k = M.createElement("stop").attr({
              offset: k[0],
              "stop-color": r,
              "stop-opacity": e
            }).add(x);
            x.stops.push(k)
          })), l = "url(" + M.url + "#" + E + ")", A.setAttribute(d, l), A.gradient = q, k.toString = function() {
            return l
          })
        })
      },
      applyTextOutline: function(k) {
        var d = this.element,
          M, A, b, c, h; - 1 !== k.indexOf("contrast") && (k = k.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));
        k = k.split(" ");
        A = k[k.length - 1];
        if ((b = k[0]) && "none" !== b && a.svg) {
          this.fakeTS = !0;
          k = [].slice.call(d.getElementsByTagName("tspan"));
          this.ySetter = this.xSetter;
          b = b.replace(/(^[\d\.]+)(.*?)$/g, function(a, k, d) {
            return 2 * k + d
          });
          for (h = k.length; h--;) M = k[h], "highcharts-text-outline" === M.getAttribute("class") && f(k, d.removeChild(M));
          c = d.firstChild;
          t(k, function(a, k) {
            0 === k && (a.setAttribute("x", d.getAttribute("x")), k = d.getAttribute("y"), a.setAttribute("y", k || 0), null === k && d.setAttribute("y", 0));
            a = a.cloneNode(1);
            m(a, {
              "class": "highcharts-text-outline",
              fill: A,
              stroke: A,
              "stroke-width": b,
              "stroke-linejoin": "round"
            });
            d.insertBefore(a, c)
          })
        }
      },
      attr: function(a,
        k, d, A) {
        var M, b = this.element,
          f, c = this,
          h, I;
        "string" === typeof a && void 0 !== k && (M = a, a = {}, a[M] = k);
        "string" === typeof a ? c = (this[a + "Getter"] || this._defaultGetter).call(this, a, b) : (H(a, function(k, d) {
          h = !1;
          A || P(this, d);
          this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(d) && (f || (this.symbolAttr(a), f = !0), h = !0);
          !this.rotation || "x" !== d && "y" !== d || (this.doTransform = !0);
          h || (I = this[d + "Setter"] || this._defaultSetter, I.call(this, k, d, b), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) &&
            this.updateShadows(d, k, I))
        }, this), this.afterSetters());
        d && d.call(this);
        return c
      },
      afterSetters: function() {
        this.doTransform && (this.updateTransform(), this.doTransform = !1)
      },
      updateShadows: function(a, k, d) {
        for (var M = this.shadows, A = M.length; A--;) d.call(M[A], "height" === a ? Math.max(k - (M[A].cutHeight || 0), 0) : "d" === a ? this.d : k, a, M[A])
      },
      addClass: function(a, k) {
        var d = this.attr("class") || ""; - 1 === d.indexOf(a) && (k || (a = (d + (d ? " " : "") + a).replace("  ", " ")), this.attr("class", a));
        return this
      },
      hasClass: function(a) {
        return -1 !==
          w(a, (this.attr("class") || "").split(" "))
      },
      removeClass: function(a) {
        return this.attr("class", (this.attr("class") || "").replace(a, ""))
      },
      symbolAttr: function(a) {
        var k = this;
        t("x y r start end width height innerR anchorX anchorY".split(" "), function(d) {
          k[d] = E(a[d], k[d])
        });
        k.attr({
          d: k.renderer.symbols[k.symbolName](k.x, k.y, k.width, k.height, k)
        })
      },
      clip: function(a) {
        return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none")
      },
      crisp: function(a, k) {
        var d;
        k = k || a.strokeWidth || 0;
        d = Math.round(k) % 2 / 2;
        a.x = Math.floor(a.x || this.x || 0) + d;
        a.y = Math.floor(a.y || this.y || 0) + d;
        a.width = Math.floor((a.width || this.width || 0) - 2 * d);
        a.height = Math.floor((a.height || this.height || 0) - 2 * d);
        y(a.strokeWidth) && (a.strokeWidth = k);
        return a
      },
      css: function(a) {
        var d = this.styles,
          A = {},
          b = this.element,
          f, c = "",
          M, h = !d,
          I = ["textOutline", "textOverflow", "width"];
        a && a.color && (a.fill = a.color);
        d && H(a, function(a, k) {
          a !== d[k] && (A[k] = a, h = !0)
        });
        h && (d && (a = n(d, A)), f = this.textWidth = a && a.width && "auto" !== a.width && "text" === b.nodeName.toLowerCase() && k(a.width),
          this.styles = a, f && !R && this.renderer.forExport && delete a.width, b.namespaceURI === this.SVG_NS ? (M = function(a, k) {
            return "-" + k.toLowerCase()
          }, H(a, function(a, k) {
            -1 === w(k, I) && (c += k.replace(/([A-Z])/g, M) + ":" + a + ";")
          }), c && m(b, "style", c)) : z(b, a), this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));
        return this
      },
      strokeWidth: function() {
        return this["stroke-width"] || 0
      },
      on: function(a, k) {
        var d = this,
          A = d.element;
        h && "click" === a ? (A.ontouchstart =
          function(a) {
            d.touchEventFired = Date.now();
            a.preventDefault();
            k.call(A, a)
          }, A.onclick = function(a) {
            (-1 === N.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (d.touchEventFired || 0)) && k.call(A, a)
          }) : A["on" + a] = k;
        return this
      },
      setRadialReference: function(a) {
        var k = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = a;
        k && k.radAttr && k.animate(this.renderer.getRadialAttr(a, k.radAttr));
        return this
      },
      translate: function(a, k) {
        return this.attr({
          translateX: a,
          translateY: k
        })
      },
      invert: function(a) {
        this.inverted =
          a;
        this.updateTransform();
        return this
      },
      updateTransform: function() {
        var a = this.translateX || 0,
          k = this.translateY || 0,
          d = this.scaleX,
          A = this.scaleY,
          b = this.inverted,
          f = this.rotation,
          c = this.matrix,
          h = this.element;
        b && (a += this.width, k += this.height);
        a = ["translate(" + a + "," + k + ")"];
        y(c) && a.push("matrix(" + c.join(",") + ")");
        b ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + E(this.rotationOriginX, h.getAttribute("x"), 0) + " " + E(this.rotationOriginY, h.getAttribute("y") || 0) + ")");
        (y(d) || y(A)) && a.push("scale(" + E(d, 1) +
          " " + E(A, 1) + ")");
        a.length && h.setAttribute("transform", a.join(" "))
      },
      toFront: function() {
        var a = this.element;
        a.parentNode.appendChild(a);
        return this
      },
      align: function(a, k, d) {
        var A, b, c, h, M = {};
        b = this.renderer;
        c = b.alignedObjects;
        var I, x;
        if (a) {
          if (this.alignOptions = a, this.alignByTranslate = k, !d || F(d)) this.alignTo = A = d || "renderer", f(c, this), c.push(this), d = null
        } else a = this.alignOptions, k = this.alignByTranslate, A = this.alignTo;
        d = E(d, b[A], b);
        A = a.align;
        b = a.verticalAlign;
        c = (d.x || 0) + (a.x || 0);
        h = (d.y || 0) + (a.y || 0);
        "right" ===
        A ? I = 1 : "center" === A && (I = 2);
        I && (c += (d.width - (a.width || 0)) / I);
        M[k ? "translateX" : "x"] = Math.round(c);
        "bottom" === b ? x = 1 : "middle" === b && (x = 2);
        x && (h += (d.height - (a.height || 0)) / x);
        M[k ? "translateY" : "y"] = Math.round(h);
        this[this.placed ? "animate" : "attr"](M);
        this.placed = !0;
        this.alignAttr = M;
        return this
      },
      getBBox: function(a, k) {
        var d, A = this.renderer,
          b, c = this.element,
          f = this.styles,
          h, I = this.textStr,
          M, x = A.cache,
          r = A.cacheKeys,
          e;
        k = E(k, this.rotation);
        b = k * l;
        h = f && f.fontSize;
        y(I) && (e = I.toString(), -1 === e.indexOf("\x3c") && (e = e.replace(/[0-9]/g,
          "0")), e += ["", k || 0, h, this.textWidth, f && f.textOverflow].join());
        e && !a && (d = x[e]);
        if (!d) {
          if (c.namespaceURI === this.SVG_NS || A.forExport) {
            try {
              (M = this.fakeTS && function(a) {
                t(c.querySelectorAll(".highcharts-text-outline"), function(k) {
                  k.style.display = a
                })
              }) && M("none"), d = c.getBBox ? n({}, c.getBBox()) : {
                width: c.offsetWidth,
                height: c.offsetHeight
              }, M && M("")
            } catch (fa) {}
            if (!d || 0 > d.width) d = {
              width: 0,
              height: 0
            }
          } else d = this.htmlGetBBox();
          A.isSVG && (a = d.width, A = d.height, f && "11px" === f.fontSize && 17 === Math.round(A) && (d.height = A =
            14), k && (d.width = Math.abs(A * Math.sin(b)) + Math.abs(a * Math.cos(b)), d.height = Math.abs(A * Math.cos(b)) + Math.abs(a * Math.sin(b))));
          if (e && 0 < d.height) {
            for (; 250 < r.length;) delete x[r.shift()];
            x[e] || r.push(e);
            x[e] = d
          }
        }
        return d
      },
      show: function(a) {
        return this.attr({
          visibility: a ? "inherit" : "visible"
        })
      },
      hide: function() {
        return this.attr({
          visibility: "hidden"
        })
      },
      fadeOut: function(a) {
        var k = this;
        k.animate({
          opacity: 0
        }, {
          duration: a || 150,
          complete: function() {
            k.attr({
              y: -9999
            })
          }
        })
      },
      add: function(a) {
        var k = this.renderer,
          d = this.element,
          A;
        a && (this.parentGroup = a);
        this.parentInverted = a && a.inverted;
        void 0 !== this.textStr && k.buildText(this);
        this.added = !0;
        if (!a || a.handleZ || this.zIndex) A = this.zIndexSetter();
        A || (a ? a.element : k.box).appendChild(d);
        if (this.onAdd) this.onAdd();
        return this
      },
      safeRemoveChild: function(a) {
        var k = a.parentNode;
        k && k.removeChild(a)
      },
      destroy: function() {
        var a = this,
          k = a.element || {},
          d = a.renderer.isSVG && "SPAN" === k.nodeName && a.parentGroup,
          A = k.ownerSVGElement,
          b = a.clipPath;
        k.onclick = k.onmouseout = k.onmouseover = k.onmousemove = k.point =
          null;
        P(a);
        b && A && (t(A.querySelectorAll("[clip-path],[CLIP-PATH]"), function(a) {
          var k = a.getAttribute("clip-path"),
            d = b.element.id;
          (-1 < k.indexOf("(#" + d + ")") || -1 < k.indexOf('("#' + d + '")')) && a.removeAttribute("clip-path")
        }), a.clipPath = b.destroy());
        if (a.stops) {
          for (A = 0; A < a.stops.length; A++) a.stops[A] = a.stops[A].destroy();
          a.stops = null
        }
        a.safeRemoveChild(k);
        for (a.destroyShadows(); d && d.div && 0 === d.div.childNodes.length;) k = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = k;
        a.alignTo && f(a.renderer.alignedObjects,
          a);
        H(a, function(k, d) {
          delete a[d]
        });
        return null
      },
      shadow: function(a, k, d) {
        var A = [],
          b, c, f = this.element,
          h, I, x, n;
        if (!a) this.destroyShadows();
        else if (!this.shadows) {
          I = E(a.width, 3);
          x = (a.opacity || .15) / I;
          n = this.parentInverted ? "(-1,-1)" : "(" + E(a.offsetX, 1) + ", " + E(a.offsetY, 1) + ")";
          for (b = 1; b <= I; b++) c = f.cloneNode(0), h = 2 * I + 1 - 2 * b, m(c, {
              isShadow: "true",
              stroke: a.color || "#000000",
              "stroke-opacity": x * b,
              "stroke-width": h,
              transform: "translate" + n,
              fill: "none"
            }), d && (m(c, "height", Math.max(m(c, "height") - h, 0)), c.cutHeight = h), k ?
            k.element.appendChild(c) : f.parentNode && f.parentNode.insertBefore(c, f), A.push(c);
          this.shadows = A
        }
        return this
      },
      destroyShadows: function() {
        t(this.shadows || [], function(a) {
          this.safeRemoveChild(a)
        }, this);
        this.shadows = void 0
      },
      xGetter: function(a) {
        "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
        return this._defaultGetter(a)
      },
      _defaultGetter: function(a) {
        a = E(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
        /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
        return a
      },
      dSetter: function(a,
        k, d) {
        a && a.join && (a = a.join(" "));
        /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
        this[k] !== a && (d.setAttribute(k, a), this[k] = a)
      },
      dashstyleSetter: function(a) {
        var d, A = this["stroke-width"];
        "inherit" === A && (A = 1);
        if (a = a && a.toLowerCase()) {
          a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (d = a.length; d--;) a[d] = k(a[d]) * A;
          a = a.join(",").replace(/NaN/g,
            "none");
          this.element.setAttribute("stroke-dasharray", a)
        }
      },
      alignSetter: function(a) {
        this.alignValue = a;
        this.element.setAttribute("text-anchor", {
          left: "start",
          center: "middle",
          right: "end"
        } [a])
      },
      opacitySetter: function(a, k, d) {
        this[k] = a;
        d.setAttribute(k, a)
      },
      titleSetter: function(a) {
        var k = this.element.getElementsByTagName("title")[0];
        k || (k = e.createElementNS(this.SVG_NS, "title"), this.element.appendChild(k));
        k.firstChild && k.removeChild(k.firstChild);
        k.appendChild(e.createTextNode(String(E(a), "").replace(/<[^>]*>/g,
          "").replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e")))
      },
      textSetter: function(a) {
        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this))
      },
      fillSetter: function(a, k, d) {
        "string" === typeof a ? d.setAttribute(k, a) : a && this.complexColor(a, k, d)
      },
      visibilitySetter: function(a, k, d) {
        "inherit" === a ? d.removeAttribute(k) : this[k] !== a && d.setAttribute(k, a);
        this[k] = a
      },
      zIndexSetter: function(a, d) {
        var A = this.renderer,
          b = this.parentGroup,
          c = (b || A).element || A.box,
          f, h = this.element,
          I, x, A = c === A.box;
        f = this.added;
        var n;
        y(a) && (h.zIndex = a, a = +a, this[d] === a && (f = !1), this[d] = a);
        if (f) {
          (a = this.zIndex) && b && (b.handleZ = !0);
          d = c.childNodes;
          for (n = d.length - 1; 0 <= n && !I; n--)
            if (b = d[n], f = b.zIndex, x = !y(f), b !== h)
              if (0 > a && x && !A && !n) c.insertBefore(h, d[n]), I = !0;
              else if (k(f) <= a || x && (!y(a) || 0 <= a)) c.insertBefore(h, d[n + 1] || null), I = !0;
          I || (c.insertBefore(h, d[A ? 3 : 0] || null), I = !0)
        }
        return I
      },
      _defaultSetter: function(a, k, d) {
        d.setAttribute(k, a)
      }
    });
    B.prototype.yGetter = B.prototype.xGetter;
    B.prototype.translateXSetter = B.prototype.translateYSetter =
      B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.rotationOriginXSetter = B.prototype.rotationOriginYSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = B.prototype.matrixSetter = function(a, k) {
        this[k] = a;
        this.doTransform = !0
      };
    B.prototype["stroke-widthSetter"] = B.prototype.strokeSetter = function(a, k, d) {
      this[k] = a;
      this.stroke && this["stroke-width"] ? (B.prototype.fillSetter.call(this, this.stroke, "stroke", d), d.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" ===
        k && 0 === a && this.hasStroke && (d.removeAttribute("stroke"), this.hasStroke = !1)
    };
    C = a.SVGRenderer = function() {
      this.init.apply(this, arguments)
    };
    n(C.prototype, {
      Element: B,
      SVG_NS: I,
      init: function(a, k, d, A, b, c) {
        var f;
        A = this.createElement("svg").attr({
          version: "1.1",
          "class": "highcharts-root"
        }).css(this.getStyle(A));
        f = A.element;
        a.appendChild(f);
        m(a, "dir", "ltr"); - 1 === a.innerHTML.indexOf("xmlns") && m(f, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = f;
        this.boxWrapper = A;
        this.alignedObjects = [];
        this.url = (r || x) && e.getElementsByTagName("base").length ?
          N.location.href.replace(/#.*?$/, "").replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highstock 6.1.0"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = c;
        this.forExport = b;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(k, d, !1);
        var h;
        r && a.getBoundingClientRect && (k = function() {
          z(a, {
            left: 0,
            top: 0
          });
          h = a.getBoundingClientRect();
          z(a, {
            left: Math.ceil(h.left) -
              h.left + "px",
            top: Math.ceil(h.top) - h.top + "px"
          })
        }, k(), this.unSubPixelFix = G(N, "resize", k))
      },
      getStyle: function(a) {
        return this.style = n({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, a)
      },
      setStyle: function(a) {
        this.boxWrapper.css(this.getStyle(a))
      },
      isHidden: function() {
        return !this.boxWrapper.getBBox().width
      },
      destroy: function() {
        var a = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        b(this.gradients || {});
        this.gradients = null;
        a && (this.defs = a.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null
      },
      createElement: function(a) {
        var k = new this.Element;
        k.init(this, a);
        return k
      },
      draw: d,
      getRadialAttr: function(a, k) {
        return {
          cx: a[0] - a[2] / 2 + k.cx * a[2],
          cy: a[1] - a[2] / 2 + k.cy * a[2],
          r: k.r * a[2]
        }
      },
      getSpanWidth: function(a) {
        return a.getBBox(!0).width
      },
      applyEllipsis: function(a, k, d, A) {
        var b = a.rotation,
          c = d,
          f, h = 0,
          I = d.length,
          x = function(a) {
            k.removeChild(k.firstChild);
            a && k.appendChild(e.createTextNode(a))
          },
          n;
        a.rotation = 0;
        c = this.getSpanWidth(a, k);
        if (n =
          c > A) {
          for (; h <= I;) f = Math.ceil((h + I) / 2), c = d.substring(0, f) + "\u2026", x(c), c = this.getSpanWidth(a, k), h === I ? h = I + 1 : c > A ? I = f - 1 : h = f;
          0 === I && x("")
        }
        a.rotation = b;
        return n
      },
      escapes: {
        "\x26": "\x26amp;",
        "\x3c": "\x26lt;",
        "\x3e": "\x26gt;",
        "'": "\x26#39;",
        '"': "\x26quot;"
      },
      buildText: function(a) {
        var d = a.element,
          A = this,
          b = A.forExport,
          f = E(a.textStr, "").toString(),
          h = -1 !== f.indexOf("\x3c"),
          x = d.childNodes,
          n, r = m(d, "x"),
          q = a.styles,
          l = a.textWidth,
          D = q && q.lineHeight,
          F = q && q.textOutline,
          P = q && "ellipsis" === q.textOverflow,
          K = q && "nowrap" ===
          q.whiteSpace,
          M = q && q.fontSize,
          J, g, Q = x.length,
          q = l && !a.added && this.box,
          u = function(a) {
            var b;
            b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : M || A.style.fontSize || 12;
            return D ? k(D) : A.fontMetrics(b, a.getAttribute("style") ? a : d).h
          },
          y = function(a, k) {
            H(A.escapes, function(d, A) {
              k && -1 !== w(d, k) || (a = a.toString().replace(new RegExp(d, "g"), A))
            });
            return a
          },
          N = function(a, k) {
            var d;
            d = a.indexOf("\x3c");
            a = a.substring(d, a.indexOf("\x3e") - d);
            d = a.indexOf(k + "\x3d");
            if (-1 !== d && (d = d + k.length + 1, k = a.charAt(d), '"' === k || "'" ===
                k)) return a = a.substring(d + 1), a.substring(0, a.indexOf(k))
          };
        J = [f, P, K, D, F, M, l].join();
        if (J !== a.textCache) {
          for (a.textCache = J; Q--;) d.removeChild(x[Q]);
          h || F || P || l || -1 !== f.indexOf(" ") ? (q && q.appendChild(d), f = h ? f.replace(/<(b|strong)>/g, '\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g, '\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g, "\x3cspan").replace(/<\/(b|strong|i|em|a)>/g, "\x3c/span\x3e").split(/<br.*?>/g) : [f], f = c(f, function(a) {
            return "" !== a
          }), t(f, function(k, f) {
            var c, h = 0;
            k = k.replace(/^\s+|\s+$/g,
              "").replace(/<span/g, "|||\x3cspan").replace(/<\/span>/g, "\x3c/span\x3e|||");
            c = k.split("|||");
            t(c, function(k) {
              if ("" !== k || 1 === c.length) {
                var x = {},
                  q = e.createElementNS(A.SVG_NS, "tspan"),
                  w, E;
                (w = N(k, "class")) && m(q, "class", w);
                if (w = N(k, "style")) w = w.replace(/(;| |^)color([ :])/, "$1fill$2"), m(q, "style", w);
                (E = N(k, "href")) && !b && (m(q, "onclick", 'location.href\x3d"' + E + '"'), m(q, "class", "highcharts-anchor"), z(q, {
                  cursor: "pointer"
                }));
                k = y(k.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");
                if (" " !== k) {
                  q.appendChild(e.createTextNode(k));
                  h ? x.dx = 0 : f && null !== r && (x.x = r);
                  m(q, x);
                  d.appendChild(q);
                  !h && g && (!R && b && z(q, {
                    display: "block"
                  }), m(q, "dy", u(q)));
                  if (l) {
                    x = k.replace(/([^\^])-/g, "$1- ").split(" ");
                    E = 1 < c.length || f || 1 < x.length && !K;
                    var H = [],
                      D, t = u(q),
                      F = a.rotation;
                    for (P && (n = A.applyEllipsis(a, q, k, l)); !P && E && (x.length || H.length);) a.rotation = 0, D = A.getSpanWidth(a, q), k = D > l, void 0 === n && (n = k), k && 1 !== x.length ? (q.removeChild(q.firstChild), H.unshift(x.pop())) : (x = H, H = [], x.length && !K && (q = e.createElementNS(I, "tspan"), m(q, {
                        dy: t,
                        x: r
                      }), w && m(q, "style", w), d.appendChild(q)),
                      D > l && (l = D)), x.length && q.appendChild(e.createTextNode(x.join(" ").replace(/- /g, "-")));
                    a.rotation = F
                  }
                  h++
                }
              }
            });
            g = g || d.childNodes.length
          }), n && a.attr("title", y(a.textStr, ["\x26lt;", "\x26gt;"])), q && q.removeChild(d), F && a.applyTextOutline && a.applyTextOutline(F)) : d.appendChild(e.createTextNode(y(f)))
        }
      },
      getContrast: function(a) {
        a = v(a).rgba;
        return 510 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF"
      },
      button: function(a, k, d, A, b, f, c, h, x) {
        var I = this.label(a, k, d, x, null, null, null, null, "button"),
          q = 0;
        I.attr(K({
          padding: 8,
          r: 2
        }, b));
        var r,
          e, w, E;
        b = K({
          fill: "#f7f7f7",
          stroke: "#cccccc",
          "stroke-width": 1,
          style: {
            color: "#333333",
            cursor: "pointer",
            fontWeight: "normal"
          }
        }, b);
        r = b.style;
        delete b.style;
        f = K(b, {
          fill: "#e6e6e6"
        }, f);
        e = f.style;
        delete f.style;
        c = K(b, {
          fill: "#e6ebf5",
          style: {
            color: "#000000",
            fontWeight: "bold"
          }
        }, c);
        w = c.style;
        delete c.style;
        h = K(b, {
          style: {
            color: "#cccccc"
          }
        }, h);
        E = h.style;
        delete h.style;
        G(I.element, J ? "mouseover" : "mouseenter", function() {
          3 !== q && I.setState(1)
        });
        G(I.element, J ? "mouseout" : "mouseleave", function() {
          3 !== q && I.setState(q)
        });
        I.setState =
          function(a) {
            1 !== a && (I.state = q = a);
            I.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
            I.attr([b, f, c, h][a || 0]).css([r, e, w, E][a || 0])
          };
        I.attr(b).css(n({
          cursor: "default"
        }, r));
        return I.on("click", function(a) {
          3 !== q && A.call(I, a)
        })
      },
      crispLine: function(a, k) {
        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - k % 2 / 2);
        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + k % 2 / 2);
        return a
      },
      path: function(a) {
        var k = {
          fill: "none"
        };
        D(a) ? k.d = a : q(a) && n(k,
          a);
        return this.createElement("path").attr(k)
      },
      circle: function(a, k, d) {
        a = q(a) ? a : {
          x: a,
          y: k,
          r: d
        };
        k = this.createElement("circle");
        k.xSetter = k.ySetter = function(a, k, d) {
          d.setAttribute("c" + k, a)
        };
        return k.attr(a)
      },
      arc: function(a, k, d, A, b, f) {
        q(a) ? (A = a, k = A.y, d = A.r, a = A.x) : A = {
          innerR: A,
          start: b,
          end: f
        };
        a = this.symbol("arc", a, k, d, d, A);
        a.r = d;
        return a
      },
      rect: function(a, k, d, A, b, f) {
        b = q(a) ? a.r : b;
        var c = this.createElement("rect");
        a = q(a) ? a : void 0 === a ? {} : {
          x: a,
          y: k,
          width: Math.max(d, 0),
          height: Math.max(A, 0)
        };
        void 0 !== f && (a.strokeWidth =
          f, a = c.crisp(a));
        a.fill = "none";
        b && (a.r = b);
        c.rSetter = function(a, k, d) {
          m(d, {
            rx: a,
            ry: a
          })
        };
        return c.attr(a)
      },
      setSize: function(a, k, d) {
        var A = this.alignedObjects,
          b = A.length;
        this.width = a;
        this.height = k;
        for (this.boxWrapper.animate({
            width: a,
            height: k
          }, {
            step: function() {
              this.attr({
                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
              })
            },
            duration: E(d, !0) ? void 0 : 0
          }); b--;) A[b].align()
      },
      g: function(a) {
        var k = this.createElement("g");
        return a ? k.attr({
          "class": "highcharts-" + a
        }) : k
      },
      image: function(a, k, d, A, b, f) {
        var c = {
            preserveAspectRatio: "none"
          },
          h, I = function(a, k) {
            a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", k) : a.setAttribute("hc-svg-href", k)
          };
        1 < arguments.length && n(c, {
          x: k,
          y: d,
          width: A,
          height: b
        });
        h = this.createElement("image").attr(c);
        f ? (I(h.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\x3d\x3d"), c = new N.Image, G(c, "load", function(k) {
          I(h.element, a);
          f.call(h, k)
        }), c.src = a) : I(h.element, a);
        return h
      },
      symbol: function(a, k, d, A, b, c) {
        var f = this,
          h, I = /^url\((.*?)\)$/,
          x = I.test(a),
          q = !x && (this.symbols[a] ?
            a : "circle"),
          r = q && this.symbols[q],
          w = y(k) && r && r.call(this.symbols, Math.round(k), Math.round(d), A, b, c),
          l, H;
        r ? (h = this.path(w), h.attr("fill", "none"), n(h, {
          symbolName: q,
          x: k,
          y: d,
          width: A,
          height: b
        }), c && n(h, c)) : x && (l = a.match(I)[1], h = this.image(l), h.imgwidth = E(Q[l] && Q[l].width, c && c.width), h.imgheight = E(Q[l] && Q[l].height, c && c.height), H = function() {
          h.attr({
            width: h.width,
            height: h.height
          })
        }, t(["width", "height"], function(a) {
          h[a + "Setter"] = function(a, k) {
            var d = {},
              A = this["img" + k],
              b = "width" === k ? "translateX" : "translateY";
            this[k] = a;
            y(A) && (this.element && this.element.setAttribute(k, A), this.alignByTranslate || (d[b] = ((this[k] || 0) - A) / 2, this.attr(d)))
          }
        }), y(k) && h.attr({
          x: k,
          y: d
        }), h.isImg = !0, y(h.imgwidth) && y(h.imgheight) ? H() : (h.attr({
          width: 0,
          height: 0
        }), u("img", {
          onload: function() {
            var a = g[f.chartIndex];
            0 === this.width && (z(this, {
              position: "absolute",
              top: "-999em"
            }), e.body.appendChild(this));
            Q[l] = {
              width: this.width,
              height: this.height
            };
            h.imgwidth = this.width;
            h.imgheight = this.height;
            h.element && H();
            this.parentNode && this.parentNode.removeChild(this);
            f.imgCount--;
            if (!f.imgCount && a && a.onload) a.onload()
          },
          src: l
        }), this.imgCount++));
        return h
      },
      symbols: {
        circle: function(a, k, d, A) {
          return this.arc(a + d / 2, k + A / 2, d / 2, A / 2, {
            start: 0,
            end: 2 * Math.PI,
            open: !1
          })
        },
        square: function(a, k, d, A) {
          return ["M", a, k, "L", a + d, k, a + d, k + A, a, k + A, "Z"]
        },
        triangle: function(a, k, d, A) {
          return ["M", a + d / 2, k, "L", a + d, k + A, a, k + A, "Z"]
        },
        "triangle-down": function(a, k, d, A) {
          return ["M", a, k, "L", a + d, k, a + d / 2, k + A, "Z"]
        },
        diamond: function(a, k, d, A) {
          return ["M", a + d / 2, k, "L", a + d, k + A / 2, a + d / 2, k + A, a, k + A / 2, "Z"]
        },
        arc: function(a,
          k, d, A, b) {
          var c = b.start,
            f = b.r || d,
            h = b.r || A || d,
            I = b.end - .001;
          d = b.innerR;
          A = E(b.open, .001 > Math.abs(b.end - b.start - 2 * Math.PI));
          var x = Math.cos(c),
            n = Math.sin(c),
            q = Math.cos(I),
            I = Math.sin(I);
          b = .001 > b.end - c - Math.PI ? 0 : 1;
          f = ["M", a + f * x, k + h * n, "A", f, h, 0, b, 1, a + f * q, k + h * I];
          y(d) && f.push(A ? "M" : "L", a + d * q, k + d * I, "A", d, d, 0, b, 0, a + d * x, k + d * n);
          f.push(A ? "" : "Z");
          return f
        },
        callout: function(a, k, d, A, b) {
          var c = Math.min(b && b.r || 0, d, A),
            f = c + 6,
            h = b && b.anchorX;
          b = b && b.anchorY;
          var I;
          I = ["M", a + c, k, "L", a + d - c, k, "C", a + d, k, a + d, k, a + d, k + c, "L", a + d, k + A -
            c, "C", a + d, k + A, a + d, k + A, a + d - c, k + A, "L", a + c, k + A, "C", a, k + A, a, k + A, a, k + A - c, "L", a, k + c, "C", a, k, a, k, a + c, k
          ];
          h && h > d ? b > k + f && b < k + A - f ? I.splice(13, 3, "L", a + d, b - 6, a + d + 6, b, a + d, b + 6, a + d, k + A - c) : I.splice(13, 3, "L", a + d, A / 2, h, b, a + d, A / 2, a + d, k + A - c) : h && 0 > h ? b > k + f && b < k + A - f ? I.splice(33, 3, "L", a, b + 6, a - 6, b, a, b - 6, a, k + c) : I.splice(33, 3, "L", a, A / 2, h, b, a, A / 2, a, k + c) : b && b > A && h > a + f && h < a + d - f ? I.splice(23, 3, "L", h + 6, k + A, h, k + A + 6, h - 6, k + A, a + c, k + A) : b && 0 > b && h > a + f && h < a + d - f && I.splice(3, 3, "L", h - 6, k, h, k - 6, h + 6, k, d - c, k);
          return I
        }
      },
      clipRect: function(k, d, A,
        b) {
        var c = a.uniqueKey(),
          f = this.createElement("clipPath").attr({
            id: c
          }).add(this.defs);
        k = this.rect(k, d, A, b, 0).add(f);
        k.id = c;
        k.clipPath = f;
        k.count = 0;
        return k
      },
      text: function(a, k, d, A) {
        var b = {};
        if (A && (this.allowHTML || !this.forExport)) return this.html(a, k, d);
        b.x = Math.round(k || 0);
        d && (b.y = Math.round(d));
        if (a || 0 === a) b.text = a;
        a = this.createElement("text").attr(b);
        A || (a.xSetter = function(a, k, d) {
          var A = d.getElementsByTagName("tspan"),
            b, c = d.getAttribute(k),
            f;
          for (f = 0; f < A.length; f++) b = A[f], b.getAttribute(k) === c && b.setAttribute(k,
            a);
          d.setAttribute(k, a)
        });
        return a
      },
      fontMetrics: function(a, d) {
        a = a || d && d.style && d.style.fontSize || this.style && this.style.fontSize;
        a = /px/.test(a) ? k(a) : /em/.test(a) ? parseFloat(a) * (d ? this.fontMetrics(null, d.parentNode).f : 16) : 12;
        d = 24 > a ? a + 3 : Math.round(1.2 * a);
        return {
          h: d,
          b: Math.round(.8 * d),
          f: a
        }
      },
      rotCorr: function(a, k, d) {
        var A = a;
        k && d && (A = Math.max(A * Math.cos(k * l), 4));
        return {
          x: -a / 3 * Math.sin(k * l),
          y: A
        }
      },
      label: function(k, d, b, c, f, h, I, x, q) {
        var r = this,
          e = r.g("button" !== q && "label"),
          w = e.text = r.text("", 0, 0, I).attr({
            zIndex: 1
          }),
          E, l, H = 0,
          D = 3,
          F = 0,
          R, P, J, g, Q, m = {},
          u, N, v = /^url\((.*?)\)$/.test(c),
          z = v,
          M, p, S, O;
        q && e.addClass("highcharts-" + q);
        z = v;
        M = function() {
          return (u || 0) % 2 / 2
        };
        p = function() {
          var a = w.element.style,
            k = {};
          l = (void 0 === R || void 0 === P || Q) && y(w.textStr) && w.getBBox();
          e.width = (R || l.width || 0) + 2 * D + F;
          e.height = (P || l.height || 0) + 2 * D;
          N = D + r.fontMetrics(a && a.fontSize, w).b;
          z && (E || (e.box = E = r.symbols[c] || v ? r.symbol(c) : r.rect(), E.addClass(("button" === q ? "" : "highcharts-label-box") + (q ? " highcharts-" + q + "-box" : "")), E.add(e), a = M(), k.x = a, k.y = (x ? -N :
            0) + a), k.width = Math.round(e.width), k.height = Math.round(e.height), E.attr(n(k, m)), m = {})
        };
        S = function() {
          var a = F + D,
            k;
          k = x ? 0 : N;
          y(R) && l && ("center" === Q || "right" === Q) && (a += {
            center: .5,
            right: 1
          } [Q] * (R - l.width));
          if (a !== w.x || k !== w.y) w.attr("x", a), void 0 !== k && w.attr("y", k);
          w.x = a;
          w.y = k
        };
        O = function(a, k) {
          E ? E.attr(a, k) : m[a] = k
        };
        e.onAdd = function() {
          w.add(e);
          e.attr({
            text: k || 0 === k ? k : "",
            x: d,
            y: b
          });
          E && y(f) && e.attr({
            anchorX: f,
            anchorY: h
          })
        };
        e.widthSetter = function(k) {
          R = a.isNumber(k) ? k : null
        };
        e.heightSetter = function(a) {
          P = a
        };
        e["text-alignSetter"] =
          function(a) {
            Q = a
          };
        e.paddingSetter = function(a) {
          y(a) && a !== D && (D = e.padding = a, S())
        };
        e.paddingLeftSetter = function(a) {
          y(a) && a !== F && (F = a, S())
        };
        e.alignSetter = function(a) {
          a = {
            left: 0,
            center: .5,
            right: 1
          } [a];
          a !== H && (H = a, l && e.attr({
            x: J
          }))
        };
        e.textSetter = function(a) {
          void 0 !== a && w.textSetter(a);
          p();
          S()
        };
        e["stroke-widthSetter"] = function(a, k) {
          a && (z = !0);
          u = this["stroke-width"] = a;
          O(k, a)
        };
        e.strokeSetter = e.fillSetter = e.rSetter = function(a, k) {
          "r" !== k && ("fill" === k && a && (z = !0), e[k] = a);
          O(k, a)
        };
        e.anchorXSetter = function(a, k) {
          f = e.anchorX =
            a;
          O(k, Math.round(a) - M() - J)
        };
        e.anchorYSetter = function(a, k) {
          h = e.anchorY = a;
          O(k, a - g)
        };
        e.xSetter = function(a) {
          e.x = a;
          H && (a -= H * ((R || l.width) + 2 * D), e["forceAnimate:x"] = !0);
          J = Math.round(a);
          e.attr("translateX", J)
        };
        e.ySetter = function(a) {
          g = e.y = Math.round(a);
          e.attr("translateY", g)
        };
        var ea = e.css;
        return n(e, {
          css: function(a) {
            if (a) {
              var k = {};
              a = K(a);
              t(e.textProps, function(d) {
                void 0 !== a[d] && (k[d] = a[d], delete a[d])
              });
              w.css(k);
              "width" in k && p()
            }
            return ea.call(e, a)
          },
          getBBox: function() {
            return {
              width: l.width + 2 * D,
              height: l.height +
                2 * D,
              x: l.x - D,
              y: l.y - D
            }
          },
          shadow: function(a) {
            a && (p(), E && E.shadow(a));
            return e
          },
          destroy: function() {
            A(e.element, "mouseenter");
            A(e.element, "mouseleave");
            w && (w = w.destroy());
            E && (E = E.destroy());
            B.prototype.destroy.call(e);
            e = r = p = S = O = null
          }
        })
      }
    });
    a.Renderer = C
  })(L);
  (function(a) {
    var B = a.attr,
      C = a.createElement,
      G = a.css,
      p = a.defined,
      m = a.each,
      g = a.extend,
      v = a.isFirefox,
      z = a.isMS,
      u = a.isWebKit,
      y = a.pick,
      l = a.pInt,
      b = a.SVGRenderer,
      e = a.win,
      t = a.wrap;
    g(a.SVGElement.prototype, {
      htmlCss: function(a) {
        var b = this.element;
        if (b = a && "SPAN" ===
          b.tagName && a.width) delete a.width, this.textWidth = b, this.htmlUpdateTransform();
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = g(this.styles, a);
        G(this.element, a);
        return this
      },
      htmlGetBBox: function() {
        var a = this.element;
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        }
      },
      htmlUpdateTransform: function() {
        if (this.added) {
          var a = this.renderer,
            b = this.element,
            c = this.translateX || 0,
            h = this.translateY || 0,
            e = this.x || 0,
            D = this.y || 0,
            r = this.textAlign ||
            "left",
            t = {
              left: 0,
              center: .5,
              right: 1
            } [r],
            q = this.styles,
            F = q && q.whiteSpace;
          G(b, {
            marginLeft: c,
            marginTop: h
          });
          this.shadows && m(this.shadows, function(a) {
            G(a, {
              marginLeft: c + 1,
              marginTop: h + 1
            })
          });
          this.inverted && m(b.childNodes, function(d) {
            a.invertChild(d, b)
          });
          if ("SPAN" === b.tagName) {
            var q = this.rotation,
              x = this.textWidth && l(this.textWidth),
              K = [q, r, b.innerHTML, this.textWidth, this.textAlign].join(),
              d;
            (d = x !== this.oldTextWidth) && !(d = x > this.oldTextWidth) && ((d = this.textPxLength) || (G(b, {
                width: "",
                whiteSpace: F || "nowrap"
              }), d =
              b.offsetWidth), d = d > x);
            d && /[ \-]/.test(b.textContent || b.innerText) && (G(b, {
              width: x + "px",
              display: "block",
              whiteSpace: F || "normal"
            }), this.oldTextWidth = x);
            K !== this.cTT && (F = a.fontMetrics(b.style.fontSize).b, p(q) && q !== (this.oldRotation || 0) && this.setSpanRotation(q, t, F), this.getSpanCorrection(!p(q) && this.textPxLength || b.offsetWidth, F, t, q, r));
            G(b, {
              left: e + (this.xCorr || 0) + "px",
              top: D + (this.yCorr || 0) + "px"
            });
            this.cTT = K;
            this.oldRotation = q
          }
        } else this.alignOnAdd = !0
      },
      setSpanRotation: function(a, b, c) {
        var f = {},
          e = this.renderer.getTransformKey();
        f[e] = f.transform = "rotate(" + a + "deg)";
        f[e + (v ? "Origin" : "-origin")] = f.transformOrigin = 100 * b + "% " + c + "px";
        G(this.element, f)
      },
      getSpanCorrection: function(a, b, c) {
        this.xCorr = -a * c;
        this.yCorr = -b
      }
    });
    g(b.prototype, {
      getTransformKey: function() {
        return z && !/Edge/.test(e.navigator.userAgent) ? "-ms-transform" : u ? "-webkit-transform" : v ? "MozTransform" : e.opera ? "-o-transform" : ""
      },
      html: function(a, b, c) {
        var f = this.createElement("span"),
          e = f.element,
          n = f.renderer,
          r = n.isSVG,
          l = function(a, b) {
            m(["opacity", "visibility"], function(c) {
              t(a,
                c + "Setter",
                function(a, d, c, f) {
                  a.call(this, d, c, f);
                  b[c] = d
                })
            });
            a.addedSetters = !0
          };
        f.textSetter = function(a) {
          a !== e.innerHTML && delete this.bBox;
          this.textStr = a;
          e.innerHTML = y(a, "");
          f.doTransform = !0
        };
        r && l(f, f.element.style);
        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function(a, b) {
          "align" === b && (b = "textAlign");
          f[b] = a;
          f.doTransform = !0
        };
        f.afterSetters = function() {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1)
        };
        f.attr({
          text: a,
          x: Math.round(b),
          y: Math.round(c)
        }).css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize,
          position: "absolute"
        });
        e.style.whiteSpace = "nowrap";
        f.css = f.htmlCss;
        r && (f.add = function(a) {
          var b, c = n.box.parentNode,
            h = [];
          if (this.parentGroup = a) {
            if (b = a.div, !b) {
              for (; a;) h.push(a), a = a.parentGroup;
              m(h.reverse(), function(a) {
                function d(k, d) {
                  a[d] = k;
                  "translateX" === d ? x.left = k + "px" : x.top = k + "px";
                  a.doTransform = !0
                }
                var x, k = B(a.element, "class");
                k && (k = {
                  className: k
                });
                b = a.div = a.div || C("div", k, {
                  position: "absolute",
                  left: (a.translateX || 0) + "px",
                  top: (a.translateY || 0) + "px",
                  display: a.display,
                  opacity: a.opacity,
                  pointerEvents: a.styles && a.styles.pointerEvents
                }, b || c);
                x = b.style;
                g(a, {
                  classSetter: function(a) {
                    return function(k) {
                      this.element.setAttribute("class", k);
                      a.className = k
                    }
                  }(b),
                  on: function() {
                    h[0].div && f.on.apply({
                      element: h[0].div
                    }, arguments);
                    return a
                  },
                  translateXSetter: d,
                  translateYSetter: d
                });
                a.addedSetters || l(a, x)
              })
            }
          } else b = c;
          b.appendChild(e);
          f.added = !0;
          f.alignOnAdd && f.htmlUpdateTransform();
          return f
        });
        return f
      }
    })
  })(L);
  (function(a) {
    var B = a.defined,
      C = a.each,
      G = a.extend,
      p = a.merge,
      m = a.pick,
      g = a.timeUnits,
      v = a.win;
    a.Time = function(a) {
      this.update(a, !1)
    };
    a.Time.prototype = {
      defaultOptions: {},
      update: function(g) {
        var u = m(g && g.useUTC, !0),
          y = this;
        this.options = g = p(!0, this.options || {}, g);
        this.Date = g.Date || v.Date;
        this.timezoneOffset = (this.useUTC = u) && g.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        (this.variableTimezone = !(u && !g.getTimezoneOffset && !g.timezone)) || this.timezoneOffset ? (this.get = function(a, b) {
            var e = b.getTime(),
              l = e - y.getTimezoneOffset(b);
            b.setTime(l);
            a = b["getUTC" + a]();
            b.setTime(e);
            return a
          },
          this.set = function(l, b, e) {
            var t;
            if (-1 !== a.inArray(l, ["Milliseconds", "Seconds", "Minutes"])) b["set" + l](e);
            else t = y.getTimezoneOffset(b), t = b.getTime() - t, b.setTime(t), b["setUTC" + l](e), l = y.getTimezoneOffset(b), t = b.getTime() + l, b.setTime(t)
          }) : u ? (this.get = function(a, b) {
          return b["getUTC" + a]()
        }, this.set = function(a, b, e) {
          return b["setUTC" + a](e)
        }) : (this.get = function(a, b) {
          return b["get" + a]()
        }, this.set = function(a, b, e) {
          return b["set" + a](e)
        })
      },
      makeTime: function(g, u, y, l, b, e) {
        var t, n, f;
        this.useUTC ? (t = this.Date.UTC.apply(0,
          arguments), n = this.getTimezoneOffset(t), t += n, f = this.getTimezoneOffset(t), n !== f ? t += f - n : n - 36E5 !== this.getTimezoneOffset(t - 36E5) || a.isSafari || (t -= 36E5)) : t = (new this.Date(g, u, m(y, 1), m(l, 0), m(b, 0), m(e, 0))).getTime();
        return t
      },
      timezoneOffsetFunction: function() {
        var g = this,
          m = this.options,
          y = v.moment;
        if (!this.useUTC) return function(a) {
          return 6E4 * (new Date(a)).getTimezoneOffset()
        };
        if (m.timezone) {
          if (y) return function(a) {
            return 6E4 * -y.tz(a, m.timezone).utcOffset()
          };
          a.error(25)
        }
        return this.useUTC && m.getTimezoneOffset ?
          function(a) {
            return 6E4 * m.getTimezoneOffset(a)
          } : function() {
            return 6E4 * (g.timezoneOffset || 0)
          }
      },
      dateFormat: function(g, m, y) {
        if (!a.defined(m) || isNaN(m)) return a.defaultOptions.lang.invalidDate || "";
        g = a.pick(g, "%Y-%m-%d %H:%M:%S");
        var l = this,
          b = new this.Date(m),
          e = this.get("Hours", b),
          t = this.get("Day", b),
          n = this.get("Date", b),
          f = this.get("Month", b),
          c = this.get("FullYear", b),
          h = a.defaultOptions.lang,
          w = h.weekdays,
          D = h.shortWeekdays,
          r = a.pad,
          b = a.extend({
            a: D ? D[t] : w[t].substr(0, 3),
            A: w[t],
            d: r(n),
            e: r(n, 2, " "),
            w: t,
            b: h.shortMonths[f],
            B: h.months[f],
            m: r(f + 1),
            y: c.toString().substr(2, 2),
            Y: c,
            H: r(e),
            k: e,
            I: r(e % 12 || 12),
            l: e % 12 || 12,
            M: r(l.get("Minutes", b)),
            p: 12 > e ? "AM" : "PM",
            P: 12 > e ? "am" : "pm",
            S: r(b.getSeconds()),
            L: r(Math.round(m % 1E3), 3)
          }, a.dateFormats);
        a.objectEach(b, function(a, b) {
          for (; - 1 !== g.indexOf("%" + b);) g = g.replace("%" + b, "function" === typeof a ? a.call(l, m) : a)
        });
        return y ? g.substr(0, 1).toUpperCase() + g.substr(1) : g
      },
      getTimeTicks: function(a, u, y, l) {
        var b = this,
          e = [],
          t = {},
          n, f = new b.Date(u),
          c = a.unitRange,
          h = a.count || 1,
          w;
        if (B(u)) {
          b.set("Milliseconds",
            f, c >= g.second ? 0 : h * Math.floor(b.get("Milliseconds", f) / h));
          c >= g.second && b.set("Seconds", f, c >= g.minute ? 0 : h * Math.floor(b.get("Seconds", f) / h));
          c >= g.minute && b.set("Minutes", f, c >= g.hour ? 0 : h * Math.floor(b.get("Minutes", f) / h));
          c >= g.hour && b.set("Hours", f, c >= g.day ? 0 : h * Math.floor(b.get("Hours", f) / h));
          c >= g.day && b.set("Date", f, c >= g.month ? 1 : h * Math.floor(b.get("Date", f) / h));
          c >= g.month && (b.set("Month", f, c >= g.year ? 0 : h * Math.floor(b.get("Month", f) / h)), n = b.get("FullYear", f));
          c >= g.year && b.set("FullYear", f, n - n % h);
          c === g.week &&
            b.set("Date", f, b.get("Date", f) - b.get("Day", f) + m(l, 1));
          n = b.get("FullYear", f);
          l = b.get("Month", f);
          var D = b.get("Date", f),
            r = b.get("Hours", f);
          u = f.getTime();
          b.variableTimezone && (w = y - u > 4 * g.month || b.getTimezoneOffset(u) !== b.getTimezoneOffset(y));
          f = f.getTime();
          for (u = 1; f < y;) e.push(f), f = c === g.year ? b.makeTime(n + u * h, 0) : c === g.month ? b.makeTime(n, l + u * h) : !w || c !== g.day && c !== g.week ? w && c === g.hour && 1 < h ? b.makeTime(n, l, D, r + u * h) : f + c * h : b.makeTime(n, l, D + u * h * (c === g.day ? 1 : 7)), u++;
          e.push(f);
          c <= g.hour && 1E4 > e.length && C(e, function(a) {
            0 ===
              a % 18E5 && "000000000" === b.dateFormat("%H%M%S%L", a) && (t[a] = "day")
          })
        }
        e.info = G(a, {
          higherRanks: t,
          totalRange: c * h
        });
        return e
      }
    }
  })(L);
  (function(a) {
    var B = a.color,
      C = a.merge;
    a.defaultOptions = {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
        weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        decimalPoint: ".",
        numericSymbols: "kMGTPE".split(""),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {},
      time: a.Time.prototype.defaultOptions,
      chart: {
        borderRadius: 0,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null,
        borderColor: "#335cad",
        backgroundColor: "#ffffff",
        plotBorderColor: "#cccccc"
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        widthAdjust: -44
      },
      plotOptions: {},
      labels: {
        style: {
          position: "absolute",
          color: "#333333"
        }
      },
      legend: {
        enabled: !0,
        align: "center",
        alignColumns: !0,
        layout: "horizontal",
        labelFormatter: function() {
          return this.name
        },
        borderColor: "#999999",
        borderRadius: 0,
        navigation: {
          activeColor: "#003399",
          inactiveColor: "#cccccc"
        },
        itemStyle: {
          color: "#333333",
          fontSize: "12px",
          fontWeight: "bold",
          textOverflow: "ellipsis"
        },
        itemHoverStyle: {
          color: "#000000"
        },
        itemHiddenStyle: {
          color: "#cccccc"
        },
        shadow: !1,
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        squareSymbol: !0,
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {
          style: {
            fontWeight: "bold"
          }
        }
      },
      loading: {
        labelStyle: {
          fontWeight: "bold",
          position: "relative",
          top: "45%"
        },
        style: {
          position: "absolute",
          backgroundColor: "#ffffff",
          opacity: .5,
          textAlign: "center"
        }
      },
      tooltip: {
        enabled: !0,
        animation: a.svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        padding: 8,
        snap: a.isTouchDevice ? 25 : 10,
        backgroundColor: B("#f7f7f7").setOpacity(.85).get(),
        borderWidth: 1,
        headerFormat: '\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
        pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',
        shadow: !0,
        style: {
          color: "#333333",
          cursor: "default",
          fontSize: "12px",
          pointerEvents: "none",
          whiteSpace: "nowrap"
        }
      },
      credits: {
        enabled: !0,
        href: "http://www.highcharts.com",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        style: {
          cursor: "pointer",
          color: "#999999",
          fontSize: "9px"
        },
        text: "Highcharts.com"
      }
    };
    a.setOptions = function(B) {
      a.defaultOptions = C(!0, a.defaultOptions, B);
      a.time.update(C(a.defaultOptions.global, a.defaultOptions.time), !1);
      return a.defaultOptions
    };
    a.getOptions = function() {
      return a.defaultOptions
    };
    a.defaultPlotOptions = a.defaultOptions.plotOptions;
    a.time = new a.Time(C(a.defaultOptions.global, a.defaultOptions.time));
    a.dateFormat = function(C, p, m) {
      return a.time.dateFormat(C, p, m)
    }
  })(L);
  (function(a) {
    var B = a.correctFloat,
      C = a.defined,
      G = a.destroyObjectProperties,
      p = a.fireEvent,
      m = a.isNumber,
      g = a.merge,
      v = a.pick,
      z = a.deg2rad;
    a.Tick = function(a, g, l, b) {
      this.axis = a;
      this.pos = g;
      this.type = l || "";
      this.isNewLabel = this.isNew = !0;
      l || b || this.addLabel()
    };
    a.Tick.prototype = {
      addLabel: function() {
        var a = this.axis,
          m = a.options,
          l = a.chart,
          b = a.categories,
          e = a.names,
          t = this.pos,
          n = m.labels,
          f = a.tickPositions,
          c = t === f[0],
          h = t === f[f.length - 1],
          e = b ? v(b[t], e[t], t) : t,
          b = this.label,
          f = f.info,
          w;
        a.isDatetimeAxis && f && (w = m.dateTimeLabelFormats[f.higherRanks[t] || f.unitName]);
        this.isFirst = c;
        this.isLast = h;
        m = a.labelFormatter.call({
          axis: a,
          chart: l,
          isFirst: c,
          isLast: h,
          dateTimeLabelFormat: w,
          value: a.isLog ? B(a.lin2log(e)) : e,
          pos: t
        });
        if (C(b)) b && b.attr({
          text: m
        });
        else {
          if (this.label = b = C(m) && n.enabled ? l.renderer.text(m, 0, 0, n.useHTML).css(g(n.style)).add(a.labelGroup) : null) b.textPxLength = b.getBBox().width;
          this.rotation =
            0
        }
      },
      getLabelSize: function() {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
      },
      handleOverflow: function(a) {
        var g = this.axis,
          l = g.options.labels,
          b = a.x,
          e = g.chart.chartWidth,
          t = g.chart.spacing,
          n = v(g.labelLeft, Math.min(g.pos, t[3])),
          t = v(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, e - t[1])),
          f = this.label,
          c = this.rotation,
          h = {
            left: 0,
            center: .5,
            right: 1
          } [g.labelAlign || f.attr("align")],
          w = f.getBBox().width,
          D = g.getSlotWidth(),
          r = D,
          J = 1,
          q, F = {};
        if (c || !1 === l.overflow) 0 > c && b - h * w < n ? q = Math.round(b /
          Math.cos(c * z) - n) : 0 < c && b + h * w > t && (q = Math.round((e - b) / Math.cos(c * z)));
        else if (e = b + (1 - h) * w, b - h * w < n ? r = a.x + r * (1 - h) - n : e > t && (r = t - a.x + r * h, J = -1), r = Math.min(D, r), r < D && "center" === g.labelAlign && (a.x += J * (D - r - h * (D - Math.min(w, r)))), w > r || g.autoRotation && (f.styles || {}).width) q = r;
        q && (F.width = q, (l.style || {}).textOverflow || (F.textOverflow = "ellipsis"), f.css(F))
      },
      getPosition: function(g, m, l, b) {
        var e = this.axis,
          t = e.chart,
          n = b && t.oldChartHeight || t.chartHeight;
        g = {
          x: g ? a.correctFloat(e.translate(m + l, null, null, b) + e.transB) : e.left +
            e.offset + (e.opposite ? (b && t.oldChartWidth || t.chartWidth) - e.right - e.left : 0),
          y: g ? n - e.bottom + e.offset - (e.opposite ? e.height : 0) : a.correctFloat(n - e.translate(m + l, null, null, b) - e.transB)
        };
        p(this, "afterGetPosition", {
          pos: g
        });
        return g
      },
      getLabelPosition: function(a, g, l, b, e, t, n, f) {
        var c = this.axis,
          h = c.transA,
          w = c.reversed,
          D = c.staggerLines,
          r = c.tickRotCorr || {
            x: 0,
            y: 0
          },
          J = e.y,
          q = b || c.reserveSpaceDefault ? 0 : -c.labelOffset * ("center" === c.labelAlign ? .5 : 1),
          F = {};
        C(J) || (J = 0 === c.side ? l.rotation ? -8 : -l.getBBox().height : 2 === c.side ?
          r.y + 8 : Math.cos(l.rotation * z) * (r.y - l.getBBox(!1, 0).height / 2));
        a = a + e.x + q + r.x - (t && b ? t * h * (w ? -1 : 1) : 0);
        g = g + J - (t && !b ? t * h * (w ? 1 : -1) : 0);
        D && (l = n / (f || 1) % D, c.opposite && (l = D - l - 1), g += c.labelOffset / D * l);
        F.x = a;
        F.y = Math.round(g);
        p(this, "afterGetLabelPosition", {
          pos: F
        });
        return F
      },
      getMarkPath: function(a, g, l, b, e, t) {
        return t.crispLine(["M", a, g, "L", a + (e ? 0 : -l), g + (e ? l : 0)], b)
      },
      renderGridLine: function(a, g, l) {
        var b = this.axis,
          e = b.options,
          t = this.gridLine,
          n = {},
          f = this.pos,
          c = this.type,
          h = b.tickmarkOffset,
          w = b.chart.renderer,
          D = c ? c + "Grid" :
          "grid",
          r = e[D + "LineWidth"],
          J = e[D + "LineColor"],
          e = e[D + "LineDashStyle"];
        t || (n.stroke = J, n["stroke-width"] = r, e && (n.dashstyle = e), c || (n.zIndex = 1), a && (n.opacity = 0), this.gridLine = t = w.path().attr(n).addClass("highcharts-" + (c ? c + "-" : "") + "grid-line").add(b.gridGroup));
        if (!a && t && (a = b.getPlotLinePath(f + h, t.strokeWidth() * l, a, !0))) t[this.isNew ? "attr" : "animate"]({
          d: a,
          opacity: g
        })
      },
      renderMark: function(a, g, l) {
        var b = this.axis,
          e = b.options,
          t = b.chart.renderer,
          n = this.type,
          f = n ? n + "Tick" : "tick",
          c = b.tickSize(f),
          h = this.mark,
          w = !h,
          D = a.x;
        a = a.y;
        var r = v(e[f + "Width"], !n && b.isXAxis ? 1 : 0),
          e = e[f + "Color"];
        c && (b.opposite && (c[0] = -c[0]), w && (this.mark = h = t.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(b.axisGroup), h.attr({
          stroke: e,
          "stroke-width": r
        })), h[w ? "attr" : "animate"]({
          d: this.getMarkPath(D, a, c[0], h.strokeWidth() * l, b.horiz, t),
          opacity: g
        }))
      },
      renderLabel: function(a, g, l, b) {
        var e = this.axis,
          t = e.horiz,
          n = e.options,
          f = this.label,
          c = n.labels,
          h = c.step,
          e = e.tickmarkOffset,
          w = !0,
          D = a.x;
        a = a.y;
        f && m(D) && (f.xy = a = this.getLabelPosition(D, a, f, t, c, e,
          b, h), this.isFirst && !this.isLast && !v(n.showFirstLabel, 1) || this.isLast && !this.isFirst && !v(n.showLastLabel, 1) ? w = !1 : !t || c.step || c.rotation || g || 0 === l || this.handleOverflow(a), h && b % h && (w = !1), w && m(a.y) ? (a.opacity = l, f[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (f.attr("y", -9999), this.isNewLabel = !0))
      },
      render: function(g, m, l) {
        var b = this.axis,
          e = b.horiz,
          t = this.getPosition(e, this.pos, b.tickmarkOffset, m),
          n = t.x,
          f = t.y,
          b = e && n === b.pos + b.len || !e && f === b.pos ? -1 : 1;
        l = v(l, 1);
        this.isActive = !0;
        this.renderGridLine(m,
          l, b);
        this.renderMark(t, l, b);
        this.renderLabel(t, m, l, g);
        this.isNew = !1;
        a.fireEvent(this, "afterRender")
      },
      destroy: function() {
        G(this, this.axis)
      }
    }
  })(L);
  var da = function(a) {
    var B = a.addEvent,
      C = a.animObject,
      G = a.arrayMax,
      p = a.arrayMin,
      m = a.color,
      g = a.correctFloat,
      v = a.defaultOptions,
      z = a.defined,
      u = a.deg2rad,
      y = a.destroyObjectProperties,
      l = a.each,
      b = a.extend,
      e = a.fireEvent,
      t = a.format,
      n = a.getMagnitude,
      f = a.grep,
      c = a.inArray,
      h = a.isArray,
      w = a.isNumber,
      D = a.isString,
      r = a.merge,
      J = a.normalizeTickInterval,
      q = a.objectEach,
      F = a.pick,
      x = a.removeEvent,
      K = a.splat,
      d = a.syncTimeout,
      H = a.Tick,
      E = function() {
        this.init.apply(this, arguments)
      };
    a.extend(E.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: "%H:%M:%S.%L",
          second: "%H:%M:%S",
          minute: "%H:%M",
          hour: "%H:%M",
          day: "%e. %b",
          week: "%e. %b",
          month: "%b '%y",
          year: "%Y"
        },
        endOnTick: !1,
        labels: {
          enabled: !0,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          },
          x: 0
        },
        maxPadding: .01,
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickmarkPlacement: "between",
        tickPixelInterval: 100,
        tickPosition: "outside",
        title: {
          align: "middle",
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        tickColor: "#ccd6eb"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        maxPadding: .05,
        minPadding: .05,
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          allowOverlap: !1,
          enabled: !1,
          formatter: function() {
            return a.numberFormat(this.total,
              -1)
          },
          style: {
            fontSize: "11px",
            fontWeight: "bold",
            color: "#000000",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      init: function(a, d) {
        var k = d.isX,
          b = this;
        b.chart = a;
        b.horiz = a.inverted && !b.isZAxis ? !k : k;
        b.isXAxis = k;
        b.coll = b.coll ||
          (k ? "xAxis" : "yAxis");
        e(this, "init", {
          userOptions: d
        });
        b.opposite = d.opposite;
        b.side = d.side || (b.horiz ? b.opposite ? 0 : 2 : b.opposite ? 1 : 3);
        b.setOptions(d);
        var A = this.options,
          f = A.type;
        b.labelFormatter = A.labels.formatter || b.defaultLabelFormatter;
        b.userOptions = d;
        b.minPixelPadding = 0;
        b.reversed = A.reversed;
        b.visible = !1 !== A.visible;
        b.zoomEnabled = !1 !== A.zoomEnabled;
        b.hasNames = "category" === f || !0 === A.categories;
        b.categories = A.categories || b.hasNames;
        b.names || (b.names = [], b.names.keys = {});
        b.plotLinesAndBandsGroups = {};
        b.isLog =
          "logarithmic" === f;
        b.isDatetimeAxis = "datetime" === f;
        b.positiveValuesOnly = b.isLog && !b.allowNegativeLog;
        b.isLinked = z(A.linkedTo);
        b.ticks = {};
        b.labelEdge = [];
        b.minorTicks = {};
        b.plotLinesAndBands = [];
        b.alternateBands = {};
        b.len = 0;
        b.minRange = b.userMinRange = A.minRange || A.maxZoom;
        b.range = A.range;
        b.offset = A.offset || 0;
        b.stacks = {};
        b.oldStacks = {};
        b.stacksTouched = 0;
        b.max = null;
        b.min = null;
        b.crosshair = F(A.crosshair, K(a.options.tooltip.crosshairs)[k ? 0 : 1], !1);
        d = b.options.events; - 1 === c(b, a.axes) && (k ? a.axes.splice(a.xAxis.length,
          0, b) : a.axes.push(b), a[b.coll].push(b));
        b.series = b.series || [];
        a.inverted && !b.isZAxis && k && void 0 === b.reversed && (b.reversed = !0);
        q(d, function(a, k) {
          B(b, k, a)
        });
        b.lin2log = A.linearToLogConverter || b.lin2log;
        b.isLog && (b.val2lin = b.log2lin, b.lin2val = b.lin2log);
        e(this, "afterInit")
      },
      setOptions: function(a) {
        this.options = r(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
          r(v[this.coll], a));
        e(this, "afterSetOptions", {
          userOptions: a
        })
      },
      defaultLabelFormatter: function() {
        var k = this.axis,
          d = this.value,
          b = k.chart.time,
          c = k.categories,
          f = this.dateTimeLabelFormat,
          h = v.lang,
          x = h.numericSymbols,
          h = h.numericSymbolMagnitude || 1E3,
          e = x && x.length,
          r, n = k.options.labels.format,
          k = k.isLog ? Math.abs(d) : k.tickInterval;
        if (n) r = t(n, this, b);
        else if (c) r = d;
        else if (f) r = b.dateFormat(f, d);
        else if (e && 1E3 <= k)
          for (; e-- && void 0 === r;) b = Math.pow(h, e + 1), k >= b && 0 === 10 * d % b && null !== x[e] && 0 !== d && (r = a.numberFormat(d / b,
            -1) + x[e]);
        void 0 === r && (r = 1E4 <= Math.abs(d) ? a.numberFormat(d, -1) : a.numberFormat(d, -1, void 0, ""));
        return r
      },
      getSeriesExtremes: function() {
        var a = this,
          d = a.chart;
        e(this, "getSeriesExtremes", null, function() {
          a.hasVisibleSeries = !1;
          a.dataMin = a.dataMax = a.threshold = null;
          a.softThreshold = !a.isXAxis;
          a.buildStacks && a.buildStacks();
          l(a.series, function(k) {
            if (k.visible || !d.options.chart.ignoreHiddenSeries) {
              var b = k.options,
                A = b.threshold,
                c;
              a.hasVisibleSeries = !0;
              a.positiveValuesOnly && 0 >= A && (A = null);
              if (a.isXAxis) b = k.xData,
                b.length && (k = p(b), c = G(b), w(k) || k instanceof Date || (b = f(b, w), k = p(b), c = G(b)), b.length && (a.dataMin = Math.min(F(a.dataMin, b[0], k), k), a.dataMax = Math.max(F(a.dataMax, b[0], c), c)));
              else if (k.getExtremes(), c = k.dataMax, k = k.dataMin, z(k) && z(c) && (a.dataMin = Math.min(F(a.dataMin, k), k), a.dataMax = Math.max(F(a.dataMax, c), c)), z(A) && (a.threshold = A), !b.softThreshold || a.positiveValuesOnly) a.softThreshold = !1
            }
          })
        });
        e(this, "afterGetSeriesExtremes")
      },
      translate: function(a, d, b, c, f, h) {
        var k = this.linkedParent || this,
          A = 1,
          x = 0,
          I = c ?
          k.oldTransA : k.transA;
        c = c ? k.oldMin : k.min;
        var e = k.minPixelPadding;
        f = (k.isOrdinal || k.isBroken || k.isLog && f) && k.lin2val;
        I || (I = k.transA);
        b && (A *= -1, x = k.len);
        k.reversed && (A *= -1, x -= A * (k.sector || k.len));
        d ? (a = (a * A + x - e) / I + c, f && (a = k.lin2val(a))) : (f && (a = k.val2lin(a)), a = w(c) ? A * (a - c) * I + x + A * e + (w(h) ? I * h : 0) : void 0);
        return a
      },
      toPixels: function(a, d) {
        return this.translate(a, !1, !this.horiz, null, !0) + (d ? 0 : this.pos)
      },
      toValue: function(a, d) {
        return this.translate(a - (d ? 0 : this.pos), !0, !this.horiz, null, !0)
      },
      getPlotLinePath: function(a,
        d, b, c, f) {
        var k = this.chart,
          A = this.left,
          h = this.top,
          x, I, e = b && k.oldChartHeight || k.chartHeight,
          r = b && k.oldChartWidth || k.chartWidth,
          n;
        x = this.transB;
        var q = function(a, k, d) {
          if (a < k || a > d) c ? a = Math.min(Math.max(k, a), d) : n = !0;
          return a
        };
        f = F(f, this.translate(a, null, null, b));
        f = Math.min(Math.max(-1E5, f), 1E5);
        a = b = Math.round(f + x);
        x = I = Math.round(e - f - x);
        w(f) ? this.horiz ? (x = h, I = e - this.bottom, a = b = q(a, A, A + this.width)) : (a = A, b = r - this.right, x = I = q(x, h, h + this.height)) : (n = !0, c = !1);
        return n && !c ? null : k.renderer.crispLine(["M", a, x, "L",
          b, I
        ], d || 1)
      },
      getLinearTickPositions: function(a, d, b) {
        var k, A = g(Math.floor(d / a) * a);
        b = g(Math.ceil(b / a) * a);
        var c = [],
          f;
        g(A + a) === A && (f = 20);
        if (this.single) return [d];
        for (d = A; d <= b;) {
          c.push(d);
          d = g(d + a, f);
          if (d === k) break;
          k = d
        }
        return c
      },
      getMinorTickInterval: function() {
        var a = this.options;
        return !0 === a.minorTicks ? F(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval
      },
      getMinorTickPositions: function() {
        var a = this,
          d = a.options,
          b = a.tickPositions,
          c = a.minorTickInterval,
          f = [],
          h = a.pointRangePadding || 0,
          x = a.min -
          h,
          h = a.max + h,
          e = h - x;
        if (e && e / c < a.len / 3)
          if (a.isLog) l(this.paddedTicks, function(k, d, b) {
            d && f.push.apply(f, a.getLogTickPositions(c, b[d - 1], b[d], !0))
          });
          else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) f = f.concat(a.getTimeTicks(a.normalizeTimeTickInterval(c), x, h, d.startOfWeek));
        else
          for (d = x + (b[0] - x) % c; d <= h && d !== f[0]; d += c) f.push(d);
        0 !== f.length && a.trimTicks(f);
        return f
      },
      adjustForMinRange: function() {
        var a = this.options,
          d = this.min,
          b = this.max,
          c, f, h, x, e, r, n, q;
        this.isXAxis && void 0 === this.minRange && !this.isLog &&
          (z(a.min) || z(a.max) ? this.minRange = null : (l(this.series, function(a) {
            r = a.xData;
            for (x = n = a.xIncrement ? 1 : r.length - 1; 0 < x; x--)
              if (e = r[x] - r[x - 1], void 0 === h || e < h) h = e
          }), this.minRange = Math.min(5 * h, this.dataMax - this.dataMin)));
        b - d < this.minRange && (f = this.dataMax - this.dataMin >= this.minRange, q = this.minRange, c = (q - b + d) / 2, c = [d - c, F(a.min, d - c)], f && (c[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), d = G(c), b = [d + q, F(a.max, d + q)], f && (b[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b = p(b), b - d < q && (c[0] = b - q, c[1] =
          F(a.min, b - q), d = G(c)));
        this.min = d;
        this.max = b
      },
      getClosest: function() {
        var a;
        this.categories ? a = 1 : l(this.series, function(k) {
          var d = k.closestPointRange,
            b = k.visible || !k.chart.options.chart.ignoreHiddenSeries;
          !k.noSharedTooltip && z(d) && b && (a = z(a) ? Math.min(a, d) : d)
        });
        return a
      },
      nameToX: function(a) {
        var k = h(this.categories),
          d = k ? this.categories : this.names,
          b = a.options.x,
          f;
        a.series.requireSorting = !1;
        z(b) || (b = !1 === this.options.uniqueNames ? a.series.autoIncrement() : k ? c(a.name, d) : F(d.keys[a.name], -1)); - 1 === b ? k || (f = d.length) :
          f = b;
        void 0 !== f && (this.names[f] = a.name, this.names.keys[a.name] = f);
        return f
      },
      updateNames: function() {
        var k = this,
          d = this.names;
        0 < d.length && (l(a.keys(d.keys), function(a) {
          delete d.keys[a]
        }), d.length = 0, this.minRange = this.userMinRange, l(this.series || [], function(a) {
          a.xIncrement = null;
          if (!a.points || a.isDirtyData) a.processData(), a.generatePoints();
          l(a.points, function(d, b) {
            var c;
            d.options && (c = k.nameToX(d), void 0 !== c && c !== d.x && (d.x = c, a.xData[b] = c))
          })
        }))
      },
      setAxisTranslation: function(a) {
        var k = this,
          d = k.max - k.min,
          b =
          k.axisPointRange || 0,
          c, f = 0,
          h = 0,
          x = k.linkedParent,
          r = !!k.categories,
          n = k.transA,
          q = k.isXAxis;
        if (q || r || b) c = k.getClosest(), x ? (f = x.minPointOffset, h = x.pointRangePadding) : l(k.series, function(a) {
          var d = r ? 1 : q ? F(a.options.pointRange, c, 0) : k.axisPointRange || 0;
          a = a.options.pointPlacement;
          b = Math.max(b, d);
          k.single || (f = Math.max(f, D(a) ? 0 : d / 2), h = Math.max(h, "on" === a ? 0 : d))
        }), x = k.ordinalSlope && c ? k.ordinalSlope / c : 1, k.minPointOffset = f *= x, k.pointRangePadding = h *= x, k.pointRange = Math.min(b, d), q && (k.closestPointRange = c);
        a && (k.oldTransA =
          n);
        k.translationSlope = k.transA = n = k.options.staticScale || k.len / (d + h || 1);
        k.transB = k.horiz ? k.left : k.bottom;
        k.minPixelPadding = n * f;
        e(this, "afterSetAxisTranslation")
      },
      minFromRange: function() {
        return this.max - this.range
      },
      setTickInterval: function(k) {
        var d = this,
          b = d.chart,
          c = d.options,
          f = d.isLog,
          h = d.isDatetimeAxis,
          x = d.isXAxis,
          r = d.isLinked,
          q = c.maxPadding,
          E = c.minPadding,
          D = c.tickInterval,
          H = c.tickPixelInterval,
          t = d.categories,
          K = w(d.threshold) ? d.threshold : null,
          m = d.softThreshold,
          y, v, u, p;
        h || t || r || this.getTickAmount();
        u = F(d.userMin, c.min);
        p = F(d.userMax, c.max);
        r ? (d.linkedParent = b[d.coll][c.linkedTo], b = d.linkedParent.getExtremes(), d.min = F(b.min, b.dataMin), d.max = F(b.max, b.dataMax), c.type !== d.linkedParent.options.type && a.error(11, 1)) : (!m && z(K) && (d.dataMin >= K ? (y = K, E = 0) : d.dataMax <= K && (v = K, q = 0)), d.min = F(u, y, d.dataMin), d.max = F(p, v, d.dataMax));
        f && (d.positiveValuesOnly && !k && 0 >= Math.min(d.min, F(d.dataMin, d.min)) && a.error(10, 1), d.min = g(d.log2lin(d.min), 15), d.max = g(d.log2lin(d.max), 15));
        d.range && z(d.max) && (d.userMin = d.min =
          u = Math.max(d.dataMin, d.minFromRange()), d.userMax = p = d.max, d.range = null);
        e(d, "foundExtremes");
        d.beforePadding && d.beforePadding();
        d.adjustForMinRange();
        !(t || d.axisPointRange || d.usePercentage || r) && z(d.min) && z(d.max) && (b = d.max - d.min) && (!z(u) && E && (d.min -= b * E), !z(p) && q && (d.max += b * q));
        w(c.softMin) && !w(d.userMin) && (d.min = Math.min(d.min, c.softMin));
        w(c.softMax) && !w(d.userMax) && (d.max = Math.max(d.max, c.softMax));
        w(c.floor) && (d.min = Math.max(d.min, c.floor));
        w(c.ceiling) && (d.max = Math.min(d.max, c.ceiling));
        m && z(d.dataMin) &&
          (K = K || 0, !z(u) && d.min < K && d.dataMin >= K ? d.min = K : !z(p) && d.max > K && d.dataMax <= K && (d.max = K));
        d.tickInterval = d.min === d.max || void 0 === d.min || void 0 === d.max ? 1 : r && !D && H === d.linkedParent.options.tickPixelInterval ? D = d.linkedParent.tickInterval : F(D, this.tickAmount ? (d.max - d.min) / Math.max(this.tickAmount - 1, 1) : void 0, t ? 1 : (d.max - d.min) * H / Math.max(d.len, H));
        x && !k && l(d.series, function(a) {
          a.processData(d.min !== d.oldMin || d.max !== d.oldMax)
        });
        d.setAxisTranslation(!0);
        d.beforeSetTickPositions && d.beforeSetTickPositions();
        d.postProcessTickInterval && (d.tickInterval = d.postProcessTickInterval(d.tickInterval));
        d.pointRange && !D && (d.tickInterval = Math.max(d.pointRange, d.tickInterval));
        k = F(c.minTickInterval, d.isDatetimeAxis && d.closestPointRange);
        !D && d.tickInterval < k && (d.tickInterval = k);
        h || f || D || (d.tickInterval = J(d.tickInterval, null, n(d.tickInterval), F(c.allowDecimals, !(.5 < d.tickInterval && 5 > d.tickInterval && 1E3 < d.max && 9999 > d.max)), !!this.tickAmount));
        this.tickAmount || (d.tickInterval = d.unsquish());
        this.setTickPositions()
      },
      setTickPositions: function() {
        var a =
          this.options,
          d, b = a.tickPositions;
        d = this.getMinorTickInterval();
        var c = a.tickPositioner,
          f = a.startOnTick,
          h = a.endOnTick;
        this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === d && this.tickInterval ? this.tickInterval / 5 : d;
        this.single = this.min === this.max && z(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
        this.tickPositions = d = b && b.slice();
        !d && (d = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,
          a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), d.length > this.len && (d = [d[0], d.pop()], d[0] === d[1] && (d.length = 1)), this.tickPositions = d, c && (c = c.apply(this, [this.min, this.max]))) && (this.tickPositions = d = c);
        this.paddedTicks = d.slice(0);
        this.trimTicks(d, f, h);
        this.isLinked || (this.single && 2 > d.length && (this.min -= .5, this.max += .5), b ||
          c || this.adjustTickAmount());
        e(this, "afterSetTickPositions")
      },
      trimTicks: function(a, d, b) {
        var k = a[0],
          c = a[a.length - 1],
          f = this.minPointOffset || 0;
        if (!this.isLinked) {
          if (d && -Infinity !== k) this.min = k;
          else
            for (; this.min - f > a[0];) a.shift();
          if (b) this.max = c;
          else
            for (; this.max + f < a[a.length - 1];) a.pop();
          0 === a.length && z(k) && !this.options.tickPositions && a.push((c + k) / 2)
        }
      },
      alignToOthers: function() {
        var a = {},
          d, b = this.options;
        !1 === this.chart.options.chart.alignTicks || !1 === b.alignTicks || !1 === b.startOnTick || !1 === b.endOnTick ||
          this.isLog || l(this.chart[this.coll], function(k) {
            var b = k.options,
              b = [k.horiz ? b.left : b.top, b.width, b.height, b.pane].join();
            k.series.length && (a[b] ? d = !0 : a[b] = 1)
          });
        return d
      },
      getTickAmount: function() {
        var a = this.options,
          d = a.tickAmount,
          b = a.tickPixelInterval;
        !z(a.tickInterval) && this.len < b && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (d = 2);
        !d && this.alignToOthers() && (d = Math.ceil(this.len / b) + 1);
        4 > d && (this.finalTickAmt = d, d = 5);
        this.tickAmount = d
      },
      adjustTickAmount: function() {
        var a = this.tickInterval,
          d =
          this.tickPositions,
          b = this.tickAmount,
          c = this.finalTickAmt,
          f = d && d.length,
          h = F(this.threshold, this.softThreshold ? 0 : null);
        if (this.hasData()) {
          if (f < b) {
            for (; d.length < b;) d.length % 2 || this.min === h ? d.push(g(d[d.length - 1] + a)) : d.unshift(g(d[0] - a));
            this.transA *= (f - 1) / (b - 1);
            this.min = d[0];
            this.max = d[d.length - 1]
          } else f > b && (this.tickInterval *= 2, this.setTickPositions());
          if (z(c)) {
            for (a = b = d.length; a--;)(3 === c && 1 === a % 2 || 2 >= c && 0 < a && a < b - 1) && d.splice(a, 1);
            this.finalTickAmt = void 0
          }
        }
      },
      setScale: function() {
        var a, d;
        this.oldMin =
          this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        d = this.len !== this.oldAxisLength;
        l(this.series, function(d) {
          if (d.isDirtyData || d.isDirty || d.xAxis.isDirty) a = !0
        });
        d || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty =
          d || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
        e(this, "afterSetScale")
      },
      setExtremes: function(a, d, c, f, h) {
        var k = this,
          x = k.chart;
        c = F(c, !0);
        l(k.series, function(a) {
          delete a.kdTree
        });
        h = b(h, {
          min: a,
          max: d
        });
        e(k, "setExtremes", h, function() {
          k.userMin = a;
          k.userMax = d;
          k.eventArgs = h;
          c && x.redraw(f)
        })
      },
      zoom: function(a, d) {
        var k = this.dataMin,
          b = this.dataMax,
          c = this.options,
          f = Math.min(k, F(c.min, k)),
          c = Math.max(b, F(c.max, b));
        if (a !== this.min || d !== this.max) this.allowZoomOutside || (z(k) &&
          (a < f && (a = f), a > c && (a = c)), z(b) && (d < f && (d = f), d > c && (d = c))), this.displayBtn = void 0 !== a || void 0 !== d, this.setExtremes(a, d, !1, void 0, {
          trigger: "zoom"
        });
        return !0
      },
      setAxisSize: function() {
        var d = this.chart,
          b = this.options,
          c = b.offsets || [0, 0, 0, 0],
          f = this.horiz,
          h = this.width = Math.round(a.relativeLength(F(b.width, d.plotWidth - c[3] + c[1]), d.plotWidth)),
          x = this.height = Math.round(a.relativeLength(F(b.height, d.plotHeight - c[0] + c[2]), d.plotHeight)),
          e = this.top = Math.round(a.relativeLength(F(b.top, d.plotTop + c[0]), d.plotHeight, d.plotTop)),
          b = this.left = Math.round(a.relativeLength(F(b.left, d.plotLeft + c[3]), d.plotWidth, d.plotLeft));
        this.bottom = d.chartHeight - x - e;
        this.right = d.chartWidth - h - b;
        this.len = Math.max(f ? h : x, 0);
        this.pos = f ? b : e
      },
      getExtremes: function() {
        var a = this.isLog;
        return {
          min: a ? g(this.lin2log(this.min)) : this.min,
          max: a ? g(this.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        }
      },
      getThreshold: function(a) {
        var d = this.isLog,
          k = d ? this.lin2log(this.min) : this.min,
          d = d ? this.lin2log(this.max) :
          this.max;
        null === a || -Infinity === a ? a = k : Infinity === a ? a = d : k > a ? a = k : d < a && (a = d);
        return this.translate(a, 0, 1, 0, 1)
      },
      autoLabelAlign: function(a) {
        a = (F(a, 0) - 90 * this.side + 720) % 360;
        return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center"
      },
      tickSize: function(a) {
        var d = this.options,
          k = d[a + "Length"],
          b = F(d[a + "Width"], "tick" === a && this.isXAxis ? 1 : 0);
        if (b && k) return "inside" === d[a + "Position"] && (k = -k), [k, b]
      },
      labelMetrics: function() {
        var a = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style &&
          this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label)
      },
      unsquish: function() {
        var a = this.options.labels,
          d = this.horiz,
          b = this.tickInterval,
          c = b,
          f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / b),
          h, x = a.rotation,
          e = this.labelMetrics(),
          r, q = Number.MAX_VALUE,
          n, w = function(a) {
            a /= f || 1;
            a = 1 < a ? Math.ceil(a) : 1;
            return g(a * b)
          };
        d ? (n = !a.staggerLines && !a.step && (z(x) ? [x] : f < F(a.autoRotationLimit, 80) && a.autoRotation)) && l(n, function(a) {
          var d;
          if (a === x || a && -90 <= a && 90 >= a) r = w(Math.abs(e.h / Math.sin(u * a))), d =
            r + Math.abs(a / 360), d < q && (q = d, h = a, c = r)
        }) : a.step || (c = w(e.h));
        this.autoRotation = n;
        this.labelRotation = F(h, x);
        return c
      },
      getSlotWidth: function() {
        var a = this.chart,
          d = this.horiz,
          b = this.options.labels,
          c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          f = a.margin[3];
        return d && 2 > (b.step || 0) && !b.rotation && (this.staggerLines || 1) * this.len / c || !d && (b.style && parseInt(b.style.width, 10) || f && f - a.spacing[3] || .33 * a.chartWidth)
      },
      renderUnsquish: function() {
        var a = this.chart,
          d = a.renderer,
          b = this.tickPositions,
          c = this.ticks,
          f = this.options.labels,
          h = this.horiz,
          x = this.getSlotWidth(),
          e = Math.max(1, Math.round(x - 2 * (f.padding || 5))),
          r = {},
          q = this.labelMetrics(),
          n = f.style && f.style.textOverflow,
          w, E, H = 0,
          t;
        D(f.rotation) || (r.rotation = f.rotation || 0);
        l(b, function(a) {
          (a = c[a]) && a.label && a.label.textPxLength > H && (H = a.label.textPxLength)
        });
        this.maxLabelLength = H;
        if (this.autoRotation) H > e && H > q.h ? r.rotation = this.labelRotation : this.labelRotation = 0;
        else if (x && (w = e, !n))
          for (E = "clip", e = b.length; !h && e--;)
            if (t = b[e], t = c[t].label) t.styles && "ellipsis" ===
              t.styles.textOverflow ? t.css({
                textOverflow: "clip"
              }) : t.textPxLength > x && t.css({
                width: x + "px"
              }), t.getBBox().height > this.len / b.length - (q.h - q.f) && (t.specificTextOverflow = "ellipsis");
        r.rotation && (w = H > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight, n || (E = "ellipsis"));
        if (this.labelAlign = f.align || this.autoLabelAlign(this.labelRotation)) r.align = this.labelAlign;
        l(b, function(a) {
          var d = (a = c[a]) && a.label,
            b = {};
          d && (d.attr(r), !w || f.style && f.style.width || !(w < d.textPxLength || "SPAN" === d.element.tagName) || (b.width = w, n ||
            (b.textOverflow = d.specificTextOverflow || E), d.css(b)), delete d.specificTextOverflow, a.rotation = r.rotation)
        });
        this.tickRotCorr = d.rotCorr(q.b, this.labelRotation || 0, 0 !== this.side)
      },
      hasData: function() {
        return this.hasVisibleSeries || z(this.min) && z(this.max) && this.tickPositions && 0 < this.tickPositions.length
      },
      addTitle: function(a) {
        var d = this.chart.renderer,
          b = this.horiz,
          k = this.opposite,
          c = this.options.title,
          f;
        this.axisTitle || ((f = c.textAlign) || (f = (b ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: k ? "right" : "left",
          middle: "center",
          high: k ? "left" : "right"
        })[c.align]), this.axisTitle = d.text(c.text, 0, 0, c.useHTML).attr({
          zIndex: 7,
          rotation: c.rotation || 0,
          align: f
        }).addClass("highcharts-axis-title").css(r(c.style)).add(this.axisGroup), this.axisTitle.isNew = !0);
        c.style.width || this.isRadial || this.axisTitle.css({
          width: this.len
        });
        this.axisTitle[a ? "show" : "hide"](!0)
      },
      generateTick: function(a) {
        var d = this.ticks;
        d[a] ? d[a].addLabel() : d[a] = new H(this, a)
      },
      getOffset: function() {
        var a = this,
          d = a.chart,
          b = d.renderer,
          c = a.options,
          f = a.tickPositions,
          h = a.ticks,
          x = a.horiz,
          e = a.side,
          r = d.inverted && !a.isZAxis ? [1, 0, 3, 2][e] : e,
          n, w, E = 0,
          D, H = 0,
          t = c.title,
          K = c.labels,
          g = 0,
          J = d.axisOffset,
          d = d.clipOffset,
          m = [-1, 1, 1, -1][e],
          y = c.className,
          v = a.axisParent,
          u = this.tickSize("tick");
        n = a.hasData();
        a.showAxis = w = n || F(c.showEmpty, !0);
        a.staggerLines = a.horiz && K.staggerLines;
        a.axisGroup || (a.gridGroup = b.g("grid").attr({
          zIndex: c.gridZIndex || 1
        }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (y || "")).add(v), a.axisGroup = b.g("axis").attr({
          zIndex: c.zIndex || 2
        }).addClass("highcharts-" +
          this.coll.toLowerCase() + " " + (y || "")).add(v), a.labelGroup = b.g("axis-labels").attr({
          zIndex: K.zIndex || 7
        }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (y || "")).add(v));
        n || a.isLinked ? (l(f, function(d, b) {
            a.generateTick(d, b)
          }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === e || 2 === e || {
            1: "left",
            3: "right"
          } [e] === a.labelAlign, F(K.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && l(f, function(a) {
            g = Math.max(h[a].getLabelSize(), g)
          }), a.staggerLines && (g *= a.staggerLines), a.labelOffset = g *
          (a.opposite ? -1 : 1)) : q(h, function(a, d) {
          a.destroy();
          delete h[d]
        });
        t && t.text && !1 !== t.enabled && (a.addTitle(w), w && !1 !== t.reserveSpace && (a.titleOffset = E = a.axisTitle.getBBox()[x ? "height" : "width"], D = t.offset, H = z(D) ? 0 : F(t.margin, x ? 5 : 10)));
        a.renderLine();
        a.offset = m * F(c.offset, J[e]);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        b = 0 === e ? -a.labelMetrics().h : 2 === e ? a.tickRotCorr.y : 0;
        H = Math.abs(g) + H;
        g && (H = H - b + m * (x ? F(K.y, a.tickRotCorr.y + 8 * m) : K.x));
        a.axisTitleMargin = F(D, H);
        J[e] = Math.max(J[e], a.axisTitleMargin + E + m * a.offset,
          H, n && f.length && u ? u[0] + m * a.offset : 0);
        c = c.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
        d[r] = Math.max(d[r], c)
      },
      getLinePath: function(a) {
        var d = this.chart,
          b = this.opposite,
          k = this.offset,
          c = this.horiz,
          f = this.left + (b ? this.width : 0) + k,
          k = d.chartHeight - this.bottom - (b ? this.height : 0) + k;
        b && (a *= -1);
        return d.renderer.crispLine(["M", c ? this.left : f, c ? k : this.top, "L", c ? d.chartWidth - this.right : f, c ? k : d.chartHeight - this.bottom], a)
      },
      renderLine: function() {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),
          this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          }))
      },
      getTitlePosition: function() {
        var a = this.horiz,
          d = this.left,
          b = this.top,
          c = this.len,
          f = this.options.title,
          h = a ? d : b,
          x = this.opposite,
          e = this.offset,
          r = f.x || 0,
          n = f.y || 0,
          q = this.axisTitle,
          w = this.chart.renderer.fontMetrics(f.style && f.style.fontSize, q),
          q = Math.max(q.getBBox(null, 0).height - w.h - 1, 0),
          c = {
            low: h + (a ? 0 : c),
            middle: h + c / 2,
            high: h + (a ? c : 0)
          } [f.align],
          d = (a ? b + this.height : d) + (a ? 1 : -1) * (x ? -1 : 1) * this.axisTitleMargin + [-q,
            q, w.f, -q
          ][this.side];
        return {
          x: a ? c + r : d + (x ? this.width : 0) + e + r,
          y: a ? d + n - (x ? this.height : 0) + e : c + n
        }
      },
      renderMinorTick: function(a) {
        var d = this.chart.hasRendered && w(this.oldMin),
          b = this.minorTicks;
        b[a] || (b[a] = new H(this, a, "minor"));
        d && b[a].isNew && b[a].render(null, !0);
        b[a].render(null, !1, 1)
      },
      renderTick: function(a, d) {
        var b = this.isLinked,
          k = this.ticks,
          c = this.chart.hasRendered && w(this.oldMin);
        if (!b || a >= this.min && a <= this.max) k[a] || (k[a] = new H(this, a)), c && k[a].isNew && k[a].render(d, !0, .1), k[a].render(d)
      },
      render: function() {
        var b =
          this,
          c = b.chart,
          f = b.options,
          h = b.isLog,
          x = b.isLinked,
          r = b.tickPositions,
          n = b.axisTitle,
          E = b.ticks,
          D = b.minorTicks,
          t = b.alternateBands,
          K = f.stackLabels,
          F = f.alternateGridColor,
          g = b.tickmarkOffset,
          J = b.axisLine,
          m = b.showAxis,
          y = C(c.renderer.globalAnimation),
          v, u;
        b.labelEdge.length = 0;
        b.overlap = !1;
        l([E, D, t], function(a) {
          q(a, function(a) {
            a.isActive = !1
          })
        });
        if (b.hasData() || x) b.minorTickInterval && !b.categories && l(b.getMinorTickPositions(), function(a) {
          b.renderMinorTick(a)
        }), r.length && (l(r, function(a, d) {
            b.renderTick(a, d)
          }),
          g && (0 === b.min || b.single) && (E[-1] || (E[-1] = new H(b, -1, null, !0)), E[-1].render(-1))), F && l(r, function(d, k) {
          u = void 0 !== r[k + 1] ? r[k + 1] + g : b.max - g;
          0 === k % 2 && d < b.max && u <= b.max + (c.polar ? -g : g) && (t[d] || (t[d] = new a.PlotLineOrBand(b)), v = d + g, t[d].options = {
            from: h ? b.lin2log(v) : v,
            to: h ? b.lin2log(u) : u,
            color: F
          }, t[d].render(), t[d].isActive = !0)
        }), b._addedPlotLB || (l((f.plotLines || []).concat(f.plotBands || []), function(a) {
          b.addPlotBandOrLine(a)
        }), b._addedPlotLB = !0);
        l([E, D, t], function(a) {
          var b, k = [],
            f = y.duration;
          q(a, function(a,
            d) {
            a.isActive || (a.render(d, !1, 0), a.isActive = !1, k.push(d))
          });
          d(function() {
            for (b = k.length; b--;) a[k[b]] && !a[k[b]].isActive && (a[k[b]].destroy(), delete a[k[b]])
          }, a !== t && c.hasRendered && f ? f : 0)
        });
        J && (J[J.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(J.strokeWidth())
        }), J.isPlaced = !0, J[m ? "show" : "hide"](!0));
        n && m && (f = b.getTitlePosition(), w(f.y) ? (n[n.isNew ? "attr" : "animate"](f), n.isNew = !1) : (n.attr("y", -9999), n.isNew = !0));
        K && K.enabled && b.renderStackTotals();
        b.isDirty = !1;
        e(this, "afterRender")
      },
      redraw: function() {
        this.visible &&
          (this.render(), l(this.plotLinesAndBands, function(a) {
            a.render()
          }));
        l(this.series, function(a) {
          a.isDirty = !0
        })
      },
      keepProps: "extKey hcEvents names series userMax userMin".split(" "),
      destroy: function(a) {
        var d = this,
          b = d.stacks,
          k = d.plotLinesAndBands,
          f;
        e(this, "destroy", {
          keepEvents: a
        });
        a || x(d);
        q(b, function(a, d) {
          y(a);
          b[d] = null
        });
        l([d.ticks, d.minorTicks, d.alternateBands], function(a) {
          y(a)
        });
        if (k)
          for (a = k.length; a--;) k[a].destroy();
        l("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),
          function(a) {
            d[a] && (d[a] = d[a].destroy())
          });
        for (f in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[f] = d.plotLinesAndBandsGroups[f].destroy();
        q(d, function(a, b) {
          -1 === c(b, d.keepProps) && delete d[b]
        })
      },
      drawCrosshair: function(a, d) {
        var b, c = this.crosshair,
          k = F(c.snap, !0),
          f, h = this.cross;
        e(this, "drawCrosshair", {
          e: a,
          point: d
        });
        a || (a = this.cross && this.cross.e);
        if (this.crosshair && !1 !== (z(d) || !k)) {
          k ? z(d) && (f = F(d.crosshairPos, this.isXAxis ? d.plotX : this.len - d.plotY)) : f = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY +
            this.pos);
          z(f) && (b = this.getPlotLinePath(d && (this.isXAxis ? d.x : F(d.stackY, d.y)), null, null, null, f) || null);
          if (!z(b)) {
            this.hideCrosshair();
            return
          }
          k = this.categories && !this.isRadial;
          h || (this.cross = h = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (k ? "category " : "thin ") + c.className).attr({
            zIndex: F(c.zIndex, 2)
          }).add(), h.attr({
            stroke: c.color || (k ? m("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": F(c.width, 1)
          }).css({
            "pointer-events": "none"
          }), c.dashStyle && h.attr({
            dashstyle: c.dashStyle
          }));
          h.show().attr({
            d: b
          });
          k && !c.width && h.attr({
            "stroke-width": this.transA
          });
          this.cross.e = a
        } else this.hideCrosshair();
        e(this, "afterDrawCrosshair", {
          e: a,
          point: d
        })
      },
      hideCrosshair: function() {
        this.cross && this.cross.hide()
      }
    });
    return a.Axis = E
  }(L);
  (function(a) {
    var B = a.Axis,
      C = a.getMagnitude,
      G = a.normalizeTickInterval,
      p = a.timeUnits;
    B.prototype.getTimeTicks = function() {
      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments)
    };
    B.prototype.normalizeTimeTickInterval = function(a, g) {
      var m = g || [
        ["millisecond", [1,
          2, 5, 10, 20, 25, 50, 100, 200, 500
        ]],
        ["second", [1, 2, 5, 10, 15, 30]],
        ["minute", [1, 2, 5, 10, 15, 30]],
        ["hour", [1, 2, 3, 4, 6, 8, 12]],
        ["day", [1, 2]],
        ["week", [1, 2]],
        ["month", [1, 2, 3, 4, 6]],
        ["year", null]
      ];
      g = m[m.length - 1];
      var z = p[g[0]],
        u = g[1],
        y;
      for (y = 0; y < m.length && !(g = m[y], z = p[g[0]], u = g[1], m[y + 1] && a <= (z * u[u.length - 1] + p[m[y + 1][0]]) / 2); y++);
      z === p.year && a < 5 * z && (u = [1, 2, 5]);
      a = G(a / z, u, "year" === g[0] ? Math.max(C(a / z), 1) : 1);
      return {
        unitRange: z,
        count: a,
        unitName: g[0]
      }
    }
  })(L);
  (function(a) {
    var B = a.Axis,
      C = a.getMagnitude,
      G = a.map,
      p = a.normalizeTickInterval,
      m = a.pick;
    B.prototype.getLogTickPositions = function(a, v, z, u) {
      var g = this.options,
        l = this.len,
        b = [];
      u || (this._minorAutoInterval = null);
      if (.5 <= a) a = Math.round(a), b = this.getLinearTickPositions(a, v, z);
      else if (.08 <= a)
        for (var l = Math.floor(v), e, t, n, f, c, g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; l < z + 1 && !c; l++)
          for (t = g.length, e = 0; e < t && !c; e++) n = this.log2lin(this.lin2log(l) * g[e]), n > v && (!u || f <= z) && void 0 !== f && b.push(f), f > z && (c = !0), f = n;
      else v = this.lin2log(v), z = this.lin2log(z), a = u ? this.getMinorTickInterval() :
        g.tickInterval, a = m("auto" === a ? null : a, this._minorAutoInterval, g.tickPixelInterval / (u ? 5 : 1) * (z - v) / ((u ? l / this.tickPositions.length : l) || 1)), a = p(a, null, C(a)), b = G(this.getLinearTickPositions(a, v, z), this.log2lin), u || (this._minorAutoInterval = a / 5);
      u || (this.tickInterval = a);
      return b
    };
    B.prototype.log2lin = function(a) {
      return Math.log(a) / Math.LN10
    };
    B.prototype.lin2log = function(a) {
      return Math.pow(10, a)
    }
  })(L);
  (function(a, B) {
    var C = a.arrayMax,
      G = a.arrayMin,
      p = a.defined,
      m = a.destroyObjectProperties,
      g = a.each,
      v = a.erase,
      z =
      a.merge,
      u = a.pick;
    a.PlotLineOrBand = function(a, l) {
      this.axis = a;
      l && (this.options = l, this.id = l.id)
    };
    a.PlotLineOrBand.prototype = {
      render: function() {
        var g = this,
          l = g.axis,
          b = l.horiz,
          e = g.options,
          t = e.label,
          n = g.label,
          f = e.to,
          c = e.from,
          h = e.value,
          w = p(c) && p(f),
          D = p(h),
          r = g.svgElem,
          J = !r,
          q = [],
          F = e.color,
          x = u(e.zIndex, 0),
          K = e.events,
          q = {
            "class": "highcharts-plot-" + (w ? "band " : "line ") + (e.className || "")
          },
          d = {},
          H = l.chart.renderer,
          E = w ? "bands" : "lines";
        l.isLog && (c = l.log2lin(c), f = l.log2lin(f), h = l.log2lin(h));
        D ? (q = {
            stroke: F,
            "stroke-width": e.width
          },
          e.dashStyle && (q.dashstyle = e.dashStyle)) : w && (F && (q.fill = F), e.borderWidth && (q.stroke = e.borderColor, q["stroke-width"] = e.borderWidth));
        d.zIndex = x;
        E += "-" + x;
        (F = l.plotLinesAndBandsGroups[E]) || (l.plotLinesAndBandsGroups[E] = F = H.g("plot-" + E).attr(d).add());
        J && (g.svgElem = r = H.path().attr(q).add(F));
        if (D) q = l.getPlotLinePath(h, r.strokeWidth());
        else if (w) q = l.getPlotBandPath(c, f, e);
        else return;
        J && q && q.length ? (r.attr({
          d: q
        }), K && a.objectEach(K, function(a, d) {
          r.on(d, function(a) {
            K[d].apply(g, [a])
          })
        })) : r && (q ? (r.show(),
          r.animate({
            d: q
          })) : (r.hide(), n && (g.label = n = n.destroy())));
        t && p(t.text) && q && q.length && 0 < l.width && 0 < l.height && !q.flat ? (t = z({
          align: b && w && "center",
          x: b ? !w && 4 : 10,
          verticalAlign: !b && w && "middle",
          y: b ? w ? 16 : 10 : w ? 6 : -4,
          rotation: b && !w && 90
        }, t), this.renderLabel(t, q, w, x)) : n && n.hide();
        return g
      },
      renderLabel: function(a, l, b, e) {
        var t = this.label,
          n = this.axis.chart.renderer;
        t || (t = {
            align: a.textAlign || a.align,
            rotation: a.rotation,
            "class": "highcharts-plot-" + (b ? "band" : "line") + "-label " + (a.className || "")
          }, t.zIndex = e, this.label = t =
          n.text(a.text, 0, 0, a.useHTML).attr(t).add(), t.css(a.style));
        e = l.xBounds || [l[1], l[4], b ? l[6] : l[1]];
        l = l.yBounds || [l[2], l[5], b ? l[7] : l[2]];
        b = G(e);
        n = G(l);
        t.align(a, !1, {
          x: b,
          y: n,
          width: C(e) - b,
          height: C(l) - n
        });
        t.show()
      },
      destroy: function() {
        v(this.axis.plotLinesAndBands, this);
        delete this.axis;
        m(this)
      }
    };
    a.extend(B.prototype, {
      getPlotBandPath: function(a, l) {
        var b = this.getPlotLinePath(l, null, null, !0),
          e = this.getPlotLinePath(a, null, null, !0),
          t = [],
          n = this.horiz,
          f = 1,
          c;
        a = a < this.min && l < this.min || a > this.max && l > this.max;
        if (e &&
          b)
          for (a && (c = e.toString() === b.toString(), f = 0), a = 0; a < e.length; a += 6) n && b[a + 1] === e[a + 1] ? (b[a + 1] += f, b[a + 4] += f) : n || b[a + 2] !== e[a + 2] || (b[a + 2] += f, b[a + 5] += f), t.push("M", e[a + 1], e[a + 2], "L", e[a + 4], e[a + 5], b[a + 4], b[a + 5], b[a + 1], b[a + 2], "z"), t.flat = c;
        return t
      },
      addPlotBand: function(a) {
        return this.addPlotBandOrLine(a, "plotBands")
      },
      addPlotLine: function(a) {
        return this.addPlotBandOrLine(a, "plotLines")
      },
      addPlotBandOrLine: function(g, l) {
        var b = (new a.PlotLineOrBand(this, g)).render(),
          e = this.userOptions;
        b && (l && (e[l] = e[l] || [],
          e[l].push(g)), this.plotLinesAndBands.push(b));
        return b
      },
      removePlotBandOrLine: function(a) {
        for (var l = this.plotLinesAndBands, b = this.options, e = this.userOptions, t = l.length; t--;) l[t].id === a && l[t].destroy();
        g([b.plotLines || [], e.plotLines || [], b.plotBands || [], e.plotBands || []], function(b) {
          for (t = b.length; t--;) b[t].id === a && v(b, b[t])
        })
      },
      removePlotBand: function(a) {
        this.removePlotBandOrLine(a)
      },
      removePlotLine: function(a) {
        this.removePlotBandOrLine(a)
      }
    })
  })(L, da);
  (function(a) {
    var B = a.each,
      C = a.extend,
      G = a.format,
      p = a.isNumber,
      m = a.map,
      g = a.merge,
      v = a.pick,
      z = a.splat,
      u = a.syncTimeout,
      y = a.timeUnits;
    a.Tooltip = function() {
      this.init.apply(this, arguments)
    };
    a.Tooltip.prototype = {
      init: function(a, b) {
        this.chart = a;
        this.options = b;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = b.split && !a.inverted;
        this.shared = b.shared || this.split
      },
      cleanSplit: function(a) {
        B(this.chart.series, function(b) {
          var e = b && b.tt;
          e && (!e.isActive || a ? b.tt = e.destroy() : e.isActive = !1)
        })
      },
      getLabel: function() {
        var a = this.chart.renderer,
          b = this.options;
        this.label ||
          (this.split ? this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({
            padding: b.padding,
            r: b.borderRadius
          }), this.label.attr({
            fill: b.backgroundColor,
            "stroke-width": b.borderWidth
          }).css(b.style).shadow(b.shadow)), this.label.attr({
            zIndex: 8
          }).add());
        return this.label
      },
      update: function(a) {
        this.destroy();
        g(!0, this.chart.options.tooltip.userOptions, a);
        this.init(this.chart, g(!0, this.options, a))
      },
      destroy: function() {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
        a.clearTimeout(this.hideTimer);
        a.clearTimeout(this.tooltipTimeout)
      },
      move: function(l, b, e, t) {
        var n = this,
          f = n.now,
          c = !1 !== n.options.animation && !n.isHidden && (1 < Math.abs(l - f.x) || 1 < Math.abs(b - f.y)),
          h = n.followPointer || 1 < n.len;
        C(f, {
          x: c ? (2 * f.x + l) / 3 : l,
          y: c ? (f.y + b) / 2 : b,
          anchorX: h ? void 0 : c ? (2 * f.anchorX + e) / 3 : e,
          anchorY: h ? void 0 : c ? (f.anchorY + t) / 2 : t
        });
        n.getLabel().attr(f);
        c && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
          n &&
            n.move(l, b, e, t)
        }, 32))
      },
      hide: function(l) {
        var b = this;
        a.clearTimeout(this.hideTimer);
        l = v(l, this.options.hideDelay, 500);
        this.isHidden || (this.hideTimer = u(function() {
          b.getLabel()[l ? "fadeOut" : "hide"]();
          b.isHidden = !0
        }, l))
      },
      getAnchor: function(a, b) {
        var e, l = this.chart,
          n = l.inverted,
          f = l.plotTop,
          c = l.plotLeft,
          h = 0,
          w = 0,
          D, r;
        a = z(a);
        e = a[0].tooltipPos;
        this.followPointer && b && (void 0 === b.chartX && (b = l.pointer.normalize(b)), e = [b.chartX - l.plotLeft, b.chartY - f]);
        e || (B(a, function(a) {
          D = a.series.yAxis;
          r = a.series.xAxis;
          h += a.plotX +
            (!n && r ? r.left - c : 0);
          w += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!n && D ? D.top - f : 0)
        }), h /= a.length, w /= a.length, e = [n ? l.plotWidth - w : h, this.shared && !n && 1 < a.length && b ? b.chartY - f : n ? l.plotHeight - h : w]);
        return m(e, Math.round)
      },
      getPosition: function(a, b, e) {
        var l = this.chart,
          n = this.distance,
          f = {},
          c = l.inverted && e.h || 0,
          h, w = ["y", l.chartHeight, b, e.plotY + l.plotTop, l.plotTop, l.plotTop + l.plotHeight],
          D = ["x", l.chartWidth, a, e.plotX + l.plotLeft, l.plotLeft, l.plotLeft + l.plotWidth],
          r = !this.followPointer && v(e.ttBelow, !l.inverted ===
            !!e.negative),
          g = function(a, d, b, h, k, x) {
            var e = b < h - n,
              q = h + n + b < d,
              w = h - n - b;
            h += n;
            if (r && q) f[a] = h;
            else if (!r && e) f[a] = w;
            else if (e) f[a] = Math.min(x - b, 0 > w - c ? w : w - c);
            else if (q) f[a] = Math.max(k, h + c + b > d ? h : h + c);
            else return !1
          },
          q = function(a, d, b, c) {
            var k;
            c < n || c > d - n ? k = !1 : f[a] = c < b / 2 ? 1 : c > d - b / 2 ? d - b - 2 : c - b / 2;
            return k
          },
          F = function(a) {
            var d = w;
            w = D;
            D = d;
            h = a
          },
          x = function() {
            !1 !== g.apply(0, w) ? !1 !== q.apply(0, D) || h || (F(!0), x()) : h ? f.x = f.y = 0 : (F(!0), x())
          };
        (l.inverted || 1 < this.len) && F();
        x();
        return f
      },
      defaultFormatter: function(a) {
        var b = this.points ||
          z(this),
          e;
        e = [a.tooltipFooterHeaderFormatter(b[0])];
        e = e.concat(a.bodyFormatter(b));
        e.push(a.tooltipFooterHeaderFormatter(b[0], !0));
        return e
      },
      refresh: function(l, b) {
        var e, t = this.options,
          n, f = l,
          c, h = {},
          w = [];
        e = t.formatter || this.defaultFormatter;
        var h = this.shared,
          D;
        t.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = z(f)[0].series.tooltipOptions.followPointer, c = this.getAnchor(f, b), b = c[0], n = c[1], !h || f.series && f.series.noSharedTooltip ? h = f.getLabelConfig() : (B(f, function(a) {
            a.setState("hover");
            w.push(a.getLabelConfig())
          }),
          h = {
            x: f[0].category,
            y: f[0].y
          }, h.points = w, f = f[0]), this.len = w.length, h = e.call(h, this), D = f.series, this.distance = v(D.tooltipOptions.distance, 16), !1 === h ? this.hide() : (e = this.getLabel(), this.isHidden && e.attr({
          opacity: 1
        }).show(), this.split ? this.renderSplit(h, z(l)) : (t.style.width || e.css({
          width: this.chart.spacingBox.width
        }), e.attr({
          text: h && h.join ? h.join("") : h
        }), e.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + v(f.colorIndex, D.colorIndex)), e.attr({
          stroke: t.borderColor || f.color || D.color ||
            "#666666"
        }), this.updatePosition({
          plotX: b,
          plotY: n,
          negative: f.negative,
          ttBelow: f.ttBelow,
          h: c[2] || 0
        })), this.isHidden = !1))
      },
      renderSplit: function(l, b) {
        var e = this,
          t = [],
          n = this.chart,
          f = n.renderer,
          c = !0,
          h = this.options,
          w = 0,
          D = this.getLabel();
        a.isString(l) && (l = [!1, l]);
        B(l.slice(0, b.length + 1), function(a, l) {
          if (!1 !== a) {
            l = b[l - 1] || {
              isHeader: !0,
              plotX: b[0].plotX
            };
            var r = l.series || e,
              F = r.tt,
              x = l.series || {},
              K = "highcharts-color-" + v(l.colorIndex, x.colorIndex, "none");
            F || (r.tt = F = f.label(null, null, null, "callout", null, null, h.useHTML).addClass("highcharts-tooltip-box " +
              K).attr({
              padding: h.padding,
              r: h.borderRadius,
              fill: h.backgroundColor,
              stroke: h.borderColor || l.color || x.color || "#333333",
              "stroke-width": h.borderWidth
            }).add(D));
            F.isActive = !0;
            F.attr({
              text: a
            });
            F.css(h.style).shadow(h.shadow);
            a = F.getBBox();
            x = a.width + F.strokeWidth();
            l.isHeader ? (w = a.height, x = Math.max(0, Math.min(l.plotX + n.plotLeft - x / 2, n.chartWidth - x))) : x = l.plotX + n.plotLeft - v(h.distance, 16) - x;
            0 > x && (c = !1);
            a = (l.series && l.series.yAxis && l.series.yAxis.pos) + (l.plotY || 0);
            a -= n.plotTop;
            t.push({
              target: l.isHeader ? n.plotHeight +
                w : a,
              rank: l.isHeader ? 1 : 0,
              size: r.tt.getBBox().height + 1,
              point: l,
              x: x,
              tt: F
            })
          }
        });
        this.cleanSplit();
        a.distribute(t, n.plotHeight + w);
        B(t, function(a) {
          var b = a.point,
            f = b.series;
          a.tt.attr({
            visibility: void 0 === a.pos ? "hidden" : "inherit",
            x: c || b.isHeader ? a.x : b.plotX + n.plotLeft + v(h.distance, 16),
            y: a.pos + n.plotTop,
            anchorX: b.isHeader ? b.plotX + n.plotLeft : b.plotX + f.xAxis.pos,
            anchorY: b.isHeader ? a.pos + n.plotTop - 15 : b.plotY + f.yAxis.pos
          })
        })
      },
      updatePosition: function(a) {
        var b = this.chart,
          e = this.getLabel(),
          e = (this.options.positioner ||
            this.getPosition).call(this, e.width, e.height, a);
        this.move(Math.round(e.x), Math.round(e.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop)
      },
      getDateFormat: function(a, b, e, t) {
        var n = this.chart.time,
          f = n.dateFormat("%m-%d %H:%M:%S.%L", b),
          c, h, w = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          l = "millisecond";
        for (h in y) {
          if (a === y.week && +n.dateFormat("%w", b) === e && "00:00:00.000" === f.substr(6)) {
            h = "week";
            break
          }
          if (y[h] > a) {
            h = l;
            break
          }
          if (w[h] && f.substr(w[h]) !== "01-01 00:00:00.000".substr(w[h])) break;
          "week" !== h && (l = h)
        }
        h &&
          (c = t[h]);
        return c
      },
      getXDateFormat: function(a, b, e) {
        b = b.dateTimeLabelFormats;
        var l = e && e.closestPointRange;
        return (l ? this.getDateFormat(l, a.x, e.options.startOfWeek, b) : b.day) || b.year
      },
      tooltipFooterHeaderFormatter: function(a, b) {
        b = b ? "footer" : "header";
        var e = a.series,
          l = e.tooltipOptions,
          n = l.xDateFormat,
          f = e.xAxis,
          c = f && "datetime" === f.options.type && p(a.key),
          h = l[b + "Format"];
        c && !n && (n = this.getXDateFormat(a, l, f));
        c && n && B(a.point && a.point.tooltipDateKeys || ["key"], function(a) {
          h = h.replace("{point." + a + "}", "{point." +
            a + ":" + n + "}")
        });
        return G(h, {
          point: a,
          series: e
        }, this.chart.time)
      },
      bodyFormatter: function(a) {
        return m(a, function(a) {
          var b = a.series.tooltipOptions;
          return (b[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || "point") + "Format"])
        })
      }
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.attr,
      G = a.charts,
      p = a.color,
      m = a.css,
      g = a.defined,
      v = a.each,
      z = a.extend,
      u = a.find,
      y = a.fireEvent,
      l = a.isNumber,
      b = a.isObject,
      e = a.offset,
      t = a.pick,
      n = a.splat,
      f = a.Tooltip;
    a.Pointer = function(a,
      b) {
      this.init(a, b)
    };
    a.Pointer.prototype = {
      init: function(a, b) {
        this.options = b;
        this.chart = a;
        this.runChartClick = b.chart.events && !!b.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        f && (a.tooltip = new f(a, b.tooltip), this.followTouchMove = t(b.tooltip.followTouchMove, !0));
        this.setDOMEvents()
      },
      zoomOption: function(a) {
        var b = this.chart,
          c = b.options.chart,
          f = c.zoomType || "",
          b = b.inverted;
        /touch/.test(a.type) && (f = t(c.pinchType, f));
        this.zoomX = a = /x/.test(f);
        this.zoomY = f = /y/.test(f);
        this.zoomHor = a && !b || f && b;
        this.zoomVert =
          f && !b || a && b;
        this.hasZoom = a || f
      },
      normalize: function(a, b) {
        var c;
        c = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
        b || (this.chartPosition = b = e(this.chart.container));
        return z(a, {
          chartX: Math.round(c.pageX - b.left),
          chartY: Math.round(c.pageY - b.top)
        })
      },
      getCoordinates: function(a) {
        var b = {
          xAxis: [],
          yAxis: []
        };
        v(this.chart.axes, function(c) {
          b[c.isXAxis ? "xAxis" : "yAxis"].push({
            axis: c,
            value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
          })
        });
        return b
      },
      findNearestKDPoint: function(a, f, e) {
        var c;
        v(a, function(a) {
          var h = !(a.noSharedTooltip && f) && 0 > a.options.findNearestPointBy.indexOf("y");
          a = a.searchPoint(e, h);
          if ((h = b(a, !0)) && !(h = !b(c, !0))) var h = c.distX - a.distX,
            n = c.dist - a.dist,
            r = (a.series.group && a.series.group.zIndex) - (c.series.group && c.series.group.zIndex),
            h = 0 < (0 !== h && f ? h : 0 !== n ? n : 0 !== r ? r : c.series.index > a.series.index ? -1 : 1);
          h && (c = a)
        });
        return c
      },
      getPointFromEvent: function(a) {
        a = a.target;
        for (var b; a && !b;) b = a.point, a = a.parentNode;
        return b
      },
      getChartCoordinatesFromPoint: function(a, b) {
        var c = a.series,
          f = c.xAxis,
          c = c.yAxis,
          h =
          t(a.clientX, a.plotX),
          e = a.shapeArgs;
        if (f && c) return b ? {
          chartX: f.len + f.pos - h,
          chartY: c.len + c.pos - a.plotY
        } : {
          chartX: h + f.pos,
          chartY: a.plotY + c.pos
        };
        if (e && e.x && e.y) return {
          chartX: e.x,
          chartY: e.y
        }
      },
      getHoverData: function(c, f, e, n, r, l, q) {
        var h, x = [],
          w = q && q.isBoosting;
        n = !(!n || !c);
        q = f && !f.stickyTracking ? [f] : a.grep(e, function(a) {
          return a.visible && !(!r && a.directTouch) && t(a.options.enableMouseTracking, !0) && a.stickyTracking
        });
        f = (h = n ? c : this.findNearestKDPoint(q, r, l)) && h.series;
        h && (r && !f.noSharedTooltip ? (q = a.grep(e, function(a) {
          return a.visible &&
            !(!r && a.directTouch) && t(a.options.enableMouseTracking, !0) && !a.noSharedTooltip
        }), v(q, function(a) {
          var d = u(a.points, function(a) {
            return a.x === h.x && !a.isNull
          });
          b(d) && (w && (d = a.getPoint(d)), x.push(d))
        })) : x.push(h));
        return {
          hoverPoint: h,
          hoverSeries: f,
          hoverPoints: x
        }
      },
      runPointActions: function(b, f) {
        var c = this.chart,
          h = c.tooltip && c.tooltip.options.enabled ? c.tooltip : void 0,
          e = h ? h.shared : !1,
          n = f || c.hoverPoint,
          q = n && n.series || c.hoverSeries,
          q = this.getHoverData(n, q, c.series, !!f || q && q.directTouch && this.isDirectTouch, e,
            b, {
              isBoosting: c.isBoosting
            }),
          l, n = q.hoverPoint;
        l = q.hoverPoints;
        f = (q = q.hoverSeries) && q.tooltipOptions.followPointer;
        e = e && q && !q.noSharedTooltip;
        if (n && (n !== c.hoverPoint || h && h.isHidden)) {
          v(c.hoverPoints || [], function(b) {
            -1 === a.inArray(b, l) && b.setState()
          });
          v(l || [], function(a) {
            a.setState("hover")
          });
          if (c.hoverSeries !== q) q.onMouseOver();
          c.hoverPoint && c.hoverPoint.firePointEvent("mouseOut");
          if (!n.series) return;
          n.firePointEvent("mouseOver");
          c.hoverPoints = l;
          c.hoverPoint = n;
          h && h.refresh(e ? l : n, b)
        } else f && h && !h.isHidden &&
          (n = h.getAnchor([{}], b), h.updatePosition({
            plotX: n[0],
            plotY: n[1]
          }));
        this.unDocMouseMove || (this.unDocMouseMove = B(c.container.ownerDocument, "mousemove", function(b) {
          var c = G[a.hoverChartIndex];
          if (c) c.pointer.onDocumentMouseMove(b)
        }));
        v(c.axes, function(c) {
          var f = t(c.crosshair.snap, !0),
            d = f ? a.find(l, function(a) {
              return a.series[c.coll] === c
            }) : void 0;
          d || !f ? c.drawCrosshair(b, d) : c.hideCrosshair()
        })
      },
      reset: function(a, b) {
        var c = this.chart,
          f = c.hoverSeries,
          h = c.hoverPoint,
          e = c.hoverPoints,
          q = c.tooltip,
          l = q && q.shared ? e : h;
        a && l && v(n(l), function(b) {
          b.series.isCartesian && void 0 === b.plotX && (a = !1)
        });
        if (a) q && l && (q.refresh(l), h && (h.setState(h.state, !0), v(c.axes, function(a) {
          a.crosshair && a.drawCrosshair(null, h)
        })));
        else {
          if (h) h.onMouseOut();
          e && v(e, function(a) {
            a.setState()
          });
          if (f) f.onMouseOut();
          q && q.hide(b);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          v(c.axes, function(a) {
            a.hideCrosshair()
          });
          this.hoverX = c.hoverPoints = c.hoverPoint = null
        }
      },
      scaleGroups: function(a, b) {
        var c = this.chart,
          f;
        v(c.series, function(h) {
          f =
            a || h.getPlotBox();
          h.xAxis && h.xAxis.zoomEnabled && h.group && (h.group.attr(f), h.markerGroup && (h.markerGroup.attr(f), h.markerGroup.clip(b ? c.clipRect : null)), h.dataLabelsGroup && h.dataLabelsGroup.attr(f))
        });
        c.clipRect.attr(b || c.clipBox)
      },
      dragStart: function(a) {
        var b = this.chart;
        b.mouseIsDown = a.type;
        b.cancelClick = !1;
        b.mouseDownX = this.mouseDownX = a.chartX;
        b.mouseDownY = this.mouseDownY = a.chartY
      },
      drag: function(a) {
        var b = this.chart,
          c = b.options.chart,
          f = a.chartX,
          e = a.chartY,
          n = this.zoomHor,
          q = this.zoomVert,
          l = b.plotLeft,
          x = b.plotTop,
          t = b.plotWidth,
          d = b.plotHeight,
          H, E = this.selectionMarker,
          k = this.mouseDownX,
          A = this.mouseDownY,
          g = c.panKey && a[c.panKey + "Key"];
        E && E.touch || (f < l ? f = l : f > l + t && (f = l + t), e < x ? e = x : e > x + d && (e = x + d), this.hasDragged = Math.sqrt(Math.pow(k - f, 2) + Math.pow(A - e, 2)), 10 < this.hasDragged && (H = b.isInsidePlot(k - l, A - x), b.hasCartesianSeries && (this.zoomX || this.zoomY) && H && !g && !E && (this.selectionMarker = E = b.renderer.rect(l, x, n ? 1 : t, q ? 1 : d, 0).attr({
          fill: c.selectionMarkerFill || p("#335cad").setOpacity(.25).get(),
          "class": "highcharts-selection-marker",
          zIndex: 7
        }).add()), E && n && (f -= k, E.attr({
          width: Math.abs(f),
          x: (0 < f ? 0 : f) + k
        })), E && q && (f = e - A, E.attr({
          height: Math.abs(f),
          y: (0 < f ? 0 : f) + A
        })), H && !E && c.panning && b.pan(a, c.panning)))
      },
      drop: function(a) {
        var b = this,
          c = this.chart,
          f = this.hasPinched;
        if (this.selectionMarker) {
          var e = {
              originalEvent: a,
              xAxis: [],
              yAxis: []
            },
            n = this.selectionMarker,
            q = n.attr ? n.attr("x") : n.x,
            t = n.attr ? n.attr("y") : n.y,
            x = n.attr ? n.attr("width") : n.width,
            K = n.attr ? n.attr("height") : n.height,
            d;
          if (this.hasDragged || f) v(c.axes, function(c) {
            if (c.zoomEnabled && g(c.min) &&
              (f || b[{
                xAxis: "zoomX",
                yAxis: "zoomY"
              } [c.coll]])) {
              var h = c.horiz,
                k = "touchend" === a.type ? c.minPixelPadding : 0,
                n = c.toValue((h ? q : t) + k),
                h = c.toValue((h ? q + x : t + K) - k);
              e[c.coll].push({
                axis: c,
                min: Math.min(n, h),
                max: Math.max(n, h)
              });
              d = !0
            }
          }), d && y(c, "selection", e, function(a) {
            c.zoom(z(a, f ? {
              animation: !1
            } : null))
          });
          l(c.index) && (this.selectionMarker = this.selectionMarker.destroy());
          f && this.scaleGroups()
        }
        c && l(c.index) && (m(c.container, {
          cursor: c._cursor
        }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
      },
      onContainerMouseDown: function(a) {
        a = this.normalize(a);
        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a))
      },
      onDocumentMouseUp: function(b) {
        G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(b)
      },
      onDocumentMouseMove: function(a) {
        var b = this.chart,
          c = this.chartPosition;
        a = this.normalize(a, c);
        !c || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset()
      },
      onContainerMouseLeave: function(b) {
        var c =
          G[a.hoverChartIndex];
        c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null)
      },
      onContainerMouseMove: function(b) {
        var c = this.chart;
        g(a.hoverChartIndex) && G[a.hoverChartIndex] && G[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);
        b = this.normalize(b);
        b.returnValue = !1;
        "mousedown" === c.mouseIsDown && this.drag(b);
        !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b)
      },
      inClass: function(a, b) {
        for (var c; a;) {
          if (c =
            C(a, "class")) {
            if (-1 !== c.indexOf(b)) return !0;
            if (-1 !== c.indexOf("highcharts-container")) return !1
          }
          a = a.parentNode
        }
      },
      onTrackerMouseOut: function(a) {
        var b = this.chart.hoverSeries;
        a = a.relatedTarget || a.toElement;
        this.isDirectTouch = !1;
        if (!(!b || !a || b.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut()
      },
      onContainerClick: function(a) {
        var b = this.chart,
          f = b.hoverPoint,
          c = b.plotLeft,
          e = b.plotTop;
        a = this.normalize(a);
        b.cancelClick ||
          (f && this.inClass(a.target, "highcharts-tracker") ? (y(f.series, "click", z(a, {
            point: f
          })), b.hoverPoint && f.firePointEvent("click", a)) : (z(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - c, a.chartY - e) && y(b, "click", a)))
      },
      setDOMEvents: function() {
        var b = this,
          f = b.chart.container,
          e = f.ownerDocument;
        f.onmousedown = function(a) {
          b.onContainerMouseDown(a)
        };
        f.onmousemove = function(a) {
          b.onContainerMouseMove(a)
        };
        f.onclick = function(a) {
          b.onContainerClick(a)
        };
        this.unbindContainerMouseLeave = B(f, "mouseleave", b.onContainerMouseLeave);
        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = B(e, "mouseup", b.onDocumentMouseUp));
        a.hasTouch && (f.ontouchstart = function(a) {
          b.onContainerTouchStart(a)
        }, f.ontouchmove = function(a) {
          b.onContainerTouchMove(a)
        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = B(e, "touchend", b.onDocumentTouchEnd)))
      },
      destroy: function() {
        var b = this;
        b.unDocMouseMove && b.unDocMouseMove();
        this.unbindContainerMouseLeave();
        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd &&
          (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
        clearInterval(b.tooltipTimeout);
        a.objectEach(b, function(a, f) {
          b[f] = null
        })
      }
    }
  })(L);
  (function(a) {
    var B = a.charts,
      C = a.each,
      G = a.extend,
      p = a.map,
      m = a.noop,
      g = a.pick;
    G(a.Pointer.prototype, {
      pinchTranslate: function(a, g, m, p, l, b) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, g, m, p, l, b);
        this.zoomVert && this.pinchTranslateDirection(!1, a, g, m, p, l, b)
      },
      pinchTranslateDirection: function(a, g, m, p, l, b, e, t) {
        var n = this.chart,
          f = a ? "x" : "y",
          c = a ? "X" : "Y",
          h = "chart" + c,
          w = a ? "width" :
          "height",
          D = n["plot" + (a ? "Left" : "Top")],
          r, J, q = t || 1,
          F = n.inverted,
          x = n.bounds[a ? "h" : "v"],
          K = 1 === g.length,
          d = g[0][h],
          H = m[0][h],
          E = !K && g[1][h],
          k = !K && m[1][h],
          A;
        m = function() {
          !K && 20 < Math.abs(d - E) && (q = t || Math.abs(H - k) / Math.abs(d - E));
          J = (D - H) / q + d;
          r = n["plot" + (a ? "Width" : "Height")] / q
        };
        m();
        g = J;
        g < x.min ? (g = x.min, A = !0) : g + r > x.max && (g = x.max - r, A = !0);
        A ? (H -= .8 * (H - e[f][0]), K || (k -= .8 * (k - e[f][1])), m()) : e[f] = [H, k];
        F || (b[f] = J - D, b[w] = r);
        b = F ? 1 / q : q;
        l[w] = r;
        l[f] = g;
        p[F ? a ? "scaleY" : "scaleX" : "scale" + c] = q;
        p["translate" + c] = b * D + (H - b * d)
      },
      pinch: function(a) {
        var v =
          this,
          u = v.chart,
          y = v.pinchDown,
          l = a.touches,
          b = l.length,
          e = v.lastValidTouch,
          t = v.hasZoom,
          n = v.selectionMarker,
          f = {},
          c = 1 === b && (v.inClass(a.target, "highcharts-tracker") && u.runTrackerClick || v.runChartClick),
          h = {};
        1 < b && (v.initiated = !0);
        t && v.initiated && !c && a.preventDefault();
        p(l, function(a) {
          return v.normalize(a)
        });
        "touchstart" === a.type ? (C(l, function(a, b) {
          y[b] = {
            chartX: a.chartX,
            chartY: a.chartY
          }
        }), e.x = [y[0].chartX, y[1] && y[1].chartX], e.y = [y[0].chartY, y[1] && y[1].chartY], C(u.axes, function(a) {
          if (a.zoomEnabled) {
            var b =
              u.bounds[a.horiz ? "h" : "v"],
              f = a.minPixelPadding,
              c = a.toPixels(g(a.options.min, a.dataMin)),
              h = a.toPixels(g(a.options.max, a.dataMax)),
              e = Math.max(c, h);
            b.min = Math.min(a.pos, Math.min(c, h) - f);
            b.max = Math.max(a.pos + a.len, e + f)
          }
        }), v.res = !0) : v.followTouchMove && 1 === b ? this.runPointActions(v.normalize(a)) : y.length && (n || (v.selectionMarker = n = G({
          destroy: m,
          touch: !0
        }, u.plotBox)), v.pinchTranslate(y, l, f, n, h, e), v.hasPinched = t, v.scaleGroups(f, h), v.res && (v.res = !1, this.reset(!1, 0)))
      },
      touch: function(m, p) {
        var u = this.chart,
          v, l;
        if (u.index !== a.hoverChartIndex) this.onContainerMouseLeave({
          relatedTarget: !0
        });
        a.hoverChartIndex = u.index;
        1 === m.touches.length ? (m = this.normalize(m), (l = u.isInsidePlot(m.chartX - u.plotLeft, m.chartY - u.plotTop)) && !u.openMenu ? (p && this.runPointActions(m), "touchmove" === m.type && (p = this.pinchDown, v = p[0] ? 4 <= Math.sqrt(Math.pow(p[0].chartX - m.chartX, 2) + Math.pow(p[0].chartY - m.chartY, 2)) : !1), g(v, !0) && this.pinch(m)) : p && this.reset()) : 2 === m.touches.length && this.pinch(m)
      },
      onContainerTouchStart: function(a) {
        this.zoomOption(a);
        this.touch(a, !0)
      },
      onContainerTouchMove: function(a) {
        this.touch(a)
      },
      onDocumentTouchEnd: function(g) {
        B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(g)
      }
    })
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.charts,
      G = a.css,
      p = a.doc,
      m = a.extend,
      g = a.noop,
      v = a.Pointer,
      z = a.removeEvent,
      u = a.win,
      y = a.wrap;
    if (!a.hasTouch && (u.PointerEvent || u.MSPointerEvent)) {
      var l = {},
        b = !!u.PointerEvent,
        e = function() {
          var b = [];
          b.item = function(a) {
            return this[a]
          };
          a.objectEach(l, function(a) {
            b.push({
              pageX: a.pageX,
              pageY: a.pageY,
              target: a.target
            })
          });
          return b
        },
        t = function(b, f, c, h) {
          "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !C[a.hoverChartIndex] || (h(b), h = C[a.hoverChartIndex].pointer, h[f]({
            type: c,
            target: b.currentTarget,
            preventDefault: g,
            touches: e()
          }))
        };
      m(v.prototype, {
        onContainerPointerDown: function(a) {
          t(a, "onContainerTouchStart", "touchstart", function(a) {
            l[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY,
              target: a.currentTarget
            }
          })
        },
        onContainerPointerMove: function(a) {
          t(a, "onContainerTouchMove", "touchmove", function(a) {
            l[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY
            };
            l[a.pointerId].target || (l[a.pointerId].target = a.currentTarget)
          })
        },
        onDocumentPointerUp: function(a) {
          t(a, "onDocumentTouchEnd", "touchend", function(a) {
            delete l[a.pointerId]
          })
        },
        batchMSEvents: function(a) {
          a(this.chart.container, b ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
          a(this.chart.container, b ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
          a(p, b ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
        }
      });
      y(v.prototype, "init", function(a, b, c) {
        a.call(this, b, c);
        this.hasZoom &&
          G(b.container, {
            "-ms-touch-action": "none",
            "touch-action": "none"
          })
      });
      y(v.prototype, "setDOMEvents", function(a) {
        a.apply(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B)
      });
      y(v.prototype, "destroy", function(a) {
        this.batchMSEvents(z);
        a.call(this)
      })
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.css,
      G = a.discardElement,
      p = a.defined,
      m = a.each,
      g = a.fireEvent,
      v = a.isFirefox,
      z = a.marginNames,
      u = a.merge,
      y = a.pick,
      l = a.setAnimation,
      b = a.stableSort,
      e = a.win,
      t = a.wrap;
    a.Legend = function(a, b) {
      this.init(a, b)
    };
    a.Legend.prototype = {
      init: function(a, b) {
        this.chart = a;
        this.setOptions(b);
        b.enabled && (this.render(), B(this.chart, "endResize", function() {
          this.legend.positionCheckboxes()
        }))
      },
      setOptions: function(a) {
        var b = y(a.padding, 8);
        this.options = a;
        this.itemStyle = a.itemStyle;
        this.itemHiddenStyle = u(this.itemStyle, a.itemHiddenStyle);
        this.itemMarginTop = a.itemMarginTop || 0;
        this.padding = b;
        this.initialItemY = b - 5;
        this.symbolWidth = y(a.symbolWidth, 16);
        this.pages = []
      },
      update: function(a, b) {
        var f = this.chart;
        this.setOptions(u(!0, this.options, a));
        this.destroy();
        f.isDirtyLegend = f.isDirtyBox = !0;
        y(b, !0) && f.redraw();
        g(this, "afterUpdate")
      },
      colorizeItem: function(a, b) {
        a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        var f = this.options,
          h = a.legendItem,
          e = a.legendLine,
          n = a.legendSymbol,
          l = this.itemHiddenStyle.color,
          f = b ? f.itemStyle.color : l,
          t = b ? a.color || l : l,
          q = a.options && a.options.marker,
          F = {
            fill: t
          };
        h && h.css({
          fill: f,
          color: f
        });
        e && e.attr({
          stroke: t
        });
        n && (q && n.isMarker && (F = a.pointAttribs(), b || (F.stroke = F.fill = l)), n.attr(F));
        g(this, "afterColorizeItem", {
          item: a,
          visible: b
        })
      },
      positionItem: function(a) {
        var b = this.options,
          c = b.symbolPadding,
          b = !b.rtl,
          h = a._legendItemPos,
          e = h[0],
          h = h[1],
          n = a.checkbox;
        (a = a.legendGroup) && a.element && a.translate(b ? e : this.legendWidth - e - 2 * c - 4, h);
        n && (n.x = e, n.y = h)
      },
      destroyItem: function(a) {
        var b = a.checkbox;
        m(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b) {
          a[b] && (a[b] = a[b].destroy())
        });
        b && G(a.checkbox)
      },
      destroy: function() {
        function a(a) {
          this[a] && (this[a] = this[a].destroy())
        }
        m(this.getAllItems(), function(b) {
          m(["legendItem",
            "legendGroup"
          ], a, b)
        });
        m("clipRect up down pager nav box title group".split(" "), a, this);
        this.display = null
      },
      positionCheckboxes: function() {
        var a = this.group && this.group.alignAttr,
          b, c = this.clipHeight || this.legendHeight,
          h = this.titleHeight;
        a && (b = a.translateY, m(this.allItems, function(f) {
          var e = f.checkbox,
            n;
          e && (n = b + h + e.y + (this.scrollOffset || 0) + 3, C(e, {
            left: a.translateX + f.checkboxOffset + e.x - 20 + "px",
            top: n + "px",
            display: n > b - 6 && n < b + c - 6 ? "" : "none"
          }))
        }, this))
      },
      renderTitle: function() {
        var a = this.options,
          b = this.padding,
          c = a.title,
          h = 0;
        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, null, null, null, a.useHTML, null, "legend-title").attr({
          zIndex: 1
        }).css(c.style).add(this.group)), a = this.title.getBBox(), h = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
          translateY: h
        }));
        this.titleHeight = h
      },
      setText: function(b) {
        var f = this.options;
        b.legendItem.attr({
          text: f.labelFormat ? a.format(f.labelFormat, b, this.chart.time) : f.labelFormatter.call(b)
        })
      },
      renderItem: function(a) {
        var b = this.chart,
          c = b.renderer,
          h =
          this.options,
          e = this.symbolWidth,
          l = h.symbolPadding,
          n = this.itemStyle,
          t = this.itemHiddenStyle,
          q = "horizontal" === h.layout ? y(h.itemDistance, 20) : 0,
          g = !h.rtl,
          x = a.legendItem,
          K = !a.series,
          d = !K && a.series.drawLegendSymbol ? a.series : a,
          H = d.options,
          H = this.createCheckboxForItem && H && H.showCheckbox,
          q = e + l + q + (H ? 20 : 0),
          E = h.useHTML,
          k = a.options.className;
        x || (a.legendGroup = c.g("legend-item").addClass("highcharts-" + d.type + "-series highcharts-color-" + a.colorIndex + (k ? " " + k : "") + (K ? " highcharts-series-" + a.index : "")).attr({
            zIndex: 1
          }).add(this.scrollGroup),
          a.legendItem = x = c.text("", g ? e + l : -l, this.baseline || 0, E).css(u(a.visible ? n : t)).attr({
            align: g ? "left" : "right",
            zIndex: 2
          }).add(a.legendGroup), this.baseline || (e = n.fontSize, this.fontMetrics = c.fontMetrics(e, x), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, x.attr("y", this.baseline)), this.symbolHeight = h.symbolHeight || this.fontMetrics.f, d.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, x, E), H && this.createCheckboxForItem(a));
        this.colorizeItem(a, a.visible);
        n.width || x.css({
          width: (h.itemWidth ||
            h.width || b.spacingBox.width) - q
        });
        this.setText(a);
        b = x.getBBox();
        a.itemWidth = a.checkboxOffset = h.itemWidth || a.legendItemWidth || b.width + q;
        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
        this.totalItemWidth += a.itemWidth;
        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight)
      },
      layoutItem: function(a) {
        var b = this.options,
          c = this.padding,
          h = "horizontal" === b.layout,
          e = a.itemHeight,
          l = b.itemMarginBottom || 0,
          n = this.itemMarginTop,
          t = h ? y(b.itemDistance, 20) : 0,
          q = b.width,
          g = q || this.chart.spacingBox.width -
          2 * c - b.x,
          b = b.alignColumns && this.totalItemWidth > g ? this.maxItemWidth : a.itemWidth;
        h && this.itemX - c + b > g && (this.itemX = c, this.itemY += n + this.lastLineHeight + l, this.lastLineHeight = 0);
        this.lastItemY = n + this.itemY + l;
        this.lastLineHeight = Math.max(e, this.lastLineHeight);
        a._legendItemPos = [this.itemX, this.itemY];
        h ? this.itemX += b : (this.itemY += n + e + l, this.lastLineHeight = e);
        this.offsetWidth = q || Math.max((h ? this.itemX - c - (a.checkbox ? 0 : t) : b) + c, this.offsetWidth)
      },
      getAllItems: function() {
        var a = [];
        m(this.chart.series, function(b) {
          var c =
            b && b.options;
          b && y(c.showInLegend, p(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)))
        });
        g(this, "afterGetAllItems", {
          allItems: a
        });
        return a
      },
      getAlignment: function() {
        var a = this.options;
        return a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0)
      },
      adjustMargins: function(a, b) {
        var c = this.chart,
          f = this.options,
          e = this.getAlignment();
        e && m([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function(h, l) {
          h.test(e) && !p(a[l]) && (c[z[l]] = Math.max(c[z[l]],
            c.legend[(l + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l] * f[l % 2 ? "x" : "y"] + y(f.margin, 12) + b[l] + (0 === l && void 0 !== c.options.title.margin ? c.titleOffset + c.options.title.margin : 0)))
        })
      },
      render: function() {
        var a = this.chart,
          f = a.renderer,
          c = this.group,
          e, l, t, r, g = this.box,
          q = this.options,
          F = this.padding;
        this.itemX = F;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        c || (this.group = c = f.g("legend").attr({
          zIndex: 7
        }).add(), this.contentGroup = f.g().attr({
          zIndex: 1
        }).add(c), this.scrollGroup = f.g().add(this.contentGroup));
        this.renderTitle();
        e = this.getAllItems();
        b(e, function(a, b) {
          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)
        });
        q.reversed && e.reverse();
        this.allItems = e;
        this.display = l = !!e.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        m(e, this.renderItem, this);
        m(e, this.layoutItem, this);
        t = (q.width || this.offsetWidth) + F;
        r = this.lastItemY + this.lastLineHeight + this.titleHeight;
        r = this.handleOverflow(r);
        r += F;
        g || (this.box = g = f.rect().addClass("highcharts-legend-box").attr({
            r: q.borderRadius
          }).add(c),
          g.isNew = !0);
        g.attr({
          stroke: q.borderColor,
          "stroke-width": q.borderWidth || 0,
          fill: q.backgroundColor || "none"
        }).shadow(q.shadow);
        0 < t && 0 < r && (g[g.isNew ? "attr" : "animate"](g.crisp.call({}, {
          x: 0,
          y: 0,
          width: t,
          height: r
        }, g.strokeWidth())), g.isNew = !1);
        g[l ? "show" : "hide"]();
        this.legendWidth = t;
        this.legendHeight = r;
        m(e, this.positionItem, this);
        l && (f = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (f = u(f, {
          y: f.y + a.titleOffset + a.options.title.margin
        })), c.align(u(q, {
          width: t,
          height: r
        }), !0, f));
        a.isResizing || this.positionCheckboxes()
      },
      handleOverflow: function(a) {
        var b = this,
          c = this.chart,
          e = c.renderer,
          l = this.options,
          n = l.y,
          r = this.padding,
          c = c.spacingBox.height + ("top" === l.verticalAlign ? -n : n) - r,
          n = l.maxHeight,
          t, q = this.clipRect,
          g = l.navigation,
          x = y(g.animation, !0),
          K = g.arrowSize || 12,
          d = this.nav,
          H = this.pages,
          E, k = this.allItems,
          A = function(a) {
            "number" === typeof a ? q.attr({
              height: a
            }) : q && (b.clipRect = q.destroy(), b.contentGroup.clip());
            b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + r + "px,9999px," + (r + a) + "px,0)" : "auto")
          };
        "horizontal" !== l.layout ||
          "middle" === l.verticalAlign || l.floating || (c /= 2);
        n && (c = Math.min(c, n));
        H.length = 0;
        a > c && !1 !== g.enabled ? (this.clipHeight = t = Math.max(c - 20 - this.titleHeight - r, 0), this.currentPage = y(this.currentPage, 1), this.fullHeight = a, m(k, function(a, b) {
          var d = a._legendItemPos[1],
            c = Math.round(a.legendItem.getBBox().height),
            f = H.length;
          if (!f || d - H[f - 1] > t && (E || d) !== H[f - 1]) H.push(E || d), f++;
          a.pageIx = f - 1;
          E && (k[b - 1].pageIx = f - 1);
          b === k.length - 1 && d + c - H[f - 1] > t && (H.push(d), a.pageIx = f);
          d !== E && (E = d)
        }), q || (q = b.clipRect = e.clipRect(0, r, 9999,
          0), b.contentGroup.clip(q)), A(t), d || (this.nav = d = e.g().attr({
          zIndex: 1
        }).add(this.group), this.up = e.symbol("triangle", 0, 0, K, K).on("click", function() {
          b.scroll(-1, x)
        }).add(d), this.pager = e.text("", 15, 10).addClass("highcharts-legend-navigation").css(g.style).add(d), this.down = e.symbol("triangle-down", 0, 0, K, K).on("click", function() {
          b.scroll(1, x)
        }).add(d)), b.scroll(0), a = c) : d && (A(), this.nav = d.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return a
      },
      scroll: function(a, b) {
        var c = this.pages,
          f =
          c.length;
        a = this.currentPage + a;
        var e = this.clipHeight,
          n = this.options.navigation,
          r = this.pager,
          t = this.padding;
        a > f && (a = f);
        0 < a && (void 0 !== b && l(b, this.chart), this.nav.attr({
          translateX: t,
          translateY: e + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), this.up.attr({
          "class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        }), r.attr({
          text: a + "/" + f
        }), this.down.attr({
          x: 18 + this.pager.getBBox().width,
          "class": a === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        }), this.up.attr({
          fill: 1 ===
            a ? n.inactiveColor : n.activeColor
        }).css({
          cursor: 1 === a ? "default" : "pointer"
        }), this.down.attr({
          fill: a === f ? n.inactiveColor : n.activeColor
        }).css({
          cursor: a === f ? "default" : "pointer"
        }), this.scrollOffset = -c[a - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = a, this.positionCheckboxes())
      }
    };
    a.LegendSymbolMixin = {
      drawRectangle: function(a, b) {
        var c = a.symbolHeight,
          f = a.options.squareSymbol;
        b.legendSymbol = this.chart.renderer.rect(f ? (a.symbolWidth - c) / 2 : 0, a.baseline - c + 1, f ? c : a.symbolWidth,
          c, y(a.options.symbolRadius, c / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(b.legendGroup)
      },
      drawLineMarker: function(a) {
        var b = this.options,
          c = b.marker,
          e = a.symbolWidth,
          l = a.symbolHeight,
          n = l / 2,
          r = this.chart.renderer,
          t = this.legendGroup;
        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
        var q;
        q = {
          "stroke-width": b.lineWidth || 0
        };
        b.dashStyle && (q.dashstyle = b.dashStyle);
        this.legendLine = r.path(["M", 0, a, "L", e, a]).addClass("highcharts-graph").attr(q).add(t);
        c && !1 !== c.enabled && (b = Math.min(y(c.radius, n), n), 0 === this.symbol.indexOf("url") &&
          (c = u(c, {
            width: l,
            height: l
          }), b = 0), this.legendSymbol = c = r.symbol(this.symbol, e / 2 - b, a - b, 2 * b, 2 * b, c).addClass("highcharts-point").add(t), c.isMarker = !0)
      }
    };
    (/Trident\/7\.0/.test(e.navigator.userAgent) || v) && t(a.Legend.prototype, "positionItem", function(a, b) {
      var c = this,
        f = function() {
          b._legendItemPos && a.call(c, b)
        };
      f();
      setTimeout(f)
    })
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.animate,
      G = a.animObject,
      p = a.attr,
      m = a.doc,
      g = a.Axis,
      v = a.createElement,
      z = a.defaultOptions,
      u = a.discardElement,
      y = a.charts,
      l = a.css,
      b = a.defined,
      e = a.each,
      t = a.extend,
      n = a.find,
      f = a.fireEvent,
      c = a.grep,
      h = a.isNumber,
      w = a.isObject,
      D = a.isString,
      r = a.Legend,
      J = a.marginNames,
      q = a.merge,
      F = a.objectEach,
      x = a.Pointer,
      K = a.pick,
      d = a.pInt,
      H = a.removeEvent,
      E = a.seriesTypes,
      k = a.splat,
      A = a.syncTimeout,
      P = a.win,
      R = a.Chart = function() {
        this.getArgs.apply(this, arguments)
      };
    a.chart = function(a, b, d) {
      return new R(a, b, d)
    };
    t(R.prototype, {
      callbacks: [],
      getArgs: function() {
        var a = [].slice.call(arguments);
        if (D(a[0]) || a[0].nodeName) this.renderTo = a.shift();
        this.init(a[0], a[1])
      },
      init: function(b, d) {
        var k,
          c, e = b.series,
          h = b.plotOptions || {};
        f(this, "init", {
          args: arguments
        }, function() {
          b.series = null;
          k = q(z, b);
          for (c in k.plotOptions) k.plotOptions[c].tooltip = h[c] && q(h[c].tooltip) || void 0;
          k.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          k.series = b.series = e;
          this.userOptions = b;
          var x = k.chart,
            l = x.events;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = d;
          this.isResizing = 0;
          this.options = k;
          this.axes = [];
          this.series = [];
          this.time = b.time && a.keys(b.time).length ?
            new a.Time(b.time) : a.time;
          this.hasCartesianSeries = x.showAxes;
          var E = this;
          E.index = y.length;
          y.push(E);
          a.chartCount++;
          l && F(l, function(a, b) {
            B(E, b, a)
          });
          E.xAxis = [];
          E.yAxis = [];
          E.pointCount = E.colorCounter = E.symbolCounter = 0;
          f(E, "afterInit");
          E.firstRender()
        })
      },
      initSeries: function(b) {
        var d = this.options.chart;
        (d = E[b.type || d.type || d.defaultSeriesType]) || a.error(17, !0);
        d = new d;
        d.init(this, b);
        return d
      },
      orderSeries: function(a) {
        var b = this.series;
        for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName())
      },
      isInsidePlot: function(a, b, d) {
        var k = d ? b : a;
        a = d ? a : b;
        return 0 <= k && k <= this.plotWidth && 0 <= a && a <= this.plotHeight
      },
      redraw: function(b) {
        f(this, "beforeRedraw");
        var d = this.axes,
          k = this.series,
          c = this.pointer,
          h = this.legend,
          x = this.isDirtyLegend,
          l, q, E = this.hasCartesianSeries,
          r = this.isDirtyBox,
          n, H = this.renderer,
          g = H.isHidden(),
          A = [];
        this.setResponsive && this.setResponsive(!1);
        a.setAnimation(b, this);
        g && this.temporaryDisplay();
        this.layOutTitles();
        for (b = k.length; b--;)
          if (n = k[b], n.options.stacking && (l = !0, n.isDirty)) {
            q = !0;
            break
          } if (q)
          for (b = k.length; b--;) n = k[b], n.options.stacking && (n.isDirty = !0);
        e(k, function(a) {
          a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), x = !0);
          a.isDirtyData && f(a, "updatedData")
        });
        x && h.options.enabled && (h.render(), this.isDirtyLegend = !1);
        l && this.getStacks();
        E && e(d, function(a) {
          a.updateNames();
          a.setScale()
        });
        this.getMargins();
        E && (e(d, function(a) {
          a.isDirty && (r = !0)
        }), e(d, function(a) {
          var b = a.min + "," + a.max;
          a.extKey !== b && (a.extKey = b, A.push(function() {
            f(a, "afterSetExtremes", t(a.eventArgs,
              a.getExtremes()));
            delete a.eventArgs
          }));
          (r || l) && a.redraw()
        }));
        r && this.drawChartBox();
        f(this, "predraw");
        e(k, function(a) {
          (r || a.isDirty) && a.visible && a.redraw();
          a.isDirtyData = !1
        });
        c && c.reset(!0);
        H.draw();
        f(this, "redraw");
        f(this, "render");
        g && this.temporaryDisplay(!0);
        e(A, function(a) {
          a.call()
        })
      },
      get: function(a) {
        function b(b) {
          return b.id === a || b.options && b.options.id === a
        }
        var d, k = this.series,
          c;
        d = n(this.axes, b) || n(this.series, b);
        for (c = 0; !d && c < k.length; c++) d = n(k[c].points || [], b);
        return d
      },
      getAxes: function() {
        var a =
          this,
          b = this.options,
          d = b.xAxis = k(b.xAxis || {}),
          b = b.yAxis = k(b.yAxis || {});
        f(this, "getAxes");
        e(d, function(a, b) {
          a.index = b;
          a.isX = !0
        });
        e(b, function(a, b) {
          a.index = b
        });
        d = d.concat(b);
        e(d, function(b) {
          new g(a, b)
        });
        f(this, "afterGetAxes")
      },
      getSelectedPoints: function() {
        var a = [];
        e(this.series, function(b) {
          a = a.concat(c(b.data || [], function(a) {
            return a.selected
          }))
        });
        return a
      },
      getSelectedSeries: function() {
        return c(this.series, function(a) {
          return a.selected
        })
      },
      setTitle: function(a, b, d) {
        var k = this,
          c = k.options,
          f;
        f = c.title = q({
          style: {
            color: "#333333",
            fontSize: c.isStock ? "16px" : "18px"
          }
        }, c.title, a);
        c = c.subtitle = q({
          style: {
            color: "#666666"
          }
        }, c.subtitle, b);
        e([
          ["title", a, f],
          ["subtitle", b, c]
        ], function(a, b) {
          var d = a[0],
            c = k[d],
            f = a[1];
          a = a[2];
          c && f && (k[d] = c = c.destroy());
          a && !c && (k[d] = k.renderer.text(a.text, 0, 0, a.useHTML).attr({
            align: a.align,
            "class": "highcharts-" + d,
            zIndex: a.zIndex || 4
          }).add(), k[d].update = function(a) {
            k.setTitle(!b && a, b && a)
          }, k[d].css(a.style))
        });
        k.layOutTitles(d)
      },
      layOutTitles: function(a) {
        var b = 0,
          d, k = this.renderer,
          c = this.spacingBox;
        e(["title", "subtitle"],
          function(a) {
            var d = this[a],
              f = this.options[a];
            a = "title" === a ? -3 : f.verticalAlign ? 0 : b + 2;
            var e;
            d && (e = f.style.fontSize, e = k.fontMetrics(e, d).b, d.css({
              width: (f.width || c.width + f.widthAdjust) + "px"
            }).align(t({
              y: a + e
            }, f), !1, "spacingBox"), f.floating || f.verticalAlign || (b = Math.ceil(b + d.getBBox(f.useHTML).height)))
          }, this);
        d = this.titleOffset !== b;
        this.titleOffset = b;
        !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && K(a, !0) && this.isDirtyBox && this.redraw())
      },
      getChartSize: function() {
        var d = this.options.chart,
          k = d.width,
          d = d.height,
          c = this.renderTo;
        b(k) || (this.containerWidth = a.getStyle(c, "width"));
        b(d) || (this.containerHeight = a.getStyle(c, "height"));
        this.chartWidth = Math.max(0, k || this.containerWidth || 600);
        this.chartHeight = Math.max(0, a.relativeLength(d, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400))
      },
      temporaryDisplay: function(b) {
        var d = this.renderTo;
        if (b)
          for (; d && d.style;) d.hcOrigStyle && (a.css(d, d.hcOrigStyle), delete d.hcOrigStyle), d.hcOrigDetached && (m.body.removeChild(d), d.hcOrigDetached = !1), d = d.parentNode;
        else
          for (; d && d.style;) {
            m.body.contains(d) || d.parentNode || (d.hcOrigDetached = !0, m.body.appendChild(d));
            if ("none" === a.getStyle(d, "display", !1) || d.hcOricDetached) d.hcOrigStyle = {
              display: d.style.display,
              height: d.style.height,
              overflow: d.style.overflow
            }, b = {
              display: "block",
              overflow: "hidden"
            }, d !== this.renderTo && (b.height = 0), a.css(d, b), d.offsetWidth || d.style.setProperty("display", "block", "important");
            d = d.parentNode;
            if (d === m.body) break
          }
      },
      setClassName: function(a) {
        this.container.className = "highcharts-container " +
          (a || "")
      },
      getContainer: function() {
        var b, k = this.options,
          c = k.chart,
          e, x;
        b = this.renderTo;
        var l = a.uniqueKey(),
          q;
        b || (this.renderTo = b = c.renderTo);
        D(b) && (this.renderTo = b = m.getElementById(b));
        b || a.error(13, !0);
        e = d(p(b, "data-highcharts-chart"));
        h(e) && y[e] && y[e].hasRendered && y[e].destroy();
        p(b, "data-highcharts-chart", this.index);
        b.innerHTML = "";
        c.skipClone || b.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        e = this.chartWidth;
        x = this.chartHeight;
        q = t({
          position: "relative",
          overflow: "hidden",
          width: e + "px",
          height: x +
            "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
        }, c.style);
        this.container = b = v("div", {
          id: l
        }, q, b);
        this._cursor = b.style.cursor;
        this.renderer = new(a[c.renderer] || a.Renderer)(b, e, x, null, c.forExport, k.exporting && k.exporting.allowHTML);
        this.setClassName(c.className);
        this.renderer.setStyle(c.style);
        this.renderer.chartIndex = this.index;
        f(this, "afterGetContainer")
      },
      getMargins: function(a) {
        var d = this.spacing,
          k = this.margin,
          c = this.titleOffset;
        this.resetMargins();
        c &&
          !b(k[0]) && (this.plotTop = Math.max(this.plotTop, c + this.options.title.margin + d[0]));
        this.legend && this.legend.display && this.legend.adjustMargins(k, d);
        this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);
        this.adjustPlotArea && this.adjustPlotArea();
        a || this.getAxisMargins()
      },
      getAxisMargins: function() {
        var a = this,
          d = a.axisOffset = [0, 0, 0, 0],
          k = a.margin;
        a.hasCartesianSeries && e(a.axes, function(a) {
          a.visible && a.getOffset()
        });
        e(J, function(c, f) {
          b(k[f]) || (a[c] += d[f])
        });
        a.setChartSize()
      },
      reflow: function(d) {
        var k = this,
          c = k.options.chart,
          f = k.renderTo,
          e = b(c.width) && b(c.height),
          h = c.width || a.getStyle(f, "width"),
          c = c.height || a.getStyle(f, "height"),
          f = d ? d.target : P;
        if (!e && !k.isPrinting && h && c && (f === P || f === m)) {
          if (h !== k.containerWidth || c !== k.containerHeight) a.clearTimeout(k.reflowTimeout), k.reflowTimeout = A(function() {
            k.container && k.setSize(void 0, void 0, !1)
          }, d ? 100 : 0);
          k.containerWidth = h;
          k.containerHeight = c
        }
      },
      setReflow: function(a) {
        var b = this;
        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow &&
          (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = B(P, "resize", function(a) {
            b.reflow(a)
          }), B(this, "destroy", this.unbindReflow))
      },
      setSize: function(b, d, k) {
        var c = this,
          h = c.renderer;
        c.isResizing += 1;
        a.setAnimation(k, c);
        c.oldChartHeight = c.chartHeight;
        c.oldChartWidth = c.chartWidth;
        void 0 !== b && (c.options.chart.width = b);
        void 0 !== d && (c.options.chart.height = d);
        c.getChartSize();
        b = h.globalAnimation;
        (b ? C : l)(c.container, {
          width: c.chartWidth + "px",
          height: c.chartHeight + "px"
        }, b);
        c.setChartSize(!0);
        h.setSize(c.chartWidth,
          c.chartHeight, k);
        e(c.axes, function(a) {
          a.isDirty = !0;
          a.setScale()
        });
        c.isDirtyLegend = !0;
        c.isDirtyBox = !0;
        c.layOutTitles();
        c.getMargins();
        c.redraw(k);
        c.oldChartHeight = null;
        f(c, "resize");
        A(function() {
          c && f(c, "endResize", null, function() {
            --c.isResizing
          })
        }, G(b).duration)
      },
      setChartSize: function(a) {
        var b = this.inverted,
          d = this.renderer,
          c = this.chartWidth,
          k = this.chartHeight,
          h = this.options.chart,
          x = this.spacing,
          l = this.clipOffset,
          q, E, r, n;
        this.plotLeft = q = Math.round(this.plotLeft);
        this.plotTop = E = Math.round(this.plotTop);
        this.plotWidth = r = Math.max(0, Math.round(c - q - this.marginRight));
        this.plotHeight = n = Math.max(0, Math.round(k - E - this.marginBottom));
        this.plotSizeX = b ? n : r;
        this.plotSizeY = b ? r : n;
        this.plotBorderWidth = h.plotBorderWidth || 0;
        this.spacingBox = d.spacingBox = {
          x: x[3],
          y: x[0],
          width: c - x[3] - x[1],
          height: k - x[0] - x[2]
        };
        this.plotBox = d.plotBox = {
          x: q,
          y: E,
          width: r,
          height: n
        };
        c = 2 * Math.floor(this.plotBorderWidth / 2);
        b = Math.ceil(Math.max(c, l[3]) / 2);
        d = Math.ceil(Math.max(c, l[0]) / 2);
        this.clipBox = {
          x: b,
          y: d,
          width: Math.floor(this.plotSizeX - Math.max(c,
            l[1]) / 2 - b),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(c, l[2]) / 2 - d))
        };
        a || e(this.axes, function(a) {
          a.setAxisSize();
          a.setAxisTranslation()
        });
        f(this, "afterSetChartSize", {
          skipAxes: a
        })
      },
      resetMargins: function() {
        var a = this,
          b = a.options.chart;
        e(["margin", "spacing"], function(d) {
          var c = b[d],
            k = w(c) ? c : [c, c, c, c];
          e(["Top", "Right", "Bottom", "Left"], function(c, f) {
            a[d][f] = K(b[d + c], k[f])
          })
        });
        e(J, function(b, d) {
          a[b] = K(a.margin[d], a.spacing[d])
        });
        a.axisOffset = [0, 0, 0, 0];
        a.clipOffset = [0, 0, 0, 0]
      },
      drawChartBox: function() {
        var a =
          this.options.chart,
          b = this.renderer,
          d = this.chartWidth,
          c = this.chartHeight,
          k = this.chartBackground,
          e = this.plotBackground,
          h = this.plotBorder,
          x, l = this.plotBGImage,
          q = a.backgroundColor,
          E = a.plotBackgroundColor,
          r = a.plotBackgroundImage,
          n, t = this.plotLeft,
          H = this.plotTop,
          g = this.plotWidth,
          A = this.plotHeight,
          K = this.plotBox,
          w = this.clipRect,
          F = this.clipBox,
          m = "animate";
        k || (this.chartBackground = k = b.rect().addClass("highcharts-background").add(), m = "attr");
        x = a.borderWidth || 0;
        n = x + (a.shadow ? 8 : 0);
        q = {
          fill: q || "none"
        };
        if (x || k["stroke-width"]) q.stroke =
          a.borderColor, q["stroke-width"] = x;
        k.attr(q).shadow(a.shadow);
        k[m]({
          x: n / 2,
          y: n / 2,
          width: d - n - x % 2,
          height: c - n - x % 2,
          r: a.borderRadius
        });
        m = "animate";
        e || (m = "attr", this.plotBackground = e = b.rect().addClass("highcharts-plot-background").add());
        e[m](K);
        e.attr({
          fill: E || "none"
        }).shadow(a.plotShadow);
        r && (l ? l.animate(K) : this.plotBGImage = b.image(r, t, H, g, A).add());
        w ? w.animate({
          width: F.width,
          height: F.height
        }) : this.clipRect = b.clipRect(F);
        m = "animate";
        h || (m = "attr", this.plotBorder = h = b.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        h.attr({
          stroke: a.plotBorderColor,
          "stroke-width": a.plotBorderWidth || 0,
          fill: "none"
        });
        h[m](h.crisp({
          x: t,
          y: H,
          width: g,
          height: A
        }, -h.strokeWidth()));
        this.isDirtyBox = !1;
        f(this, "afterDrawChartBox")
      },
      propFromSeries: function() {
        var a = this,
          b = a.options.chart,
          d, c = a.options.series,
          k, f;
        e(["inverted", "angular", "polar"], function(e) {
          d = E[b.type || b.defaultSeriesType];
          f = b[e] || d && d.prototype[e];
          for (k = c && c.length; !f && k--;)(d = E[c[k].type]) && d.prototype[e] && (f = !0);
          a[e] = f
        })
      },
      linkSeries: function() {
        var a = this,
          b = a.series;
        e(b, function(a) {
          a.linkedSeries.length =
            0
        });
        e(b, function(b) {
          var d = b.options.linkedTo;
          D(d) && (d = ":previous" === d ? a.series[b.index - 1] : a.get(d)) && d.linkedParent !== b && (d.linkedSeries.push(b), b.linkedParent = d, b.visible = K(b.options.visible, d.options.visible, b.visible))
        });
        f(this, "afterLinkSeries")
      },
      renderSeries: function() {
        e(this.series, function(a) {
          a.translate();
          a.render()
        })
      },
      renderLabels: function() {
        var a = this,
          b = a.options.labels;
        b.items && e(b.items, function(c) {
          var k = t(b.style, c.style),
            f = d(k.left) + a.plotLeft,
            e = d(k.top) + a.plotTop + 12;
          delete k.left;
          delete k.top;
          a.renderer.text(c.html, f, e).attr({
            zIndex: 2
          }).css(k).add()
        })
      },
      render: function() {
        var a = this.axes,
          b = this.renderer,
          d = this.options,
          c, k, f;
        this.setTitle();
        this.legend = new r(this, d.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        d = this.plotWidth;
        c = this.plotHeight = Math.max(this.plotHeight - 21, 0);
        e(a, function(a) {
          a.setScale()
        });
        this.getAxisMargins();
        k = 1.1 < d / this.plotWidth;
        f = 1.05 < c / this.plotHeight;
        if (k || f) e(a, function(a) {
          (a.horiz && k || !a.horiz && f) && a.setTickInterval(!0)
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries && e(a, function(a) {
          a.visible && a.render()
        });
        this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0
      },
      addCredits: function(a) {
        var b = this;
        a = q(!0, this.options.credits, a);
        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
          a.href &&
            (P.location.href = a.href)
        }).attr({
          align: a.position.align,
          zIndex: 8
        }).css(a.style).add().align(a.position), this.credits.update = function(a) {
          b.credits = b.credits.destroy();
          b.addCredits(a)
        })
      },
      destroy: function() {
        var b = this,
          d = b.axes,
          c = b.series,
          k = b.container,
          h, x = k && k.parentNode;
        f(b, "destroy");
        b.renderer.forExport ? a.erase(y, b) : y[b.index] = void 0;
        a.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        H(b);
        for (h = d.length; h--;) d[h] = d[h].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (h = c.length; h--;) c[h] = c[h].destroy();
        e("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function(a) {
          var d = b[a];
          d && d.destroy && (b[a] = d.destroy())
        });
        k && (k.innerHTML = "", H(k), x && u(k));
        F(b, function(a, d) {
          delete b[d]
        })
      },
      firstRender: function() {
        var a = this,
          b = a.options;
        if (!a.isReadyToRender || a.isReadyToRender()) {
          a.getContainer();
          a.resetMargins();
          a.setChartSize();
          a.propFromSeries();
          a.getAxes();
          e(b.series || [], function(b) {
            a.initSeries(b)
          });
          a.linkSeries();
          f(a, "beforeRender");
          x && (a.pointer = new x(a, b));
          a.render();
          if (!a.renderer.imgCount && a.onload) a.onload();
          a.temporaryDisplay(!0)
        }
      },
      onload: function() {
        e([this.callback].concat(this.callbacks), function(a) {
          a && void 0 !== this.index && a.apply(this, [this])
        }, this);
        f(this, "load");
        f(this, "render");
        b(this.index) && this.setReflow(this.options.chart.reflow);
        this.onload = null
      }
    })
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.Chart,
      G = a.each;
    B(C, "afterSetChartSize", function(p) {
      var m =
        this.options.chart.scrollablePlotArea;
      if (m = m && m.minWidth)
        if (this.scrollablePixels = m = Math.max(0, m - this.chartWidth)) this.plotWidth += m, this.clipBox.width += m, p.skipAxes || G(this.axes, function(g) {
          1 === g.side ? g.getPlotLinePath = function() {
            var m = this.right,
              p;
            this.right = m - g.chart.scrollablePixels;
            p = a.Axis.prototype.getPlotLinePath.apply(this, arguments);
            this.right = m;
            return p
          } : (g.setAxisSize(), g.setAxisTranslation())
        })
    });
    B(C, "render", function() {
      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(),
        this.applyFixed()) : this.fixedDiv && this.applyFixed()
    });
    C.prototype.setUpScrolling = function() {
      this.scrollingContainer = a.createElement("div", {
        className: "highcharts-scrolling"
      }, {
        overflowX: "auto",
        WebkitOverflowScrolling: "touch"
      }, this.renderTo);
      this.innerContainer = a.createElement("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null
    };
    C.prototype.applyFixed = function() {
      var p = this.container,
        m, g;
      this.fixedDiv || (this.fixedDiv =
        a.createElement("div", {
          className: "highcharts-fixed"
        }, {
          position: "absolute",
          overflow: "hidden",
          pointerEvents: "none",
          zIndex: 2
        }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.fixedRenderer = m = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = m.path().attr({
          fill: a.color(this.options.chart.backgroundColor || "#fff").setOpacity(.85).get(),
          zIndex: -1
        }).addClass("highcharts-scrollable-mask").add(), a.each([this.inverted ? ".highcharts-xaxis" : ".highcharts-yaxis", this.inverted ?
          ".highcharts-xaxis-labels" : ".highcharts-yaxis-labels", ".highcharts-contextbutton", ".highcharts-credits", ".highcharts-legend", ".highcharts-subtitle", ".highcharts-title"
        ], function(g) {
          a.each(p.querySelectorAll(g), function(a) {
            m.box.appendChild(a);
            a.style.pointerEvents = "auto"
          })
        }));
      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      g = this.chartWidth + this.scrollablePixels;
      this.container.style.width = g + "px";
      this.renderer.boxWrapper.attr({
        width: g,
        height: this.chartHeight,
        viewBox: [0, 0, g, this.chartHeight].join(" ")
      });
      g = this.options.chart.scrollablePlotArea;
      g.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * g.scrollPositionX);
      var v = this.axisOffset;
      g = this.plotTop - v[0] - 1;
      var v = this.plotTop + this.plotHeight + v[2],
        z = this.plotLeft + this.plotWidth - this.scrollablePixels;
      this.scrollableMask.attr({
        d: this.scrollablePixels ? ["M", 0, g, "L", this.plotLeft - 1, g, "L", this.plotLeft - 1, v, "L", 0, v, "Z", "M", z, g, "L", this.chartWidth, g, "L", this.chartWidth, v, "L", z, v, "Z"] : ["M", 0, 0]
      })
    }
  })(L);
  (function(a) {
    var B, C = a.each,
      G =
      a.extend,
      p = a.erase,
      m = a.fireEvent,
      g = a.format,
      v = a.isArray,
      z = a.isNumber,
      u = a.pick,
      y = a.removeEvent;
    a.Point = B = function() {};
    a.Point.prototype = {
      init: function(a, b, e) {
        this.series = a;
        this.color = a.color;
        this.applyOptions(b, e);
        a.options.colorByPoint ? (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter], b = b.length, e = a.colorCounter, a.colorCounter++, a.colorCounter === b && (a.colorCounter = 0)) : e = a.colorIndex;
        this.colorIndex = u(this.colorIndex, e);
        a.chart.pointCount++;
        m(this, "afterInit");
        return this
      },
      applyOptions: function(a, b) {
        var e = this.series,
          l = e.options.pointValKey || e.pointValKey;
        a = B.prototype.optionsToObject.call(this, a);
        G(this, a);
        this.options = this.options ? G(this.options, a) : a;
        a.group && delete this.group;
        l && (this.y = this[l]);
        this.isNull = u(this.isValid && !this.isValid(), null === this.x || !z(this.y, !0));
        this.selected && (this.state = "select");
        "name" in this && void 0 === b && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));
        void 0 === this.x && e && (this.x = void 0 === b ? e.autoIncrement(this) : b);
        return this
      },
      setNestedProperty: function(l, b, e) {
        e = e.split(".");
        a.reduce(e, function(e, l, f, c) {
          e[l] = c.length - 1 === f ? b : a.isObject(e[l], !0) ? e[l] : {};
          return e[l]
        }, l);
        return l
      },
      optionsToObject: function(l) {
        var b = {},
          e = this.series,
          t = e.options.keys,
          n = t || e.pointArrayMap || ["y"],
          f = n.length,
          c = 0,
          h = 0;
        if (z(l) || null === l) b[n[0]] = l;
        else if (v(l))
          for (!t && l.length > f && (e = typeof l[0], "string" === e ? b.name = l[0] : "number" === e && (b.x = l[0]), c++); h < f;) t && void 0 === l[c] || (0 < n[h].indexOf(".") ? a.Point.prototype.setNestedProperty(b, l[c], n[h]) : b[n[h]] =
            l[c]), c++, h++;
        else "object" === typeof l && (b = l, l.dataLabels && (e._hasPointLabels = !0), l.marker && (e._hasPointMarkers = !0));
        return b
      },
      getClassName: function() {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative",
          "") : "")
      },
      getZone: function() {
        var a = this.series,
          b = a.zones,
          a = a.zoneAxis || "y",
          e = 0,
          t;
        for (t = b[e]; this[a] >= t.value;) t = b[++e];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = t && t.color && !this.options.color ? t.color : this.nonZonedColor;
        return t
      },
      destroy: function() {
        var a = this.series.chart,
          b = a.hoverPoints,
          e;
        a.pointCount--;
        b && (this.setState(), p(b, this), b.length || (a.hoverPoints = null));
        if (this === a.hoverPoint) this.onMouseOut();
        if (this.graphic || this.dataLabel) y(this), this.destroyElements();
        this.legendItem &&
          a.legend.destroyItem(this);
        for (e in this) this[e] = null
      },
      destroyElements: function() {
        for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], b, e = 6; e--;) b = a[e], this[b] && (this[b] = this[b].destroy())
      },
      getLabelConfig: function() {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        }
      },
      tooltipFormatter: function(a) {
        var b = this.series,
          e = b.tooltipOptions,
          l = u(e.valueDecimals, ""),
          n = e.valuePrefix || "",
          f = e.valueSuffix || "";
        C(b.pointArrayMap || ["y"], function(b) {
          b = "{point." + b;
          if (n || f) a = a.replace(RegExp(b + "}", "g"), n + b + "}" + f);
          a = a.replace(RegExp(b + "}", "g"), b + ":,." + l + "f}")
        });
        return g(a, {
          point: this,
          series: this.series
        }, b.chart.time)
      },
      firePointEvent: function(a, b, e) {
        var l = this,
          n = this.series.options;
        (n.point.events[a] || l.options && l.options.events && l.options.events[a]) && this.importEvents();
        "click" === a && n.allowPointSelect && (e = function(a) {
          l.select && l.select(null, a.ctrlKey ||
            a.metaKey || a.shiftKey)
        });
        m(this, a, b, e)
      },
      visible: !0
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.animObject,
      G = a.arrayMax,
      p = a.arrayMin,
      m = a.correctFloat,
      g = a.defaultOptions,
      v = a.defaultPlotOptions,
      z = a.defined,
      u = a.each,
      y = a.erase,
      l = a.extend,
      b = a.fireEvent,
      e = a.grep,
      t = a.isArray,
      n = a.isNumber,
      f = a.isString,
      c = a.merge,
      h = a.objectEach,
      w = a.pick,
      D = a.removeEvent,
      r = a.splat,
      J = a.SVGElement,
      q = a.syncTimeout,
      F = a.win;
    a.Series = a.seriesType("line", null, {
      lineWidth: 2,
      allowPointSelect: !1,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        lineWidth: 0,
        lineColor: "#ffffff",
        enabledThreshold: 2,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: "center",
        formatter: function() {
          return null === this.y ? "" : a.numberFormat(this.y, -1)
        },
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        padding: 5
      },
      cropThreshold: 300,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          marker: {}
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    }, {
      isCartesian: !0,
      pointClass: a.Point,
      sorted: !0,
      requireSorting: !0,
      directTouch: !1,
      axisTypes: ["xAxis", "yAxis"],
      colorCounter: 0,
      parallelArrays: ["x", "y"],
      coll: "series",
      init: function(a, c) {
        var d = this,
          f, e = a.series,
          k;
        d.chart = a;
        d.options = c = d.setOptions(c);
        d.linkedSeries = [];
        d.bindAxes();
        l(d, {
          name: c.name,
          state: "",
          visible: !1 !== c.visible,
          selected: !0 === c.selected
        });
        f = c.events;
        h(f, function(a, b) {
          B(d, b, a)
        });
        if (f && f.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;
        d.getColor();
        d.getSymbol();
        u(d.parallelArrays, function(a) {
          d[a + "Data"] = []
        });
        d.setData(c.data, !1);
        d.isCartesian && (a.hasCartesianSeries = !0);
        e.length && (k = e[e.length - 1]);
        d._i = w(k && k._i, -1) + 1;
        a.orderSeries(this.insert(e));
        b(this, "afterInit")
      },
      insert: function(a) {
        var b = this.options.index,
          d;
        if (n(b)) {
          for (d = a.length; d--;)
            if (b >=
              w(a[d].options.index, a[d]._i)) {
              a.splice(d + 1, 0, this);
              break
            } - 1 === d && a.unshift(this);
          d += 1
        } else a.push(this);
        return w(d, a.length - 1)
      },
      bindAxes: function() {
        var b = this,
          c = b.options,
          d = b.chart,
          f;
        u(b.axisTypes || [], function(e) {
          u(d[e], function(a) {
            f = a.options;
            if (c[e] === f.index || void 0 !== c[e] && c[e] === f.id || void 0 === c[e] && 0 === f.index) b.insert(a.series), b[e] = a, a.isDirty = !0
          });
          b[e] || b.optionalAxis === e || a.error(18, !0)
        })
      },
      updateParallelArrays: function(a, b) {
        var d = a.series,
          c = arguments,
          f = n(b) ? function(c) {
            var k = "y" === c && d.toYData ?
              d.toYData(a) : a[c];
            d[c + "Data"][b] = k
          } : function(a) {
            Array.prototype[b].apply(d[a + "Data"], Array.prototype.slice.call(c, 2))
          };
        u(d.parallelArrays, f)
      },
      autoIncrement: function() {
        var a = this.options,
          b = this.xIncrement,
          d, c = a.pointIntervalUnit,
          f = this.chart.time,
          b = w(b, a.pointStart, 0);
        this.pointInterval = d = w(this.pointInterval, a.pointInterval, 1);
        c && (a = new f.Date(b), "day" === c ? f.set("Date", a, f.get("Date", a) + d) : "month" === c ? f.set("Month", a, f.get("Month", a) + d) : "year" === c && f.set("FullYear", a, f.get("FullYear", a) + d), d = a.getTime() -
          b);
        this.xIncrement = b + d;
        return b
      },
      setOptions: function(a) {
        var f = this.chart,
          d = f.options,
          e = d.plotOptions,
          h = (f.userOptions || {}).plotOptions || {},
          k = e[this.type];
        this.userOptions = a;
        f = c(k, e.series, a);
        this.tooltipOptions = c(g.tooltip, g.plotOptions.series && g.plotOptions.series.tooltip, g.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);
        this.stickyTracking = w(a.stickyTracking, h[this.type] && h[this.type].stickyTracking, h.series && h.series.stickyTracking,
          this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
        null === k.marker && delete f.marker;
        this.zoneAxis = f.zoneAxis;
        a = this.zones = (f.zones || []).slice();
        !f.negativeColor && !f.negativeFillColor || f.zones || a.push({
          value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
          className: "highcharts-negative",
          color: f.negativeColor,
          fillColor: f.negativeFillColor
        });
        a.length && z(a[a.length - 1].value) && a.push({
          color: this.color,
          fillColor: this.fillColor
        });
        b(this, "afterSetOptions", {
          options: f
        });
        return f
      },
      getName: function() {
        return this.name ||
          "Series " + (this.index + 1)
      },
      getCyclic: function(a, b, d) {
        var c, f = this.chart,
          k = this.userOptions,
          e = a + "Index",
          h = a + "Counter",
          x = d ? d.length : w(f.options.chart[a + "Count"], f[a + "Count"]);
        b || (c = w(k[e], k["_" + e]), z(c) || (f.series.length || (f[h] = 0), k["_" + e] = c = f[h] % x, f[h] += 1), d && (b = d[c]));
        void 0 !== c && (this[e] = c);
        this[a] = b
      },
      getColor: function() {
        this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || v[this.type].color, this.chart.options.colors)
      },
      getSymbol: function() {
        this.getCyclic("symbol",
          this.options.marker.symbol, this.chart.options.symbols)
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
      updateData: function(b) {
        var c = this.options,
          d = this.points,
          f = [],
          e, k, h, x = this.requireSorting;
        u(b, function(b) {
          var k;
          k = a.defined(b) && this.pointClass.prototype.optionsToObject.call({
            series: this
          }, b).x;
          n(k) && (k = a.inArray(k, this.xData, h), -1 === k ? f.push(b) : b !== c.data[k] ? (d[k].update(b, !1, null, !1), d[k].touched = !0, x && (h = k)) : d[k] && (d[k].touched = !0), e = !0)
        }, this);
        if (e)
          for (b = d.length; b--;) k = d[b], k.touched || k.remove(!1),
            k.touched = !1;
        else if (b.length === d.length) u(b, function(a, b) {
          d[b].update && a !== c.data[b] && d[b].update(a, !1, null, !1)
        });
        else return !1;
        u(f, function(a) {
          this.addPoint(a, !1)
        }, this);
        return !0
      },
      setData: function(b, c, d, e) {
        var h = this,
          k = h.points,
          x = k && k.length || 0,
          q, l = h.options,
          r = h.chart,
          g = null,
          H = h.xAxis,
          F = l.turboThreshold,
          m = this.xData,
          D = this.yData,
          K = (q = h.pointArrayMap) && q.length,
          J;
        b = b || [];
        q = b.length;
        c = w(c, !0);
        !1 !== e && q && x && !h.cropped && !h.hasGroupedData && h.visible && (J = this.updateData(b));
        if (!J) {
          h.xIncrement = null;
          h.colorCounter =
            0;
          u(this.parallelArrays, function(a) {
            h[a + "Data"].length = 0
          });
          if (F && q > F) {
            for (d = 0; null === g && d < q;) g = b[d], d++;
            if (n(g))
              for (d = 0; d < q; d++) m[d] = this.autoIncrement(), D[d] = b[d];
            else if (t(g))
              if (K)
                for (d = 0; d < q; d++) g = b[d], m[d] = g[0], D[d] = g.slice(1, K + 1);
              else
                for (d = 0; d < q; d++) g = b[d], m[d] = g[0], D[d] = g[1];
            else a.error(12)
          } else
            for (d = 0; d < q; d++) void 0 !== b[d] && (g = {
              series: h
            }, h.pointClass.prototype.applyOptions.apply(g, [b[d]]), h.updateParallelArrays(g, d));
          D && f(D[0]) && a.error(14, !0);
          h.data = [];
          h.options.data = h.userOptions.data =
            b;
          for (d = x; d--;) k[d] && k[d].destroy && k[d].destroy();
          H && (H.minRange = H.userMinRange);
          h.isDirty = r.isDirtyBox = !0;
          h.isDirtyData = !!k;
          d = !1
        }
        "point" === l.legendType && (this.processData(), this.generatePoints());
        c && r.redraw(d)
      },
      processData: function(b) {
        var c = this.xData,
          d = this.yData,
          f = c.length,
          e;
        e = 0;
        var k, h, x = this.xAxis,
          q, l = this.options;
        q = l.cropThreshold;
        var r = this.getExtremesFromAll || l.getExtremesFromAll,
          n = this.isCartesian,
          l = x && x.val2lin,
          g = x && x.isLog,
          t = this.requireSorting,
          w, F;
        if (n && !this.isDirty && !x.isDirty && !this.yAxis.isDirty &&
          !b) return !1;
        x && (b = x.getExtremes(), w = b.min, F = b.max);
        if (n && this.sorted && !r && (!q || f > q || this.forceCrop))
          if (c[f - 1] < w || c[0] > F) c = [], d = [];
          else if (c[0] < w || c[f - 1] > F) e = this.cropData(this.xData, this.yData, w, F), c = e.xData, d = e.yData, e = e.start, k = !0;
        for (q = c.length || 1; --q;) f = g ? l(c[q]) - l(c[q - 1]) : c[q] - c[q - 1], 0 < f && (void 0 === h || f < h) ? h = f : 0 > f && t && (a.error(15), t = !1);
        this.cropped = k;
        this.cropStart = e;
        this.processedXData = c;
        this.processedYData = d;
        this.closestPointRange = h
      },
      cropData: function(a, b, d, c, f) {
        var k = a.length,
          e = 0,
          h = k,
          x;
        f =
          w(f, this.cropShoulder, 1);
        for (x = 0; x < k; x++)
          if (a[x] >= d) {
            e = Math.max(0, x - f);
            break
          } for (d = x; d < k; d++)
          if (a[d] > c) {
            h = d + f;
            break
          } return {
          xData: a.slice(e, h),
          yData: b.slice(e, h),
          start: e,
          end: h
        }
      },
      generatePoints: function() {
        var a = this.options,
          b = a.data,
          d = this.data,
          c, f = this.processedXData,
          k = this.processedYData,
          e = this.pointClass,
          h = f.length,
          q = this.cropStart || 0,
          l, n = this.hasGroupedData,
          a = a.keys,
          g, t = [],
          w;
        d || n || (d = [], d.length = b.length, d = this.data = d);
        a && n && (this.options.keys = !1);
        for (w = 0; w < h; w++) l = q + w, n ? (g = (new e).init(this, [f[w]].concat(r(k[w]))),
          g.dataGroup = this.groupMap[w]) : (g = d[l]) || void 0 === b[l] || (d[l] = g = (new e).init(this, b[l], f[w])), g && (g.index = l, t[w] = g);
        this.options.keys = a;
        if (d && (h !== (c = d.length) || n))
          for (w = 0; w < c; w++) w !== q || n || (w += h), d[w] && (d[w].destroyElements(), d[w].plotX = void 0);
        this.data = d;
        this.points = t
      },
      getExtremes: function(a) {
        var b = this.yAxis,
          d = this.processedXData,
          c, f = [],
          k = 0;
        c = this.xAxis.getExtremes();
        var e = c.min,
          h = c.max,
          q, x, l = this.requireSorting ? 1 : 0,
          r, g;
        a = a || this.stackedYData || this.processedYData || [];
        c = a.length;
        for (g = 0; g < c; g++)
          if (x =
            d[g], r = a[g], q = (n(r, !0) || t(r)) && (!b.positiveValuesOnly || r.length || 0 < r), x = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (d[g + l] || x) >= e && (d[g - l] || x) <= h, q && x)
            if (q = r.length)
              for (; q--;) "number" === typeof r[q] && (f[k++] = r[q]);
            else f[k++] = r;
        this.dataMin = p(f);
        this.dataMax = G(f)
      },
      translate: function() {
        this.processedXData || this.processData();
        this.generatePoints();
        var a = this.options,
          c = a.stacking,
          d = this.xAxis,
          f = d.categories,
          e = this.yAxis,
          k = this.points,
          h = k.length,
          q = !!this.modifyValue,
          l = a.pointPlacement,
          r = "between" === l || n(l),
          g = a.threshold,
          t = a.startFromThreshold ? g : 0,
          F, D, J, u, v = Number.MAX_VALUE;
        "between" === l && (l = .5);
        n(l) && (l *= w(a.pointRange || d.pointRange));
        for (a = 0; a < h; a++) {
          var p = k[a],
            y = p.x,
            C = p.y;
          D = p.low;
          var B = c && e.stacks[(this.negStacks && C < (t ? 0 : g) ? "-" : "") + this.stackKey],
            G;
          e.positiveValuesOnly && null !== C && 0 >= C && (p.isNull = !0);
          p.plotX = F = m(Math.min(Math.max(-1E5, d.translate(y, 0, 0, 0, 1, l, "flags" === this.type)), 1E5));
          c && this.visible && !p.isNull && B && B[y] && (u = this.getStackIndicator(u, y, this.index), G = B[y], C = G.points[u.key],
            D = C[0], C = C[1], D === t && u.key === B[y].base && (D = w(n(g) && g, e.min)), e.positiveValuesOnly && 0 >= D && (D = null), p.total = p.stackTotal = G.total, p.percentage = G.total && p.y / G.total * 100, p.stackY = C, G.setOffset(this.pointXOffset || 0, this.barW || 0));
          p.yBottom = z(D) ? Math.min(Math.max(-1E5, e.translate(D, 0, 1, 0, 1)), 1E5) : null;
          q && (C = this.modifyValue(C, p));
          p.plotY = D = "number" === typeof C && Infinity !== C ? Math.min(Math.max(-1E5, e.translate(C, 0, 1, 0, 1)), 1E5) : void 0;
          p.isInside = void 0 !== D && 0 <= D && D <= e.len && 0 <= F && F <= d.len;
          p.clientX = r ? m(d.translate(y,
            0, 0, 0, 1, l)) : F;
          p.negative = p.y < (g || 0);
          p.category = f && void 0 !== f[p.x] ? f[p.x] : p.x;
          p.isNull || (void 0 !== J && (v = Math.min(v, Math.abs(F - J))), J = F);
          p.zone = this.zones.length && p.getZone()
        }
        this.closestPointRangePx = v;
        b(this, "afterTranslate")
      },
      getValidPoints: function(a, b) {
        var d = this.chart;
        return e(a || this.points || [], function(a) {
          return b && !d.isInsidePlot(a.plotX, a.plotY, d.inverted) ? !1 : !a.isNull
        })
      },
      setClip: function(a) {
        var b = this.chart,
          d = this.options,
          c = b.renderer,
          f = b.inverted,
          k = this.clipBox,
          e = k || b.clipBox,
          h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, e.height, d.xAxis, d.yAxis].join(),
          q = b[h],
          l = b[h + "m"];
        q || (a && (e.width = 0, f && (e.x = b.plotSizeX), b[h + "m"] = l = c.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[h] = q = c.clipRect(e), q.count = {
          length: 0
        });
        a && !q.count[this.index] && (q.count[this.index] = !0, q.count.length += 1);
        !1 !== d.clip && (this.group.clip(a || k ? q : b.clipRect), this.markerGroup.clip(l), this.sharedClipKey = h);
        a || (q.count[this.index] && (delete q.count[this.index], --q.count.length),
          0 === q.count.length && h && b[h] && (k || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())))
      },
      animate: function(a) {
        var b = this.chart,
          d = C(this.options.animation),
          c;
        a ? this.setClip(d) : (c = this.sharedClipKey, (a = b[c]) && a.animate({
          width: b.plotSizeX,
          x: 0
        }, d), b[c + "m"] && b[c + "m"].animate({
          width: b.plotSizeX + 99,
          x: 0
        }, d), this.animate = null)
      },
      afterAnimate: function() {
        this.setClip();
        b(this, "afterAnimate");
        this.finishedAnimating = !0
      },
      drawPoints: function() {
        var a = this.points,
          b = this.chart,
          d, c, f, k, e = this.options.marker,
          h, q, l, r = this[this.specialGroup] || this.markerGroup,
          g, n = w(e.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);
        if (!1 !== e.enabled || this._hasPointMarkers)
          for (d = 0; d < a.length; d++) c = a[d], k = c.graphic, h = c.marker || {}, q = !!c.marker, f = n && void 0 === h.enabled || h.enabled, l = c.isInside, f && !c.isNull ? (f = w(h.symbol, this.symbol), g = this.markerAttribs(c, c.selected && "select"), k ? k[l ? "show" : "hide"](!0).animate(g) : l && (0 < g.width || c.hasImage) && (c.graphic = k = b.renderer.symbol(f, g.x, g.y, g.width,
            g.height, q ? h : e).add(r)), k && k.attr(this.pointAttribs(c, c.selected && "select")), k && k.addClass(c.getClassName(), !0)) : k && (c.graphic = k.destroy())
      },
      markerAttribs: function(a, b) {
        var d = this.options.marker,
          c = a.marker || {},
          f = c.symbol || d.symbol,
          k = w(c.radius, d.radius);
        b && (d = d.states[b], b = c.states && c.states[b], k = w(b && b.radius, d && d.radius, k + (d && d.radiusPlus || 0)));
        a.hasImage = f && 0 === f.indexOf("url");
        a.hasImage && (k = 0);
        a = {
          x: Math.floor(a.plotX) - k,
          y: a.plotY - k
        };
        k && (a.width = a.height = 2 * k);
        return a
      },
      pointAttribs: function(a,
        b) {
        var d = this.options.marker,
          c = a && a.options,
          f = c && c.marker || {},
          k = this.color,
          e = c && c.color,
          h = a && a.color,
          c = w(f.lineWidth, d.lineWidth);
        a = a && a.zone && a.zone.color;
        k = e || a || h || k;
        a = f.fillColor || d.fillColor || k;
        k = f.lineColor || d.lineColor || k;
        b && (d = d.states[b], b = f.states && f.states[b] || {}, c = w(b.lineWidth, d.lineWidth, c + w(b.lineWidthPlus, d.lineWidthPlus, 0)), a = b.fillColor || d.fillColor || a, k = b.lineColor || d.lineColor || k);
        return {
          stroke: k,
          "stroke-width": c,
          fill: a
        }
      },
      destroy: function() {
        var c = this,
          f = c.chart,
          d = /AppleWebKit\/533/.test(F.navigator.userAgent),
          e, q, k = c.data || [],
          l, r;
        b(c, "destroy");
        D(c);
        u(c.axisTypes || [], function(a) {
          (r = c[a]) && r.series && (y(r.series, c), r.isDirty = r.forceRedraw = !0)
        });
        c.legendItem && c.chart.legend.destroyItem(c);
        for (q = k.length; q--;)(l = k[q]) && l.destroy && l.destroy();
        c.points = null;
        a.clearTimeout(c.animationTimeout);
        h(c, function(a, b) {
          a instanceof J && !a.survive && (e = d && "group" === b ? "hide" : "destroy", a[e]())
        });
        f.hoverSeries === c && (f.hoverSeries = null);
        y(f.series, c);
        f.orderSeries();
        h(c, function(a, b) {
          delete c[b]
        })
      },
      getGraphPath: function(a, b,
        d) {
        var c = this,
          f = c.options,
          k = f.step,
          e, h = [],
          q = [],
          l;
        a = a || c.points;
        (e = a.reversed) && a.reverse();
        (k = {
          right: 1,
          center: 2
        } [k] || k && 3) && e && (k = 4 - k);
        !f.connectNulls || b || d || (a = this.getValidPoints(a));
        u(a, function(e, r) {
          var x = e.plotX,
            g = e.plotY,
            n = a[r - 1];
          (e.leftCliff || n && n.rightCliff) && !d && (l = !0);
          e.isNull && !z(b) && 0 < r ? l = !f.connectNulls : e.isNull && !b ? l = !0 : (0 === r || l ? r = ["M", e.plotX, e.plotY] : c.getPointSpline ? r = c.getPointSpline(a, e, r) : k ? (r = 1 === k ? ["L", n.plotX, g] : 2 === k ? ["L", (n.plotX + x) / 2, n.plotY, "L", (n.plotX + x) / 2, g] : ["L", x,
            n.plotY
          ], r.push("L", x, g)) : r = ["L", x, g], q.push(e.x), k && (q.push(e.x), 2 === k && q.push(e.x)), h.push.apply(h, r), l = !1)
        });
        h.xMap = q;
        return c.graphPath = h
      },
      drawGraph: function() {
        var a = this,
          b = this.options,
          d = (this.gappedPath || this.getGraphPath).call(this),
          c = [
            ["graph", "highcharts-graph", b.lineColor || this.color, b.dashStyle]
          ],
          c = a.getZonesGraphs(c);
        u(c, function(c, f) {
          var k = c[0],
            e = a[k];
          e ? (e.endX = a.preventGraphAnimation ? null : d.xMap, e.animate({
            d: d
          })) : d.length && (a[k] = a.chart.renderer.path(d).addClass(c[1]).attr({
              zIndex: 1
            }).add(a.group),
            e = {
              stroke: c[2],
              "stroke-width": b.lineWidth,
              fill: a.fillGraph && a.color || "none"
            }, c[3] ? e.dashstyle = c[3] : "square" !== b.linecap && (e["stroke-linecap"] = e["stroke-linejoin"] = "round"), e = a[k].attr(e).shadow(2 > f && b.shadow));
          e && (e.startX = d.xMap, e.isArea = d.isArea)
        })
      },
      getZonesGraphs: function(a) {
        u(this.zones, function(b, d) {
          a.push(["zone-graph-" + d, "highcharts-graph highcharts-zone-graph-" + d + " " + (b.className || ""), b.color || this.color, b.dashStyle || this.options.dashStyle])
        }, this);
        return a
      },
      applyZones: function() {
        var a = this,
          b = this.chart,
          d = b.renderer,
          c = this.zones,
          f, k, e = this.clips || [],
          h, q = this.graph,
          l = this.area,
          r = Math.max(b.chartWidth, b.chartHeight),
          g = this[(this.zoneAxis || "y") + "Axis"],
          n, t, F = b.inverted,
          D, m, J, p, v = !1;
        c.length && (q || l) && g && void 0 !== g.min && (t = g.reversed, D = g.horiz, q && !this.showLine && q.hide(), l && l.hide(), n = g.getExtremes(), u(c, function(c, x) {
          f = t ? D ? b.plotWidth : 0 : D ? 0 : g.toPixels(n.min);
          f = Math.min(Math.max(w(k, f), 0), r);
          k = Math.min(Math.max(Math.round(g.toPixels(w(c.value, n.max), !0)), 0), r);
          v && (f = k = g.toPixels(n.max));
          m = Math.abs(f - k);
          J = Math.min(f, k);
          p = Math.max(f, k);
          g.isXAxis ? (h = {
            x: F ? p : J,
            y: 0,
            width: m,
            height: r
          }, D || (h.x = b.plotHeight - h.x)) : (h = {
            x: 0,
            y: F ? p : J,
            width: r,
            height: m
          }, D && (h.y = b.plotWidth - h.y));
          F && d.isVML && (h = g.isXAxis ? {
            x: 0,
            y: t ? J : p,
            height: h.width,
            width: b.chartWidth
          } : {
            x: h.y - b.plotLeft - b.spacingBox.x,
            y: 0,
            width: h.height,
            height: b.chartHeight
          });
          e[x] ? e[x].animate(h) : (e[x] = d.clipRect(h), q && a["zone-graph-" + x].clip(e[x]), l && a["zone-area-" + x].clip(e[x]));
          v = c.value > n.max;
          a.resetZones && 0 === k && (k = void 0)
        }), this.clips = e)
      },
      invertGroups: function(a) {
        function b() {
          u(["group",
            "markerGroup"
          ], function(b) {
            d[b] && (c.renderer.isVML && d[b].attr({
              width: d.yAxis.len,
              height: d.xAxis.len
            }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(a))
          })
        }
        var d = this,
          c = d.chart,
          f;
        d.xAxis && (f = B(c, "resize", b), B(d, "destroy", f), b(a), d.invertGroups = b)
      },
      plotGroup: function(a, b, d, c, f) {
        var k = this[a],
          e = !k;
        e && (this[a] = k = this.chart.renderer.g().attr({
          zIndex: c || .1
        }).add(f));
        k.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (z(this.colorIndex) ? "highcharts-color-" +
          this.colorIndex + " " : "") + (this.options.className || "") + (k.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        k.attr({
          visibility: d
        })[e ? "attr" : "animate"](this.getPlotBox());
        return k
      },
      getPlotBox: function() {
        var a = this.chart,
          b = this.xAxis,
          d = this.yAxis;
        a.inverted && (b = d, d = this.xAxis);
        return {
          translateX: b ? b.left : a.plotLeft,
          translateY: d ? d.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        }
      },
      render: function() {
        var a = this,
          c = a.chart,
          d, f = a.options,
          e = !!a.animate && c.renderer.isSVG && C(f.animation).duration,
          k = a.visible ? "inherit" :
          "hidden",
          h = f.zIndex,
          l = a.hasRendered,
          r = c.seriesGroup,
          g = c.inverted;
        d = a.plotGroup("group", "series", k, h, r);
        a.markerGroup = a.plotGroup("markerGroup", "markers", k, h, r);
        e && a.animate(!0);
        d.inverted = a.isCartesian ? g : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.drawDataLabels && a.drawDataLabels();
        a.visible && a.drawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(g);
        !1 === f.clip || a.sharedClipKey || l || d.clip(c.clipRect);
        e && a.animate();
        l || (a.animationTimeout = q(function() {
            a.afterAnimate()
          },
          e));
        a.isDirty = !1;
        a.hasRendered = !0;
        b(a, "afterRender")
      },
      redraw: function() {
        var a = this.chart,
          b = this.isDirty || this.isDirtyData,
          d = this.group,
          c = this.xAxis,
          f = this.yAxis;
        d && (a.inverted && d.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), d.animate({
          translateX: w(c && c.left, a.plotLeft),
          translateY: w(f && f.top, a.plotTop)
        }));
        this.translate();
        this.render();
        b && delete this.kdTree
      },
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function(a, b) {
        var d = this.xAxis,
          c = this.yAxis,
          f = this.chart.inverted;
        return this.searchKDTree({
          clientX: f ?
            d.len - a.chartY + d.pos : a.chartX - d.pos,
          plotY: f ? c.len - a.chartX + c.pos : a.chartY - c.pos
        }, b)
      },
      buildKDTree: function() {
        function a(d, c, f) {
          var k, e;
          if (e = d && d.length) return k = b.kdAxisArray[c % f], d.sort(function(a, b) {
            return a[k] - b[k]
          }), e = Math.floor(e / 2), {
            point: d[e],
            left: a(d.slice(0, e), c + 1, f),
            right: a(d.slice(e + 1), c + 1, f)
          }
        }
        this.buildingKdTree = !0;
        var b = this,
          d = -1 < b.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete b.kdTree;
        q(function() {
            b.kdTree = a(b.getValidPoints(null, !b.directTouch), d, d);
            b.buildingKdTree = !1
          }, b.options.kdNow ?
          0 : 1)
      },
      searchKDTree: function(a, b) {
        function d(a, b, h, q) {
          var l = b.point,
            r = c.kdAxisArray[h % q],
            g, n, t = l;
          n = z(a[f]) && z(l[f]) ? Math.pow(a[f] - l[f], 2) : null;
          g = z(a[k]) && z(l[k]) ? Math.pow(a[k] - l[k], 2) : null;
          g = (n || 0) + (g || 0);
          l.dist = z(g) ? Math.sqrt(g) : Number.MAX_VALUE;
          l.distX = z(n) ? Math.sqrt(n) : Number.MAX_VALUE;
          r = a[r] - l[r];
          g = 0 > r ? "left" : "right";
          n = 0 > r ? "right" : "left";
          b[g] && (g = d(a, b[g], h + 1, q), t = g[e] < t[e] ? g : l);
          b[n] && Math.sqrt(r * r) < t[e] && (a = d(a, b[n], h + 1, q), t = a[e] < t[e] ? a : t);
          return t
        }
        var c = this,
          f = this.kdAxisArray[0],
          k = this.kdAxisArray[1],
          e = b ? "distX" : "dist";
        b = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree();
        if (this.kdTree) return d(a, this.kdTree, b, b)
      }
    })
  })(L);
  (function(a) {
    var B = a.Axis,
      C = a.Chart,
      G = a.correctFloat,
      p = a.defined,
      m = a.destroyObjectProperties,
      g = a.each,
      v = a.format,
      z = a.objectEach,
      u = a.pick,
      y = a.Series;
    a.StackItem = function(a, b, e, g, n) {
      var f = a.chart.inverted;
      this.axis = a;
      this.isNegative = e;
      this.options = b;
      this.x = g;
      this.total = null;
      this.points = {};
      this.stack = n;
      this.rightCliff = this.leftCliff =
        0;
      this.alignOptions = {
        align: b.align || (f ? e ? "left" : "right" : "center"),
        verticalAlign: b.verticalAlign || (f ? "middle" : e ? "bottom" : "top"),
        y: u(b.y, f ? 4 : e ? 14 : -6),
        x: u(b.x, f ? e ? -6 : 6 : 0)
      };
      this.textAlign = b.textAlign || (f ? e ? "right" : "left" : "center")
    };
    a.StackItem.prototype = {
      destroy: function() {
        m(this, this.axis)
      },
      render: function(a) {
        var b = this.axis.chart,
          e = this.options,
          l = e.format,
          l = l ? v(l, this, b.time) : e.formatter.call(this);
        this.label ? this.label.attr({
          text: l,
          visibility: "hidden"
        }) : this.label = b.renderer.text(l, null, null, e.useHTML).css(e.style).attr({
          align: this.textAlign,
          rotation: e.rotation,
          visibility: "hidden"
        }).add(a)
      },
      setOffset: function(a, b) {
        var e = this.axis,
          l = e.chart,
          g = e.translate(e.usePercentage ? 100 : this.total, 0, 0, 0, 1),
          f = e.translate(0),
          f = Math.abs(g - f);
        a = l.xAxis[0].translate(this.x) + a;
        e = this.getStackBox(l, this, a, g, b, f, e);
        if (b = this.label) b.align(this.alignOptions, null, e), e = b.alignAttr, b[!1 === this.options.crop || l.isInsidePlot(e.x, e.y) ? "show" : "hide"](!0)
      },
      getStackBox: function(a, b, e, g, n, f, c) {
        var h = b.axis.reversed,
          l = a.inverted;
        a = c.height + c.pos - a.plotTop;
        b = b.isNegative &&
          !h || !b.isNegative && h;
        return {
          x: l ? b ? g : g - f : e,
          y: l ? a - e - n : b ? a - g - f : a - g,
          width: l ? f : n,
          height: l ? n : f
        }
      }
    };
    C.prototype.getStacks = function() {
      var a = this;
      g(a.yAxis, function(a) {
        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks)
      });
      g(a.series, function(b) {
        !b.options.stacking || !0 !== b.visible && !1 !== a.options.chart.ignoreHiddenSeries || (b.stackKey = b.type + u(b.options.stack, ""))
      })
    };
    B.prototype.buildStacks = function() {
      var a = this.series,
        b = u(this.options.reversedStacks, !0),
        e = a.length,
        g;
      if (!this.isXAxis) {
        this.usePercentage = !1;
        for (g = e; g--;) a[b ? g : e - g - 1].setStackedPoints();
        for (g = 0; g < e; g++) a[g].modifyStacks()
      }
    };
    B.prototype.renderStackTotals = function() {
      var a = this.chart,
        b = a.renderer,
        e = this.stacks,
        g = this.stackTotalGroup;
      g || (this.stackTotalGroup = g = b.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6
      }).add());
      g.translate(a.plotLeft, a.plotTop);
      z(e, function(a) {
        z(a, function(a) {
          a.render(g)
        })
      })
    };
    B.prototype.resetStacks = function() {
      var a = this,
        b = a.stacks;
      a.isXAxis || z(b, function(b) {
        z(b, function(e, l) {
          e.touched < a.stacksTouched ? (e.destroy(),
            delete b[l]) : (e.total = null, e.cumulative = null)
        })
      })
    };
    B.prototype.cleanStacks = function() {
      var a;
      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), z(a, function(a) {
        z(a, function(a) {
          a.cumulative = a.total
        })
      }))
    };
    y.prototype.setStackedPoints = function() {
      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var l = this.processedXData,
          b = this.processedYData,
          e = [],
          g = b.length,
          n = this.options,
          f = n.threshold,
          c = u(n.startFromThreshold && f, 0),
          h = n.stack,
          n = n.stacking,
          w = this.stackKey,
          D = "-" + w,
          r = this.negStacks,
          m = this.yAxis,
          q = m.stacks,
          F = m.oldStacks,
          x, v, d, H, E, k, A;
        m.stacksTouched += 1;
        for (E = 0; E < g; E++) k = l[E], A = b[E], x = this.getStackIndicator(x, k, this.index), H = x.key, d = (v = r && A < (c ? 0 : f)) ? D : w, q[d] || (q[d] = {}), q[d][k] || (F[d] && F[d][k] ? (q[d][k] = F[d][k], q[d][k].total = null) : q[d][k] = new a.StackItem(m, m.options.stackLabels, v, k, h)), d = q[d][k], null !== A ? (d.points[H] = d.points[this.index] = [u(d.cumulative, c)], p(d.cumulative) || (d.base = H), d.touched = m.stacksTouched, 0 < x.index && !1 === this.singleStacks && (d.points[H][0] =
          d.points[this.index + "," + k + ",0"][0])) : d.points[H] = d.points[this.index] = null, "percent" === n ? (v = v ? w : D, r && q[v] && q[v][k] ? (v = q[v][k], d.total = v.total = Math.max(v.total, d.total) + Math.abs(A) || 0) : d.total = G(d.total + (Math.abs(A) || 0))) : d.total = G(d.total + (A || 0)), d.cumulative = u(d.cumulative, c) + (A || 0), null !== A && (d.points[H].push(d.cumulative), e[E] = d.cumulative);
        "percent" === n && (m.usePercentage = !0);
        this.stackedYData = e;
        m.oldStacks = {}
      }
    };
    y.prototype.modifyStacks = function() {
      var a = this,
        b = a.stackKey,
        e = a.yAxis.stacks,
        t = a.processedXData,
        n, f = a.options.stacking;
      a[f + "Stacker"] && g([b, "-" + b], function(b) {
        for (var c = t.length, l, g; c--;)
          if (l = t[c], n = a.getStackIndicator(n, l, a.index, b), g = (l = e[b] && e[b][l]) && l.points[n.key]) a[f + "Stacker"](g, l, c)
      })
    };
    y.prototype.percentStacker = function(a, b, e) {
      b = b.total ? 100 / b.total : 0;
      a[0] = G(a[0] * b);
      a[1] = G(a[1] * b);
      this.stackedYData[e] = a[1]
    };
    y.prototype.getStackIndicator = function(a, b, e, g) {
      !p(a) || a.x !== b || g && a.key !== g ? a = {
        x: b,
        index: 0,
        key: g
      } : a.index++;
      a.key = [e, b, a.index].join();
      return a
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.animate,
      G = a.Axis,
      p = a.createElement,
      m = a.css,
      g = a.defined,
      v = a.each,
      z = a.erase,
      u = a.extend,
      y = a.fireEvent,
      l = a.inArray,
      b = a.isNumber,
      e = a.isObject,
      t = a.isArray,
      n = a.merge,
      f = a.objectEach,
      c = a.pick,
      h = a.Point,
      w = a.Series,
      D = a.seriesTypes,
      r = a.setAnimation,
      J = a.splat;
    u(a.Chart.prototype, {
      addSeries: function(a, b, f) {
        var e, d = this;
        a && (b = c(b, !0), y(d, "addSeries", {
          options: a
        }, function() {
          e = d.initSeries(a);
          d.isDirtyLegend = !0;
          d.linkSeries();
          y(d, "afterAddSeries");
          b && d.redraw(f)
        }));
        return e
      },
      addAxis: function(a, b, f, e) {
        var d = b ? "xAxis" :
          "yAxis",
          h = this.options;
        a = n(a, {
          index: this[d].length,
          isX: b
        });
        b = new G(this, a);
        h[d] = J(h[d] || {});
        h[d].push(a);
        c(f, !0) && this.redraw(e);
        return b
      },
      showLoading: function(a) {
        var b = this,
          c = b.options,
          f = b.loadingDiv,
          d = c.loading,
          e = function() {
            f && m(f, {
              left: b.plotLeft + "px",
              top: b.plotTop + "px",
              width: b.plotWidth + "px",
              height: b.plotHeight + "px"
            })
          };
        f || (b.loadingDiv = f = p("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, b.container), b.loadingSpan = p("span", {
          className: "highcharts-loading-inner"
        }, null, f), B(b,
          "redraw", e));
        f.className = "highcharts-loading";
        b.loadingSpan.innerHTML = a || c.lang.loading;
        m(f, u(d.style, {
          zIndex: 10
        }));
        m(b.loadingSpan, d.labelStyle);
        b.loadingShown || (m(f, {
          opacity: 0,
          display: ""
        }), C(f, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        }));
        b.loadingShown = !0;
        e()
      },
      hideLoading: function() {
        var a = this.options,
          b = this.loadingDiv;
        b && (b.className = "highcharts-loading highcharts-loading-hidden", C(b, {
          opacity: 0
        }, {
          duration: a.loading.hideDuration || 100,
          complete: function() {
            m(b, {
              display: "none"
            })
          }
        }));
        this.loadingShown = !1
      },
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
      update: function(a, e, h, r) {
        var d = this,
          q = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle"
          },
          x = a.chart,
          k, t, w = [];
        y(d, "update", {
          options: a
        });
        if (x) {
          n(!0, d.options.chart, x);
          "className" in x && d.setClassName(x.className);
          "reflow" in x && d.setReflow(x.reflow);
          if ("inverted" in x || "polar" in x) d.propFromSeries(), k = !0;
          "alignTicks" in x && (k = !0);
          f(x, function(a, b) {
            -1 !== l("chart." + b, d.propsRequireUpdateSeries) && (t = !0); - 1 !== l(b, d.propsRequireDirtyBox) && (d.isDirtyBox = !0)
          });
          "style" in x && d.renderer.setStyle(x.style)
        }
        a.colors && (this.options.colors = a.colors);
        a.plotOptions &&
          n(!0, this.options.plotOptions, a.plotOptions);
        f(a, function(a, b) {
          if (d[b] && "function" === typeof d[b].update) d[b].update(a, !1);
          else if ("function" === typeof d[q[b]]) d[q[b]](a);
          "chart" !== b && -1 !== l(b, d.propsRequireUpdateSeries) && (t = !0)
        });
        v("xAxis yAxis zAxis series colorAxis pane".split(" "), function(b) {
          a[b] && (v(J(a[b]), function(a, c) {
            (c = g(a.id) && d.get(a.id) || d[b][c]) && c.coll === b && (c.update(a, !1), h && (c.touched = !0));
            if (!c && h)
              if ("series" === b) d.addSeries(a, !1).touched = !0;
              else if ("xAxis" === b || "yAxis" === b) d.addAxis(a,
              "xAxis" === b, !1).touched = !0
          }), h && v(d[b], function(a) {
            a.touched ? delete a.touched : w.push(a)
          }))
        });
        v(w, function(a) {
          a.remove(!1)
        });
        k && v(d.axes, function(a) {
          a.update({}, !1)
        });
        t && v(d.series, function(a) {
          a.update({}, !1)
        });
        a.loading && n(!0, d.options.loading, a.loading);
        k = x && x.width;
        x = x && x.height;
        b(k) && k !== d.chartWidth || b(x) && x !== d.chartHeight ? d.setSize(k, x, r) : c(e, !0) && d.redraw(r)
      },
      setSubtitle: function(a) {
        this.setTitle(void 0, a)
      }
    });
    u(h.prototype, {
      update: function(a, b, f, h) {
        function d() {
          q.applyOptions(a);
          null === q.y &&
            k && (q.graphic = k.destroy());
          e(a, !0) && (k && k.element && a && a.marker && void 0 !== a.marker.symbol && (q.graphic = k.destroy()), a && a.dataLabels && q.dataLabel && (q.dataLabel = q.dataLabel.destroy()), q.connector && (q.connector = q.connector.destroy()));
          g = q.index;
          l.updateParallelArrays(q, g);
          n.data[g] = e(n.data[g], !0) || e(a, !0) ? q.options : c(a, n.data[g]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (r.isDirtyBox = !0);
          "point" === n.legendType && (r.isDirtyLegend = !0);
          b && r.redraw(f)
        }
        var q = this,
          l = q.series,
          k = q.graphic,
          g, r = l.chart,
          n = l.options;
        b = c(b, !0);
        !1 === h ? d() : q.firePointEvent("update", {
          options: a
        }, d)
      },
      remove: function(a, b) {
        this.series.removePoint(l(this, this.series.data), a, b)
      }
    });
    u(w.prototype, {
      addPoint: function(a, b, f, e) {
        var d = this.options,
          h = this.data,
          q = this.chart,
          k = this.xAxis,
          k = k && k.hasNames && k.names,
          l = d.data,
          g, r, n = this.xData,
          x, t;
        b = c(b, !0);
        g = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(g, [a]);
        t = g.x;
        x = n.length;
        if (this.requireSorting && t < n[x - 1])
          for (r = !0; x && n[x - 1] > t;) x--;
        this.updateParallelArrays(g,
          "splice", x, 0, 0);
        this.updateParallelArrays(g, x);
        k && g.name && (k[t] = g.name);
        l.splice(x, 0, a);
        r && (this.data.splice(x, 0, null), this.processData());
        "point" === d.legendType && this.generatePoints();
        f && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(g, "shift"), l.shift()));
        this.isDirtyData = this.isDirty = !0;
        b && q.redraw(e)
      },
      removePoint: function(a, b, f) {
        var e = this,
          d = e.data,
          h = d[a],
          q = e.points,
          k = e.chart,
          l = function() {
            q && q.length === d.length && q.splice(a, 1);
            d.splice(a, 1);
            e.options.data.splice(a, 1);
            e.updateParallelArrays(h || {
              series: e
            }, "splice", a, 1);
            h && h.destroy();
            e.isDirty = !0;
            e.isDirtyData = !0;
            b && k.redraw()
          };
        r(f, k);
        b = c(b, !0);
        h ? h.firePointEvent("remove", null, l) : l()
      },
      remove: function(a, b, f) {
        function e() {
          d.destroy();
          h.isDirtyLegend = h.isDirtyBox = !0;
          h.linkSeries();
          c(a, !0) && h.redraw(b)
        }
        var d = this,
          h = d.chart;
        !1 !== f ? y(d, "remove", null, e) : e()
      },
      update: function(b, f) {
        var e = this,
          h = e.chart,
          d = e.userOptions,
          q = e.oldType || e.type,
          g = b.type || d.type || h.options.chart.type,
          k = D[q].prototype,
          r, t = ["group", "markerGroup", "dataLabelsGroup"],
          w = ["navigatorSeries",
            "baseSeries"
          ],
          m = e.finishedAnimating && {
            animation: !1
          },
          F = ["data", "name", "turboThreshold"],
          J = a.keys(b),
          p = 0 < J.length;
        v(J, function(a) {
          -1 === l(a, F) && (p = !1)
        });
        if (p) b.data && this.setData(b.data, !1), b.name && this.setName(b.name, !1);
        else {
          w = t.concat(w);
          v(w, function(a) {
            w[a] = e[a];
            delete e[a]
          });
          b = n(d, m, {
            index: e.index,
            pointStart: c(d.pointStart, e.xData[0])
          }, {
            data: e.options.data
          }, b);
          e.remove(!1, null, !1);
          for (r in k) e[r] = void 0;
          D[g || q] ? u(e, D[g || q].prototype) : a.error(17, !0);
          v(w, function(a) {
            e[a] = w[a]
          });
          e.init(h, b);
          b.zIndex !==
            d.zIndex && v(t, function(a) {
              e[a] && e[a].attr({
                zIndex: b.zIndex
              })
            });
          e.oldType = q;
          h.linkSeries()
        }
        y(this, "afterUpdate");
        c(f, !0) && h.redraw(!1)
      },
      setName: function(a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0
      }
    });
    u(G.prototype, {
      update: function(a, b) {
        var f = this.chart;
        a = n(this.userOptions, a);
        f.options[this.coll].indexOf && (f.options[this.coll][f.options[this.coll].indexOf(this.userOptions)] = a);
        this.destroy(!0);
        this.init(f, u(a, {
          events: void 0
        }));
        f.isDirtyBox = !0;
        c(b, !0) && f.redraw()
      },
      remove: function(a) {
        for (var b = this.chart, f = this.coll, e = this.series, d = e.length; d--;) e[d] && e[d].remove(!1);
        z(b.axes, this);
        z(b[f], this);
        t(b.options[f]) ? b.options[f].splice(this.options.index, 1) : delete b.options[f];
        v(b[f], function(a, b) {
          a.options.index = a.userOptions.index = b
        });
        this.destroy();
        b.isDirtyBox = !0;
        c(a, !0) && b.redraw()
      },
      setTitle: function(a, b) {
        this.update({
          title: a
        }, b)
      },
      setCategories: function(a, b) {
        this.update({
          categories: a
        }, b)
      }
    })
  })(L);
  (function(a) {
    var B = a.color,
      C = a.each,
      G = a.map,
      p = a.pick,
      m = a.Series,
      g = a.seriesType;
    g("area", "line", {
      softThreshold: !1,
      threshold: 0
    }, {
      singleStacks: !1,
      getStackPoints: function(g) {
        var m = [],
          u = [],
          v = this.xAxis,
          l = this.yAxis,
          b = l.stacks[this.stackKey],
          e = {},
          t = this.index,
          n = l.series,
          f = n.length,
          c, h = p(l.options.reversedStacks, !0) ? 1 : -1,
          w;
        g = g || this.points;
        if (this.options.stacking) {
          for (w = 0; w < g.length; w++) g[w].leftNull = g[w].rightNull = null, e[g[w].x] = g[w];
          a.objectEach(b, function(a, b) {
            null !== a.total && u.push(b)
          });
          u.sort(function(a, b) {
            return a - b
          });
          c = G(n, function() {
            return this.visible
          });
          C(u,
            function(a, g) {
              var r = 0,
                q, n;
              if (e[a] && !e[a].isNull) m.push(e[a]), C([-1, 1], function(l) {
                var r = 1 === l ? "rightNull" : "leftNull",
                  d = 0,
                  x = b[u[g + l]];
                if (x)
                  for (w = t; 0 <= w && w < f;) q = x.points[w], q || (w === t ? e[a][r] = !0 : c[w] && (n = b[a].points[w]) && (d -= n[1] - n[0])), w += h;
                e[a][1 === l ? "rightCliff" : "leftCliff"] = d
              });
              else {
                for (w = t; 0 <= w && w < f;) {
                  if (q = b[a].points[w]) {
                    r = q[1];
                    break
                  }
                  w += h
                }
                r = l.translate(r, 0, 1, 0, 1);
                m.push({
                  isNull: !0,
                  plotX: v.translate(a, 0, 0, 0, 1),
                  x: a,
                  plotY: r,
                  yBottom: r
                })
              }
            })
        }
        return m
      },
      getGraphPath: function(a) {
        var g = m.prototype.getGraphPath,
          u = this.options,
          v = u.stacking,
          l = this.yAxis,
          b, e, t = [],
          n = [],
          f = this.index,
          c, h = l.stacks[this.stackKey],
          w = u.threshold,
          D = l.getThreshold(u.threshold),
          r, u = u.connectNulls || "percent" === v,
          J = function(b, e, g) {
            var q = a[b];
            b = v && h[q.x].points[f];
            var d = q[g + "Null"] || 0;
            g = q[g + "Cliff"] || 0;
            var r, x, q = !0;
            g || d ? (r = (d ? b[0] : b[1]) + g, x = b[0] + g, q = !!d) : !v && a[e] && a[e].isNull && (r = x = w);
            void 0 !== r && (n.push({
              plotX: c,
              plotY: null === r ? D : l.getThreshold(r),
              isNull: q,
              isCliff: !0
            }), t.push({
              plotX: c,
              plotY: null === x ? D : l.getThreshold(x),
              doCurve: !1
            }))
          };
        a =
          a || this.points;
        v && (a = this.getStackPoints(a));
        for (b = 0; b < a.length; b++)
          if (e = a[b].isNull, c = p(a[b].rectPlotX, a[b].plotX), r = p(a[b].yBottom, D), !e || u) u || J(b, b - 1, "left"), e && !v && u || (n.push(a[b]), t.push({
            x: b,
            plotX: c,
            plotY: r
          })), u || J(b, b + 1, "right");
        b = g.call(this, n, !0, !0);
        t.reversed = !0;
        e = g.call(this, t, !0, !0);
        e.length && (e[0] = "L");
        e = b.concat(e);
        g = g.call(this, n, !1, u);
        e.xMap = b.xMap;
        this.areaPath = e;
        return g
      },
      drawGraph: function() {
        this.areaPath = [];
        m.prototype.drawGraph.apply(this);
        var a = this,
          g = this.areaPath,
          u = this.options,
          y = [
            ["area", "highcharts-area", this.color, u.fillColor]
          ];
        C(this.zones, function(g, b) {
          y.push(["zone-area-" + b, "highcharts-area highcharts-zone-area-" + b + " " + g.className, g.color || a.color, g.fillColor || u.fillColor])
        });
        C(y, function(l) {
          var b = l[0],
            e = a[b];
          e ? (e.endX = a.preventGraphAnimation ? null : g.xMap, e.animate({
            d: g
          })) : (e = a[b] = a.chart.renderer.path(g).addClass(l[1]).attr({
            fill: p(l[3], B(l[2]).setOpacity(p(u.fillOpacity, .75)).get()),
            zIndex: 0
          }).add(a.group), e.isArea = !0);
          e.startX = g.xMap;
          e.shiftUnit = u.step ? 2 : 1
        })
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
    })
  })(L);
  (function(a) {
    var B = a.pick;
    a = a.seriesType;
    a("spline", "line", {}, {
      getPointSpline: function(a, G, p) {
        var m = G.plotX,
          g = G.plotY,
          v = a[p - 1];
        p = a[p + 1];
        var z, u, y, l;
        if (v && !v.isNull && !1 !== v.doCurve && !G.isCliff && p && !p.isNull && !1 !== p.doCurve && !G.isCliff) {
          a = v.plotY;
          y = p.plotX;
          p = p.plotY;
          var b = 0;
          z = (1.5 * m + v.plotX) / 2.5;
          u = (1.5 * g + a) / 2.5;
          y = (1.5 * m + y) / 2.5;
          l = (1.5 * g + p) / 2.5;
          y !== z && (b = (l - u) * (y - m) / (y - z) + g - l);
          u += b;
          l += b;
          u > a && u > g ? (u = Math.max(a, g), l = 2 * g - u) : u < a && u < g && (u = Math.min(a, g), l = 2 * g - u);
          l > p && l > g ? (l = Math.max(p, g), u = 2 * g - l) : l < p && l < g &&
            (l = Math.min(p, g), u = 2 * g - l);
          G.rightContX = y;
          G.rightContY = l
        }
        G = ["C", B(v.rightContX, v.plotX), B(v.rightContY, v.plotY), B(z, m), B(u, g), m, g];
        v.rightContX = v.rightContY = null;
        return G
      }
    })
  })(L);
  (function(a) {
    var B = a.seriesTypes.area.prototype,
      C = a.seriesType;
    C("areaspline", "spline", a.defaultPlotOptions.area, {
      getStackPoints: B.getStackPoints,
      getGraphPath: B.getGraphPath,
      drawGraph: B.drawGraph,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
    })
  })(L);
  (function(a) {
    var B = a.animObject,
      C = a.color,
      G = a.each,
      p = a.extend,
      m = a.isNumber,
      g = a.merge,
      v = a.pick,
      z = a.Series,
      u = a.seriesType,
      y = a.svg;
    u("column", "line", {
      borderRadius: 0,
      crisp: !0,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1,
          brightness: .1
        },
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: "#ffffff"
    }, {
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function() {
        z.prototype.init.apply(this, arguments);
        var a = this,
          b = a.chart;
        b.hasRendered && G(b.series, function(b) {
          b.type === a.type && (b.isDirty = !0)
        })
      },
      getColumnMetrics: function() {
        var a = this,
          b = a.options,
          e = a.xAxis,
          g = a.yAxis,
          n = e.reversed,
          f, c = {},
          h = 0;
        !1 === b.grouping ? h = 1 : G(a.chart.series, function(b) {
          var e = b.options,
            l = b.yAxis,
            r;
          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== l.len || g.pos !== l.pos || (e.stacking ? (f = b.stackKey, void 0 === c[f] && (c[f] = h++), r = c[f]) : !1 !== e.grouping &&
            (r = h++), b.columnIndex = r)
        });
        var w = Math.min(Math.abs(e.transA) * (e.ordinalSlope || b.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),
          m = w * b.groupPadding,
          r = (w - 2 * m) / (h || 1),
          b = Math.min(b.maxPointWidth || e.len, v(b.pointWidth, r * (1 - 2 * b.pointPadding)));
        a.columnMetrics = {
          width: b,
          offset: (r - b) / 2 + (m + ((a.columnIndex || 0) + (n ? 1 : 0)) * r - w / 2) * (n ? -1 : 1)
        };
        return a.columnMetrics
      },
      crispCol: function(a, b, e, g) {
        var l = this.chart,
          f = this.borderWidth,
          c = -(f % 2 ? .5 : 0),
          f = f % 2 ? .5 : 1;
        l.inverted && l.renderer.isVML && (f += 1);
        this.options.crisp &&
          (e = Math.round(a + e) + c, a = Math.round(a) + c, e -= a);
        g = Math.round(b + g) + f;
        c = .5 >= Math.abs(b) && .5 < g;
        b = Math.round(b) + f;
        g -= b;
        c && g && (--b, g += 1);
        return {
          x: a,
          y: b,
          width: e,
          height: g
        }
      },
      translate: function() {
        var a = this,
          b = a.chart,
          e = a.options,
          g = a.dense = 2 > a.closestPointRange * a.xAxis.transA,
          g = a.borderWidth = v(e.borderWidth, g ? 0 : 1),
          n = a.yAxis,
          f = e.threshold,
          c = a.translatedThreshold = n.getThreshold(f),
          h = v(e.minPointLength, 5),
          w = a.getColumnMetrics(),
          m = w.width,
          r = a.barW = Math.max(m, 1 + 2 * g),
          J = a.pointXOffset = w.offset;
        b.inverted && (c -= .5);
        e.pointPadding &&
          (r = Math.ceil(r));
        z.prototype.translate.apply(a);
        G(a.points, function(e) {
          var g = v(e.yBottom, c),
            q = 999 + Math.abs(g),
            q = Math.min(Math.max(-q, e.plotY), n.len + q),
            l = e.plotX + J,
            d = r,
            t = Math.min(q, g),
            w, k = Math.max(q, g) - t;
          h && Math.abs(k) < h && (k = h, w = !n.reversed && !e.negative || n.reversed && e.negative, e.y === f && a.dataMax <= f && n.min < f && (w = !w), t = Math.abs(t - c) > h ? g - h : c - (w ? h : 0));
          e.barX = l;
          e.pointWidth = m;
          e.tooltipPos = b.inverted ? [n.len + n.pos - b.plotLeft - q, a.xAxis.len - l - d / 2, k] : [l + d / 2, q + n.pos - b.plotTop, k];
          e.shapeType = "rect";
          e.shapeArgs =
            a.crispCol.apply(a, e.isNull ? [l, c, d, 0] : [l, t, d, k])
        })
      },
      getSymbol: a.noop,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      drawGraph: function() {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data")
      },
      pointAttribs: function(a, b) {
        var e = this.options,
          l, n = this.pointAttrToOptions || {};
        l = n.stroke || "borderColor";
        var f = n["stroke-width"] || "borderWidth",
          c = a && a.color || this.color,
          h = a && a[l] || e[l] || this.color || c,
          w = a && a[f] || e[f] || this[f] || 0,
          n = e.dashStyle;
        a && this.zones.length && (c = a.getZone(), c = a.options.color ||
          c && c.color || this.color);
        b && (a = g(e.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, c = a.color || void 0 !== b && C(c).brighten(a.brightness).get() || c, h = a[l] || h, w = a[f] || w, n = a.dashStyle || n);
        l = {
          fill: c,
          stroke: h,
          "stroke-width": w
        };
        n && (l.dashstyle = n);
        return l
      },
      drawPoints: function() {
        var a = this,
          b = this.chart,
          e = a.options,
          t = b.renderer,
          n = e.animationLimit || 250,
          f;
        G(a.points, function(c) {
          var h = c.graphic,
            l = h && b.pointCount < n ? "animate" : "attr";
          if (m(c.plotY) && null !== c.y) {
            f = c.shapeArgs;
            if (h) h[l](g(f));
            else c.graphic =
              h = t[c.shapeType](f).add(c.group || a.group);
            e.borderRadius && h.attr({
              r: e.borderRadius
            });
            h[l](a.pointAttribs(c, c.selected && "select")).shadow(e.shadow, null, e.stacking && !e.borderRadius);
            h.addClass(c.getClassName(), !0)
          } else h && (c.graphic = h.destroy())
        })
      },
      animate: function(a) {
        var b = this,
          e = this.yAxis,
          g = b.options,
          l = this.chart.inverted,
          f = {},
          c = l ? "translateX" : "translateY",
          h;
        y && (a ? (f.scaleY = .001, a = Math.min(e.pos + e.len, Math.max(e.pos, e.toPixels(g.threshold))), l ? f.translateX = a - e.len : f.translateY = a, b.group.attr(f)) :
          (h = b.group.attr(c), b.group.animate({
            scaleY: 1
          }, p(B(b.options.animation), {
            step: function(a, g) {
              f[c] = h + g.pos * (e.pos - h);
              b.group.attr(f)
            }
          })), b.animate = null))
      },
      remove: function() {
        var a = this,
          b = a.chart;
        b.hasRendered && G(b.series, function(b) {
          b.type === a.type && (b.isDirty = !0)
        });
        z.prototype.remove.apply(a, arguments)
      }
    })
  })(L);
  (function(a) {
    a = a.seriesType;
    a("bar", "column", null, {
      inverted: !0
    })
  })(L);
  (function(a) {
    var B = a.Series;
    a = a.seriesType;
    a("scatter", "line", {
      lineWidth: 0,
      findNearestPointBy: "xy",
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',
        pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"
      }
    }, {
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      drawGraph: function() {
        this.options.lineWidth && B.prototype.drawGraph.call(this)
      }
    })
  })(L);
  (function(a) {
    var B = a.deg2rad,
      C = a.isNumber,
      G = a.pick,
      p = a.relativeLength;
    a.CenteredSeriesMixin = {
      getCenter: function() {
        var a = this.options,
          g = this.chart,
          v = 2 * (a.slicedOffset || 0),
          z = g.plotWidth - 2 * v,
          g = g.plotHeight - 2 * v,
          u = a.center,
          u = [G(u[0], "50%"), G(u[1], "50%"), a.size || "100%", a.innerSize || 0],
          y = Math.min(z, g),
          l, b;
        for (l = 0; 4 > l; ++l) b = u[l], a = 2 > l || 2 === l && /%$/.test(b), u[l] = p(b, [z, g, y, u[2]][l]) + (a ? v : 0);
        u[3] > u[2] && (u[3] = u[2]);
        return u
      },
      getStartAndEndRadians: function(a, g) {
        a = C(a) ? a : 0;
        g = C(g) && g > a && 360 > g - a ? g : a + 360;
        return {
          start: B * (a + -90),
          end: B * (g + -90)
        }
      }
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.CenteredSeriesMixin,
      G = a.defined,
      p = a.each,
      m = a.extend,
      g = C.getStartAndEndRadians,
      v = a.inArray,
      z = a.noop,
      u = a.pick,
      y = a.Point,
      l = a.Series,
      b = a.seriesType,
      e = a.setAnimation;
    b("pie", "line", {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        distance: 30,
        enabled: !0,
        formatter: function() {
          return this.point.isNull ? void 0 : this.point.name
        },
        x: 0
      },
      ignoreHiddenPoint: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      },
      borderColor: "#ffffff",
      borderWidth: 1,
      states: {
        hover: {
          brightness: .1
        }
      }
    }, {
      isCartesian: !1,
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group",
        "dataLabelsGroup"
      ],
      axisTypes: [],
      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
      animate: function(a) {
        var b = this,
          f = b.points,
          c = b.startAngleRad;
        a || (p(f, function(a) {
          var f = a.graphic,
            e = a.shapeArgs;
          f && (f.attr({
            r: a.startR || b.center[3] / 2,
            start: c,
            end: c
          }), f.animate({
            r: e.r,
            start: e.start,
            end: e.end
          }, b.options.animation))
        }), b.animate = null)
      },
      updateTotals: function() {
        var a, b = 0,
          f = this.points,
          c = f.length,
          e, g = this.options.ignoreHiddenPoint;
        for (a = 0; a < c; a++) e = f[a], b += g && !e.visible ? 0 : e.isNull ? 0 : e.y;
        this.total = b;
        for (a =
          0; a < c; a++) e = f[a], e.percentage = 0 < b && (e.visible || !g) ? e.y / b * 100 : 0, e.total = b
      },
      generatePoints: function() {
        l.prototype.generatePoints.call(this);
        this.updateTotals()
      },
      translate: function(a) {
        this.generatePoints();
        var b = 0,
          f = this.options,
          c = f.slicedOffset,
          e = c + (f.borderWidth || 0),
          l, m, r, t = g(f.startAngle, f.endAngle),
          q = this.startAngleRad = t.start,
          t = (this.endAngleRad = t.end) - q,
          F = this.points,
          x, p = f.dataLabels.distance,
          f = f.ignoreHiddenPoint,
          d, H = F.length,
          E;
        a || (this.center = a = this.getCenter());
        this.getX = function(b, d, c) {
          r = Math.asin(Math.min((b -
            a[1]) / (a[2] / 2 + c.labelDistance), 1));
          return a[0] + (d ? -1 : 1) * Math.cos(r) * (a[2] / 2 + c.labelDistance)
        };
        for (d = 0; d < H; d++) {
          E = F[d];
          E.labelDistance = u(E.options.dataLabels && E.options.dataLabels.distance, p);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, E.labelDistance);
          l = q + b * t;
          if (!f || E.visible) b += E.percentage / 100;
          m = q + b * t;
          E.shapeType = "arc";
          E.shapeArgs = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * l) / 1E3,
            end: Math.round(1E3 * m) / 1E3
          };
          r = (m + l) / 2;
          r > 1.5 * Math.PI ? r -= 2 * Math.PI : r < -Math.PI / 2 && (r += 2 * Math.PI);
          E.slicedTranslation = {
            translateX: Math.round(Math.cos(r) * c),
            translateY: Math.round(Math.sin(r) * c)
          };
          m = Math.cos(r) * a[2] / 2;
          x = Math.sin(r) * a[2] / 2;
          E.tooltipPos = [a[0] + .7 * m, a[1] + .7 * x];
          E.half = r < -Math.PI / 2 || r > Math.PI / 2 ? 1 : 0;
          E.angle = r;
          l = Math.min(e, E.labelDistance / 5);
          E.labelPos = [a[0] + m + Math.cos(r) * E.labelDistance, a[1] + x + Math.sin(r) * E.labelDistance, a[0] + m + Math.cos(r) * l, a[1] + x + Math.sin(r) * l, a[0] + m, a[1] + x, 0 > E.labelDistance ? "center" : E.half ? "right" : "left", r]
        }
      },
      drawGraph: null,
      drawPoints: function() {
        var a = this,
          b = a.chart.renderer,
          f, c, e, g, l = a.options.shadow;
        l && !a.shadowGroup && (a.shadowGroup = b.g("shadow").add(a.group));
        p(a.points, function(h) {
          c = h.graphic;
          if (h.isNull) c && (h.graphic = c.destroy());
          else {
            g = h.shapeArgs;
            f = h.getTranslate();
            var r = h.shadowGroup;
            l && !r && (r = h.shadowGroup = b.g("shadow").add(a.shadowGroup));
            r && r.attr(f);
            e = a.pointAttribs(h, h.selected && "select");
            c ? c.setRadialReference(a.center).attr(e).animate(m(g, f)) : (h.graphic = c = b[h.shapeType](g).setRadialReference(a.center).attr(f).add(a.group), h.visible || c.attr({
                visibility: "hidden"
              }),
              c.attr(e).attr({
                "stroke-linejoin": "round"
              }).shadow(l, r));
            c.addClass(h.getClassName())
          }
        })
      },
      searchPoint: z,
      sortByAngle: function(a, b) {
        a.sort(function(a, c) {
          return void 0 !== a.angle && (c.angle - a.angle) * b
        })
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      getCenter: C.getCenter,
      getSymbol: z
    }, {
      init: function() {
        y.prototype.init.apply(this, arguments);
        var a = this,
          b;
        a.name = u(a.name, "Slice");
        b = function(b) {
          a.slice("select" === b.type)
        };
        B(a, "select", b);
        B(a, "unselect", b);
        return a
      },
      isValid: function() {
        return a.isNumber(this.y,
          !0) && 0 <= this.y
      },
      setVisible: function(a, b) {
        var f = this,
          c = f.series,
          e = c.chart,
          g = c.options.ignoreHiddenPoint;
        b = u(b, g);
        a !== f.visible && (f.visible = f.options.visible = a = void 0 === a ? !f.visible : a, c.options.data[v(f, c.data)] = f.options, p(["graphic", "dataLabel", "connector", "shadowGroup"], function(b) {
          if (f[b]) f[b][a ? "show" : "hide"](!0)
        }), f.legendItem && e.legend.colorizeItem(f, a), a || "hover" !== f.state || f.setState(""), g && (c.isDirty = !0), b && e.redraw())
      },
      slice: function(a, b, f) {
        var c = this.series;
        e(f, c.chart);
        u(b, !0);
        this.sliced =
          this.options.sliced = G(a) ? a : !this.sliced;
        c.options.data[v(this, c.data)] = this.options;
        this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate())
      },
      getTranslate: function() {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        }
      },
      haloPath: function(a) {
        var b = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + a, b.r + a, {
          innerR: this.shapeArgs.r - 1,
          start: b.start,
          end: b.end
        })
      }
    })
  })(L);
  (function(a) {
    var B =
      a.addEvent,
      C = a.arrayMax,
      G = a.defined,
      p = a.each,
      m = a.extend,
      g = a.format,
      v = a.map,
      z = a.merge,
      u = a.noop,
      y = a.pick,
      l = a.relativeLength,
      b = a.Series,
      e = a.seriesTypes,
      t = a.some,
      n = a.stableSort;
    a.distribute = function(b, c, e) {
      function f(a, b) {
        return a.target - b.target
      }
      var h, g = !0,
        l = b,
        q = [],
        m;
      m = 0;
      var x = l.reducedLen || c;
      for (h = b.length; h--;) m += b[h].size;
      if (m > x) {
        n(b, function(a, b) {
          return (b.rank || 0) - (a.rank || 0)
        });
        for (m = h = 0; m <= x;) m += b[h].size, h++;
        q = b.splice(h - 1, b.length)
      }
      n(b, f);
      for (b = v(b, function(a) {
          return {
            size: a.size,
            targets: [a.target],
            align: y(a.align, .5)
          }
        }); g;) {
        for (h = b.length; h--;) g = b[h], m = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = Math.min(Math.max(0, m - g.size * g.align), c - g.size);
        h = b.length;
        for (g = !1; h--;) 0 < h && b[h - 1].pos + b[h - 1].size > b[h].pos && (b[h - 1].size += b[h].size, b[h - 1].targets = b[h - 1].targets.concat(b[h].targets), b[h - 1].align = .5, b[h - 1].pos + b[h - 1].size > c && (b[h - 1].pos = c - b[h - 1].size), b.splice(h, 1), g = !0)
      }
      l.push.apply(l, q);
      h = 0;
      t(b, function(b) {
        var d = 0;
        if (t(b.targets, function() {
            l[h].pos = b.pos + d;
            if (Math.abs(l[h].pos -
                l[h].target) > e) return p(l.slice(0, h + 1), function(a) {
              delete a.pos
            }), l.reducedLen = (l.reducedLen || c) - .1 * c, l.reducedLen > .1 * c && a.distribute(l, c, e), !0;
            d += l[h].size;
            h++
          })) return !0
      });
      n(l, f)
    };
    b.prototype.drawDataLabels = function() {
      function b(a, b) {
        var d = b.filter;
        return d ? (b = d.operator, a = a[d.property], d = d.value, "\x3e" === b && a > d || "\x3c" === b && a < d || "\x3e\x3d" === b && a >= d || "\x3c\x3d" === b && a <= d || "\x3d\x3d" === b && a == d || "\x3d\x3d\x3d" === b && a === d ? !0 : !1) : !0
      }
      var c = this,
        e = c.chart,
        l = c.options,
        n = l.dataLabels,
        r = c.points,
        m, q, t =
        c.hasRendered || 0,
        x, u, d = y(n.defer, !!l.animation),
        H = e.renderer;
      if (n.enabled || c._hasPointLabels) c.dlProcessOptions && c.dlProcessOptions(n), u = c.plotGroup("dataLabelsGroup", "data-labels", d && !t ? "hidden" : "visible", n.zIndex || 6), d && (u.attr({
        opacity: +t
      }), t || B(c, "afterAnimate", function() {
        c.visible && u.show(!0);
        u[l.animation ? "animate" : "attr"]({
          opacity: 1
        }, {
          duration: 200
        })
      })), q = n, p(r, function(d) {
        var f, h = d.dataLabel,
          r, w, t = d.connector,
          F = !h,
          E;
        m = d.dlOptions || d.options && d.options.dataLabels;
        (f = y(m && m.enabled, q.enabled) &&
          !d.isNull) && (f = !0 === b(d, m || n));
        f && (n = z(q, m), r = d.getLabelConfig(), E = n[d.formatPrefix + "Format"] || n.format, x = G(E) ? g(E, r, e.time) : (n[d.formatPrefix + "Formatter"] || n.formatter).call(r, n), E = n.style, r = n.rotation, E.color = y(n.color, E.color, c.color, "#000000"), "contrast" === E.color && (d.contrastColor = H.getContrast(d.color || c.color), E.color = n.inside || 0 > y(d.labelDistance, n.distance) || l.stacking ? d.contrastColor : "#000000"), l.cursor && (E.cursor = l.cursor), w = {
          fill: n.backgroundColor,
          stroke: n.borderColor,
          "stroke-width": n.borderWidth,
          r: n.borderRadius || 0,
          rotation: r,
          padding: n.padding,
          zIndex: 1
        }, a.objectEach(w, function(a, b) {
          void 0 === a && delete w[b]
        }));
        !h || f && G(x) ? f && G(x) && (h ? w.text = x : (h = d.dataLabel = r ? H.text(x, 0, -9999).addClass("highcharts-data-label") : H.label(x, 0, -9999, n.shape, null, null, n.useHTML, null, "data-label"), h.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (n.className || "") + (n.useHTML ? "highcharts-tracker" : ""))), h.attr(w), h.css(E).shadow(n.shadow), h.added || h.add(u), c.alignDataLabel(d, h, n, null, F)) : (d.dataLabel = h = h.destroy(),
          t && (d.connector = t.destroy()))
      });
      a.fireEvent(this, "afterDrawDataLabels")
    };
    b.prototype.alignDataLabel = function(a, b, e, g, l) {
      var c = this.chart,
        f = c.inverted,
        h = y(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
        n = y(a.plotY, -9999),
        x = b.getBBox(),
        w, d = e.rotation,
        t = e.align,
        E = this.visible && (a.series.forceDL || c.isInsidePlot(h, Math.round(n), f) || g && c.isInsidePlot(h, f ? g.x + 1 : g.y + g.height - 1, f)),
        k = "justify" === y(e.overflow, "justify");
      if (E && (w = e.style.fontSize, w = c.renderer.fontMetrics(w, b).b, g = m({
          x: f ? this.yAxis.len - n : h,
          y: Math.round(f ?
            this.xAxis.len - h : n),
          width: 0,
          height: 0
        }, g), m(e, {
          width: x.width,
          height: x.height
        }), d ? (k = !1, h = c.renderer.rotCorr(w, d), h = {
          x: g.x + e.x + g.width / 2 + h.x,
          y: g.y + e.y + {
            top: 0,
            middle: .5,
            bottom: 1
          } [e.verticalAlign] * g.height
        }, b[l ? "attr" : "animate"](h).attr({
          align: t
        }), n = (d + 720) % 360, n = 180 < n && 360 > n, "left" === t ? h.y -= n ? x.height : 0 : "center" === t ? (h.x -= x.width / 2, h.y -= x.height / 2) : "right" === t && (h.x -= x.width, h.y -= n ? 0 : x.height), b.placed = !0, b.alignAttr = h) : (b.align(e, null, g), h = b.alignAttr), k ? a.isLabelJustified = this.justifyDataLabel(b, e,
          h, x, g, l) : y(e.crop, !0) && (E = c.isInsidePlot(h.x, h.y) && c.isInsidePlot(h.x + x.width, h.y + x.height)), e.shape && !d)) b[l ? "attr" : "animate"]({
        anchorX: f ? c.plotWidth - a.plotY : a.plotX,
        anchorY: f ? c.plotHeight - a.plotX : a.plotY
      });
      E || (b.attr({
        y: -9999
      }), b.placed = !1)
    };
    b.prototype.justifyDataLabel = function(a, b, e, g, l, r) {
      var c = this.chart,
        f = b.align,
        h = b.verticalAlign,
        n, m, d = a.box ? 0 : a.padding || 0;
      n = e.x + d;
      0 > n && ("right" === f ? b.align = "left" : b.x = -n, m = !0);
      n = e.x + g.width - d;
      n > c.plotWidth && ("left" === f ? b.align = "right" : b.x = c.plotWidth - n, m = !0);
      n = e.y + d;
      0 > n && ("bottom" === h ? b.verticalAlign = "top" : b.y = -n, m = !0);
      n = e.y + g.height - d;
      n > c.plotHeight && ("top" === h ? b.verticalAlign = "bottom" : b.y = c.plotHeight - n, m = !0);
      m && (a.placed = !r, a.align(b, null, l));
      return m
    };
    e.pie && (e.pie.prototype.drawDataLabels = function() {
      var f = this,
        c = f.data,
        e, g = f.chart,
        l = f.options.dataLabels,
        r = y(l.connectorPadding, 10),
        n = y(l.connectorWidth, 1),
        q = g.plotWidth,
        m = g.plotHeight,
        x = Math.round(g.chartWidth / 3),
        t, d = f.center,
        H = d[2] / 2,
        E = d[1],
        k, A, u, v, z = [
          [],
          []
        ],
        B, N, M, S, O = [0, 0, 0, 0];
      f.visible && (l.enabled ||
        f._hasPointLabels) && (p(c, function(a) {
          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), a.dataLabel.shortened = !1)
        }), b.prototype.drawDataLabels.apply(f), p(c, function(a) {
          a.dataLabel && a.visible && (z[a.half].push(a), a.dataLabel._pos = null, !G(l.style.width) && !G(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > x && (a.dataLabel.css({
            width: .7 * x
          }), a.dataLabel.shortened = !0))
        }),
        p(z, function(b, c) {
          var h, n, x = b.length,
            t = [],
            w;
          if (x)
            for (f.sortByAngle(b, c - .5), 0 < f.maxLabelDistance && (h = Math.max(0, E - H - f.maxLabelDistance), n = Math.min(E + H + f.maxLabelDistance, g.plotHeight), p(b, function(a) {
                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, E - H - a.labelDistance), a.bottom = Math.min(E + H + a.labelDistance, g.plotHeight), w = a.dataLabel.getBBox().height || 21, a.positionsIndex = t.push({
                  target: a.labelPos[1] - a.top + w / 2,
                  size: w,
                  rank: a.y
                }) - 1)
              }), h = n + w - h, a.distribute(t, h, h / 5)), S = 0; S < x; S++) e = b[S], n = e.positionsIndex,
              u = e.labelPos, k = e.dataLabel, M = !1 === e.visible ? "hidden" : "inherit", N = h = u[1], t && G(t[n]) && (void 0 === t[n].pos ? M = "hidden" : (v = t[n].size, N = e.top + t[n].pos)), delete e.positionIndex, B = l.justify ? d[0] + (c ? -1 : 1) * (H + e.labelDistance) : f.getX(N < e.top + 2 || N > e.bottom - 2 ? h : N, c, e), k._attr = {
                visibility: M,
                align: u[6]
              }, k._pos = {
                x: B + l.x + ({
                  left: r,
                  right: -r
                } [u[6]] || 0),
                y: N + l.y - 10
              }, u.x = B, u.y = N, y(l.crop, !0) && (A = k.getBBox().width, h = null, B - A < r && 1 === c ? (h = Math.round(A - B + r), O[3] = Math.max(h, O[3])) : B + A > q - r && 0 === c && (h = Math.round(B + A - q + r), O[1] =
                Math.max(h, O[1])), 0 > N - v / 2 ? O[0] = Math.max(Math.round(-N + v / 2), O[0]) : N + v / 2 > m && (O[2] = Math.max(Math.round(N + v / 2 - m), O[2])), k.sideOverflow = h)
        }), 0 === C(O) || this.verifyDataLabelOverflow(O)) && (this.placeDataLabels(), n && p(this.points, function(a) {
        var b;
        t = a.connector;
        if ((k = a.dataLabel) && k._pos && a.visible && 0 < a.labelDistance) {
          M = k._attr.visibility;
          if (b = !t) a.connector = t = g.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(f.dataLabelsGroup),
            t.attr({
              "stroke-width": n,
              stroke: l.connectorColor || a.color || "#666666"
            });
          t[b ? "attr" : "animate"]({
            d: f.connectorPath(a.labelPos)
          });
          t.attr("visibility", M)
        } else t && (a.connector = t.destroy())
      }))
    }, e.pie.prototype.connectorPath = function(a) {
      var b = a.x,
        f = a.y;
      return y(this.options.dataLabels.softConnector, !0) ? ["M", b + ("left" === a[6] ? 5 : -5), f, "C", b, f, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5]] : ["M", b + ("left" === a[6] ? 5 : -5), f, "L", a[2], a[3], "L", a[4], a[5]]
    }, e.pie.prototype.placeDataLabels = function() {
      p(this.points, function(a) {
        var b =
          a.dataLabel;
        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({
          width: b._attr.width + "px",
          textOverflow: this.options.dataLabels.style.textOverflow || "ellipsis"
        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({
          y: -9999
        }))
      }, this)
    }, e.pie.prototype.alignDataLabel = u, e.pie.prototype.verifyDataLabelOverflow = function(a) {
      var b = this.center,
        e = this.options,
        f = e.center,
        g = e.minSize || 80,
        r, n = null !== e.size;
      n || (null !== f[0] ? r = Math.max(b[2] -
        Math.max(a[1], a[3]), g) : (r = Math.max(b[2] - a[1] - a[3], g), b[0] += (a[3] - a[1]) / 2), null !== f[1] ? r = Math.max(Math.min(r, b[2] - Math.max(a[0], a[2])), g) : (r = Math.max(Math.min(r, b[2] - a[0] - a[2]), g), b[1] += (a[0] - a[2]) / 2), r < b[2] ? (b[2] = r, b[3] = Math.min(l(e.innerSize || 0, r), r), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : n = !0);
      return n
    });
    e.column && (e.column.prototype.alignDataLabel = function(a, c, e, g, l) {
      var f = this.chart.inverted,
        h = a.series,
        q = a.dlBox || a.shapeArgs,
        n = y(a.below, a.plotY > y(this.translatedThreshold,
          h.yAxis.len)),
        m = y(e.inside, !!this.options.stacking);
      q && (g = z(q), 0 > g.y && (g.height += g.y, g.y = 0), q = g.y + g.height - h.yAxis.len, 0 < q && (g.height -= q), f && (g = {
        x: h.yAxis.len - g.y - g.height,
        y: h.xAxis.len - g.x - g.width,
        width: g.height,
        height: g.width
      }), m || (f ? (g.x += n ? 0 : g.width, g.width = 0) : (g.y += n ? g.height : 0, g.height = 0)));
      e.align = y(e.align, !f || m ? "center" : n ? "right" : "left");
      e.verticalAlign = y(e.verticalAlign, f || m ? "middle" : n ? "top" : "bottom");
      b.prototype.alignDataLabel.call(this, a, c, e, g, l);
      a.isLabelJustified && a.contrastColor && a.dataLabel.css({
        color: a.contrastColor
      })
    })
  })(L);
  (function(a) {
    var B = a.Chart,
      C = a.each,
      G = a.objectEach,
      p = a.pick;
    a = a.addEvent;
    a(B, "render", function() {
      var a = [];
      C(this.labelCollectors || [], function(g) {
        a = a.concat(g())
      });
      C(this.yAxis || [], function(g) {
        g.options.stackLabels && !g.options.stackLabels.allowOverlap && G(g.stacks, function(g) {
          G(g, function(g) {
            a.push(g.label)
          })
        })
      });
      C(this.series || [], function(g) {
        var m = g.options.dataLabels,
          z = g.dataLabelCollections || ["dataLabel"];
        (m.enabled || g._hasPointLabels) && !m.allowOverlap && g.visible && C(z, function(m) {
          C(g.points, function(g) {
            g[m] &&
              (g[m].labelrank = p(g.labelrank, g.shapeArgs && g.shapeArgs.height), a.push(g[m]))
          })
        })
      });
      this.hideOverlappingLabels(a)
    });
    B.prototype.hideOverlappingLabels = function(a) {
      var g = a.length,
        m, p, u, y, l, b, e, t, n, f = function(a, b, e, f, g, l, q, n) {
          return !(g > a + e || g + q < a || l > b + f || l + n < b)
        };
      for (p = 0; p < g; p++)
        if (m = a[p]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.width || (u = m.getBBox(), m.width = u.width, m.height = u.height);
      a.sort(function(a, b) {
        return (b.labelrank || 0) - (a.labelrank || 0)
      });
      for (p = 0; p < g; p++)
        for (u = a[p], m = p + 1; m < g; ++m)
          if (y = a[m], u && y &&
            u !== y && u.placed && y.placed && 0 !== u.newOpacity && 0 !== y.newOpacity && (l = u.alignAttr, b = y.alignAttr, e = u.parentGroup, t = y.parentGroup, n = 2 * (u.box ? 0 : u.padding || 0), l = f(l.x + e.translateX, l.y + e.translateY, u.width - n, u.height - n, b.x + t.translateX, b.y + t.translateY, y.width - n, y.height - n)))(u.labelrank < y.labelrank ? u : y).newOpacity = 0;
      C(a, function(a) {
        var b, c;
        a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function() {
          a.hide()
        }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), a.isOld = !0)
      })
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.Chart,
      G = a.createElement,
      p = a.css,
      m = a.defaultOptions,
      g = a.defaultPlotOptions,
      v = a.each,
      z = a.extend,
      u = a.fireEvent,
      y = a.hasTouch,
      l = a.inArray,
      b = a.isObject,
      e = a.Legend,
      t = a.merge,
      n = a.pick,
      f = a.Point,
      c = a.Series,
      h = a.seriesTypes,
      w = a.svg,
      D;
    D = a.TrackerMixin = {
      drawTrackerPoint: function() {
        var a = this,
          b = a.chart.pointer,
          c = function(a) {
            var c = b.getPointFromEvent(a);
            void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a))
          };
        v(a.points, function(a) {
          a.graphic && (a.graphic.element.point = a);
          a.dataLabel &&
            (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a)
        });
        a._hasTracking || (v(a.trackerGroups, function(e) {
          if (a[e]) {
            a[e].addClass("highcharts-tracker").on("mouseover", c).on("mouseout", function(a) {
              b.onTrackerMouseOut(a)
            });
            if (y) a[e].on("touchstart", c);
            a.options.cursor && a[e].css(p).css({
              cursor: a.options.cursor
            })
          }
        }), a._hasTracking = !0);
        u(this, "afterDrawTracker")
      },
      drawTrackerGraph: function() {
        var a = this,
          b = a.options,
          c = b.trackByArea,
          e = [].concat(c ? a.areaPath : a.graphPath),
          f = e.length,
          h = a.chart,
          d =
          h.pointer,
          g = h.renderer,
          l = h.options.tooltip.snap,
          k = a.tracker,
          n, m = function() {
            if (h.hoverSeries !== a) a.onMouseOver()
          },
          t = "rgba(192,192,192," + (w ? .0001 : .002) + ")";
        if (f && !c)
          for (n = f + 1; n--;) "M" === e[n] && e.splice(n + 1, 0, e[n + 1] - l, e[n + 2], "L"), (n && "M" === e[n] || n === f) && e.splice(n, 0, "L", e[n - 2] + l, e[n - 1]);
        k ? k.attr({
          d: e
        }) : a.graph && (a.tracker = g.path(e).attr({
          "stroke-linejoin": "round",
          visibility: a.visible ? "visible" : "hidden",
          stroke: t,
          fill: c ? t : "none",
          "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * l),
          zIndex: 2
        }).add(a.group), v([a.tracker,
          a.markerGroup
        ], function(a) {
          a.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function(a) {
            d.onTrackerMouseOut(a)
          });
          b.cursor && a.css({
            cursor: b.cursor
          });
          if (y) a.on("touchstart", m)
        }));
        u(this, "afterDrawTracker")
      }
    };
    h.column && (h.column.prototype.drawTracker = D.drawTrackerPoint);
    h.pie && (h.pie.prototype.drawTracker = D.drawTrackerPoint);
    h.scatter && (h.scatter.prototype.drawTracker = D.drawTrackerPoint);
    z(e.prototype, {
      setItemEvents: function(a, b, c) {
        var e = this,
          h = e.chart.renderer.boxWrapper,
          g = "highcharts-legend-" +
          (a instanceof f ? "point" : "series") + "-active";
        (c ? b : a.legendGroup).on("mouseover", function() {
          a.setState("hover");
          h.addClass(g);
          b.css(e.options.itemHoverStyle)
        }).on("mouseout", function() {
          b.css(t(a.visible ? e.itemStyle : e.itemHiddenStyle));
          h.removeClass(g);
          a.setState()
        }).on("click", function(b) {
          var d = function() {
            a.setVisible && a.setVisible()
          };
          h.removeClass(g);
          b = {
            browserEvent: b
          };
          a.firePointEvent ? a.firePointEvent("legendItemClick", b, d) : u(a, "legendItemClick", b, d)
        })
      },
      createCheckboxForItem: function(a) {
        a.checkbox =
          G("input", {
            type: "checkbox",
            checked: a.selected,
            defaultChecked: a.selected
          }, this.options.itemCheckboxStyle, this.chart.container);
        B(a.checkbox, "click", function(b) {
          u(a.series || a, "checkboxClick", {
            checked: b.target.checked,
            item: a
          }, function() {
            a.select()
          })
        })
      }
    });
    m.legend.itemStyle.cursor = "pointer";
    z(C.prototype, {
      showResetZoom: function() {
        function a() {
          b.zoomOut()
        }
        var b = this,
          c = m.lang,
          e = b.options.chart.resetZoomButton,
          f = e.theme,
          h = f.states,
          d = "chart" === e.relativeTo ? null : "plotBox";
        u(this, "beforeShowResetZoom", null,
          function() {
            b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, f, h && h.hover).attr({
              align: e.position.align,
              title: c.resetZoomTitle
            }).addClass("highcharts-reset-zoom").add().align(e.position, !1, d)
          })
      },
      zoomOut: function() {
        u(this, "selection", {
          resetSelection: !0
        }, this.zoom)
      },
      zoom: function(a) {
        var c, e = this.pointer,
          f = !1,
          h;
        !a || a.resetSelection ? (v(this.axes, function(a) {
          c = a.zoom()
        }), e.initiated = !1) : v(a.xAxis.concat(a.yAxis), function(a) {
          var b = a.axis;
          e[b.isXAxis ? "zoomX" : "zoomY"] && (c = b.zoom(a.min, a.max), b.displayBtn &&
            (f = !0))
        });
        h = this.resetZoomButton;
        f && !h ? this.showResetZoom() : !f && b(h) && (this.resetZoomButton = h.destroy());
        c && this.redraw(n(this.options.chart.animation, a && a.animation, 100 > this.pointCount))
      },
      pan: function(a, b) {
        var c = this,
          e = c.hoverPoints,
          f;
        e && v(e, function(a) {
          a.setState()
        });
        v("xy" === b ? [1, 0] : [1], function(b) {
          b = c[b ? "xAxis" : "yAxis"][0];
          var d = b.horiz,
            e = a[d ? "chartX" : "chartY"],
            d = d ? "mouseDownX" : "mouseDownY",
            h = c[d],
            k = (b.pointRange || 0) / 2,
            g = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,
            l = b.getExtremes(),
            n = b.toValue(h - e, !0) + k * g,
            g = b.toValue(h + b.len - e, !0) - k * g,
            q = g < n,
            h = q ? g : n,
            n = q ? n : g,
            g = Math.min(l.dataMin, k ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),
            k = Math.max(l.dataMax, k ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),
            q = g - h;
          0 < q && (n += q, h = g);
          q = n - k;
          0 < q && (n = k, h -= q);
          b.series.length && h !== l.min && n !== l.max && (b.setExtremes(h, n, !1, !1, {
            trigger: "pan"
          }), f = !0);
          c[d] = e
        });
        f && c.redraw(!1);
        p(c.container, {
          cursor: "move"
        })
      }
    });
    z(f.prototype, {
      select: function(a, b) {
        var c = this,
          e = c.series,
          f = e.chart;
        a = n(a, !c.selected);
        c.firePointEvent(a ? "select" : "unselect", {
          accumulate: b
        }, function() {
          c.selected = c.options.selected = a;
          e.options.data[l(c, e.data)] = c.options;
          c.setState(a && "select");
          b || v(f.getSelectedPoints(), function(a) {
            a.selected && a !== c && (a.selected = a.options.selected = !1, e.options.data[l(a, e.data)] = a.options, a.setState(""), a.firePointEvent("unselect"))
          })
        })
      },
      onMouseOver: function(a) {
        var b = this.series.chart,
          c = b.pointer;
        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);
        c.runPointActions(a, this)
      },
      onMouseOut: function() {
        var a =
          this.series.chart;
        this.firePointEvent("mouseOut");
        v(a.hoverPoints || [], function(a) {
          a.setState()
        });
        a.hoverPoints = a.hoverPoint = null
      },
      importEvents: function() {
        if (!this.hasImportedEvents) {
          var b = this,
            c = t(b.series.options.point, b.options).events;
          b.events = c;
          a.objectEach(c, function(a, c) {
            B(b, c, a)
          });
          this.hasImportedEvents = !0
        }
      },
      setState: function(a, b) {
        var c = Math.floor(this.plotX),
          e = this.plotY,
          f = this.series,
          h = f.options.states[a || "normal"] || {},
          d = g[f.type].marker && f.options.marker,
          l = d && !1 === d.enabled,
          r = d && d.states &&
          d.states[a || "normal"] || {},
          k = !1 === r.enabled,
          m = f.stateMarkerGraphic,
          t = this.marker || {},
          w = f.chart,
          p = f.halo,
          D, v = d && f.markerAttribs;
        a = a || "";
        if (!(a === this.state && !b || this.selected && "select" !== a || !1 === h.enabled || a && (k || l && !1 === r.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {
          v && (D = f.markerAttribs(this, a));
          if (this.graphic) this.state && this.graphic.removeClass("highcharts-point-" + this.state), a && this.graphic.addClass("highcharts-point-" + a), this.graphic.animate(f.pointAttribs(this, a), n(w.options.chart.animation,
            h.animation)), D && this.graphic.animate(D, n(w.options.chart.animation, r.animation, d.animation)), m && m.hide();
          else {
            if (a && r) {
              d = t.symbol || f.symbol;
              m && m.currentSymbol !== d && (m = m.destroy());
              if (m) m[b ? "animate" : "attr"]({
                x: D.x,
                y: D.y
              });
              else d && (f.stateMarkerGraphic = m = w.renderer.symbol(d, D.x, D.y, D.width, D.height).add(f.markerGroup), m.currentSymbol = d);
              m && m.attr(f.pointAttribs(this, a))
            }
            m && (m[a && w.isInsidePlot(c, e, w.inverted) ? "show" : "hide"](), m.element.point = this)
          }(c = h.halo) && c.size ? (p || (f.halo = p = w.renderer.path().add((this.graphic ||
            m).parentGroup)), p.show()[b ? "animate" : "attr"]({
            d: this.haloPath(c.size)
          }), p.attr({
            "class": "highcharts-halo highcharts-color-" + n(this.colorIndex, f.colorIndex) + (this.className ? " " + this.className : "")
          }), p.point = this, p.attr(z({
            fill: this.color || f.color,
            "fill-opacity": c.opacity,
            zIndex: -1
          }, c.attributes))) : p && p.point && p.point.haloPath && p.animate({
            d: p.point.haloPath(0)
          }, null, p.hide);
          this.state = a;
          u(this, "afterSetState")
        }
      },
      haloPath: function(a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) -
          a, this.plotY - a, 2 * a, 2 * a)
      }
    });
    z(c.prototype, {
      onMouseOver: function() {
        var a = this.chart,
          b = a.hoverSeries;
        if (b && b !== this) b.onMouseOut();
        this.options.events.mouseOver && u(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this
      },
      onMouseOut: function() {
        var a = this.options,
          b = this.chart,
          c = b.tooltip,
          e = b.hoverPoint;
        b.hoverSeries = null;
        if (e) e.onMouseOut();
        this && a.events.mouseOut && u(this, "mouseOut");
        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
        this.setState()
      },
      setState: function(a) {
        var b = this,
          c = b.options,
          e = b.graph,
          f = c.states,
          h = c.lineWidth,
          c = 0;
        a = a || "";
        if (b.state !== a && (v([b.group, b.markerGroup, b.dataLabelsGroup], function(d) {
            d && (b.state && d.removeClass("highcharts-series-" + b.state), a && d.addClass("highcharts-series-" + a))
          }), b.state = a, !f[a] || !1 !== f[a].enabled) && (a && (h = f[a].lineWidth || h + (f[a].lineWidthPlus || 0)), e && !e.dashstyle))
          for (h = {
              "stroke-width": h
            }, e.animate(h, n(f[a || "normal"] && f[a || "normal"].animation, b.chart.options.chart.animation)); b["zone-graph-" + c];) b["zone-graph-" + c].attr(h), c += 1
      },
      setVisible: function(a, b) {
        var c = this,
          e = c.chart,
          f = c.legendItem,
          h, d = e.options.chart.ignoreHiddenSeries,
          g = c.visible;
        h = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !g : a) ? "show" : "hide";
        v(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function(a) {
          if (c[a]) c[a][h]()
        });
        if (e.hoverSeries === c || (e.hoverPoint && e.hoverPoint.series) === c) c.onMouseOut();
        f && e.legend.colorizeItem(c, a);
        c.isDirty = !0;
        c.options.stacking && v(e.series, function(a) {
          a.options.stacking && a.visible && (a.isDirty = !0)
        });
        v(c.linkedSeries,
          function(b) {
            b.setVisible(a, !1)
          });
        d && (e.isDirtyBox = !0);
        !1 !== b && e.redraw();
        u(c, h)
      },
      show: function() {
        this.setVisible(!0)
      },
      hide: function() {
        this.setVisible(!1)
      },
      select: function(a) {
        this.selected = a = void 0 === a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        u(this, a ? "select" : "unselect")
      },
      drawTracker: D.drawTrackerGraph
    })
  })(L);
  (function(a) {
    var B = a.Chart,
      C = a.each,
      G = a.inArray,
      p = a.isArray,
      m = a.isObject,
      g = a.pick,
      v = a.splat;
    B.prototype.setResponsive = function(g) {
      var m = this.options.responsive,
        p = [],
        l = this.currentResponsive;
      m && m.rules && C(m.rules, function(b) {
        void 0 === b._id && (b._id = a.uniqueKey());
        this.matchResponsiveRule(b, p, g)
      }, this);
      var b = a.merge.apply(0, a.map(p, function(b) {
          return a.find(m.rules, function(a) {
            return a._id === b
          }).chartOptions
        })),
        p = p.toString() || void 0;
      p !== (l && l.ruleIds) && (l && this.update(l.undoOptions, g), p ? (this.currentResponsive = {
        ruleIds: p,
        mergedOptions: b,
        undoOptions: this.currentOptions(b)
      }, this.update(b, g)) : this.currentResponsive = void 0)
    };
    B.prototype.matchResponsiveRule = function(a, m) {
      var p = a.condition;
      (p.callback || function() {
        return this.chartWidth <= g(p.maxWidth, Number.MAX_VALUE) && this.chartHeight <= g(p.maxHeight, Number.MAX_VALUE) && this.chartWidth >= g(p.minWidth, 0) && this.chartHeight >= g(p.minHeight, 0)
      }).call(this) && m.push(a._id)
    };
    B.prototype.currentOptions = function(g) {
      function u(g, b, e, t) {
        var l;
        a.objectEach(g, function(a, c) {
          if (!t && -1 < G(c, ["series", "xAxis", "yAxis"]))
            for (a = v(a), e[c] = [], l = 0; l < a.length; l++) b[c][l] && (e[c][l] = {}, u(a[l], b[c][l], e[c][l], t + 1));
          else m(a) ? (e[c] = p(a) ? [] : {}, u(a, b[c] || {}, e[c], t + 1)) :
            e[c] = b[c] || null
        })
      }
      var y = {};
      u(g, this.options, y, 0);
      return y
    }
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.Axis,
      G = a.Chart,
      p = a.css,
      m = a.defined,
      g = a.each,
      v = a.extend,
      z = a.noop,
      u = a.pick,
      y = a.timeUnits,
      l = a.wrap;
    l(a.Series.prototype, "init", function(a) {
      var b;
      a.apply(this, Array.prototype.slice.call(arguments, 1));
      (b = this.xAxis) && b.options.ordinal && B(this, "updatedData", function() {
        delete b.ordinalIndex
      })
    });
    l(C.prototype, "getTimeTicks", function(a, e, g, l, f, c, h, w) {
      var b = 0,
        n, t, q = {},
        p, x, u, d = [],
        H = -Number.MAX_VALUE,
        E = this.options.tickPixelInterval,
        k = this.chart.time;
      if (!this.options.ordinal && !this.options.breaks || !c || 3 > c.length || void 0 === g) return a.call(this, e, g, l, f);
      x = c.length;
      for (n = 0; n < x; n++) {
        u = n && c[n - 1] > l;
        c[n] < g && (b = n);
        if (n === x - 1 || c[n + 1] - c[n] > 5 * h || u) {
          if (c[n] > H) {
            for (t = a.call(this, e, c[b], c[n], f); t.length && t[0] <= H;) t.shift();
            t.length && (H = t[t.length - 1]);
            d = d.concat(t)
          }
          b = n + 1
        }
        if (u) break
      }
      a = t.info;
      if (w && a.unitRange <= y.hour) {
        n = d.length - 1;
        for (b = 1; b < n; b++) k.dateFormat("%d", d[b]) !== k.dateFormat("%d", d[b - 1]) && (q[d[b]] = "day", p = !0);
        p && (q[d[0]] = "day");
        a.higherRanks =
          q
      }
      d.info = a;
      if (w && m(E)) {
        w = k = d.length;
        n = [];
        var A;
        for (p = []; w--;) b = this.translate(d[w]), A && (p[w] = A - b), n[w] = A = b;
        p.sort();
        p = p[Math.floor(p.length / 2)];
        p < .6 * E && (p = null);
        w = d[k - 1] > l ? k - 1 : k;
        for (A = void 0; w--;) b = n[w], l = Math.abs(A - b), A && l < .8 * E && (null === p || l < .8 * p) ? (q[d[w]] && !q[d[w + 1]] ? (l = w + 1, A = b) : l = w, d.splice(l, 1)) : A = b
      }
      return d
    });
    v(C.prototype, {
      beforeSetTickPositions: function() {
        var a, e = [],
          l = !1,
          n, f = this.getExtremes(),
          c = f.min,
          h = f.max,
          w, p = this.isXAxis && !!this.options.breaks,
          f = this.options.ordinal,
          r = Number.MAX_VALUE,
          v = this.chart.options.chart.ignoreHiddenSeries;
        n = "highcharts-navigator-xaxis" === this.options.className;
        !this.options.overscroll || this.max !== this.dataMax || this.chart.mouseIsDown && !n || this.eventArgs && (!this.eventArgs || "navigator" === this.eventArgs.trigger) || (this.max += this.options.overscroll, !n && m(this.userMin) && (this.min += this.options.overscroll));
        if (f || p) {
          g(this.series, function(b, c) {
            if (!(v && !1 === b.visible || !1 === b.takeOrdinalPosition && !p) && (e = e.concat(b.processedXData), a = e.length, e.sort(function(a, b) {
                return a -
                  b
              }), r = Math.min(r, u(b.closestPointRange, r)), a))
              for (c = a - 1; c--;) e[c] === e[c + 1] && e.splice(c, 1)
          });
          a = e.length;
          if (2 < a) {
            n = e[1] - e[0];
            for (w = a - 1; w-- && !l;) e[w + 1] - e[w] !== n && (l = !0);
            !this.options.keepOrdinalPadding && (e[0] - c > n || h - e[e.length - 1] > n) && (l = !0)
          } else this.options.overscroll && (2 === a ? r = e[1] - e[0] : 1 === a ? (r = this.options.overscroll, e = [e[0], e[0] + r]) : r = this.overscrollPointsRange);
          l ? (this.options.overscroll && (this.overscrollPointsRange = r, e = e.concat(this.getOverscrollPositions())), this.ordinalPositions = e, n = this.ordinal2lin(Math.max(c,
            e[0]), !0), w = Math.max(this.ordinal2lin(Math.min(h, e[e.length - 1]), !0), 1), this.ordinalSlope = h = (h - c) / (w - n), this.ordinalOffset = c - n * h) : (this.overscrollPointsRange = u(this.closestPointRange, this.overscrollPointsRange), this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0)
        }
        this.isOrdinal = f && l;
        this.groupIntervalFactor = null
      },
      val2lin: function(a, e) {
        var b = this.ordinalPositions;
        if (b) {
          var g = b.length,
            f, c;
          for (f = g; f--;)
            if (b[f] === a) {
              c = f;
              break
            } for (f = g - 1; f--;)
            if (a > b[f] || 0 === f) {
              a = (a - b[f]) / (b[f + 1] - b[f]);
              c = f +
                a;
              break
            } e = e ? c : this.ordinalSlope * (c || 0) + this.ordinalOffset
        } else e = a;
        return e
      },
      lin2val: function(a, e) {
        var b = this.ordinalPositions;
        if (b) {
          var g = this.ordinalSlope,
            f = this.ordinalOffset,
            c = b.length - 1,
            h;
          if (e) 0 > a ? a = b[0] : a > c ? a = b[c] : (c = Math.floor(a), h = a - c);
          else
            for (; c--;)
              if (e = g * c + f, a >= e) {
                g = g * (c + 1) + f;
                h = (a - e) / (g - e);
                break
              } return void 0 !== h && void 0 !== b[c] ? b[c] + (h ? h * (b[c + 1] - b[c]) : 0) : a
        }
        return a
      },
      getExtendedPositions: function() {
        var a = this,
          e = a.chart,
          l = a.series[0].currentDataGrouping,
          n = a.ordinalIndex,
          f = l ? l.count + l.unitName :
          "raw",
          c = a.options.overscroll,
          h = a.getExtremes(),
          m, p;
        n || (n = a.ordinalIndex = {});
        n[f] || (m = {
          series: [],
          chart: e,
          getExtremes: function() {
            return {
              min: h.dataMin,
              max: h.dataMax + c
            }
          },
          options: {
            ordinal: !0
          },
          val2lin: C.prototype.val2lin,
          ordinal2lin: C.prototype.ordinal2lin
        }, g(a.series, function(b) {
          p = {
            xAxis: m,
            xData: b.xData.slice(),
            chart: e,
            destroyGroupedData: z
          };
          p.xData = p.xData.concat(a.getOverscrollPositions());
          p.options = {
            dataGrouping: l ? {
              enabled: !0,
              forced: !0,
              approximation: "open",
              units: [
                [l.unitName, [l.count]]
              ]
            } : {
              enabled: !1
            }
          };
          b.processData.apply(p);
          m.series.push(p)
        }), a.beforeSetTickPositions.apply(m), n[f] = m.ordinalPositions);
        return n[f]
      },
      getOverscrollPositions: function() {
        var b = this.options.overscroll,
          e = this.overscrollPointsRange,
          g = [],
          l = this.dataMax;
        if (a.defined(e))
          for (g.push(l); l <= this.dataMax + b;) l += e, g.push(l);
        return g
      },
      getGroupIntervalFactor: function(a, e, g) {
        var b;
        g = g.processedXData;
        var f = g.length,
          c = [];
        b = this.groupIntervalFactor;
        if (!b) {
          for (b = 0; b < f - 1; b++) c[b] = g[b + 1] - g[b];
          c.sort(function(a, b) {
            return a - b
          });
          c = c[Math.floor(f /
            2)];
          a = Math.max(a, g[0]);
          e = Math.min(e, g[f - 1]);
          this.groupIntervalFactor = b = f * c / (e - a)
        }
        return b
      },
      postProcessTickInterval: function(a) {
        var b = this.ordinalSlope;
        return b ? this.options.breaks ? this.closestPointRange || a : a / (b / this.closestPointRange) : a
      }
    });
    C.prototype.ordinal2lin = C.prototype.val2lin;
    l(G.prototype, "pan", function(a, e) {
      var b = this.xAxis[0],
        l = b.options.overscroll,
        f = e.chartX,
        c = !1;
      if (b.options.ordinal && b.series.length) {
        var h = this.mouseDownX,
          m = b.getExtremes(),
          u = m.dataMax,
          r = m.min,
          v = m.max,
          q = this.hoverPoints,
          F = b.closestPointRange || b.overscrollPointsRange,
          h = (h - f) / (b.translationSlope * (b.ordinalSlope || F)),
          x = {
            ordinalPositions: b.getExtendedPositions()
          },
          F = b.lin2val,
          y = b.val2lin,
          d;
        x.ordinalPositions ? 1 < Math.abs(h) && (q && g(q, function(a) {
            a.setState()
          }), 0 > h ? (q = x, d = b.ordinalPositions ? b : x) : (q = b.ordinalPositions ? b : x, d = x), x = d.ordinalPositions, u > x[x.length - 1] && x.push(u), this.fixedRange = v - r, h = b.toFixedRange(null, null, F.apply(q, [y.apply(q, [r, !0]) + h, !0]), F.apply(d, [y.apply(d, [v, !0]) + h, !0])), h.min >= Math.min(m.dataMin, r) &&
          h.max <= Math.max(u, v) + l && b.setExtremes(h.min, h.max, !0, !1, {
            trigger: "pan"
          }), this.mouseDownX = f, p(this.container, {
            cursor: "move"
          })) : c = !0
      } else c = !0;
      c && (l && (b.max = b.dataMax + l), a.apply(this, Array.prototype.slice.call(arguments, 1)))
    })
  })(L);
  (function(a) {
    function B() {
      return Array.prototype.slice.call(arguments, 1)
    }

    function C(a) {
      a.apply(this);
      this.drawBreaks(this.xAxis, ["x"]);
      this.drawBreaks(this.yAxis, p(this.pointArrayMap, ["y"]))
    }
    var G = a.addEvent,
      p = a.pick,
      m = a.wrap,
      g = a.each,
      v = a.extend,
      z = a.isArray,
      u = a.fireEvent,
      y = a.Axis,
      l = a.Series;
    v(y.prototype, {
      isInBreak: function(a, e) {
        var b = a.repeat || Infinity,
          g = a.from,
          f = a.to - a.from;
        e = e >= g ? (e - g) % b : b - (g - e) % b;
        return a.inclusive ? e <= f : e < f && 0 !== e
      },
      isInAnyBreak: function(a, e) {
        var b = this.options.breaks,
          g = b && b.length,
          f, c, h;
        if (g) {
          for (; g--;) this.isInBreak(b[g], a) && (f = !0, c || (c = p(b[g].showPoints, this.isXAxis ? !1 : !0)));
          h = f && e ? f && !c : f
        }
        return h
      }
    });
    G(y, "afterSetTickPositions", function() {
      if (this.options.breaks) {
        var a = this.tickPositions,
          e = this.tickPositions.info,
          g = [],
          l;
        for (l = 0; l < a.length; l++) this.isInAnyBreak(a[l]) ||
          g.push(a[l]);
        this.tickPositions = g;
        this.tickPositions.info = e
      }
    });
    G(y, "afterSetOptions", function() {
      this.options.breaks && this.options.breaks.length && (this.options.ordinal = !1)
    });
    G(y, "afterInit", function() {
      var a = this,
        e;
      e = this.options.breaks;
      a.isBroken = z(e) && !!e.length;
      a.isBroken && (a.val2lin = function(b) {
        var e = b,
          f, c;
        for (c = 0; c < a.breakArray.length; c++)
          if (f = a.breakArray[c], f.to <= b) e -= f.len;
          else if (f.from >= b) break;
        else if (a.isInBreak(f, b)) {
          e -= b - f.from;
          break
        }
        return e
      }, a.lin2val = function(b) {
        var e, f;
        for (f = 0; f < a.breakArray.length &&
          !(e = a.breakArray[f], e.from >= b); f++) e.to < b ? b += e.len : a.isInBreak(e, b) && (b += e.len);
        return b
      }, a.setExtremes = function(a, b, e, c, h) {
        for (; this.isInAnyBreak(a);) a -= this.closestPointRange;
        for (; this.isInAnyBreak(b);) b -= this.closestPointRange;
        y.prototype.setExtremes.call(this, a, b, e, c, h)
      }, a.setAxisTranslation = function(b) {
        y.prototype.setAxisTranslation.call(this, b);
        b = a.options.breaks;
        var e = [],
          f = [],
          c = 0,
          h, l, m = a.userMin || a.min,
          r = a.userMax || a.max,
          t = p(a.pointRangePadding, 0),
          q, v;
        g(b, function(b) {
          l = b.repeat || Infinity;
          a.isInBreak(b,
            m) && (m += b.to % l - m % l);
          a.isInBreak(b, r) && (r -= r % l - b.from % l)
        });
        g(b, function(a) {
          q = a.from;
          for (l = a.repeat || Infinity; q - l > m;) q -= l;
          for (; q < m;) q += l;
          for (v = q; v < r; v += l) e.push({
            value: v,
            move: "in"
          }), e.push({
            value: v + (a.to - a.from),
            move: "out",
            size: a.breakSize
          })
        });
        e.sort(function(a, b) {
          return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value
        });
        h = 0;
        q = m;
        g(e, function(a) {
          h += "in" === a.move ? 1 : -1;
          1 === h && "in" === a.move && (q = a.value);
          0 === h && (f.push({
              from: q,
              to: a.value,
              len: a.value - q - (a.size || 0)
            }), c += a.value - q -
            (a.size || 0))
        });
        a.breakArray = f;
        a.unitLength = r - m - c + t;
        u(a, "afterBreaks");
        a.options.staticScale ? a.transA = a.options.staticScale : a.unitLength && (a.transA *= (r - a.min + t) / a.unitLength);
        t && (a.minPixelPadding = a.transA * a.minPointOffset);
        a.min = m;
        a.max = r
      })
    });
    m(l.prototype, "generatePoints", function(a) {
      a.apply(this, B(arguments));
      var b = this.xAxis,
        g = this.yAxis,
        l = this.points,
        f, c = l.length,
        h = this.options.connectNulls,
        m;
      if (b && g && (b.options.breaks || g.options.breaks))
        for (; c--;) f = l[c], m = null === f.y && !1 === h, m || !b.isInAnyBreak(f.x,
          !0) && !g.isInAnyBreak(f.y, !0) || (l.splice(c, 1), this.data[c] && this.data[c].destroyElements())
    });
    a.Series.prototype.drawBreaks = function(a, e) {
      var b = this,
        l = b.points,
        f, c, h, m;
      a && g(e, function(e) {
        f = a.breakArray || [];
        c = a.isXAxis ? a.min : p(b.options.threshold, a.min);
        g(l, function(b) {
          m = p(b["stack" + e.toUpperCase()], b[e]);
          g(f, function(e) {
            h = !1;
            if (c < e.from && m > e.to || c > e.from && m < e.from) h = "pointBreak";
            else if (c < e.from && m > e.from && m < e.to || c > e.from && m > e.to && m < e.from) h = "pointInBreak";
            h && u(a, h, {
              point: b,
              brk: e
            })
          })
        })
      })
    };
    a.Series.prototype.gappedPath =
      function() {
        var b = this.currentDataGrouping,
          e = b && b.totalRange,
          b = this.options.gapSize,
          g = this.points.slice(),
          l = g.length - 1,
          f = this.yAxis;
        if (b && 0 < l)
          for ("value" !== this.options.gapUnit && (b *= this.closestPointRange), e && e > b && (b = e); l--;) g[l + 1].x - g[l].x > b && (e = (g[l].x + g[l + 1].x) / 2, g.splice(l + 1, 0, {
            isNull: !0,
            x: e
          }), this.options.stacking && (e = f.stacks[this.stackKey][e] = new a.StackItem(f, f.options.stackLabels, !1, e, this.stack), e.total = 0));
        return this.getGraphPath(g)
      };
    m(a.seriesTypes.column.prototype, "drawPoints", C);
    m(a.Series.prototype,
      "drawPoints", C)
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.arrayMax,
      G = a.arrayMin,
      p = a.Axis,
      m = a.defaultPlotOptions,
      g = a.defined,
      v = a.each,
      z = a.extend,
      u = a.format,
      y = a.isNumber,
      l = a.merge,
      b = a.pick,
      e = a.Point,
      t = a.Series,
      n = a.Tooltip,
      f = a.wrap,
      c = t.prototype,
      h = c.processData,
      w = c.generatePoints,
      D = {
        approximation: "average",
        groupPixelWidth: 2,
        dateTimeLabelFormats: {
          millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"],
          second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"],
          minute: ["%A, %b %e, %H:%M",
            "%A, %b %e, %H:%M", "-%H:%M"
          ],
          hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"],
          day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
          week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"],
          month: ["%B %Y", "%B", "-%B %Y"],
          year: ["%Y", "%Y", "-%Y"]
        }
      },
      r = {
        line: {},
        spline: {},
        area: {},
        areaspline: {},
        column: {
          approximation: "sum",
          groupPixelWidth: 10
        },
        arearange: {
          approximation: "range"
        },
        areasplinerange: {
          approximation: "range"
        },
        columnrange: {
          approximation: "range",
          groupPixelWidth: 10
        },
        candlestick: {
          approximation: "ohlc",
          groupPixelWidth: 10
        },
        ohlc: {
          approximation: "ohlc",
          groupPixelWidth: 5
        }
      },
      J = a.defaultDataGroupingUnits = [
        ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
        ["second", [1, 2, 5, 10, 15, 30]],
        ["minute", [1, 2, 5, 10, 15, 30]],
        ["hour", [1, 2, 3, 4, 6, 8, 12]],
        ["day", [1]],
        ["week", [1]],
        ["month", [1, 3, 6]],
        ["year", null]
      ],
      q = a.approximations = {
        sum: function(a) {
          var b = a.length,
            c;
          if (!b && a.hasNulls) c = null;
          else if (b)
            for (c = 0; b--;) c += a[b];
          return c
        },
        average: function(a) {
          var b = a.length;
          a = q.sum(a);
          y(a) && b && (a /= b);
          return a
        },
        averages: function() {
          var a = [];
          v(arguments, function(b) {
            a.push(q.average(b))
          });
          return void 0 === a[0] ? void 0 : a
        },
        open: function(a) {
          return a.length ? a[0] : a.hasNulls ? null : void 0
        },
        high: function(a) {
          return a.length ? C(a) : a.hasNulls ? null : void 0
        },
        low: function(a) {
          return a.length ? G(a) : a.hasNulls ? null : void 0
        },
        close: function(a) {
          return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0
        },
        ohlc: function(a, b, c, d) {
          a = q.open(a);
          b = q.high(b);
          c = q.low(c);
          d = q.close(d);
          if (y(a) || y(b) || y(c) || y(d)) return [a, b, c, d]
        },
        range: function(a, b) {
          a = q.low(a);
          b = q.high(b);
          if (y(a) ||
            y(b)) return [a, b];
          if (null === a && null === b) return null
        }
      };
    c.groupData = function(a, b, c, d) {
      var e = this.data,
        f = this.options.data,
        k = [],
        h = [],
        g = [],
        l = a.length,
        m, n, p = !!b,
        w = [];
      d = "function" === typeof d ? d : q[d] || r[this.type] && q[r[this.type].approximation] || q[D.approximation];
      var x = this.pointArrayMap,
        t = x && x.length,
        u = 0;
      n = 0;
      var F, z;
      t ? v(x, function() {
        w.push([])
      }) : w.push([]);
      F = t || 1;
      for (z = 0; z <= l && !(a[z] >= c[0]); z++);
      for (z; z <= l; z++) {
        for (; void 0 !== c[u + 1] && a[z] >= c[u + 1] || z === l;) {
          m = c[u];
          this.dataGroupInfo = {
            start: n,
            length: w[0].length
          };
          n = d.apply(this, w);
          void 0 !== n && (k.push(m), h.push(n), g.push(this.dataGroupInfo));
          n = z;
          for (m = 0; m < F; m++) w[m].length = 0, w[m].hasNulls = !1;
          u += 1;
          if (z === l) break
        }
        if (z === l) break;
        if (x) {
          m = this.cropStart + z;
          var J = e && e[m] || this.pointClass.prototype.applyOptions.apply({
              series: this
            }, [f[m]]),
            B;
          for (m = 0; m < t; m++) B = J[x[m]], y(B) ? w[m].push(B) : null === B && (w[m].hasNulls = !0)
        } else m = p ? b[z] : null, y(m) ? w[0].push(m) : null === m && (w[0].hasNulls = !0)
      }
      return [k, h, g]
    };
    c.processData = function() {
      var a = this.chart,
        e = this.options.dataGrouping,
        f = !1 !==
        this.allowDG && e && b(e.enabled, a.options.isStock),
        d = this.visible || !a.options.chart.ignoreHiddenSeries,
        l, m = this.currentDataGrouping,
        k;
      this.forceCrop = f;
      this.groupPixelWidth = null;
      this.hasProcessed = !0;
      if (!1 !== h.apply(this, arguments) && f) {
        this.destroyGroupedData();
        var n, q = e.groupAll ? this.xData : this.processedXData,
          r = e.groupAll ? this.yData : this.processedYData,
          p = a.plotSizeX,
          a = this.xAxis,
          w = a.options.ordinal,
          t = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();
        if (t) {
          this.isDirty = l = !0;
          this.points =
            null;
          f = a.getExtremes();
          k = f.min;
          f = f.max;
          w = w && a.getGroupIntervalFactor(k, f, this) || 1;
          t = t * (f - k) / p * w;
          p = a.getTimeTicks(a.normalizeTimeTickInterval(t, e.units || J), Math.min(k, q[0]), Math.max(f, q[q.length - 1]), a.options.startOfWeek, q, this.closestPointRange);
          r = c.groupData.apply(this, [q, r, p, e.approximation]);
          q = r[0];
          w = r[1];
          if (e.smoothed && q.length) {
            n = q.length - 1;
            for (q[n] = Math.min(q[n], f); n-- && 0 < n;) q[n] += t / 2;
            q[0] = Math.max(q[0], k)
          }
          k = p.info;
          this.closestPointRange = p.info.totalRange;
          this.groupMap = r[2];
          g(q[0]) && q[0] < a.dataMin &&
            d && (a.min <= a.dataMin && (a.min = q[0]), a.dataMin = q[0]);
          e.groupAll && (e = this.cropData(q, w, a.min, a.max, 1), q = e.xData, w = e.yData);
          this.processedXData = q;
          this.processedYData = w
        } else this.groupMap = null;
        this.hasGroupedData = l;
        this.currentDataGrouping = k;
        this.preventGraphAnimation = (m && m.totalRange) !== (k && k.totalRange)
      }
    };
    c.destroyGroupedData = function() {
      var a = this.groupedData;
      v(a || [], function(b, c) {
        b && (a[c] = b.destroy ? b.destroy() : null)
      });
      this.groupedData = null
    };
    c.generatePoints = function() {
      w.apply(this);
      this.destroyGroupedData();
      this.groupedData = this.hasGroupedData ? this.points : null
    };
    B(e, "update", function() {
      if (this.dataGroup) return a.error(24), !1
    });
    f(n.prototype, "tooltipFooterHeaderFormatter", function(a, b, c) {
      var d = this.chart.time,
        e = b.series,
        f = e.tooltipOptions,
        k = e.options.dataGrouping,
        h = f.xDateFormat,
        g, l = e.xAxis;
      return l && "datetime" === l.options.type && k && y(b.key) ? (a = e.currentDataGrouping, k = k.dateTimeLabelFormats, a ? (l = k[a.unitName], 1 === a.count ? h = l[0] : (h = l[1], g = l[2])) : !h && k && (h = this.getXDateFormat(b, f, l)), h = d.dateFormat(h, b.key),
        g && (h += d.dateFormat(g, b.key + a.totalRange - 1)), u(f[(c ? "footer" : "header") + "Format"], {
          point: z(b.point, {
            key: h
          }),
          series: e
        }, d)) : a.call(this, b, c)
    });
    B(t, "destroy", c.destroyGroupedData);
    B(t, "afterSetOptions", function(a) {
      a = a.options;
      var b = this.type,
        c = this.chart.options.plotOptions,
        d = m[b].dataGrouping,
        e = this.useCommonDataGrouping && D;
      if (r[b] || e) d || (d = l(D, r[b])), a.dataGrouping = l(e, d, c.series && c.series.dataGrouping, c[b].dataGrouping, this.userOptions.dataGrouping);
      this.chart.options.isStock && (this.requireSorting = !0)
    });
    B(p, "afterSetScale", function() {
      v(this.series, function(a) {
        a.hasProcessed = !1
      })
    });
    p.prototype.getGroupPixelWidth = function() {
      var a = this.series,
        b = a.length,
        c, d = 0,
        e = !1,
        f;
      for (c = b; c--;)(f = a[c].options.dataGrouping) && (d = Math.max(d, f.groupPixelWidth));
      for (c = b; c--;)(f = a[c].options.dataGrouping) && a[c].hasProcessed && (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / d || b && f.forced) && (e = !0);
      return e ? d : 0
    };
    p.prototype.setDataGrouping = function(a, c) {
      var e;
      c = b(c, !0);
      a || (a = {
        forced: !1,
        units: null
      });
      if (this instanceof p)
        for (e = this.series.length; e--;) this.series[e].update({
          dataGrouping: a
        }, !1);
      else v(this.chart.options.series, function(b) {
        b.dataGrouping = a
      }, !1);
      this.ordinalSlope = null;
      c && this.chart.redraw()
    }
  })(L);
  (function(a) {
    var B = a.each,
      C = a.Point,
      G = a.seriesType,
      p = a.seriesTypes;
    G("ohlc", "column", {
      lineWidth: 1,
      tooltip: {
        pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cb\x3e {series.name}\x3c/b\x3e\x3cbr/\x3eOpen: {point.open}\x3cbr/\x3eHigh: {point.high}\x3cbr/\x3eLow: {point.low}\x3cbr/\x3eClose: {point.close}\x3cbr/\x3e'
      },
      threshold: null,
      states: {
        hover: {
          lineWidth: 3
        }
      },
      stickyTracking: !0
    }, {
      directTouch: !1,
      pointArrayMap: ["open", "high", "low", "close"],
      toYData: function(a) {
        return [a.open, a.high, a.low, a.close]
      },
      pointValKey: "close",
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      },
      pointAttribs: function(a, g) {
        g = p.column.prototype.pointAttribs.call(this, a, g);
        var m = this.options;
        delete g.fill;
        !a.options.color && m.upColor && a.open < a.close && (g.stroke = m.upColor);
        return g
      },
      translate: function() {
        var a = this,
          g = a.yAxis,
          v = !!a.modifyValue,
          z = ["plotOpen", "plotHigh", "plotLow", "plotClose", "yBottom"];
        p.column.prototype.translate.apply(a);
        B(a.points, function(m) {
          B([m.open, m.high, m.low, m.close, m.low], function(p, l) {
            null !== p && (v && (p = a.modifyValue(p)), m[z[l]] = g.toPixels(p, !0))
          });
          m.tooltipPos[1] = m.plotHigh + g.pos - a.chart.plotTop
        })
      },
      drawPoints: function() {
        var a = this,
          g = a.chart;
        B(a.points, function(m) {
          var p, u, v, l, b = m.graphic,
            e, t = !b;
          void 0 !== m.plotY && (b || (m.graphic = b = g.renderer.path().add(a.group)), b.attr(a.pointAttribs(m, m.selected && "select")), u = b.strokeWidth() %
            2 / 2, e = Math.round(m.plotX) - u, v = Math.round(m.shapeArgs.width / 2), l = ["M", e, Math.round(m.yBottom), "L", e, Math.round(m.plotHigh)], null !== m.open && (p = Math.round(m.plotOpen) + u, l.push("M", e, p, "L", e - v, p)), null !== m.close && (p = Math.round(m.plotClose) + u, l.push("M", e, p, "L", e + v, p)), b[t ? "attr" : "animate"]({
              d: l
            }).addClass(m.getClassName(), !0))
        })
      },
      animate: null
    }, {
      getClassName: function() {
        return C.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down")
      }
    })
  })(L);
  (function(a) {
    var B =
      a.defaultPlotOptions,
      C = a.each,
      G = a.merge,
      p = a.seriesType,
      m = a.seriesTypes;
    p("candlestick", "ohlc", G(B.column, {
      states: {
        hover: {
          lineWidth: 2
        }
      },
      tooltip: B.ohlc.tooltip,
      threshold: null,
      lineColor: "#000000",
      lineWidth: 1,
      upColor: "#ffffff",
      stickyTracking: !0
    }), {
      pointAttribs: function(a, p) {
        var g = m.column.prototype.pointAttribs.call(this, a, p),
          u = this.options,
          v = a.open < a.close,
          l = u.lineColor || this.color;
        g["stroke-width"] = u.lineWidth;
        g.fill = a.options.color || (v ? u.upColor || this.color : this.color);
        g.stroke = a.lineColor || (v ? u.upLineColor ||
          l : l);
        p && (a = u.states[p], g.fill = a.color || g.fill, g.stroke = a.lineColor || g.stroke, g["stroke-width"] = a.lineWidth || g["stroke-width"]);
        return g
      },
      drawPoints: function() {
        var a = this,
          m = a.chart;
        C(a.points, function(g) {
          var p = g.graphic,
            v, l, b, e, t, n, f, c = !p;
          void 0 !== g.plotY && (p || (g.graphic = p = m.renderer.path().add(a.group)), p.attr(a.pointAttribs(g, g.selected && "select")).shadow(a.options.shadow), t = p.strokeWidth() % 2 / 2, n = Math.round(g.plotX) - t, v = g.plotOpen, l = g.plotClose, b = Math.min(v, l), v = Math.max(v, l), f = Math.round(g.shapeArgs.width /
            2), l = Math.round(b) !== Math.round(g.plotHigh), e = v !== g.yBottom, b = Math.round(b) + t, v = Math.round(v) + t, t = [], t.push("M", n - f, v, "L", n - f, b, "L", n + f, b, "L", n + f, v, "Z", "M", n, b, "L", n, l ? Math.round(g.plotHigh) : b, "M", n, v, "L", n, e ? Math.round(g.yBottom) : v), p[c ? "attr" : "animate"]({
            d: t
          }).addClass(g.getClassName(), !0))
        })
      }
    })
  })(L);
  da = function(a) {
    var B = a.each,
      C = a.defined,
      G = a.seriesTypes,
      p = a.stableSort;
    return {
      getPlotBox: function() {
        return a.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) ||
          this)
      },
      translate: function() {
        G.column.prototype.translate.apply(this);
        var a = this.options,
          g = this.chart,
          v = this.points,
          z = v.length - 1,
          u, y, l = a.onSeries,
          l = l && g.get(l),
          a = a.onKey || "y",
          b = l && l.options.step,
          e = l && l.points,
          t = e && e.length,
          n = g.inverted,
          f = this.xAxis,
          c = this.yAxis,
          h = 0,
          w, D, r, J;
        if (l && l.visible && t)
          for (h = (l.pointXOffset || 0) + (l.barW || 0) / 2, u = l.currentDataGrouping, D = e[t - 1].x + (u ? u.totalRange : 0), p(v, function(a, b) {
              return a.x - b.x
            }), a = "plot" + a[0].toUpperCase() + a.substr(1); t-- && v[z] && !(w = e[t], u = v[z], u.y = w.y, w.x <=
              u.x && void 0 !== w[a] && (u.x <= D && (u.plotY = w[a], w.x < u.x && !b && (r = e[t + 1]) && void 0 !== r[a] && (J = (u.x - w.x) / (r.x - w.x), u.plotY += J * (r[a] - w[a]), u.y += J * (r.y - w.y))), z--, t++, 0 > z)););
        B(v, function(a, b) {
          var e;
          a.plotX += h;
          if (void 0 === a.plotY || n) 0 <= a.plotX && a.plotX <= f.len ? n ? (a.plotY = f.translate(a.x, 0, 1, 0, 1), a.plotX = C(a.y) ? c.translate(a.y, 0, 0, 0, 1) : 0) : a.plotY = g.chartHeight - f.bottom - (f.opposite ? f.height : 0) + f.offset - c.top : a.shapeArgs = {};
          (y = v[b - 1]) && y.plotX === a.plotX && (void 0 === y.stackIndex && (y.stackIndex = 0), e = y.stackIndex + 1);
          a.stackIndex = e
        });
        this.onSeries = l
      }
    }
  }(L);
  (function(a, B) {
    function C(a) {
      l[a + "pin"] = function(b, g, m, f, c) {
        var e = c && c.anchorX;
        c = c && c.anchorY;
        "circle" === a && f > m && (b -= Math.round((f - m) / 2), m = f);
        b = l[a](b, g, m, f);
        e && c && (b.push("M", "circle" === a ? b[1] - b[4] : b[1] + b[4] / 2, g > c ? g : g + f, "L", e, c), b = b.concat(l.circle(e - 1, c - 1, 2, 2)));
        return b
      }
    }
    var G = a.addEvent,
      p = a.each,
      m = a.merge,
      g = a.noop,
      v = a.Renderer,
      z = a.seriesType,
      u = a.TrackerMixin,
      y = a.VMLRenderer,
      l = a.SVGRenderer.prototype.symbols;
    z("flags", "column", {
      pointRange: 0,
      allowOverlapX: !1,
      shape: "flag",
      stackDistance: 12,
      textAlign: "center",
      tooltip: {
        pointFormat: "{point.text}\x3cbr/\x3e"
      },
      threshold: null,
      y: -30,
      fillColor: "#ffffff",
      lineWidth: 1,
      states: {
        hover: {
          lineColor: "#000000",
          fillColor: "#ccd6eb"
        }
      },
      style: {
        fontSize: "11px",
        fontWeight: "bold"
      }
    }, {
      sorted: !1,
      noSharedTooltip: !0,
      allowDG: !1,
      takeOrdinalPosition: !1,
      trackerGroups: ["markerGroup"],
      forceCrop: !0,
      init: a.Series.prototype.init,
      pointAttribs: function(a, e) {
        var b = this.options,
          g = a && a.color || this.color,
          f = b.lineColor,
          c = a && a.lineWidth;
        a = a && a.fillColor ||
          b.fillColor;
        e && (a = b.states[e].fillColor, f = b.states[e].lineColor, c = b.states[e].lineWidth);
        return {
          fill: a || g,
          stroke: f || g,
          "stroke-width": c || b.lineWidth || 0
        }
      },
      translate: B.translate,
      getPlotBox: B.getPlotBox,
      drawPoints: function() {
        var b = this.points,
          e = this.chart,
          g = e.renderer,
          l, f, c = e.inverted,
          h = this.options,
          w = h.y,
          u, r, v, q, y, x, z = this.yAxis,
          d = {},
          H = [];
        for (r = b.length; r--;) v = b[r], x = (c ? v.plotY : v.plotX) > this.xAxis.len, l = v.plotX, q = v.stackIndex, u = v.options.shape || h.shape, f = v.plotY, void 0 !== f && (f = v.plotY + w - (void 0 !== q &&
          q * h.stackDistance)), v.anchorX = q ? void 0 : v.plotX, y = q ? void 0 : v.plotY, q = v.graphic, void 0 !== f && 0 <= l && !x ? (q || (q = v.graphic = g.label("", null, null, u, null, null, h.useHTML).attr(this.pointAttribs(v)).css(m(h.style, v.style)).attr({
          align: "flag" === u ? "left" : "center",
          width: h.width,
          height: h.height,
          "text-align": h.textAlign
        }).addClass("highcharts-point").add(this.markerGroup), v.graphic.div && (v.graphic.div.point = v), q.shadow(h.shadow), q.isNew = !0), 0 < l && (l -= q.strokeWidth() % 2), u = {
          y: f,
          anchorY: y
        }, h.allowOverlapX && (u.x = l, u.anchorX =
          v.anchorX), q.attr({
          text: v.options.title || h.title || "A"
        })[q.isNew ? "attr" : "animate"](u), h.allowOverlapX || (d[v.plotX] ? d[v.plotX].size = Math.max(d[v.plotX].size, q.width) : d[v.plotX] = {
          align: 0,
          size: q.width,
          target: l,
          anchorX: l
        }), v.tooltipPos = [l, f + z.pos - e.plotTop]) : q && (v.graphic = q.destroy());
        h.allowOverlapX || (a.objectEach(d, function(a) {
          a.plotX = a.anchorX;
          H.push(a)
        }), a.distribute(H, c ? z.len : this.xAxis.len, 100), p(b, function(a) {
          var b = a.graphic && d[a.plotX];
          b && (a.graphic[a.graphic.isNew ? "attr" : "animate"]({
              x: b.pos,
              anchorX: a.anchorX
            }),
            a.graphic.isNew = !1)
        }));
        h.useHTML && a.wrap(this.markerGroup, "on", function(b) {
          return a.SVGElement.prototype.on.apply(b.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1))
        })
      },
      drawTracker: function() {
        var a = this.points;
        u.drawTrackerPoint.apply(this);
        p(a, function(b) {
          var e = b.graphic;
          e && G(e.element, "mouseover", function() {
            0 < b.stackIndex && !b.raised && (b._y = e.y, e.attr({
              y: b._y - 8
            }), b.raised = !0);
            p(a, function(a) {
              a !== b && a.raised && a.graphic && (a.graphic.attr({
                y: a._y
              }), a.raised = !1)
            })
          })
        })
      },
      animate: g,
      buildKDTree: g,
      setClip: g,
      invertGroups: g
    });
    l.flag = function(a, e, g, m, f) {
      var b = f && f.anchorX || a;
      f = f && f.anchorY || e;
      return l.circle(b - 1, f - 1, 2, 2).concat(["M", b, f, "L", a, e + m, a, e, a + g, e, a + g, e + m, a, e + m, "Z"])
    };
    C("circle");
    C("square");
    v === y && p(["flag", "circlepin", "squarepin"], function(a) {
      y.prototype.symbols[a] = l[a]
    })
  })(L, da);
  (function(a) {
    function B(a, b, c) {
      this.init(a, b, c)
    }
    var C = a.addEvent,
      G = a.Axis,
      p = a.correctFloat,
      m = a.defaultOptions,
      g = a.defined,
      v = a.destroyObjectProperties,
      z = a.each,
      u = a.fireEvent,
      y = a.hasTouch,
      l = a.isTouchDevice,
      b =
      a.merge,
      e = a.pick,
      t = a.removeEvent,
      n = a.wrap,
      f, c = {
        height: l ? 20 : 14,
        barBorderRadius: 0,
        buttonBorderRadius: 0,
        liveRedraw: a.svg && !l,
        margin: 10,
        minWidth: 6,
        step: .2,
        zIndex: 3,
        barBackgroundColor: "#cccccc",
        barBorderWidth: 1,
        barBorderColor: "#cccccc",
        buttonArrowColor: "#333333",
        buttonBackgroundColor: "#e6e6e6",
        buttonBorderColor: "#cccccc",
        buttonBorderWidth: 1,
        rifleColor: "#333333",
        trackBackgroundColor: "#f2f2f2",
        trackBorderColor: "#f2f2f2",
        trackBorderWidth: 1
      };
    m.scrollbar = b(!0, c, m.scrollbar);
    a.swapXY = f = function(a, b) {
      var c = a.length,
        e;
      if (b)
        for (b = 0; b < c; b += 3) e = a[b + 1], a[b + 1] = a[b + 2], a[b + 2] = e;
      return a
    };
    B.prototype = {
      init: function(a, f, g) {
        this.scrollbarButtons = [];
        this.renderer = a;
        this.userOptions = f;
        this.options = b(c, f);
        this.chart = g;
        this.size = e(this.options.size, this.options.height);
        f.enabled && (this.render(), this.initEvents(), this.addEvents())
      },
      render: function() {
        var a = this.renderer,
          b = this.options,
          c = this.size,
          e;
        this.group = e = a.g("scrollbar").attr({
          zIndex: b.zIndex,
          translateY: -99999
        }).add();
        this.track = a.rect().addClass("highcharts-scrollbar-track").attr({
          x: 0,
          r: b.trackBorderRadius || 0,
          height: c,
          width: c
        }).add(e);
        this.track.attr({
          fill: b.trackBackgroundColor,
          stroke: b.trackBorderColor,
          "stroke-width": b.trackBorderWidth
        });
        this.trackBorderWidth = this.track.strokeWidth();
        this.track.attr({
          y: -this.trackBorderWidth % 2 / 2
        });
        this.scrollbarGroup = a.g().add(e);
        this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({
          height: c,
          width: c,
          r: b.barBorderRadius || 0
        }).add(this.scrollbarGroup);
        this.scrollbarRifles = a.path(f(["M", -3, c / 4, "L", -3, 2 * c / 3, "M", 0, c / 4, "L", 0, 2 * c / 3, "M",
          3, c / 4, "L", 3, 2 * c / 3
        ], b.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);
        this.scrollbar.attr({
          fill: b.barBackgroundColor,
          stroke: b.barBorderColor,
          "stroke-width": b.barBorderWidth
        });
        this.scrollbarRifles.attr({
          stroke: b.rifleColor,
          "stroke-width": 1
        });
        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();
        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);
        this.drawScrollbarButton(0);
        this.drawScrollbarButton(1)
      },
      position: function(a, b, c, e) {
        var f =
          this.options.vertical,
          h = 0,
          g = this.rendered ? "animate" : "attr";
        this.x = a;
        this.y = b + this.trackBorderWidth;
        this.width = c;
        this.xOffset = this.height = e;
        this.yOffset = h;
        f ? (this.width = this.yOffset = c = h = this.size, this.xOffset = b = 0, this.barWidth = e - 2 * c, this.x = a += this.options.margin) : (this.height = this.xOffset = e = b = this.size, this.barWidth = c - 2 * e, this.y += this.options.margin);
        this.group[g]({
          translateX: a,
          translateY: this.y
        });
        this.track[g]({
          width: c,
          height: e
        });
        this.scrollbarButtons[1][g]({
          translateX: f ? 0 : c - b,
          translateY: f ? e - h : 0
        })
      },
      drawScrollbarButton: function(a) {
        var b = this.renderer,
          c = this.scrollbarButtons,
          e = this.options,
          h = this.size,
          g;
        g = b.g().add(this.group);
        c.push(g);
        g = b.rect().addClass("highcharts-scrollbar-button").add(g);
        g.attr({
          stroke: e.buttonBorderColor,
          "stroke-width": e.buttonBorderWidth,
          fill: e.buttonBackgroundColor
        });
        g.attr(g.crisp({
          x: -.5,
          y: -.5,
          width: h + 1,
          height: h + 1,
          r: e.buttonBorderRadius
        }, g.strokeWidth()));
        g = b.path(f(["M", h / 2 + (a ? -1 : 1), h / 2 - 3, "L", h / 2 + (a ? -1 : 1), h / 2 + 3, "L", h / 2 + (a ? 2 : -2), h / 2], e.vertical)).addClass("highcharts-scrollbar-arrow").add(c[a]);
        g.attr({
          fill: e.buttonArrowColor
        })
      },
      setRange: function(a, b) {
        var c = this.options,
          e = c.vertical,
          f = c.minWidth,
          h = this.barWidth,
          l, m, n = this.rendered && !this.hasDragged ? "animate" : "attr";
        g(h) && (a = Math.max(a, 0), l = Math.ceil(h * a), this.calculatedWidth = m = p(h * Math.min(b, 1) - l), m < f && (l = (h - f + m) * a, m = f), f = Math.floor(l + this.xOffset + this.yOffset), h = m / 2 - .5, this.from = a, this.to = b, e ? (this.scrollbarGroup[n]({
            translateY: f
          }), this.scrollbar[n]({
            height: m
          }), this.scrollbarRifles[n]({
            translateY: h
          }), this.scrollbarTop = f, this.scrollbarLeft =
          0) : (this.scrollbarGroup[n]({
          translateX: f
        }), this.scrollbar[n]({
          width: m
        }), this.scrollbarRifles[n]({
          translateX: h
        }), this.scrollbarLeft = f, this.scrollbarTop = 0), 12 >= m ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), !1 === c.showFull && (0 >= a && 1 <= b ? this.group.hide() : this.group.show()), this.rendered = !0)
      },
      initEvents: function() {
        var a = this;
        a.mouseMoveHandler = function(b) {
          var c = a.chart.pointer.normalize(b),
            e = a.options.vertical ? "chartY" : "chartX",
            f = a.initPositions;
          !a.grabbedCenter || b.touches && 0 === b.touches[0][e] ||
            (c = a.cursorToScrollbarPosition(c)[e], e = a[e], e = c - e, a.hasDragged = !0, a.updatePosition(f[0] + e, f[1] + e), a.hasDragged && u(a, "changed", {
              from: a.from,
              to: a.to,
              trigger: "scrollbar",
              DOMType: b.type,
              DOMEvent: b
            }))
        };
        a.mouseUpHandler = function(b) {
          a.hasDragged && u(a, "changed", {
            from: a.from,
            to: a.to,
            trigger: "scrollbar",
            DOMType: b.type,
            DOMEvent: b
          });
          a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null
        };
        a.mouseDownHandler = function(b) {
          b = a.chart.pointer.normalize(b);
          b = a.cursorToScrollbarPosition(b);
          a.chartX = b.chartX;
          a.chartY = b.chartY;
          a.initPositions = [a.from, a.to];
          a.grabbedCenter = !0
        };
        a.buttonToMinClick = function(b) {
          var c = p(a.to - a.from) * a.options.step;
          a.updatePosition(p(a.from - c), p(a.to - c));
          u(a, "changed", {
            from: a.from,
            to: a.to,
            trigger: "scrollbar",
            DOMEvent: b
          })
        };
        a.buttonToMaxClick = function(b) {
          var c = (a.to - a.from) * a.options.step;
          a.updatePosition(a.from + c, a.to + c);
          u(a, "changed", {
            from: a.from,
            to: a.to,
            trigger: "scrollbar",
            DOMEvent: b
          })
        };
        a.trackClick = function(b) {
          var c = a.chart.pointer.normalize(b),
            e = a.to - a.from,
            f = a.y + a.scrollbarTop,
            g = a.x + a.scrollbarLeft;
          a.options.vertical && c.chartY > f || !a.options.vertical && c.chartX > g ? a.updatePosition(a.from + e, a.to + e) : a.updatePosition(a.from - e, a.to - e);
          u(a, "changed", {
            from: a.from,
            to: a.to,
            trigger: "scrollbar",
            DOMEvent: b
          })
        }
      },
      cursorToScrollbarPosition: function(a) {
        var b = this.options,
          b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;
        return {
          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),
          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)
        }
      },
      updatePosition: function(a, b) {
        1 < b && (a = p(1 - p(b - a)), b = 1);
        0 > a && (b = p(b - a), a = 0);
        this.from = a;
        this.to = b
      },
      update: function(a) {
        this.destroy();
        this.init(this.chart.renderer, b(!0, this.options, a), this.chart)
      },
      addEvents: function() {
        var a = this.options.inverted ? [1, 0] : [0, 1],
          b = this.scrollbarButtons,
          c = this.scrollbarGroup.element,
          e = this.mouseDownHandler,
          f = this.mouseMoveHandler,
          g = this.mouseUpHandler,
          a = [
            [b[a[0]].element, "click", this.buttonToMinClick],
            [b[a[1]].element, "click", this.buttonToMaxClick],
            [this.track.element, "click", this.trackClick],
            [c, "mousedown", e],
            [c.ownerDocument, "mousemove", f],
            [c.ownerDocument,
              "mouseup", g
            ]
          ];
        y && a.push([c, "touchstart", e], [c.ownerDocument, "touchmove", f], [c.ownerDocument, "touchend", g]);
        z(a, function(a) {
          C.apply(null, a)
        });
        this._events = a
      },
      removeEvents: function() {
        z(this._events, function(a) {
          t.apply(null, a)
        });
        this._events.length = 0
      },
      destroy: function() {
        var a = this.chart.scroller;
        this.removeEvents();
        z(["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"], function(a) {
          this[a] && this[a].destroy && (this[a] = this[a].destroy())
        }, this);
        a && this === a.scrollbar && (a.scrollbar = null, v(a.scrollbarButtons))
      }
    };
    n(G.prototype, "init", function(a) {
      var b = this;
      a.apply(b, Array.prototype.slice.call(arguments, 1));
      b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new B(b.chart.renderer, b.options.scrollbar, b.chart), C(b.scrollbar, "changed", function(a) {
        var c = Math.min(e(b.options.min, b.min), b.min, b.dataMin),
          f = Math.max(e(b.options.max, b.max), b.max, b.dataMax) - c,
          g;
        b.horiz && !b.reversed || !b.horiz && b.reversed ? (g = c + f * this.to, c += f *
          this.from) : (g = c + f * (1 - this.from), c += f * (1 - this.to));
        b.setExtremes(c, g, !0, !1, a)
      }))
    });
    n(G.prototype, "render", function(a) {
      var b = Math.min(e(this.options.min, this.min), this.min, e(this.dataMin, this.min)),
        c = Math.max(e(this.options.max, this.max), this.max, e(this.dataMax, this.max)),
        f = this.scrollbar,
        h = this.titleOffset || 0;
      a.apply(this, Array.prototype.slice.call(arguments, 1));
      if (f) {
        this.horiz ? (f.position(this.left, this.top + this.height + 2 + this.chart.scrollbarsOffsets[1] + (this.opposite ? 0 : h + this.axisTitleMargin + this.offset),
          this.width, this.height), h = 1) : (f.position(this.left + this.width + 2 + this.chart.scrollbarsOffsets[0] + (this.opposite ? h + this.axisTitleMargin + this.offset : 0), this.top, this.width, this.height), h = 0);
        if (!this.opposite && !this.horiz || this.opposite && this.horiz) this.chart.scrollbarsOffsets[h] += this.scrollbar.size + this.scrollbar.options.margin;
        isNaN(b) || isNaN(c) || !g(this.min) || !g(this.max) ? f.setRange(0, 0) : (h = (this.min - b) / (c - b), b = (this.max - b) / (c - b), this.horiz && !this.reversed || !this.horiz && this.reversed ? f.setRange(h,
          b) : f.setRange(1 - b, 1 - h))
      }
    });
    n(G.prototype, "getOffset", function(a) {
      var b = this.horiz ? 2 : 1,
        c = this.scrollbar;
      a.apply(this, Array.prototype.slice.call(arguments, 1));
      c && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[b] += c.size + c.options.margin)
    });
    n(G.prototype, "destroy", function(a) {
      this.scrollbar && (this.scrollbar = this.scrollbar.destroy());
      a.apply(this, Array.prototype.slice.call(arguments, 1))
    });
    a.Scrollbar = B
  })(L);
  (function(a) {
    function B(a) {
      this.init(a)
    }
    var C = a.addEvent,
      G = a.Axis,
      p = a.Chart,
      m = a.color,
      g = a.defaultOptions,
      v = a.defined,
      z = a.destroyObjectProperties,
      u = a.each,
      y = a.erase,
      l = a.error,
      b = a.extend,
      e = a.grep,
      t = a.hasTouch,
      n = a.isArray,
      f = a.isNumber,
      c = a.isObject,
      h = a.merge,
      w = a.pick,
      D = a.removeEvent,
      r = a.Scrollbar,
      J = a.Series,
      q = a.seriesTypes,
      F = a.wrap,
      x = [].concat(a.defaultDataGroupingUnits),
      K = function(a) {
        var b = e(arguments, f);
        if (b.length) return Math[a].apply(0, b)
      };
    x[4] = ["day", [1, 2, 3, 4]];
    x[5] = ["week", [1, 2, 3]];
    q = void 0 === q.areaspline ? "line" : "areaspline";
    b(g, {
      navigator: {
        height: 40,
        margin: 25,
        maskInside: !0,
        handles: {
          width: 7,
          height: 15,
          symbols: ["navigator-handle", "navigator-handle"],
          enabled: !0,
          lineWidth: 1,
          backgroundColor: "#f2f2f2",
          borderColor: "#999999"
        },
        maskFill: m("#6685c2").setOpacity(.3).get(),
        outlineColor: "#cccccc",
        outlineWidth: 1,
        series: {
          type: q,
          fillOpacity: .05,
          lineWidth: 1,
          compare: null,
          dataGrouping: {
            approximation: "average",
            enabled: !0,
            groupPixelWidth: 2,
            smoothed: !0,
            units: x
          },
          dataLabels: {
            enabled: !1,
            zIndex: 2
          },
          id: "highcharts-navigator-series",
          className: "highcharts-navigator-series",
          lineColor: null,
          marker: {
            enabled: !1
          },
          pointRange: 0,
          threshold: null
        },
        xAxis: {
          overscroll: 0,
          className: "highcharts-navigator-xaxis",
          tickLength: 0,
          lineWidth: 0,
          gridLineColor: "#e6e6e6",
          gridLineWidth: 1,
          tickPixelInterval: 200,
          labels: {
            align: "left",
            style: {
              color: "#999999"
            },
            x: 3,
            y: -4
          },
          crosshair: !1
        },
        yAxis: {
          className: "highcharts-navigator-yaxis",
          gridLineWidth: 0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: .1,
          maxPadding: .1,
          labels: {
            enabled: !1
          },
          crosshair: !1,
          title: {
            text: null
          },
          tickLength: 0,
          tickWidth: 0
        }
      }
    });
    a.Renderer.prototype.symbols["navigator-handle"] = function(a, b, c, e, f) {
      a = f.width /
        2;
      b = Math.round(a / 3) + .5;
      f = f.height;
      return ["M", -a - 1, .5, "L", a, .5, "L", a, f + .5, "L", -a - 1, f + .5, "L", -a - 1, .5, "M", -b, 4, "L", -b, f - 3, "M", b - 1, 4, "L", b - 1, f - 3]
    };
    B.prototype = {
      drawHandle: function(a, b, c, e) {
        var d = this.navigatorOptions.handles.height;
        this.handles[b][e](c ? {
          translateX: Math.round(this.left + this.height / 2),
          translateY: Math.round(this.top + parseInt(a, 10) + .5 - d)
        } : {
          translateX: Math.round(this.left + parseInt(a, 10)),
          translateY: Math.round(this.top + this.height / 2 - d / 2 - 1)
        })
      },
      drawOutline: function(a, b, c, e) {
        var d = this.navigatorOptions.maskInside,
          f = this.outline.strokeWidth(),
          k = f / 2,
          f = f % 2 / 2,
          g = this.outlineHeight,
          h = this.scrollbarHeight,
          l = this.size,
          m = this.left - h,
          n = this.top;
        c ? (m -= k, c = n + b + f, b = n + a + f, a = ["M", m + g, n - h - f, "L", m + g, c, "L", m, c, "L", m, b, "L", m + g, b, "L", m + g, n + l + h].concat(d ? ["M", m + g, c - k, "L", m + g, b + k] : [])) : (a += m + h - f, b += m + h - f, n += k, a = ["M", m, n, "L", a, n, "L", a, n + g, "L", b, n + g, "L", b, n, "L", m + l + 2 * h, n].concat(d ? ["M", a - k, n, "L", b + k, n] : []));
        this.outline[e]({
          d: a
        })
      },
      drawMasks: function(a, b, c, e) {
        var d = this.left,
          f = this.top,
          k = this.height,
          g, h, l, m;
        c ? (l = [d, d, d], m = [f, f + a,
          f + b
        ], h = [k, k, k], g = [a, b - a, this.size - b]) : (l = [d, d + a, d + b], m = [f, f, f], h = [a, b - a, this.size - b], g = [k, k, k]);
        u(this.shades, function(a, b) {
          a[e]({
            x: l[b],
            y: m[b],
            width: h[b],
            height: g[b]
          })
        })
      },
      renderElements: function() {
        var a = this,
          b = a.navigatorOptions,
          c = b.maskInside,
          e = a.chart,
          f = e.inverted,
          g = e.renderer,
          h;
        a.navigatorGroup = h = g.g("navigator").attr({
          zIndex: 8,
          visibility: "hidden"
        }).add();
        var l = {
          cursor: f ? "ns-resize" : "ew-resize"
        };
        u([!c, c, !c], function(d, c) {
          a.shades[c] = g.rect().addClass("highcharts-navigator-mask" + (1 === c ? "-inside" :
            "-outside")).attr({
            fill: d ? b.maskFill : "rgba(0,0,0,0)"
          }).css(1 === c && l).add(h)
        });
        a.outline = g.path().addClass("highcharts-navigator-outline").attr({
          "stroke-width": b.outlineWidth,
          stroke: b.outlineColor
        }).add(h);
        b.handles.enabled && u([0, 1], function(d) {
          b.handles.inverted = e.inverted;
          a.handles[d] = g.symbol(b.handles.symbols[d], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);
          a.handles[d].attr({
            zIndex: 7 - d
          }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][d]).add(h);
          var c = b.handles;
          a.handles[d].attr({
            fill: c.backgroundColor,
            stroke: c.borderColor,
            "stroke-width": c.lineWidth
          }).css(l)
        })
      },
      update: function(a) {
        u(this.series || [], function(a) {
          a.baseSeries && delete a.baseSeries.navigatorSeries
        });
        this.destroy();
        h(!0, this.chart.options.navigator, this.options, a);
        this.init(this.chart)
      },
      render: function(b, c, e, k) {
        var d = this.chart,
          g, h, l = this.scrollbarHeight,
          m, n = this.xAxis;
        g = n.fake ? d.xAxis[0] : n;
        var q = this.navigatorEnabled,
          p, r = this.rendered;
        h = d.inverted;
        var t, x = d.xAxis[0].minRange,
          u =
          d.xAxis[0].options.maxRange;
        if (!this.hasDragged || v(e)) {
          if (!f(b) || !f(c))
            if (r) e = 0, k = w(n.width, g.width);
            else return;
          this.left = w(n.left, d.plotLeft + l + (h ? d.plotWidth : 0));
          this.size = p = m = w(n.len, (h ? d.plotHeight : d.plotWidth) - 2 * l);
          d = h ? l : m + 2 * l;
          e = w(e, n.toPixels(b, !0));
          k = w(k, n.toPixels(c, !0));
          f(e) && Infinity !== Math.abs(e) || (e = 0, k = d);
          b = n.toValue(e, !0);
          c = n.toValue(k, !0);
          t = Math.abs(a.correctFloat(c - b));
          t < x ? this.grabbedLeft ? e = n.toPixels(c - x, !0) : this.grabbedRight && (k = n.toPixels(b + x, !0)) : v(u) && t > u && (this.grabbedLeft ?
            e = n.toPixels(c - u, !0) : this.grabbedRight && (k = n.toPixels(b + u, !0)));
          this.zoomedMax = Math.min(Math.max(e, k, 0), p);
          this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(e, k), 0), p);
          this.range = this.zoomedMax - this.zoomedMin;
          p = Math.round(this.zoomedMax);
          e = Math.round(this.zoomedMin);
          q && (this.navigatorGroup.attr({
            visibility: "visible"
          }), r = r && !this.hasDragged ? "animate" : "attr", this.drawMasks(e, p, h, r), this.drawOutline(e, p, h, r), this.navigatorOptions.handles.enabled && (this.drawHandle(e,
            0, h, r), this.drawHandle(p, 1, h, r)));
          this.scrollbar && (h ? (h = this.top - l, g = this.left - l + (q || !g.opposite ? 0 : (g.titleOffset || 0) + g.axisTitleMargin), l = m + 2 * l) : (h = this.top + (q ? this.height : -l), g = this.left - l), this.scrollbar.position(g, h, d, l), this.scrollbar.setRange(this.zoomedMin / m, this.zoomedMax / m));
          this.rendered = !0
        }
      },
      addMouseEvents: function() {
        var a = this,
          b = a.chart,
          c = b.container,
          e = [],
          f, g;
        a.mouseMoveHandler = f = function(b) {
          a.onMouseMove(b)
        };
        a.mouseUpHandler = g = function(b) {
          a.onMouseUp(b)
        };
        e = a.getPartsEvents("mousedown");
        e.push(C(c, "mousemove", f), C(c.ownerDocument, "mouseup", g));
        t && (e.push(C(c, "touchmove", f), C(c.ownerDocument, "touchend", g)), e.concat(a.getPartsEvents("touchstart")));
        a.eventsToUnbind = e;
        a.series && a.series[0] && e.push(C(a.series[0].xAxis, "foundExtremes", function() {
          b.navigator.modifyNavigatorAxisExtremes()
        }))
      },
      getPartsEvents: function(a) {
        var b = this,
          d = [];
        u(["shades", "handles"], function(c) {
          u(b[c], function(e, f) {
            d.push(C(e.element, a, function(a) {
              b[c + "Mousedown"](a, f)
            }))
          })
        });
        return d
      },
      shadesMousedown: function(a,
        b) {
        a = this.chart.pointer.normalize(a);
        var d = this.chart,
          c = this.xAxis,
          e = this.zoomedMin,
          f = this.left,
          g = this.size,
          h = this.range,
          l = a.chartX,
          m, n;
        d.inverted && (l = a.chartY, f = this.top);
        1 === b ? (this.grabbedCenter = l, this.fixedWidth = h, this.dragOffset = l - e) : (a = l - f - h / 2, 0 === b ? a = Math.max(0, a) : 2 === b && a + h >= g && (a = g - h, c.reversed ? (a -= h, n = this.getUnionExtremes().dataMin) : m = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = h, b = c.toFixedRange(a, a + h, n, m), v(b.min) && d.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min,
          b.max), !0, null, {
          trigger: "navigator"
        })))
      },
      handlesMousedown: function(a, b) {
        this.chart.pointer.normalize(a);
        a = this.chart;
        var d = a.xAxis[0],
          c = a.inverted && !d.reversed || !a.inverted && d.reversed;
        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = c ? d.min : d.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = c ? d.max : d.min);
        a.fixedRange = null
      },
      onMouseMove: function(a) {
        var b = this,
          d = b.chart,
          c = b.left,
          e = b.navigatorSize,
          f = b.range,
          g = b.dragOffset,
          h = d.inverted;
        a.touches &&
          0 === a.touches[0].pageX || (a = d.pointer.normalize(a), d = a.chartX, h && (c = b.top, d = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, d - c, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, d - c)) : b.grabbedCenter && (b.hasDragged = !0, d < g ? d = g : d > e + g - f && (d = e + g - f), b.render(0, 0, d - g, d - g + f)), b.hasDragged && b.scrollbar && b.scrollbar.options.liveRedraw && (a.DOMType = a.type, setTimeout(function() {
            b.onMouseUp(a)
          }, 0)))
      },
      onMouseUp: function(a) {
        var b = this.chart,
          d = this.xAxis,
          c = d && d.reversed,
          e = this.scrollbar,
          f, g, h = a.DOMEvent || a;
        (!this.hasDragged || e && e.hasDragged) && "scrollbar" !== a.trigger || (e = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? f = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (g = this.fixedExtreme), this.zoomedMax === this.size && (g = c ? e.dataMin : e.dataMax), 0 === this.zoomedMin && (f = c ? e.dataMax : e.dataMin), d = d.toFixedRange(this.zoomedMin, this.zoomedMax, f, g), v(d.min) && b.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {
          trigger: "navigator",
          triggerOp: "navigator-drag",
          DOMEvent: h
        }));
        "mousemove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null)
      },
      removeEvents: function() {
        this.eventsToUnbind && (u(this.eventsToUnbind, function(a) {
          a()
        }), this.eventsToUnbind = void 0);
        this.removeBaseSeriesEvents()
      },
      removeBaseSeriesEvents: function() {
        var a = this.baseSeries || [];
        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && u(a, function(a) {
          D(a,
            "updatedData", this.updatedDataHandler)
        }, this), a[0].xAxis && D(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes))
      },
      init: function(a) {
        var b = a.options,
          d = b.navigator,
          c = d.enabled,
          e = b.scrollbar,
          f = e.enabled,
          b = c ? d.height : 0,
          g = f ? e.height : 0;
        this.handles = [];
        this.shades = [];
        this.chart = a;
        this.setBaseSeries();
        this.height = b;
        this.scrollbarHeight = g;
        this.scrollbarEnabled = f;
        this.navigatorEnabled = c;
        this.navigatorOptions = d;
        this.scrollbarOptions = e;
        this.outlineHeight = b + g;
        this.opposite = w(d.opposite, !c && a.inverted);
        var l =
          this,
          e = l.baseSeries,
          f = a.xAxis.length,
          m = a.yAxis.length,
          n = e && e[0] && e[0].xAxis || a.xAxis[0] || {
            options: {}
          };
        a.extraMargin = {
          type: l.opposite ? "plotTop" : "marginBottom",
          value: (c || !a.inverted ? l.outlineHeight : 0) + d.margin
        };
        a.inverted && (a.extraMargin.type = l.opposite ? "marginRight" : "plotLeft");
        a.isDirtyBox = !0;
        l.navigatorEnabled ? (l.xAxis = new G(a, h({
          breaks: n.options.breaks,
          ordinal: n.options.ordinal
        }, d.xAxis, {
          id: "navigator-x-axis",
          yAxis: "navigator-y-axis",
          isX: !0,
          type: "datetime",
          index: f,
          offset: 0,
          keepOrdinalPadding: !0,
          startOnTick: !1,
          endOnTick: !1,
          minPadding: 0,
          maxPadding: 0,
          zoomEnabled: !1
        }, a.inverted ? {
          offsets: [g, 0, -g, 0],
          width: b
        } : {
          offsets: [0, -g, 0, g],
          height: b
        })), l.yAxis = new G(a, h(d.yAxis, {
          id: "navigator-y-axis",
          alignTicks: !1,
          offset: 0,
          index: m,
          zoomEnabled: !1
        }, a.inverted ? {
          width: b
        } : {
          height: b
        })), e || d.series.data ? l.updateNavigatorSeries(!1) : 0 === a.series.length && (l.unbindRedraw = C(a, "beforeRedraw", function() {
          0 < a.series.length && !l.series && (l.setBaseSeries(), l.unbindRedraw())
        })), l.renderElements(), l.addMouseEvents()) : l.xAxis = {
          translate: function(b, d) {
            var c = a.xAxis[0],
              e = c.getExtremes(),
              f = c.len - 2 * g,
              k = K("min", c.options.min, e.dataMin),
              c = K("max", c.options.max, e.dataMax) - k;
            return d ? b * c / f + k : f * (b - k) / c
          },
          toPixels: function(a) {
            return this.translate(a)
          },
          toValue: function(a) {
            return this.translate(a, !0)
          },
          toFixedRange: G.prototype.toFixedRange,
          fake: !0
        };
        a.options.scrollbar.enabled && (a.scrollbar = l.scrollbar = new r(a.renderer, h(a.options.scrollbar, {
          margin: l.navigatorEnabled ? 0 : 10,
          vertical: a.inverted
        }), a), C(l.scrollbar, "changed", function(b) {
          var d =
            l.size,
            c = d * this.to,
            d = d * this.from;
          l.hasDragged = l.scrollbar.hasDragged;
          l.render(0, 0, d, c);
          (a.options.scrollbar.liveRedraw || "mousemove" !== b.DOMType && "touchmove" !== b.DOMType) && setTimeout(function() {
            l.onMouseUp(b)
          })
        }));
        l.addBaseSeriesEvents();
        l.addChartEvents()
      },
      getUnionExtremes: function(a) {
        var b = this.chart.xAxis[0],
          d = this.xAxis,
          c = d.options,
          e = b.options,
          f;
        a && null === b.dataMin || (f = {
          dataMin: w(c && c.min, K("min", e.min, b.dataMin, d.dataMin, d.min)),
          dataMax: w(c && c.max, K("max", e.max, b.dataMax, d.dataMax, d.max))
        });
        return f
      },
      setBaseSeries: function(a, b) {
        var d = this.chart,
          c = this.baseSeries = [];
        a = a || d.options && d.options.navigator.baseSeries || 0;
        u(d.series || [], function(b, d) {
          b.options.isInternal || !b.options.showInNavigator && (d !== a && b.options.id !== a || !1 === b.options.showInNavigator) || c.push(b)
        });
        this.xAxis && !this.xAxis.fake && this.updateNavigatorSeries(!0, b)
      },
      updateNavigatorSeries: function(d, c) {
        var e = this,
          f = e.chart,
          l = e.baseSeries,
          m, q, p = e.navigatorOptions.series,
          r, t = {
            enableMouseTracking: !1,
            index: null,
            linkedTo: null,
            group: "nav",
            padXAxis: !1,
            xAxis: "navigator-x-axis",
            yAxis: "navigator-y-axis",
            showInLegend: !1,
            stacking: !1,
            isInternal: !0,
            visible: !0
          },
          x = e.series = a.grep(e.series || [], function(b) {
            var d = b.baseSeries;
            return 0 > a.inArray(d, l) ? (d && (D(d, "updatedData", e.updatedDataHandler), delete d.navigatorSeries), b.destroy(), !1) : !0
          });
        l && l.length && u(l, function(a) {
          var d = a.navigatorSeries,
            k = b({
              color: a.color
            }, n(p) ? g.navigator.series : p);
          d && !1 === e.navigatorOptions.adaptToUpdatedData || (t.name = "Navigator " + l.length, m = a.options || {}, r = m.navigatorOptions || {}, q =
            h(m, t, k, r), k = r.data || k.data, e.hasNavigatorData = e.hasNavigatorData || !!k, q.data = k || m.data && m.data.slice(0), d && d.options ? d.update(q, c) : (a.navigatorSeries = f.initSeries(q), a.navigatorSeries.baseSeries = a, x.push(a.navigatorSeries)))
        });
        if (p.data && (!l || !l.length) || n(p)) e.hasNavigatorData = !1, p = a.splat(p), u(p, function(a, b) {
          t.name = "Navigator " + (x.length + 1);
          q = h(g.navigator.series, {
            color: f.series[b] && !f.series[b].options.isInternal && f.series[b].color || f.options.colors[b] || f.options.colors[0]
          }, t, a);
          q.data = a.data;
          q.data && (e.hasNavigatorData = !0, x.push(f.initSeries(q)))
        });
        d && this.addBaseSeriesEvents()
      },
      addBaseSeriesEvents: function() {
        var a = this,
          b = a.baseSeries || [];
        b[0] && b[0].xAxis && C(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);
        u(b, function(b) {
          C(b, "show", function() {
            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1)
          });
          C(b, "hide", function() {
            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1)
          });
          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && C(b, "updatedData", this.updatedDataHandler);
          C(b, "remove", function() {
            this.navigatorSeries && (y(a.series, this.navigatorSeries), v(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries)
          })
        }, this)
      },
      modifyNavigatorAxisExtremes: function() {
        var a = this.xAxis,
          b;
        a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax))
      },
      modifyBaseAxisExtremes: function() {
        var a = this.chart.navigator,
          b = this.getExtremes(),
          c = b.dataMin,
          e = b.dataMax,
          b = b.max - b.min,
          g = a.stickToMin,
          h =
          a.stickToMax,
          l = w(this.options.overscroll, 0),
          m, n, q = a.series && a.series[0],
          p = !!this.setExtremes;
        this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger || (g && (n = c, m = n + b), h && (m = e + l, g || (n = Math.max(m - b, q && q.xData ? q.xData[0] : -Number.MAX_VALUE))), p && (g || h) && f(n) && (this.min = this.userMin = n, this.max = this.userMax = m));
        a.stickToMin = a.stickToMax = null
      },
      updatedDataHandler: function() {
        var a = this.chart.navigator,
          b = this.navigatorSeries;
        a.stickToMax = a.xAxis.reversed ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >=
          Math.round(a.size);
        a.stickToMin = f(this.xAxis.min) && this.xAxis.min <= this.xData[0] && (!this.chart.fixedRange || !a.stickToMax);
        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1))
      },
      addChartEvents: function() {
        C(this.chart, "redraw", function() {
          var a = this.navigator,
            b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || a.scrollbar && this.xAxis[0]);
          b && a.render(b.min, b.max)
        })
      },
      destroy: function() {
        this.removeEvents();
        this.xAxis && (y(this.chart.xAxis, this.xAxis),
          y(this.chart.axes, this.xAxis));
        this.yAxis && (y(this.chart.yAxis, this.yAxis), y(this.chart.axes, this.yAxis));
        u(this.series || [], function(a) {
          a.destroy && a.destroy()
        });
        u("series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" "), function(a) {
          this[a] && this[a].destroy && this[a].destroy();
          this[a] = null
        }, this);
        u([this.handles], function(a) {
          z(a)
        }, this)
      }
    };
    a.Navigator = B;
    F(G.prototype, "zoom", function(a, b, c) {
      var d = this.chart,
        e = d.options,
        f = e.chart.zoomType,
        g = e.chart.pinchType,
        h = e.navigator,
        e = e.rangeSelector,
        l;
      this.isXAxis && (h && h.enabled || e && e.enabled) && ("x" === f || "x" === g ? d.resetZoomButton = "blocked" : "y" === f ? l = !1 : "xy" !== f && "xy" !== g || !this.options.range || (d = this.previousZoom, v(b) ? this.previousZoom = [this.min, this.max] : d && (b = d[0], c = d[1], delete this.previousZoom)));
      return void 0 !== l ? l : a.call(this, b, c)
    });
    C(p, "beforeRender", function() {
      var a = this.options;
      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new B(this)
    });
    C(p, "afterSetChartSize",
      function() {
        var a = this.legend,
          b = this.navigator,
          c, e, f, g;
        b && (e = a && a.options, f = b.xAxis, g = b.yAxis, c = b.scrollbarHeight, this.inverted ? (b.left = b.opposite ? this.chartWidth - c - b.height : this.spacing[3] + c, b.top = this.plotTop + c) : (b.left = this.plotLeft + c, b.top = b.navigatorOptions.top || this.chartHeight - b.height - c - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (e && "bottom" === e.verticalAlign && e.enabled && !e.floating ? a.legendHeight + w(e.margin, 10) : 0)), f && g && (this.inverted ? f.options.left =
          g.options.left = b.left : f.options.top = g.options.top = b.top, f.setAxisSize(), g.setAxisSize()))
      });
    F(J.prototype, "addPoint", function(a, b, e, f, g) {
      var d = this.options.turboThreshold;
      d && this.xData.length > d && c(b, !0) && this.chart.navigator && l(20, !0);
      a.call(this, b, e, f, g)
    });
    C(p, "afterAddSeries", function() {
      this.navigator && this.navigator.setBaseSeries(null, !1)
    });
    C(J, "afterUpdate", function() {
      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1)
    });
    p.prototype.callbacks.push(function(a) {
      var b =
        a.navigator;
      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max))
    })
  })(L);
  (function(a) {
    function B(a) {
      this.init(a)
    }
    var C = a.addEvent,
      G = a.Axis,
      p = a.Chart,
      m = a.css,
      g = a.createElement,
      v = a.defaultOptions,
      z = a.defined,
      u = a.destroyObjectProperties,
      y = a.discardElement,
      l = a.each,
      b = a.extend,
      e = a.fireEvent,
      t = a.isNumber,
      n = a.merge,
      f = a.pick,
      c = a.pInt,
      h = a.splat,
      w = a.wrap;
    b(v, {
      rangeSelector: {
        verticalAlign: "top",
        buttonTheme: {
          "stroke-width": 0,
          width: 28,
          height: 18,
          padding: 2,
          zIndex: 7
        },
        floating: !1,
        x: 0,
        y: 0,
        height: void 0,
        inputPosition: {
          align: "right",
          x: 0,
          y: 0
        },
        buttonPosition: {
          align: "left",
          x: 0,
          y: 0
        },
        labelStyle: {
          color: "#666666"
        }
      }
    });
    v.lang = n(v.lang, {
      rangeSelectorZoom: "Zoom",
      rangeSelectorFrom: "From",
      rangeSelectorTo: "To"
    });
    B.prototype = {
      clickButton: function(a, b) {
        var c = this,
          e = c.chart,
          g = c.buttonOptions[a],
          m = e.xAxis[0],
          n = e.scroller && e.scroller.getUnionExtremes() || m || {},
          d = n.dataMin,
          p = n.dataMax,
          r, k = m && Math.round(Math.min(m.max, f(p, m.max))),
          u = g.type,
          v, n = g._range,
          w, D, y, z = g.dataGrouping;
        if (null !== d && null !== p) {
          e.fixedRange = n;
          z && (this.forcedDataGrouping = !0, G.prototype.setDataGrouping.call(m || {
            chart: this.chart
          }, z, !1));
          if ("month" === u || "year" === u) m ? (u = {
            range: g,
            max: k,
            chart: e,
            dataMin: d,
            dataMax: p
          }, r = m.minFromRange.call(u), t(u.newMax) && (k = u.newMax)) : n = g;
          else if (n) r = Math.max(k - n, d), k = Math.min(r + n, p);
          else if ("ytd" === u)
            if (m) void 0 === p && (d = Number.MAX_VALUE, p = Number.MIN_VALUE, l(e.series, function(a) {
              a = a.xData;
              d = Math.min(a[0], d);
              p = Math.max(a[a.length - 1], p)
            }), b = !1), k = c.getYTDExtremes(p, d, e.time.useUTC), r = w = k.min, k = k.max;
            else {
              C(e, "beforeRender", function() {
                c.clickButton(a)
              });
              return
            }
          else "all" === u && m && (r = d, k = p);
          r += g._offsetMin;
          k += g._offsetMax;
          c.setSelected(a);
          m ? m.setExtremes(r, k, f(b, 1), null, {
            trigger: "rangeSelectorButton",
            rangeSelectorButton: g
          }) : (v = h(e.options.xAxis)[0], y = v.range, v.range = n, D = v.min, v.min = w, C(e, "load", function() {
            v.range = y;
            v.min = D
          }))
        }
      },
      setSelected: function(a) {
        this.selected = this.options.selected = a
      },
      defaultButtons: [{
          type: "month",
          count: 1,
          text: "1m"
        }, {
          type: "month",
          count: 3,
          text: "3m"
        }, {
          type: "month",
          count: 6,
          text: "6m"
        }, {
          type: "ytd",
          text: "YTD"
        }, {
          type: "year",
          count: 1,
          text: "1y"
        },
        {
          type: "all",
          text: "All"
        }
      ],
      init: function(a) {
        var b = this,
          c = a.options.rangeSelector,
          f = c.buttons || [].concat(b.defaultButtons),
          g = c.selected,
          h = function() {
            var a = b.minInput,
              c = b.maxInput;
            a && a.blur && e(a, "blur");
            c && c.blur && e(c, "blur")
          };
        b.chart = a;
        b.options = c;
        b.buttons = [];
        a.extraTopMargin = c.height;
        b.buttonOptions = f;
        this.unMouseDown = C(a.container, "mousedown", h);
        this.unResize = C(a, "resize", h);
        l(f, b.computeButtonRange);
        void 0 !== g && f[g] && this.clickButton(g, !1);
        C(a, "load", function() {
          a.xAxis && a.xAxis[0] && C(a.xAxis[0],
            "setExtremes",
            function(c) {
              this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && this.setDataGrouping(!1, !1)
            })
        })
      },
      updateButtonStates: function() {
        var a = this.chart,
          b = a.xAxis[0],
          c = Math.round(b.max - b.min),
          e = !b.hasVisibleSeries,
          f = a.scroller && a.scroller.getUnionExtremes() || b,
          g = f.dataMin,
          h = f.dataMax,
          a = this.getYTDExtremes(h, g, a.time.useUTC),
          d = a.min,
          m = a.max,
          n = this.selected,
          k = t(n),
          p = this.options.allButtonsEnabled,
          u = this.buttons;
        l(this.buttonOptions,
          function(a, f) {
            var l = a._range,
              q = a.type,
              r = a.count || 1,
              t = u[f],
              v = 0;
            a = a._offsetMax - a._offsetMin;
            f = f === n;
            var x = l > h - g,
              w = l < b.minRange,
              A = !1,
              y = !1,
              l = l === c;
            ("month" === q || "year" === q) && c + 36E5 >= 864E5 * {
              month: 28,
              year: 365
            } [q] * r - a && c - 36E5 <= 864E5 * {
              month: 31,
              year: 366
            } [q] * r + a ? l = !0 : "ytd" === q ? (l = m - d + a === c, A = !f) : "all" === q && (l = b.max - b.min >= h - g, y = !f && k && l);
            q = !p && (x || w || y || e);
            r = f && l || l && !k && !A;
            q ? v = 3 : r && (k = !0, v = 2);
            t.state !== v && t.setState(v)
          })
      },
      computeButtonRange: function(a) {
        var b = a.type,
          c = a.count || 1,
          e = {
            millisecond: 1,
            second: 1E3,
            minute: 6E4,
            hour: 36E5,
            day: 864E5,
            week: 6048E5
          };
        if (e[b]) a._range = e[b] * c;
        else if ("month" === b || "year" === b) a._range = 864E5 * {
          month: 30,
          year: 365
        } [b] * c;
        a._offsetMin = f(a.offsetMin, 0);
        a._offsetMax = f(a.offsetMax, 0);
        a._range += a._offsetMax - a._offsetMin
      },
      setInputValue: function(a, b) {
        var c = this.chart.options.rangeSelector,
          e = this.chart.time,
          f = this[a + "Input"];
        z(b) && (f.previousValue = f.HCTime, f.HCTime = b);
        f.value = e.dateFormat(c.inputEditDateFormat || "%Y-%m-%d", f.HCTime);
        this[a + "DateBox"].attr({
          text: e.dateFormat(c.inputDateFormat ||
            "%b %e, %Y", f.HCTime)
        })
      },
      showInput: function(a) {
        var b = this.inputGroup,
          c = this[a + "DateBox"];
        m(this[a + "Input"], {
          left: b.translateX + c.x + "px",
          top: b.translateY + "px",
          width: c.width - 2 + "px",
          height: c.height - 2 + "px",
          border: "2px solid silver"
        })
      },
      hideInput: function(a) {
        m(this[a + "Input"], {
          border: 0,
          width: "1px",
          height: "1px"
        });
        this.setInputValue(a)
      },
      drawInput: function(a) {
        function e() {
          var a = y.value,
            b = (u.inputDateParser || Date.parse)(a),
            d = h.xAxis[0],
            e = h.scroller && h.scroller.xAxis ? h.scroller.xAxis : d,
            g = e.dataMin,
            e = e.dataMax;
          b !== y.previousValue && (y.previousValue = b, t(b) || (b = a.split("-"), b = Date.UTC(c(b[0]), c(b[1]) - 1, c(b[2]))), t(b) && (h.time.useUTC || (b += 6E4 * (new Date).getTimezoneOffset()), w ? b > f.maxInput.HCTime ? b = void 0 : b < g && (b = g) : b < f.minInput.HCTime ? b = void 0 : b > e && (b = e), void 0 !== b && d.setExtremes(w ? b : d.min, w ? d.max : b, void 0, void 0, {
            trigger: "rangeSelectorInput"
          })))
        }
        var f = this,
          h = f.chart,
          l = h.renderer.style || {},
          p = h.renderer,
          u = h.options.rangeSelector,
          d = f.div,
          w = "min" === a,
          y, k, A = this.inputGroup;
        this[a + "Label"] = k = p.label(v.lang[w ? "rangeSelectorFrom" :
          "rangeSelectorTo"], this.inputGroup.offset).addClass("highcharts-range-label").attr({
          padding: 2
        }).add(A);
        A.offset += k.width + 5;
        this[a + "DateBox"] = p = p.label("", A.offset).addClass("highcharts-range-input").attr({
          padding: 2,
          width: u.inputBoxWidth || 90,
          height: u.inputBoxHeight || 17,
          stroke: u.inputBoxBorderColor || "#cccccc",
          "stroke-width": 1,
          "text-align": "center"
        }).on("click", function() {
          f.showInput(a);
          f[a + "Input"].focus()
        }).add(A);
        A.offset += p.width + (w ? 10 : 0);
        this[a + "Input"] = y = g("input", {
          name: a,
          className: "highcharts-range-selector",
          type: "text"
        }, {
          top: h.plotTop + "px"
        }, d);
        k.css(n(l, u.labelStyle));
        p.css(n({
          color: "#333333"
        }, l, u.inputStyle));
        m(y, b({
          position: "absolute",
          border: 0,
          width: "1px",
          height: "1px",
          padding: 0,
          textAlign: "center",
          fontSize: l.fontSize,
          fontFamily: l.fontFamily,
          top: "-9999em"
        }, u.inputStyle));
        y.onfocus = function() {
          f.showInput(a)
        };
        y.onblur = function() {
          f.hideInput(a)
        };
        y.onchange = e;
        y.onkeypress = function(a) {
          13 === a.keyCode && e()
        }
      },
      getPosition: function() {
        var a = this.chart,
          b = a.options.rangeSelector,
          a = "top" === b.verticalAlign ? a.plotTop -
          a.axisOffset[0] : 0;
        return {
          buttonTop: a + b.buttonPosition.y,
          inputTop: a + b.inputPosition.y - 10
        }
      },
      getYTDExtremes: function(a, b, c) {
        var e = this.chart.time,
          f = new e.Date(a),
          g = e.get("FullYear", f);
        c = c ? e.Date.UTC(g, 0, 1) : +new e.Date(g, 0, 1);
        b = Math.max(b || 0, c);
        f = f.getTime();
        return {
          max: Math.min(a || f, f),
          min: b
        }
      },
      render: function(a, b) {
        var c = this,
          e = c.chart,
          h = e.renderer,
          m = e.container,
          n = e.options,
          d = n.exporting && !1 !== n.exporting.enabled && n.navigation && n.navigation.buttonOptions,
          p = v.lang,
          r = c.div,
          k = n.rangeSelector,
          n = k.floating,
          t = c.buttons,
          r = c.inputGroup,
          u = k.buttonTheme,
          w = k.buttonPosition,
          y = k.inputPosition,
          z = k.inputEnabled,
          D = u && u.states,
          B = e.plotLeft,
          C, G = c.buttonGroup,
          L;
        L = c.rendered;
        var X = c.options.verticalAlign,
          Z = e.legend,
          aa = Z && Z.options,
          ba = w.y,
          Y = y.y,
          ca = L || !1,
          W = 0,
          T = 0,
          U;
        if (!1 !== k.enabled) {
          L || (c.group = L = h.g("range-selector-group").attr({
              zIndex: 7
            }).add(), c.buttonGroup = G = h.g("range-selector-buttons").add(L), c.zoomText = h.text(p.rangeSelectorZoom, f(B + w.x, B), 15).css(k.labelStyle).add(G), C = f(B + w.x, B) + c.zoomText.getBBox().width +
            5, l(c.buttonOptions, function(a, b) {
              t[b] = h.button(a.text, C, 0, function() {
                var d = a.events && a.events.click,
                  e;
                d && (e = d.call(a));
                !1 !== e && c.clickButton(b);
                c.isActive = !0
              }, u, D && D.hover, D && D.select, D && D.disabled).attr({
                "text-align": "center"
              }).add(G);
              C += t[b].width + f(k.buttonSpacing, 5)
            }), !1 !== z && (c.div = r = g("div", null, {
              position: "relative",
              height: 0,
              zIndex: 1
            }), m.parentNode.insertBefore(r, m), c.inputGroup = r = h.g("input-group").add(L), r.offset = 0, c.drawInput("min"), c.drawInput("max")));
          B = e.plotLeft - e.spacing[3];
          c.updateButtonStates();
          d && this.titleCollision(e) && "top" === X && "right" === w.align && w.y + G.getBBox().height - 12 < (d.y || 0) + d.height && (W = -40);
          "left" === w.align ? U = w.x - e.spacing[3] : "right" === w.align && (U = w.x + W - e.spacing[1]);
          G.align({
            y: w.y,
            width: G.getBBox().width,
            align: w.align,
            x: U
          }, !0, e.spacingBox);
          c.group.placed = ca;
          c.buttonGroup.placed = ca;
          !1 !== z && (W = d && this.titleCollision(e) && "top" === X && "right" === y.align && y.y - r.getBBox().height - 12 < (d.y || 0) + d.height + e.spacing[0] ? -40 : 0, "left" === y.align ? U = B : "right" === y.align && (U = -Math.max(e.axisOffset[1],
            -W)), r.align({
            y: y.y,
            width: r.getBBox().width,
            align: y.align,
            x: y.x + U - 2
          }, !0, e.spacingBox), m = r.alignAttr.translateX + r.alignOptions.x - W + r.getBBox().x + 2, d = r.alignOptions.width, p = G.alignAttr.translateX + G.getBBox().x, U = G.getBBox().width + 20, (y.align === w.align || p + U > m && m + d > p && ba < Y + r.getBBox().height) && r.attr({
            translateX: r.alignAttr.translateX + (e.axisOffset[1] >= -W ? 0 : -W),
            translateY: r.alignAttr.translateY + G.getBBox().height + 10
          }), c.setInputValue("min", a), c.setInputValue("max", b), c.inputGroup.placed = ca);
          c.group.align({
              verticalAlign: X
            },
            !0, e.spacingBox);
          a = c.group.getBBox().height + 20;
          b = c.group.alignAttr.translateY;
          "bottom" === X && (Z = aa && "bottom" === aa.verticalAlign && aa.enabled && !aa.floating ? Z.legendHeight + f(aa.margin, 10) : 0, a = a + Z - 20, T = b - a - (n ? 0 : k.y) - 10);
          if ("top" === X) n && (T = 0), e.titleOffset && (T = e.titleOffset + e.options.title.margin), T += e.margin[0] - e.spacing[0] || 0;
          else if ("middle" === X)
            if (Y === ba) T = 0 > Y ? b + void 0 : b;
            else if (Y || ba) T = 0 > Y || 0 > ba ? T - Math.min(Y, ba) : b - a + NaN;
          c.group.translate(k.x, k.y + Math.floor(T));
          !1 !== z && (c.minInput.style.marginTop = c.group.translateY +
            "px", c.maxInput.style.marginTop = c.group.translateY + "px");
          c.rendered = !0
        }
      },
      getHeight: function() {
        var a = this.options,
          b = this.group,
          c = a.y,
          e = a.buttonPosition.y,
          a = a.inputPosition.y,
          b = b ? b.getBBox(!0).height + 13 + c : 0,
          c = Math.min(a, e);
        if (0 > a && 0 > e || 0 < a && 0 < e) b += Math.abs(c);
        return b
      },
      titleCollision: function(a) {
        return !(a.options.title.text || a.options.subtitle.text)
      },
      update: function(a) {
        var b = this.chart;
        n(!0, b.options.rangeSelector, a);
        this.destroy();
        this.init(b);
        b.rangeSelector.render()
      },
      destroy: function() {
        var b = this,
          c = b.minInput,
          e = b.maxInput;
        b.unMouseDown();
        b.unResize();
        u(b.buttons);
        c && (c.onfocus = c.onblur = c.onchange = null);
        e && (e.onfocus = e.onblur = e.onchange = null);
        a.objectEach(b, function(a, c) {
          a && "chart" !== c && (a.destroy ? a.destroy() : a.nodeType && y(this[c]));
          a !== B.prototype[c] && (b[c] = null)
        }, this)
      }
    };
    G.prototype.toFixedRange = function(a, b, c, e) {
      var g = this.chart && this.chart.fixedRange;
      a = f(c, this.translate(a, !0, !this.horiz));
      b = f(e, this.translate(b, !0, !this.horiz));
      c = g && (b - a) / g;
      .7 < c && 1.3 > c && (e ? a = b - g : b = a + g);
      t(a) && t(b) || (a =
        b = void 0);
      return {
        min: a,
        max: b
      }
    };
    G.prototype.minFromRange = function() {
      var a = this.range,
        b = {
          month: "Month",
          year: "FullYear"
        } [a.type],
        c, e = this.max,
        g, h, l = function(a, c) {
          var d = new Date(a),
            e = d["get" + b]();
          d["set" + b](e + c);
          e === d["get" + b]() && d.setDate(0);
          return d.getTime() - a
        };
      t(a) ? (c = e - a, h = a) : (c = e + l(e, -a.count), this.chart && (this.chart.fixedRange = e - c));
      g = f(this.dataMin, Number.MIN_VALUE);
      t(c) || (c = g);
      c <= g && (c = g, void 0 === h && (h = l(c, a.count)), this.newMax = Math.min(c + h, this.dataMax));
      t(e) || (c = void 0);
      return c
    };
    C(p, "afterGetContainer",
      function() {
        this.options.rangeSelector.enabled && (this.rangeSelector = new B(this))
      });
    w(p.prototype, "render", function(a, b, c) {
      var e = this.axes,
        f = this.rangeSelector;
      f && (l(e, function(a) {
        a.updateNames();
        a.setScale()
      }), this.getAxisMargins(), f.render(), e = f.options.verticalAlign, f.options.floating || ("bottom" === e ? this.extraBottomMargin = !0 : "middle" !== e && (this.extraTopMargin = !0)));
      a.call(this, b, c)
    });
    C(p, "update", function(a) {
      var b = a.options;
      a = this.rangeSelector;
      this.extraTopMargin = this.extraBottomMargin = !1;
      this.isDirtyBox = !0;
      a && (a.render(), b = b.rangeSelector && b.rangeSelector.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)))
    });
    w(p.prototype, "redraw", function(a, b, c) {
      var e = this.rangeSelector;
      e && !e.options.floating && (e.render(), e = e.options.verticalAlign, "bottom" === e ? this.extraBottomMargin = !0 : "middle" !== e && (this.extraTopMargin = !0));
      a.call(this, b, c)
    });
    p.prototype.adjustPlotArea = function() {
      var a = this.rangeSelector;
      this.rangeSelector &&
        (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a))
    };
    p.prototype.callbacks.push(function(a) {
      function b() {
        c = a.xAxis[0].getExtremes();
        t(c.min) && e.render(c.min, c.max)
      }
      var c, e = a.rangeSelector,
        f, g;
      e && (g = C(a.xAxis[0], "afterSetExtremes", function(a) {
        e.render(a.min, a.max)
      }), f = C(a, "redraw", b), b());
      C(a, "destroy", function() {
        e && (f(), g())
      })
    });
    a.RangeSelector = B
  })(L);
  (function(a) {
    var B = a.addEvent,
      C = a.arrayMax,
      G = a.arrayMin,
      p = a.Axis,
      m = a.Chart,
      g = a.defined,
      v = a.each,
      z = a.extend,
      u = a.format,
      y = a.grep,
      l = a.inArray,
      b = a.isNumber,
      e = a.isString,
      t = a.map,
      n = a.merge,
      f = a.pick,
      c = a.Point,
      h = a.Renderer,
      w = a.Series,
      D = a.splat,
      r = a.SVGRenderer,
      J = a.VMLRenderer,
      q = a.wrap,
      F = w.prototype,
      x = F.init,
      K = F.processData,
      d = c.prototype.tooltipFormatter;
    a.StockChart = a.stockChart = function(b, c, d) {
      var g = e(b) || b.nodeName,
        k = arguments[g ? 1 : 0],
        h = k.series,
        l = a.getOptions(),
        p, q = f(k.navigator && k.navigator.enabled, l.navigator.enabled, !0),
        r = q ? {
          startOnTick: !1,
          endOnTick: !1
        } : null,
        u = {
          marker: {
            enabled: !1,
            radius: 2
          }
        },
        v = {
          shadow: !1,
          borderWidth: 0
        };
      k.xAxis = t(D(k.xAxis || {}), function(a, b) {
        return n({
          minPadding: 0,
          maxPadding: 0,
          overscroll: 0,
          ordinal: !0,
          title: {
            text: null
          },
          labels: {
            overflow: "justify"
          },
          showLastLabel: !0
        }, l.xAxis, l.xAxis && l.xAxis[b], a, {
          type: "datetime",
          categories: null
        }, r)
      });
      k.yAxis = t(D(k.yAxis || {}), function(a, b) {
        p = f(a.opposite, !0);
        return n({
          labels: {
            y: -2
          },
          opposite: p,
          showLastLabel: !(!a.categories && "category" !== a.type),
          title: {
            text: null
          }
        }, l.yAxis, l.yAxis && l.yAxis[b], a)
      });
      k.series = null;
      k = n({
        chart: {
          panning: !0,
          pinchType: "x"
        },
        navigator: {
          enabled: q
        },
        scrollbar: {
          enabled: f(l.scrollbar.enabled, !0)
        },
        rangeSelector: {
          enabled: f(l.rangeSelector.enabled, !0)
        },
        title: {
          text: null
        },
        tooltip: {
          split: f(l.tooltip.split, !0),
          crosshairs: !0
        },
        legend: {
          enabled: !1
        },
        plotOptions: {
          line: u,
          spline: u,
          area: u,
          areaspline: u,
          arearange: u,
          areasplinerange: u,
          column: v,
          columnrange: v,
          candlestick: v,
          ohlc: v
        }
      }, k, {
        isStock: !0
      });
      k.series = h;
      return g ? new m(b, k, d) : new m(k, c)
    };
    q(p.prototype, "autoLabelAlign", function(a) {
      var b = this.chart,
        c = this.options,
        b = b._labelPanes = b._labelPanes || {},
        d = this.options.labels;
      return this.chart.options.isStock && "yAxis" === this.coll && (c = c.top + "," + c.height, !b[c] && d.enabled) ? (15 === d.x && (d.x = 0), void 0 === d.align && (d.align = "right"), b[c] = this, "right") : a.apply(this, [].slice.call(arguments, 1))
    });
    B(p, "destroy", function() {
      var a = this.chart,
        b = this.options && this.options.top + "," + this.options.height;
      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b]
    });
    q(p.prototype, "getPlotLinePath", function(c, d, k, h, m, n) {
      var p = this,
        q = this.isLinked && !this.series ? this.linkedParent.series :
        this.series,
        r = p.chart,
        u = r.renderer,
        w = p.left,
        x = p.top,
        y, A, z, E, B = [],
        D = [],
        C, H;
      if ("xAxis" !== p.coll && "yAxis" !== p.coll) return c.apply(this, [].slice.call(arguments, 1));
      D = function(a) {
        var c = "xAxis" === a ? "yAxis" : "xAxis";
        a = p.options[c];
        return b(a) ? [r[c][a]] : e(a) ? [r.get(a)] : t(q, function(a) {
          return a[c]
        })
      }(p.coll);
      v(p.isXAxis ? r.yAxis : r.xAxis, function(a) {
        if (g(a.options.id) ? -1 === a.options.id.indexOf("navigator") : 1) {
          var b = a.isXAxis ? "yAxis" : "xAxis",
            b = g(a.options[b]) ? r[b][a.options[b]] : r[b][0];
          p === b && D.push(a)
        }
      });
      C = D.length ? [] : [p.isXAxis ? r.yAxis[0] : r.xAxis[0]];
      v(D, function(b) {
        -1 !== l(b, C) || a.find(C, function(a) {
          return a.pos === b.pos && a.len && b.len
        }) || C.push(b)
      });
      H = f(n, p.translate(d, null, null, h));
      b(H) && (p.horiz ? v(C, function(a) {
        var b;
        A = a.pos;
        E = A + a.len;
        y = z = Math.round(H + p.transB);
        if (y < w || y > w + p.width) m ? y = z = Math.min(Math.max(w, y), w + p.width) : b = !0;
        b || B.push("M", y, A, "L", z, E)
      }) : v(C, function(a) {
        var b;
        y = a.pos;
        z = y + a.len;
        A = E = Math.round(x + p.height - H);
        if (A < x || A > x + p.height) m ? A = E = Math.min(Math.max(x, A), p.top + p.height) : b = !0;
        b || B.push("M",
          y, A, "L", z, E)
      }));
      return 0 < B.length ? u.crispPolyLine(B, k || 1) : null
    });
    r.prototype.crispPolyLine = function(a, b) {
      var c;
      for (c = 0; c < a.length; c += 6) a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = Math.round(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = Math.round(a[c + 2]) + b % 2 / 2);
      return a
    };
    h === J && (J.prototype.crispPolyLine = r.prototype.crispPolyLine);
    q(p.prototype, "hideCrosshair", function(a, b) {
      a.call(this, b);
      this.crossLabel && (this.crossLabel = this.crossLabel.hide())
    });
    B(p, "afterDrawCrosshair", function(a) {
      var b, c;
      if (g(this.crosshair.label) &&
        this.crosshair.label.enabled && this.cross) {
        var d = this.chart,
          e = this.options.crosshair.label,
          h = this.horiz;
        b = this.opposite;
        c = this.left;
        var l = this.top,
          m = this.crossLabel,
          n = e.format,
          p = "",
          q = "inside" === this.options.tickPosition,
          r = !1 !== this.crosshair.snap,
          t = 0,
          v = a.e || this.cross && this.cross.e,
          w = a.point;
        a = h ? "center" : b ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
        m || (m = this.crossLabel = d.renderer.label(null, null, null, e.shape || "callout").addClass("highcharts-crosshair-label" +
          (this.series[0] && " highcharts-color-" + this.series[0].colorIndex)).attr({
          align: e.align || a,
          padding: f(e.padding, 8),
          r: f(e.borderRadius, 3),
          zIndex: 2
        }).add(this.labelGroup), m.attr({
          fill: e.backgroundColor || this.series[0] && this.series[0].color || "#666666",
          stroke: e.borderColor || "",
          "stroke-width": e.borderWidth || 0
        }).css(z({
          color: "#ffffff",
          fontWeight: "normal",
          fontSize: "11px",
          textAlign: "center"
        }, e.style)));
        h ? (a = r ? w.plotX + c : v.chartX, l += b ? 0 : this.height) : (a = b ? this.width + c : 0, l = r ? w.plotY + l : v.chartY);
        n || e.formatter ||
          (this.isDatetimeAxis && (p = "%b %d, %Y"), n = "{value" + (p ? ":" + p : "") + "}");
        p = r ? w[this.isXAxis ? "x" : "y"] : this.toValue(h ? v.chartX : v.chartY);
        m.attr({
          text: n ? u(n, {
            value: p
          }, d.time) : e.formatter.call(this, p),
          x: a,
          y: l,
          visibility: p < this.min || p > this.max ? "hidden" : "visible"
        });
        e = m.getBBox();
        if (h) {
          if (q && !b || !q && b) l = m.y - e.height
        } else l = m.y - e.height / 2;
        h ? (b = c - e.x, c = c + this.width - e.x) : (b = "left" === this.labelAlign ? c : 0, c = "right" === this.labelAlign ? c + this.width : d.chartWidth);
        m.translateX < b && (t = b - m.translateX);
        m.translateX + e.width >=
          c && (t = -(m.translateX + e.width - c));
        m.attr({
          x: a + t,
          y: l,
          anchorX: h ? a : this.opposite ? 0 : d.chartWidth,
          anchorY: h ? this.opposite ? d.chartHeight : 0 : l + e.height / 2
        })
      }
    });
    F.init = function() {
      x.apply(this, arguments);
      this.setCompare(this.options.compare)
    };
    F.setCompare = function(a) {
      this.modifyValue = "value" === a || "percent" === a ? function(b, c) {
        var d = this.compareValue;
        if (void 0 !== b && void 0 !== d) return b = "value" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b
      } : null;
      this.userOptions.compare = a;
      this.chart.hasRendered &&
        (this.isDirty = !0)
    };
    F.processData = function() {
      var a, c = -1,
        d, e, f = !0 === this.options.compareStart ? 0 : 1,
        g, h;
      K.apply(this, arguments);
      if (this.xAxis && this.processedYData)
        for (d = this.processedXData, e = this.processedYData, g = e.length, this.pointArrayMap && (c = l("close", this.pointArrayMap), -1 === c && (c = l(this.pointValKey || "y", this.pointArrayMap))), a = 0; a < g - f; a++)
          if (h = e[a] && -1 < c ? e[a][c] : e[a], b(h) && d[a + f] >= this.xAxis.min && 0 !== h) {
            this.compareValue = h;
            break
          }
    };
    q(F, "getExtremes", function(a) {
      var b;
      a.apply(this, [].slice.call(arguments,
        1));
      this.modifyValue && (b = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)], this.dataMin = G(b), this.dataMax = C(b))
    });
    p.prototype.setCompare = function(a, b) {
      this.isXAxis || (v(this.series, function(b) {
        b.setCompare(a)
      }), f(b, !0) && this.chart.redraw())
    };
    c.prototype.tooltipFormatter = function(b) {
      b = b.replace("{point.change}", (0 < this.change ? "+" : "") + a.numberFormat(this.change, f(this.series.tooltipOptions.changeDecimals, 2)));
      return d.apply(this, [b])
    };
    q(w.prototype, "render", function(a) {
      this.chart.is3d &&
        this.chart.is3d() || this.chart.polar || !this.xAxis || this.xAxis.isRadial || (!this.clipBox && this.animate ? (this.clipBox = n(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len) : this.chart[this.sharedClipKey] ? this.chart[this.sharedClipKey].attr({
          width: this.xAxis.len,
          height: this.yAxis.len
        }) : this.clipBox && (this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len));
      a.call(this)
    });
    q(m.prototype, "getSelectedPoints", function(a) {
      var b = a.call(this);
      v(this.series, function(a) {
        a.hasGroupedData &&
          (b = b.concat(y(a.points || [], function(a) {
            return a.selected
          })))
      });
      return b
    });
    B(m, "update", function(a) {
      a = a.options;
      "scrollbar" in a && this.navigator && (n(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar)
    })
  })(L);
  return L
});;
/*! RESOURCE: /scripts/highcharts/highcharts-more.src.js */
'use strict';
(function(factory) {
  if (typeof module === 'object' && module.exports) {
    module.exports = factory;
  } else {
    factory(Highcharts);
  }
}(function(Highcharts) {
  (function(H) {
    var CenteredSeriesMixin = H.CenteredSeriesMixin,
      each = H.each,
      extend = H.extend,
      merge = H.merge,
      splat = H.splat;

    function Pane(options, chart) {
      this.init(options, chart);
    }
    extend(Pane.prototype, {
      coll: 'pane',
      init: function(options, chart) {
        this.chart = chart;
        this.background = [];
        chart.pane.push(this);
        this.setOptions(options);
      },
      setOptions: function(options) {
        this.options = options = merge(
          this.defaultOptions,
          this.chart.angular ? {
            background: {}
          } : undefined,
          options
        );
      },
      render: function() {
        var options = this.options,
          backgroundOption = this.options.background,
          renderer = this.chart.renderer,
          len,
          i;
        if (!this.group) {
          this.group = renderer.g('pane-group')
            .attr({
              zIndex: options.zIndex || 0
            })
            .add();
        }
        this.updateCenter();
        if (backgroundOption) {
          backgroundOption = splat(backgroundOption);
          len = Math.max(
            backgroundOption.length,
            this.background.length || 0
          );
          for (i = 0; i < len; i++) {
            if (backgroundOption[i] && this.axis) {
              this.renderBackground(
                merge(
                  this.defaultBackgroundOptions,
                  backgroundOption[i]
                ),
                i
              );
            } else if (this.background[i]) {
              this.background[i] = this.background[i].destroy();
              this.background.splice(i, 1);
            }
          }
        }
      },
      renderBackground: function(backgroundOptions, i) {
        var method = 'animate';
        if (!this.background[i]) {
          this.background[i] = this.chart.renderer.path()
            .add(this.group);
          method = 'attr';
        }
        this.background[i][method]({
          'd': this.axis.getPlotBandPath(
            backgroundOptions.from,
            backgroundOptions.to,
            backgroundOptions
          )
        }).attr({
          'fill': backgroundOptions.backgroundColor,
          'stroke': backgroundOptions.borderColor,
          'stroke-width': backgroundOptions.borderWidth,
          'class': 'highcharts-pane ' + (backgroundOptions.className || '')
        });
      },
      defaultOptions: {
        center: ['50%', '50%'],
        size: '85%',
        startAngle: 0
      },
      defaultBackgroundOptions: {
        shape: 'circle',
        borderWidth: 1,
        borderColor: '#cccccc',
        backgroundColor: {
          linearGradient: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 1
          },
          stops: [
            [0, '#ffffff'],
            [1, '#e6e6e6']
          ]
        },
        from: -Number.MAX_VALUE,
        innerRadius: 0,
        to: Number.MAX_VALUE,
        outerRadius: '105%'
      },
      updateCenter: function(axis) {
        this.center = (axis || this.axis || {}).center =
          CenteredSeriesMixin.getCenter.call(this);
      },
      update: function(options, redraw) {
        merge(true, this.options, options);
        this.setOptions(this.options);
        this.render();
        each(this.chart.axes, function(axis) {
          if (axis.pane === this) {
            axis.pane = null;
            axis.update({}, redraw);
          }
        }, this);
      }
    });
    H.Pane = Pane;
  }(Highcharts));
  (function(H) {
    var addEvent = H.addEvent,
      Axis = H.Axis,
      each = H.each,
      extend = H.extend,
      map = H.map,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      Tick = H.Tick,
      wrap = H.wrap,
      correctFloat = H.correctFloat,
      hiddenAxisMixin,
      radialAxisMixin,
      axisProto = Axis.prototype,
      tickProto = Tick.prototype;
    if (!H.radialAxisExtended) {
      H.radialAxisExtended = true;
      hiddenAxisMixin = {
        getOffset: noop,
        redraw: function() {
          this.isDirty = false;
        },
        render: function() {
          this.isDirty = false;
        },
        setScale: noop,
        setCategories: noop,
        setTitle: noop
      };
      radialAxisMixin = {
        defaultRadialGaugeOptions: {
          labels: {
            align: 'center',
            x: 0,
            y: null
          },
          minorGridLineWidth: 0,
          minorTickInterval: 'auto',
          minorTickLength: 10,
          minorTickPosition: 'inside',
          minorTickWidth: 1,
          tickLength: 10,
          tickPosition: 'inside',
          tickWidth: 2,
          title: {
            rotation: 0
          },
          zIndex: 2
        },
        defaultRadialXOptions: {
          gridLineWidth: 1,
          labels: {
            align: null,
            distance: 15,
            x: 0,
            y: null,
            style: {
              textOverflow: 'none'
            }
          },
          maxPadding: 0,
          minPadding: 0,
          showLastLabel: false,
          tickLength: 0
        },
        defaultRadialYOptions: {
          gridLineInterpolation: 'circle',
          labels: {
            align: 'right',
            x: -3,
            y: -2
          },
          showLastLabel: false,
          title: {
            x: 4,
            text: null,
            rotation: 90
          }
        },
        setOptions: function(userOptions) {
          var options = this.options = merge(
            this.defaultOptions,
            this.defaultRadialOptions,
            userOptions
          );
          if (!options.plotBands) {
            options.plotBands = [];
          }
        },
        getOffset: function() {
          axisProto.getOffset.call(this);
          this.chart.axisOffset[this.side] = 0;
        },
        getLinePath: function(lineWidth, radius) {
          var center = this.center,
            end,
            chart = this.chart,
            r = pick(radius, center[2] / 2 - this.offset),
            path;
          if (this.isCircular || radius !== undefined) {
            path = this.chart.renderer.symbols.arc(
              this.left + center[0],
              this.top + center[1],
              r,
              r, {
                start: this.startAngleRad,
                end: this.endAngleRad,
                open: true,
                innerR: 0
              }
            );
            path.xBounds = [this.left + center[0]];
            path.yBounds = [this.top + center[1] - r];
          } else {
            end = this.postTranslate(this.angleRad, r);
            path = [
              'M',
              center[0] + chart.plotLeft,
              center[1] + chart.plotTop,
              'L',
              end.x,
              end.y
            ];
          }
          return path;
        },
        setAxisTranslation: function() {
          axisProto.setAxisTranslation.call(this);
          if (this.center) {
            if (this.isCircular) {
              this.transA = (this.endAngleRad - this.startAngleRad) /
                ((this.max - this.min) || 1);
            } else {
              this.transA = (
                (this.center[2] / 2) /
                ((this.max - this.min) || 1)
              );
            }
            if (this.isXAxis) {
              this.minPixelPadding = this.transA * this.minPointOffset;
            } else {
              this.minPixelPadding = 0;
            }
          }
        },
        beforeSetTickPositions: function() {
          this.autoConnect = (
            this.isCircular &&
            pick(this.userMax, this.options.max) === undefined &&
            correctFloat(this.endAngleRad - this.startAngleRad) ===
            correctFloat(2 * Math.PI)
          );
          if (this.autoConnect) {
            this.max += (
              (this.categories && 1) ||
              this.pointRange ||
              this.closestPointRange ||
              0
            );
          }
        },
        setAxisSize: function() {
          axisProto.setAxisSize.call(this);
          if (this.isRadial) {
            this.pane.updateCenter(this);
            if (this.isCircular) {
              this.sector = this.endAngleRad - this.startAngleRad;
            }
            this.len = this.width = this.height =
              this.center[2] * pick(this.sector, 1) / 2;
          }
        },
        getPosition: function(value, length) {
          return this.postTranslate(
            this.isCircular ?
            this.translate(value) :
            this.angleRad,
            pick(
              this.isCircular ? length : this.translate(value),
              this.center[2] / 2
            ) - this.offset
          );
        },
        postTranslate: function(angle, radius) {
          var chart = this.chart,
            center = this.center;
          angle = this.startAngleRad + angle;
          return {
            x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
            y: chart.plotTop + center[1] + Math.sin(angle) * radius
          };
        },
        getPlotBandPath: function(from, to, options) {
          var center = this.center,
            startAngleRad = this.startAngleRad,
            fullRadius = center[2] / 2,
            radii = [
              pick(options.outerRadius, '100%'),
              options.innerRadius,
              pick(options.thickness, 10)
            ],
            offset = Math.min(this.offset, 0),
            percentRegex = /%$/,
            start,
            end,
            open,
            isCircular = this.isCircular,
            ret;
          if (this.options.gridLineInterpolation === 'polygon') {
            ret = this.getPlotLinePath(from).concat(
              this.getPlotLinePath(to, true)
            );
          } else {
            from = Math.max(from, this.min);
            to = Math.min(to, this.max);
            if (!isCircular) {
              radii[0] = this.translate(from);
              radii[1] = this.translate(to);
            }
            radii = map(radii, function(radius) {
              if (percentRegex.test(radius)) {
                radius = (pInt(radius, 10) * fullRadius) / 100;
              }
              return radius;
            });
            if (options.shape === 'circle' || !isCircular) {
              start = -Math.PI / 2;
              end = Math.PI * 1.5;
              open = true;
            } else {
              start = startAngleRad + this.translate(from);
              end = startAngleRad + this.translate(to);
            }
            radii[0] -= offset;
            radii[2] -= offset;
            ret = this.chart.renderer.symbols.arc(
              this.left + center[0],
              this.top + center[1],
              radii[0],
              radii[0], {
                start: Math.min(start, end),
                end: Math.max(start, end),
                innerR: pick(radii[1], radii[0] - radii[2]),
                open: open
              }
            );
          }
          return ret;
        },
        getPlotLinePath: function(value, reverse) {
          var axis = this,
            center = axis.center,
            chart = axis.chart,
            end = axis.getPosition(value),
            xAxis,
            xy,
            tickPositions,
            ret;
          if (axis.isCircular) {
            ret = [
              'M',
              center[0] + chart.plotLeft,
              center[1] + chart.plotTop,
              'L',
              end.x,
              end.y
            ];
          } else if (axis.options.gridLineInterpolation === 'circle') {
            value = axis.translate(value);
            if (value) {
              ret = axis.getLinePath(0, value);
            }
          } else {
            each(chart.xAxis, function(a) {
              if (a.pane === axis.pane) {
                xAxis = a;
              }
            });
            ret = [];
            value = axis.translate(value);
            tickPositions = xAxis.tickPositions;
            if (xAxis.autoConnect) {
              tickPositions = tickPositions.concat([tickPositions[0]]);
            }
            if (reverse) {
              tickPositions = [].concat(tickPositions).reverse();
            }
            each(tickPositions, function(pos, i) {
              xy = xAxis.getPosition(pos, value);
              ret.push(i ? 'L' : 'M', xy.x, xy.y);
            });
          }
          return ret;
        },
        getTitlePosition: function() {
          var center = this.center,
            chart = this.chart,
            titleOptions = this.options.title;
          return {
            x: chart.plotLeft + center[0] + (titleOptions.x || 0),
            y: (
              chart.plotTop +
              center[1] -
              ({
                high: 0.5,
                middle: 0.25,
                low: 0
              } [titleOptions.align] * center[2]) +
              (titleOptions.y || 0)
            )
          };
        }
      };
      addEvent(Axis, 'init', function(e) {
        var chart = this.chart,
          angular = chart.angular,
          polar = chart.polar,
          isX = this.isXAxis,
          isHidden = angular && isX,
          isCircular,
          chartOptions = chart.options,
          paneIndex = e.userOptions.pane || 0,
          pane = this.pane = chart.pane && chart.pane[paneIndex];
        if (angular) {
          extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);
          isCircular = !isX;
          if (isCircular) {
            this.defaultRadialOptions = this.defaultRadialGaugeOptions;
          }
        } else if (polar) {
          extend(this, radialAxisMixin);
          isCircular = isX;
          this.defaultRadialOptions = isX ?
            this.defaultRadialXOptions :
            merge(this.defaultYAxisOptions, this.defaultRadialYOptions);
        }
        if (angular || polar) {
          this.isRadial = true;
          chart.inverted = false;
          chartOptions.chart.zoomType = null;
        } else {
          this.isRadial = false;
        }
        if (pane && isCircular) {
          pane.axis = this;
        }
        this.isCircular = isCircular;
      });
      addEvent(Axis, 'afterInit', function() {
        var chart = this.chart,
          options = this.options,
          isHidden = chart.angular && this.isXAxis,
          pane = this.pane,
          paneOptions = pane && pane.options;
        if (!isHidden && pane && (chart.angular || chart.polar)) {
          this.angleRad = (options.angle || 0) * Math.PI / 180;
          this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
          this.endAngleRad = (
            pick(paneOptions.endAngle, paneOptions.startAngle + 360) - 90
          ) * Math.PI / 180;
          this.offset = options.offset || 0;
        }
      });
      wrap(axisProto, 'autoLabelAlign', function(proceed) {
        if (!this.isRadial) {
          return proceed.apply(this, [].slice.call(arguments, 1));
        }
      });
      addEvent(Tick, 'afterGetPosition', function(e) {
        if (this.axis.getPosition) {
          extend(e.pos, this.axis.getPosition(this.pos));
        }
      });
      addEvent(Tick, 'afterGetLabelPosition', function(e) {
        var axis = this.axis,
          label = this.label,
          labelOptions = axis.options.labels,
          optionsY = labelOptions.y,
          ret,
          centerSlot = 20,
          align = labelOptions.align,
          angle = (
            (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) /
            Math.PI * 180
          ) % 360;
        if (axis.isRadial) {
          ret = axis.getPosition(this.pos, (axis.center[2] / 2) +
            pick(labelOptions.distance, -25));
          if (labelOptions.rotation === 'auto') {
            label.attr({
              rotation: angle
            });
          } else if (optionsY === null) {
            optionsY = (
              axis.chart.renderer
              .fontMetrics(label.styles && label.styles.fontSize).b -
              label.getBBox().height / 2
            );
          }
          if (align === null) {
            if (axis.isCircular) {
              if (
                this.label.getBBox().width >
                axis.len * axis.tickInterval / (axis.max - axis.min)
              ) {
                centerSlot = 0;
              }
              if (angle > centerSlot && angle < 180 - centerSlot) {
                align = 'left';
              } else if (
                angle > 180 + centerSlot &&
                angle < 360 - centerSlot
              ) {
                align = 'right';
              } else {
                align = 'center';
              }
            } else {
              align = 'center';
            }
            label.attr({
              align: align
            });
          }
          e.pos.x = ret.x + labelOptions.x;
          e.pos.y = ret.y + optionsY;
        }
      });
      wrap(tickProto, 'getMarkPath', function(
        proceed,
        x,
        y,
        tickLength,
        tickWidth,
        horiz,
        renderer
      ) {
        var axis = this.axis,
          endPoint,
          ret;
        if (axis.isRadial) {
          endPoint = axis.getPosition(
            this.pos,
            axis.center[2] / 2 + tickLength
          );
          ret = [
            'M',
            x,
            y,
            'L',
            endPoint.x,
            endPoint.y
          ];
        } else {
          ret = proceed.call(
            this,
            x,
            y,
            tickLength,
            tickWidth,
            horiz,
            renderer
          );
        }
        return ret;
      });
    }
  }(Highcharts));
  (function(H) {
    var each = H.each,
      noop = H.noop,
      pick = H.pick,
      defined = H.defined,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes,
      seriesProto = Series.prototype,
      pointProto = H.Point.prototype;
    seriesType('arearange', 'area', {
      lineWidth: 1,
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      trackByArea: true,
      dataLabels: {
        align: null,
        verticalAlign: null,
        xLow: 0,
        xHigh: 0,
        yLow: 0,
        yHigh: 0
      }
    }, {
      pointArrayMap: ['low', 'high'],
      dataLabelCollections: ['dataLabel', 'dataLabelUpper'],
      toYData: function(point) {
        return [point.low, point.high];
      },
      pointValKey: 'low',
      deferTranslatePolar: true,
      highToXY: function(point) {
        var chart = this.chart,
          xy = this.xAxis.postTranslate(
            point.rectPlotX,
            this.yAxis.len - point.plotHigh
          );
        point.plotHighX = xy.x - chart.plotLeft;
        point.plotHigh = xy.y - chart.plotTop;
        point.plotLowX = point.plotX;
      },
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          hasModifyValue = !!series.modifyValue;
        seriesTypes.area.prototype.translate.apply(series);
        each(series.points, function(point) {
          var low = point.low,
            high = point.high,
            plotY = point.plotY;
          if (high === null || low === null) {
            point.isNull = true;
            point.plotY = null;
          } else {
            point.plotLow = plotY;
            point.plotHigh = yAxis.translate(
              hasModifyValue ? series.modifyValue(high, point) : high,
              0,
              1,
              0,
              1
            );
            if (hasModifyValue) {
              point.yBottom = point.plotHigh;
            }
          }
        });
        if (this.chart.polar) {
          each(this.points, function(point) {
            series.highToXY(point);
            point.tooltipPos = [
              (point.plotHighX + point.plotLowX) / 2,
              (point.plotHigh + point.plotLow) / 2
            ];
          });
        }
      },
      getGraphPath: function(points) {
        var highPoints = [],
          highAreaPoints = [],
          i,
          getGraphPath = seriesTypes.area.prototype.getGraphPath,
          point,
          pointShim,
          linePath,
          lowerPath,
          options = this.options,
          connectEnds = this.chart.polar && options.connectEnds !== false,
          connectNulls = options.connectNulls,
          step = options.step,
          higherPath,
          higherAreaPath;
        points = points || this.points;
        i = points.length;
        i = points.length;
        while (i--) {
          point = points[i];
          if (
            !point.isNull &&
            !connectEnds &&
            !connectNulls &&
            (!points[i + 1] || points[i + 1].isNull)
          ) {
            highAreaPoints.push({
              plotX: point.plotX,
              plotY: point.plotY,
              doCurve: false
            });
          }
          pointShim = {
            polarPlotY: point.polarPlotY,
            rectPlotX: point.rectPlotX,
            yBottom: point.yBottom,
            plotX: pick(point.plotHighX, point.plotX),
            plotY: point.plotHigh,
            isNull: point.isNull
          };
          highAreaPoints.push(pointShim);
          highPoints.push(pointShim);
          if (
            !point.isNull &&
            !connectEnds &&
            !connectNulls &&
            (!points[i - 1] || points[i - 1].isNull)
          ) {
            highAreaPoints.push({
              plotX: point.plotX,
              plotY: point.plotY,
              doCurve: false
            });
          }
        }
        lowerPath = getGraphPath.call(this, points);
        if (step) {
          if (step === true) {
            step = 'left';
          }
          options.step = {
            left: 'right',
            center: 'center',
            right: 'left'
          } [step];
        }
        higherPath = getGraphPath.call(this, highPoints);
        higherAreaPath = getGraphPath.call(this, highAreaPoints);
        options.step = step;
        linePath = [].concat(lowerPath, higherPath);
        if (!this.chart.polar && higherAreaPath[0] === 'M') {
          higherAreaPath[0] = 'L';
        }
        this.graphPath = linePath;
        this.areaPath = lowerPath.concat(higherAreaPath);
        linePath.isArea = true;
        linePath.xMap = lowerPath.xMap;
        this.areaPath.xMap = lowerPath.xMap;
        return linePath;
      },
      drawDataLabels: function() {
        var data = this.data,
          length = data.length,
          i,
          originalDataLabels = [],
          dataLabelOptions = this.options.dataLabels,
          align = dataLabelOptions.align,
          verticalAlign = dataLabelOptions.verticalAlign,
          inside = dataLabelOptions.inside,
          point,
          up,
          inverted = this.chart.inverted;
        if (dataLabelOptions.enabled || this._hasPointLabels) {
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = inside ?
                point.plotHigh < point.plotLow :
                point.plotHigh > point.plotLow;
              point.y = point.high;
              point._plotY = point.plotY;
              point.plotY = point.plotHigh;
              originalDataLabels[i] = point.dataLabel;
              point.dataLabel = point.dataLabelUpper;
              point.below = up;
              if (inverted) {
                if (!align) {
                  dataLabelOptions.align = up ? 'right' : 'left';
                }
              } else {
                if (!verticalAlign) {
                  dataLabelOptions.verticalAlign = up ?
                    'top' :
                    'bottom';
                }
              }
              dataLabelOptions.x = dataLabelOptions.xHigh;
              dataLabelOptions.y = dataLabelOptions.yHigh;
            }
          }
          if (seriesProto.drawDataLabels) {
            seriesProto.drawDataLabels.apply(this, arguments);
          }
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = inside ?
                point.plotHigh < point.plotLow :
                point.plotHigh > point.plotLow;
              point.dataLabelUpper = point.dataLabel;
              point.dataLabel = originalDataLabels[i];
              point.y = point.low;
              point.plotY = point._plotY;
              point.below = !up;
              if (inverted) {
                if (!align) {
                  dataLabelOptions.align = up ? 'left' : 'right';
                }
              } else {
                if (!verticalAlign) {
                  dataLabelOptions.verticalAlign = up ?
                    'bottom' :
                    'top';
                }
              }
              dataLabelOptions.x = dataLabelOptions.xLow;
              dataLabelOptions.y = dataLabelOptions.yLow;
            }
          }
          if (seriesProto.drawDataLabels) {
            seriesProto.drawDataLabels.apply(this, arguments);
          }
        }
        dataLabelOptions.align = align;
        dataLabelOptions.verticalAlign = verticalAlign;
      },
      alignDataLabel: function() {
        seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);
      },
      drawPoints: function() {
        var series = this,
          pointLength = series.points.length,
          point,
          i;
        seriesProto.drawPoints.apply(series, arguments);
        i = 0;
        while (i < pointLength) {
          point = series.points[i];
          point.origProps = {
            plotY: point.plotY,
            plotX: point.plotX,
            isInside: point.isInside,
            negative: point.negative,
            zone: point.zone,
            y: point.y
          };
          point.lowerGraphic = point.graphic;
          point.graphic = point.upperGraphic;
          point.plotY = point.plotHigh;
          if (defined(point.plotHighX)) {
            point.plotX = point.plotHighX;
          }
          point.y = point.high;
          point.negative = point.high < (series.options.threshold || 0);
          point.zone = series.zones.length && point.getZone();
          if (!series.chart.polar) {
            point.isInside = point.isTopInside = (
              point.plotY !== undefined &&
              point.plotY >= 0 &&
              point.plotY <= series.yAxis.len &&
              point.plotX >= 0 &&
              point.plotX <= series.xAxis.len
            );
          }
          i++;
        }
        seriesProto.drawPoints.apply(series, arguments);
        i = 0;
        while (i < pointLength) {
          point = series.points[i];
          point.upperGraphic = point.graphic;
          point.graphic = point.lowerGraphic;
          H.extend(point, point.origProps);
          delete point.origProps;
          i++;
        }
      },
      setStackedPoints: noop
    }, {
      setState: function() {
        var prevState = this.state,
          series = this.series,
          isPolar = series.chart.polar;
        if (!defined(this.plotHigh)) {
          this.plotHigh = series.yAxis.toPixels(this.high, true);
        }
        if (!defined(this.plotLow)) {
          this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
        }
        if (series.stateMarkerGraphic) {
          series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
          series.stateMarkerGraphic = series.upperStateMarkerGraphic;
        }
        this.graphic = this.upperGraphic;
        this.plotY = this.plotHigh;
        if (isPolar) {
          this.plotX = this.plotHighX;
        }
        pointProto.setState.apply(this, arguments);
        this.state = prevState;
        this.plotY = this.plotLow;
        this.graphic = this.lowerGraphic;
        if (isPolar) {
          this.plotX = this.plotLowX;
        }
        if (series.stateMarkerGraphic) {
          series.upperStateMarkerGraphic = series.stateMarkerGraphic;
          series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
          series.lowerStateMarkerGraphic = undefined;
        }
        pointProto.setState.apply(this, arguments);
      },
      haloPath: function() {
        var isPolar = this.series.chart.polar,
          path = [];
        this.plotY = this.plotLow;
        if (isPolar) {
          this.plotX = this.plotLowX;
        }
        if (this.isInside) {
          path = pointProto.haloPath.apply(this, arguments);
        }
        this.plotY = this.plotHigh;
        if (isPolar) {
          this.plotX = this.plotHighX;
        }
        if (this.isTopInside) {
          path = path.concat(
            pointProto.haloPath.apply(this, arguments)
          );
        }
        return path;
      },
      destroyElements: function() {
        var graphics = ['lowerGraphic', 'upperGraphic'];
        each(graphics, function(graphicName) {
          if (this[graphicName]) {
            this[graphicName] = this[graphicName].destroy();
          }
        }, this);
        this.graphic = null;
        return pointProto.destroyElements.apply(this, arguments);
      }
    });
  }(Highcharts));
  (function(H) {
    var seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('areasplinerange', 'arearange', null, {
      getPointSpline: seriesTypes.spline.prototype.getPointSpline
    });
  }(Highcharts));
  (function(H) {
    var defaultPlotOptions = H.defaultPlotOptions,
      each = H.each,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    var colProto = seriesTypes.column.prototype;
    var columnRangeOptions = {
      pointRange: null,
      marker: null,
      states: {
        hover: {
          halo: false
        }
      }
    };
    seriesType('columnrange', 'arearange', merge(
      defaultPlotOptions.column,
      defaultPlotOptions.arearange,
      columnRangeOptions
    ), {
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          xAxis = series.xAxis,
          startAngleRad = xAxis.startAngleRad,
          start,
          chart = series.chart,
          isRadial = series.xAxis.isRadial,
          safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999,
          plotHigh;

        function safeBounds(pixelPos) {
          return Math.min(Math.max(
            -safeDistance,
            pixelPos
          ), safeDistance);
        }
        colProto.translate.apply(series);
        each(series.points, function(point) {
          var shapeArgs = point.shapeArgs,
            minPointLength = series.options.minPointLength,
            heightDifference,
            height,
            y;
          point.plotHigh = plotHigh = safeBounds(
            yAxis.translate(point.high, 0, 1, 0, 1)
          );
          point.plotLow = safeBounds(point.plotY);
          y = plotHigh;
          height = pick(point.rectPlotY, point.plotY) - plotHigh;
          if (Math.abs(height) < minPointLength) {
            heightDifference = (minPointLength - height);
            height += heightDifference;
            y -= heightDifference / 2;
          } else if (height < 0) {
            height *= -1;
            y -= height;
          }
          if (isRadial) {
            start = point.barX + startAngleRad;
            point.shapeType = 'path';
            point.shapeArgs = {
              d: series.polarArc(
                y + height,
                y,
                start,
                start + point.pointWidth
              )
            };
          } else {
            shapeArgs.height = height;
            shapeArgs.y = y;
            point.tooltipPos = chart.inverted ? [
              yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
              xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x -
              shapeArgs.width / 2,
              height
            ] : [
              xAxis.left - chart.plotLeft + shapeArgs.x +
              shapeArgs.width / 2,
              yAxis.pos - chart.plotTop + y + height / 2,
              height
            ];
          }
        });
      },
      directTouch: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      drawGraph: noop,
      getSymbol: noop,
      crispCol: colProto.crispCol,
      drawPoints: colProto.drawPoints,
      drawTracker: colProto.drawTracker,
      getColumnMetrics: colProto.getColumnMetrics,
      pointAttribs: colProto.pointAttribs,
      animate: function() {
        return colProto.animate.apply(this, arguments);
      },
      polarArc: function() {
        return colProto.polarArc.apply(this, arguments);
      },
      translate3dPoints: function() {
        return colProto.translate3dPoints.apply(this, arguments);
      },
      translate3dShapes: function() {
        return colProto.translate3dShapes.apply(this, arguments);
      }
    }, {
      setState: colProto.pointClass.prototype.setState
    });
  }(Highcharts));
  (function(H) {
    var each = H.each,
      isNumber = H.isNumber,
      merge = H.merge,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      Series = H.Series,
      seriesType = H.seriesType,
      TrackerMixin = H.TrackerMixin;
    seriesType('gauge', 'line', {
      dataLabels: {
        enabled: true,
        defer: false,
        y: 15,
        borderRadius: 3,
        crop: false,
        verticalAlign: 'top',
        zIndex: 2,
        borderWidth: 1,
        borderColor: '#cccccc'
      },
      dial: {},
      pivot: {},
      tooltip: {
        headerFormat: ''
      },
      showInLegend: false
    }, {
      angular: true,
      directTouch: true,
      drawGraph: noop,
      fixedBox: true,
      forceDL: true,
      noSharedTooltip: true,
      trackerGroups: ['group', 'dataLabelsGroup'],
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          options = series.options,
          center = yAxis.center;
        series.generatePoints();
        each(series.points, function(point) {
          var dialOptions = merge(options.dial, point.dial),
            radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) /
            200,
            baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) /
            100,
            rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) /
            100,
            baseWidth = dialOptions.baseWidth || 3,
            topWidth = dialOptions.topWidth || 1,
            overshoot = options.overshoot,
            rotation = yAxis.startAngleRad +
            yAxis.translate(point.y, null, null, null, true);
          if (isNumber(overshoot)) {
            overshoot = overshoot / 180 * Math.PI;
            rotation = Math.max(
              yAxis.startAngleRad - overshoot,
              Math.min(yAxis.endAngleRad + overshoot, rotation)
            );
          } else if (options.wrap === false) {
            rotation = Math.max(
              yAxis.startAngleRad,
              Math.min(yAxis.endAngleRad, rotation)
            );
          }
          rotation = rotation * 180 / Math.PI;
          point.shapeType = 'path';
          point.shapeArgs = {
            d: dialOptions.path || [
              'M',
              -rearLength, -baseWidth / 2,
              'L',
              baseLength, -baseWidth / 2,
              radius, -topWidth / 2,
              radius, topWidth / 2,
              baseLength, baseWidth / 2,
              -rearLength, baseWidth / 2,
              'z'
            ],
            translateX: center[0],
            translateY: center[1],
            rotation: rotation
          };
          point.plotX = center[0];
          point.plotY = center[1];
        });
      },
      drawPoints: function() {
        var series = this,
          center = series.yAxis.center,
          pivot = series.pivot,
          options = series.options,
          pivotOptions = options.pivot,
          renderer = series.chart.renderer;
        each(series.points, function(point) {
          var graphic = point.graphic,
            shapeArgs = point.shapeArgs,
            d = shapeArgs.d,
            dialOptions = merge(options.dial, point.dial);
          if (graphic) {
            graphic.animate(shapeArgs);
            shapeArgs.d = d;
          } else {
            point.graphic = renderer[point.shapeType](shapeArgs)
              .attr({
                rotation: shapeArgs.rotation,
                zIndex: 1
              })
              .addClass('highcharts-dial')
              .add(series.group);
            point.graphic.attr({
              stroke: dialOptions.borderColor || 'none',
              'stroke-width': dialOptions.borderWidth || 0,
              fill: dialOptions.backgroundColor ||
                '#000000'
            });
          }
        });
        if (pivot) {
          pivot.animate({
            translateX: center[0],
            translateY: center[1]
          });
        } else {
          series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))
            .attr({
              zIndex: 2
            })
            .addClass('highcharts-pivot')
            .translate(center[0], center[1])
            .add(series.group);
          series.pivot.attr({
            'stroke-width': pivotOptions.borderWidth || 0,
            stroke: pivotOptions.borderColor ||
              '#cccccc',
            fill: pivotOptions.backgroundColor ||
              '#000000'
          });
        }
      },
      animate: function(init) {
        var series = this;
        if (!init) {
          each(series.points, function(point) {
            var graphic = point.graphic;
            if (graphic) {
              graphic.attr({
                rotation: series.yAxis.startAngleRad * 180 / Math.PI
              });
              graphic.animate({
                rotation: point.shapeArgs.rotation
              }, series.options.animation);
            }
          });
          series.animate = null;
        }
      },
      render: function() {
        this.group = this.plotGroup(
          'group',
          'series',
          this.visible ? 'visible' : 'hidden',
          this.options.zIndex,
          this.chart.seriesGroup
        );
        Series.prototype.render.call(this);
        this.group.clip(this.chart.clipRect);
      },
      setData: function(data, redraw) {
        Series.prototype.setData.call(this, data, false);
        this.processData();
        this.generatePoints();
        if (pick(redraw, true)) {
          this.chart.redraw();
        }
      },
      drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint
    }, {
      setState: function(state) {
        this.state = state;
      }
    });
  }(Highcharts));
  (function(H) {
    var each = H.each,
      noop = H.noop,
      pick = H.pick,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('boxplot', 'column', {
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> ' +
          '{series.name}</b><br/>' +
          'Maximum: {point.high}<br/>' +
          'Upper quartile: {point.q3}<br/>' +
          'Median: {point.median}<br/>' +
          'Lower quartile: {point.q1}<br/>' +
          'Minimum: {point.low}<br/>'
      },
      whiskerLength: '50%',
      fillColor: '#ffffff',
      lineWidth: 1,
      medianWidth: 2,
      whiskerWidth: 2
    }, {
      pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],
      toYData: function(point) {
        return [point.low, point.q1, point.median, point.q3, point.high];
      },
      pointValKey: 'high',
      pointAttribs: function() {
        return {};
      },
      drawDataLabels: noop,
      translate: function() {
        var series = this,
          yAxis = series.yAxis,
          pointArrayMap = series.pointArrayMap;
        seriesTypes.column.prototype.translate.apply(series);
        each(series.points, function(point) {
          each(pointArrayMap, function(key) {
            if (point[key] !== null) {
              point[key + 'Plot'] = yAxis.translate(
                point[key], 0, 1, 0, 1
              );
            }
          });
        });
      },
      drawPoints: function() {
        var series = this,
          points = series.points,
          options = series.options,
          chart = series.chart,
          renderer = chart.renderer,
          q1Plot,
          q3Plot,
          highPlot,
          lowPlot,
          medianPlot,
          medianPath,
          crispCorr,
          crispX = 0,
          boxPath,
          width,
          left,
          right,
          halfWidth,
          doQuartiles = series.doQuartiles !== false,
          pointWiskerLength,
          whiskerLength = series.options.whiskerLength;
        each(points, function(point) {
          var graphic = point.graphic,
            verb = graphic ? 'animate' : 'attr',
            shapeArgs = point.shapeArgs;
          var boxAttr = {},
            stemAttr = {},
            whiskersAttr = {},
            medianAttr = {},
            color = point.color || series.color;
          if (point.plotY !== undefined) {
            width = shapeArgs.width;
            left = Math.floor(shapeArgs.x);
            right = left + width;
            halfWidth = Math.round(width / 2);
            q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
            q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
            highPlot = Math.floor(point.highPlot);
            lowPlot = Math.floor(point.lowPlot);
            if (!graphic) {
              point.graphic = graphic = renderer.g('point')
                .add(series.group);
              point.stem = renderer.path()
                .addClass('highcharts-boxplot-stem')
                .add(graphic);
              if (whiskerLength) {
                point.whiskers = renderer.path()
                  .addClass('highcharts-boxplot-whisker')
                  .add(graphic);
              }
              if (doQuartiles) {
                point.box = renderer.path(boxPath)
                  .addClass('highcharts-boxplot-box')
                  .add(graphic);
              }
              point.medianShape = renderer.path(medianPath)
                .addClass('highcharts-boxplot-median')
                .add(graphic);
            }
            stemAttr.stroke = point.stemColor || options.stemColor || color;
            stemAttr['stroke-width'] = pick(
              point.stemWidth,
              options.stemWidth,
              options.lineWidth
            );
            stemAttr.dashstyle =
              point.stemDashStyle || options.stemDashStyle;
            point.stem.attr(stemAttr);
            if (whiskerLength) {
              whiskersAttr.stroke =
                point.whiskerColor || options.whiskerColor || color;
              whiskersAttr['stroke-width'] = pick(
                point.whiskerWidth,
                options.whiskerWidth,
                options.lineWidth
              );
              point.whiskers.attr(whiskersAttr);
            }
            if (doQuartiles) {
              boxAttr.fill = (
                point.fillColor ||
                options.fillColor ||
                color
              );
              boxAttr.stroke = options.lineColor || color;
              boxAttr['stroke-width'] = options.lineWidth || 0;
              point.box.attr(boxAttr);
            }
            medianAttr.stroke =
              point.medianColor || options.medianColor || color;
            medianAttr['stroke-width'] = pick(
              point.medianWidth,
              options.medianWidth,
              options.lineWidth
            );
            point.medianShape.attr(medianAttr);
            crispCorr = (point.stem.strokeWidth() % 2) / 2;
            crispX = left + halfWidth + crispCorr;
            point.stem[verb]({
              d: [
                'M',
                crispX, q3Plot,
                'L',
                crispX, highPlot,
                'M',
                crispX, q1Plot,
                'L',
                crispX, lowPlot
              ]
            });
            if (doQuartiles) {
              crispCorr = (point.box.strokeWidth() % 2) / 2;
              q1Plot = Math.floor(q1Plot) + crispCorr;
              q3Plot = Math.floor(q3Plot) + crispCorr;
              left += crispCorr;
              right += crispCorr;
              point.box[verb]({
                d: [
                  'M',
                  left, q3Plot,
                  'L',
                  left, q1Plot,
                  'L',
                  right, q1Plot,
                  'L',
                  right, q3Plot,
                  'L',
                  left, q3Plot,
                  'z'
                ]
              });
            }
            if (whiskerLength) {
              crispCorr = (point.whiskers.strokeWidth() % 2) / 2;
              highPlot = highPlot + crispCorr;
              lowPlot = lowPlot + crispCorr;
              pointWiskerLength = (/%$/).test(whiskerLength) ?
                halfWidth * parseFloat(whiskerLength) / 100 :
                whiskerLength / 2;
              point.whiskers[verb]({
                d: [
                  'M',
                  crispX - pointWiskerLength,
                  highPlot,
                  'L',
                  crispX + pointWiskerLength,
                  highPlot,
                  'M',
                  crispX - pointWiskerLength,
                  lowPlot,
                  'L',
                  crispX + pointWiskerLength,
                  lowPlot
                ]
              });
            }
            medianPlot = Math.round(point.medianPlot);
            crispCorr = (point.medianShape.strokeWidth() % 2) / 2;
            medianPlot = medianPlot + crispCorr;
            point.medianShape[verb]({
              d: [
                'M',
                left,
                medianPlot,
                'L',
                right,
                medianPlot
              ]
            });
          }
        });
      },
      setStackedPoints: noop
    });
  }(Highcharts));
  (function(H) {
    var each = H.each,
      noop = H.noop,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('errorbar', 'boxplot', {
      color: '#000000',
      grouping: false,
      linkedTo: ':previous',
      tooltip: {
        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      whiskerWidth: null
    }, {
      type: 'errorbar',
      pointArrayMap: ['low', 'high'],
      toYData: function(point) {
        return [point.low, point.high];
      },
      pointValKey: 'high',
      doQuartiles: false,
      drawDataLabels: seriesTypes.arearange ?
        function() {
          var valKey = this.pointValKey;
          seriesTypes.arearange.prototype.drawDataLabels.call(this);
          each(this.data, function(point) {
            point.y = point[valKey];
          });
        } : noop,
      getColumnMetrics: function() {
        return (this.linkedParent && this.linkedParent.columnMetrics) ||
          seriesTypes.column.prototype.getColumnMetrics.call(this);
      }
    });
  }(Highcharts));
  (function(H) {
    var correctFloat = H.correctFloat,
      isNumber = H.isNumber,
      pick = H.pick,
      Point = H.Point,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('waterfall', 'column', {
      dataLabels: {
        inside: true
      },
      lineWidth: 1,
      lineColor: '#333333',
      dashStyle: 'dot',
      borderColor: '#333333',
      states: {
        hover: {
          lineWidthPlus: 0
        }
      }
    }, {
      pointValKey: 'y',
      showLine: true,
      translate: function() {
        var series = this,
          options = series.options,
          yAxis = series.yAxis,
          len,
          i,
          points,
          point,
          shapeArgs,
          stack,
          y,
          yValue,
          previousY,
          previousIntermediate,
          range,
          minPointLength = pick(options.minPointLength, 5),
          halfMinPointLength = minPointLength / 2,
          threshold = options.threshold,
          stacking = options.stacking,
          stackIndicator,
          tooltipY;
        seriesTypes.column.prototype.translate.apply(series);
        previousY = previousIntermediate = threshold;
        points = series.points;
        for (i = 0, len = points.length; i < len; i++) {
          point = points[i];
          yValue = series.processedYData[i];
          shapeArgs = point.shapeArgs;
          stack = stacking &&
            yAxis.stacks[
              (series.negStacks && yValue < threshold ? '-' : '') +
              series.stackKey
            ];
          stackIndicator = series.getStackIndicator(
            stackIndicator,
            point.x,
            series.index
          );
          range = pick(
            stack && stack[point.x].points[stackIndicator.key],
            [0, yValue]
          );
          if (point.isSum) {
            point.y = correctFloat(yValue);
          } else if (point.isIntermediateSum) {
            point.y = correctFloat(yValue - previousIntermediate);
          }
          y = Math.max(previousY, previousY + point.y) + range[0];
          shapeArgs.y = yAxis.translate(y, 0, 1, 0, 1);
          if (point.isSum) {
            shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);
            shapeArgs.height = Math.min(
              yAxis.translate(range[0], 0, 1, 0, 1),
              yAxis.len
            ) - shapeArgs.y;
          } else if (point.isIntermediateSum) {
            shapeArgs.y = yAxis.translate(range[1], 0, 1, 0, 1);
            shapeArgs.height = Math.min(
              yAxis.translate(previousIntermediate, 0, 1, 0, 1),
              yAxis.len
            ) - shapeArgs.y;
            previousIntermediate = range[1];
          } else {
            shapeArgs.height = yValue > 0 ?
              yAxis.translate(previousY, 0, 1, 0, 1) - shapeArgs.y :
              yAxis.translate(previousY, 0, 1, 0, 1) -
              yAxis.translate(previousY - yValue, 0, 1, 0, 1);
            previousY += stack && stack[point.x] ?
              stack[point.x].total :
              yValue;
          }
          if (shapeArgs.height < 0) {
            shapeArgs.y += shapeArgs.height;
            shapeArgs.height *= -1;
          }
          point.plotY = shapeArgs.y = Math.round(shapeArgs.y) -
            (series.borderWidth % 2) / 2;
          shapeArgs.height = Math.max(Math.round(shapeArgs.height), 0.001);
          point.yBottom = shapeArgs.y + shapeArgs.height;
          if (shapeArgs.height <= minPointLength && !point.isNull) {
            shapeArgs.height = minPointLength;
            shapeArgs.y -= halfMinPointLength;
            point.plotY = shapeArgs.y;
            if (point.y < 0) {
              point.minPointLengthOffset = -halfMinPointLength;
            } else {
              point.minPointLengthOffset = halfMinPointLength;
            }
          } else {
            point.minPointLengthOffset = 0;
          }
          tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
          if (series.chart.inverted) {
            point.tooltipPos[0] = yAxis.len - tooltipY;
          } else {
            point.tooltipPos[1] = tooltipY;
          }
        }
      },
      processData: function(force) {
        var series = this,
          options = series.options,
          yData = series.yData,
          points = series.options.data,
          point,
          dataLength = yData.length,
          threshold = options.threshold || 0,
          subSum,
          sum,
          dataMin,
          dataMax,
          y,
          i;
        sum = subSum = dataMin = dataMax = threshold;
        for (i = 0; i < dataLength; i++) {
          y = yData[i];
          point = points && points[i] ? points[i] : {};
          if (y === 'sum' || point.isSum) {
            yData[i] = correctFloat(sum);
          } else if (y === 'intermediateSum' || point.isIntermediateSum) {
            yData[i] = correctFloat(subSum);
          } else {
            sum += y;
            subSum += y;
          }
          dataMin = Math.min(sum, dataMin);
          dataMax = Math.max(sum, dataMax);
        }
        Series.prototype.processData.call(this, force);
        if (!series.options.stacking) {
          series.dataMin = dataMin;
          series.dataMax = dataMax;
        }
      },
      toYData: function(pt) {
        if (pt.isSum) {
          return (pt.x === 0 ? null : 'sum');
        }
        if (pt.isIntermediateSum) {
          return (pt.x === 0 ? null : 'intermediateSum');
        }
        return pt.y;
      },
      pointAttribs: function(point, state) {
        var upColor = this.options.upColor,
          attr;
        if (upColor && !point.options.color) {
          point.color = point.y > 0 ? upColor : null;
        }
        attr = seriesTypes.column.prototype.pointAttribs.call(
          this,
          point,
          state
        );
        delete attr.dashstyle;
        return attr;
      },
      getGraphPath: function() {
        return ['M', 0, 0];
      },
      getCrispPath: function() {
        var data = this.data,
          length = data.length,
          lineWidth = this.graph.strokeWidth() + this.borderWidth,
          normalizer = Math.round(lineWidth) % 2 / 2,
          reversedXAxis = this.xAxis.reversed,
          reversedYAxis = this.yAxis.reversed,
          path = [],
          prevArgs,
          pointArgs,
          i,
          d;
        for (i = 1; i < length; i++) {
          pointArgs = data[i].shapeArgs;
          prevArgs = data[i - 1].shapeArgs;
          d = [
            'M',
            prevArgs.x + (reversedXAxis ? 0 : prevArgs.width),
            prevArgs.y + data[i - 1].minPointLengthOffset + normalizer,
            'L',
            pointArgs.x + (reversedXAxis ? prevArgs.width : 0),
            prevArgs.y + data[i - 1].minPointLengthOffset + normalizer
          ];
          if (
            (data[i - 1].y < 0 && !reversedYAxis) ||
            (data[i - 1].y > 0 && reversedYAxis)
          ) {
            d[2] += prevArgs.height;
            d[5] += prevArgs.height;
          }
          path = path.concat(d);
        }
        return path;
      },
      drawGraph: function() {
        Series.prototype.drawGraph.call(this);
        this.graph.attr({
          d: this.getCrispPath()
        });
      },
      setStackedPoints: function() {
        var series = this,
          options = series.options,
          stackedYLength,
          i;
        Series.prototype.setStackedPoints.apply(series, arguments);
        stackedYLength = series.stackedYData ? series.stackedYData.length : 0;
        for (i = 1; i < stackedYLength; i++) {
          if (
            !options.data[i].isSum &&
            !options.data[i].isIntermediateSum
          ) {
            series.stackedYData[i] += series.stackedYData[i - 1];
          }
        }
      },
      getExtremes: function() {
        if (this.options.stacking) {
          return Series.prototype.getExtremes.apply(this, arguments);
        }
      }
    }, {
      getClassName: function() {
        var className = Point.prototype.getClassName.call(this);
        if (this.isSum) {
          className += ' highcharts-sum';
        } else if (this.isIntermediateSum) {
          className += ' highcharts-intermediate-sum';
        }
        return className;
      },
      isValid: function() {
        return isNumber(this.y, true) || this.isSum || this.isIntermediateSum;
      }
    });
  }(Highcharts));
  (function(H) {
    var LegendSymbolMixin = H.LegendSymbolMixin,
      noop = H.noop,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('polygon', 'scatter', {
      marker: {
        enabled: false,
        states: {
          hover: {
            enabled: false
          }
        }
      },
      stickyTracking: false,
      tooltip: {
        followPointer: true,
        pointFormat: ''
      },
      trackByArea: true
    }, {
      type: 'polygon',
      getGraphPath: function() {
        var graphPath = Series.prototype.getGraphPath.call(this),
          i = graphPath.length + 1;
        while (i--) {
          if ((i === graphPath.length || graphPath[i] === 'M') && i > 0) {
            graphPath.splice(i, 0, 'z');
          }
        }
        this.areaPath = graphPath;
        return graphPath;
      },
      drawGraph: function() {
        this.options.fillColor = this.color;
        seriesTypes.area.prototype.drawGraph.call(this);
      },
      drawLegendSymbol: LegendSymbolMixin.drawRectangle,
      drawTracker: Series.prototype.drawTracker,
      setStackedPoints: noop
    });
  }(Highcharts));
  (function(H) {
    var arrayMax = H.arrayMax,
      arrayMin = H.arrayMin,
      Axis = H.Axis,
      color = H.color,
      each = H.each,
      isNumber = H.isNumber,
      noop = H.noop,
      pick = H.pick,
      pInt = H.pInt,
      Point = H.Point,
      Series = H.Series,
      seriesType = H.seriesType,
      seriesTypes = H.seriesTypes;
    seriesType('bubble', 'scatter', {
      dataLabels: {
        formatter: function() {
          return this.point.z;
        },
        inside: true,
        verticalAlign: 'middle'
      },
      animationLimit: 250,
      marker: {
        lineColor: null,
        lineWidth: 1,
        fillOpacity: 0.5,
        radius: null,
        states: {
          hover: {
            radiusPlus: 0
          }
        },
        symbol: 'circle'
      },
      minSize: 8,
      maxSize: '20%',
      softThreshold: false,
      states: {
        hover: {
          halo: {
            size: 5
          }
        }
      },
      tooltip: {
        pointFormat: '({point.x}, {point.y}), Size: {point.z}'
      },
      turboThreshold: 0,
      zThreshold: 0,
      zoneAxis: 'z'
    }, {
      pointArrayMap: ['y', 'z'],
      parallelArrays: ['x', 'y', 'z'],
      trackerGroups: ['group', 'dataLabelsGroup'],
      specialGroup: 'group',
      bubblePadding: true,
      zoneAxis: 'z',
      directTouch: true,
      pointAttribs: function(point, state) {
        var markerOptions = this.options.marker,
          fillOpacity = markerOptions.fillOpacity,
          attr = Series.prototype.pointAttribs.call(this, point, state);
        if (fillOpacity !== 1) {
          attr.fill = color(attr.fill).setOpacity(fillOpacity).get('rgba');
        }
        return attr;
      },
      getRadii: function(zMin, zMax, minSize, maxSize) {
        var len,
          i,
          pos,
          zData = this.zData,
          radii = [],
          options = this.options,
          sizeByArea = options.sizeBy !== 'width',
          zThreshold = options.zThreshold,
          zRange = zMax - zMin,
          value,
          radius;
        for (i = 0, len = zData.length; i < len; i++) {
          value = zData[i];
          if (options.sizeByAbsoluteValue && value !== null) {
            value = Math.abs(value - zThreshold);
            zMax = zRange = Math.max(
              zMax - zThreshold,
              Math.abs(zMin - zThreshold)
            );
            zMin = 0;
          }
          if (value === null) {
            radius = null;
          } else if (value < zMin) {
            radius = minSize / 2 - 1;
          } else {
            pos = zRange > 0 ? (value - zMin) / zRange : 0.5;
            if (sizeByArea && pos >= 0) {
              pos = Math.sqrt(pos);
            }
            radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
          }
          radii.push(radius);
        }
        this.radii = radii;
      },
      animate: function(init) {
        if (
          !init &&
          this.points.length < this.options.animationLimit
        ) {
          each(this.points, function(point) {
            var graphic = point.graphic,
              animationTarget;
            if (graphic && graphic.width) {
              animationTarget = {
                x: graphic.x,
                y: graphic.y,
                width: graphic.width,
                height: graphic.height
              };
              graphic.attr({
                x: point.plotX,
                y: point.plotY,
                width: 1,
                height: 1
              });
              graphic.animate(animationTarget, this.options.animation);
            }
          }, this);
          this.animate = null;
        }
      },
      translate: function() {
        var i,
          data = this.data,
          point,
          radius,
          radii = this.radii;
        seriesTypes.scatter.prototype.translate.call(this);
        i = data.length;
        while (i--) {
          point = data[i];
          radius = radii ? radii[i] : 0;
          if (isNumber(radius) && radius >= this.minPxSize / 2) {
            point.marker = H.extend(point.marker, {
              radius: radius,
              width: 2 * radius,
              height: 2 * radius
            });
            point.dlBox = {
              x: point.plotX - radius,
              y: point.plotY - radius,
              width: 2 * radius,
              height: 2 * radius
            };
          } else {
            point.shapeArgs = point.plotY = point.dlBox = undefined;
          }
        }
      },
      alignDataLabel: seriesTypes.column.prototype.alignDataLabel,
      buildKDTree: noop,
      applyZones: noop
    }, {
      haloPath: function(size) {
        return Point.prototype.haloPath.call(
          this,
          size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size
        );
      },
      ttBelow: false
    });
    Axis.prototype.beforePadding = function() {
      var axis = this,
        axisLength = this.len,
        chart = this.chart,
        pxMin = 0,
        pxMax = axisLength,
        isXAxis = this.isXAxis,
        dataKey = isXAxis ? 'xData' : 'yData',
        min = this.min,
        extremes = {},
        smallestSize = Math.min(chart.plotWidth, chart.plotHeight),
        zMin = Number.MAX_VALUE,
        zMax = -Number.MAX_VALUE,
        range = this.max - min,
        transA = axisLength / range,
        activeSeries = [];
      each(this.series, function(series) {
        var seriesOptions = series.options,
          zData;
        if (
          series.bubblePadding &&
          (series.visible || !chart.options.chart.ignoreHiddenSeries)
        ) {
          axis.allowZoomOutside = true;
          activeSeries.push(series);
          if (isXAxis) {
            each(['minSize', 'maxSize'], function(prop) {
              var length = seriesOptions[prop],
                isPercent = /%$/.test(length);
              length = pInt(length);
              extremes[prop] = isPercent ?
                smallestSize * length / 100 :
                length;
            });
            series.minPxSize = extremes.minSize;
            series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
            zData = series.zData;
            if (zData.length) {
              zMin = pick(seriesOptions.zMin, Math.min(
                zMin,
                Math.max(
                  arrayMin(zData),
                  seriesOptions.displayNegative === false ?
                  seriesOptions.zThreshold :
                  -Number.MAX_VALUE
                )
              ));
              zMax = pick(
                seriesOptions.zMax,
                Math.max(zMax, arrayMax(zData))
              );
            }
          }
        }
      });
      each(activeSeries, function(series) {
        var data = series[dataKey],
          i = data.length,
          radius;
        if (isXAxis) {
          series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);
        }
        if (range > 0) {
          while (i--) {
            if (
              isNumber(data[i]) &&
              axis.dataMin <= data[i] &&
              data[i] <= axis.dataMax
            ) {
              radius = series.radii[i];
              pxMin = Math.min(
                ((data[i] - min) * transA) - radius,
                pxMin
              );
              pxMax = Math.max(
                ((data[i] - min) * transA) + radius,
                pxMax
              );
            }
          }
        }
      });
      if (activeSeries.length && range > 0 && !this.isLog) {
        pxMax -= axisLength;
        transA *= (axisLength + pxMin - pxMax) / axisLength;
        each(
          [
            ['min', 'userMin', pxMin],
            ['max', 'userMax', pxMax]
          ],
          function(keys) {
            if (pick(axis.options[keys[0]], axis[keys[1]]) === undefined) {
              axis[keys[0]] += keys[2] / transA;
            }
          }
        );
      }
    };
  }(Highcharts));
  (function(H) {
    var each = H.each,
      pick = H.pick,
      Pointer = H.Pointer,
      Series = H.Series,
      seriesTypes = H.seriesTypes,
      wrap = H.wrap,
      seriesProto = Series.prototype,
      pointerProto = Pointer.prototype,
      colProto;
    if (!H.polarExtended) {
      H.polarExtended = true;
      seriesProto.searchPointByAngle = function(e) {
        var series = this,
          chart = series.chart,
          xAxis = series.xAxis,
          center = xAxis.pane.center,
          plotX = e.chartX - center[0] - chart.plotLeft,
          plotY = e.chartY - center[1] - chart.plotTop;
        return this.searchKDTree({
          clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))
        });
      };
      seriesProto.getConnectors = function(
        segment,
        index,
        calculateNeighbours,
        connectEnds
      ) {
        var i,
          prevPointInd,
          nextPointInd,
          previousPoint,
          nextPoint,
          previousX,
          previousY,
          nextX,
          nextY,
          plotX,
          plotY,
          ret,
          smoothing = 1.5,
          denom = smoothing + 1,
          leftContX,
          leftContY,
          rightContX,
          rightContY,
          dLControlPoint,
          dRControlPoint,
          leftContAngle,
          rightContAngle,
          jointAngle,
          addedNumber = connectEnds ? 1 : 0;
        if (index >= 0 && index <= segment.length - 1) {
          i = index;
        } else if (index < 0) {
          i = segment.length - 1 + index;
        } else {
          i = 0;
        }
        prevPointInd = (i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1;
        nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1;
        previousPoint = segment[prevPointInd];
        nextPoint = segment[nextPointInd];
        previousX = previousPoint.plotX;
        previousY = previousPoint.plotY;
        nextX = nextPoint.plotX;
        nextY = nextPoint.plotY;
        plotX = segment[i].plotX;
        plotY = segment[i].plotY;
        leftContX = (smoothing * plotX + previousX) / denom;
        leftContY = (smoothing * plotY + previousY) / denom;
        rightContX = (smoothing * plotX + nextX) / denom;
        rightContY = (smoothing * plotY + nextY) / denom;
        dLControlPoint = Math.sqrt(
          Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)
        );
        dRControlPoint = Math.sqrt(
          Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)
        );
        leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
        rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
        jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);
        if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
          jointAngle -= Math.PI;
        }
        leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
        leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
        rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
        rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
        ret = {
          rightContX: rightContX,
          rightContY: rightContY,
          leftContX: leftContX,
          leftContY: leftContY,
          plotX: plotX,
          plotY: plotY
        };
        if (calculateNeighbours) {
          ret.prevPointCont = this.getConnectors(
            segment,
            prevPointInd,
            false,
            connectEnds
          );
        }
        return ret;
      };
      wrap(seriesProto, 'buildKDTree', function(proceed) {
        if (this.chart.polar) {
          if (this.kdByAngle) {
            this.searchPoint = this.searchPointByAngle;
          } else {
            this.options.findNearestPointBy = 'xy';
          }
        }
        proceed.apply(this);
      });
      seriesProto.toXY = function(point) {
        var xy,
          chart = this.chart,
          plotX = point.plotX,
          plotY = point.plotY,
          clientX;
        point.rectPlotX = plotX;
        point.rectPlotY = plotY;
        xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);
        point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
        point.plotY = point.polarPlotY = xy.y - chart.plotTop;
        if (this.kdByAngle) {
          clientX = (
            (plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle
          ) % 360;
          if (clientX < 0) {
            clientX += 360;
          }
          point.clientX = clientX;
        } else {
          point.clientX = point.plotX;
        }
      };
      if (seriesTypes.spline) {
        wrap(
          seriesTypes.spline.prototype,
          'getPointSpline',
          function(proceed, segment, point, i) {
            var ret,
              connectors;
            if (this.chart.polar) {
              if (!i) {
                ret = ['M', point.plotX, point.plotY];
              } else {
                connectors = this.getConnectors(
                  segment,
                  i,
                  true,
                  this.connectEnds
                );
                ret = [
                  'C',
                  connectors.prevPointCont.rightContX,
                  connectors.prevPointCont.rightContY,
                  connectors.leftContX,
                  connectors.leftContY,
                  connectors.plotX,
                  connectors.plotY
                ];
              }
            } else {
              ret = proceed.call(this, segment, point, i);
            }
            return ret;
          }
        );
        if (seriesTypes.areasplinerange) {
          seriesTypes.areasplinerange.prototype.getPointSpline =
            seriesTypes.spline.prototype.getPointSpline;
        }
      }
      H.addEvent(Series, 'afterTranslate', function() {
        var chart = this.chart,
          points,
          i;
        if (chart.polar) {
          this.kdByAngle = chart.tooltip && chart.tooltip.shared;
          if (!this.preventPostTranslate) {
            points = this.points;
            i = points.length;
            while (i--) {
              this.toXY(points[i]);
            }
          }
          if (!this.hasClipCircleSetter) {
            this.hasClipCircleSetter = Boolean(
              H.addEvent(this, 'afterRender', function() {
                var circ;
                if (chart.polar) {
                  circ = this.yAxis.center;
                  this.group.clip(
                    chart.renderer.clipCircle(
                      circ[0],
                      circ[1],
                      circ[2] / 2
                    )
                  );
                  this.setClip = H.noop;
                }
              })
            );
          }
        }
      });
      wrap(seriesProto, 'getGraphPath', function(proceed, points) {
        var series = this,
          i,
          firstValid,
          popLastPoint;
        if (this.chart.polar) {
          points = points || this.points;
          for (i = 0; i < points.length; i++) {
            if (!points[i].isNull) {
              firstValid = i;
              break;
            }
          }
          if (
            this.options.connectEnds !== false &&
            firstValid !== undefined
          ) {
            this.connectEnds = true;
            points.splice(points.length, 0, points[firstValid]);
            popLastPoint = true;
          }
          each(points, function(point) {
            if (point.polarPlotY === undefined) {
              series.toXY(point);
            }
          });
        }
        var ret = proceed.apply(this, [].slice.call(arguments, 1));
        if (popLastPoint) {
          points.pop();
        }
        return ret;
      });
      var polarAnimate = function(proceed, init) {
        var chart = this.chart,
          animation = this.options.animation,
          group = this.group,
          markerGroup = this.markerGroup,
          center = this.xAxis.center,
          plotLeft = chart.plotLeft,
          plotTop = chart.plotTop,
          attribs;
        if (chart.polar) {
          if (chart.renderer.isSVG) {
            if (animation === true) {
              animation = {};
            }
            if (init) {
              attribs = {
                translateX: center[0] + plotLeft,
                translateY: center[1] + plotTop,
                scaleX: 0.001,
                scaleY: 0.001
              };
              group.attr(attribs);
              if (markerGroup) {
                markerGroup.attr(attribs);
              }
            } else {
              attribs = {
                translateX: plotLeft,
                translateY: plotTop,
                scaleX: 1,
                scaleY: 1
              };
              group.animate(attribs, animation);
              if (markerGroup) {
                markerGroup.animate(attribs, animation);
              }
              this.animate = null;
            }
          }
        } else {
          proceed.call(this, init);
        }
      };
      wrap(seriesProto, 'animate', polarAnimate);
      if (seriesTypes.column) {
        colProto = seriesTypes.column.prototype;
        colProto.polarArc = function(low, high, start, end) {
          var center = this.xAxis.center,
            len = this.yAxis.len;
          return this.chart.renderer.symbols.arc(
            center[0],
            center[1],
            len - high,
            null, {
              start: start,
              end: end,
              innerR: len - pick(low, len)
            }
          );
        };
        wrap(colProto, 'animate', polarAnimate);
        wrap(colProto, 'translate', function(proceed) {
          var xAxis = this.xAxis,
            startAngleRad = xAxis.startAngleRad,
            start,
            points,
            point,
            i;
          this.preventPostTranslate = true;
          proceed.call(this);
          if (xAxis.isRadial) {
            points = this.points;
            i = points.length;
            while (i--) {
              point = points[i];
              start = point.barX + startAngleRad;
              point.shapeType = 'path';
              point.shapeArgs = {
                d: this.polarArc(
                  point.yBottom,
                  point.plotY,
                  start,
                  start + point.pointWidth
                )
              };
              this.toXY(point);
              point.tooltipPos = [point.plotX, point.plotY];
              point.ttBelow = point.plotY > xAxis.center[1];
            }
          }
        });
        wrap(colProto, 'alignDataLabel', function(
          proceed,
          point,
          dataLabel,
          options,
          alignTo,
          isNew
        ) {
          if (this.chart.polar) {
            var angle = point.rectPlotX / Math.PI * 180,
              align,
              verticalAlign;
            if (options.align === null) {
              if (angle > 20 && angle < 160) {
                align = 'left';
              } else if (angle > 200 && angle < 340) {
                align = 'right';
              } else {
                align = 'center';
              }
              options.align = align;
            }
            if (options.verticalAlign === null) {
              if (angle < 45 || angle > 315) {
                verticalAlign = 'bottom';
              } else if (angle > 135 && angle < 225) {
                verticalAlign = 'top';
              } else {
                verticalAlign = 'middle';
              }
              options.verticalAlign = verticalAlign;
            }
            seriesProto.alignDataLabel.call(
              this,
              point,
              dataLabel,
              options,
              alignTo,
              isNew
            );
          } else {
            proceed.call(this, point, dataLabel, options, alignTo, isNew);
          }
        });
      }
      wrap(pointerProto, 'getCoordinates', function(proceed, e) {
        var chart = this.chart,
          ret = {
            xAxis: [],
            yAxis: []
          };
        if (chart.polar) {
          each(chart.axes, function(axis) {
            var isXAxis = axis.isXAxis,
              center = axis.center,
              x = e.chartX - center[0] - chart.plotLeft,
              y = e.chartY - center[1] - chart.plotTop;
            ret[isXAxis ? 'xAxis' : 'yAxis'].push({
              axis: axis,
              value: axis.translate(
                isXAxis ?
                Math.PI - Math.atan2(x, y) :
                Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)),
                true
              )
            });
          });
        } else {
          ret = proceed.call(this, e);
        }
        return ret;
      });
      H.SVGRenderer.prototype.clipCircle = function(x, y, r) {
        var wrapper,
          id = H.uniqueKey(),
          clipPath = this.createElement('clipPath').attr({
            id: id
          }).add(this.defs);
        wrapper = this.circle(x, y, r).add(clipPath);
        wrapper.id = id;
        wrapper.clipPath = clipPath;
        return wrapper;
      };
      H.addEvent(H.Chart, 'getAxes', function() {
        if (!this.pane) {
          this.pane = [];
        }
        each(H.splat(this.options.pane), function(paneOptions) {
          new H.Pane(
            paneOptions,
            this
          );
        }, this);
      });
      H.addEvent(H.Chart, 'afterDrawChartBox', function() {
        each(this.pane, function(pane) {
          pane.render();
        });
      });
      wrap(H.Chart.prototype, 'get', function(proceed, id) {
        return H.find(this.pane, function(pane) {
          return pane.options.id === id;
        }) || proceed.call(this, id);
      });
    }
  }(Highcharts));
}));;
/*! RESOURCE: /scripts/highcharts/modules/exporting.js */
(function(h) {
  "object" === typeof module && module.exports ? module.exports = h : h(Highcharts)
})(function(h) {
  (function(f) {
    var h = f.defaultOptions,
      z = f.doc,
      A = f.Chart,
      w = f.addEvent,
      H = f.removeEvent,
      D = f.fireEvent,
      q = f.createElement,
      B = f.discardElement,
      u = f.css,
      p = f.merge,
      r = f.pick,
      k = f.each,
      E = f.objectEach,
      t = f.extend,
      I = f.isTouchDevice,
      C = f.win,
      F = C.navigator.userAgent,
      J = f.Renderer.prototype.symbols;
    /Edge\/|Trident\/|MSIE /.test(F);
    /firefox/i.test(F);
    t(h.lang, {
      printChart: "Print chart",
      downloadPNG: "Download PNG image",
      downloadJPEG: "Download JPEG image",
      downloadPDF: "Download PDF document",
      downloadSVG: "Download SVG vector image",
      contextButtonTitle: "Chart context menu"
    });
    h.navigation = {
      buttonOptions: {
        theme: {},
        symbolSize: 14,
        symbolX: 12.5,
        symbolY: 10.5,
        align: "right",
        buttonSpacing: 3,
        height: 22,
        verticalAlign: "top",
        width: 24
      }
    };
    p(!0, h.navigation, {
      menuStyle: {
        border: "1px solid #999999",
        background: "#ffffff",
        padding: "5px 0"
      },
      menuItemStyle: {
        padding: "0.5em 1em",
        background: "none",
        color: "#333333",
        fontSize: I ? "14px" : "11px",
        transition: "background 250ms, color 250ms"
      },
      menuItemHoverStyle: {
        background: "#335cad",
        color: "#ffffff"
      },
      buttonOptions: {
        symbolFill: "#666666",
        symbolStroke: "#666666",
        symbolStrokeWidth: 3,
        theme: {
          fill: "#ffffff",
          stroke: "none",
          padding: 5
        }
      }
    });
    h.exporting = {
      type: "image/png",
      url: "https://export.highcharts.com/",
      printMaxWidth: 780,
      scale: 2,
      buttons: {
        contextButton: {
          className: "highcharts-contextbutton",
          menuClassName: "highcharts-contextmenu",
          symbol: "menu",
          _titleKey: "contextButtonTitle",
          menuItems: "printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")
        }
      },
      menuItemDefinitions: {
        printChart: {
          textKey: "printChart",
          onclick: function() {
            this.print()
          }
        },
        separator: {
          separator: !0
        },
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function() {
            this.exportChart()
          }
        },
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function() {
            this.exportChart({
              type: "image/jpeg"
            })
          }
        },
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function() {
            this.exportChart({
              type: "application/pdf"
            })
          }
        },
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function() {
            this.exportChart({
              type: "image/svg+xml"
            })
          }
        }
      }
    };
    f.post = function(a, b, e) {
      var c = q("form", p({
          method: "post",
          action: a,
          enctype: "multipart/form-data"
        },
        e), {
        display: "none"
      }, z.body);
      E(b, function(a, b) {
        q("input", {
          type: "hidden",
          name: b,
          value: a
        }, null, c)
      });
      c.submit();
      B(c)
    };
    t(A.prototype, {
      sanitizeSVG: function(a, b) {
        if (b && b.exporting && b.exporting.allowHTML) {
          var e = a.match(/<\/svg>(.*?$)/);
          e && e[1] && (e = '\x3cforeignObject x\x3d"0" y\x3d"0" width\x3d"' + b.chart.width + '" height\x3d"' + b.chart.height + '"\x3e\x3cbody xmlns\x3d"http://www.w3.org/1999/xhtml"\x3e' + e[1] + "\x3c/body\x3e\x3c/foreignObject\x3e", a = a.replace("\x3c/svg\x3e", e + "\x3c/svg\x3e"))
        }
        a = a.replace(/zIndex="[^"]+"/g,
          "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '\x3csvg xmlns:xlink\x3d"http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, " xlink:href\x3d").replace(/\n/, " ").replace(/<\/svg>.*?$/, "\x3c/svg\x3e").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1\x3d"rgb($2)" $1-opacity\x3d"$3"').replace(/&nbsp;/g,
          "\u00a0").replace(/&shy;/g, "\u00ad");
        this.ieSanitizeSVG && (a = this.ieSanitizeSVG(a));
        return a
      },
      getChartHTML: function() {
        return this.container.innerHTML
      },
      getSVG: function(a) {
        var b, e, c, v, m, g = p(this.options, a);
        e = q("div", null, {
          position: "absolute",
          top: "-9999em",
          width: this.chartWidth + "px",
          height: this.chartHeight + "px"
        }, z.body);
        c = this.renderTo.style.width;
        m = this.renderTo.style.height;
        c = g.exporting.sourceWidth || g.chart.width || /px$/.test(c) && parseInt(c, 10) || 600;
        m = g.exporting.sourceHeight || g.chart.height || /px$/.test(m) &&
          parseInt(m, 10) || 400;
        t(g.chart, {
          animation: !1,
          renderTo: e,
          forExport: !0,
          renderer: "SVGRenderer",
          width: c,
          height: m
        });
        g.exporting.enabled = !1;
        delete g.data;
        g.series = [];
        k(this.series, function(a) {
          v = p(a.userOptions, {
            animation: !1,
            enableMouseTracking: !1,
            showCheckbox: !1,
            visible: a.visible
          });
          v.isInternal || g.series.push(v)
        });
        k(this.axes, function(a) {
          a.userOptions.internalKey || (a.userOptions.internalKey = f.uniqueKey())
        });
        b = new f.Chart(g, this.callback);
        a && k(["xAxis", "yAxis", "series"], function(c) {
          var d = {};
          a[c] && (d[c] = a[c],
            b.update(d))
        });
        k(this.axes, function(a) {
          var c = f.find(b.axes, function(b) {
              return b.options.internalKey === a.userOptions.internalKey
            }),
            d = a.getExtremes(),
            e = d.userMin,
            d = d.userMax;
          !c || void 0 === e && void 0 === d || c.setExtremes(e, d, !0, !1)
        });
        c = b.getChartHTML();
        c = this.sanitizeSVG(c, g);
        g = null;
        b.destroy();
        B(e);
        return c
      },
      getSVGForExport: function(a, b) {
        var e = this.options.exporting;
        return this.getSVG(p({
          chart: {
            borderRadius: 0
          }
        }, e.chartOptions, b, {
          exporting: {
            sourceWidth: a && a.sourceWidth || e.sourceWidth,
            sourceHeight: a && a.sourceHeight ||
              e.sourceHeight
          }
        }))
      },
      exportChart: function(a, b) {
        b = this.getSVGForExport(a, b);
        a = p(this.options.exporting, a);
        f.post(a.url, {
          filename: a.filename || "chart",
          type: a.type,
          width: a.width || 0,
          scale: a.scale,
          svg: b
        }, a.formAttributes)
      },
      print: function() {
        var a = this,
          b = a.container,
          e = [],
          c = b.parentNode,
          f = z.body,
          m = f.childNodes,
          g = a.options.exporting.printMaxWidth,
          d, n;
        if (!a.isPrinting) {
          a.isPrinting = !0;
          a.pointer.reset(null, 0);
          D(a, "beforePrint");
          if (n = g && a.chartWidth > g) d = [a.options.chart.width, void 0, !1], a.setSize(g, void 0, !1);
          k(m, function(a, b) {
            1 === a.nodeType && (e[b] = a.style.display, a.style.display = "none")
          });
          f.appendChild(b);
          C.focus();
          C.print();
          setTimeout(function() {
            c.appendChild(b);
            k(m, function(a, b) {
              1 === a.nodeType && (a.style.display = e[b])
            });
            a.isPrinting = !1;
            n && a.setSize.apply(a, d);
            D(a, "afterPrint")
          }, 1E3)
        }
      },
      contextMenu: function(a, b, e, c, v, m, g) {
        var d = this,
          n = d.options.navigation,
          h = d.chartWidth,
          G = d.chartHeight,
          p = "cache-" + a,
          l = d[p],
          x = Math.max(v, m),
          y, r;
        l || (d[p] = l = q("div", {
              className: a
            }, {
              position: "absolute",
              zIndex: 1E3,
              padding: x + "px"
            },
            d.container), y = q("div", {
            className: "highcharts-menu"
          }, null, l), u(y, t({
            MozBoxShadow: "3px 3px 10px #888",
            WebkitBoxShadow: "3px 3px 10px #888",
            boxShadow: "3px 3px 10px #888"
          }, n.menuStyle)), r = function() {
            u(l, {
              display: "none"
            });
            g && g.setState(0);
            d.openMenu = !1
          }, d.exportEvents.push(w(l, "mouseleave", function() {
            l.hideTimer = setTimeout(r, 500)
          }), w(l, "mouseenter", function() {
            f.clearTimeout(l.hideTimer)
          }), w(z, "mouseup", function(b) {
            d.pointer.inClass(b.target, a) || r()
          })), k(b, function(a) {
            "string" === typeof a && (a = d.options.exporting.menuItemDefinitions[a]);
            if (f.isObject(a, !0)) {
              var b;
              a.separator ? b = q("hr", null, null, y) : (b = q("div", {
                className: "highcharts-menu-item",
                onclick: function(b) {
                  b && b.stopPropagation();
                  r();
                  a.onclick && a.onclick.apply(d, arguments)
                },
                innerHTML: a.text || d.options.lang[a.textKey]
              }, null, y), b.onmouseover = function() {
                u(this, n.menuItemHoverStyle)
              }, b.onmouseout = function() {
                u(this, n.menuItemStyle)
              }, u(b, t({
                cursor: "pointer"
              }, n.menuItemStyle)));
              d.exportDivElements.push(b)
            }
          }), d.exportDivElements.push(y, l), d.exportMenuWidth = l.offsetWidth, d.exportMenuHeight =
          l.offsetHeight);
        b = {
          display: "block"
        };
        e + d.exportMenuWidth > h ? b.right = h - e - v - x + "px" : b.left = e - x + "px";
        c + m + d.exportMenuHeight > G && "top" !== g.alignOptions.verticalAlign ? b.bottom = G - c - x + "px" : b.top = c + m - x + "px";
        u(l, b);
        d.openMenu = !0
      },
      addButton: function(a) {
        var b = this,
          e = b.renderer,
          c = p(b.options.navigation.buttonOptions, a),
          f = c.onclick,
          m = c.menuItems,
          g, d, n = c.symbolSize || 12;
        b.btnCount || (b.btnCount = 0);
        b.exportDivElements || (b.exportDivElements = [], b.exportSVGElements = []);
        if (!1 !== c.enabled) {
          var h = c.theme,
            k = h.states,
            q = k && k.hover,
            k = k && k.select,
            l;
          delete h.states;
          f ? l = function(a) {
            a.stopPropagation();
            f.call(b, a)
          } : m && (l = function() {
            b.contextMenu(d.menuClassName, m, d.translateX, d.translateY, d.width, d.height, d);
            d.setState(2)
          });
          c.text && c.symbol ? h.paddingLeft = r(h.paddingLeft, 25) : c.text || t(h, {
            width: c.width,
            height: c.height,
            padding: 0
          });
          d = e.button(c.text, 0, 0, l, h, q, k).addClass(a.className).attr({
            "stroke-linecap": "round",
            title: r(b.options.lang[c._titleKey], ""),
            zIndex: 3
          });
          d.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;
          c.symbol &&
            (g = e.symbol(c.symbol, c.symbolX - n / 2, c.symbolY - n / 2, n, n, {
              width: n,
              height: n
            }).addClass("highcharts-button-symbol").attr({
              zIndex: 1
            }).add(d), g.attr({
              stroke: c.symbolStroke,
              fill: c.symbolFill,
              "stroke-width": c.symbolStrokeWidth || 1
            }));
          d.add().align(t(c, {
            width: d.width,
            x: r(c.x, b.buttonOffset)
          }), !0, "spacingBox");
          b.buttonOffset += (d.width + c.buttonSpacing) * ("right" === c.align ? -1 : 1);
          b.exportSVGElements.push(d, g)
        }
      },
      destroyExport: function(a) {
        var b = a ? a.target : this;
        a = b.exportSVGElements;
        var e = b.exportDivElements,
          c = b.exportEvents,
          h;
        a && (k(a, function(a, c) {
          a && (a.onclick = a.ontouchstart = null, h = "cache-" + a.menuClassName, b[h] && delete b[h], b.exportSVGElements[c] = a.destroy())
        }), a.length = 0);
        e && (k(e, function(a, c) {
          f.clearTimeout(a.hideTimer);
          H(a, "mouseleave");
          b.exportDivElements[c] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
          B(a)
        }), e.length = 0);
        c && (k(c, function(a) {
          a()
        }), c.length = 0)
      }
    });
    J.menu = function(a, b, e, c) {
      return ["M", a, b + 2.5, "L", a + e, b + 2.5, "M", a, b + c / 2 + .5, "L", a + e, b + c / 2 + .5, "M", a, b + c - 1.5, "L", a + e, b + c - 1.5]
    };
    A.prototype.renderExporting =
      function() {
        var a = this,
          b = a.options.exporting,
          e = b.buttons,
          c = a.isDirtyExporting || !a.exportSVGElements;
        a.buttonOffset = 0;
        a.isDirtyExporting && a.destroyExport();
        c && !1 !== b.enabled && (a.exportEvents = [], E(e, function(b) {
          a.addButton(b)
        }), a.isDirtyExporting = !1);
        w(a, "destroy", a.destroyExport)
      };
    A.prototype.callbacks.push(function(a) {
      a.renderExporting();
      w(a, "redraw", a.renderExporting);
      k(["exporting", "navigation"], function(b) {
        a[b] = {
          update: function(e, c) {
            a.isDirtyExporting = !0;
            p(!0, a.options[b], e);
            r(c, !0) && a.redraw()
          }
        }
      })
    })
  })(h)
});;
/*! RESOURCE: /scripts/highcharts/modules/offline-exporting.js */
(function(n) {
  "object" === typeof module && module.exports ? module.exports = n : n(Highcharts)
})(function(n) {
  (function(c) {
    function n(a, f) {
      var d = t.getElementsByTagName("head")[0],
        b = t.createElement("script");
      b.type = "text/javascript";
      b.src = a;
      b.onload = f;
      b.onerror = function() {
        c.error("Error loading script " + a)
      };
      d.appendChild(b)
    }
    var C = c.merge,
      e = c.win,
      r = e.navigator,
      t = e.document,
      w = c.each,
      x = e.URL || e.webkitURL || e,
      B = /Edge\/|Trident\/|MSIE /.test(r.userAgent),
      D = /Edge\/\d+/.test(r.userAgent),
      E = B ? 150 : 0;
    c.CanVGRenderer = {};
    c.dataURLtoBlob = function(a) {
      if (e.atob && e.ArrayBuffer && e.Uint8Array && e.Blob && x.createObjectURL) {
        a = a.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
        for (var c = e.atob(a[3]), d = new e.ArrayBuffer(c.length), d = new e.Uint8Array(d), b = 0; b < d.length; ++b) d[b] = c.charCodeAt(b);
        a = new e.Blob([d], {
          type: a[1]
        });
        return x.createObjectURL(a)
      }
    };
    c.downloadURL = function(a, f) {
      var d = t.createElement("a"),
        b;
      if ("string" === typeof a || a instanceof String || !r.msSaveOrOpenBlob) {
        if (D || 2E6 < a.length)
          if (a = c.dataURLtoBlob(a), !a) throw "Data URL length limit reached";
        if (void 0 !== d.download) d.href = a, d.download = f, t.body.appendChild(d), d.click(), t.body.removeChild(d);
        else try {
          if (b = e.open(a, "chart"), void 0 === b || null === b) throw "Failed to open window";
        } catch (u) {
          e.location.href = a
        }
      } else r.msSaveOrOpenBlob(a, f)
    };
    c.svgToDataUrl = function(a) {
      var c = -1 < r.userAgent.indexOf("WebKit") && 0 > r.userAgent.indexOf("Chrome");
      try {
        if (!c && 0 > r.userAgent.toLowerCase().indexOf("firefox")) return x.createObjectURL(new e.Blob([a], {
          type: "image/svg+xml;charset-utf-16"
        }))
      } catch (d) {}
      return "data:image/svg+xml;charset\x3dUTF-8," +
        encodeURIComponent(a)
    };
    c.imageToDataUrl = function(a, c, d, b, u, l, k, m, p) {
      var g = new e.Image,
        h, f = function() {
          setTimeout(function() {
            var e = t.createElement("canvas"),
              f = e.getContext && e.getContext("2d"),
              y;
            try {
              if (f) {
                e.height = g.height * b;
                e.width = g.width * b;
                f.drawImage(g, 0, 0, e.width, e.height);
                try {
                  y = e.toDataURL(c), u(y, c, d, b)
                } catch (F) {
                  h(a, c, d, b)
                }
              } else k(a, c, d, b)
            } finally {
              p && p(a, c, d, b)
            }
          }, E)
        },
        q = function() {
          m(a, c, d, b);
          p && p(a, c, d, b)
        };
      h = function() {
        g = new e.Image;
        h = l;
        g.crossOrigin = "Anonymous";
        g.onload = f;
        g.onerror = q;
        g.src = a
      };
      g.onload = f;
      g.onerror = q;
      g.src = a
    };
    c.downloadSVGLocal = function(a, f, d, b) {
      function u(b, a) {
        a = new e.jsPDF("l", "pt", [b.width.baseVal.value + 2 * a, b.height.baseVal.value + 2 * a]);
        w(b.querySelectorAll('*[visibility\x3d"hidden"]'), function(b) {
          b.parentNode.removeChild(b)
        });
        e.svg2pdf(b, a, {
          removeInvalid: !0
        });
        return a.output("datauristring")
      }

      function l() {
        z.innerHTML = a;
        var e = z.getElementsByTagName("text"),
          f;
        w(e, function(b) {
          w(["font-family", "font-size"], function(a) {
            for (var c = b; c && c !== z;) {
              if (c.style[a]) {
                b.style[a] = c.style[a];
                break
              }
              c = c.parentNode
            }
          });
          b.style["font-family"] = b.style["font-family"] && b.style["font-family"].split(" ").splice(-1);
          f = b.getElementsByTagName("title");
          w(f, function(a) {
            b.removeChild(a)
          })
        });
        e = u(z.firstChild, 0);
        try {
          c.downloadURL(e, v), b && b()
        } catch (G) {
          d()
        }
      }
      var k, m, p = !0,
        g, h = f.libURL || c.getOptions().exporting.libURL,
        z = t.createElement("div"),
        q = f.type || "image/png",
        v = (f.filename || "chart") + "." + ("image/svg+xml" === q ? "svg" : q.split("/")[1]),
        A = f.scale || 1,
        h = "/" !== h.slice(-1) ? h + "/" : h;
      if ("image/svg+xml" === q) try {
        r.msSaveOrOpenBlob ?
          (m = new MSBlobBuilder, m.append(a), k = m.getBlob("image/svg+xml")) : k = c.svgToDataUrl(a), c.downloadURL(k, v), b && b()
      } catch (y) {
        d()
      } else "application/pdf" === q ? e.jsPDF && e.svg2pdf ? l() : (p = !0, n(h + "jspdf.js", function() {
        n(h + "svg2pdf.js", function() {
          l()
        })
      })) : (k = c.svgToDataUrl(a), g = function() {
        try {
          x.revokeObjectURL(k)
        } catch (y) {}
      }, c.imageToDataUrl(k, q, {}, A, function(a) {
        try {
          c.downloadURL(a, v), b && b()
        } catch (F) {
          d()
        }
      }, function() {
        var f = t.createElement("canvas"),
          u = f.getContext("2d"),
          l = a.match(/^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/)[1] *
          A,
          k = a.match(/^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/)[1] * A,
          m = function() {
            u.drawSvg(a, 0, 0, l, k);
            try {
              c.downloadURL(r.msSaveOrOpenBlob ? f.msToBlob() : f.toDataURL(q), v), b && b()
            } catch (H) {
              d()
            } finally {
              g()
            }
          };
        f.width = l;
        f.height = k;
        e.canvg ? m() : (p = !0, n(h + "rgbcolor.js", function() {
          n(h + "canvg.js", function() {
            m()
          })
        }))
      }, d, d, function() {
        p && g()
      }))
    };
    c.Chart.prototype.getSVGForLocalExport = function(a, e, d, b) {
      var f = this,
        l, k = 0,
        m, p, g, h, n, q = function(a, c, d) {
          ++k;
          d.imageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href",
            a);
          k === l.length && b(f.sanitizeSVG(m.innerHTML, p))
        };
      c.wrap(c.Chart.prototype, "getChartHTML", function(b) {
        var a = b.apply(this, Array.prototype.slice.call(arguments, 1));
        p = this.options;
        m = this.container.cloneNode(!0);
        return a
      });
      f.getSVGForExport(a, e);
      l = m.getElementsByTagName("image");
      try {
        if (l.length)
          for (h = 0, n = l.length; h < n; ++h) g = l[h], c.imageToDataUrl(g.getAttributeNS("http://www.w3.org/1999/xlink", "href"), "image/png", {
            imageElement: g
          }, a.scale, q, d, d, d);
        else b(f.sanitizeSVG(m.innerHTML, p))
      } catch (v) {
        d()
      }
    };
    c.Chart.prototype.exportChartLocal =
      function(a, e) {
        var d = this,
          b = c.merge(d.options.exporting, a),
          f = function() {
            if (!1 === b.fallbackToExportServer)
              if (b.error) b.error(b);
              else throw "Fallback to export server disabled";
            else d.exportChart(b)
          };
        B && ("application/pdf" === b.type || d.container.getElementsByTagName("image").length && "image/svg+xml" !== b.type) || "application/pdf" === b.type && d.container.getElementsByTagName("image").length ? f() : d.getSVGForLocalExport(b, e, f, function(a) {
          -1 < a.indexOf("\x3cforeignObject") && "image/svg+xml" !== b.type ? f() : c.downloadSVGLocal(a,
            b, f)
        })
      };
    C(!0, c.getOptions().exporting, {
      libURL: "https://code.highcharts.com/6.1.0/lib/",
      menuItemDefinitions: {
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function() {
            this.exportChartLocal()
          }
        },
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function() {
            this.exportChartLocal({
              type: "image/jpeg"
            })
          }
        },
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function() {
            this.exportChartLocal({
              type: "image/svg+xml"
            })
          }
        },
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function() {
            this.exportChartLocal({
              type: "application/pdf"
            })
          }
        }
      }
    })
  })(n)
});;
/*! RESOURCE: /scripts/highcharts/modules/export-data.js */
(function(q) {
  "object" === typeof module && module.exports ? module.exports = q : q(Highcharts)
})(function(q) {
  (function(a) {
    a.ajax = function(z) {
      var c = a.merge(!0, {
        url: !1,
        type: "GET",
        dataType: "json",
        success: !1,
        error: !1,
        data: !1,
        headers: {}
      }, z);
      z = {
        json: "application/json",
        xml: "application/xml",
        text: "text/plain",
        octet: "application/octet-stream"
      };
      var m = new XMLHttpRequest;
      if (!c.url) return !1;
      m.open(c.type.toUpperCase(), c.url, !0);
      m.setRequestHeader("Content-Type", z[c.dataType] || z.text);
      a.objectEach(c.headers, function(a, c) {
        m.setRequestHeader(c,
          a)
      });
      m.onreadystatechange = function() {
        var a;
        if (4 === m.readyState) {
          if (200 === m.status) {
            a = m.responseText;
            if ("json" === c.dataType) try {
              a = JSON.parse(a)
            } catch (e) {
              c.error && c.error(m, e);
              return
            }
            return c.success && c.success(a)
          }
          c.error && c.error(m, m.responseText)
        }
      };
      try {
        c.data = JSON.stringify(c.data)
      } catch (u) {}
      m.send(c.data || !0)
    }
  })(q);
  (function(a) {
    var z = a.defined,
      c = a.each,
      m = a.pick,
      u = a.win,
      e = u.document,
      n = a.seriesTypes,
      q = void 0 !== e.createElement("a").download;
    a.setOptions({
      exporting: {
        csv: {
          columnHeaderFormatter: null,
          dateFormat: "%Y-%m-%d %H:%M:%S",
          decimalPoint: null,
          itemDelimiter: null,
          lineDelimiter: "\n"
        },
        showTable: !1,
        useMultiLevelHeaders: !0,
        useRowspanHeaders: !0
      },
      lang: {
        downloadCSV: "Download CSV",
        downloadXLS: "Download XLS",
        openInCloud: "Open in Highcharts Cloud",
        viewData: "View data table"
      }
    });
    a.addEvent(a.Chart, "render", function() {
      this.options && this.options.exporting && this.options.exporting.showTable && this.viewData()
    });
    a.Chart.prototype.setUpKeyToAxis = function() {
      n.arearange && (n.arearange.prototype.keyToAxis = {
        low: "y",
        high: "y"
      })
    };
    a.Chart.prototype.getDataRows =
      function(f) {
        var g = this.time,
          h = this.options.exporting && this.options.exporting.csv || {},
          d, l = this.xAxis,
          r = {},
          e = [],
          p, D = [],
          v = [],
          A, w, k, E = function(b, d, k) {
            if (h.columnHeaderFormatter) {
              var g = h.columnHeaderFormatter(b, d, k);
              if (!1 !== g) return g
            }
            return b ? b instanceof a.Axis ? b.options.title && b.options.title.text || (b.isDatetimeAxis ? "DateTime" : "Category") : f ? {
              columnTitle: 1 < k ? d : b.name,
              topLevelColumnTitle: b.name
            } : b.name + (1 < k ? " (" + d + ")" : "") : "Category"
          },
          B = [];
        w = 0;
        this.setUpKeyToAxis();
        c(this.series, function(b) {
          var d = b.options.keys ||
            b.pointArrayMap || ["y"],
            k = d.length,
            x = !b.requireSorting && {},
            p = {},
            e = {},
            y = a.inArray(b.xAxis, l),
            n, t;
          c(d, function(d) {
            var a = (b.keyToAxis && b.keyToAxis[d] || d) + "Axis";
            p[d] = b[a] && b[a].categories || [];
            e[d] = b[a] && b[a].isDatetimeAxis
          });
          if (!1 !== b.options.includeInCSVExport && !b.options.isInternal && !1 !== b.visible) {
            a.find(B, function(b) {
              return b[0] === y
            }) || B.push([y, w]);
            for (t = 0; t < k;) A = E(b, d[t], d.length), v.push(A.columnTitle || A), f && D.push(A.topLevelColumnTitle || A), t++;
            n = {
              chart: b.chart,
              autoIncrement: b.autoIncrement,
              options: b.options,
              pointArrayMap: b.pointArrayMap
            };
            c(b.options.data, function(a, f) {
              var c, l;
              l = {
                series: n
              };
              b.pointClass.prototype.applyOptions.apply(l, [a]);
              a = l.x;
              x && (x[a] && (a += "|" + f), x[a] = !0);
              t = 0;
              r[a] || (r[a] = [], r[a].xValues = []);
              r[a].x = l.x;
              r[a].xValues[y] = l.x;
              b.xAxis && "name" !== b.exportKey || (r[a].name = b.data[f] && b.data[f].name);
              for (; t < k;) f = d[t], c = l[f], r[a][w + t] = m(p[f][c], e[f] ? g.dateFormat(h.dateFormat, c) : null, c), t++
            });
            w += t
          }
        });
        for (p in r) r.hasOwnProperty(p) && e.push(r[p]);
        var x, y;
        p = f ? [D, v] : [v];
        for (w = B.length; w--;) x = B[w][0],
          y = B[w][1], d = l[x], e.sort(function(b, a) {
            return b.xValues[x] - a.xValues[x]
          }), k = E(d), p[0].splice(y, 0, k), f && p[1] && p[1].splice(y, 0, k), c(e, function(b) {
            var a = b.name;
            d && !z(a) && (d.isDatetimeAxis ? (b.x instanceof Date && (b.x = b.x.getTime()), a = g.dateFormat(h.dateFormat, b.x)) : a = d.categories ? m(d.names[b.x], d.categories[b.x], b.x) : b.x);
            b.splice(y, 0, a)
          });
        return p = p.concat(e)
      };
    a.Chart.prototype.getCSV = function(a) {
      var f = "",
        h = this.getDataRows(),
        d = this.options.exporting.csv,
        l = m(d.decimalPoint, "," !== d.itemDelimiter && a ? (1.1).toLocaleString()[1] :
          "."),
        e = m(d.itemDelimiter, "," === l ? ";" : ","),
        n = d.lineDelimiter;
      c(h, function(a, d) {
        for (var c, g = a.length; g--;) c = a[g], "string" === typeof c && (c = '"' + c + '"'), "number" === typeof c && "." !== l && (c = c.toString().replace(".", l)), a[g] = c;
        f += a.join(e);
        d < h.length - 1 && (f += n)
      });
      return f
    };
    a.Chart.prototype.getTable = function(a) {
      var f = "\x3ctable\x3e",
        h = this.options,
        d = a ? (1.1).toLocaleString()[1] : ".",
        l = m(h.exporting.useMultiLevelHeaders, !0);
      a = this.getDataRows(l);
      var e = 0,
        n = l ? a.shift() : null,
        p = a.shift(),
        q = function(a, c, f, l) {
          var k = m(l,
            "");
          c = "text" + (c ? " " + c : "");
          "number" === typeof k ? (k = k.toString(), "," === d && (k = k.replace(".", d)), c = "number") : l || (c = "empty");
          return "\x3c" + a + (f ? " " + f : "") + ' class\x3d"' + c + '"\x3e' + k + "\x3c/" + a + "\x3e"
        };
      !1 !== h.exporting.tableCaption && (f += '\x3ccaption class\x3d"highcharts-table-caption"\x3e' + m(h.exporting.tableCaption, h.title.text ? h.title.text.replace(/&/g, "\x26amp;").replace(/</g, "\x26lt;").replace(/>/g, "\x26gt;").replace(/"/g, "\x26quot;").replace(/'/g, "\x26#x27;").replace(/\//g, "\x26#x2F;") : "Chart") + "\x3c/caption\x3e");
      for (var v = 0, u = a.length; v < u; ++v) a[v].length > e && (e = a[v].length);
      f += function(a, d, c) {
        var f = "\x3cthead\x3e",
          e = 0;
        c = c || d && d.length;
        var k, b, g = 0;
        if (b = l && a && d) {
          a: if (b = a.length, d.length === b) {
            for (; b--;)
              if (a[b] !== d[b]) {
                b = !1;
                break a
              } b = !0
          } else b = !1;b = !b
        }
        if (b) {
          for (f += "\x3ctr\x3e"; e < c; ++e) b = a[e], k = a[e + 1], b === k ? ++g : g ? (f += q("th", "highcharts-table-topheading", 'scope\x3d"col" colspan\x3d"' + (g + 1) + '"', b), g = 0) : (b === d[e] ? h.exporting.useRowspanHeaders ? (k = 2, delete d[e]) : (k = 1, d[e] = "") : k = 1, f += q("th", "highcharts-table-topheading",
            'scope\x3d"col"' + (1 < k ? ' valign\x3d"top" rowspan\x3d"' + k + '"' : ""), b));
          f += "\x3c/tr\x3e"
        }
        if (d) {
          f += "\x3ctr\x3e";
          e = 0;
          for (c = d.length; e < c; ++e) void 0 !== d[e] && (f += q("th", null, 'scope\x3d"col"', d[e]));
          f += "\x3c/tr\x3e"
        }
        return f + "\x3c/thead\x3e"
      }(n, p, Math.max(e, p.length));
      f += "\x3ctbody\x3e";
      c(a, function(a) {
        f += "\x3ctr\x3e";
        for (var d = 0; d < e; d++) f += q(d ? "td" : "th", null, d ? "" : 'scope\x3d"row"', a[d]);
        f += "\x3c/tr\x3e"
      });
      return f += "\x3c/tbody\x3e\x3c/table\x3e"
    };
    a.Chart.prototype.fileDownload = function(c, g, h) {
      var d;
      d = this.options.exporting.filename ?
        this.options.exporting.filename : this.title && this.title.textStr ? this.title.textStr.replace(/ /g, "-").toLowerCase() : "chart";
      u.Blob && u.navigator.msSaveOrOpenBlob ? (c = new u.Blob(["\ufeff" + h], {
        type: "text/csv"
      }), u.navigator.msSaveOrOpenBlob(c, d + "." + g)) : q ? (h = e.createElement("a"), h.href = c, h.download = d + "." + g, this.container.appendChild(h), h.click(), h.remove()) : a.error("The browser doesn't support downloading files")
    };
    a.Chart.prototype.downloadCSV = function() {
      var a = this.getCSV(!0);
      this.fileDownload("data:text/csv,\ufeff" +
        encodeURIComponent(a), "csv", a, "text/csv")
    };
    a.Chart.prototype.downloadXLS = function() {
      var a = '\x3chtml xmlns:o\x3d"urn:schemas-microsoft-com:office:office" xmlns:x\x3d"urn:schemas-microsoft-com:office:excel" xmlns\x3d"http://www.w3.org/TR/REC-html40"\x3e\x3chead\x3e\x3c!--[if gte mso 9]\x3e\x3cxml\x3e\x3cx:ExcelWorkbook\x3e\x3cx:ExcelWorksheets\x3e\x3cx:ExcelWorksheet\x3e\x3cx:Name\x3eArk1\x3c/x:Name\x3e\x3cx:WorksheetOptions\x3e\x3cx:DisplayGridlines/\x3e\x3c/x:WorksheetOptions\x3e\x3c/x:ExcelWorksheet\x3e\x3c/x:ExcelWorksheets\x3e\x3c/x:ExcelWorkbook\x3e\x3c/xml\x3e\x3c![endif]--\x3e\x3cstyle\x3etd{border:none;font-family: Calibri, sans-serif;} .number{mso-number-format:"0.00";} .text{ mso-number-format:"@";}\x3c/style\x3e\x3cmeta name\x3dProgId content\x3dExcel.Sheet\x3e\x3cmeta charset\x3dUTF-8\x3e\x3c/head\x3e\x3cbody\x3e' +
        this.getTable(!0) + "\x3c/body\x3e\x3c/html\x3e";
      this.fileDownload("data:application/vnd.ms-excel;base64," + u.btoa(unescape(encodeURIComponent(a))), "xls", a, "application/vnd.ms-excel")
    };
    a.Chart.prototype.viewData = function() {
      this.dataTableDiv || (this.dataTableDiv = e.createElement("div"), this.dataTableDiv.className = "highcharts-data-table", this.renderTo.parentNode.insertBefore(this.dataTableDiv, this.renderTo.nextSibling));
      this.dataTableDiv.innerHTML = this.getTable()
    };
    a.Chart.prototype.openInCloud = function() {
      function c(d) {
        Object.keys(d).forEach(function(e) {
          "function" ===
          typeof d[e] && delete d[e];
          a.isObject(d[e]) && c(d[e])
        })
      }
      var g, h;
      g = a.merge(this.userOptions);
      c(g);
      g = {
        name: g.title && g.title.text || "Chart title",
        options: g,
        settings: {
          constructor: "Chart",
          dataProvider: {
            csv: this.getCSV()
          }
        }
      };
      h = JSON.stringify(g);
      (function() {
        var a = e.createElement("form");
        e.body.appendChild(a);
        a.method = "post";
        a.action = "https://cloud-api.highcharts.com/openincloud";
        a.target = "_blank";
        var c = e.createElement("input");
        c.type = "hidden";
        c.name = "chart";
        c.value = h;
        a.appendChild(c);
        a.submit();
        e.body.removeChild(a)
      })()
    };
    var C = a.getOptions().exporting;
    C && (a.extend(C.menuItemDefinitions, {
      downloadCSV: {
        textKey: "downloadCSV",
        onclick: function() {
          this.downloadCSV()
        }
      },
      downloadXLS: {
        textKey: "downloadXLS",
        onclick: function() {
          this.downloadXLS()
        }
      },
      viewData: {
        textKey: "viewData",
        onclick: function() {
          this.viewData()
        }
      },
      openInCloud: {
        textKey: "openInCloud",
        onclick: function() {
          this.openInCloud()
        }
      }
    }), C.buttons.contextButton.menuItems.push("separator", "downloadCSV", "downloadXLS", "viewData", "openInCloud"));
    n.map && (n.map.prototype.exportKey = "name");
    n.mapbubble && (n.mapbubble.prototype.exportKey = "name");
    n.treemap && (n.treemap.prototype.exportKey = "name")
  })(q)
});;
/*! RESOURCE: /scripts/highcharts/modules/accessibility.js */
(function(r) {
  "object" === typeof module && module.exports ? module.exports = r : r(Highcharts)
})(function(r) {
  (function(a) {
    function r(a, f) {
      var k = a.indexOf("#each("),
        h = a.indexOf("#plural("),
        g = a.indexOf("["),
        m = a.indexOf("]");
      if (-1 < k) {
        var g = a.slice(k).indexOf(")") + k,
          l = a.substring(0, k),
          h = a.substring(g + 1),
          g = a.substring(k + 6, g).split(","),
          k = Number(g[1]);
        a = "";
        if (f = f[g[0]])
          for (k = isNaN(k) ? f.length : k, k = 0 > k ? f.length + k : Math.min(k, f.length), g = 0; g < k; ++g) a += l + f[g] + h;
        return a.length ? a : ""
      }
      if (-1 < h) {
        l = a.slice(h).indexOf(")") + h;
        a = a.substring(h + 8, l).split(",");
        switch (Number(f[a[0]])) {
          case 0:
            a = t(a[4], a[1]);
            break;
          case 1:
            a = t(a[2], a[1]);
            break;
          case 2:
            a = t(a[3], a[1]);
            break;
          default:
            a = a[1]
        }
        a ? (f = a, f = f.trim && f.trim() || f.replace(/^\s+|\s+$/g, "")) : f = "";
        return f
      }
      return -1 < g ? (h = a.substring(0, g), a = Number(a.substring(g + 1, m)), f = f[h], !isNaN(a) && f && (0 > a ? (l = f[f.length + a], void 0 === l && (l = f[0])) : (l = f[a], void 0 === l && (l = f[f.length - 1]))), void 0 !== l ? l : "") : "{" + a + "}"
    }
    var u = a.each,
      t = a.pick;
    a.i18nFormat = function(m, f, k) {
      var h = function(d, a) {
          d = d.slice(a || 0);
          var c = d.indexOf("{"),
            b = d.indexOf("}");
          if (-1 < c && b > c) return {
            statement: d.substring(c + 1, b),
            begin: a + c + 1,
            end: a + b
          }
        },
        g = [],
        q, l;
      l = 0;
      do q = h(m, l), l = m.substring(l, q && q.begin - 1), l.length && g.push({
        value: l,
        type: "constant"
      }), q && g.push({
        value: q.statement,
        type: "statement"
      }), l = q && q.end + 1; while (q);
      u(g, function(d) {
        "statement" === d.type && (d.value = r(d.value, f))
      });
      return a.format(a.reduce(g, function(d, a) {
        return d + a.value
      }, ""), f, k)
    };
    a.Chart.prototype.langFormat = function(m, f, k) {
      m = m.split(".");
      for (var h = this.options.lang, g = 0; g <
        m.length; ++g) h = h && h[m[g]];
      return "string" === typeof h && a.i18nFormat(h, f, k)
    };
    a.setOptions({
      lang: {
        accessibility: {
          screenReaderRegionLabel: "Chart screen reader information.",
          navigationHint: "Use regions/landmarks to skip ahead to chart {#plural(numSeries, and navigate between data series,)}",
          defaultChartTitle: "Chart",
          longDescriptionHeading: "Long description.",
          noDescription: "No description available.",
          structureHeading: "Structure.",
          viewAsDataTable: "View as data table.",
          chartHeading: "Chart graphic.",
          chartContainerLabel: "Interactive chart. {title}. Use up and down arrows to navigate with most screen readers.",
          rangeSelectorMinInput: "Select start date.",
          rangeSelectorMaxInput: "Select end date.",
          tableSummary: "Table representation of chart.",
          mapZoomIn: "Zoom chart",
          mapZoomOut: "Zoom out chart",
          rangeSelectorButton: "Select range {buttonText}",
          legendItem: "Toggle visibility of series {itemName}",
          svgContainerTitle: "{chartTitle}",
          seriesTypeDescriptions: {
            boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
            arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
            areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
            bubble: "Bubble charts are scatter charts where each data point also has a size value.",
            columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
            errorbar: "Errorbar series are used to display the variability of the data.",
            funnel: "Funnel charts are used to display reduction of data in stages.",
            pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
            waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
          },
          chartTypes: {
            emptyChart: "Empty chart",
            mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
            unknownMap: "Map of unspecified region with {numSeries} data series.",
            combinationChart: "Combination chart with {numSeries} data series.",
            defaultSingle: "Chart with {numPoints} data {#plural(numPoints, points, point)}.",
            defaultMultiple: "Chart with {numSeries} data series.",
            splineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
            splineMultiple: "Line chart with {numSeries} lines.",
            lineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
            lineMultiple: "Line chart with {numSeries} lines.",
            columnSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
            columnMultiple: "Bar chart with {numSeries} data series.",
            barSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
            barMultiple: "Bar chart with {numSeries} data series.",
            pieSingle: "Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.",
            pieMultiple: "Pie chart with {numSeries} pies.",
            scatterSingle: "Scatter chart with {numPoints} {#plural(numPoints, points, point)}.",
            scatterMultiple: "Scatter chart with {numSeries} data series.",
            boxplotSingle: "Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
            boxplotMultiple: "Boxplot with {numSeries} data series.",
            bubbleSingle: "Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
            bubbleMultiple: "Bubble chart with {numSeries} data series."
          },
          axis: {
            xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}.",
            xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}",
            yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}.",
            yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}"
          },
          exporting: {
            chartMenuLabel: "Chart export",
            menuButtonLabel: "View export menu",
            exportRegionLabel: "Chart export menu"
          },
          series: {
            summary: {
              default: "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
              defaultCombination: "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
              line: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
              lineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
              spline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
              splineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
              column: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
              columnCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
              bar: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
              barCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
              pie: "{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.",
              pieCombination: "{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.",
              scatter: "{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.",
              scatterCombination: "{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.",
              boxplot: "{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.",
              boxplotCombination: "{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
              bubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
              bubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
              map: "{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.",
              mapCombination: "{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.",
              mapline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
              maplineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
              mapbubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
              mapbubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}."
            },
            description: "{description}",
            xAxisDescription: "X axis, {name}",
            yAxisDescription: "Y axis, {name}"
          }
        }
      }
    })
  })(r);
  (function(a) {
    function r(d) {
      return d.replace(/&/g, "\x26amp;").replace(/</g, "\x26lt;").replace(/>/g, "\x26gt;").replace(/"/g, "\x26quot;").replace(/'/g, "\x26#x27;").replace(/\//g, "\x26#x2F;")
    }

    function u(d) {
      return "string" === typeof d ? d.replace(/<\/?[^>]+(>|$)/g, "") : d
    }

    function t(d) {
      for (var a = d.childNodes.length; a--;) d.appendChild(d.childNodes[a])
    }
    var m = a.win.document,
      f = a.each,
      k = a.map,
      h = a.erase,
      g = a.addEvent,
      q = a.merge,
      l = {
        position: "absolute",
        left: "-9999px",
        top: "auto",
        width: "1px",
        height: "1px",
        overflow: "hidden"
      };
    a.Series.prototype.commonKeys = "name id category x value y".split(" ");
    a.Series.prototype.specialKeys = "z open high q3 median q1 low close".split(" ");
    a.seriesTypes.pie && (a.seriesTypes.pie.prototype.specialKeys = []);
    a.setOptions({
      accessibility: {
        enabled: !0,
        pointDescriptionThreshold: !1,
        screenReaderSectionFormatter: function(d) {
          var a = d.options,
            c = d.types || [],
            b = {
              chart: d,
              numSeries: d.series && d.series.length
            },
            c = (1 === c.length && "pie" === c[0] || "map" === c[0]) && {} || d.getAxesDescription();
          return "\x3cdiv\x3e" + d.langFormat("accessibility.navigationHint", b) + "\x3c/div\x3e\x3ch3\x3e" + (a.title.text ? r(a.title.text) : d.langFormat("accessibility.defaultChartTitle", b)) + (a.subtitle && a.subtitle.text ? ". " + r(a.subtitle.text) : "") + "\x3c/h3\x3e\x3ch4\x3e" + d.langFormat("accessibility.longDescriptionHeading", b) + "\x3c/h4\x3e\x3cdiv\x3e" + (a.chart.description || d.langFormat("accessibility.noDescription", b)) + "\x3c/div\x3e\x3ch4\x3e" +
            d.langFormat("accessibility.structureHeading", b) + "\x3c/h4\x3e\x3cdiv\x3e" + (a.chart.typeDescription || d.getTypeDescription()) + "\x3c/div\x3e" + (c.xAxis ? "\x3cdiv\x3e" + c.xAxis + "\x3c/div\x3e" : "") + (c.yAxis ? "\x3cdiv\x3e" + c.yAxis + "\x3c/div\x3e" : "")
        }
      }
    });
    a.addEvent(a.Series, "afterRender", function() {
      this.chart.options.accessibility.enabled && this.setA11yDescription()
    });
    a.Series.prototype.setA11yDescription = function() {
      var d = this.chart.options.accessibility,
        a = this.points && this.points.length && this.points[0].graphic &&
        this.points[0].graphic.element,
        c = a && a.parentNode || this.graph && this.graph.element || this.group && this.group.element;
      c && (c.lastChild === a && t(c), this.points && (this.points.length < d.pointDescriptionThreshold || !1 === d.pointDescriptionThreshold) && f(this.points, function(b) {
        b.graphic && (b.graphic.element.setAttribute("role", "img"), b.graphic.element.setAttribute("tabindex", "-1"), b.graphic.element.setAttribute("aria-label", u(b.series.options.pointDescriptionFormatter && b.series.options.pointDescriptionFormatter(b) ||
          d.pointDescriptionFormatter && d.pointDescriptionFormatter(b) || b.buildPointInfoString())))
      }), 1 < this.chart.series.length || d.describeSingleSeries) && (c.setAttribute("role", this.options.exposeElementToA11y ? "img" : "region"), c.setAttribute("tabindex", "-1"), c.setAttribute("aria-label", u(d.seriesDescriptionFormatter && d.seriesDescriptionFormatter(this) || this.buildSeriesInfoString())))
    };
    a.Series.prototype.buildSeriesInfoString = function() {
      var a = this.chart,
        e = this.description || this.options.description,
        e = e && a.langFormat("accessibility.series.description", {
          description: e,
          series: this
        }),
        c = a.langFormat("accessibility.series.xAxisDescription", {
          name: this.xAxis && this.xAxis.getDescription(),
          series: this
        }),
        b = a.langFormat("accessibility.series.yAxisDescription", {
          name: this.yAxis && this.yAxis.getDescription(),
          series: this
        }),
        n = {
          name: this.name || "",
          ix: this.index + 1,
          numSeries: a.series.length,
          numPoints: this.points.length,
          series: this
        },
        p = 1 === a.types.length ? "" : "Combination";
      return (a.langFormat("accessibility.series.summary." + this.type + p, n) || a.langFormat("accessibility.series.summary.default" +
        p, n)) + (e ? " " + e : "") + (1 < a.yAxis.length && this.yAxis ? " " + b : "") + (1 < a.xAxis.length && this.xAxis ? " " + c : "")
    };
    a.Point.prototype.buildPointInfoString = function() {
      var d = this,
        e = d.series,
        c = e.chart.options.accessibility,
        b = "",
        n = e.xAxis && e.xAxis.isDatetimeAxis,
        c = n && e.chart.time.dateFormat(c.pointDateFormatter && c.pointDateFormatter(d) || c.pointDateFormat || a.Tooltip.prototype.getXDateFormat.call({
          getDateFormat: a.Tooltip.prototype.getDateFormat,
          chart: e.chart
        }, d, e.chart.options.tooltip, e.xAxis), d.x);
      a.find(e.specialKeys,
        function(b) {
          return void 0 !== d[b]
        }) ? (n && (b = c), f(e.commonKeys.concat(e.specialKeys), function(c) {
        void 0 === d[c] || n && "x" === c || (b += (b ? ". " : "") + c + ", " + d[c])
      })) : b = (this.name || c || this.category || this.id || "x, " + this.x) + ", " + (void 0 !== this.value ? this.value : this.y);
      return this.index + 1 + ". " + b + "." + (this.description ? " " + this.description : "")
    };
    a.Axis.prototype.getDescription = function() {
      return this.userOptions && this.userOptions.description || this.axisTitle && this.axisTitle.textStr || this.options.id || this.categories && "categories" ||
        this.isDatetimeAxis && "Time" || "values"
    };
    g(a.Series, "afterInit", function() {
      var a = this.chart;
      a.options.accessibility.enabled && (a.types = a.types || [], 0 > a.types.indexOf(this.type) && a.types.push(this.type))
    });
    g(a.Series, "remove", function() {
      var a = this.chart,
        e = this,
        c = !1;
      f(a.series, function(b) {
        b !== e && 0 > a.types.indexOf(e.type) && (c = !0)
      });
      c || h(a.types, e.type)
    });
    a.Chart.prototype.getTypeDescription = function() {
      var a = this.types && this.types[0],
        e = this.series && this.series[0] || {},
        c = e.mapTitle,
        b = this.langFormat("accessibility.seriesTypeDescriptions." +
          a, {
            chart: this
          }),
        e = {
          numSeries: this.series.length,
          numPoints: e.points && e.points.length,
          chart: this,
          mapTitle: c
        },
        n = this.series && 1 === this.series.length ? "Single" : "Multiple";
      if (a) {
        if ("map" === a) return c ? this.langFormat("accessibility.chartTypes.mapTypeDescription", e) : this.langFormat("accessibility.chartTypes.unknownMap", e);
        if (1 < this.types.length) return this.langFormat("accessibility.chartTypes.combinationChart", e)
      } else return this.langFormat("accessibility.chartTypes.emptyChart", e);
      return (this.langFormat("accessibility.chartTypes." +
        a + n, e) || this.langFormat("accessibility.chartTypes.default" + n, e)) + (b ? " " + b : "")
    };
    a.Chart.prototype.getAxesDescription = function() {
      var a = this.xAxis.length,
        e = this.yAxis.length,
        c = {};
      a && (c.xAxis = this.langFormat("accessibility.axis.xAxisDescription" + (1 < a ? "Plural" : "Singular"), {
        chart: this,
        names: k(this.xAxis, function(b) {
          return b.getDescription()
        }),
        numAxes: a
      }));
      e && (c.yAxis = this.langFormat("accessibility.axis.yAxisDescription" + (1 < e ? "Plural" : "Singular"), {
        chart: this,
        names: k(this.yAxis, function(b) {
          return b.getDescription()
        }),
        numAxes: e
      }));
      return c
    };
    a.Chart.prototype.addAccessibleContextMenuAttribs = function() {
      var a = this.exportDivElements;
      a && (f(a, function(a) {
        "DIV" !== a.tagName || a.children && a.children.length || (a.setAttribute("role", "menuitem"), a.setAttribute("tabindex", -1))
      }), a[0].parentNode.setAttribute("role", "menu"), a[0].parentNode.setAttribute("aria-label", this.langFormat("accessibility.exporting.chartMenuLabel", {
        chart: this
      })))
    };
    a.Chart.prototype.addScreenReaderRegion = function(a, e) {
      var c = this,
        b = c.screenReaderRegion = m.createElement("div"),
        n = m.createElement("h4"),
        p = m.createElement("a"),
        d = m.createElement("h4");
      b.setAttribute("id", a);
      b.setAttribute("role", "region");
      b.setAttribute("aria-label", c.langFormat("accessibility.screenReaderRegionLabel", {
        chart: this
      }));
      b.innerHTML = c.options.accessibility.screenReaderSectionFormatter(c);
      c.getCSV && (p.innerHTML = c.langFormat("accessibility.viewAsDataTable", {
          chart: c
        }), p.href = "#" + e, p.setAttribute("tabindex", "-1"), p.onclick = c.options.accessibility.onTableAnchorClick || function() {
          c.viewData();
          m.getElementById(e).focus()
        },
        n.appendChild(p), b.appendChild(n));
      d.innerHTML = c.langFormat("accessibility.chartHeading", {
        chart: c
      });
      c.renderTo.insertBefore(d, c.renderTo.firstChild);
      c.renderTo.insertBefore(b, c.renderTo.firstChild);
      q(!0, d.style, l);
      q(!0, b.style, l)
    };
    a.Chart.prototype.callbacks.push(function(d) {
      var e = d.options;
      if (e.accessibility.enabled) {
        var c = m.createElementNS("http://www.w3.org/2000/svg", "g"),
          b = d.container.getElementsByTagName("desc")[0],
          n = d.container.getElementsByTagName("text"),
          p = "highcharts-title-" + d.index,
          v = "highcharts-data-table-" +
          d.index,
          w = "highcharts-information-region-" + d.index,
          g = e.title.text || d.langFormat("accessibility.defaultChartTitle", {
            chart: d
          }),
          h = u(d.langFormat("accessibility.svgContainerTitle", {
            chartTitle: g
          }));
        h.length && (e = m.createElementNS("http://www.w3.org/2000/svg", "title"), e.textContent = h, e.id = p, b.parentNode.insertBefore(e, b));
        d.renderTo.setAttribute("role", "region");
        d.renderTo.setAttribute("aria-label", d.langFormat("accessibility.chartContainerLabel", {
          title: u(g),
          chart: d
        }));
        if (d.exportSVGElements && d.exportSVGElements[0] &&
          d.exportSVGElements[0].element) {
          var k = d.exportSVGElements[0].element.onclick,
            b = d.exportSVGElements[0].element.parentNode;
          d.exportSVGElements[0].element.onclick = function() {
            k.apply(this, Array.prototype.slice.call(arguments));
            d.addAccessibleContextMenuAttribs();
            d.highlightExportItem(0)
          };
          d.exportSVGElements[0].element.setAttribute("role", "button");
          d.exportSVGElements[0].element.setAttribute("aria-label", d.langFormat("accessibility.exporting.menuButtonLabel", {
            chart: d
          }));
          c.appendChild(d.exportSVGElements[0].element);
          c.setAttribute("role", "region");
          c.setAttribute("aria-label", d.langFormat("accessibility.exporting.exportRegionLabel", {
            chart: d
          }));
          b.appendChild(c)
        }
        d.rangeSelector && f(["minInput", "maxInput"], function(b, c) {
          d.rangeSelector[b] && (d.rangeSelector[b].setAttribute("tabindex", "-1"), d.rangeSelector[b].setAttribute("role", "textbox"), d.rangeSelector[b].setAttribute("aria-label", d.langFormat("accessibility.rangeSelector" + (c ? "MaxInput" : "MinInput"), {
            chart: d
          })))
        });
        f(n, function(b) {
          b.setAttribute("aria-hidden", "true")
        });
        d.addScreenReaderRegion(w, v);
        a.wrap(d, "getTable", function(b) {
          return b.apply(this, Array.prototype.slice.call(arguments, 1)).replace("\x3ctable\x3e", '\x3ctable id\x3d"' + v + '" summary\x3d"' + d.langFormat("accessibility.tableSummary", {
            chart: d
          }) + '"\x3e')
        })
      }
    })
  })(r);
  (function(a) {
    function r(c) {
      return "string" === typeof c ? c.replace(/<\/?[^>]+(>|$)/g, "") : c
    }

    function u(c, b) {
      this.chart = c;
      this.id = b.id;
      this.keyCodeMap = b.keyCodeMap;
      this.validate = b.validate;
      this.init = b.init;
      this.terminate = b.terminate
    }

    function t(c) {
      var b;
      c && c.onclick && k.createEvent && (b = k.createEvent("Events"), b.initEvent("click", !0, !1), c.onclick(b))
    }

    function m(c) {
      var b = c.series.chart.options.accessibility;
      return c.isNull && b.keyboardNavigation.skipNullPoints || c.series.options.skipKeyboardNavigation || !c.series.visible || !1 === c.visible || b.pointDescriptionThreshold && b.pointDescriptionThreshold <= c.series.points.length
    }
    var f = a.win,
      k = f.document,
      h = a.each,
      g = a.addEvent,
      q = a.fireEvent,
      l = a.merge,
      d = a.pick,
      e;
    a.extend(a.SVGElement.prototype, {
      addFocusBorder: function(c,
        b) {
        this.focusBorder && this.removeFocusBorder();
        var a = this.getBBox();
        c = d(c, 3);
        this.focusBorder = this.renderer.rect(a.x - c, a.y - c, a.width + 2 * c, a.height + 2 * c, b && b.borderRadius).addClass("highcharts-focus-border").attr({
          stroke: b && b.stroke,
          "stroke-width": b && b.strokeWidth
        }).attr({
          zIndex: 99
        }).add(this.parentGroup)
      },
      removeFocusBorder: function() {
        this.focusBorder && (this.focusBorder.destroy(), delete this.focusBorder)
      }
    });
    a.Series.prototype.keyboardMoveVertical = !0;
    h(["column", "pie"], function(c) {
      a.seriesTypes[c] && (a.seriesTypes[c].prototype.keyboardMoveVertical = !1)
    });
    a.setOptions({
      accessibility: {
        keyboardNavigation: {
          enabled: !0,
          focusBorder: {
            enabled: !0,
            hideBrowserFocusOutline: !0,
            style: {
              color: "#335cad",
              lineWidth: 2,
              borderRadius: 3
            },
            margin: 2
          },
          skipNullPoints: !0
        }
      }
    });
    u.prototype = {
      run: function(c) {
        var b = this,
          a = c.which || c.keyCode,
          d = !1,
          e = !1;
        h(this.keyCodeMap, function(n) {
          -1 < n[0].indexOf(a) && (d = !0, e = !1 === n[1].call(b, a, c) ? !1 : !0)
        });
        d || 9 !== a || (e = this.move(c.shiftKey ? -1 : 1));
        return e
      },
      move: function(c) {
        var b = this.chart;
        this.terminate && this.terminate(c);
        b.keyboardNavigationModuleIndex +=
          c;
        var a = b.keyboardNavigationModules[b.keyboardNavigationModuleIndex];
        b.focusElement && b.focusElement.removeFocusBorder();
        if (a) {
          if (a.validate && !a.validate()) return this.move(c);
          if (a.init) return a.init(c), !0
        }
        b.keyboardNavigationModuleIndex = 0;
        0 < c ? (this.chart.exiting = !0, this.chart.tabExitAnchor.focus()) : this.chart.renderTo.focus();
        return !1
      }
    };
    a.Axis.prototype.panStep = function(c, b) {
      var a = b || 3;
      b = this.getExtremes();
      var d = (b.max - b.min) / a * c,
        a = b.max + d,
        d = b.min + d,
        e = a - d;
      0 > c && d < b.dataMin ? (d = b.dataMin, a = d + e) : 0 < c &&
        a > b.dataMax && (a = b.dataMax, d = a - e);
      this.setExtremes(d, a)
    };
    a.Chart.prototype.setFocusToElement = function(c, b) {
      var a = this.options.accessibility.keyboardNavigation.focusBorder;
      b = b || c;
      b.element && b.element.focus && (b.element.focus(), a.hideBrowserFocusOutline && b.css({
        outline: "none"
      }));
      a.enabled && (this.focusElement && this.focusElement.removeFocusBorder(), c.addFocusBorder(a.margin, {
        stroke: a.style.color,
        strokeWidth: a.style.lineWidth,
        borderRadius: a.style.borderRadius
      }), this.focusElement = c)
    };
    a.Point.prototype.highlight =
      function() {
        var c = this.series.chart;
        if (this.isNull) c.tooltip && c.tooltip.hide(0);
        else this.onMouseOver();
        this.graphic && c.setFocusToElement(this.graphic);
        c.highlightedPoint = this;
        return this
      };
    a.Chart.prototype.highlightAdjacentPoint = function(c) {
      var b = this.series,
        a = this.highlightedPoint,
        d = a && a.index || 0,
        e = a && a.series.points,
        f = this.series && this.series[this.series.length - 1],
        f = f && f.points && f.points[f.points.length - 1];
      if (!b[0] || !b[0].points) return !1;
      if (a) {
        if (e[d] !== a)
          for (f = 0; f < e.length; ++f)
            if (e[f] === a) {
              d = f;
              break
            } b = b[a.series.index + (c ? 1 : -1)];
        d = e[d + (c ? 1 : -1)] || b && b.points[c ? 0 : b.points.length - 1];
        if (!d) return !1
      } else d = c ? b[0].points[0] : f;
      return m(d) ? (this.highlightedPoint = d, this.highlightAdjacentPoint(c)) : d.highlight()
    };
    a.Series.prototype.highlightFirstValidPoint = function() {
      var c = this.chart.highlightedPoint,
        b = (c && c.series) === this ? c.index : 0;
      if (c = this.points) {
        for (var a = b, d = c.length; a < d; ++a)
          if (!m(c[a])) return c[a].highlight();
        for (; 0 <= b; --b)
          if (!m(c[b])) return c[b].highlight()
      }
      return !1
    };
    a.Chart.prototype.highlightAdjacentSeries =
      function(c) {
        var b, a, d = this.highlightedPoint,
          e = (b = this.series && this.series[this.series.length - 1]) && b.points && b.points[b.points.length - 1];
        if (!this.highlightedPoint) return b = c ? this.series && this.series[0] : b, (a = c ? b && b.points && b.points[0] : e) ? a.highlight() : !1;
        b = this.series[d.series.index + (c ? -1 : 1)];
        if (!b) return !1;
        var e = Infinity,
          f, g = b.points.length;
        if (void 0 === d.plotX || void 0 === d.plotY) a = void 0;
        else {
          for (; g--;) f = b.points[g], void 0 !== f.plotX && void 0 !== f.plotY && (f = (d.plotX - f.plotX) * (d.plotX - f.plotX) * 4 + (d.plotY -
            f.plotY) * (d.plotY - f.plotY) * 1, f < e && (e = f, a = g));
          a = void 0 !== a && b.points[a]
        }
        if (!a) return !1;
        if (!b.visible) return a.highlight(), c = this.highlightAdjacentSeries(c), c ? c : (d.highlight(), !1);
        a.highlight();
        return a.series.highlightFirstValidPoint()
      };
    a.Chart.prototype.highlightAdjacentPointVertical = function(c) {
      var b = this.highlightedPoint,
        a = Infinity,
        d;
      if (void 0 === b.plotX || void 0 === b.plotY) return !1;
      h(this.series, function(n) {
        h(n.points, function(e) {
          if (void 0 !== e.plotY && void 0 !== e.plotX && e !== b) {
            var f = e.plotY - b.plotY,
              p = Math.abs(e.plotX - b.plotX),
              p = Math.abs(f) * Math.abs(f) + p * p * 4;
            n.yAxis.reversed && (f *= -1);
            !(0 > f && c || 0 < f && !c || 5 > p || m(e)) && p < a && (a = p, d = e)
          }
        })
      });
      return d ? d.highlight() : !1
    };
    a.Chart.prototype.showExportMenu = function() {
      this.exportSVGElements && this.exportSVGElements[0] && (this.exportSVGElements[0].element.onclick(), this.highlightExportItem(0))
    };
    a.Chart.prototype.hideExportMenu = function() {
      var c = this.exportDivElements;
      if (c) {
        h(c, function(b) {
          q(b, "mouseleave")
        });
        if (c[this.highlightedExportItem] && c[this.highlightedExportItem].onmouseout) c[this.highlightedExportItem].onmouseout();
        this.highlightedExportItem = 0;
        e && this.renderTo.focus()
      }
    };
    a.Chart.prototype.highlightExportItem = function(c) {
      var b = this.exportDivElements && this.exportDivElements[c],
        a = this.exportDivElements && this.exportDivElements[this.highlightedExportItem];
      if (b && "DIV" === b.tagName && (!b.children || !b.children.length)) {
        b.focus && e && b.focus();
        if (a && a.onmouseout) a.onmouseout();
        if (b.onmouseover) b.onmouseover();
        this.highlightedExportItem = c;
        return !0
      }
    };
    a.Chart.prototype.highlightLastExportItem = function() {
      var c;
      if (this.exportDivElements)
        for (c =
          this.exportDivElements.length; c-- && !this.highlightExportItem(c););
    };
    a.Chart.prototype.highlightRangeSelectorButton = function(c) {
      var b = this.rangeSelector.buttons;
      b[this.highlightedRangeSelectorItemIx] && b[this.highlightedRangeSelectorItemIx].setState(this.oldRangeSelectorItemState || 0);
      this.highlightedRangeSelectorItemIx = c;
      return b[c] ? (this.setFocusToElement(b[c].box, b[c]), this.oldRangeSelectorItemState = b[c].state, b[c].setState(2), !0) : !1
    };
    a.Chart.prototype.highlightLegendItem = function(c) {
      var b = this.legend.allItems,
        a = this.highlightedLegendItemIx;
      return b[c] ? (b[a] && q(b[a].legendGroup.element, "mouseout"), void 0 !== b[c].pageIx && b[c].pageIx + 1 !== this.legend.currentPage && this.legend.scroll(1 + b[c].pageIx - this.legend.currentPage), this.highlightedLegendItemIx = c, this.setFocusToElement(b[c].legendItem, b[c].legendGroup), q(b[c].legendGroup.element, "mouseover"), !0) : !1
    };
    a.Chart.prototype.addKeyboardNavigationModules = function() {
      function a(a, c, d) {
        return new u(b, l({
          keyCodeMap: c
        }, {
          id: a
        }, d))
      }
      var b = this;
      b.keyboardNavigationModules = [a("entry", []), a("points", [
        [
          [37, 39],
          function(a) {
            a = 39 === a;
            return b.highlightAdjacentPoint(a) ? !0 : this.init(a ? 1 : -1)
          }
        ],
        [
          [38, 40],
          function(a) {
            a = 38 !== a;
            var c = b.options.accessibility.keyboardNavigation;
            if (c.mode && "serialize" === c.mode) return b.highlightAdjacentPoint(a) ? !0 : this.init(a ? 1 : -1);
            b[b.highlightedPoint && b.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries"](a);
            return !0
          }
        ],
        [
          [13, 32],
          function() {
            b.highlightedPoint && b.highlightedPoint.firePointEvent("click")
          }
        ]
      ], {
        init: function(a) {
          var c = b.series.length,
            d = 0 < a ? 0 : c;
          if (0 < a)
            for (delete b.highlightedPoint; d < c;) {
              if (a = b.series[d].highlightFirstValidPoint()) return a;
              ++d
            } else
              for (; d--;)
                if (b.highlightedPoint = b.series[d].points[b.series[d].points.length - 1], a = b.series[d].highlightFirstValidPoint()) return a
        },
        terminate: function() {
          b.tooltip && b.tooltip.hide(0);
          delete b.highlightedPoint
        }
      }), a("exporting", [
        [
          [37, 38],
          function() {
            for (var a = b.highlightedExportItem || 0, c = !0; a--;)
              if (b.highlightExportItem(a)) {
                c = !1;
                break
              } if (c) return b.highlightLastExportItem(),
              !0
          }
        ],
        [
          [39, 40],
          function() {
            for (var a = !0, c = (b.highlightedExportItem || 0) + 1; c < b.exportDivElements.length; ++c)
              if (b.highlightExportItem(c)) {
                a = !1;
                break
              } if (a) return b.highlightExportItem(0), !0
          }
        ],
        [
          [13, 32],
          function() {
            t(b.exportDivElements[b.highlightedExportItem])
          }
        ]
      ], {
        validate: function() {
          return b.exportChart && !(b.options.exporting && !1 === b.options.exporting.enabled)
        },
        init: function(a) {
          b.highlightedPoint = null;
          b.showExportMenu();
          0 > a && b.highlightLastExportItem()
        },
        terminate: function() {
          b.hideExportMenu()
        }
      }), a("mapZoom",
        [
          [
            [38, 40, 37, 39],
            function(a) {
              b[38 === a || 40 === a ? "yAxis" : "xAxis"][0].panStep(39 > a ? -1 : 1)
            }
          ],
          [
            [9],
            function(a, c) {
              b.mapNavButtons[b.focusedMapNavButtonIx].setState(0);
              if (c.shiftKey && !b.focusedMapNavButtonIx || !c.shiftKey && b.focusedMapNavButtonIx) return b.mapZoom(), this.move(c.shiftKey ? -1 : 1);
              b.focusedMapNavButtonIx += c.shiftKey ? -1 : 1;
              a = b.mapNavButtons[b.focusedMapNavButtonIx];
              b.setFocusToElement(a.box, a);
              a.setState(2)
            }
          ],
          [
            [13, 32],
            function() {
              t(b.mapNavButtons[b.focusedMapNavButtonIx].element)
            }
          ]
        ], {
          validate: function() {
            return b.mapZoom &&
              b.mapNavButtons && 2 === b.mapNavButtons.length
          },
          init: function(a) {
            var c = b.mapNavButtons[0],
              d = b.mapNavButtons[1],
              c = 0 < a ? c : d;
            h(b.mapNavButtons, function(a, c) {
              a.element.setAttribute("tabindex", -1);
              a.element.setAttribute("role", "button");
              a.element.setAttribute("aria-label", b.langFormat("accessibility.mapZoom" + (c ? "Out" : "In"), {
                chart: b
              }))
            });
            b.setFocusToElement(c.box, c);
            c.setState(2);
            b.focusedMapNavButtonIx = 0 < a ? 0 : 1
          }
        }), a("rangeSelector", [
        [
          [37, 39, 38, 40],
          function(a) {
            a = 37 === a || 38 === a ? -1 : 1;
            if (!b.highlightRangeSelectorButton(b.highlightedRangeSelectorItemIx +
                a)) return this.move(a)
          }
        ],
        [
          [13, 32],
          function() {
            3 !== b.oldRangeSelectorItemState && t(b.rangeSelector.buttons[b.highlightedRangeSelectorItemIx].element)
          }
        ]
      ], {
        validate: function() {
          return b.rangeSelector && b.rangeSelector.buttons && b.rangeSelector.buttons.length
        },
        init: function(a) {
          h(b.rangeSelector.buttons, function(a) {
            a.element.setAttribute("tabindex", "-1");
            a.element.setAttribute("role", "button");
            a.element.setAttribute("aria-label", b.langFormat("accessibility.rangeSelectorButton", {
              chart: b,
              buttonText: a.text && a.text.textStr
            }))
          });
          b.highlightRangeSelectorButton(0 < a ? 0 : b.rangeSelector.buttons.length - 1)
        }
      }), a("rangeSelectorInput", [
        [
          [9, 38, 40],
          function(a, c) {
            a = 9 === a && c.shiftKey || 38 === a ? -1 : 1;
            c = b.highlightedInputRangeIx += a;
            if (1 < c || 0 > c) return this.move(a);
            b.rangeSelector[c ? "maxInput" : "minInput"].focus()
          }
        ]
      ], {
        validate: function() {
          return b.rangeSelector && b.rangeSelector.inputGroup && "hidden" !== b.rangeSelector.inputGroup.element.getAttribute("visibility") && !1 !== b.options.rangeSelector.inputEnabled && b.rangeSelector.minInput && b.rangeSelector.maxInput
        },
        init: function(a) {
          b.highlightedInputRangeIx = 0 < a ? 0 : 1;
          b.rangeSelector[b.highlightedInputRangeIx ? "maxInput" : "minInput"].focus()
        }
      }), a("legend", [
        [
          [37, 39, 38, 40],
          function(a) {
            a = 37 === a || 38 === a ? -1 : 1;
            !b.highlightLegendItem(b.highlightedLegendItemIx + a) && 1 < b.legend.allItems.length && this.init(a)
          }
        ],
        [
          [13, 32],
          function() {
            t(b.legend.allItems[b.highlightedLegendItemIx].legendItem.element.parentNode)
          }
        ]
      ], {
        validate: function() {
          return b.legend && b.legend.allItems && b.legend.display && !(b.colorAxis && b.colorAxis.length) && !1 !==
            (b.options.legend && b.options.legend.keyboardNavigation && b.options.legend.keyboardNavigation.enabled)
        },
        init: function(a) {
          h(b.legend.allItems, function(a) {
            a.legendGroup.element.setAttribute("tabindex", "-1");
            a.legendGroup.element.setAttribute("role", "button");
            a.legendGroup.element.setAttribute("aria-label", b.langFormat("accessibility.legendItem", {
              chart: b,
              itemName: r(a.name)
            }))
          });
          b.highlightLegendItem(0 < a ? 0 : b.legend.allItems.length - 1)
        }
      })]
    };
    a.Chart.prototype.addExitAnchor = function() {
      var a = this;
      a.tabExitAnchor =
        k.createElement("div");
      a.tabExitAnchor.setAttribute("tabindex", "0");
      l(!0, a.tabExitAnchor.style, {
        position: "absolute",
        left: "-9999px",
        top: "auto",
        width: "1px",
        height: "1px",
        overflow: "hidden"
      });
      a.renderTo.appendChild(a.tabExitAnchor);
      return g(a.tabExitAnchor, "focus", function(b) {
        b = b || f.event;
        a.exiting ? a.exiting = !1 : (a.renderTo.focus(), b.preventDefault(), a.keyboardNavigationModuleIndex = a.keyboardNavigationModules.length - 1, b = a.keyboardNavigationModules[a.keyboardNavigationModuleIndex], b.validate && !b.validate() ?
          b.move(-1) : b.init(-1))
      })
    };
    a.Chart.prototype.resetKeyboardNavigation = function() {
      var a = this.keyboardNavigationModules && this.keyboardNavigationModules[this.keyboardNavigationModuleIndex || 0];
      a && a.terminate && a.terminate();
      this.focusElement && this.focusElement.removeFocusBorder();
      this.keyboardNavigationModuleIndex = 0;
      this.keyboardReset = !0
    };
    a.addEvent(a.Series, "destroy", function() {
      var a = this.chart;
      a.highlightedPoint && a.highlightedPoint.series === this && (delete a.highlightedPoint, a.focusElement && a.focusElement.removeFocusBorder())
    });
    a.Chart.prototype.callbacks.push(function(a) {
      var b = a.options.accessibility;
      b.enabled && b.keyboardNavigation.enabled && (e = !!a.renderTo.getElementsByTagName("g")[0].focus, a.addKeyboardNavigationModules(), a.keyboardNavigationModuleIndex = 0, a.container.hasAttribute && !a.container.hasAttribute("tabIndex") && a.container.setAttribute("tabindex", "0"), a.tabExitAnchor || (a.unbindExitAnchorFocus = a.addExitAnchor()), a.unbindKeydownHandler = g(a.renderTo, "keydown", function(b) {
        b = b || f.event;
        var c = a.keyboardNavigationModules[a.keyboardNavigationModuleIndex];
        a.keyboardReset = !1;
        c && c.run(b) && b.preventDefault()
      }), a.unbindBlurHandler = g(k, "mouseup", function() {
        a.keyboardReset || a.pointer && a.pointer.chartPosition || a.resetKeyboardNavigation()
      }), g(a, "destroy", function() {
        a.resetKeyboardNavigation();
        a.unbindExitAnchorFocus && a.tabExitAnchor && a.unbindExitAnchorFocus();
        a.unbindKeydownHandler && a.renderTo && a.unbindKeydownHandler();
        a.unbindBlurHandler && a.unbindBlurHandler()
      }))
    })
  })(r)
});;
/*! RESOURCE: /scripts/highcharts/modules/pattern-fill.js */
(function(g) {
  "object" === typeof module && module.exports ? module.exports = g : g(Highcharts)
})(function(g) {
  (function(e) {
    function g(b, a) {
      b = JSON.stringify(b);
      var d = b.length || 0,
        c = 0,
        e = 0;
      if (a) {
        a = Math.max(Math.floor(d / 500), 1);
        for (var f = 0; f < d; f += a) c += b.charCodeAt(f);
        c &= c
      }
      for (; e < d; ++e) a = b.charCodeAt(e), c = (c << 5) - c + a, c &= c;
      return c.toString(16).replace("-", "1")
    }
    var m = e.wrap,
      k = e.each,
      n = e.merge;
    e.Point.prototype.calculatePatternDimensions = function(b) {
      if (!b.width || !b.height) {
        var a = this.graphic && (this.graphic.getBBox &&
            this.graphic.getBBox(!0) || this.graphic.element && this.graphic.element.getBBox()) || {},
          d = this.shapeArgs;
        d && (a.width = d.width || a.width, a.height = d.height || a.height, a.x = d.x || a.x, a.y = d.y || a.y);
        if (b.image) {
          if (!a.width || !a.height) {
            b._width = "defer";
            b._height = "defer";
            return
          }
          b.aspectRatio && (a.aspectRatio = a.width / a.height, b.aspectRatio > a.aspectRatio ? a.aspectWidth = a.height * b.aspectRatio : a.aspectHeight = a.width / b.aspectRatio);
          b._width = b.width || Math.ceil(a.aspectWidth || a.width);
          b._height = b.height || Math.ceil(a.aspectHeight ||
            a.height)
        }
        b.width || (b._x = b.x || 0, b._x += a.x - Math.round(a.aspectWidth ? Math.abs(a.aspectWidth - a.width) / 2 : 0));
        b.height || (b._y = b.y || 0, b._y += a.y - Math.round(a.aspectHeight ? Math.abs(a.aspectHeight - a.height) / 2 : 0))
      }
    };
    e.SVGRenderer.prototype.addPattern = function(b, a) {
      var d, c = e.pick(a, !0),
        h = b.width || b._width || 32,
        f = b.height || b._height || 32,
        g = b.color || "#343434",
        l = b.id,
        m = this,
        n = function(a) {
          m.rect(0, 0, h, f).attr({
            fill: a
          }).add(d)
        };
      l || (this.idCounter = this.idCounter || 0, l = "highcharts-pattern-" + this.idCounter, ++this.idCounter);
      this.defIds = this.defIds || [];
      if (!(-1 < e.inArray(l, this.defIds))) return this.defIds.push(l), d = this.createElement("pattern").attr({
        id: l,
        patternUnits: "userSpaceOnUse",
        width: h,
        height: f,
        x: b._x || b.x || 0,
        y: b._y || b.y || 0
      }).add(this.defs), d.id = l, b.path ? (a = b.path, a.fill && n(a.fill), this.createElement("path").attr({
        d: a.d || a,
        stroke: a.stroke || g,
        "stroke-width": a.strokeWidth || 2
      }).add(d), d.color = g) : b.image && (c ? this.image(b.image, 0, 0, h, f, function() {
          this.animate({
            opacity: 1
          }, c);
          e.removeEvent(this.element, "load")
        }).attr({
          opacity: 0
        }).add(d) :
        this.image(b.image, 0, 0, h, f).add(d)), void 0 !== b.opacity && k(d.element.childNodes, function(a) {
        a.setAttribute("opacity", b.opacity)
      }), this.patternElements = this.patternElements || {}, this.patternElements[l] = d
    };
    m(e.Series.prototype, "getColor", function(b) {
      var a = this.options.color;
      a && a.pattern && !a.pattern.color ? (delete this.options.color, b.apply(this, Array.prototype.slice.call(arguments, 1)), a.pattern.color = this.color, this.color = this.options.color = a) : b.apply(this, Array.prototype.slice.call(arguments, 1))
    });
    m(e.Series.prototype,
      "render",
      function(b) {
        var a = this.chart.isResizing;
        (this.isDirtyData || a || !this.chart.hasRendered) && k(this.points || [], function(b) {
          var c = b.options && b.options.color;
          c && c.pattern && (!a || b.shapeArgs && b.shapeArgs.width && b.shapeArgs.height ? b.calculatePatternDimensions(c.pattern) : (c.pattern._width = "defer", c.pattern._height = "defer"))
        });
        return b.apply(this, Array.prototype.slice.call(arguments, 1))
      });
    m(e.Point.prototype, "applyOptions", function(b) {
      var a = b.apply(this, Array.prototype.slice.call(arguments, 1)),
        d = a.options.color;
      d && d.pattern && ("string" === typeof d.pattern.path && (d.pattern.path = {
        d: d.pattern.path
      }), a.color = a.options.color = n(a.series.options.color, d));
      return a
    });
    e.addEvent(e.SVGRenderer, "complexColor", function(b) {
      var a = b.args[0],
        d = b.args[1];
      b = b.args[2];
      var c = a.pattern,
        h = "#343434",
        f;
      if (!c) return !0;
      if (c.image || "string" === typeof c.path || c.path && c.path.d) {
        f = (f = b.parentNode && b.parentNode.getAttribute("class")) && -1 < f.indexOf("highcharts-legend");
        "defer" !== c._width && "defer" !== c._height || e.Point.prototype.calculatePatternDimensions.call({
            graphic: {
              element: b
            }
          },
          c);
        if (f || !c.id) c = n({}, c), c.id = "highcharts-pattern-" + g(c) + g(c, !0);
        this.addPattern(c, !this.forExport && e.animObject(e.pick(c.animation, this.globalAnimation, {
          duration: 100
        })));
        h = "url(" + this.url + "#" + c.id + ")"
      } else h = c.color || h;
      b.setAttribute(d, h);
      a.toString = function() {
        return h
      };
      return !1
    });
    e.addEvent(e.Chart, "endResize", function() {
      e.grep(this.renderer.defIds || [], function(b) {
        return b && b.indexOf && 0 === b.indexOf("highcharts-pattern-")
      }).length && (k(this.series, function(b) {
        k(b.points, function(a) {
          (a = a.options &&
            a.options.color) && a.pattern && (a.pattern._width = "defer", a.pattern._height = "defer")
        })
      }), this.redraw(!1))
    });
    e.addEvent(e.Chart, "redraw", function() {
      var b = [],
        a = this.renderer,
        d = e.grep(a.defIds || [], function(a) {
          return a.indexOf && 0 === a.indexOf("highcharts-pattern-")
        });
      d.length && (k(this.renderTo.querySelectorAll('[color^\x3d"url(#"], [fill^\x3d"url(#"], [stroke^\x3d"url(#"]'), function(a) {
        (a = a.getAttribute("fill") || a.getAttribute("color") || a.getAttribute("stroke")) && b.push(a.substring(a.indexOf("url(#") + 5).replace(")",
          ""))
      }), k(d, function(c) {
        -1 === e.inArray(c, b) && (e.erase(a.defIds, c), a.patternElements[c] && (a.patternElements[c].destroy(), delete a.patternElements[c]))
      }))
    });
    e.Chart.prototype.callbacks.push(function(b) {
      var a = e.getOptions().colors;
      k("M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11;M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9;M 3 0 L 3 10 M 8 0 L 8 10;M 0 3 L 10 3 M 0 8 L 10 8;M 0 3 L 5 3 L 5 0 M 5 10 L 5 7 L 10 7;M 3 3 L 8 3 L 8 8 L 3 8 Z;M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0;M 10 3 L 5 3 L 5 0 M 5 10 L 5 7 L 0 7;M 2 5 L 5 2 L 8 5 L 5 8 Z;M 0 0 L 5 10 L 10 0".split(";"),
        function(d, c) {
          b.renderer.addPattern({
            id: "highcharts-default-pattern-" + c,
            path: d,
            color: a[c],
            width: 10,
            height: 10
          })
        })
    })
  })(g)
});;
/*! RESOURCE: /scripts/highcharts/modules/funnel.js */
(function(e) {
  "object" === typeof module && module.exports ? module.exports = e : e(Highcharts)
})(function(e) {
  (function(g) {
    var e = g.seriesType,
      C = g.seriesTypes,
      H = g.noop,
      D = g.pick,
      I = g.each;
    e("funnel", "pie", {
      animation: !1,
      center: ["50%", "50%"],
      width: "90%",
      neckWidth: "30%",
      height: "100%",
      neckHeight: "25%",
      reversed: !1,
      size: !0,
      dataLabels: {
        connectorWidth: 1
      },
      states: {
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      }
    }, {
      animate: H,
      translate: function() {
        var b = function(a, b) {
            return /%$/.test(a) ? b * parseInt(a, 10) / 100 : parseInt(a, 10)
          },
          E =
          0,
          c = this.chart,
          f = this.options,
          d = f.reversed,
          e = f.ignoreHiddenPoint,
          t = c.plotWidth,
          c = c.plotHeight,
          q = 0,
          g = f.center,
          h = b(g[0], t),
          r = b(g[1], c),
          C = b(f.width, t),
          l, v, m = b(f.height, c),
          w = b(f.neckWidth, t),
          F = b(f.neckHeight, c),
          x = r - m / 2 + m - F,
          b = this.data,
          z, A, D = "left" === f.dataLabels.position ? 1 : 0,
          B, n, G, u, k, y, p;
        this.getWidthAt = v = function(a) {
          var b = r - m / 2;
          return a > x || m === F ? w : w + (C - w) * (1 - (a - b) / (m - F))
        };
        this.getX = function(a, b, c) {
          return h + (b ? -1 : 1) * (v(d ? 2 * r - a : a) / 2 + c.labelDistance)
        };
        this.center = [h, r, m];
        this.centerX = h;
        I(b, function(a) {
          e &&
            !1 === a.visible || (E += a.y)
        });
        I(b, function(a) {
          p = null;
          A = E ? a.y / E : 0;
          n = r - m / 2 + q * m;
          k = n + A * m;
          l = v(n);
          B = h - l / 2;
          G = B + l;
          l = v(k);
          u = h - l / 2;
          y = u + l;
          n > x ? (B = u = h - w / 2, G = y = h + w / 2) : k > x && (p = k, l = v(x), u = h - l / 2, y = u + l, k = x);
          d && (n = 2 * r - n, k = 2 * r - k, p = p ? 2 * r - p : null);
          z = ["M", B, n, "L", G, n, y, k];
          p && z.push(y, p, u, p);
          z.push(u, k, "Z");
          a.shapeType = "path";
          a.shapeArgs = {
            d: z
          };
          a.percentage = 100 * A;
          a.plotX = h;
          a.plotY = (n + (p || k)) / 2;
          a.tooltipPos = [h, a.plotY];
          a.slice = H;
          a.half = D;
          e && !1 === a.visible || (q += A)
        })
      },
      sortByAngle: function(b) {
        b.sort(function(b, c) {
          return b.plotY -
            c.plotY
        })
      },
      drawDataLabels: function() {
        var b = this.data,
          e = this.options.dataLabels.distance,
          c, f, d, g = b.length,
          t, q;
        for (this.center[2] -= 2 * e; g--;) d = b[g], f = (c = d.half) ? 1 : -1, q = d.plotY, d.labelDistance = D(d.options.dataLabels && d.options.dataLabels.distance, e), this.maxLabelDistance = Math.max(d.labelDistance, this.maxLabelDistance || 0), t = this.getX(q, c, d), d.labelPos = [0, q, t + (d.labelDistance - 5) * f, q, t + d.labelDistance * f, q, c ? "right" : "left", 0];
        C.pie.prototype.drawDataLabels.call(this)
      }
    });
    e("pyramid", "funnel", {
      neckWidth: "0%",
      neckHeight: "0%",
      reversed: !0
    })
  })(e)
});;
/*! RESOURCE: /scripts/highcharts/modules/heatmap.js */
(function(n) {
  "object" === typeof module && module.exports ? module.exports = n : n(Highcharts)
})(function(n) {
  (function(b) {
    var u = b.addEvent,
      g = b.Axis,
      n = b.Chart,
      m = b.color,
      q, h = b.each,
      t = b.extend,
      r = b.isNumber,
      e = b.Legend,
      c = b.LegendSymbolMixin,
      x = b.noop,
      w = b.merge,
      p = b.pick;
    b.ColorAxis || (q = b.ColorAxis = function() {
      this.init.apply(this, arguments)
    }, t(q.prototype, g.prototype), t(q.prototype, {
      defaultColorAxisOptions: {
        lineWidth: 0,
        minPadding: 0,
        maxPadding: 0,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        startOnTick: !0,
        endOnTick: !0,
        offset: 0,
        marker: {
          animation: {
            duration: 50
          },
          width: .01,
          color: "#999999"
        },
        labels: {
          overflow: "justify",
          rotation: 0
        },
        minColor: "#e6ebf5",
        maxColor: "#003399",
        tickLength: 5,
        showInLegend: !0
      },
      keepProps: ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"].concat(g.prototype.keepProps),
      init: function(a, d) {
        var f = "vertical" !== a.options.legend.layout,
          l;
        this.coll = "colorAxis";
        l = w(this.defaultColorAxisOptions, {
          side: f ? 2 : 1,
          reversed: !f
        }, d, {
          opposite: !f,
          showEmpty: !1,
          title: null,
          visible: a.options.legend.enabled
        });
        g.prototype.init.call(this, a, l);
        d.dataClasses && this.initDataClasses(d);
        this.initStops();
        this.horiz = f;
        this.zoomEnabled = !1;
        this.defaultLegendLength = 200
      },
      initDataClasses: function(a) {
        var d = this.chart,
          f, l = 0,
          k = d.options.chart.colorCount,
          b = this.options,
          e = a.dataClasses.length;
        this.dataClasses = f = [];
        this.legendItems = [];
        h(a.dataClasses, function(a, c) {
          a = w(a);
          f.push(a);
          a.color || ("category" === b.dataClassColor ? (c = d.options.colors, k = c.length, a.color = c[l], a.colorIndex = l, l++, l === k && (l = 0)) : a.color = m(b.minColor).tweenTo(m(b.maxColor),
            2 > e ? .5 : c / (e - 1)))
        })
      },
      setTickPositions: function() {
        if (!this.dataClasses) return g.prototype.setTickPositions.call(this)
      },
      initStops: function() {
        this.stops = this.options.stops || [
          [0, this.options.minColor],
          [1, this.options.maxColor]
        ];
        h(this.stops, function(a) {
          a.color = m(a[1])
        })
      },
      setOptions: function(a) {
        g.prototype.setOptions.call(this, a);
        this.options.crosshair = this.options.marker
      },
      setAxisSize: function() {
        var a = this.legendSymbol,
          d = this.chart,
          f = d.options.legend || {},
          l, k;
        a ? (this.left = f = a.attr("x"), this.top = l = a.attr("y"),
          this.width = k = a.attr("width"), this.height = a = a.attr("height"), this.right = d.chartWidth - f - k, this.bottom = d.chartHeight - l - a, this.len = this.horiz ? k : a, this.pos = this.horiz ? f : l) : this.len = (this.horiz ? f.symbolWidth : f.symbolHeight) || this.defaultLegendLength
      },
      normalizedValue: function(a) {
        this.isLog && (a = this.val2lin(a));
        return 1 - (this.max - a) / (this.max - this.min || 1)
      },
      toColor: function(a, d) {
        var f = this.stops,
          l, k, b = this.dataClasses,
          e, c;
        if (b)
          for (c = b.length; c--;) {
            if (e = b[c], l = e.from, f = e.to, (void 0 === l || a >= l) && (void 0 === f ||
                a <= f)) {
              k = e.color;
              d && (d.dataClass = c, d.colorIndex = e.colorIndex);
              break
            }
          } else {
            a = this.normalizedValue(a);
            for (c = f.length; c-- && !(a > f[c][0]););
            l = f[c] || f[c + 1];
            f = f[c + 1] || l;
            a = 1 - (f[0] - a) / (f[0] - l[0] || 1);
            k = l.color.tweenTo(f.color, a)
          }
        return k
      },
      getOffset: function() {
        var a = this.legendGroup,
          d = this.chart.axisOffset[this.side];
        a && (this.axisParent = a, g.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = d)
      },
      setLegendColor: function() {
        var a,
          d = this.reversed;
        a = d ? 1 : 0;
        d = d ? 0 : 1;
        a = this.horiz ? [a, 0, d, 0] : [0, d, 0, a];
        this.legendColor = {
          linearGradient: {
            x1: a[0],
            y1: a[1],
            x2: a[2],
            y2: a[3]
          },
          stops: this.stops
        }
      },
      drawLegendSymbol: function(a, d) {
        var f = a.padding,
          b = a.options,
          k = this.horiz,
          c = p(b.symbolWidth, k ? this.defaultLegendLength : 12),
          e = p(b.symbolHeight, k ? 12 : this.defaultLegendLength),
          h = p(b.labelPadding, k ? 16 : 30),
          b = p(b.itemDistance, 10);
        this.setLegendColor();
        d.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, c, e).attr({
          zIndex: 1
        }).add(d.legendGroup);
        this.legendItemWidth =
          c + f + (k ? b : h);
        this.legendItemHeight = e + f + (k ? h : 0)
      },
      setState: function(a) {
        h(this.series, function(d) {
          d.setState(a)
        })
      },
      visible: !0,
      setVisible: x,
      getSeriesExtremes: function() {
        var a = this.series,
          d = a.length;
        this.dataMin = Infinity;
        for (this.dataMax = -Infinity; d--;) void 0 !== a[d].valueMin && (this.dataMin = Math.min(this.dataMin, a[d].valueMin), this.dataMax = Math.max(this.dataMax, a[d].valueMax))
      },
      drawCrosshair: function(a, d) {
        var f = d && d.plotX,
          b = d && d.plotY,
          c, e = this.pos,
          h = this.len;
        d && (c = this.toPixels(d[d.series.colorKey]), c < e ?
          c = e - 2 : c > e + h && (c = e + h + 2), d.plotX = c, d.plotY = this.len - c, g.prototype.drawCrosshair.call(this, a, d), d.plotX = f, d.plotY = b, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.cross.attr({
            fill: this.crosshair.color
          })))
      },
      getPlotLinePath: function(a, d, f, b, c) {
        return r(c) ? this.horiz ? ["M", c - 4, this.top - 6, "L", c + 4, this.top - 6, c, this.top, "Z"] : ["M", this.left, c, "L", this.left - 6, c + 6, this.left - 6, c - 6, "Z"] : g.prototype.getPlotLinePath.call(this,
          a, d, f, b)
      },
      update: function(a, d) {
        var c = this.chart,
          b = c.legend;
        h(this.series, function(a) {
          a.isDirtyData = !0
        });
        a.dataClasses && b.allItems && (h(b.allItems, function(a) {
          a.isDataClass && a.legendGroup && a.legendGroup.destroy()
        }), c.isDirtyLegend = !0);
        c.options[this.coll] = w(this.userOptions, a);
        g.prototype.update.call(this, a, d);
        this.legendItem && (this.setLegendColor(), b.colorizeItem(this, !0))
      },
      remove: function() {
        this.legendItem && this.chart.legend.destroyItem(this);
        g.prototype.remove.call(this)
      },
      getDataClassLegendSymbols: function() {
        var a =
          this,
          d = this.chart,
          f = this.legendItems,
          e = d.options.legend,
          k = e.valueDecimals,
          q = e.valueSuffix || "",
          g;
        f.length || h(this.dataClasses, function(e, l) {
          var m = !0,
            r = e.from,
            p = e.to;
          g = "";
          void 0 === r ? g = "\x3c " : void 0 === p && (g = "\x3e ");
          void 0 !== r && (g += b.numberFormat(r, k) + q);
          void 0 !== r && void 0 !== p && (g += " - ");
          void 0 !== p && (g += b.numberFormat(p, k) + q);
          f.push(t({
            chart: d,
            name: g,
            options: {},
            drawLegendSymbol: c.drawRectangle,
            visible: !0,
            setState: x,
            isDataClass: !0,
            setVisible: function() {
              m = this.visible = !m;
              h(a.series, function(a) {
                h(a.points,
                  function(a) {
                    a.dataClass === l && a.setVisible(m)
                  })
              });
              d.legend.colorizeItem(this, m)
            }
          }, e))
        });
        return f
      },
      name: ""
    }), h(["fill", "stroke"], function(a) {
      b.Fx.prototype[a + "Setter"] = function() {
        this.elem.attr(a, m(this.start).tweenTo(m(this.end), this.pos), null, !0)
      }
    }), u(n, "afterGetAxes", function() {
      var a = this.options.colorAxis;
      this.colorAxis = [];
      a && new q(this, a)
    }), u(e, "afterGetAllItems", function(a) {
      var d = [],
        c = this.chart.colorAxis[0];
      c && c.options && (c.options.showInLegend && (c.options.dataClasses ? d = c.getDataClassLegendSymbols() :
        d.push(c)), h(c.series, function(c) {
        b.erase(a.allItems, c)
      }));
      for (; d.length;) a.allItems.unshift(d.pop())
    }), u(e, "afterColorizeItem", function(a) {
      a.visible && a.item.legendColor && a.item.legendSymbol.attr({
        fill: a.item.legendColor
      })
    }), u(e, "afterUpdate", function(a, c, b) {
      this.chart.colorAxis[0] && this.chart.colorAxis[0].update({}, b)
    }))
  })(n);
  (function(b) {
    var n = b.defined,
      g = b.each,
      v = b.noop,
      m = b.seriesTypes;
    b.colorPointMixin = {
      isValid: function() {
        return null !== this.value && Infinity !== this.value && -Infinity !== this.value
      },
      setVisible: function(b) {
        var h = this,
          q = b ? "show" : "hide";
        g(["graphic", "dataLabel"], function(b) {
          if (h[b]) h[b][q]()
        })
      },
      setState: function(g) {
        b.Point.prototype.setState.call(this, g);
        this.graphic && this.graphic.attr({
          zIndex: "hover" === g ? 1 : 0
        })
      }
    };
    b.colorSeriesMixin = {
      pointArrayMap: ["value"],
      axisTypes: ["xAxis", "yAxis", "colorAxis"],
      optionalAxis: "colorAxis",
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      getSymbol: v,
      parallelArrays: ["x", "y", "value"],
      colorKey: "value",
      pointAttribs: m.column.prototype.pointAttribs,
      translateColors: function() {
        var b = this,
          h = this.options.nullColor,
          m = this.colorAxis,
          r = this.colorKey;
        g(this.data, function(e) {
          var c = e[r];
          if (c = e.options.color || (e.isNull ? h : m && void 0 !== c ? m.toColor(c, e) : e.color || b.color)) e.color = c
        })
      },
      colorAttribs: function(b) {
        var g = {};
        n(b.color) && (g[this.colorProp || "fill"] = b.color);
        return g
      }
    }
  })(n);
  (function(b) {
    var n = b.colorPointMixin,
      g = b.each,
      v = b.merge,
      m = b.noop,
      q = b.pick,
      h = b.Series,
      t = b.seriesType,
      r = b.seriesTypes;
    t("heatmap", "scatter", {
      animation: !1,
      borderWidth: 0,
      nullColor: "#f7f7f7",
      dataLabels: {
        formatter: function() {
          return this.point.value
        },
        inside: !0,
        verticalAlign: "middle",
        crop: !1,
        overflow: !1,
        padding: 0
      },
      marker: null,
      pointRange: null,
      tooltip: {
        pointFormat: "{point.x}, {point.y}: {point.value}\x3cbr/\x3e"
      },
      states: {
        hover: {
          halo: !1,
          brightness: .2
        }
      }
    }, v(b.colorSeriesMixin, {
      pointArrayMap: ["y", "value"],
      hasPointSpecificOptions: !0,
      getExtremesFromAll: !0,
      directTouch: !0,
      init: function() {
        var b;
        r.scatter.prototype.init.apply(this, arguments);
        b = this.options;
        b.pointRange = q(b.pointRange, b.colsize || 1);
        this.yAxis.axisPointRange = b.rowsize || 1
      },
      translate: function() {
        var b = this.options,
          c = this.xAxis,
          h = this.yAxis,
          m = b.pointPadding || 0,
          p = function(a, b, c) {
            return Math.min(Math.max(b, a), c)
          };
        this.generatePoints();
        g(this.points, function(a) {
          var d = (b.colsize || 1) / 2,
            e = (b.rowsize || 1) / 2,
            g = p(Math.round(c.len - c.translate(a.x - d, 0, 1, 0, 1)), -c.len, 2 * c.len),
            d = p(Math.round(c.len - c.translate(a.x + d, 0, 1, 0, 1)), -c.len, 2 * c.len),
            k = p(Math.round(h.translate(a.y - e, 0, 1, 0, 1)), -h.len, 2 * h.len),
            e = p(Math.round(h.translate(a.y + e, 0, 1, 0, 1)), -h.len,
              2 * h.len),
            n = q(a.pointPadding, m);
          a.plotX = a.clientX = (g + d) / 2;
          a.plotY = (k + e) / 2;
          a.shapeType = "rect";
          a.shapeArgs = {
            x: Math.min(g, d) + n,
            y: Math.min(k, e) + n,
            width: Math.abs(d - g) - 2 * n,
            height: Math.abs(e - k) - 2 * n
          }
        });
        this.translateColors()
      },
      drawPoints: function() {
        r.column.prototype.drawPoints.call(this);
        g(this.points, function(b) {
          b.graphic.attr(this.colorAttribs(b))
        }, this)
      },
      animate: m,
      getBox: m,
      drawLegendSymbol: b.LegendSymbolMixin.drawRectangle,
      alignDataLabel: r.column.prototype.alignDataLabel,
      getExtremes: function() {
        h.prototype.getExtremes.call(this,
          this.valueData);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        h.prototype.getExtremes.call(this)
      }
    }), b.extend({
      haloPath: function(b) {
        if (!b) return [];
        var c = this.shapeArgs;
        return ["M", c.x - b, c.y - b, "L", c.x - b, c.y + c.height + b, c.x + c.width + b, c.y + c.height + b, c.x + c.width + b, c.y - b, "Z"]
      }
    }, n))
  })(n)
});;
/*! RESOURCE: /scripts/highcharts/modules/solid-gauge.js */
(function(l) {
  "object" === typeof module && module.exports ? module.exports = l : l(Highcharts)
})(function(l) {
  (function(e) {
    var l = e.pInt,
      u = e.pick,
      m = e.each,
      r = e.isNumber,
      w = e.wrap,
      v;
    w(e.Renderer.prototype.symbols, "arc", function(a, f, d, c, e, b) {
      a = a(f, d, c, e, b);
      b.rounded && (c = ((b.r || c) - b.innerR) / 2, b = ["A", c, c, 0, 1, 1, a[12], a[13]], a.splice.apply(a, [a.length - 1, 0].concat(["A", c, c, 0, 1, 1, a[1], a[2]])), a.splice.apply(a, [11, 3].concat(b)));
      return a
    });
    v = {
      initDataClasses: function(a) {
        var f = this.chart,
          d, c = 0,
          t = this.options;
        this.dataClasses =
          d = [];
        m(a.dataClasses, function(b, h) {
          b = e.merge(b);
          d.push(b);
          b.color || ("category" === t.dataClassColor ? (h = f.options.colors, b.color = h[c++], c === h.length && (c = 0)) : b.color = e.color(t.minColor).tweenTo(e.color(t.maxColor), h / (a.dataClasses.length - 1)))
        })
      },
      initStops: function(a) {
        this.stops = a.stops || [
          [0, this.options.minColor],
          [1, this.options.maxColor]
        ];
        m(this.stops, function(a) {
          a.color = e.color(a[1])
        })
      },
      toColor: function(a, f) {
        var d = this.stops,
          c, e, b = this.dataClasses,
          h, g;
        if (b)
          for (g = b.length; g--;) {
            if (h = b[g], c = h.from, d =
              h.to, (void 0 === c || a >= c) && (void 0 === d || a <= d)) {
              e = h.color;
              f && (f.dataClass = g);
              break
            }
          } else {
            this.isLog && (a = this.val2lin(a));
            a = 1 - (this.max - a) / (this.max - this.min);
            for (g = d.length; g-- && !(a > d[g][0]););
            c = d[g] || d[g + 1];
            d = d[g + 1] || c;
            a = 1 - (d[0] - a) / (d[0] - c[0] || 1);
            e = c.color.tweenTo(d.color, a)
          }
        return e
      }
    };
    e.seriesType("solidgauge", "gauge", {
      colorByPoint: !0
    }, {
      translate: function() {
        var a = this.yAxis;
        e.extend(a, v);
        !a.dataClasses && a.options.dataClasses && a.initDataClasses(a.options);
        a.initStops(a.options);
        e.seriesTypes.gauge.prototype.translate.call(this)
      },
      drawPoints: function() {
        var a = this,
          f = a.yAxis,
          d = f.center,
          c = a.options,
          t = a.chart.renderer,
          b = c.overshoot,
          h = r(b) ? b / 180 * Math.PI : 0,
          g;
        r(c.threshold) && (g = f.startAngleRad + f.translate(c.threshold, null, null, null, !0));
        this.thresholdAngleRad = u(g, f.startAngleRad);
        m(a.points, function(b) {
          var g = b.graphic,
            k = f.startAngleRad + f.translate(b.y, null, null, null, !0),
            m = l(u(b.options.radius, c.radius, 100)) * d[2] / 200,
            n = l(u(b.options.innerRadius, c.innerRadius, 60)) * d[2] / 200,
            p = f.toColor(b.y, b),
            q = Math.min(f.startAngleRad, f.endAngleRad),
            r = Math.max(f.startAngleRad, f.endAngleRad);
          "none" === p && (p = b.color || a.color || "none");
          "none" !== p && (b.color = p);
          k = Math.max(q - h, Math.min(r + h, k));
          !1 === c.wrap && (k = Math.max(q, Math.min(r, k)));
          q = Math.min(k, a.thresholdAngleRad);
          k = Math.max(k, a.thresholdAngleRad);
          k - q > 2 * Math.PI && (k = q + 2 * Math.PI);
          b.shapeArgs = n = {
            x: d[0],
            y: d[1],
            r: m,
            innerR: n,
            start: q,
            end: k,
            rounded: c.rounded
          };
          b.startR = m;
          g ? (b = n.d, g.animate(e.extend({
            fill: p
          }, n)), b && (n.d = b)) : (b.graphic = t.arc(n).addClass(b.getClassName(), !0).attr({
              fill: p,
              "sweep-flag": 0
            }).add(a.group),
            "square" !== c.linecap && b.graphic.attr({
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }), b.graphic.attr({
              stroke: c.borderColor || "none",
              "stroke-width": c.borderWidth || 0
            }))
        })
      },
      animate: function(a) {
        a || (this.startAngleRad = this.thresholdAngleRad, e.seriesTypes.pie.prototype.animate.call(this, a))
      }
    })
  })(l)
});;
/*! RESOURCE: /scripts/highcharts/modules/treemap.js */
(function(x) {
  "object" === typeof module && module.exports ? module.exports = x : x(Highcharts)
})(function(x) {
  var F = function(b) {
    var x = b.each,
      C = b.extend,
      q = b.isArray,
      k = b.isObject,
      r = b.isNumber,
      E = b.merge,
      A = b.pick,
      n = b.reduce;
    return {
      getColor: function(t, u) {
        var y = u.index,
          g = u.mapOptionsToLevel,
          n = u.parentColor,
          z = u.parentColorIndex,
          v = u.series,
          e = u.colors,
          q = u.siblings,
          l = v.points,
          k, D, B, r;
        if (t) {
          l = l[t.i];
          t = g[t.level] || {};
          if (k = l && t.colorByPoint) B = l.index % (e ? e.length : v.chart.options.chart.colorCount), D = e && e[B];
          e = l && l.options.color;
          k = t && t.color;
          if (g = n) g = (g = t && t.colorVariation) && "brightness" === g.key ? b.color(n).brighten(y / q * g.to).get() : n;
          k = A(e, k, D, g, v.color);
          r = A(l && l.options.colorIndex, t && t.colorIndex, B, z, u.colorIndex)
        }
        return {
          color: k,
          colorIndex: r
        }
      },
      getLevelOptions: function(b) {
        var u = null,
          y, g, t, z;
        if (k(b))
          for (u = {}, t = r(b.from) ? b.from : 1, z = b.levels, g = {}, y = k(b.defaults) ? b.defaults : {}, q(z) && (g = n(z, function(b, e) {
              var g, l;
              k(e) && r(e.level) && (l = E({}, e), g = "boolean" === typeof l.levelIsConstant ? l.levelIsConstant : y.levelIsConstant, delete l.levelIsConstant,
                delete l.level, e = e.level + (g ? 0 : t - 1), k(b[e]) ? C(b[e], l) : b[e] = l);
              return b
            }, {})), z = r(b.to) ? b.to : 1, b = 0; b <= z; b++) u[b] = E({}, y, k(g[b]) ? g[b] : {});
        return u
      },
      setTreeValues: function u(b, g) {
        var n = g.before,
          k = g.idRoot,
          y = g.mapIdToNode[k],
          e = g.points[b.i],
          q = e && e.options || {},
          l = 0,
          r = [];
        C(b, {
          levelDynamic: b.level - (("boolean" === typeof g.levelIsConstant ? g.levelIsConstant : 1) ? 0 : y.level),
          name: A(e && e.name, ""),
          visible: k === b.id || ("boolean" === typeof g.visible ? g.visible : !1)
        });
        "function" === typeof n && (b = n(b, g));
        x(b.children, function(e,
          n) {
          var k = C({}, g);
          C(k, {
            index: n,
            siblings: b.children.length,
            visible: b.visible
          });
          e = u(e, k);
          r.push(e);
          e.visible && (l += e.val)
        });
        b.visible = 0 < l || b.visible;
        n = A(q.value, l);
        C(b, {
          children: r,
          childrenTotal: l,
          isLeaf: b.visible && !l,
          val: n
        });
        return b
      },
      updateRootId: function(b) {
        var n;
        k(b) && (n = k(b.options) ? b.options : {}, n = A(b.rootNode, n.rootId, ""), k(b.userOptions) && (b.userOptions.rootId = n), b.rootNode = n);
        return n
      }
    }
  }(x);
  (function(b, x) {
    var C = b.seriesType,
      q = b.seriesTypes,
      k = b.map,
      r = b.merge,
      E = b.extend,
      A = b.noop,
      n = b.each,
      t = x.getColor,
      u = x.getLevelOptions,
      y = b.grep,
      g = b.isNumber,
      F = b.isObject,
      z = b.isString,
      v = b.pick,
      e = b.Series,
      H = b.stableSort,
      l = b.Color,
      I = function(a, c, d) {
        d = d || this;
        b.objectEach(a, function(b, f) {
          c.call(d, b, f, a)
        })
      },
      D = b.reduce,
      B = function(a, c, d) {
        d = d || this;
        a = c.call(d, a);
        !1 !== a && B(a, c, d)
      },
      J = x.updateRootId;
    C("treemap", "scatter", {
      showInLegend: !1,
      marker: !1,
      colorByPoint: !1,
      dataLabels: {
        enabled: !0,
        defer: !1,
        verticalAlign: "middle",
        formatter: function() {
          return this.point.name || this.point.id
        },
        inside: !0
      },
      tooltip: {
        headerFormat: "",
        pointFormat: "\x3cb\x3e{point.name}\x3c/b\x3e: {point.value}\x3cbr/\x3e"
      },
      ignoreHiddenPoint: !0,
      layoutAlgorithm: "sliceAndDice",
      layoutStartingDirection: "vertical",
      alternateStartingDirection: !1,
      levelIsConstant: !0,
      drillUpButton: {
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      borderColor: "#e6e6e6",
      borderWidth: 1,
      opacity: .15,
      states: {
        hover: {
          borderColor: "#999999",
          brightness: q.heatmap ? 0 : .1,
          halo: !1,
          opacity: .75,
          shadow: !1
        }
      }
    }, {
      pointArrayMap: ["value"],
      axisTypes: q.heatmap ? ["xAxis", "yAxis", "colorAxis"] : ["xAxis", "yAxis"],
      directTouch: !0,
      optionalAxis: "colorAxis",
      getSymbol: A,
      parallelArrays: ["x", "y",
        "value", "colorValue"
      ],
      colorKey: "colorValue",
      translateColors: q.heatmap && q.heatmap.prototype.translateColors,
      colorAttribs: q.heatmap && q.heatmap.prototype.colorAttribs,
      trackerGroups: ["group", "dataLabelsGroup"],
      getListOfParents: function(a, c) {
        a = D(a || [], function(a, c, b) {
          c = v(c.parent, "");
          void 0 === a[c] && (a[c] = []);
          a[c].push(b);
          return a
        }, {});
        I(a, function(a, m, f) {
          "" !== m && -1 === b.inArray(m, c) && (n(a, function(a) {
            f[""].push(a)
          }), delete f[m])
        });
        return a
      },
      getTree: function() {
        var a = k(this.data, function(a) {
            return a.id
          }),
          a = this.getListOfParents(this.data, a);
        this.nodeMap = [];
        return this.buildNode("", -1, 0, a, null)
      },
      init: function(a, c) {
        e.prototype.init.call(this, a, c);
        this.options.allowDrillToNode && b.addEvent(this, "click", this.onClickDrillToNode)
      },
      buildNode: function(a, c, d, b, f) {
        var p = this,
          m = [],
          h = p.points[c],
          G = 0,
          e;
        n(b[a] || [], function(c) {
          e = p.buildNode(p.points[c].id, c, d + 1, b, a);
          G = Math.max(e.height + 1, G);
          m.push(e)
        });
        c = {
          id: a,
          i: c,
          children: m,
          height: G,
          level: d,
          parent: f,
          visible: !1
        };
        p.nodeMap[c.id] = c;
        h && (h.node = c);
        return c
      },
      setTreeValues: function(a) {
        var c =
          this,
          d = c.options,
          b = c.nodeMap[c.rootNode],
          d = "boolean" === typeof d.levelIsConstant ? d.levelIsConstant : !0,
          f = 0,
          p = [],
          e, h = c.points[a.i];
        n(a.children, function(a) {
          a = c.setTreeValues(a);
          p.push(a);
          a.ignore || (f += a.val)
        });
        H(p, function(a, c) {
          return a.sortIndex - c.sortIndex
        });
        e = v(h && h.options.value, f);
        h && (h.value = e);
        E(a, {
          children: p,
          childrenTotal: f,
          ignore: !(v(h && h.visible, !0) && 0 < e),
          isLeaf: a.visible && !f,
          levelDynamic: a.level - (d ? 0 : b.level),
          name: v(h && h.name, ""),
          sortIndex: v(h && h.sortIndex, -e),
          val: e
        });
        return a
      },
      calculateChildrenAreas: function(a,
        c) {
        var d = this,
          b = d.options,
          f = d.mapOptionsToLevel[a.level + 1],
          p = v(d[f && f.layoutAlgorithm] && f.layoutAlgorithm, b.layoutAlgorithm),
          e = b.alternateStartingDirection,
          h = [];
        a = y(a.children, function(a) {
          return !a.ignore
        });
        f && f.layoutStartingDirection && (c.direction = "vertical" === f.layoutStartingDirection ? 0 : 1);
        h = d[p](c, a);
        n(a, function(a, b) {
          b = h[b];
          a.values = r(b, {
            val: a.childrenTotal,
            direction: e ? 1 - c.direction : c.direction
          });
          a.pointValues = r(b, {
            x: b.x / d.axisRatio,
            width: b.width / d.axisRatio
          });
          a.children.length && d.calculateChildrenAreas(a,
            a.values)
        })
      },
      setPointValues: function() {
        var a = this,
          c = a.xAxis,
          d = a.yAxis;
        n(a.points, function(b) {
          var f = b.node,
            p = f.pointValues,
            m, h, e;
          e = (a.pointAttribs(b)["stroke-width"] || 0) % 2 / 2;
          p && f.visible ? (f = Math.round(c.translate(p.x, 0, 0, 0, 1)) - e, m = Math.round(c.translate(p.x + p.width, 0, 0, 0, 1)) - e, h = Math.round(d.translate(p.y, 0, 0, 0, 1)) - e, p = Math.round(d.translate(p.y + p.height, 0, 0, 0, 1)) - e, b.shapeType = "rect", b.shapeArgs = {
              x: Math.min(f, m),
              y: Math.min(h, p),
              width: Math.abs(m - f),
              height: Math.abs(p - h)
            }, b.plotX = b.shapeArgs.x + b.shapeArgs.width /
            2, b.plotY = b.shapeArgs.y + b.shapeArgs.height / 2) : (delete b.plotX, delete b.plotY)
        })
      },
      setColorRecursive: function(a, c, b, e, f) {
        var d = this,
          m = d && d.chart,
          m = m && m.options && m.options.colors,
          h;
        if (a) {
          h = t(a, {
            colors: m,
            index: e,
            mapOptionsToLevel: d.mapOptionsToLevel,
            parentColor: c,
            parentColorIndex: b,
            series: d,
            siblings: f
          });
          if (c = d.points[a.i]) c.color = h.color, c.colorIndex = h.colorIndex;
          n(a.children || [], function(c, b) {
            d.setColorRecursive(c, h.color, h.colorIndex, b, a.children.length)
          })
        }
      },
      algorithmGroup: function(a, c, b, m) {
        this.height =
          a;
        this.width = c;
        this.plot = m;
        this.startDirection = this.direction = b;
        this.lH = this.nH = this.lW = this.nW = this.total = 0;
        this.elArr = [];
        this.lP = {
          total: 0,
          lH: 0,
          nH: 0,
          lW: 0,
          nW: 0,
          nR: 0,
          lR: 0,
          aspectRatio: function(a, c) {
            return Math.max(a / c, c / a)
          }
        };
        this.addElement = function(a) {
          this.lP.total = this.elArr[this.elArr.length - 1];
          this.total += a;
          0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR =
            this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH));
          this.elArr.push(a)
        };
        this.reset = function() {
          this.lW = this.nW = 0;
          this.elArr = [];
          this.total = 0
        }
      },
      algorithmCalcPoints: function(a, c, b, m) {
        var d, e, g, h, l = b.lW,
          k = b.lH,
          w = b.plot,
          t, u = 0,
          q = b.elArr.length - 1;
        c ? (l = b.nW, k = b.nH) : t = b.elArr[b.elArr.length - 1];
        n(b.elArr, function(a) {
          if (c ||
            u < q) 0 === b.direction ? (d = w.x, e = w.y, g = l, h = a / g) : (d = w.x, e = w.y, h = k, g = a / h), m.push({
            x: d,
            y: e,
            width: g,
            height: h
          }), 0 === b.direction ? w.y += h : w.x += g;
          u += 1
        });
        b.reset();
        0 === b.direction ? b.width -= l : b.height -= k;
        w.y = w.parent.y + (w.parent.height - b.height);
        w.x = w.parent.x + (w.parent.width - b.width);
        a && (b.direction = 1 - b.direction);
        c || b.addElement(t)
      },
      algorithmLowAspectRatio: function(a, b, d) {
        var c = [],
          e = this,
          p, g = {
            x: b.x,
            y: b.y,
            parent: b
          },
          h = 0,
          l = d.length - 1,
          k = new this.algorithmGroup(b.height, b.width, b.direction, g);
        n(d, function(d) {
          p = d.val /
            b.val * b.height * b.width;
          k.addElement(p);
          k.lP.nR > k.lP.lR && e.algorithmCalcPoints(a, !1, k, c, g);
          h === l && e.algorithmCalcPoints(a, !0, k, c, g);
          h += 1
        });
        return c
      },
      algorithmFill: function(a, b, d) {
        var c = [],
          e, p = b.direction,
          g = b.x,
          h = b.y,
          k = b.width,
          l = b.height,
          t, u, q, r;
        n(d, function(d) {
          e = d.val / b.val * b.height * b.width;
          t = g;
          u = h;
          0 === p ? (r = l, q = e / r, k -= q, g += q) : (q = k, r = e / q, l -= r, h += r);
          c.push({
            x: t,
            y: u,
            width: q,
            height: r
          });
          a && (p = 1 - p)
        });
        return c
      },
      strip: function(a, b) {
        return this.algorithmLowAspectRatio(!1, a, b)
      },
      squarified: function(a, b) {
        return this.algorithmLowAspectRatio(!0,
          a, b)
      },
      sliceAndDice: function(a, b) {
        return this.algorithmFill(!0, a, b)
      },
      stripes: function(a, b) {
        return this.algorithmFill(!1, a, b)
      },
      translate: function() {
        var a = this,
          b = a.options,
          d = J(a),
          m, f;
        e.prototype.translate.call(a);
        f = a.tree = a.getTree();
        m = a.nodeMap[d];
        a.mapOptionsToLevel = u({
          from: m.level + 1,
          levels: b.levels,
          to: f.height,
          defaults: {
            levelIsConstant: a.options.levelIsConstant,
            colorByPoint: b.colorByPoint
          }
        });
        "" === d || m && m.children.length || (a.drillToNode("", !1), d = a.rootNode, m = a.nodeMap[d]);
        B(a.nodeMap[a.rootNode], function(b) {
          var c = !1,
            d = b.parent;
          b.visible = !0;
          if (d || "" === d) c = a.nodeMap[d];
          return c
        });
        B(a.nodeMap[a.rootNode].children, function(a) {
          var b = !1;
          n(a, function(a) {
            a.visible = !0;
            a.children.length && (b = (b || []).concat(a.children))
          });
          return b
        });
        a.setTreeValues(f);
        a.axisRatio = a.xAxis.len / a.yAxis.len;
        a.nodeMap[""].pointValues = d = {
          x: 0,
          y: 0,
          width: 100,
          height: 100
        };
        a.nodeMap[""].values = d = r(d, {
          width: d.width * a.axisRatio,
          direction: "vertical" === b.layoutStartingDirection ? 0 : 1,
          val: f.val
        });
        a.calculateChildrenAreas(f, d);
        a.colorAxis ? a.translateColors() :
          b.colorByPoint || a.setColorRecursive(a.tree);
        b.allowDrillToNode && (b = m.pointValues, a.xAxis.setExtremes(b.x, b.x + b.width, !1), a.yAxis.setExtremes(b.y, b.y + b.height, !1), a.xAxis.setScale(), a.yAxis.setScale());
        a.setPointValues()
      },
      drawDataLabels: function() {
        var a = this,
          b = a.mapOptionsToLevel,
          d = y(a.points, function(a) {
            return a.node.visible
          }),
          m, f;
        n(d, function(c) {
          f = b[c.node.level];
          m = {
            style: {}
          };
          c.node.isLeaf || (m.enabled = !1);
          f && f.dataLabels && (m = r(m, f.dataLabels), a._hasPointLabels = !0);
          c.shapeArgs && (m.style.width = c.shapeArgs.width,
            c.dataLabel && c.dataLabel.css({
              width: c.shapeArgs.width + "px"
            }));
          c.dlOptions = r(m, c.options.dataLabels)
        });
        e.prototype.drawDataLabels.call(this)
      },
      alignDataLabel: function(a) {
        q.column.prototype.alignDataLabel.apply(this, arguments);
        a.dataLabel && a.dataLabel.attr({
          zIndex: (a.node.zIndex || 0) + 1
        })
      },
      pointAttribs: function(a, b) {
        var c = F(this.mapOptionsToLevel) ? this.mapOptionsToLevel : {},
          e = a && c[a.node.level] || {},
          c = this.options,
          f = b && c.states[b] || {},
          g = a && a.getClassName() || "";
        a = {
          stroke: a && a.borderColor || e.borderColor ||
            f.borderColor || c.borderColor,
          "stroke-width": v(a && a.borderWidth, e.borderWidth, f.borderWidth, c.borderWidth),
          dashstyle: a && a.borderDashStyle || e.borderDashStyle || f.borderDashStyle || c.borderDashStyle,
          fill: a && a.color || this.color
        }; - 1 !== g.indexOf("highcharts-above-level") ? (a.fill = "none", a["stroke-width"] = 0) : -1 !== g.indexOf("highcharts-internal-node-interactive") ? (b = v(f.opacity, c.opacity), a.fill = l(a.fill).setOpacity(b).get(), a.cursor = "pointer") : -1 !== g.indexOf("highcharts-internal-node") ? a.fill = "none" : b && (a.fill =
          l(a.fill).brighten(f.brightness).get());
        return a
      },
      drawPoints: function() {
        var a = this,
          b = y(a.points, function(a) {
            return a.node.visible
          });
        n(b, function(b) {
          var c = "level-group-" + b.node.levelDynamic;
          a[c] || (a[c] = a.chart.renderer.g(c).attr({
            zIndex: 1E3 - b.node.levelDynamic
          }).add(a.group));
          b.group = a[c]
        });
        q.column.prototype.drawPoints.call(this);
        a.options.allowDrillToNode && n(b, function(b) {
          b.graphic && (b.drillId = a.options.interactByLeaf ? a.drillToByLeaf(b) : a.drillToByGroup(b))
        })
      },
      onClickDrillToNode: function(a) {
        var b =
          (a = a.point) && a.drillId;
        z(b) && (a.setState(""), this.drillToNode(b))
      },
      drillToByGroup: function(a) {
        var b = !1;
        1 !== a.node.level - this.nodeMap[this.rootNode].level || a.node.isLeaf || (b = a.id);
        return b
      },
      drillToByLeaf: function(a) {
        var b = !1;
        if (a.node.parent !== this.rootNode && a.node.isLeaf)
          for (a = a.node; !b;) a = this.nodeMap[a.parent], a.parent === this.rootNode && (b = a.id);
        return b
      },
      drillUp: function() {
        var a = this.nodeMap[this.rootNode];
        a && z(a.parent) && this.drillToNode(a.parent)
      },
      drillToNode: function(a, b) {
        var c = this.nodeMap[a];
        this.idPreviousRoot = this.rootNode;
        this.rootNode = a;
        "" === a ? this.drillUpButton = this.drillUpButton.destroy() : this.showDrillUpButton(c && c.name || a);
        this.isDirty = !0;
        v(b, !0) && this.chart.redraw()
      },
      showDrillUpButton: function(a) {
        var b = this;
        a = a || "\x3c Back";
        var d = b.options.drillUpButton,
          e, f;
        d.text && (a = d.text);
        this.drillUpButton ? (this.drillUpButton.placed = !1, this.drillUpButton.attr({
          text: a
        }).align()) : (f = (e = d.theme) && e.states, this.drillUpButton = this.chart.renderer.button(a, null, null, function() {
            b.drillUp()
          }, e, f &&
          f.hover, f && f.select).addClass("highcharts-drillup-button").attr({
          align: d.position.align,
          zIndex: 7
        }).add().align(d.position, !1, d.relativeTo || "plotBox"))
      },
      buildKDTree: A,
      drawLegendSymbol: b.LegendSymbolMixin.drawRectangle,
      getExtremes: function() {
        e.prototype.getExtremes.call(this, this.colorValueData);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        e.prototype.getExtremes.call(this)
      },
      getExtremesFromAll: !0,
      bindAxes: function() {
        var a = {
          endOnTick: !1,
          gridLineWidth: 0,
          lineWidth: 0,
          min: 0,
          dataMin: 0,
          minPadding: 0,
          max: 100,
          dataMax: 100,
          maxPadding: 0,
          startOnTick: !1,
          title: null,
          tickPositions: []
        };
        e.prototype.bindAxes.call(this);
        b.extend(this.yAxis.options, a);
        b.extend(this.xAxis.options, a)
      },
      utils: {
        recursive: B,
        reduce: D
      }
    }, {
      getClassName: function() {
        var a = b.Point.prototype.getClassName.call(this),
          c = this.series,
          d = c.options;
        this.node.level <= c.nodeMap[c.rootNode].level ? a += " highcharts-above-level" : this.node.isLeaf || v(d.interactByLeaf, !d.allowDrillToNode) ? this.node.isLeaf || (a += " highcharts-internal-node") : a += " highcharts-internal-node-interactive";
        return a
      },
      isValid: function() {
        return this.id || g(this.value)
      },
      setState: function(a) {
        b.Point.prototype.setState.call(this, a);
        this.graphic && this.graphic.attr({
          zIndex: "hover" === a ? 1 : 0
        })
      },
      setVisible: q.pie.prototype.pointClass.prototype.setVisible
    })
  })(x, F)
});;
/*! RESOURCE: /scripts/highcharts/modules/no-data-to-display.js */
(function(d) {
  "object" === typeof module && module.exports ? module.exports = d : d(Highcharts)
})(function(d) {
  (function(c) {
    var d = c.seriesTypes,
      e = c.Chart.prototype,
      f = c.getOptions(),
      g = c.extend,
      h = c.each;
    g(f.lang, {
      noData: "No data to display"
    });
    f.noData = {
      position: {
        x: 0,
        y: 0,
        align: "center",
        verticalAlign: "middle"
      }
    };
    f.noData.style = {
      fontWeight: "bold",
      fontSize: "12px",
      color: "#666666"
    };
    h("bubble gauge heatmap pie sankey treemap waterfall".split(" "), function(b) {
      d[b] && (d[b].prototype.hasData = function() {
        return !!this.points.length
      })
    });
    c.Series.prototype.hasData = function() {
      return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin
    };
    e.showNoData = function(b) {
      var a = this.options;
      b = b || a && a.lang.noData;
      a = a && a.noData;
      !this.noDataLabel && this.renderer && (this.noDataLabel = this.renderer.label(b, 0, 0, null, null, null, a.useHTML, null, "no-data"), this.noDataLabel.attr(a.attr).css(a.style), this.noDataLabel.add(), this.noDataLabel.align(g(this.noDataLabel.getBBox(), a.position), !1, "plotBox"))
    };
    e.hideNoData = function() {
      this.noDataLabel && (this.noDataLabel =
        this.noDataLabel.destroy())
    };
    e.hasData = function() {
      for (var b = this.series || [], a = b.length; a--;)
        if (b[a].hasData() && !b[a].options.isInternal) return !0;
      return this.loadingShown
    };
    c.addEvent(c.Chart, "render", function() {
      this.hasData() ? this.hideNoData() : this.showNoData()
    })
  })(d)
});;
/*! RESOURCE: /scripts/highcharts/modules/boost.js */
(function(t) {
  "object" === typeof module && module.exports ? module.exports = t : t(Highcharts)
})(function(t) {
  (function(h) {
    function t() {
      var a = Array.prototype.slice.call(arguments),
        c = -Number.MAX_VALUE;
      n(a, function(a) {
        if ("undefined" !== typeof a && null !== a && "undefined" !== typeof a.length && 0 < a.length) return c = a.length, !0
      });
      return c
    }

    function ba(a) {
      var c = 0,
        e = 0,
        f = I(a.options.boost && a.options.boost.allowForce, !0),
        b;
      if ("undefined" !== typeof a.boostForceChartBoost) return a.boostForceChartBoost;
      if (1 < a.series.length)
        for (var k =
            0; k < a.series.length; k++) b = a.series[k], K[b.type] && ++e, t(b.processedXData, b.options.data, b.points) >= (b.options.boostThreshold || Number.MAX_VALUE) && ++c;
      a.boostForceChartBoost = f && e === a.series.length && 0 < c || 5 < c;
      return a.boostForceChartBoost
    }

    function ja(a) {
      function c(b, d) {
        d = a.createShader("vertex" === d ? a.VERTEX_SHADER : a.FRAGMENT_SHADER);
        a.shaderSource(d, b);
        a.compileShader(d);
        return a.getShaderParameter(d, a.COMPILE_STATUS) ? d : !1
      }

      function e() {
        function b(b) {
          return a.getUniformLocation(k, b)
        }
        var e = c("#version 100\nprecision highp float;\nattribute vec4 aVertexPosition;\nattribute vec4 aColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform mat4 uPMatrix;\nuniform float pSize;\nuniform float translatedThreshold;\nuniform bool hasThreshold;\nuniform bool skipTranslation;\nuniform float plotHeight;\nuniform float xAxisTrans;\nuniform float xAxisMin;\nuniform float xAxisMinPad;\nuniform float xAxisPointRange;\nuniform float xAxisLen;\nuniform bool  xAxisPostTranslate;\nuniform float xAxisOrdinalSlope;\nuniform float xAxisOrdinalOffset;\nuniform float xAxisPos;\nuniform bool  xAxisCVSCoord;\nuniform float yAxisTrans;\nuniform float yAxisMin;\nuniform float yAxisMinPad;\nuniform float yAxisPointRange;\nuniform float yAxisLen;\nuniform bool  yAxisPostTranslate;\nuniform float yAxisOrdinalSlope;\nuniform float yAxisOrdinalOffset;\nuniform float yAxisPos;\nuniform bool  yAxisCVSCoord;\nuniform bool  isBubble;\nuniform bool  bubbleSizeByArea;\nuniform float bubbleZMin;\nuniform float bubbleZMax;\nuniform float bubbleZThreshold;\nuniform float bubbleMinSize;\nuniform float bubbleMaxSize;\nuniform bool  bubbleSizeAbs;\nuniform bool  isInverted;\nfloat bubbleRadius(){\nfloat value \x3d aVertexPosition.w;\nfloat zMax \x3d bubbleZMax;\nfloat zMin \x3d bubbleZMin;\nfloat radius \x3d 0.0;\nfloat pos \x3d 0.0;\nfloat zRange \x3d zMax - zMin;\nif (bubbleSizeAbs){\nvalue \x3d value - bubbleZThreshold;\nzMax \x3d max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);\nzMin \x3d 0.0;\n}\nif (value \x3c zMin){\nradius \x3d bubbleZMin / 2.0 - 1.0;\n} else {\npos \x3d zRange \x3e 0.0 ? (value - zMin) / zRange : 0.5;\nif (bubbleSizeByArea \x26\x26 pos \x3e 0.0){\npos \x3d sqrt(pos);\n}\nradius \x3d ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;\n}\nreturn radius * 2.0;\n}\nfloat translate(float val,\nfloat pointPlacement,\nfloat localA,\nfloat localMin,\nfloat minPixelPadding,\nfloat pointRange,\nfloat len,\nbool  cvsCoord\n){\nfloat sign \x3d 1.0;\nfloat cvsOffset \x3d 0.0;\nif (cvsCoord) {\nsign *\x3d -1.0;\ncvsOffset \x3d len;\n}\nreturn sign * (val - localMin) * localA + cvsOffset + \n(sign * minPixelPadding);\n}\nfloat xToPixels(float value){\nif (skipTranslation){\nreturn value;// + xAxisPos;\n}\nreturn translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord);// + xAxisPos;\n}\nfloat yToPixels(float value, float checkTreshold){\nfloat v;\nif (skipTranslation){\nv \x3d value;// + yAxisPos;\n} else {\nv \x3d translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord);// + yAxisPos;\nif (v \x3e plotHeight) {\nv \x3d plotHeight;\n}\n}\nif (checkTreshold \x3e 0.0 \x26\x26 hasThreshold) {\nv \x3d min(v, translatedThreshold);\n}\nreturn v;\n}\nvoid main(void) {\nif (isBubble){\ngl_PointSize \x3d bubbleRadius();\n} else {\ngl_PointSize \x3d pSize;\n}\nvColor \x3d aColor;\nif (isInverted) {\ngl_Position \x3d uPMatrix * vec4(xToPixels(aVertexPosition.y) + yAxisPos, yToPixels(aVertexPosition.x, aVertexPosition.z) + xAxisPos, 0.0, 1.0);\n} else {\ngl_Position \x3d uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);\n}\n}",
            "vertex"),
          f = c("precision highp float;\nuniform vec4 fillColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform sampler2D uSampler;\nuniform bool isCircle;\nuniform bool hasColor;\nvoid main(void) {\nvec4 col \x3d fillColor;\nvec4 tcol;\nif (hasColor) {\ncol \x3d vColor;\n}\nif (isCircle) {\ntcol \x3d texture2D(uSampler, gl_PointCoord.st);\ncol *\x3d tcol;\nif (tcol.r \x3c 0.0) {\ndiscard;\n} else {\ngl_FragColor \x3d col;\n}\n} else {\ngl_FragColor \x3d col;\n}\n}", "fragment");
        if (!e || !f) return k = !1;
        k = a.createProgram();
        a.attachShader(k, e);
        a.attachShader(k, f);
        a.linkProgram(k);
        a.useProgram(k);
        a.bindAttribLocation(k, 0, "aVertexPosition");
        h = b("uPMatrix");
        l = b("pSize");
        N = b("fillColor");
        p = b("isBubble");
        g = b("bubbleSizeAbs");
        B = b("bubbleSizeByArea");
        v = b("uSampler");
        d = b("skipTranslation");
        m = b("isCircle");
        n = b("isInverted");
        E = b("plotHeight");
        return !0
      }

      function f(d, c) {
        d = b[d] = b[d] || a.getUniformLocation(k, d);
        a.uniform1f(d, c)
      }
      var b = {},
        k, h, l, N, p, g, B, d, m, n, E, v;
      a && e();
      return {
        psUniform: function() {
          return l
        },
        pUniform: function() {
          return h
        },
        fillColorUniform: function() {
          return N
        },
        setPlotHeight: function(b) {
          a.uniform1f(E, b)
        },
        setBubbleUniforms: function(b, d, c) {
          var e = b.options,
            k = Number.MAX_VALUE,
            h = -Number.MAX_VALUE;
          "bubble" === b.type && (k = I(e.zMin, Math.min(k, Math.max(d, !1 === e.displayNegative ? e.zThreshold : -Number.MAX_VALUE))), h = I(e.zMax, Math.max(h, c)), a.uniform1i(p, 1), a.uniform1i(m, 1), a.uniform1i(B, "width" !== b.options.sizeBy), a.uniform1i(g, b.options.sizeByAbsoluteValue), f("bubbleZMin", k), f("bubbleZMax", h), f("bubbleZThreshold",
            b.options.zThreshold), f("bubbleMinSize", b.minPxSize), f("bubbleMaxSize", b.maxPxSize))
        },
        bind: function() {
          a.useProgram(k)
        },
        program: function() {
          return k
        },
        create: e,
        setUniform: f,
        setPMatrix: function(b) {
          a.uniformMatrix4fv(h, !1, b)
        },
        setColor: function(b) {
          a.uniform4f(N, b[0] / 255, b[1] / 255, b[2] / 255, b[3])
        },
        setPointSize: function(b) {
          a.uniform1f(l, b)
        },
        setSkipTranslation: function(b) {
          a.uniform1i(d, !0 === b ? 1 : 0)
        },
        setTexture: function() {
          a.uniform1i(v, 0)
        },
        setDrawAsCircle: function(b) {
          a.uniform1i(m, b ? 1 : 0)
        },
        reset: function() {
          a.uniform1i(p,
            0);
          a.uniform1i(m, 0)
        },
        setInverted: function(b) {
          a.uniform1i(n, b)
        },
        destroy: function() {
          a && k && (a.deleteProgram(k), k = !1)
        }
      }
    }

    function T(a, c, e) {
      function f() {
        b && (a.deleteBuffer(b), k = b = !1);
        n = 0;
        h = e || 2;
        p = []
      }
      var b = !1,
        k = !1,
        h = e || 2,
        l = !1,
        n = 0,
        p;
      return {
        destroy: f,
        bind: function() {
          if (!b) return !1;
          a.vertexAttribPointer(k, h, a.FLOAT, !1, 0, 0)
        },
        data: p,
        build: function(e, B, d) {
          var g;
          p = e || [];
          if (!(p && 0 !== p.length || l)) return f(), !1;
          h = d || h;
          b && a.deleteBuffer(b);
          l || (g = new Float32Array(p));
          b = a.createBuffer();
          a.bindBuffer(a.ARRAY_BUFFER, b);
          a.bufferData(a.ARRAY_BUFFER, l || g, a.STATIC_DRAW);
          k = a.getAttribLocation(c.program(), B);
          a.enableVertexAttribArray(k);
          return !0
        },
        render: function(c, e, d) {
          var f = l ? l.length : p.length;
          if (!b || !f) return !1;
          if (!c || c > f || 0 > c) c = 0;
          if (!e || e > f) e = f;
          a.drawArrays(a[(d || "points").toUpperCase()], c / h, (e - c) / h);
          return !0
        },
        allocate: function(a) {
          n = -1;
          l = new Float32Array(4 * a)
        },
        push: function(a, b, d, c) {
          l && (l[++n] = a, l[++n] = b, l[++n] = d, l[++n] = c)
        }
      }
    }

    function la(a) {
      function c(a) {
        var b, d;
        return a.isSeriesBoosting ? (b = !!a.options.stacking, d = a.xData ||
          a.options.xData || a.processedXData, b = (b ? a.data : d || a.options.data).length, "treemap" === a.type ? b *= 12 : "heatmap" === a.type ? b *= 6 : K[a.type] && (b *= 2), b) : 0
      }

      function e() {
        d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT)
      }

      function f(a, b) {
        function d(a) {
          a && (b.colorData.push(a[0]), b.colorData.push(a[1]), b.colorData.push(a[2]), b.colorData.push(a[3]))
        }

        function c(a, b, c, e, f) {
          d(f);
          q.usePreallocated ? B.push(a, b, c ? 1 : 0, e || 1) : (E.push(a), E.push(b), E.push(c ? 1 : 0), E.push(e || 1))
        }

        function e() {
          b.segments.length && (b.segments[b.segments.length -
            1].to = E.length)
        }

        function f() {
          b.segments.length && b.segments[b.segments.length - 1].from === E.length || (e(), b.segments.push({
            from: E.length
          }))
        }

        function F(a, b, e, f, F) {
          d(F);
          c(a + e, b);
          d(F);
          c(a, b);
          d(F);
          c(a, b + f);
          d(F);
          c(a, b + f);
          d(F);
          c(a + e, b + f);
          d(F);
          c(a + e, b)
        }

        function Q(a) {
          q.useGPUTranslations || (b.skipTranslation = !0, a.x = ca.toPixels(a.x, !0), a.y = G.toPixels(a.y, !0));
          c(a.x, a.y, 0, 2)
        }
        var g = a.pointArrayMap && "low,high" === a.pointArrayMap.join(","),
          k = a.chart,
          l = a.options,
          v = !!l.stacking,
          p = l.data,
          m = a.xAxis.getExtremes(),
          x = m.min,
          m = m.max,
          w = a.yAxis.getExtremes(),
          z = w.min,
          w = w.max,
          t = a.xData || l.xData || a.processedXData,
          A = a.yData || l.yData || a.processedYData,
          D = a.zData || l.zData || a.processedZData,
          G = a.yAxis,
          ca = a.xAxis,
          I = a.chart.plotHeight,
          L = a.chart.plotWidth,
          W = !t || 0 === t.length,
          S = l.connectNulls,
          r = a.points || !1,
          N = !1,
          J = !1,
          y, U, V, p = v ? a.data : t || p,
          t = {
            x: -Number.MAX_VALUE,
            y: 0
          },
          H = {
            x: Number.MIN_VALUE,
            y: 0
          },
          O = 0,
          u, M, C = -1,
          Y = !1,
          Z = !1,
          aa, ka = "undefined" === typeof k.index,
          P = !1,
          X = !1,
          ba = K[a.type],
          T = !1,
          R = !0;
        if (!(l.boostData && 0 < l.boostData.length)) {
          k.inverted &&
            (I = a.chart.plotWidth, L = a.chart.plotHeight);
          a.closestPointRangePx = Number.MAX_VALUE;
          f();
          if (r && 0 < r.length) b.skipTranslation = !0, b.drawMode = "triangles", r[0].node && r[0].node.levelDynamic && r.sort(function(a, b) {
            if (a.node) {
              if (a.node.levelDynamic > b.node.levelDynamic) return 1;
              if (a.node.levelDynamic < b.node.levelDynamic) return -1
            }
            return 0
          }), n(r, function(b) {
            var d = b.plotY,
              c;
            "undefined" === typeof d || isNaN(d) || null === b.y || (d = b.shapeArgs, c = b.series.pointAttribs(b), b = c["stroke-width"] || 0, U = h.color(c.fill).rgba, U[0] /=
              255, U[1] /= 255, U[2] /= 255, "treemap" === a.type && (b = b || 1, V = h.color(c.stroke).rgba, V[0] /= 255, V[1] /= 255, V[2] /= 255, F(d.x, d.y, d.width, d.height, V), b /= 2), "heatmap" === a.type && k.inverted && (d.x = ca.len - d.x, d.y = G.len - d.y, d.width = -d.width, d.height = -d.height), F(d.x + b, d.y + b, d.width - 2 * b, d.height - 2 * b, U))
          });
          else {
            for (; C < p.length - 1;) {
              y = p[++C];
              if (ka) break;
              W ? (r = y[0], u = y[1], p[C + 1] && (Z = p[C + 1][0]), p[C - 1] && (Y = p[C - 1][0]), 3 <= y.length && (M = y[2], y[2] > b.zMax && (b.zMax = y[2]), y[2] < b.zMin && (b.zMin = y[2]))) : (r = y, u = A[C], p[C + 1] && (Z = p[C + 1]),
                p[C - 1] && (Y = p[C - 1]), D && D.length && (M = D[C], D[C] > b.zMax && (b.zMax = D[C]), D[C] < b.zMin && (b.zMin = D[C])));
              if (S || null !== r && null !== u) {
                if (Z && Z >= x && Z <= m && (P = !0), Y && Y >= x && Y <= m && (X = !0), g ? (W && (u = y.slice(1, 3)), aa = u[0], u = u[1]) : v && (r = y.x, u = y.stackY, aa = u - y.y), null !== z && "undefined" !== typeof z && null !== w && "undefined" !== typeof w && (R = u >= z && u <= w), r > m && H.x < m && (H.x = r, H.y = u), r < x && t.x < x && (t.x = r, t.y = u), null !== u || !S)
                  if (null !== u && R) {
                    if (r >= x && r <= m && (T = !0), T || P || X) {
                      q.useGPUTranslations || (b.skipTranslation = !0, r = ca.toPixels(r, !0), u = G.toPixels(u,
                        !0), u > I && (u = I), r > L && (r = L));
                      if (ba) {
                        y = aa;
                        if (!1 === aa || "undefined" === typeof aa) y = 0 > u ? u : 0;
                        q.useGPUTranslations || (y = G.toPixels(y, !0));
                        c(r, y, 0, 0, !1)
                      }
                      b.hasMarkers && !1 !== N && (a.closestPointRangePx = Math.min(a.closestPointRangePx, Math.abs(r - N)));
                      !q.useGPUTranslations && !q.usePreallocated && N && 1 > r - N && J && 1 > Math.abs(u - J) ? q.debug.showSkipSummary && ++O : (l.step && c(r, J, 0, 2, !1), c(r, u, 0, "bubble" === a.type ? M || 1 : 2, !1), N = r, J = u)
                    }
                  } else f()
              } else f()
            }
            q.debug.showSkipSummary && console.log("skipped points:", O);
            !N && !1 !== S && t > -Number.MAX_VALUE &&
              H < Number.MAX_VALUE && (Q(t), Q(H))
          }
          e()
        }
      }

      function b() {
        x = [];
        W.data = E = [];
        A = [];
        B && B.destroy()
      }

      function k(a) {
        g && (g.setUniform("xAxisTrans", a.transA), g.setUniform("xAxisMin", a.min), g.setUniform("xAxisMinPad", a.minPixelPadding), g.setUniform("xAxisPointRange", a.pointRange), g.setUniform("xAxisLen", a.len), g.setUniform("xAxisPos", a.pos), g.setUniform("xAxisCVSCoord", !a.horiz))
      }

      function v(a) {
        g && (g.setUniform("yAxisTrans", a.transA), g.setUniform("yAxisMin", a.min), g.setUniform("yAxisMinPad", a.minPixelPadding), g.setUniform("yAxisPointRange",
          a.pointRange), g.setUniform("yAxisLen", a.len), g.setUniform("yAxisPos", a.pos), g.setUniform("yAxisCVSCoord", !a.horiz))
      }

      function l(a, b) {
        g.setUniform("hasThreshold", a);
        g.setUniform("translatedThreshold", b)
      }

      function w(c) {
        if (c) m = c.chartWidth || 800, D = c.chartHeight || 400;
        else return !1;
        if (!d || !m || !D) return !1;
        q.debug.timeRendering && console.time("gl rendering");
        d.canvas.width = m;
        d.canvas.height = D;
        g.bind();
        d.viewport(0, 0, m, D);
        g.setPMatrix([2 / m, 0, 0, 0, 0, -(2 / D), 0, 0, 0, 0, -2, 0, -1, 1, -1, 1]);
        g.setPlotHeight(c.plotHeight);
        1 < q.lineWidth && !h.isMS && d.lineWidth(q.lineWidth);
        B.build(W.data, "aVertexPosition", 4);
        B.bind();
        t && (d.bindTexture(d.TEXTURE_2D, G), g.setTexture(G));
        g.setInverted(c.inverted);
        n(x, function(a, b) {
          var c = a.series.options,
            e;
          e = "undefined" !== typeof c.lineWidth ? c.lineWidth : 1;
          var f = c.threshold,
            F = H(f),
            p = a.series.yAxis.getThreshold(f),
            f = I(c.marker ? c.marker.enabled : null, a.series.xAxis.isRadial ? !0 : null, a.series.closestPointRangePx > 2 * ((c.marker ? c.marker.radius : 10) || 10)),
            m;
          m = a.series.pointAttribs && a.series.pointAttribs().fill ||
            a.series.color;
          c.colorByPoint && (m = a.series.chart.options.colors[b]);
          a.series.fillOpacity && c.fillOpacity && (m = (new R(m)).setOpacity(I(c.fillOpacity, 1)).get());
          m = h.color(m).rgba;
          q.useAlpha || (m[3] = 1);
          "lines" === a.drawMode && q.useAlpha && 1 > m[3] && (m[3] /= 10);
          "add" === c.boostBlending ? (d.blendFunc(d.SRC_ALPHA, d.ONE), d.blendEquation(d.FUNC_ADD)) : "mult" === c.boostBlending ? d.blendFunc(d.DST_COLOR, d.ZERO) : "darken" === c.boostBlending ? (d.blendFunc(d.ONE, d.ONE), d.blendEquation(d.FUNC_MIN)) : d.blendFuncSeparate(d.SRC_ALPHA,
            d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA);
          g.reset();
          0 < a.colorData.length && (g.setUniform("hasColor", 1), b = T(d, g), b.build(a.colorData, "aColor", 4), b.bind());
          g.setColor(m);
          k(a.series.xAxis);
          v(a.series.yAxis);
          l(F, p);
          "points" === a.drawMode && (c.marker && c.marker.radius ? g.setPointSize(2 * c.marker.radius) : g.setPointSize(1));
          g.setSkipTranslation(a.skipTranslation);
          "bubble" === a.series.type && g.setBubbleUniforms(a.series, a.zMin, a.zMax);
          g.setDrawAsCircle(J[a.series.type] && t || !1);
          if (0 < e || "line_strip" !== a.drawMode)
            for (e =
              0; e < a.segments.length; e++) B.render(a.segments[e].from, a.segments[e].to, a.drawMode);
          if (a.hasMarkers && f)
            for (c.marker && c.marker.radius ? g.setPointSize(2 * c.marker.radius) : g.setPointSize(10), g.setDrawAsCircle(!0), e = 0; e < a.segments.length; e++) B.render(a.segments[e].from, a.segments[e].to, "POINTS")
        });
        q.debug.timeRendering && console.timeEnd("gl rendering");
        a && a();
        b()
      }

      function p(a) {
        e();
        if (a.renderer.forExport) return w(a);
        S ? w(a) : setTimeout(function() {
          p(a)
        }, 1)
      }
      var g = !1,
        B = !1,
        d = !1,
        m = 0,
        D = 0,
        E = !1,
        A = !1,
        t = !1,
        W = {},
        S = !1,
        x = [],
        L = O.createElement("canvas"),
        z = L.getContext("2d"),
        G, K = {
          column: !0,
          columnrange: !0,
          bar: !0,
          area: !0,
          arearange: !0
        },
        J = {
          scatter: !0,
          bubble: !0
        },
        q = {
          pointSize: 1,
          lineWidth: 1,
          fillColor: "#AA00AA",
          useAlpha: !0,
          usePreallocated: !1,
          useGPUTranslations: !1,
          debug: {
            timeRendering: !1,
            timeSeriesProcessing: !1,
            timeSetup: !1,
            timeBufferCopy: !1,
            timeKDTree: !1,
            showSkipSummary: !1
          }
        };
      return W = {
        allocateBufferForSingleSeries: function(a) {
          var b = 0;
          q.usePreallocated && (a.isSeriesBoosting && (b = c(a)), B.allocate(b))
        },
        pushSeries: function(a) {
          0 <
            x.length && x[x.length - 1].hasMarkers && (x[x.length - 1].markerTo = A.length);
          q.debug.timeSeriesProcessing && console.time("building " + a.type + " series");
          x.push({
            segments: [],
            markerFrom: A.length,
            colorData: [],
            series: a,
            zMin: Number.MAX_VALUE,
            zMax: -Number.MAX_VALUE,
            hasMarkers: a.options.marker ? !1 !== a.options.marker.enabled : !1,
            showMarksers: !0,
            drawMode: {
              area: "lines",
              arearange: "lines",
              areaspline: "line_strip",
              column: "lines",
              columnrange: "lines",
              bar: "lines",
              line: "line_strip",
              scatter: "points",
              heatmap: "triangles",
              treemap: "triangles",
              bubble: "points"
            } [a.type] || "line_strip"
          });
          f(a, x[x.length - 1]);
          q.debug.timeSeriesProcessing && console.timeEnd("building " + a.type + " series")
        },
        setSize: function(a, b) {
          if (m !== a || b !== b) m = a, D = b, g.bind(), g.setPMatrix([2 / m, 0, 0, 0, 0, -(2 / D), 0, 0, 0, 0, -2, 0, -1, 1, -1, 1])
        },
        inited: function() {
          return S
        },
        setThreshold: l,
        init: function(a, c) {
          var e = 0,
            f = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
          S = !1;
          if (!a) return !1;
          for (q.debug.timeSetup && console.time("gl setup"); e < f.length && !(d = a.getContext(f[e], {})); e++);
          if (d) c || b();
          else return !1;
          d.enable(d.BLEND);
          d.blendFunc(d.SRC_ALPHA, d.ONE_MINUS_SRC_ALPHA);
          d.disable(d.DEPTH_TEST);
          d.depthFunc(d.LESS);
          g = ja(d);
          B = T(d, g);
          t = !1;
          G = d.createTexture();
          L.width = 512;
          L.height = 512;
          z.mozImageSmoothingEnabled = !1;
          z.webkitImageSmoothingEnabled = !1;
          z.msImageSmoothingEnabled = !1;
          z.imageSmoothingEnabled = !1;
          z.strokeStyle = "rgba(255, 255, 255, 0)";
          z.fillStyle = "#FFF";
          z.beginPath();
          z.arc(256, 256, 256, 0, 2 * Math.PI);
          z.stroke();
          z.fill();
          try {
            d.bindTexture(d.TEXTURE_2D, G), d.texImage2D(d.TEXTURE_2D, 0, d.RGBA,
              d.RGBA, d.UNSIGNED_BYTE, L), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.bindTexture(d.TEXTURE_2D, null), t = !0
          } catch (sa) {}
          S = !0;
          q.debug.timeSetup && console.timeEnd("gl setup");
          return !0
        },
        render: p,
        settings: q,
        valid: function() {
          return !1 !== d
        },
        clear: e,
        flush: b,
        setXAxis: k,
        setYAxis: v,
        data: E,
        gl: function() {
          return d
        },
        allocateBuffer: function(a) {
          var b = 0;
          q.usePreallocated && (n(a.series, function(a) {
            a.isSeriesBoosting && (b += c(a))
          }), B.allocate(b))
        },
        destroy: function() {
          b();
          B.destroy();
          g.destroy();
          d && (G && d.deleteTexture(G), d.canvas.width = 1, d.canvas.height = 1)
        },
        setOptions: function(a) {
          ma(!0, q, a)
        }
      }
    }

    function da(a, c) {
      var e = a.chartWidth,
        f = a.chartHeight,
        b = a,
        k = a.seriesGroup || c.group,
        n = O.implementation.hasFeature("www.http://w3.org/TR/SVG11/feature#Extensibility", "1.1"),
        b = a.isChartSeriesBoosting() ? a : c,
        n = !1;
      b.renderTarget || (b.canvas =
        na, a.renderer.forExport || !n ? (b.renderTarget = a.renderer.image("", 0, 0, e, f).addClass("highcharts-boost-canvas").add(k), b.boostClear = function() {
          b.renderTarget.attr({
            href: ""
          })
        }, b.boostCopy = function() {
          b.boostResizeTarget();
          b.renderTarget.attr({
            href: b.canvas.toDataURL("image/png")
          })
        }) : (b.renderTargetFo = a.renderer.createElement("foreignObject").add(k), b.renderTarget = O.createElement("canvas"), b.renderTargetCtx = b.renderTarget.getContext("2d"), b.renderTargetFo.element.appendChild(b.renderTarget), b.boostClear =
          function() {
            b.renderTarget.width = b.canvas.width;
            b.renderTarget.height = b.canvas.height
          }, b.boostCopy = function() {
            b.renderTarget.width = b.canvas.width;
            b.renderTarget.height = b.canvas.height;
            b.renderTargetCtx.drawImage(b.canvas, 0, 0)
          }), b.boostResizeTarget = function() {
          e = a.chartWidth;
          f = a.chartHeight;
          (b.renderTargetFo || b.renderTarget).attr({
            x: 0,
            y: 0,
            width: e,
            height: f
          }).css({
            pointerEvents: "none",
            mixedBlendMode: "normal",
            opacity: 1
          });
          b instanceof h.Chart && b.markerGroup.translate(a.plotLeft, a.plotTop)
        }, b.boostClipRect =
        a.renderer.clipRect(), (b.renderTargetFo || b.renderTarget).clip(b.boostClipRect), b instanceof h.Chart && (b.markerGroup = b.renderer.g().add(k), b.markerGroup.translate(c.xAxis.pos, c.yAxis.pos)));
      b.canvas.width = e;
      b.canvas.height = f;
      b.boostClipRect.attr(a.getBoostClipRect(b));
      b.boostResizeTarget();
      b.boostClear();
      b.ogl || (b.ogl = la(function() {
          b.ogl.settings.debug.timeBufferCopy && console.time("buffer copy");
          b.boostCopy();
          b.ogl.settings.debug.timeBufferCopy && console.timeEnd("buffer copy")
        }), b.ogl.init(b.canvas),
        b.ogl.setOptions(a.options.boost || {}), b instanceof h.Chart && b.ogl.allocateBuffer(a));
      b.ogl.setSize(e, f);
      return b.ogl
    }

    function ea(a, c, e) {
      a && c.renderTarget && c.canvas && !(e || c.chart).isChartSeriesBoosting() && a.render(e || c.chart)
    }

    function fa(a, c) {
      a && c.renderTarget && c.canvas && !c.chart.isChartSeriesBoosting() && a.allocateBufferForSingleSeries(c)
    }

    function oa(a) {
      var c = !0;
      this.chart.options && this.chart.options.boost && (c = "undefined" === typeof this.chart.options.boost.enabled ? !0 : this.chart.options.boost.enabled);
      if (!c || !this.isSeriesBoosting) return a.call(this);
      this.chart.isBoosting = !0;
      if (a = da(this.chart, this)) fa(a, this), a.pushSeries(this);
      ea(a, this)
    }
    var J = h.win,
      O = J.document,
      pa = function() {},
      ga = h.Chart,
      R = h.Color,
      v = h.Series,
      w = h.seriesTypes,
      n = h.each,
      ha = h.extend,
      M = h.addEvent,
      qa = h.fireEvent,
      ra = h.grep,
      H = h.isNumber,
      ma = h.merge,
      I = h.pick,
      A = h.wrap,
      P = h.getOptions().plotOptions,
      na = O.createElement("canvas"),
      X, ia = "area arearange column columnrange bar line scatter heatmap bubble treemap".split(" "),
      K = {};
    n(ia, function(a) {
      K[a] =
        1
    });
    R.prototype.names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dodgerblue: "#1e90ff",
      feldspar: "#d19275",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgrey: "#d3d3d3",
      lightgreen: "#90ee90",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslateblue: "#8470ff",
      lightslategray: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370d8",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#d87093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      violetred: "#d02090",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    ga.prototype.isChartSeriesBoosting = function() {
      return I(this.options.boost && this.options.boost.seriesThreshold, 50) <= this.series.length || ba(this)
    };
    ga.prototype.getBoostClipRect =
      function(a) {
        var c = {
          x: this.plotLeft,
          y: this.plotTop,
          width: this.plotWidth,
          height: this.plotHeight
        };
        a === this && n(this.yAxis, function(a) {
          c.y = Math.min(a.pos, c.y);
          c.height = Math.max(a.pos - this.plotTop + a.len, c.height)
        }, this);
        return c
      };
    h.eachAsync = function(a, c, e, f, b, k) {
      b = b || 0;
      f = f || 3E4;
      for (var n = b + f, l = !0; l && b < n && b < a.length;) l = c(a[b], b), ++b;
      l && (b < a.length ? k ? h.eachAsync(a, c, e, f, b, k) : J.requestAnimationFrame ? J.requestAnimationFrame(function() {
          h.eachAsync(a, c, e, f, b)
        }) : setTimeout(function() {
          h.eachAsync(a, c, e, f, b)
        }) :
        e && e())
    };
    v.prototype.getPoint = function(a) {
      var c = a,
        e = this.xData || this.options.xData || this.processedXData || !1;
      !a || a instanceof this.pointClass || (c = (new this.pointClass).init(this, this.options.data[a.i], e ? e[a.i] : void 0), c.category = c.x, c.dist = a.dist, c.distX = a.distX, c.plotX = a.plotX, c.plotY = a.plotY, c.index = a.i);
      return c
    };
    A(v.prototype, "searchPoint", function(a) {
      return this.getPoint(a.apply(this, [].slice.call(arguments, 1)))
    });
    M(v, "destroy", function() {
      var a = this,
        c = a.chart;
      c.markerGroup === a.markerGroup && (a.markerGroup =
        null);
      c.hoverPoints && (c.hoverPoints = ra(c.hoverPoints, function(c) {
        return c.series === a
      }));
      c.hoverPoint && c.hoverPoint.series === a && (c.hoverPoint = null)
    });
    A(v.prototype, "getExtremes", function(a) {
      if (!this.isSeriesBoosting || !this.hasExtremes || !this.hasExtremes()) return a.apply(this, Array.prototype.slice.call(arguments, 1))
    });
    n(ia, function(a) {
      P[a] && (P[a].boostThreshold = 5E3, P[a].boostData = [], w[a].prototype.fillOpacity = !0)
    });
    n(["translate", "generatePoints", "drawTracker", "drawPoints", "render"], function(a) {
      function c(c) {
        var e =
          this.options.stacking && ("translate" === a || "generatePoints" === a),
          b = I(this.chart && this.chart.options && this.chart.options.boost && this.chart.options.boost.enabled, !0);
        if (!this.isSeriesBoosting || e || !b || "heatmap" === this.type || "treemap" === this.type || !K[this.type]) c.call(this);
        else if (this[a + "Canvas"]) this[a + "Canvas"]()
      }
      A(v.prototype, a, c);
      "translate" === a && n("column bar arearange columnrange heatmap treemap".split(" "), function(e) {
        w[e] && A(w[e].prototype, a, c)
      })
    });
    A(v.prototype, "processData", function(a) {
      function c(a) {
        return e.chart.isChartSeriesBoosting() ||
          (a ? a.length : 0) >= (e.options.boostThreshold || Number.MAX_VALUE)
      }
      var e = this,
        f = this.options.data;
      K[this.type] ? (c(f) && "heatmap" !== this.type && "treemap" !== this.type && !this.options.stacking && this.hasExtremes && this.hasExtremes(!0) || (a.apply(this, Array.prototype.slice.call(arguments, 1)), f = this.processedXData), (this.isSeriesBoosting = c(f)) ? this.enterBoost() : this.exitBoost && this.exitBoost()) : a.apply(this, Array.prototype.slice.call(arguments, 1))
    });
    M(v, "hide", function() {
      this.canvas && this.renderTarget && (this.ogl &&
        this.ogl.clear(), this.boostClear())
    });
    v.prototype.enterBoost = function() {
      this.alteredByBoost = [];
      n(["allowDG", "directTouch", "stickyTracking"], function(a) {
        this.alteredByBoost.push({
          prop: a,
          val: this[a],
          own: this.hasOwnProperty(a)
        })
      }, this);
      this.directTouch = this.allowDG = !1;
      this.stickyTracking = !0;
      this.animate = null;
      this.labelBySeries && (this.labelBySeries = this.labelBySeries.destroy())
    };
    v.prototype.exitBoost = function() {
      n(this.alteredByBoost || [], function(a) {
        a.own ? this[a.prop] = a.val : delete this[a.prop]
      }, this);
      this.boostClear && this.boostClear()
    };
    v.prototype.hasExtremes = function(a) {
      var c = this.options,
        e = this.xAxis && this.xAxis.options,
        f = this.yAxis && this.yAxis.options;
      return c.data.length > (c.boostThreshold || Number.MAX_VALUE) && H(f.min) && H(f.max) && (!a || H(e.min) && H(e.max))
    };
    v.prototype.destroyGraphics = function() {
      var a = this,
        c = this.points,
        e, f;
      if (c)
        for (f = 0; f < c.length; f += 1)(e = c[f]) && e.destroyElements && e.destroyElements();
      n(["graph", "area", "tracker"], function(b) {
        a[b] && (a[b] = a[b].destroy())
      })
    };
    h.hasWebGLSupport = function() {
      var a =
        0,
        c, e = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"],
        f = !1;
      if ("undefined" !== typeof J.WebGLRenderingContext)
        for (c = O.createElement("canvas"); a < e.length; a++) try {
          if (f = c.getContext(e[a]), "undefined" !== typeof f && null !== f) return !0
        } catch (b) {}
      return !1
    };
    h.hasWebGLSupport() ? (h.extend(v.prototype, {
      renderCanvas: function() {
        function a(a, b) {
          var c, e, f = !1,
            g = "undefined" === typeof k.index,
            h = !0;
          if (!g && (M ? (c = a[0], e = a[1]) : (c = a, e = p[b]), L ? (M && (e = a.slice(1, 3)), f = e[0], e = e[1]) : z && (c = a.x, e = a.stackY, f = e - a.y), O || (h = e >= m &&
              e <= w), null !== e && c >= v && c <= d && h))
            if (a = Math.ceil(n.toPixels(c, !0)), I) {
              if (void 0 === Q || a === A) {
                L || (f = e);
                if (void 0 === K || e > F) F = e, K = b;
                if (void 0 === Q || f < q) q = f, Q = b
              }
              a !== A && (void 0 !== Q && (e = l.toPixels(F, !0), x = l.toPixels(q, !0), R(a, e, K), x !== e && R(a, x, Q)), Q = K = void 0, A = a)
            } else e = Math.ceil(l.toPixels(e, !0)), R(a, e, b);
          return !g
        }

        function c() {
          qa(e, "renderedCanvas");
          delete e.buildKDTree;
          e.buildKDTree();
          P.debug.timeKDTree && console.timeEnd("kd tree building")
        }
        var e = this,
          f = e.options || {},
          b = !1,
          k = e.chart,
          n = this.xAxis,
          l = this.yAxis,
          t = f.xData || e.processedXData,
          p = f.yData || e.processedYData,
          g = f.data,
          b = n.getExtremes(),
          v = b.min,
          d = b.max,
          b = l.getExtremes(),
          m = b.min,
          w = b.max,
          E = {},
          A, I = !!e.sampling,
          H, J = !1 !== f.enableMouseTracking,
          x = l.getThreshold(f.threshold),
          L = e.pointArrayMap && "low,high" === e.pointArrayMap.join(","),
          z = !!f.stacking,
          G = e.cropStart || 0,
          O = e.requireSorting,
          M = !t,
          q, F, Q, K, P, T = this.xData || this.options.xData || this.processedXData || !1,
          R = function(a, b, c) {
            X = a + "," + b;
            J && !E[X] && (E[X] = !0, k.inverted && (a = n.len - a, b = l.len - b), H.push({
              x: T ? T[G + c] : !1,
              clientX: a,
              plotX: a,
              plotY: b,
              i: G + c
            }))
          },
          b = da(k, e);
        k.isBoosting = !0;
        P = b.settings;
        if (this.visible) {
          if (this.points || this.graph) this.animate = null, this.destroyGraphics();
          k.isChartSeriesBoosting() ? (this.markerGroup = k.markerGroup, this.renderTarget && (this.renderTarget = this.renderTarget.destroy())) : this.markerGroup = e.plotGroup("markerGroup", "markers", !0, 1, k.seriesGroup);
          H = this.points = [];
          e.buildKDTree = pa;
          b && (fa(b, this), b.pushSeries(e), ea(b, this, k));
          k.renderer.forExport || (P.debug.timeKDTree && console.time("kd tree building"),
            h.eachAsync(z ? e.data : t || g, a, c))
        }
      }
    }), n(["heatmap", "treemap"], function(a) {
      w[a] && A(w[a].prototype, "drawPoints", oa)
    }), w.bubble && (delete w.bubble.prototype.buildKDTree, A(w.bubble.prototype, "markerAttribs", function(a) {
      return this.isSeriesBoosting ? !1 : a.apply(this, [].slice.call(arguments, 1))
    })), w.scatter.prototype.fill = !0, ha(w.area.prototype, {
      fill: !0,
      fillOpacity: !0,
      sampling: !0
    }), ha(w.column.prototype, {
      fill: !0,
      sampling: !0
    }), h.Chart.prototype.callbacks.push(function(a) {
      M(a, "predraw", function() {
        a.boostForceChartBoost =
          void 0;
        a.boostForceChartBoost = ba(a);
        a.isBoosting = !1;
        !a.isChartSeriesBoosting() && a.didBoost && (a.didBoost = !1);
        a.boostClear && a.boostClear();
        a.canvas && a.ogl && a.isChartSeriesBoosting() && (a.didBoost = !0, a.ogl.allocateBuffer(a));
        a.markerGroup && a.xAxis && 0 < a.xAxis.length && a.yAxis && 0 < a.yAxis.length && a.markerGroup.translate(a.xAxis[0].pos, a.yAxis[0].pos)
      });
      M(a, "render", function() {
        a.ogl && a.isChartSeriesBoosting() && a.ogl.render(a)
      })
    })) : "undefined" !== typeof h.initCanvasBoost ? h.initCanvasBoost() : h.error(26)
  })(t)
});;
/*! RESOURCE: /scripts/highcharts/modules/map.js */
(function(x) {
  "object" === typeof module && module.exports ? module.exports = x : x(Highcharts)
})(function(x) {
  (function(a) {
    var l = a.addEvent,
      h = a.Axis,
      k = a.each,
      f = a.pick;
    l(h, "getSeriesExtremes", function() {
      var a = [];
      this.isXAxis && (k(this.series, function(q, f) {
        q.useMapGeometry && (a[f] = q.xData, q.xData = [])
      }), this.seriesXData = a)
    });
    l(h, "afterGetSeriesExtremes", function() {
      var a = this.seriesXData,
        g, h, t;
      this.isXAxis && (g = f(this.dataMin, Number.MAX_VALUE), h = f(this.dataMax, -Number.MAX_VALUE), k(this.series, function(e, b) {
        e.useMapGeometry &&
          (g = Math.min(g, f(e.minX, g)), h = Math.max(h, f(e.maxX, h)), e.xData = a[b], t = !0)
      }), t && (this.dataMin = g, this.dataMax = h), delete this.seriesXData)
    });
    l(h, "afterSetAxisTranslation", function() {
      var a = this.chart,
        g;
      g = a.plotWidth / a.plotHeight;
      var a = a.xAxis[0],
        f;
      "yAxis" === this.coll && void 0 !== a.transA && k(this.series, function(a) {
        a.preserveAspectRatio && (f = !0)
      });
      if (f && (this.transA = a.transA = Math.min(this.transA, a.transA), g /= (a.max - a.min) / (this.max - this.min), g = 1 > g ? this : a, a = (g.max - g.min) * g.transA, g.pixelPadding = g.len - a, g.minPixelPadding =
          g.pixelPadding / 2, a = g.fixTo)) {
        a = a[1] - g.toValue(a[0], !0);
        a *= g.transA;
        if (Math.abs(a) > g.minPixelPadding || g.min === g.dataMin && g.max === g.dataMax) a = 0;
        g.minPixelPadding -= a
      }
    });
    l(h, "render", function() {
      this.fixTo = null
    })
  })(x);
  (function(a) {
    var l = a.addEvent,
      h = a.Axis,
      k = a.Chart,
      f = a.color,
      q, g = a.each,
      u = a.extend,
      t = a.isNumber,
      e = a.Legend,
      b = a.LegendSymbolMixin,
      d = a.noop,
      n = a.merge,
      r = a.pick;
    a.ColorAxis || (q = a.ColorAxis = function() {
      this.init.apply(this, arguments)
    }, u(q.prototype, h.prototype), u(q.prototype, {
      defaultColorAxisOptions: {
        lineWidth: 0,
        minPadding: 0,
        maxPadding: 0,
        gridLineWidth: 1,
        tickPixelInterval: 72,
        startOnTick: !0,
        endOnTick: !0,
        offset: 0,
        marker: {
          animation: {
            duration: 50
          },
          width: .01,
          color: "#999999"
        },
        labels: {
          overflow: "justify",
          rotation: 0
        },
        minColor: "#e6ebf5",
        maxColor: "#003399",
        tickLength: 5,
        showInLegend: !0
      },
      keepProps: ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"].concat(h.prototype.keepProps),
      init: function(a, b) {
        var c = "vertical" !== a.options.legend.layout,
          m;
        this.coll = "colorAxis";
        m = n(this.defaultColorAxisOptions, {
          side: c ? 2 : 1,
          reversed: !c
        }, b, {
          opposite: !c,
          showEmpty: !1,
          title: null,
          visible: a.options.legend.enabled
        });
        h.prototype.init.call(this, a, m);
        b.dataClasses && this.initDataClasses(b);
        this.initStops();
        this.horiz = c;
        this.zoomEnabled = !1;
        this.defaultLegendLength = 200
      },
      initDataClasses: function(a) {
        var b = this.chart,
          c, m = 0,
          d = b.options.chart.colorCount,
          e = this.options,
          y = a.dataClasses.length;
        this.dataClasses = c = [];
        this.legendItems = [];
        g(a.dataClasses, function(a, p) {
          a = n(a);
          c.push(a);
          a.color || ("category" === e.dataClassColor ? (p = b.options.colors,
            d = p.length, a.color = p[m], a.colorIndex = m, m++, m === d && (m = 0)) : a.color = f(e.minColor).tweenTo(f(e.maxColor), 2 > y ? .5 : p / (y - 1)))
        })
      },
      setTickPositions: function() {
        if (!this.dataClasses) return h.prototype.setTickPositions.call(this)
      },
      initStops: function() {
        this.stops = this.options.stops || [
          [0, this.options.minColor],
          [1, this.options.maxColor]
        ];
        g(this.stops, function(a) {
          a.color = f(a[1])
        })
      },
      setOptions: function(a) {
        h.prototype.setOptions.call(this, a);
        this.options.crosshair = this.options.marker
      },
      setAxisSize: function() {
        var a = this.legendSymbol,
          b = this.chart,
          c = b.options.legend || {},
          p, d;
        a ? (this.left = c = a.attr("x"), this.top = p = a.attr("y"), this.width = d = a.attr("width"), this.height = a = a.attr("height"), this.right = b.chartWidth - c - d, this.bottom = b.chartHeight - p - a, this.len = this.horiz ? d : a, this.pos = this.horiz ? c : p) : this.len = (this.horiz ? c.symbolWidth : c.symbolHeight) || this.defaultLegendLength
      },
      normalizedValue: function(a) {
        this.isLog && (a = this.val2lin(a));
        return 1 - (this.max - a) / (this.max - this.min || 1)
      },
      toColor: function(a, b) {
        var c = this.stops,
          p, m, v = this.dataClasses,
          d, e;
        if (v)
          for (e = v.length; e--;) {
            if (d = v[e], p = d.from, c = d.to, (void 0 === p || a >= p) && (void 0 === c || a <= c)) {
              m = d.color;
              b && (b.dataClass = e, b.colorIndex = d.colorIndex);
              break
            }
          } else {
            a = this.normalizedValue(a);
            for (e = c.length; e-- && !(a > c[e][0]););
            p = c[e] || c[e + 1];
            c = c[e + 1] || p;
            a = 1 - (c[0] - a) / (c[0] - p[0] || 1);
            m = p.color.tweenTo(c.color, a)
          }
        return m
      },
      getOffset: function() {
        var a = this.legendGroup,
          b = this.chart.axisOffset[this.side];
        a && (this.axisParent = a, h.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight =
          this.width), this.chart.axisOffset[this.side] = b)
      },
      setLegendColor: function() {
        var a, b = this.reversed;
        a = b ? 1 : 0;
        b = b ? 0 : 1;
        a = this.horiz ? [a, 0, b, 0] : [0, b, 0, a];
        this.legendColor = {
          linearGradient: {
            x1: a[0],
            y1: a[1],
            x2: a[2],
            y2: a[3]
          },
          stops: this.stops
        }
      },
      drawLegendSymbol: function(a, b) {
        var c = a.padding,
          p = a.options,
          d = this.horiz,
          m = r(p.symbolWidth, d ? this.defaultLegendLength : 12),
          v = r(p.symbolHeight, d ? 12 : this.defaultLegendLength),
          e = r(p.labelPadding, d ? 16 : 30),
          p = r(p.itemDistance, 10);
        this.setLegendColor();
        b.legendSymbol = this.chart.renderer.rect(0,
          a.baseline - 11, m, v).attr({
          zIndex: 1
        }).add(b.legendGroup);
        this.legendItemWidth = m + c + (d ? p : e);
        this.legendItemHeight = v + c + (d ? e : 0)
      },
      setState: function(a) {
        g(this.series, function(b) {
          b.setState(a)
        })
      },
      visible: !0,
      setVisible: d,
      getSeriesExtremes: function() {
        var a = this.series,
          b = a.length;
        this.dataMin = Infinity;
        for (this.dataMax = -Infinity; b--;) void 0 !== a[b].valueMin && (this.dataMin = Math.min(this.dataMin, a[b].valueMin), this.dataMax = Math.max(this.dataMax, a[b].valueMax))
      },
      drawCrosshair: function(a, b) {
        var c = b && b.plotX,
          p = b && b.plotY,
          d, e = this.pos,
          m = this.len;
        b && (d = this.toPixels(b[b.series.colorKey]), d < e ? d = e - 2 : d > e + m && (d = e + m + 2), b.plotX = d, b.plotY = this.len - d, h.prototype.drawCrosshair.call(this, a, b), b.plotX = c, b.plotY = p, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.cross.attr({
          fill: this.crosshair.color
        })))
      },
      getPlotLinePath: function(a, b, c, d, e) {
        return t(e) ? this.horiz ? ["M", e - 4, this.top - 6, "L", e + 4, this.top - 6, e, this.top,
          "Z"
        ] : ["M", this.left, e, "L", this.left - 6, e + 6, this.left - 6, e - 6, "Z"] : h.prototype.getPlotLinePath.call(this, a, b, c, d)
      },
      update: function(a, b) {
        var c = this.chart,
          d = c.legend;
        g(this.series, function(a) {
          a.isDirtyData = !0
        });
        a.dataClasses && d.allItems && (g(d.allItems, function(a) {
          a.isDataClass && a.legendGroup && a.legendGroup.destroy()
        }), c.isDirtyLegend = !0);
        c.options[this.coll] = n(this.userOptions, a);
        h.prototype.update.call(this, a, b);
        this.legendItem && (this.setLegendColor(), d.colorizeItem(this, !0))
      },
      remove: function() {
        this.legendItem &&
          this.chart.legend.destroyItem(this);
        h.prototype.remove.call(this)
      },
      getDataClassLegendSymbols: function() {
        var e = this,
          v = this.chart,
          c = this.legendItems,
          p = v.options.legend,
          n = p.valueDecimals,
          r = p.valueSuffix || "",
          y;
        c.length || g(this.dataClasses, function(p, m) {
          var w = !0,
            f = p.from,
            q = p.to;
          y = "";
          void 0 === f ? y = "\x3c " : void 0 === q && (y = "\x3e ");
          void 0 !== f && (y += a.numberFormat(f, n) + r);
          void 0 !== f && void 0 !== q && (y += " - ");
          void 0 !== q && (y += a.numberFormat(q, n) + r);
          c.push(u({
            chart: v,
            name: y,
            options: {},
            drawLegendSymbol: b.drawRectangle,
            visible: !0,
            setState: d,
            isDataClass: !0,
            setVisible: function() {
              w = this.visible = !w;
              g(e.series, function(a) {
                g(a.points, function(a) {
                  a.dataClass === m && a.setVisible(w)
                })
              });
              v.legend.colorizeItem(this, w)
            }
          }, p))
        });
        return c
      },
      name: ""
    }), g(["fill", "stroke"], function(b) {
      a.Fx.prototype[b + "Setter"] = function() {
        this.elem.attr(b, f(this.start).tweenTo(f(this.end), this.pos), null, !0)
      }
    }), l(k, "afterGetAxes", function() {
      var a = this.options.colorAxis;
      this.colorAxis = [];
      a && new q(this, a)
    }), l(e, "afterGetAllItems", function(b) {
      var d = [],
        c = this.chart.colorAxis[0];
      c && c.options && (c.options.showInLegend && (c.options.dataClasses ? d = c.getDataClassLegendSymbols() : d.push(c)), g(c.series, function(c) {
        a.erase(b.allItems, c)
      }));
      for (; d.length;) b.allItems.unshift(d.pop())
    }), l(e, "afterColorizeItem", function(a) {
      a.visible && a.item.legendColor && a.item.legendSymbol.attr({
        fill: a.item.legendColor
      })
    }), l(e, "afterUpdate", function(a, b, c) {
      this.chart.colorAxis[0] && this.chart.colorAxis[0].update({}, c)
    }))
  })(x);
  (function(a) {
    var l = a.defined,
      h = a.each,
      k = a.noop,
      f = a.seriesTypes;
    a.colorPointMixin = {
      isValid: function() {
        return null !== this.value && Infinity !== this.value && -Infinity !== this.value
      },
      setVisible: function(a) {
        var f = this,
          q = a ? "show" : "hide";
        h(["graphic", "dataLabel"], function(a) {
          if (f[a]) f[a][q]()
        })
      },
      setState: function(f) {
        a.Point.prototype.setState.call(this, f);
        this.graphic && this.graphic.attr({
          zIndex: "hover" === f ? 1 : 0
        })
      }
    };
    a.colorSeriesMixin = {
      pointArrayMap: ["value"],
      axisTypes: ["xAxis", "yAxis", "colorAxis"],
      optionalAxis: "colorAxis",
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      getSymbol: k,
      parallelArrays: ["x", "y", "value"],
      colorKey: "value",
      pointAttribs: f.column.prototype.pointAttribs,
      translateColors: function() {
        var a = this,
          f = this.options.nullColor,
          k = this.colorAxis,
          l = this.colorKey;
        h(this.data, function(e) {
          var b = e[l];
          if (b = e.options.color || (e.isNull ? f : k && void 0 !== b ? k.toColor(b, e) : e.color || a.color)) e.color = b
        })
      },
      colorAttribs: function(a) {
        var f = {};
        l(a.color) && (f[this.colorProp || "fill"] = a.color);
        return f
      }
    }
  })(x);
  (function(a) {
    function l(a) {
      a && (a.preventDefault && a.preventDefault(), a.stopPropagation &&
        a.stopPropagation(), a.cancelBubble = !0)
    }

    function h(a) {
      this.init(a)
    }
    var k = a.addEvent,
      f = a.Chart,
      q = a.doc,
      g = a.each,
      u = a.extend,
      t = a.merge,
      e = a.pick;
    h.prototype.init = function(a) {
      this.chart = a;
      a.mapNavButtons = []
    };
    h.prototype.update = function(b) {
      var d = this.chart,
        n = d.options.mapNavigation,
        f, m, v, c, p, w = function(a) {
          this.handler.call(d, a);
          l(a)
        },
        q = d.mapNavButtons;
      b && (n = d.options.mapNavigation = t(d.options.mapNavigation, b));
      for (; q.length;) q.pop().destroy();
      e(n.enableButtons, n.enabled) && !d.renderer.forExport && a.objectEach(n.buttons,
        function(a, b) {
          f = t(n.buttonOptions, a);
          m = f.theme;
          m.style = t(f.theme.style, f.style);
          c = (v = m.states) && v.hover;
          p = v && v.select;
          a = d.renderer.button(f.text, 0, 0, w, m, c, p, 0, "zoomIn" === b ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation").attr({
            width: f.width,
            height: f.height,
            title: d.options.lang[b],
            padding: f.padding,
            zIndex: 5
          }).add();
          a.handler = f.onclick;
          a.align(u(f, {
            width: a.width,
            height: 2 * a.height
          }), null, f.alignTo);
          k(a.element, "dblclick", l);
          q.push(a)
        });
      this.updateEvents(n)
    };
    h.prototype.updateEvents =
      function(a) {
        var b = this.chart;
        e(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || k(b.container, "dblclick", function(a) {
          b.pointer.onContainerDblClick(a)
        }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
        e(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || k(b.container, void 0 === q.onmousewheel ? "DOMMouseScroll" : "mousewheel", function(a) {
            b.pointer.onContainerMouseWheel(a);
            l(a);
            return !1
          }) : this.unbindMouseWheel &&
          (this.unbindMouseWheel = this.unbindMouseWheel())
      };
    u(f.prototype, {
      fitToBox: function(a, d) {
        g([
          ["x", "width"],
          ["y", "height"]
        ], function(b) {
          var e = b[0];
          b = b[1];
          a[e] + a[b] > d[e] + d[b] && (a[b] > d[b] ? (a[b] = d[b], a[e] = d[e]) : a[e] = d[e] + d[b] - a[b]);
          a[b] > d[b] && (a[b] = d[b]);
          a[e] < d[e] && (a[e] = d[e])
        });
        return a
      },
      mapZoom: function(a, d, f, q, m) {
        var b = this.xAxis[0],
          c = b.max - b.min,
          p = e(d, b.min + c / 2),
          w = c * a,
          c = this.yAxis[0],
          n = c.max - c.min,
          g = e(f, c.min + n / 2),
          n = n * a,
          p = this.fitToBox({
            x: p - w * (q ? (q - b.pos) / b.len : .5),
            y: g - n * (m ? (m - c.pos) / c.len : .5),
            width: w,
            height: n
          }, {
            x: b.dataMin,
            y: c.dataMin,
            width: b.dataMax - b.dataMin,
            height: c.dataMax - c.dataMin
          }),
          w = p.x <= b.dataMin && p.width >= b.dataMax - b.dataMin && p.y <= c.dataMin && p.height >= c.dataMax - c.dataMin;
        q && (b.fixTo = [q - b.pos, d]);
        m && (c.fixTo = [m - c.pos, f]);
        void 0 === a || w ? (b.setExtremes(void 0, void 0, !1), c.setExtremes(void 0, void 0, !1)) : (b.setExtremes(p.x, p.x + p.width, !1), c.setExtremes(p.y, p.y + p.height, !1));
        this.redraw()
      }
    });
    k(f, "beforeRender", function() {
      this.mapNavigation = new h(this);
      this.mapNavigation.update()
    })
  })(x);
  (function(a) {
    var l =
      a.extend,
      h = a.pick,
      k = a.Pointer;
    a = a.wrap;
    l(k.prototype, {
      onContainerDblClick: function(a) {
        var f = this.chart;
        a = this.normalize(a);
        f.options.mapNavigation.enableDoubleClickZoomTo ? f.pointer.inClass(a.target, "highcharts-tracker") && f.hoverPoint && f.hoverPoint.zoomTo() : f.isInsidePlot(a.chartX - f.plotLeft, a.chartY - f.plotTop) && f.mapZoom(.5, f.xAxis[0].toValue(a.chartX), f.yAxis[0].toValue(a.chartY), a.chartX, a.chartY)
      },
      onContainerMouseWheel: function(a) {
        var f = this.chart,
          g;
        a = this.normalize(a);
        g = a.detail || -(a.wheelDelta /
          120);
        f.isInsidePlot(a.chartX - f.plotLeft, a.chartY - f.plotTop) && f.mapZoom(Math.pow(f.options.mapNavigation.mouseWheelSensitivity, g), f.xAxis[0].toValue(a.chartX), f.yAxis[0].toValue(a.chartY), a.chartX, a.chartY)
      }
    });
    a(k.prototype, "zoomOption", function(a) {
      var f = this.chart.options.mapNavigation;
      h(f.enableTouchZoom, f.enabled) && (this.chart.options.chart.pinchType = "xy");
      a.apply(this, [].slice.call(arguments, 1))
    });
    a(k.prototype, "pinchTranslate", function(a, h, g, k, l, e, b) {
      a.call(this, h, g, k, l, e, b);
      "map" === this.chart.options.chart.type &&
        this.hasZoom && (a = k.scaleX > k.scaleY, this.pinchTranslateDirection(!a, h, g, k, l, e, b, a ? k.scaleX : k.scaleY))
    })
  })(x);
  (function(a) {
    var l = a.colorPointMixin,
      h = a.each,
      k = a.extend,
      f = a.isNumber,
      q = a.map,
      g = a.merge,
      u = a.noop,
      t = a.pick,
      e = a.isArray,
      b = a.Point,
      d = a.Series,
      n = a.seriesType,
      r = a.seriesTypes,
      m = a.splat,
      v = void 0 !== a.doc.documentElement.style.vectorEffect;
    n("map", "scatter", {
      allAreas: !0,
      animation: !1,
      nullColor: "#f7f7f7",
      borderColor: "#cccccc",
      borderWidth: 1,
      marker: null,
      stickyTracking: !1,
      joinBy: "hc-key",
      dataLabels: {
        formatter: function() {
          return this.point.value
        },
        inside: !0,
        verticalAlign: "middle",
        crop: !1,
        overflow: !1,
        padding: 0
      },
      turboThreshold: 0,
      tooltip: {
        followPointer: !0,
        pointFormat: "{point.name}: {point.value}\x3cbr/\x3e"
      },
      states: {
        normal: {
          animation: !0
        },
        hover: {
          halo: null,
          brightness: .2
        },
        select: {
          color: "#cccccc"
        }
      }
    }, g(a.colorSeriesMixin, {
      type: "map",
      getExtremesFromAll: !0,
      useMapGeometry: !0,
      forceDL: !0,
      searchPoint: u,
      directTouch: !0,
      preserveAspectRatio: !0,
      pointArrayMap: ["value"],
      getBox: function(c) {
        var b = Number.MAX_VALUE,
          d = -b,
          e = b,
          m = -b,
          v = b,
          n = b,
          g = this.xAxis,
          k = this.yAxis,
          q;
        h(c || [], function(c) {
          if (c.path) {
            "string" === typeof c.path && (c.path = a.splitPath(c.path));
            var p = c.path || [],
              w = p.length,
              g = !1,
              h = -b,
              k = b,
              y = -b,
              r = b,
              A = c.properties;
            if (!c._foundBox) {
              for (; w--;) f(p[w]) && (g ? (h = Math.max(h, p[w]), k = Math.min(k, p[w])) : (y = Math.max(y, p[w]), r = Math.min(r, p[w])), g = !g);
              c._midX = k + (h - k) * t(c.middleX, A && A["hc-middle-x"], .5);
              c._midY = r + (y - r) * t(c.middleY, A && A["hc-middle-y"], .5);
              c._maxX = h;
              c._minX = k;
              c._maxY = y;
              c._minY = r;
              c.labelrank = t(c.labelrank, (h - k) * (y - r));
              c._foundBox = !0
            }
            d = Math.max(d, c._maxX);
            e = Math.min(e,
              c._minX);
            m = Math.max(m, c._maxY);
            v = Math.min(v, c._minY);
            n = Math.min(c._maxX - c._minX, c._maxY - c._minY, n);
            q = !0
          }
        });
        q && (this.minY = Math.min(v, t(this.minY, b)), this.maxY = Math.max(m, t(this.maxY, -b)), this.minX = Math.min(e, t(this.minX, b)), this.maxX = Math.max(d, t(this.maxX, -b)), g && void 0 === g.options.minRange && (g.minRange = Math.min(5 * n, (this.maxX - this.minX) / 5, g.minRange || b)), k && void 0 === k.options.minRange && (k.minRange = Math.min(5 * n, (this.maxY - this.minY) / 5, k.minRange || b)))
      },
      getExtremes: function() {
        d.prototype.getExtremes.call(this,
          this.valueData);
        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        this.dataMin = this.minY;
        this.dataMax = this.maxY
      },
      translatePath: function(a) {
        var c = !1,
          b = this.xAxis,
          d = this.yAxis,
          e = b.min,
          m = b.transA,
          b = b.minPixelPadding,
          v = d.min,
          n = d.transA,
          d = d.minPixelPadding,
          g, h = [];
        if (a)
          for (g = a.length; g--;) f(a[g]) ? (h[g] = c ? (a[g] - e) * m + b : (a[g] - v) * n + d, c = !c) : h[g] = a[g];
        return h
      },
      setData: function(c, b, v, n) {
        var p = this.options,
          w = this.chart.options.chart,
          k = w && w.map,
          r = p.mapData,
          l = p.joinBy,
          t = null === l,
          B = p.keys || this.pointArrayMap,
          u = [],
          x = {},
          z = this.chart.mapTransforms;
        !r && k && (r = "string" === typeof k ? a.maps[k] : k);
        t && (l = "_i");
        l = this.joinBy = m(l);
        l[1] || (l[1] = l[0]);
        c && h(c, function(b, d) {
          var m = 0;
          if (f(b)) c[d] = {
            value: b
          };
          else if (e(b)) {
            c[d] = {};
            !p.keys && b.length > B.length && "string" === typeof b[0] && (c[d]["hc-key"] = b[0], ++m);
            for (var v = 0; v < B.length; ++v, ++m) B[v] && void 0 !== b[m] && (0 < B[v].indexOf(".") ? a.Point.prototype.setNestedProperty(c[d], b[m], B[v]) : c[d][B[v]] = b[m])
          }
          t && (c[d]._i =
            d)
        });
        this.getBox(c);
        (this.chart.mapTransforms = z = w && w.mapTransforms || r && r["hc-transform"] || z) && a.objectEach(z, function(a) {
          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation))
        });
        if (r) {
          "FeatureCollection" === r.type && (this.mapTitle = r.title, r = a.geojson(r, this.type, this));
          this.mapData = r;
          this.mapMap = {};
          for (z = 0; z < r.length; z++) w = r[z], k = w.properties, w._i = z, l[0] && k && k[l[0]] && (w[l[0]] = k[l[0]]), x[w[l[0]]] = w;
          this.mapMap = x;
          c && l[1] && h(c, function(a) {
            x[a[l[1]]] && u.push(x[a[l[1]]])
          });
          p.allAreas ?
            (this.getBox(r), c = c || [], l[1] && h(c, function(a) {
              u.push(a[l[1]])
            }), u = "|" + q(u, function(a) {
              return a && a[l[0]]
            }).join("|") + "|", h(r, function(a) {
              l[0] && -1 !== u.indexOf("|" + a[l[0]] + "|") || (c.push(g(a, {
                value: null
              })), n = !1)
            })) : this.getBox(u)
        }
        d.prototype.setData.call(this, c, b, v, n)
      },
      drawGraph: u,
      drawDataLabels: u,
      doFullTranslate: function() {
        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans
      },
      translate: function() {
        var a = this,
          b = a.xAxis,
          d = a.yAxis,
          e = a.doFullTranslate();
        a.generatePoints();
        h(a.data, function(c) {
          c.plotX = b.toPixels(c._midX, !0);
          c.plotY = d.toPixels(c._midY, !0);
          e && (c.shapeType = "path", c.shapeArgs = {
            d: a.translatePath(c.path)
          })
        });
        a.translateColors()
      },
      pointAttribs: function(a, b) {
        a = r.column.prototype.pointAttribs.call(this, a, b);
        v ? a["vector-effect"] = "non-scaling-stroke" : a["stroke-width"] = "inherit";
        return a
      },
      drawPoints: function() {
        var a = this,
          b = a.xAxis,
          d = a.yAxis,
          e = a.group,
          m = a.chart,
          f = m.renderer,
          g, n, k, l, q = this.baseTrans,
          t, u, z, x, G;
        a.transformGroup || (a.transformGroup = f.g().attr({
          scaleX: 1,
          scaleY: 1
        }).add(e), a.transformGroup.survive = !0);
        a.doFullTranslate() ? (m.hasRendered && h(a.points, function(b) {
          b.shapeArgs && (b.shapeArgs.fill = a.pointAttribs(b, b.state).fill)
        }), a.group = a.transformGroup, r.column.prototype.drawPoints.apply(a), a.group = e, h(a.points, function(a) {
          a.graphic && (a.name && a.graphic.addClass("highcharts-name-" + a.name.replace(/ /g, "-").toLowerCase()), a.properties && a.properties["hc-key"] && a.graphic.addClass("highcharts-key-" + a.properties["hc-key"].toLowerCase()))
        }), this.baseTrans = {
          originX: b.min -
            b.minPixelPadding / b.transA,
          originY: d.min - d.minPixelPadding / d.transA + (d.reversed ? 0 : d.len / d.transA),
          transAX: b.transA,
          transAY: d.transA
        }, this.transformGroup.animate({
          translateX: 0,
          translateY: 0,
          scaleX: 1,
          scaleY: 1
        })) : (g = b.transA / q.transAX, n = d.transA / q.transAY, k = b.toPixels(q.originX, !0), l = d.toPixels(q.originY, !0), .99 < g && 1.01 > g && .99 < n && 1.01 > n && (n = g = 1, k = Math.round(k), l = Math.round(l)), t = this.transformGroup, m.renderer.globalAnimation ? (u = t.attr("translateX"), z = t.attr("translateY"), x = t.attr("scaleX"), G = t.attr("scaleY"),
          t.attr({
            animator: 0
          }).animate({
            animator: 1
          }, {
            step: function(a, b) {
              t.attr({
                translateX: u + (k - u) * b.pos,
                translateY: z + (l - z) * b.pos,
                scaleX: x + (g - x) * b.pos,
                scaleY: G + (n - G) * b.pos
              })
            }
          })) : t.attr({
          translateX: k,
          translateY: l,
          scaleX: g,
          scaleY: n
        }));
        v || a.group.element.setAttribute("stroke-width", a.options[a.pointAttrToOptions && a.pointAttrToOptions["stroke-width"] || "borderWidth"] / (g || 1));
        this.drawMapDataLabels()
      },
      drawMapDataLabels: function() {
        d.prototype.drawDataLabels.call(this);
        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect)
      },
      render: function() {
        var a = this,
          b = d.prototype.render;
        a.chart.renderer.isVML && 3E3 < a.data.length ? setTimeout(function() {
          b.call(a)
        }) : b.call(a)
      },
      animate: function(a) {
        var b = this.options.animation,
          c = this.group,
          d = this.xAxis,
          e = this.yAxis,
          m = d.pos,
          f = e.pos;
        this.chart.renderer.isSVG && (!0 === b && (b = {
          duration: 1E3
        }), a ? c.attr({
          translateX: m + d.len / 2,
          translateY: f + e.len / 2,
          scaleX: .001,
          scaleY: .001
        }) : (c.animate({
          translateX: m,
          translateY: f,
          scaleX: 1,
          scaleY: 1
        }, b), this.animate = null))
      },
      animateDrilldown: function(a) {
        var b = this.chart.plotBox,
          c = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
          d = c.bBox,
          e = this.chart.options.drilldown.animation;
        a || (a = Math.min(d.width / b.width, d.height / b.height), c.shapeArgs = {
          scaleX: a,
          scaleY: a,
          translateX: d.x,
          translateY: d.y
        }, h(this.points, function(a) {
          a.graphic && a.graphic.attr(c.shapeArgs).animate({
            scaleX: 1,
            scaleY: 1,
            translateX: 0,
            translateY: 0
          }, e)
        }), this.animate = null)
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      animateDrillupFrom: function(a) {
        r.column.prototype.animateDrillupFrom.call(this,
          a)
      },
      animateDrillupTo: function(a) {
        r.column.prototype.animateDrillupTo.call(this, a)
      }
    }), k({
      applyOptions: function(a, d) {
        a = b.prototype.applyOptions.call(this, a, d);
        d = this.series;
        var c = d.joinBy;
        d.mapData && ((c = void 0 !== a[c[1]] && d.mapMap[a[c[1]]]) ? (d.xyFromShape && (a.x = c._midX, a.y = c._midY), k(a, c)) : a.value = a.value || null);
        return a
      },
      onMouseOver: function(c) {
        a.clearTimeout(this.colorInterval);
        if (null !== this.value || this.series.options.nullInteraction) b.prototype.onMouseOver.call(this, c);
        else this.series.onMouseOut(c)
      },
      zoomTo: function() {
        var a = this.series;
        a.xAxis.setExtremes(this._minX, this._maxX, !1);
        a.yAxis.setExtremes(this._minY, this._maxY, !1);
        a.chart.redraw()
      }
    }, l))
  })(x);
  (function(a) {
    var l = a.seriesType,
      h = a.seriesTypes;
    l("mapline", "map", {
      lineWidth: 1,
      fillColor: "none"
    }, {
      type: "mapline",
      colorProp: "stroke",
      pointAttrToOptions: {
        stroke: "color",
        "stroke-width": "lineWidth"
      },
      pointAttribs: function(a, f) {
        a = h.map.prototype.pointAttribs.call(this, a, f);
        a.fill = this.options.fillColor;
        return a
      },
      drawLegendSymbol: h.line.prototype.drawLegendSymbol
    })
  })(x);
  (function(a) {
    var l = a.merge,
      h = a.Point;
    a = a.seriesType;
    a("mappoint", "scatter", {
      dataLabels: {
        enabled: !0,
        formatter: function() {
          return this.point.name
        },
        crop: !1,
        defer: !1,
        overflow: !1,
        style: {
          color: "#000000"
        }
      }
    }, {
      type: "mappoint",
      forceDL: !0
    }, {
      applyOptions: function(a, f) {
        a = void 0 !== a.lat && void 0 !== a.lon ? l(a, this.series.chart.fromLatLonToPoint(a)) : a;
        return h.prototype.applyOptions.call(this, a, f)
      }
    })
  })(x);
  (function(a) {
    var l = a.arrayMax,
      h = a.arrayMin,
      k = a.Axis,
      f = a.color,
      q = a.each,
      g = a.isNumber,
      u = a.noop,
      t = a.pick,
      e = a.pInt,
      b = a.Point,
      d = a.Series,
      n = a.seriesType,
      r = a.seriesTypes;
    n("bubble", "scatter", {
      dataLabels: {
        formatter: function() {
          return this.point.z
        },
        inside: !0,
        verticalAlign: "middle"
      },
      animationLimit: 250,
      marker: {
        lineColor: null,
        lineWidth: 1,
        fillOpacity: .5,
        radius: null,
        states: {
          hover: {
            radiusPlus: 0
          }
        },
        symbol: "circle"
      },
      minSize: 8,
      maxSize: "20%",
      softThreshold: !1,
      states: {
        hover: {
          halo: {
            size: 5
          }
        }
      },
      tooltip: {
        pointFormat: "({point.x}, {point.y}), Size: {point.z}"
      },
      turboThreshold: 0,
      zThreshold: 0,
      zoneAxis: "z"
    }, {
      pointArrayMap: ["y", "z"],
      parallelArrays: ["x",
        "y", "z"
      ],
      trackerGroups: ["group", "dataLabelsGroup"],
      specialGroup: "group",
      bubblePadding: !0,
      zoneAxis: "z",
      directTouch: !0,
      pointAttribs: function(a, b) {
        var c = this.options.marker.fillOpacity;
        a = d.prototype.pointAttribs.call(this, a, b);
        1 !== c && (a.fill = f(a.fill).setOpacity(c).get("rgba"));
        return a
      },
      getRadii: function(a, b, c, d) {
        var e, m, f, p = this.zData,
          g = [],
          n = this.options,
          v = "width" !== n.sizeBy,
          h = n.zThreshold,
          k = b - a;
        m = 0;
        for (e = p.length; m < e; m++) f = p[m], n.sizeByAbsoluteValue && null !== f && (f = Math.abs(f - h), b = k = Math.max(b - h, Math.abs(a -
          h)), a = 0), null === f ? f = null : f < a ? f = c / 2 - 1 : (f = 0 < k ? (f - a) / k : .5, v && 0 <= f && (f = Math.sqrt(f)), f = Math.ceil(c + f * (d - c)) / 2), g.push(f);
        this.radii = g
      },
      animate: function(a) {
        !a && this.points.length < this.options.animationLimit && (q(this.points, function(a) {
          var b = a.graphic,
            d;
          b && b.width && (d = {
            x: b.x,
            y: b.y,
            width: b.width,
            height: b.height
          }, b.attr({
            x: a.plotX,
            y: a.plotY,
            width: 1,
            height: 1
          }), b.animate(d, this.options.animation))
        }, this), this.animate = null)
      },
      translate: function() {
        var b, d = this.data,
          c, e, f = this.radii;
        r.scatter.prototype.translate.call(this);
        for (b = d.length; b--;) c = d[b], e = f ? f[b] : 0, g(e) && e >= this.minPxSize / 2 ? (c.marker = a.extend(c.marker, {
          radius: e,
          width: 2 * e,
          height: 2 * e
        }), c.dlBox = {
          x: c.plotX - e,
          y: c.plotY - e,
          width: 2 * e,
          height: 2 * e
        }) : c.shapeArgs = c.plotY = c.dlBox = void 0
      },
      alignDataLabel: r.column.prototype.alignDataLabel,
      buildKDTree: u,
      applyZones: u
    }, {
      haloPath: function(a) {
        return b.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a)
      },
      ttBelow: !1
    });
    k.prototype.beforePadding = function() {
      var a = this,
        b = this.len,
        c = this.chart,
        d = 0,
        f = b,
        n = this.isXAxis,
        k = n ? "xData" : "yData",
        r = this.min,
        u = {},
        x = Math.min(c.plotWidth, c.plotHeight),
        A = Number.MAX_VALUE,
        D = -Number.MAX_VALUE,
        E = this.max - r,
        C = b / E,
        F = [];
      q(this.series, function(b) {
        var d = b.options;
        !b.bubblePadding || !b.visible && c.options.chart.ignoreHiddenSeries || (a.allowZoomOutside = !0, F.push(b), n && (q(["minSize", "maxSize"], function(a) {
          var b = d[a],
            c = /%$/.test(b),
            b = e(b);
          u[a] = c ? x * b / 100 : b
        }), b.minPxSize = u.minSize, b.maxPxSize = Math.max(u.maxSize, u.minSize), b = b.zData, b.length && (A = t(d.zMin, Math.min(A, Math.max(h(b), !1 === d.displayNegative ?
          d.zThreshold : -Number.MAX_VALUE))), D = t(d.zMax, Math.max(D, l(b))))))
      });
      q(F, function(b) {
        var c = b[k],
          e = c.length,
          m;
        n && b.getRadii(A, D, b.minPxSize, b.maxPxSize);
        if (0 < E)
          for (; e--;) g(c[e]) && a.dataMin <= c[e] && c[e] <= a.dataMax && (m = b.radii[e], d = Math.min((c[e] - r) * C - m, d), f = Math.max((c[e] - r) * C + m, f))
      });
      F.length && 0 < E && !this.isLog && (f -= b, C *= (b + d - f) / b, q([
        ["min", "userMin", d],
        ["max", "userMax", f]
      ], function(b) {
        void 0 === t(a.options[b[0]], a[b[1]]) && (a[b[0]] += b[2] / C)
      }))
    }
  })(x);
  (function(a) {
    var l = a.merge,
      h = a.Point,
      k = a.seriesType,
      f = a.seriesTypes;
    f.bubble && k("mapbubble", "bubble", {
      animationLimit: 500,
      tooltip: {
        pointFormat: "{point.name}: {point.z}"
      }
    }, {
      xyFromShape: !0,
      type: "mapbubble",
      pointArrayMap: ["z"],
      getMapData: f.map.prototype.getMapData,
      getBox: f.map.prototype.getBox,
      setData: f.map.prototype.setData
    }, {
      applyOptions: function(a, g) {
        return a && void 0 !== a.lat && void 0 !== a.lon ? h.prototype.applyOptions.call(this, l(a, this.series.chart.fromLatLonToPoint(a)), g) : f.map.prototype.pointClass.prototype.applyOptions.call(this, a, g)
      },
      isValid: function() {
        return "number" ===
          typeof this.z
      },
      ttBelow: !1
    })
  })(x);
  (function(a) {
    var l = a.colorPointMixin,
      h = a.each,
      k = a.merge,
      f = a.noop,
      q = a.pick,
      g = a.Series,
      u = a.seriesType,
      t = a.seriesTypes;
    u("heatmap", "scatter", {
      animation: !1,
      borderWidth: 0,
      nullColor: "#f7f7f7",
      dataLabels: {
        formatter: function() {
          return this.point.value
        },
        inside: !0,
        verticalAlign: "middle",
        crop: !1,
        overflow: !1,
        padding: 0
      },
      marker: null,
      pointRange: null,
      tooltip: {
        pointFormat: "{point.x}, {point.y}: {point.value}\x3cbr/\x3e"
      },
      states: {
        hover: {
          halo: !1,
          brightness: .2
        }
      }
    }, k(a.colorSeriesMixin, {
      pointArrayMap: ["y", "value"],
      hasPointSpecificOptions: !0,
      getExtremesFromAll: !0,
      directTouch: !0,
      init: function() {
        var a;
        t.scatter.prototype.init.apply(this, arguments);
        a = this.options;
        a.pointRange = q(a.pointRange, a.colsize || 1);
        this.yAxis.axisPointRange = a.rowsize || 1
      },
      translate: function() {
        var a = this.options,
          b = this.xAxis,
          d = this.yAxis,
          f = a.pointPadding || 0,
          g = function(a, b, c) {
            return Math.min(Math.max(b, a), c)
          };
        this.generatePoints();
        h(this.points, function(e) {
          var n = (a.colsize || 1) / 2,
            c = (a.rowsize || 1) / 2,
            m = g(Math.round(b.len -
              b.translate(e.x - n, 0, 1, 0, 1)), -b.len, 2 * b.len),
            n = g(Math.round(b.len - b.translate(e.x + n, 0, 1, 0, 1)), -b.len, 2 * b.len),
            h = g(Math.round(d.translate(e.y - c, 0, 1, 0, 1)), -d.len, 2 * d.len),
            c = g(Math.round(d.translate(e.y + c, 0, 1, 0, 1)), -d.len, 2 * d.len),
            k = q(e.pointPadding, f);
          e.plotX = e.clientX = (m + n) / 2;
          e.plotY = (h + c) / 2;
          e.shapeType = "rect";
          e.shapeArgs = {
            x: Math.min(m, n) + k,
            y: Math.min(h, c) + k,
            width: Math.abs(n - m) - 2 * k,
            height: Math.abs(c - h) - 2 * k
          }
        });
        this.translateColors()
      },
      drawPoints: function() {
        t.column.prototype.drawPoints.call(this);
        h(this.points,
          function(a) {
            a.graphic.attr(this.colorAttribs(a))
          }, this)
      },
      animate: f,
      getBox: f,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      alignDataLabel: t.column.prototype.alignDataLabel,
      getExtremes: function() {
        g.prototype.getExtremes.call(this, this.valueData);
        this.valueMin = this.dataMin;
        this.valueMax = this.dataMax;
        g.prototype.getExtremes.call(this)
      }
    }), a.extend({
      haloPath: function(a) {
        if (!a) return [];
        var b = this.shapeArgs;
        return ["M", b.x - a, b.y - a, "L", b.x - a, b.y + b.height + a, b.x + b.width + a, b.y + b.height + a, b.x + b.width + a, b.y -
          a, "Z"
        ]
      }
    }, l))
  })(x);
  (function(a) {
    function l(a, b) {
      var d, e, f, g = !1,
        h = a.x,
        c = a.y;
      a = 0;
      for (d = b.length - 1; a < b.length; d = a++) e = b[a][1] > c, f = b[d][1] > c, e !== f && h < (b[d][0] - b[a][0]) * (c - b[a][1]) / (b[d][1] - b[a][1]) + b[a][0] && (g = !g);
      return g
    }
    var h = a.Chart,
      k = a.each,
      f = a.extend,
      q = a.format,
      g = a.merge,
      u = a.win,
      t = a.wrap;
    h.prototype.transformFromLatLon = function(e, b) {
      if (void 0 === u.proj4) return a.error(21), {
        x: 0,
        y: null
      };
      e = u.proj4(b.crs, [e.lon, e.lat]);
      var d = b.cosAngle || b.rotation && Math.cos(b.rotation),
        f = b.sinAngle || b.rotation && Math.sin(b.rotation);
      e = b.rotation ? [e[0] * d + e[1] * f, -e[0] * f + e[1] * d] : e;
      return {
        x: ((e[0] - (b.xoffset || 0)) * (b.scale || 1) + (b.xpan || 0)) * (b.jsonres || 1) + (b.jsonmarginX || 0),
        y: (((b.yoffset || 0) - e[1]) * (b.scale || 1) + (b.ypan || 0)) * (b.jsonres || 1) - (b.jsonmarginY || 0)
      }
    };
    h.prototype.transformToLatLon = function(e, b) {
      if (void 0 === u.proj4) a.error(21);
      else {
        e = {
          x: ((e.x - (b.jsonmarginX || 0)) / (b.jsonres || 1) - (b.xpan || 0)) / (b.scale || 1) + (b.xoffset || 0),
          y: ((-e.y - (b.jsonmarginY || 0)) / (b.jsonres || 1) + (b.ypan || 0)) / (b.scale || 1) + (b.yoffset || 0)
        };
        var d = b.cosAngle || b.rotation &&
          Math.cos(b.rotation),
          f = b.sinAngle || b.rotation && Math.sin(b.rotation);
        b = u.proj4(b.crs, "WGS84", b.rotation ? {
          x: e.x * d + e.y * -f,
          y: e.x * f + e.y * d
        } : e);
        return {
          lat: b.y,
          lon: b.x
        }
      }
    };
    h.prototype.fromPointToLatLon = function(e) {
      var b = this.mapTransforms,
        d;
      if (b) {
        for (d in b)
          if (b.hasOwnProperty(d) && b[d].hitZone && l({
              x: e.x,
              y: -e.y
            }, b[d].hitZone.coordinates[0])) return this.transformToLatLon(e, b[d]);
        return this.transformToLatLon(e, b["default"])
      }
      a.error(22)
    };
    h.prototype.fromLatLonToPoint = function(e) {
      var b = this.mapTransforms,
        d, f;
      if (!b) return a.error(22), {
        x: 0,
        y: null
      };
      for (d in b)
        if (b.hasOwnProperty(d) && b[d].hitZone && (f = this.transformFromLatLon(e, b[d]), l({
            x: f.x,
            y: -f.y
          }, b[d].hitZone.coordinates[0]))) return f;
      return this.transformFromLatLon(e, b["default"])
    };
    a.geojson = function(a, b, d) {
      var e = [],
        g = [],
        h = function(a) {
          var b, d = a.length;
          g.push("M");
          for (b = 0; b < d; b++) 1 === b && g.push("L"), g.push(a[b][0], -a[b][1])
        };
      b = b || "map";
      k(a.features, function(a) {
        var d = a.geometry,
          n = d.type,
          d = d.coordinates;
        a = a.properties;
        var m;
        g = [];
        "map" === b || "mapbubble" ===
          b ? ("Polygon" === n ? (k(d, h), g.push("Z")) : "MultiPolygon" === n && (k(d, function(a) {
            k(a, h)
          }), g.push("Z")), g.length && (m = {
            path: g
          })) : "mapline" === b ? ("LineString" === n ? h(d) : "MultiLineString" === n && k(d, h), g.length && (m = {
            path: g
          })) : "mappoint" === b && "Point" === n && (m = {
            x: d[0],
            y: -d[1]
          });
        m && e.push(f(m, {
          name: a.name || a.NAME,
          properties: a
        }))
      });
      d && a.copyrightShort && (d.chart.mapCredits = q(d.chart.options.credits.mapText, {
        geojson: a
      }), d.chart.mapCreditsFull = q(d.chart.options.credits.mapTextFull, {
        geojson: a
      }));
      return e
    };
    t(h.prototype,
      "addCredits",
      function(a, b) {
        b = g(!0, this.options.credits, b);
        this.mapCredits && (b.href = null);
        a.call(this, b);
        this.credits && this.mapCreditsFull && this.credits.attr({
          title: this.mapCreditsFull
        })
      })
  })(x);
  (function(a) {
    function l(a, b, e, f, g, c, h, k) {
      return ["M", a + g, b, "L", a + e - c, b, "C", a + e - c / 2, b, a + e, b + c / 2, a + e, b + c, "L", a + e, b + f - h, "C", a + e, b + f - h / 2, a + e - h / 2, b + f, a + e - h, b + f, "L", a + k, b + f, "C", a + k / 2, b + f, a, b + f - k / 2, a, b + f - k, "L", a, b + g, "C", a, b + g / 2, a + g / 2, b, a + g, b, "Z"]
    }
    var h = a.Chart,
      k = a.defaultOptions,
      f = a.each,
      q = a.extend,
      g = a.merge,
      u = a.pick,
      t = a.Renderer,
      e = a.SVGRenderer,
      b = a.VMLRenderer;
    q(k.lang, {
      zoomIn: "Zoom in",
      zoomOut: "Zoom out"
    });
    k.mapNavigation = {
      buttonOptions: {
        alignTo: "plotBox",
        align: "left",
        verticalAlign: "top",
        x: 0,
        width: 18,
        height: 18,
        padding: 5,
        style: {
          fontSize: "15px",
          fontWeight: "bold"
        },
        theme: {
          "stroke-width": 1,
          "text-align": "center"
        }
      },
      buttons: {
        zoomIn: {
          onclick: function() {
            this.mapZoom(.5)
          },
          text: "+",
          y: 0
        },
        zoomOut: {
          onclick: function() {
            this.mapZoom(2)
          },
          text: "-",
          y: 28
        }
      },
      mouseWheelSensitivity: 1.1
    };
    a.splitPath = function(a) {
      var b;
      a = a.replace(/([A-Za-z])/g,
        " $1 ");
      a = a.replace(/^\s*/, "").replace(/\s*$/, "");
      a = a.split(/[ ,]+/);
      for (b = 0; b < a.length; b++) /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));
      return a
    };
    a.maps = {};
    e.prototype.symbols.topbutton = function(a, b, e, f, g) {
      return l(a - 1, b - 1, e, f, g.r, g.r, 0, 0)
    };
    e.prototype.symbols.bottombutton = function(a, b, e, f, g) {
      return l(a - 1, b - 1, e, f, 0, 0, g.r, g.r)
    };
    t === b && f(["topbutton", "bottombutton"], function(a) {
      b.prototype.symbols[a] = e.prototype.symbols[a]
    });
    a.Map = a.mapChart = function(b, e, f) {
      var d = "string" === typeof b || b.nodeName,
        k = arguments[d ? 1 : 0],
        c = {
          endOnTick: !1,
          visible: !1,
          minPadding: 0,
          maxPadding: 0,
          startOnTick: !1
        },
        l, n = a.getOptions().credits;
      l = k.series;
      k.series = null;
      k = g({
        chart: {
          panning: "xy",
          type: "map"
        },
        credits: {
          mapText: u(n.mapText, ' \u00a9 \x3ca href\x3d"{geojson.copyrightUrl}"\x3e{geojson.copyrightShort}\x3c/a\x3e'),
          mapTextFull: u(n.mapTextFull, "{geojson.copyright}")
        },
        tooltip: {
          followTouchMove: !1
        },
        xAxis: c,
        yAxis: g(c, {
          reversed: !0
        })
      }, k, {
        chart: {
          inverted: !1,
          alignTicks: !1
        }
      });
      k.series = l;
      return d ? new h(b, k, f) : new h(k, e)
    }
  })(x)
});;
/*! RESOURCE: /scripts/highcharts/proj4.js */
! function(a) {
  if ("object" == typeof exports) module.exports = a();
  else if ("function" == typeof define && define.amd) define(a);
  else {
    var b;
    "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.proj4 = a()
  }
}(function() {
  return function a(b, c, d) {
    function e(g, h) {
      if (!c[g]) {
        if (!b[g]) {
          var i = "function" == typeof require && require;
          if (!h && i) return i(g, !0);
          if (f) return f(g, !0);
          throw new Error("Cannot find module '" + g + "'")
        }
        var j = c[g] = {
          exports: {}
        };
        b[g][0].call(j.exports, function(a) {
          var c = b[g][1][a];
          return e(c ? c : a)
        }, j, j.exports, a, b, c, d)
      }
      return c[g].exports
    }
    for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
    return e
  }({
    1: [function(a, b, c) {
      function Point(a, b, c) {
        if (!(this instanceof Point)) return new Point(a, b, c);
        if (Array.isArray(a)) this.x = a[0], this.y = a[1], this.z = a[2] || 0;
        else if ("object" == typeof a) this.x = a.x, this.y = a.y, this.z = a.z || 0;
        else if ("string" == typeof a && "undefined" == typeof b) {
          var d = a.split(",");
          this.x = parseFloat(d[0], 10), this.y = parseFloat(d[1], 10), this.z = parseFloat(d[2], 10) || 0
        } else this.x = a, this.y = b, this.z = c || 0;
        console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")
      }
      var d = a("mgrs");
      Point.fromMGRS = function(a) {
        return new Point(d.toPoint(a))
      }, Point.prototype.toMGRS = function(a) {
        return d.forward([this.x, this.y], a)
      }, b.exports = Point
    }, {
      mgrs: 67
    }],
    2: [function(a, b, c) {
      function Projection(a, b) {
        if (!(this instanceof Projection)) return new Projection(a);
        b = b || function(a) {
          if (a) throw a
        };
        var c = d(a);
        if ("object" != typeof c) return void b(a);
        var f = g(c),
          h = Projection.projections.get(f.projName);
        h ? (e(this, f), e(this, h), this.init(), b(null, this)) : b(a)
      }
      var d = a("./parseCode"),
        e = a("./extend"),
        f = a("./projections"),
        g = a("./deriveConstants");
      Projection.projections = f, Projection.projections.start(), b.exports = Projection
    }, {
      "./deriveConstants": 33,
      "./extend": 34,
      "./parseCode": 37,
      "./projections": 39
    }],
    3: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d, e, f, g = c.x,
          h = c.y,
          i = c.z || 0;
        for (f = 0; 3 > f; f++)
          if (!b || 2 !== f || void 0 !== c.z) switch (0 === f ? (d = g, e = "x") : 1 === f ? (d = h, e = "y") : (d = i, e = "z"), a.axis[f]) {
            case "e":
              c[e] = d;
              break;
            case "w":
              c[e] = -d;
              break;
            case "n":
              c[e] = d;
              break;
            case "s":
              c[e] = -d;
              break;
            case "u":
              void 0 !== c[e] && (c.z = d);
              break;
            case "d":
              void 0 !== c[e] && (c.z = -d);
              break;
            default:
              return null
          }
        return c
      }
    }, {}],
    4: [function(a, b, c) {
      var d = Math.PI / 2,
        e = a("./sign");
      b.exports = function(a) {
        return Math.abs(a) < d ? a : a - e(a) * Math.PI
      }
    }, {
      "./sign": 21
    }],
    5: [function(a, b, c) {
      var d = 2 * Math.PI,
        e = 3.14159265359,
        f = a("./sign");
      b.exports = function(a) {
        return Math.abs(a) <= e ? a : a - f(a) * d
      }
    }, {
      "./sign": 21
    }],
    6: [function(a, b, c) {
      b.exports = function(a) {
        return Math.abs(a) > 1 && (a = a > 1 ? 1 : -1), Math.asin(a)
      }
    }, {}],
    7: [function(a, b, c) {
      b.exports = function(a) {
        return 1 - .25 * a * (1 + a / 16 * (3 + 1.25 * a))
      }
    }, {}],
    8: [function(a, b, c) {
      b.exports = function(a) {
        return .375 * a * (1 + .25 * a * (1 + .46875 * a))
      }
    }, {}],
    9: [function(a, b, c) {
      b.exports = function(a) {
        return .05859375 * a * a * (1 + .75 * a)
      }
    }, {}],
    10: [function(a, b, c) {
      b.exports = function(a) {
        return a * a * a * (35 / 3072)
      }
    }, {}],
    11: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d = b * c;
        return a / Math.sqrt(1 - d * d)
      }
    }, {}],
    12: [function(a, b, c) {
      b.exports = function(a, b, c, d, e) {
        var f, g;
        f = a / b;
        for (var h = 0; 15 > h; h++)
          if (g = (a - (b * f - c * Math.sin(2 * f) + d * Math.sin(4 * f) - e * Math.sin(6 * f))) / (b - 2 * c * Math.cos(2 * f) + 4 * d * Math.cos(4 * f) - 6 * e * Math.cos(6 * f)), f += g, Math.abs(g) <= 1e-10) return f;
        return NaN
      }
    }, {}],
    13: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b) {
        var c = 1 - (1 - a * a) / (2 * a) * Math.log((1 - a) / (1 + a));
        if (Math.abs(Math.abs(b) - c) < 1e-6) return 0 > b ? -1 * d : d;
        for (var e, f, g, h, i = Math.asin(.5 * b), j = 0; 30 > j; j++)
          if (f = Math.sin(i), g = Math.cos(i), h = a * f, e = Math.pow(1 - h * h, 2) / (2 * g) * (b / (1 - a * a) - f / (1 - h * h) + .5 / a * Math.log((1 - h) / (1 + h))), i += e, Math.abs(e) <= 1e-10) return i;
        return NaN
      }
    }, {}],
    14: [function(a, b, c) {
      b.exports = function(a, b, c, d, e) {
        return a * e - b * Math.sin(2 * e) + c * Math.sin(4 * e) - d * Math.sin(6 * e)
      }
    }, {}],
    15: [function(a, b, c) {
      b.exports = function(a, b, c) {
        var d = a * b;
        return c / Math.sqrt(1 - d * d)
      }
    }, {}],
    16: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b) {
        for (var c, e, f = .5 * a, g = d - 2 * Math.atan(b), h = 0; 15 >= h; h++)
          if (c = a * Math.sin(g), e = d - 2 * Math.atan(b * Math.pow((1 - c) / (1 + c), f)) - g, g += e, Math.abs(e) <= 1e-10) return g;
        return -9999
      }
    }, {}],
    17: [function(a, b, c) {
      var d = 1,
        e = .25,
        f = .046875,
        g = .01953125,
        h = .01068115234375,
        i = .75,
        j = .46875,
        k = .013020833333333334,
        l = .007120768229166667,
        m = .3645833333333333,
        n = .005696614583333333,
        o = .3076171875;
      b.exports = function(a) {
        var b = [];
        b[0] = d - a * (e + a * (f + a * (g + a * h))), b[1] = a * (i - a * (f + a * (g + a * h)));
        var c = a * a;
        return b[2] = c * (j - a * (k + a * l)), c *= a, b[3] = c * (m - a * n), b[4] = c * a * o, b
      }
    }, {}],
    18: [function(a, b, c) {
      var d = a("./pj_mlfn"),
        e = 1e-10,
        f = 20;
      b.exports = function(a, b, c) {
        for (var g = 1 / (1 - b), h = a, i = f; i; --i) {
          var j = Math.sin(h),
            k = 1 - b * j * j;
          if (k = (d(h, j, Math.cos(h), c) - a) * (k * Math.sqrt(k)) * g, h -= k, Math.abs(k) < e) return h
        }
        return h
      }
    }, {
      "./pj_mlfn": 19
    }],
    19: [function(a, b, c) {
      b.exports = function(a, b, c, d) {
        return c *= b, b *= b, d[0] * a - c * (d[1] + b * (d[2] + b * (d[3] + b * d[4])))
      }
    }, {}],
    20: [function(a, b, c) {
      b.exports = function(a, b) {
        var c;
        return a > 1e-7 ? (c = a * b, (1 - a * a) * (b / (1 - c * c) - .5 / a * Math.log((1 - c) / (1 + c)))) : 2 * b
      }
    }, {}],
    21: [function(a, b, c) {
      b.exports = function(a) {
        return 0 > a ? -1 : 1
      }
    }, {}],
    22: [function(a, b, c) {
      b.exports = function(a, b) {
        return Math.pow((1 - a) / (1 + a), b)
      }
    }, {}],
    23: [function(a, b, c) {
      b.exports = function(a) {
        var b = {
          x: a[0],
          y: a[1]
        };
        return a.length > 2 && (b.z = a[2]), a.length > 3 && (b.m = a[3]), b
      }
    }, {}],
    24: [function(a, b, c) {
      var d = Math.PI / 2;
      b.exports = function(a, b, c) {
        var e = a * c,
          f = .5 * a;
        return e = Math.pow((1 - e) / (1 + e), f), Math.tan(.5 * (d - b)) / e
      }
    }, {}],
    25: [function(a, b, c) {
      c.wgs84 = {
        towgs84: "0,0,0",
        ellipse: "WGS84",
        datumName: "WGS84"
      }, c.ch1903 = {
        towgs84: "674.374,15.056,405.346",
        ellipse: "bessel",
        datumName: "swiss"
      }, c.ggrs87 = {
        towgs84: "-199.87,74.79,246.62",
        ellipse: "GRS80",
        datumName: "Greek_Geodetic_Reference_System_1987"
      }, c.nad83 = {
        towgs84: "0,0,0",
        ellipse: "GRS80",
        datumName: "North_American_Datum_1983"
      }, c.nad27 = {
        nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
        ellipse: "clrk66",
        datumName: "North_American_Datum_1927"
      }, c.potsdam = {
        towgs84: "606.0,23.0,413.0",
        ellipse: "bessel",
        datumName: "Potsdam Rauenberg 1950 DHDN"
      }, c.carthage = {
        towgs84: "-263.0,6.0,431.0",
        ellipse: "clark80",
        datumName: "Carthage 1934 Tunisia"
      }, c.hermannskogel = {
        towgs84: "653.0,-212.0,449.0",
        ellipse: "bessel",
        datumName: "Hermannskogel"
      }, c.ire65 = {
        towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
        ellipse: "mod_airy",
        datumName: "Ireland 1965"
      }, c.rassadiran = {
        towgs84: "-133.63,-157.5,-158.62",
        ellipse: "intl",
        datumName: "Rassadiran"
      }, c.nzgd49 = {
        towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
        ellipse: "intl",
        datumName: "New Zealand Geodetic Datum 1949"
      }, c.osgb36 = {
        towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
        ellipse: "airy",
        datumName: "Airy 1830"
      }, c.s_jtsk = {
        towgs84: "589,76,480",
        ellipse: "bessel",
        datumName: "S-JTSK (Ferro)"
      }, c.beduaram = {
        towgs84: "-106,-87,188",
        ellipse: "clrk80",
        datumName: "Beduaram"
      }, c.gunung_segara = {
        towgs84: "-403,684,41",
        ellipse: "bessel",
        datumName: "Gunung Segara Jakarta"
      }, c.rnb72 = {
        towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
        ellipse: "intl",
        datumName: "Reseau National Belge 1972"
      }
    }, {}],
    26: [function(a, b, c) {
      c.MERIT = {
        a: 6378137,
        rf: 298.257,
        ellipseName: "MERIT 1983"
      }, c.SGS85 = {
        a: 6378136,
        rf: 298.257,
        ellipseName: "Soviet Geodetic System 85"
      }, c.GRS80 = {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: "GRS 1980(IUGG, 1980)"
      }, c.IAU76 = {
        a: 6378140,
        rf: 298.257,
        ellipseName: "IAU 1976"
      }, c.airy = {
        a: 6377563.396,
        b: 6356256.91,
        ellipseName: "Airy 1830"
      }, c.APL4 = {
        a: 6378137,
        rf: 298.25,
        ellipseName: "Appl. Physics. 1965"
      }, c.NWL9D = {
        a: 6378145,
        rf: 298.25,
        ellipseName: "Naval Weapons Lab., 1965"
      }, c.mod_airy = {
        a: 6377340.189,
        b: 6356034.446,
        ellipseName: "Modified Airy"
      }, c.andrae = {
        a: 6377104.43,
        rf: 300,
        ellipseName: "Andrae 1876 (Den., Iclnd.)"
      }, c.aust_SA = {
        a: 6378160,
        rf: 298.25,
        ellipseName: "Australian Natl & S. Amer. 1969"
      }, c.GRS67 = {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: "GRS 67(IUGG 1967)"
      }, c.bessel = {
        a: 6377397.155,
        rf: 299.1528128,
        ellipseName: "Bessel 1841"
      }, c.bess_nam = {
        a: 6377483.865,
        rf: 299.1528128,
        ellipseName: "Bessel 1841 (Namibia)"
      }, c.clrk66 = {
        a: 6378206.4,
        b: 6356583.8,
        ellipseName: "Clarke 1866"
      }, c.clrk80 = {
        a: 6378249.145,
        rf: 293.4663,
        ellipseName: "Clarke 1880 mod."
      }, c.clrk58 = {
        a: 6378293.645208759,
        rf: 294.2606763692654,
        ellipseName: "Clarke 1858"
      }, c.CPM = {
        a: 6375738.7,
        rf: 334.29,
        ellipseName: "Comm. des Poids et Mesures 1799"
      }, c.delmbr = {
        a: 6376428,
        rf: 311.5,
        ellipseName: "Delambre 1810 (Belgium)"
      }, c.engelis = {
        a: 6378136.05,
        rf: 298.2566,
        ellipseName: "Engelis 1985"
      }, c.evrst30 = {
        a: 6377276.345,
        rf: 300.8017,
        ellipseName: "Everest 1830"
      }, c.evrst48 = {
        a: 6377304.063,
        rf: 300.8017,
        ellipseName: "Everest 1948"
      }, c.evrst56 = {
        a: 6377301.243,
        rf: 300.8017,
        ellipseName: "Everest 1956"
      }, c.evrst69 = {
        a: 6377295.664,
        rf: 300.8017,
        ellipseName: "Everest 1969"
      }, c.evrstSS = {
        a: 6377298.556,
        rf: 300.8017,
        ellipseName: "Everest (Sabah & Sarawak)"
      }, c.fschr60 = {
        a: 6378166,
        rf: 298.3,
        ellipseName: "Fischer (Mercury Datum) 1960"
      }, c.fschr60m = {
        a: 6378155,
        rf: 298.3,
        ellipseName: "Fischer 1960"
      }, c.fschr68 = {
        a: 6378150,
        rf: 298.3,
        ellipseName: "Fischer 1968"
      }, c.helmert = {
        a: 6378200,
        rf: 298.3,
        ellipseName: "Helmert 1906"
      }, c.hough = {
        a: 6378270,
        rf: 297,
        ellipseName: "Hough"
      }, c.intl = {
        a: 6378388,
        rf: 297,
        ellipseName: "International 1909 (Hayford)"
      }, c.kaula = {
        a: 6378163,
        rf: 298.24,
        ellipseName: "Kaula 1961"
      }, c.lerch = {
        a: 6378139,
        rf: 298.257,
        ellipseName: "Lerch 1979"
      }, c.mprts = {
        a: 6397300,
        rf: 191,
        ellipseName: "Maupertius 1738"
      }, c.new_intl = {
        a: 6378157.5,
        b: 6356772.2,
        ellipseName: "New International 1967"
      }, c.plessis = {
        a: 6376523,
        rf: 6355863,
        ellipseName: "Plessis 1817 (France)"
      }, c.krass = {
        a: 6378245,
        rf: 298.3,
        ellipseName: "Krassovsky, 1942"
      }, c.SEasia = {
        a: 6378155,
        b: 6356773.3205,
        ellipseName: "Southeast Asia"
      }, c.walbeck = {
        a: 6376896,
        b: 6355834.8467,
        ellipseName: "Walbeck"
      }, c.WGS60 = {
        a: 6378165,
        rf: 298.3,
        ellipseName: "WGS 60"
      }, c.WGS66 = {
        a: 6378145,
        rf: 298.25,
        ellipseName: "WGS 66"
      }, c.WGS7 = {
        a: 6378135,
        rf: 298.26,
        ellipseName: "WGS 72"
      }, c.WGS84 = {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
      }, c.sphere = {
        a: 6370997,
        b: 6370997,
        ellipseName: "Normal Sphere (r=6370997)"
      }
    }, {}],
    27: [function(a, b, c) {
      c.greenwich = 0, c.lisbon = -9.131906111111, c.paris = 2.337229166667, c.bogota = -74.080916666667, c.madrid = -3.687938888889, c.rome = 12.452333333333, c.bern = 7.439583333333, c.jakarta = 106.807719444444, c.ferro = -17.666666666667, c.brussels = 4.367975, c.stockholm = 18.058277777778, c.athens = 23.7163375, c.oslo = 10.722916666667
    }, {}],
    28: [function(a, b, c) {
      c.ft = {
        to_meter: .3048
      }, c["us-ft"] = {
        to_meter: 1200 / 3937
      }
    }, {}],
    29: [function(a, b, c) {
      function d(a, b, c) {
        var d;
        return Array.isArray(c) ? (d = g(a, b, c), 3 === c.length ? [d.x, d.y, d.z] : [d.x, d.y]) : g(a, b, c)
      }

      function e(a) {
        return a instanceof f ? a : a.oProj ? a.oProj : f(a)
      }

      function proj4(a, b, c) {
        a = e(a);
        var f, g = !1;
        return "undefined" == typeof b ? (b = a, a = h, g = !0) : ("undefined" != typeof b.x || Array.isArray(b)) && (c = b, b = a, a = h, g = !0), b = e(b), c ? d(a, b, c) : (f = {
          forward: function(c) {
            return d(a, b, c)
          },
          inverse: function(c) {
            return d(b, a, c)
          }
        }, g && (f.oProj = b), f)
      }
      var f = a("./Proj"),
        g = a("./transform"),
        h = f("WGS84");
      b.exports = proj4
    }, {
      "./Proj": 2,
      "./transform": 65
    }],
    30: [function(a, b, c) {
      var d = Math.PI / 2,
        e = 1,
        f = 2,
        g = 3,
        h = 4,
        i = 5,
        j = 484813681109536e-20,
        k = 1.0026,
        l = .3826834323650898,
        m = function(a) {
          return this instanceof m ? (this.datum_type = h, void(a && (a.datumCode && "none" === a.datumCode && (this.datum_type = i), a.datum_params && (this.datum_params = a.datum_params.map(parseFloat), (0 !== this.datum_params[0] || 0 !== this.datum_params[1] || 0 !== this.datum_params[2]) && (this.datum_type = e), this.datum_params.length > 3 && (0 !== this.datum_params[3] || 0 !== this.datum_params[4] || 0 !== this.datum_params[5] || 0 !== this.datum_params[6]) && (this.datum_type = f, this.datum_params[3] *= j, this.datum_params[4] *= j, this.datum_params[5] *= j, this.datum_params[6] = this.datum_params[6] / 1e6 + 1)), this.datum_type = a.grids ? g : this.datum_type, this.a = a.a, this.b = a.b, this.es = a.es, this.ep2 = a.ep2, this.datum_type === g && (this.grids = a.grids)))) : new m(a)
        };
      m.prototype = {
        compare_datums: function(a) {
          return this.datum_type !== a.datum_type ? !1 : this.a !== a.a || Math.abs(this.es - a.es) > 5e-11 ? !1 : this.datum_type === e ? this.datum_params[0] === a.datum_params[0] && this.datum_params[1] === a.datum_params[1] && this.datum_params[2] === a.datum_params[2] : this.datum_type === f ? this.datum_params[0] === a.datum_params[0] && this.datum_params[1] === a.datum_params[1] && this.datum_params[2] === a.datum_params[2] && this.datum_params[3] === a.datum_params[3] && this.datum_params[4] === a.datum_params[4] && this.datum_params[5] === a.datum_params[5] && this.datum_params[6] === a.datum_params[6] : this.datum_type === g || a.datum_type === g ? this.nadgrids === a.nadgrids : !0
        },
        geodetic_to_geocentric: function(a) {
          var b, c, e, f, g, h, i, j = a.x,
            k = a.y,
            l = a.z ? a.z : 0,
            m = 0;
          if (-d > k && k > -1.001 * d) k = -d;
          else if (k > d && 1.001 * d > k) k = d;
          else if (-d > k || k > d) return null;
          return j > Math.PI && (j -= 2 * Math.PI), g = Math.sin(k), i = Math.cos(k), h = g * g, f = this.a / Math.sqrt(1 - this.es * h), b = (f + l) * i * Math.cos(j), c = (f + l) * i * Math.sin(j), e = (f * (1 - this.es) + l) * g, a.x = b, a.y = c, a.z = e, m
        },
        geocentric_to_geodetic: function(a) {
          var b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = 1e-12,
            u = t * t,
            v = 30,
            w = a.x,
            x = a.y,
            y = a.z ? a.z : 0;
          if (o = !1, b = Math.sqrt(w * w + x * x), c = Math.sqrt(w * w + x * x + y * y), b / this.a < t) {
            if (o = !0, q = 0, c / this.a < t) return r = d, void(s = -this.b)
          } else q = Math.atan2(x, w);
          e = y / c, f = b / c, g = 1 / Math.sqrt(1 - this.es * (2 - this.es) * f * f), j = f * (1 - this.es) * g, k = e * g, p = 0;
          do p++, i = this.a / Math.sqrt(1 - this.es * k * k), s = b * j + y * k - i * (1 - this.es * k * k), h = this.es * i / (i + s), g = 1 / Math.sqrt(1 - h * (2 - h) * f * f), l = f * (1 - h) * g, m = e * g, n = m * j - l * k, j = l, k = m; while (n * n > u && v > p);
          return r = Math.atan(m / Math.abs(l)), a.x = q, a.y = r, a.z = s, a
        },
        geocentric_to_geodetic_noniter: function(a) {
          var b, c, e, f, g, h, i, j, m, n, o, p, q, r, s, t, u, v = a.x,
            w = a.y,
            x = a.z ? a.z : 0;
          if (v = parseFloat(v), w = parseFloat(w), x = parseFloat(x), u = !1, 0 !== v) b = Math.atan2(w, v);
          else if (w > 0) b = d;
          else if (0 > w) b = -d;
          else if (u = !0, b = 0, x > 0) c = d;
          else {
            if (!(0 > x)) return c = d, void(e = -this.b);
            c = -d
          }
          return g = v * v + w * w, f = Math.sqrt(g), h = x * k, j = Math.sqrt(h * h + g), n = h / j, p = f / j, o = n * n * n, i = x + this.b * this.ep2 * o, t = f - this.a * this.es * p * p * p, m = Math.sqrt(i * i + t * t), q = i / m, r = t / m, s = this.a / Math.sqrt(1 - this.es * q * q), e = r >= l ? f / r - s : -l >= r ? f / -r - s : x / q + s * (this.es - 1), u === !1 && (c = Math.atan(q / r)), a.x = b, a.y = c, a.z = e, a
        },
        geocentric_to_wgs84: function(a) {
          if (this.datum_type === e) a.x += this.datum_params[0], a.y += this.datum_params[1], a.z += this.datum_params[2];
          else if (this.datum_type === f) {
            var b = this.datum_params[0],
              c = this.datum_params[1],
              d = this.datum_params[2],
              g = this.datum_params[3],
              h = this.datum_params[4],
              i = this.datum_params[5],
              j = this.datum_params[6],
              k = j * (a.x - i * a.y + h * a.z) + b,
              l = j * (i * a.x + a.y - g * a.z) + c,
              m = j * (-h * a.x + g * a.y + a.z) + d;
            a.x = k, a.y = l, a.z = m
          }
        },
        geocentric_from_wgs84: function(a) {
          if (this.datum_type === e) a.x -= this.datum_params[0], a.y -= this.datum_params[1], a.z -= this.datum_params[2];
          else if (this.datum_type === f) {
            var b = this.datum_params[0],
              c = this.datum_params[1],
              d = this.datum_params[2],
              g = this.datum_params[3],
              h = this.datum_params[4],
              i = this.datum_params[5],
              j = this.datum_params[6],
              k = (a.x - b) / j,
              l = (a.y - c) / j,
              m = (a.z - d) / j;
            a.x = k + i * l - h * m, a.y = -i * k + l + g * m, a.z = h * k - g * l + m
          }
        }
      }, b.exports = m
    }, {}],
    31: [function(a, b, c) {
      var d = 1,
        e = 2,
        f = 3,
        g = 5,
        h = 6378137,
        i = .006694379990141316;
      b.exports = function(a, b, c) {
        function j(a) {
          return a === d || a === e
        }
        var k, l, m;
        if (a.compare_datums(b)) return c;
        if (a.datum_type === g || b.datum_type === g) return c;
        var n = a.a,
          o = a.es,
          p = b.a,
          q = b.es,
          r = a.datum_type;
        if (r === f)
          if (0 === this.apply_gridshift(a, 0, c)) a.a = h, a.es = i;
          else {
            if (!a.datum_params) return a.a = n, a.es = a.es, c;
            for (k = 1, l = 0, m = a.datum_params.length; m > l; l++) k *= a.datum_params[l];
            if (0 === k) return a.a = n, a.es = a.es, c;
            r = a.datum_params.length > 3 ? e : d
          } return b.datum_type === f && (b.a = h, b.es = i), (a.es !== b.es || a.a !== b.a || j(r) || j(b.datum_type)) && (a.geodetic_to_geocentric(c), j(a.datum_type) && a.geocentric_to_wgs84(c), j(b.datum_type) && b.geocentric_from_wgs84(c), b.geocentric_to_geodetic(c)), b.datum_type === f && this.apply_gridshift(b, 1, c), a.a = n, a.es = o, b.a = p, b.es = q, c
      }
    }, {}],
    32: [function(a, b, c) {
      function d(a) {
        var b = this;
        if (2 === arguments.length) {
          var c = arguments[1];
          "string" == typeof c ? "+" === c.charAt(0) ? d[a] = f(arguments[1]) : d[a] = g(arguments[1]) : d[a] = c
        } else if (1 === arguments.length) {
          if (Array.isArray(a)) return a.map(function(a) {
            Array.isArray(a) ? d.apply(b, a) : d(a)
          });
          if ("string" == typeof a) {
            if (a in d) return d[a]
          } else "EPSG" in a ? d["EPSG:" + a.EPSG] = a : "ESRI" in a ? d["ESRI:" + a.ESRI] = a : "IAU2000" in a ? d["IAU2000:" + a.IAU2000] = a : console.log(a);
          return
        }
      }
      var e = a("./global"),
        f = a("./projString"),
        g = a("./wkt");
      e(d), b.exports = d
    }, {
      "./global": 35,
      "./projString": 38,
      "./wkt": 66
    }],
    33: [function(a, b, c) {
      var d = a("./constants/Datum"),
        e = a("./constants/Ellipsoid"),
        f = a("./extend"),
        g = a("./datum"),
        h = 1e-10,
        i = .16666666666666666,
        j = .04722222222222222,
        k = .022156084656084655;
      b.exports = function(a) {
        if (a.datumCode && "none" !== a.datumCode) {
          var b = d[a.datumCode];
          b && (a.datum_params = b.towgs84 ? b.towgs84.split(",") : null, a.ellps = b.ellipse, a.datumName = b.datumName ? b.datumName : a.datumCode)
        }
        if (!a.a) {
          var c = e[a.ellps] ? e[a.ellps] : e.WGS84;
          f(a, c)
        }
        return a.rf && !a.b && (a.b = (1 - 1 / a.rf) * a.a), (0 === a.rf || Math.abs(a.a - a.b) < h) && (a.sphere = !0, a.b = a.a), a.a2 = a.a * a.a, a.b2 = a.b * a.b, a.es = (a.a2 - a.b2) / a.a2, a.e = Math.sqrt(a.es), a.R_A && (a.a *= 1 - a.es * (i + a.es * (j + a.es * k)), a.a2 = a.a * a.a, a.b2 = a.b * a.b, a.es = 0), a.ep2 = (a.a2 - a.b2) / a.b2, a.k0 || (a.k0 = 1), a.axis || (a.axis = "enu"), a.datum || (a.datum = g(a)), a
      }
    }, {
      "./constants/Datum": 25,
      "./constants/Ellipsoid": 26,
      "./datum": 30,
      "./extend": 34
    }],
    34: [function(a, b, c) {
      b.exports = function(a, b) {
        a = a || {};
        var c, d;
        if (!b) return a;
        for (d in b) c = b[d], void 0 !== c && (a[d] = c);
        return a
      }
    }, {}],
    35: [function(a, b, c) {
      b.exports = function(a) {
        a("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), a("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), a("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), a.WGS84 = a["EPSG:4326"], a["EPSG:3785"] = a["EPSG:3857"], a.GOOGLE = a["EPSG:3857"], a["EPSG:900913"] = a["EPSG:3857"], a["EPSG:102113"] = a["EPSG:3857"]
      }
    }, {}],
    36: [function(a, b, c) {
      var proj4 = a("./core");
      proj4.defaultDatum = "WGS84", proj4.Proj = a("./Proj"), proj4.WGS84 = new proj4.Proj("WGS84"), proj4.Point = a("./Point"), proj4.toPoint = a("./common/toPoint"), proj4.defs = a("./defs"), proj4.transform = a("./transform"), proj4.mgrs = a("mgrs"), proj4.version = a("../package.json").version, a("./includedProjections")(proj4), b.exports = proj4
    }, {
      "../package.json": 68,
      "./Point": 1,
      "./Proj": 2,
      "./common/toPoint": 23,
      "./core": 29,
      "./defs": 32,
      "./includedProjections": "hTEDpn",
      "./transform": 65,
      mgrs: 67
    }],
    37: [function(a, b, c) {
      function d(a) {
        return "string" == typeof a
      }

      function e(a) {
        return a in i
      }

      function f(a) {
        var b = ["GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS"];
        return b.reduce(function(b, c) {
          return b + 1 + a.indexOf(c)
        }, 0)
      }

      function g(a) {
        return "+" === a[0]
      }

      function h(a) {
        return d(a) ? e(a) ? i[a] : f(a) ? j(a) : g(a) ? k(a) : void 0 : a
      }
      var i = a("./defs"),
        j = a("./wkt"),
        k = a("./projString");
      b.exports = h
    }, {
      "./defs": 32,
      "./projString": 38,
      "./wkt": 66
    }],
    38: [function(a, b, c) {
      var d = .017453292519943295,
        e = a("./constants/PrimeMeridian"),
        f = a("./constants/units");
      b.exports = function(a) {
        var b = {},
          c = {};
        a.split("+").map(function(a) {
          return a.trim()
        }).filter(function(a) {
          return a
        }).forEach(function(a) {
          var b = a.split("=");
          b.push(!0), c[b[0].toLowerCase()] = b[1]
        });
        var g, h, i, j = {
          proj: "projName",
          datum: "datumCode",
          rf: function(a) {
            b.rf = parseFloat(a)
          },
          lat_0: function(a) {
            b.lat0 = a * d
          },
          lat_1: function(a) {
            b.lat1 = a * d
          },
          lat_2: function(a) {
            b.lat2 = a * d
          },
          lat_ts: function(a) {
            b.lat_ts = a * d
          },
          lon_0: function(a) {
            b.long0 = a * d
          },
          lon_1: function(a) {
            b.long1 = a * d
          },
          lon_2: function(a) {
            b.long2 = a * d
          },
          alpha: function(a) {
            b.alpha = parseFloat(a) * d
          },
          lonc: function(a) {
            b.longc = a * d
          },
          x_0: function(a) {
            b.x0 = parseFloat(a)
          },
          y_0: function(a) {
            b.y0 = parseFloat(a)
          },
          k_0: function(a) {
            b.k0 = parseFloat(a)
          },
          k: function(a) {
            b.k0 = parseFloat(a)
          },
          a: function(a) {
            b.a = parseFloat(a)
          },
          b: function(a) {
            b.b = parseFloat(a)
          },
          r_a: function() {
            b.R_A = !0
          },
          zone: function(a) {
            b.zone = parseInt(a, 10)
          },
          south: function() {
            b.utmSouth = !0
          },
          towgs84: function(a) {
            b.datum_params = a.split(",").map(function(a) {
              return parseFloat(a)
            })
          },
          to_meter: function(a) {
            b.to_meter = parseFloat(a)
          },
          units: function(a) {
            b.units = a, f[a] && (b.to_meter = f[a].to_meter)
          },
          from_greenwich: function(a) {
            b.from_greenwich = a * d
          },
          pm: function(a) {
            b.from_greenwich = (e[a] ? e[a] : parseFloat(a)) * d
          },
          nadgrids: function(a) {
            "@null" === a ? b.datumCode = "none" : b.nadgrids = a
          },
          axis: function(a) {
            var c = "ewnsud";
            3 === a.length && -1 !== c.indexOf(a.substr(0, 1)) && -1 !== c.indexOf(a.substr(1, 1)) && -1 !== c.indexOf(a.substr(2, 1)) && (b.axis = a)
          }
        };
        for (g in c) h = c[g], g in j ? (i = j[g], "function" == typeof i ? i(h) : b[i] = h) : b[g] = h;
        return "string" == typeof b.datumCode && "WGS84" !== b.datumCode && (b.datumCode = b.datumCode.toLowerCase()), b
      }
    }, {
      "./constants/PrimeMeridian": 27,
      "./constants/units": 28
    }],
    39: [function(a, b, c) {
      function d(a, b) {
        var c = g.length;
        return a.names ? (g[c] = a, a.names.forEach(function(a) {
          f[a.toLowerCase()] = c
        }), this) : (console.log(b), !0)
      }
      var e = [a("./projections/merc"), a("./projections/longlat")],
        f = {},
        g = [];
      c.add = d, c.get = function(a) {
        if (!a) return !1;
        var b = a.toLowerCase();
        return "undefined" != typeof f[b] && g[f[b]] ? g[f[b]] : void 0
      }, c.start = function() {
        e.forEach(d)
      }
    }, {
      "./projections/longlat": 51,
      "./projections/merc": 52
    }],
    40: [function(a, b, c) {
      var d = 1e-10,
        e = a("../common/msfnz"),
        f = a("../common/qsfnz"),
        g = a("../common/adjust_lon"),
        h = a("../common/asinz");
      c.init = function() {
        Math.abs(this.lat1 + this.lat2) < d || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = e(this.e3, this.sin_po, this.cos_po), this.qs1 = f(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = e(this.e3, this.sin_po, this.cos_po), this.qs2 = f(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = f(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > d ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        this.sin_phi = Math.sin(c), this.cos_phi = Math.cos(c);
        var d = f(this.e3, this.sin_phi, this.cos_phi),
          e = this.a * Math.sqrt(this.c - this.ns0 * d) / this.ns0,
          h = this.ns0 * g(b - this.long0),
          i = e * Math.sin(h) + this.x0,
          j = this.rh - e * Math.cos(h) + this.y0;
        return a.x = i, a.y = j, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, h;
        return a.x -= this.x0, a.y = this.rh - a.y + this.y0, this.ns0 >= 0 ? (b = Math.sqrt(a.x * a.x + a.y * a.y), d = 1) : (b = -Math.sqrt(a.x * a.x + a.y * a.y), d = -1), e = 0, 0 !== b && (e = Math.atan2(d * a.x, d * a.y)), d = b * this.ns0 / this.a, this.sphere ? h = Math.asin((this.c - d * d) / (2 * this.ns0)) : (c = (this.c - d * d) / this.ns0, h = this.phi1z(this.e3, c)), f = g(e / this.ns0 + this.long0), a.x = f, a.y = h, a
      }, c.phi1z = function(a, b) {
        var c, e, f, g, i, j = h(.5 * b);
        if (d > a) return j;
        for (var k = a * a, l = 1; 25 >= l; l++)
          if (c = Math.sin(j), e = Math.cos(j), f = a * c, g = 1 - f * f, i = .5 * g * g / e * (b / (1 - k) - c / g + .5 / a * Math.log((1 - f) / (1 + f))), j += i, Math.abs(i) <= 1e-7) return j;
        return null
      }, c.names = ["Albers_Conic_Equal_Area", "Albers", "aea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/msfnz": 15,
      "../common/qsfnz": 20
    }],
    41: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = Math.PI / 2,
        f = 1e-10,
        g = a("../common/mlfn"),
        h = a("../common/e0fn"),
        i = a("../common/e1fn"),
        j = a("../common/e2fn"),
        k = a("../common/e3fn"),
        l = a("../common/gN"),
        m = a("../common/asinz"),
        n = a("../common/imlfn");
      c.init = function() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0)
      }, c.forward = function(a) {
        var b, c, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H = a.x,
          I = a.y,
          J = Math.sin(a.y),
          K = Math.cos(a.y),
          L = d(H - this.long0);
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= f ? (a.x = this.x0 + this.a * (e - I) * Math.sin(L), a.y = this.y0 - this.a * (e - I) * Math.cos(L), a) : Math.abs(this.sin_p12 + 1) <= f ? (a.x = this.x0 + this.a * (e + I) * Math.sin(L), a.y = this.y0 + this.a * (e + I) * Math.cos(L), a) : (B = this.sin_p12 * J + this.cos_p12 * K * Math.cos(L), z = Math.acos(B), A = z / Math.sin(z), a.x = this.x0 + this.a * A * K * Math.sin(L), a.y = this.y0 + this.a * A * (this.cos_p12 * J - this.sin_p12 * K * Math.cos(L)), a) : (b = h(this.es), c = i(this.es), m = j(this.es), n = k(this.es), Math.abs(this.sin_p12 - 1) <= f ? (o = this.a * g(b, c, m, n, e), p = this.a * g(b, c, m, n, I), a.x = this.x0 + (o - p) * Math.sin(L), a.y = this.y0 - (o - p) * Math.cos(L), a) : Math.abs(this.sin_p12 + 1) <= f ? (o = this.a * g(b, c, m, n, e), p = this.a * g(b, c, m, n, I), a.x = this.x0 + (o + p) * Math.sin(L), a.y = this.y0 + (o + p) * Math.cos(L), a) : (q = J / K, r = l(this.a, this.e, this.sin_p12), s = l(this.a, this.e, J), t = Math.atan((1 - this.es) * q + this.es * r * this.sin_p12 / (s * K)), u = Math.atan2(Math.sin(L), this.cos_p12 * Math.tan(t) - this.sin_p12 * Math.cos(L)), C = 0 === u ? Math.asin(this.cos_p12 * Math.sin(t) - this.sin_p12 * Math.cos(t)) : Math.abs(Math.abs(u) - Math.PI) <= f ? -Math.asin(this.cos_p12 * Math.sin(t) - this.sin_p12 * Math.cos(t)) : Math.asin(Math.sin(L) * Math.cos(t) / Math.sin(u)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), w = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es), x = v * w, y = w * w, D = C * C, E = D * C, F = E * C, G = F * C, z = r * C * (1 - D * y * (1 - y) / 6 + E / 8 * x * (1 - 2 * y) + F / 120 * (y * (4 - 7 * y) - 3 * v * v * (1 - 7 * y)) - G / 48 * x), a.x = this.x0 + z * Math.sin(u), a.y = this.y0 + z * Math.cos(u), a))
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I;
        if (this.sphere) {
          if (b = Math.sqrt(a.x * a.x + a.y * a.y), b > 2 * e * this.a) return;
          return c = b / this.a, o = Math.sin(c), p = Math.cos(c), q = this.long0, Math.abs(b) <= f ? r = this.lat0 : (r = m(p * this.sin_p12 + a.y * o * this.cos_p12 / b), s = Math.abs(this.lat0) - e, q = d(Math.abs(s) <= f ? this.lat0 >= 0 ? this.long0 + Math.atan2(a.x, -a.y) : this.long0 - Math.atan2(-a.x, a.y) : this.long0 + Math.atan2(a.x * o, b * this.cos_p12 * p - a.y * this.sin_p12 * o))), a.x = q, a.y = r, a
        }
        return t = h(this.es), u = i(this.es), v = j(this.es), w = k(this.es), Math.abs(this.sin_p12 - 1) <= f ? (x = this.a * g(t, u, v, w, e), b = Math.sqrt(a.x * a.x + a.y * a.y), y = x - b, r = n(y / this.a, t, u, v, w), q = d(this.long0 + Math.atan2(a.x, -1 * a.y)), a.x = q, a.y = r, a) : Math.abs(this.sin_p12 + 1) <= f ? (x = this.a * g(t, u, v, w, e), b = Math.sqrt(a.x * a.x + a.y * a.y), y = b - x, r = n(y / this.a, t, u, v, w), q = d(this.long0 + Math.atan2(a.x, a.y)), a.x = q, a.y = r, a) : (b = Math.sqrt(a.x * a.x + a.y * a.y), B = Math.atan2(a.x, a.y), z = l(this.a, this.e, this.sin_p12), C = Math.cos(B), D = this.e * this.cos_p12 * C, E = -D * D / (1 - this.es), F = 3 * this.es * (1 - E) * this.sin_p12 * this.cos_p12 * C / (1 - this.es), G = b / z, H = G - E * (1 + E) * Math.pow(G, 3) / 6 - F * (1 + 3 * E) * Math.pow(G, 4) / 24, I = 1 - E * H * H / 2 - G * H * H * H / 6, A = Math.asin(this.sin_p12 * Math.cos(H) + this.cos_p12 * Math.sin(H) * C), q = d(this.long0 + Math.asin(Math.sin(B) * Math.sin(H) / Math.cos(A))), r = Math.atan((1 - this.es * I * this.sin_p12 / Math.sin(A)) * Math.tan(A) / (1 - this.es)), a.x = q, a.y = r, a)
      }, c.names = ["Azimuthal_Equidistant", "aeqd"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/imlfn": 12,
      "../common/mlfn": 14
    }],
    42: [function(a, b, c) {
      var d = a("../common/mlfn"),
        e = a("../common/e0fn"),
        f = a("../common/e1fn"),
        g = a("../common/e2fn"),
        h = a("../common/e3fn"),
        i = a("../common/gN"),
        j = a("../common/adjust_lon"),
        k = a("../common/adjust_lat"),
        l = a("../common/imlfn"),
        m = Math.PI / 2,
        n = 1e-10;
      c.init = function() {
        this.sphere || (this.e0 = e(this.es), this.e1 = f(this.es), this.e2 = g(this.es), this.e3 = h(this.es), this.ml0 = this.a * d(this.e0, this.e1, this.e2, this.e3, this.lat0))
      }, c.forward = function(a) {
        var b, c, e = a.x,
          f = a.y;
        if (e = j(e - this.long0), this.sphere) b = this.a * Math.asin(Math.cos(f) * Math.sin(e)), c = this.a * (Math.atan2(Math.tan(f), Math.cos(e)) - this.lat0);
        else {
          var g = Math.sin(f),
            h = Math.cos(f),
            k = i(this.a, this.e, g),
            l = Math.tan(f) * Math.tan(f),
            m = e * Math.cos(f),
            n = m * m,
            o = this.es * h * h / (1 - this.es),
            p = this.a * d(this.e0, this.e1, this.e2, this.e3, f);
          b = k * m * (1 - n * l * (1 / 6 - (8 - l + 8 * o) * n / 120)), c = p - this.ml0 + k * g / h * n * (.5 + (5 - l + 6 * o) * n / 24)
        }
        return a.x = b + this.x0, a.y = c + this.y0, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, d = a.x / this.a,
          e = a.y / this.a;
        if (this.sphere) {
          var f = e + this.lat0;
          b = Math.asin(Math.sin(f) * Math.cos(d)), c = Math.atan2(Math.tan(d), Math.cos(f))
        } else {
          var g = this.ml0 / this.a + e,
            h = l(g, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(h) - m) <= n) return a.x = this.long0, a.y = m, 0 > e && (a.y *= -1), a;
          var o = i(this.a, this.e, Math.sin(h)),
            p = o * o * o / this.a / this.a * (1 - this.es),
            q = Math.pow(Math.tan(h), 2),
            r = d * this.a / o,
            s = r * r;
          b = h - o * Math.tan(h) / p * r * r * (.5 - (1 + 3 * q) * r * r / 24), c = r * (1 - s * (q / 3 + (1 + 3 * q) * q * s / 15)) / Math.cos(h)
        }
        return a.x = j(c + this.long0), a.y = k(b), a
      }, c.names = ["Cassini", "Cassini_Soldner", "cass"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/imlfn": 12,
      "../common/mlfn": 14
    }],
    43: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/qsfnz"),
        f = a("../common/msfnz"),
        g = a("../common/iqsfnz");
      c.init = function() {
        this.sphere || (this.k0 = f(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)))
      }, c.forward = function(a) {
        var b, c, f = a.x,
          g = a.y,
          h = d(f - this.long0);
        if (this.sphere) b = this.x0 + this.a * h * Math.cos(this.lat_ts), c = this.y0 + this.a * Math.sin(g) / Math.cos(this.lat_ts);
        else {
          var i = e(this.e, Math.sin(g));
          b = this.x0 + this.a * this.k0 * h, c = this.y0 + this.a * i * .5 / this.k0
        }
        return a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c;
        return this.sphere ? (b = d(this.long0 + a.x / this.a / Math.cos(this.lat_ts)), c = Math.asin(a.y / this.a * Math.cos(this.lat_ts))) : (c = g(this.e, 2 * a.y * this.k0 / this.a), b = d(this.long0 + a.x / (this.a * this.k0))), a.x = b, a.y = c, a
      }, c.names = ["cea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/iqsfnz": 13,
      "../common/msfnz": 15,
      "../common/qsfnz": 20
    }],
    44: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/adjust_lat");
      c.init = function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y,
          f = d(b - this.long0),
          g = e(c - this.lat0);
        return a.x = this.x0 + this.a * f * this.rc, a.y = this.y0 + this.a * g, a
      }, c.inverse = function(a) {
        var b = a.x,
          c = a.y;
        return a.x = d(this.long0 + (b - this.x0) / (this.a * this.rc)), a.y = e(this.lat0 + (c - this.y0) / this.a), a
      }, c.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5
    }],
    45: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/msfnz"),
        i = a("../common/mlfn"),
        j = a("../common/adjust_lon"),
        k = a("../common/adjust_lat"),
        l = a("../common/imlfn"),
        m = 1e-10;
      c.init = function() {
        Math.abs(this.lat1 + this.lat2) < m || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = h(this.e, this.sinphi, this.cosphi), this.ml1 = i(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < m ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = h(this.e, this.sinphi, this.cosphi), this.ml2 = i(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = i(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0))
      }, c.forward = function(a) {
        var b, c = a.x,
          d = a.y;
        if (this.sphere) b = this.a * (this.g - d);
        else {
          var e = i(this.e0, this.e1, this.e2, this.e3, d);
          b = this.a * (this.g - e)
        }
        var f = this.ns * j(c - this.long0),
          g = this.x0 + b * Math.sin(f),
          h = this.y0 + this.rh - b * Math.cos(f);
        return a.x = g, a.y = h, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y = this.rh - a.y + this.y0;
        var b, c, d, e;
        this.ns >= 0 ? (c = Math.sqrt(a.x * a.x + a.y * a.y), b = 1) : (c = -Math.sqrt(a.x * a.x + a.y * a.y), b = -1);
        var f = 0;
        if (0 !== c && (f = Math.atan2(b * a.x, b * a.y)), this.sphere) return e = j(this.long0 + f / this.ns), d = k(this.g - c / this.a), a.x = e, a.y = d, a;
        var g = this.g - c / this.a;
        return d = l(g, this.e0, this.e1, this.e2, this.e3), e = j(this.long0 + f / this.ns), a.x = e, a.y = d, a
      }, c.names = ["Equidistant_Conic", "eqdc"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/imlfn": 12,
      "../common/mlfn": 14,
      "../common/msfnz": 15
    }],
    46: [function(a, b, c) {
      var d = Math.PI / 4,
        e = a("../common/srat"),
        f = Math.PI / 2,
        g = 20;
      c.init = function() {
        var a = Math.sin(this.lat0),
          b = Math.cos(this.lat0);
        b *= b, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * a * a), this.C = Math.sqrt(1 + this.es * b * b / (1 - this.es)), this.phic0 = Math.asin(a / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + d) / (Math.pow(Math.tan(.5 * this.lat0 + d), this.C) * e(this.e * a, this.ratexp))
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        return a.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * c + d), this.C) * e(this.e * Math.sin(c), this.ratexp)) - f, a.x = this.C * b, a
      }, c.inverse = function(a) {
        for (var b = 1e-14, c = a.x / this.C, h = a.y, i = Math.pow(Math.tan(.5 * h + d) / this.K, 1 / this.C), j = g; j > 0 && (h = 2 * Math.atan(i * e(this.e * Math.sin(a.y), -.5 * this.e)) - f, !(Math.abs(h - a.y) < b)); --j) a.y = h;
        return j ? (a.x = c, a.y = h, a) : null
      }, c.names = ["gauss"]
    }, {
      "../common/srat": 22
    }],
    47: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = 1e-10,
        f = a("../common/asinz");
      c.init = function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0),
          this.infinity_dist = 1e3 * this.a, this.rc = 1
      }, c.forward = function(a) {
        var b, c, f, g, h, i, j, k, l = a.x,
          m = a.y;
        return f = d(l - this.long0), b = Math.sin(m), c = Math.cos(m), g = Math.cos(f), i = this.sin_p14 * b + this.cos_p14 * c * g, h = 1, i > 0 || Math.abs(i) <= e ? (j = this.x0 + this.a * h * c * Math.sin(f) / i, k = this.y0 + this.a * h * (this.cos_p14 * b - this.sin_p14 * c * g) / i) : (j = this.x0 + this.infinity_dist * c * Math.sin(f), k = this.y0 + this.infinity_dist * (this.cos_p14 * b - this.sin_p14 * c * g)), a.x = j, a.y = k, a
      }, c.inverse = function(a) {
        var b, c, e, g, h, i;
        return a.x = (a.x - this.x0) / this.a, a.y = (a.y - this.y0) / this.a, a.x /= this.k0, a.y /= this.k0, (b = Math.sqrt(a.x * a.x + a.y * a.y)) ? (g = Math.atan2(b, this.rc), c = Math.sin(g), e = Math.cos(g), i = f(e * this.sin_p14 + a.y * c * this.cos_p14 / b), h = Math.atan2(a.x * c, b * this.cos_p14 * e - a.y * this.sin_p14 * c), h = d(this.long0 + h)) : (i = this.phic0, h = 0), a.x = h, a.y = i, a
      }, c.names = ["gnom"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6
    }],
    48: [function(a, b, c) {
      var d = a("../common/adjust_lon");
      c.init = function() {
        this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq
      }, c.forward = function(a) {
        var b, c, e, f, g, h, i, j = a.x,
          k = a.y,
          l = d(j - this.long0);
        return b = Math.pow((1 + this.e * Math.sin(k)) / (1 - this.e * Math.sin(k)), this.alfa * this.e / 2), c = 2 * (Math.atan(this.k * Math.pow(Math.tan(k / 2 + this.s45), this.alfa) / b) - this.s45), e = -l * this.alfa, f = Math.asin(Math.cos(this.ad) * Math.sin(c) + Math.sin(this.ad) * Math.cos(c) * Math.cos(e)), g = Math.asin(Math.cos(c) * Math.sin(e) / Math.cos(f)), h = this.n * g, i = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(f / 2 + this.s45), this.n), a.y = i * Math.cos(h) / 1, a.x = i * Math.sin(h) / 1, this.czech || (a.y *= -1, a.x *= -1), a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, h, i, j = a.x;
        a.x = a.y, a.y = j, this.czech || (a.y *= -1, a.x *= -1), g = Math.sqrt(a.x * a.x + a.y * a.y), f = Math.atan2(a.y, a.x), e = f / Math.sin(this.s0), d = 2 * (Math.atan(Math.pow(this.ro0 / g, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), b = Math.asin(Math.cos(this.ad) * Math.sin(d) - Math.sin(this.ad) * Math.cos(d) * Math.cos(e)), c = Math.asin(Math.cos(d) * Math.sin(e) / Math.cos(b)), a.x = this.long0 - c / this.alfa, h = b, i = 0;
        var k = 0;
        do a.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(b / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.e / 2)) - this.s45), Math.abs(h - a.y) < 1e-10 && (i = 1), h = a.y, k += 1; while (0 === i && 15 > k);
        return k >= 15 ? null : a
      }, c.names = ["Krovak", "krovak"]
    }, {
      "../common/adjust_lon": 5
    }],
    49: [function(a, b, c) {
      var d = Math.PI / 2,
        e = Math.PI / 4,
        f = 1e-10,
        g = a("../common/qsfnz"),
        h = a("../common/adjust_lon");
      c.S_POLE = 1, c.N_POLE = 2, c.EQUIT = 3, c.OBLIQ = 4, c.init = function() {
        var a = Math.abs(this.lat0);
        if (Math.abs(a - d) < f ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(a) < f ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
          var b;
          switch (this.qp = g(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = this.authset(this.es), this.mode) {
            case this.N_POLE:
              this.dd = 1;
              break;
            case this.S_POLE:
              this.dd = 1;
              break;
            case this.EQUIT:
              this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp;
              break;
            case this.OBLIQ:
              this.rq = Math.sqrt(.5 * this.qp), b = Math.sin(this.lat0), this.sinb1 = g(this.e, b) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * b * b) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd
          }
        } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0))
      }, c.forward = function(a) {
        var b, c, i, j, k, l, m, n, o, p, q = a.x,
          r = a.y;
        if (q = h(q - this.long0), this.sphere) {
          if (k = Math.sin(r), p = Math.cos(r), i = Math.cos(q), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (c = this.mode === this.EQUIT ? 1 + p * i : 1 + this.sinph0 * k + this.cosph0 * p * i, f >= c) return null;
            c = Math.sqrt(2 / c), b = c * p * Math.sin(q), c *= this.mode === this.EQUIT ? k : this.cosph0 * k - this.sinph0 * p * i
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (i = -i), Math.abs(r + this.phi0) < f) return null;
            c = e - .5 * r, c = 2 * (this.mode === this.S_POLE ? Math.cos(c) : Math.sin(c)), b = c * Math.sin(q), c *= i
          }
        } else {
          switch (m = 0, n = 0, o = 0, i = Math.cos(q), j = Math.sin(q), k = Math.sin(r), l = g(this.e, k), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = l / this.qp, n = Math.sqrt(1 - m * m)), this.mode) {
            case this.OBLIQ:
              o = 1 + this.sinb1 * m + this.cosb1 * n * i;
              break;
            case this.EQUIT:
              o = 1 + n * i;
              break;
            case this.N_POLE:
              o = d + r, l = this.qp - l;
              break;
            case this.S_POLE:
              o = r - d, l = this.qp + l
          }
          if (Math.abs(o) < f) return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              o = Math.sqrt(2 / o), c = this.mode === this.OBLIQ ? this.ymf * o * (this.cosb1 * m - this.sinb1 * n * i) : (o = Math.sqrt(2 / (1 + n * i))) * m * this.ymf, b = this.xmf * o * n * j;
              break;
            case this.N_POLE:
            case this.S_POLE:
              l >= 0 ? (b = (o = Math.sqrt(l)) * j, c = i * (this.mode === this.S_POLE ? o : -o)) : b = c = 0
          }
        }
        return a.x = this.a * b + this.x0, a.y = this.a * c + this.y0, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, e, g, i, j, k, l = a.x / this.a,
          m = a.y / this.a;
        if (this.sphere) {
          var n, o = 0,
            p = 0;
          if (n = Math.sqrt(l * l + m * m), c = .5 * n, c > 1) return null;
          switch (c = 2 * Math.asin(c), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (p = Math.sin(c), o = Math.cos(c)), this.mode) {
            case this.EQUIT:
              c = Math.abs(n) <= f ? 0 : Math.asin(m * p / n), l *= p, m = o * n;
              break;
            case this.OBLIQ:
              c = Math.abs(n) <= f ? this.phi0 : Math.asin(o * this.sinph0 + m * p * this.cosph0 / n), l *= p * this.cosph0, m = (o - Math.sin(c) * this.sinph0) * n;
              break;
            case this.N_POLE:
              m = -m, c = d - c;
              break;
            case this.S_POLE:
              c -= d
          }
          b = 0 !== m || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(l, m) : 0
        } else {
          if (k = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (l /= this.dd, m *= this.dd, j = Math.sqrt(l * l + m * m), f > j) return a.x = 0, a.y = this.phi0, a;
            g = 2 * Math.asin(.5 * j / this.rq), e = Math.cos(g), l *= g = Math.sin(g), this.mode === this.OBLIQ ? (k = e * this.sinb1 + m * g * this.cosb1 / j, i = this.qp * k, m = j * this.cosb1 * e - m * this.sinb1 * g) : (k = m * g / j, i = this.qp * k, m = j * e)
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (m = -m), i = l * l + m * m, !i) return a.x = 0, a.y = this.phi0, a;
            k = 1 - i / this.qp, this.mode === this.S_POLE && (k = -k)
          }
          b = Math.atan2(l, m), c = this.authlat(Math.asin(k), this.apa)
        }
        return a.x = h(this.long0 + b), a.y = c, a
      }, c.P00 = .3333333333333333, c.P01 = .17222222222222222, c.P02 = .10257936507936508, c.P10 = .06388888888888888, c.P11 = .0664021164021164, c.P20 = .016415012942191543, c.authset = function(a) {
        var b, c = [];
        return c[0] = a * this.P00, b = a * a, c[0] += b * this.P01, c[1] = b * this.P10, b *= a, c[0] += b * this.P02, c[1] += b * this.P11, c[2] = b * this.P20, c
      }, c.authlat = function(a, b) {
        var c = a + a;
        return a + b[0] * Math.sin(c) + b[1] * Math.sin(c + c) + b[2] * Math.sin(c + c + c)
      }, c.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"]
    }, {
      "../common/adjust_lon": 5,
      "../common/qsfnz": 20
    }],
    50: [function(a, b, c) {
      var d = 1e-10,
        e = a("../common/msfnz"),
        f = a("../common/tsfnz"),
        g = Math.PI / 2,
        h = a("../common/sign"),
        i = a("../common/adjust_lon"),
        j = a("../common/phi2z");
      c.init = function() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < d)) {
          var a = this.b / this.a;
          this.e = Math.sqrt(1 - a * a);
          var b = Math.sin(this.lat1),
            c = Math.cos(this.lat1),
            g = e(this.e, b, c),
            h = f(this.e, this.lat1, b),
            i = Math.sin(this.lat2),
            j = Math.cos(this.lat2),
            k = e(this.e, i, j),
            l = f(this.e, this.lat2, i),
            m = f(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > d ? this.ns = Math.log(g / k) / Math.log(h / l) : this.ns = b, isNaN(this.ns) && (this.ns = b), this.f0 = g / (this.ns * Math.pow(h, this.ns)), this.rh = this.a * this.f0 * Math.pow(m, this.ns), this.title || (this.title = "Lambert Conformal Conic")
        }
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        Math.abs(2 * Math.abs(c) - Math.PI) <= d && (c = h(c) * (g - 2 * d));
        var e, j, k = Math.abs(Math.abs(c) - g);
        if (k > d) e = f(this.e, c, Math.sin(c)), j = this.a * this.f0 * Math.pow(e, this.ns);
        else {
          if (k = c * this.ns, 0 >= k) return null;
          j = 0
        }
        var l = this.ns * i(b - this.long0);
        return a.x = this.k0 * (j * Math.sin(l)) + this.x0, a.y = this.k0 * (this.rh - j * Math.cos(l)) + this.y0, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, h = (a.x - this.x0) / this.k0,
          k = this.rh - (a.y - this.y0) / this.k0;
        this.ns > 0 ? (b = Math.sqrt(h * h + k * k), c = 1) : (b = -Math.sqrt(h * h + k * k), c = -1);
        var l = 0;
        if (0 !== b && (l = Math.atan2(c * h, c * k)), 0 !== b || this.ns > 0) {
          if (c = 1 / this.ns, d = Math.pow(b / (this.a * this.f0), c), e = j(this.e, d), -9999 === e) return null
        } else e = -g;
        return f = i(l / this.ns + this.long0), a.x = f, a.y = e, a
      }, c.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/sign": 21,
      "../common/tsfnz": 24
    }],
    51: [function(a, b, c) {
      function d(a) {
        return a
      }
      c.init = function() {}, c.forward = d, c.inverse = d, c.names = ["longlat", "identity"]
    }, {}],
    52: [function(a, b, c) {
      var d = a("../common/msfnz"),
        e = Math.PI / 2,
        f = 1e-10,
        g = 57.29577951308232,
        h = a("../common/adjust_lon"),
        i = Math.PI / 4,
        j = a("../common/tsfnz"),
        k = a("../common/phi2z");
      c.init = function() {
        var a = this.b / this.a;
        this.es = 1 - a * a, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = d(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1)
      }, c.forward = function(a) {
        var b = a.x,
          c = a.y;
        if (c * g > 90 && -90 > c * g && b * g > 180 && -180 > b * g) return null;
        var d, k;
        if (Math.abs(Math.abs(c) - e) <= f) return null;
        if (this.sphere) d = this.x0 + this.a * this.k0 * h(b - this.long0), k = this.y0 + this.a * this.k0 * Math.log(Math.tan(i + .5 * c));
        else {
          var l = Math.sin(c),
            m = j(this.e, c, l);
          d = this.x0 + this.a * this.k0 * h(b - this.long0), k = this.y0 - this.a * this.k0 * Math.log(m)
        }
        return a.x = d, a.y = k, a
      }, c.inverse = function(a) {
        var b, c, d = a.x - this.x0,
          f = a.y - this.y0;
        if (this.sphere) c = e - 2 * Math.atan(Math.exp(-f / (this.a * this.k0)));
        else {
          var g = Math.exp(-f / (this.a * this.k0));
          if (c = k(this.e, g), -9999 === c) return null
        }
        return b = h(this.long0 + d / (this.a * this.k0)), a.x = b, a.y = c, a
      }, c.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/tsfnz": 24
    }],
    53: [function(a, b, c) {
      var d = a("../common/adjust_lon");
      c.init = function() {}, c.forward = function(a) {
        var b = a.x,
          c = a.y,
          e = d(b - this.long0),
          f = this.x0 + this.a * e,
          g = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + c / 2.5)) * 1.25;
        return a.x = f, a.y = g, a
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b = d(this.long0 + a.x / this.a),
          c = 2.5 * (Math.atan(Math.exp(.8 * a.y / this.a)) - Math.PI / 4);
        return a.x = b, a.y = c, a
      }, c.names = ["Miller_Cylindrical", "mill"]
    }, {
      "../common/adjust_lon": 5
    }],
    54: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = 1e-10;
      c.init = function() {}, c.forward = function(a) {
        for (var b = a.x, c = a.y, f = d(b - this.long0), g = c, h = Math.PI * Math.sin(c), i = 0; !0; i++) {
          var j = -(g + Math.sin(g) - h) / (1 + Math.cos(g));
          if (g += j, Math.abs(j) < e) break
        }
        g /= 2, Math.PI / 2 - Math.abs(c) < e && (f = 0);
        var k = .900316316158 * this.a * f * Math.cos(g) + this.x0,
          l = 1.4142135623731 * this.a * Math.sin(g) + this.y0;
        return a.x = k, a.y = l, a
      }, c.inverse = function(a) {
        var b, c;
        a.x -= this.x0, a.y -= this.y0, c = a.y / (1.4142135623731 * this.a), Math.abs(c) > .999999999999 && (c = .999999999999), b = Math.asin(c);
        var e = d(this.long0 + a.x / (.900316316158 * this.a * Math.cos(b)));
        e < -Math.PI && (e = -Math.PI), e > Math.PI && (e = Math.PI), c = (2 * b + Math.sin(2 * b)) / Math.PI, Math.abs(c) > 1 && (c = 1);
        var f = Math.asin(c);
        return a.x = e, a.y = f, a
      }, c.names = ["Mollweide", "moll"]
    }, {
      "../common/adjust_lon": 5
    }],
    55: [function(a, b, c) {
      var d = 484813681109536e-20;
      c.iterations = 1, c.init = function() {
        this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013
      }, c.forward = function(a) {
        var b, c = a.x,
          e = a.y,
          f = e - this.lat0,
          g = c - this.long0,
          h = f / d * 1e-5,
          i = g,
          j = 1,
          k = 0;
        for (b = 1; 10 >= b; b++) j *= h, k += this.A[b] * j;
        var l, m, n = k,
          o = i,
          p = 1,
          q = 0,
          r = 0,
          s = 0;
        for (b = 1; 6 >= b; b++) l = p * n - q * o, m = q * n + p * o, p = l, q = m, r = r + this.B_re[b] * p - this.B_im[b] * q, s = s + this.B_im[b] * p + this.B_re[b] * q;
        return a.x = s * this.a + this.x0, a.y = r * this.a + this.y0, a
      }, c.inverse = function(a) {
        var b, c, e, f = a.x,
          g = a.y,
          h = f - this.x0,
          i = g - this.y0,
          j = i / this.a,
          k = h / this.a,
          l = 1,
          m = 0,
          n = 0,
          o = 0;
        for (b = 1; 6 >= b; b++) c = l * j - m * k, e = m * j + l * k, l = c, m = e, n = n + this.C_re[b] * l - this.C_im[b] * m, o = o + this.C_im[b] * l + this.C_re[b] * m;
        for (var p = 0; p < this.iterations; p++) {
          var q, r, s = n,
            t = o,
            u = j,
            v = k;
          for (b = 2; 6 >= b; b++) q = s * n - t * o, r = t * n + s * o, s = q, t = r, u += (b - 1) * (this.B_re[b] * s - this.B_im[b] * t), v += (b - 1) * (this.B_im[b] * s + this.B_re[b] * t);
          s = 1, t = 0;
          var w = this.B_re[1],
            x = this.B_im[1];
          for (b = 2; 6 >= b; b++) q = s * n - t * o, r = t * n + s * o, s = q, t = r, w += b * (this.B_re[b] * s - this.B_im[b] * t), x += b * (this.B_im[b] * s + this.B_re[b] * t);
          var y = w * w + x * x;
          n = (u * w + v * x) / y, o = (v * w - u * x) / y
        }
        var z = n,
          A = o,
          B = 1,
          C = 0;
        for (b = 1; 9 >= b; b++) B *= z, C += this.D[b] * B;
        var D = this.lat0 + C * d * 1e5,
          E = this.long0 + A;
        return a.x = E, a.y = D, a
      }, c.names = ["New_Zealand_Map_Grid", "nzmg"]
    }, {}],
    56: [function(a, b, c) {
      var d = a("../common/tsfnz"),
        e = a("../common/adjust_lon"),
        f = a("../common/phi2z"),
        g = Math.PI / 2,
        h = Math.PI / 4,
        i = 1e-10;
      c.init = function() {
        this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0) && (this.k0 = 1);
        var a = Math.sin(this.lat0),
          b = Math.cos(this.lat0),
          c = this.e * a;
        this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(b, 4)), this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - c * c);
        var f = d(this.e, this.lat0, a),
          g = this.bl / b * Math.sqrt((1 - this.es) / (1 - c * c));
        1 > g * g && (g = 1);
        var h, i;
        if (isNaN(this.longc)) {
          var j = d(this.e, this.lat1, Math.sin(this.lat1)),
            k = d(this.e, this.lat2, Math.sin(this.lat2));
          this.lat0 >= 0 ? this.el = (g + Math.sqrt(g * g - 1)) * Math.pow(f, this.bl) : this.el = (g - Math.sqrt(g * g - 1)) * Math.pow(f, this.bl);
          var l = Math.pow(j, this.bl),
            m = Math.pow(k, this.bl);
          h = this.el / l, i = .5 * (h - 1 / h);
          var n = (this.el * this.el - m * l) / (this.el * this.el + m * l),
            o = (m - l) / (m + l),
            p = e(this.long1 - this.long2);
          this.long0 = .5 * (this.long1 + this.long2) - Math.atan(n * Math.tan(.5 * this.bl * p) / o) / this.bl, this.long0 = e(this.long0);
          var q = e(this.long1 - this.long0);
          this.gamma0 = Math.atan(Math.sin(this.bl * q) / i), this.alpha = Math.asin(g * Math.sin(this.gamma0))
        } else h = this.lat0 >= 0 ? g + Math.sqrt(g * g - 1) : g - Math.sqrt(g * g - 1), this.el = h * Math.pow(f, this.bl), i = .5 * (h - 1 / h), this.gamma0 = Math.asin(Math.sin(this.alpha) / g), this.long0 = this.longc - Math.asin(i * Math.tan(this.gamma0)) / this.bl;
        this.no_off ? this.uc = 0 : this.lat0 >= 0 ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(g * g - 1), Math.cos(this.alpha)) : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(g * g - 1), Math.cos(this.alpha))
      }, c.forward = function(a) {
        var b, c, f, j = a.x,
          k = a.y,
          l = e(j - this.long0);
        if (Math.abs(Math.abs(k) - g) <= i) f = k > 0 ? -1 : 1, c = this.al / this.bl * Math.log(Math.tan(h + f * this.gamma0 * .5)), b = -1 * f * g * this.al / this.bl;
        else {
          var m = d(this.e, k, Math.sin(k)),
            n = this.el / Math.pow(m, this.bl),
            o = .5 * (n - 1 / n),
            p = .5 * (n + 1 / n),
            q = Math.sin(this.bl * l),
            r = (o * Math.sin(this.gamma0) - q * Math.cos(this.gamma0)) / p;
          c = Math.abs(Math.abs(r) - 1) <= i ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - r) / (1 + r)) / this.bl, b = Math.abs(Math.cos(this.bl * l)) <= i ? this.al * this.bl * l : this.al * Math.atan2(o * Math.cos(this.gamma0) + q * Math.sin(this.gamma0), Math.cos(this.bl * l)) / this.bl
        }
        return this.no_rot ? (a.x = this.x0 + b, a.y = this.y0 + c) : (b -= this.uc, a.x = this.x0 + c * Math.cos(this.alpha) + b * Math.sin(this.alpha), a.y = this.y0 + b * Math.cos(this.alpha) - c * Math.sin(this.alpha)), a
      }, c.inverse = function(a) {
        var b, c;
        this.no_rot ? (c = a.y - this.y0, b = a.x - this.x0) : (c = (a.x - this.x0) * Math.cos(this.alpha) - (a.y - this.y0) * Math.sin(this.alpha), b = (a.y - this.y0) * Math.cos(this.alpha) + (a.x - this.x0) * Math.sin(this.alpha), b += this.uc);
        var d = Math.exp(-1 * this.bl * c / this.al),
          h = .5 * (d - 1 / d),
          j = .5 * (d + 1 / d),
          k = Math.sin(this.bl * b / this.al),
          l = (k * Math.cos(this.gamma0) + h * Math.sin(this.gamma0)) / j,
          m = Math.pow(this.el / Math.sqrt((1 + l) / (1 - l)), 1 / this.bl);
        return Math.abs(l - 1) < i ? (a.x = this.long0, a.y = g) : Math.abs(l + 1) < i ? (a.x = this.long0, a.y = -1 * g) : (a.y = f(this.e, m), a.x = e(this.long0 - Math.atan2(h * Math.cos(this.gamma0) - k * Math.sin(this.gamma0), Math.cos(this.bl * b / this.al)) / this.bl)), a
      }, c.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/phi2z": 16,
      "../common/tsfnz": 24
    }],
    57: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/adjust_lon"),
        i = a("../common/adjust_lat"),
        j = a("../common/mlfn"),
        k = 1e-10,
        l = a("../common/gN"),
        m = 20;
      c.init = function() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.ml0 = this.a * j(this.e0, this.e1, this.e2, this.e3, this.lat0)
      }, c.forward = function(a) {
        var b, c, d, e = a.x,
          f = a.y,
          g = h(e - this.long0);
        if (d = g * Math.sin(f), this.sphere) Math.abs(f) <= k ? (b = this.a * g, c = -1 * this.a * this.lat0) : (b = this.a * Math.sin(d) / Math.tan(f), c = this.a * (i(f - this.lat0) + (1 - Math.cos(d)) / Math.tan(f)));
        else if (Math.abs(f) <= k) b = this.a * g, c = -1 * this.ml0;
        else {
          var m = l(this.a, this.e, Math.sin(f)) / Math.tan(f);
          b = m * Math.sin(d), c = this.a * j(this.e0, this.e1, this.e2, this.e3, f) - this.ml0 + m * (1 - Math.cos(d))
        }
        return a.x = b + this.x0, a.y = c + this.y0, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, i, l, n;
        if (d = a.x - this.x0, e = a.y - this.y0, this.sphere)
          if (Math.abs(e + this.a * this.lat0) <= k) b = h(d / this.a + this.long0), c = 0;
          else {
            g = this.lat0 + e / this.a, i = d * d / this.a / this.a + g * g, l = g;
            var o;
            for (f = m; f; --f)
              if (o = Math.tan(l), n = -1 * (g * (l * o + 1) - l - .5 * (l * l + i) * o) / ((l - g) / o - 1), l += n, Math.abs(n) <= k) {
                c = l;
                break
              } b = h(this.long0 + Math.asin(d * Math.tan(l) / this.a) / Math.sin(c))
          }
        else if (Math.abs(e + this.ml0) <= k) c = 0, b = h(this.long0 + d / this.a);
        else {
          g = (this.ml0 + e) / this.a, i = d * d / this.a / this.a + g * g, l = g;
          var p, q, r, s, t;
          for (f = m; f; --f)
            if (t = this.e * Math.sin(l), p = Math.sqrt(1 - t * t) * Math.tan(l), q = this.a * j(this.e0, this.e1, this.e2, this.e3, l), r = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), s = q / this.a, n = (g * (p * s + 1) - s - .5 * p * (s * s + i)) / (this.es * Math.sin(2 * l) * (s * s + i - 2 * g * s) / (4 * p) + (g - s) * (p * r - 2 / Math.sin(2 * l)) - r), l -= n, Math.abs(n) <= k) {
              c = l;
              break
            } p = Math.sqrt(1 - this.es * Math.pow(Math.sin(c), 2)) * Math.tan(c), b = h(this.long0 + Math.asin(d * p / this.a) / Math.sin(c))
        }
        return a.x = b, a.y = c, a
      }, c.names = ["Polyconic", "poly"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/gN": 11,
      "../common/mlfn": 14
    }],
    58: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = a("../common/adjust_lat"),
        f = a("../common/pj_enfn"),
        g = 20,
        h = a("../common/pj_mlfn"),
        i = a("../common/pj_inv_mlfn"),
        j = Math.PI / 2,
        k = 1e-10,
        l = a("../common/asinz");
      c.init = function() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = f(this.es)
      }, c.forward = function(a) {
        var b, c, e = a.x,
          f = a.y;
        if (e = d(e - this.long0), this.sphere) {
          if (this.m)
            for (var i = this.n * Math.sin(f), j = g; j; --j) {
              var l = (this.m * f + Math.sin(f) - i) / (this.m + Math.cos(f));
              if (f -= l, Math.abs(l) < k) break
            } else f = 1 !== this.n ? Math.asin(this.n * Math.sin(f)) : f;
          b = this.a * this.C_x * e * (this.m + Math.cos(f)), c = this.a * this.C_y * f
        } else {
          var m = Math.sin(f),
            n = Math.cos(f);
          c = this.a * h(f, m, n, this.en), b = this.a * e * n / Math.sqrt(1 - this.es * m * m)
        }
        return a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        var b, c, f, g;
        return a.x -= this.x0, f = a.x / this.a, a.y -= this.y0, b = a.y / this.a, this.sphere ? (b /= this.C_y, f /= this.C_x * (this.m + Math.cos(b)), this.m ? b = l((this.m * b + Math.sin(b)) / this.n) : 1 !== this.n && (b = l(Math.sin(b) / this.n)), f = d(f + this.long0), b = e(b)) : (b = i(a.y / this.a, this.es, this.en), g = Math.abs(b), j > g ? (g = Math.sin(b), c = this.long0 + a.x * Math.sqrt(1 - this.es * g * g) / (this.a * Math.cos(b)), f = d(c)) : j > g - k && (f = this.long0)), a.x = f, a.y = b, a
      }, c.names = ["Sinusoidal", "sinu"]
    }, {
      "../common/adjust_lat": 4,
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/pj_enfn": 17,
      "../common/pj_inv_mlfn": 18,
      "../common/pj_mlfn": 19
    }],
    59: [function(a, b, c) {
      c.init = function() {
        var a = this.lat0;
        this.lambda0 = this.long0;
        var b = Math.sin(a),
          c = this.a,
          d = this.rf,
          e = 1 / d,
          f = 2 * e - Math.pow(e, 2),
          g = this.e = Math.sqrt(f);
        this.R = this.k0 * c * Math.sqrt(1 - f) / (1 - f * Math.pow(b, 2)), this.alpha = Math.sqrt(1 + f / (1 - f) * Math.pow(Math.cos(a), 4)), this.b0 = Math.asin(b / this.alpha);
        var h = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
          i = Math.log(Math.tan(Math.PI / 4 + a / 2)),
          j = Math.log((1 + g * b) / (1 - g * b));
        this.K = h - this.alpha * i + this.alpha * g / 2 * j
      }, c.forward = function(a) {
        var b = Math.log(Math.tan(Math.PI / 4 - a.y / 2)),
          c = this.e / 2 * Math.log((1 + this.e * Math.sin(a.y)) / (1 - this.e * Math.sin(a.y))),
          d = -this.alpha * (b + c) + this.K,
          e = 2 * (Math.atan(Math.exp(d)) - Math.PI / 4),
          f = this.alpha * (a.x - this.lambda0),
          g = Math.atan(Math.sin(f) / (Math.sin(this.b0) * Math.tan(e) + Math.cos(this.b0) * Math.cos(f))),
          h = Math.asin(Math.cos(this.b0) * Math.sin(e) - Math.sin(this.b0) * Math.cos(e) * Math.cos(f));
        return a.y = this.R / 2 * Math.log((1 + Math.sin(h)) / (1 - Math.sin(h))) + this.y0, a.x = this.R * g + this.x0, a
      }, c.inverse = function(a) {
        for (var b = a.x - this.x0, c = a.y - this.y0, d = b / this.R, e = 2 * (Math.atan(Math.exp(c / this.R)) - Math.PI / 4), f = Math.asin(Math.cos(this.b0) * Math.sin(e) + Math.sin(this.b0) * Math.cos(e) * Math.cos(d)), g = Math.atan(Math.sin(d) / (Math.cos(this.b0) * Math.cos(d) - Math.sin(this.b0) * Math.tan(e))), h = this.lambda0 + g / this.alpha, i = 0, j = f, k = -1e3, l = 0; Math.abs(j - k) > 1e-7;) {
          if (++l > 20) return;
          i = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + f / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(j)) / 2)), k = j, j = 2 * Math.atan(Math.exp(i)) - Math.PI / 2
        }
        return a.x = h, a.y = j, a
      }, c.names = ["somerc"]
    }, {}],
    60: [function(a, b, c) {
      var d = Math.PI / 2,
        e = 1e-10,
        f = a("../common/sign"),
        g = a("../common/msfnz"),
        h = a("../common/tsfnz"),
        i = a("../common/phi2z"),
        j = a("../common/adjust_lon");
      c.ssfn_ = function(a, b, c) {
        return b *= c, Math.tan(.5 * (d + a)) * Math.pow((1 - b) / (1 + b), .5 * c)
      }, c.init = function() {
        this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= e && (this.k0 = .5 * (1 + f(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= e && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= e && (this.k0 = .5 * this.cons * g(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / h(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = g(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - d, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0))
      }, c.forward = function(a) {
        var b, c, f, g, i, k, l = a.x,
          m = a.y,
          n = Math.sin(m),
          o = Math.cos(m),
          p = j(l - this.long0);
        return Math.abs(Math.abs(l - this.long0) - Math.PI) <= e && Math.abs(m + this.lat0) <= e ? (a.x = NaN, a.y = NaN, a) : this.sphere ? (b = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * o * Math.cos(p)), a.x = this.a * b * o * Math.sin(p) + this.x0, a.y = this.a * b * (this.coslat0 * n - this.sinlat0 * o * Math.cos(p)) + this.y0, a) : (c = 2 * Math.atan(this.ssfn_(m, n, this.e)) - d, g = Math.cos(c), f = Math.sin(c), Math.abs(this.coslat0) <= e ? (i = h(this.e, m * this.con, this.con * n), k = 2 * this.a * this.k0 * i / this.cons, a.x = this.x0 + k * Math.sin(l - this.long0), a.y = this.y0 - this.con * k * Math.cos(l - this.long0), a) : (Math.abs(this.sinlat0) < e ? (b = 2 * this.a * this.k0 / (1 + g * Math.cos(p)), a.y = b * f) : (b = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * f + this.cosX0 * g * Math.cos(p))), a.y = b * (this.cosX0 * f - this.sinX0 * g * Math.cos(p)) + this.y0), a.x = b * g * Math.sin(p) + this.x0, a))
      }, c.inverse = function(a) {
        a.x -= this.x0, a.y -= this.y0;
        var b, c, f, g, h, k = Math.sqrt(a.x * a.x + a.y * a.y);
        if (this.sphere) {
          var l = 2 * Math.atan(k / (.5 * this.a * this.k0));
          return b = this.long0, c = this.lat0, e >= k ? (a.x = b, a.y = c, a) : (c = Math.asin(Math.cos(l) * this.sinlat0 + a.y * Math.sin(l) * this.coslat0 / k), b = j(Math.abs(this.coslat0) < e ? this.lat0 > 0 ? this.long0 + Math.atan2(a.x, -1 * a.y) : this.long0 + Math.atan2(a.x, a.y) : this.long0 + Math.atan2(a.x * Math.sin(l), k * this.coslat0 * Math.cos(l) - a.y * this.sinlat0 * Math.sin(l))), a.x = b, a.y = c, a)
        }
        if (Math.abs(this.coslat0) <= e) {
          if (e >= k) return c = this.lat0, b = this.long0, a.x = b, a.y = c, a;
          a.x *= this.con, a.y *= this.con, f = k * this.cons / (2 * this.a * this.k0), c = this.con * i(this.e, f), b = this.con * j(this.con * this.long0 + Math.atan2(a.x, -1 * a.y))
        } else g = 2 * Math.atan(k * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), b = this.long0, e >= k ? h = this.X0 : (h = Math.asin(Math.cos(g) * this.sinX0 + a.y * Math.sin(g) * this.cosX0 / k), b = j(this.long0 + Math.atan2(a.x * Math.sin(g), k * this.cosX0 * Math.cos(g) - a.y * this.sinX0 * Math.sin(g)))), c = -1 * i(this.e, Math.tan(.5 * (d + h)));
        return a.x = b, a.y = c, a
      }, c.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"]
    }, {
      "../common/adjust_lon": 5,
      "../common/msfnz": 15,
      "../common/phi2z": 16,
      "../common/sign": 21,
      "../common/tsfnz": 24
    }],
    61: [function(a, b, c) {
      var d = a("./gauss"),
        e = a("../common/adjust_lon");
      c.init = function() {
        d.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"))
      }, c.forward = function(a) {
        var b, c, f, g;
        return a.x = e(a.x - this.long0), d.forward.apply(this, [a]), b = Math.sin(a.y), c = Math.cos(a.y), f = Math.cos(a.x), g = this.k0 * this.R2 / (1 + this.sinc0 * b + this.cosc0 * c * f), a.x = g * c * Math.sin(a.x), a.y = g * (this.cosc0 * b - this.sinc0 * c * f), a.x = this.a * a.x + this.x0, a.y = this.a * a.y + this.y0, a
      }, c.inverse = function(a) {
        var b, c, f, g, h;
        if (a.x = (a.x - this.x0) / this.a, a.y = (a.y - this.y0) / this.a, a.x /= this.k0, a.y /= this.k0, h = Math.sqrt(a.x * a.x + a.y * a.y)) {
          var i = 2 * Math.atan2(h, this.R2);
          b = Math.sin(i), c = Math.cos(i), g = Math.asin(c * this.sinc0 + a.y * b * this.cosc0 / h), f = Math.atan2(a.x * b, h * this.cosc0 * c - a.y * this.sinc0 * b)
        } else g = this.phic0, f = 0;
        return a.x = f, a.y = g, d.inverse.apply(this, [a]), a.x = e(a.x + this.long0), a
      }, c.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative"]
    }, {
      "../common/adjust_lon": 5,
      "./gauss": 46
    }],
    62: [function(a, b, c) {
      var d = a("../common/e0fn"),
        e = a("../common/e1fn"),
        f = a("../common/e2fn"),
        g = a("../common/e3fn"),
        h = a("../common/mlfn"),
        i = a("../common/adjust_lon"),
        j = Math.PI / 2,
        k = 1e-10,
        l = a("../common/sign"),
        m = a("../common/asinz");
      c.init = function() {
        this.e0 = d(this.es), this.e1 = e(this.es), this.e2 = f(this.es), this.e3 = g(this.es), this.ml0 = this.a * h(this.e0, this.e1, this.e2, this.e3, this.lat0)
      }, c.forward = function(a) {
        var b, c, d, e = a.x,
          f = a.y,
          g = i(e - this.long0),
          j = Math.sin(f),
          k = Math.cos(f);
        if (this.sphere) {
          var l = k * Math.sin(g);
          if (Math.abs(Math.abs(l) - 1) < 1e-10) return 93;
          c = .5 * this.a * this.k0 * Math.log((1 + l) / (1 - l)), b = Math.acos(k * Math.cos(g) / Math.sqrt(1 - l * l)), 0 > f && (b = -b), d = this.a * this.k0 * (b - this.lat0)
        } else {
          var m = k * g,
            n = Math.pow(m, 2),
            o = this.ep2 * Math.pow(k, 2),
            p = Math.tan(f),
            q = Math.pow(p, 2);
          b = 1 - this.es * Math.pow(j, 2);
          var r = this.a / Math.sqrt(b),
            s = this.a * h(this.e0, this.e1, this.e2, this.e3, f);
          c = this.k0 * r * m * (1 + n / 6 * (1 - q + o + n / 20 * (5 - 18 * q + Math.pow(q, 2) + 72 * o - 58 * this.ep2))) + this.x0, d = this.k0 * (s - this.ml0 + r * p * (n * (.5 + n / 24 * (5 - q + 9 * o + 4 * Math.pow(o, 2) + n / 30 * (61 - 58 * q + Math.pow(q, 2) + 600 * o - 330 * this.ep2))))) + this.y0
        }
        return a.x = c, a.y = d, a
      }, c.inverse = function(a) {
        var b, c, d, e, f, g, h = 6;
        if (this.sphere) {
          var n = Math.exp(a.x / (this.a * this.k0)),
            o = .5 * (n - 1 / n),
            p = this.lat0 + a.y / (this.a * this.k0),
            q = Math.cos(p);
          b = Math.sqrt((1 - q * q) / (1 + o * o)), f = m(b), 0 > p && (f = -f), g = 0 === o && 0 === q ? this.long0 : i(Math.atan2(o, q) + this.long0)
        } else {
          var r = a.x - this.x0,
            s = a.y - this.y0;
          for (b = (this.ml0 + s / this.k0) / this.a, c = b, e = 0; !0 && (d = (b + this.e1 * Math.sin(2 * c) - this.e2 * Math.sin(4 * c) + this.e3 * Math.sin(6 * c)) / this.e0 - c, c += d, !(Math.abs(d) <= k)); e++)
            if (e >= h) return 95;
          if (Math.abs(c) < j) {
            var t = Math.sin(c),
              u = Math.cos(c),
              v = Math.tan(c),
              w = this.ep2 * Math.pow(u, 2),
              x = Math.pow(w, 2),
              y = Math.pow(v, 2),
              z = Math.pow(y, 2);
            b = 1 - this.es * Math.pow(t, 2);
            var A = this.a / Math.sqrt(b),
              B = A * (1 - this.es) / b,
              C = r / (A * this.k0),
              D = Math.pow(C, 2);
            f = c - A * v * D / B * (.5 - D / 24 * (5 + 3 * y + 10 * w - 4 * x - 9 * this.ep2 - D / 30 * (61 + 90 * y + 298 * w + 45 * z - 252 * this.ep2 - 3 * x))), g = i(this.long0 + C * (1 - D / 6 * (1 + 2 * y + w - D / 20 * (5 - 2 * w + 28 * y - 3 * x + 8 * this.ep2 + 24 * z))) / u)
          } else f = j * l(s), g = this.long0
        }
        return a.x = g, a.y = f, a
      }, c.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6,
      "../common/e0fn": 7,
      "../common/e1fn": 8,
      "../common/e2fn": 9,
      "../common/e3fn": 10,
      "../common/mlfn": 14,
      "../common/sign": 21
    }],
    63: [function(a, b, c) {
      var d = .017453292519943295,
        e = a("./tmerc");
      c.dependsOn = "tmerc", c.init = function() {
        this.zone && (this.lat0 = 0, this.long0 = (6 * Math.abs(this.zone) - 183) * d, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, e.init.apply(this), this.forward = e.forward, this.inverse = e.inverse)
      }, c.names = ["Universal Transverse Mercator System", "utm"]
    }, {
      "./tmerc": 62
    }],
    64: [function(a, b, c) {
      var d = a("../common/adjust_lon"),
        e = Math.PI / 2,
        f = 1e-10,
        g = a("../common/asinz");
      c.init = function() {
        this.R = this.a
      }, c.forward = function(a) {
        var b, c, h = a.x,
          i = a.y,
          j = d(h - this.long0);
        Math.abs(i) <= f && (b = this.x0 + this.R * j, c = this.y0);
        var k = g(2 * Math.abs(i / Math.PI));
        (Math.abs(j) <= f || Math.abs(Math.abs(i) - e) <= f) && (b = this.x0, c = i >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * k) : this.y0 + Math.PI * this.R * -Math.tan(.5 * k));
        var l = .5 * Math.abs(Math.PI / j - j / Math.PI),
          m = l * l,
          n = Math.sin(k),
          o = Math.cos(k),
          p = o / (n + o - 1),
          q = p * p,
          r = p * (2 / n - 1),
          s = r * r,
          t = Math.PI * this.R * (l * (p - s) + Math.sqrt(m * (p - s) * (p - s) - (s + m) * (q - s))) / (s + m);
        0 > j && (t = -t), b = this.x0 + t;
        var u = m + p;
        return t = Math.PI * this.R * (r * u - l * Math.sqrt((s + m) * (m + 1) - u * u)) / (s + m), c = i >= 0 ? this.y0 + t : this.y0 - t, a.x = b, a.y = c, a
      }, c.inverse = function(a) {
        var b, c, e, g, h, i, j, k, l, m, n, o, p;
        return a.x -= this.x0, a.y -= this.y0, n = Math.PI * this.R, e = a.x / n, g = a.y / n, h = e * e + g * g, i = -Math.abs(g) * (1 + h), j = i - 2 * g * g + e * e, k = -2 * i + 1 + 2 * g * g + h * h, p = g * g / k + (2 * j * j * j / k / k / k - 9 * i * j / k / k) / 27, l = (i - j * j / 3 / k) / k, m = 2 * Math.sqrt(-l / 3), n = 3 * p / l / m, Math.abs(n) > 1 && (n = n >= 0 ? 1 : -1), o = Math.acos(n) / 3, c = a.y >= 0 ? (-m * Math.cos(o + Math.PI / 3) - j / 3 / k) * Math.PI : -(-m * Math.cos(o + Math.PI / 3) - j / 3 / k) * Math.PI, b = Math.abs(e) < f ? this.long0 : d(this.long0 + Math.PI * (h - 1 + Math.sqrt(1 + 2 * (e * e - g * g) + h * h)) / 2 / e), a.x = b, a.y = c, a
      }, c.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
    }, {
      "../common/adjust_lon": 5,
      "../common/asinz": 6
    }],
    65: [function(a, b, c) {
      var d = .017453292519943295,
        e = 57.29577951308232,
        f = 1,
        g = 2,
        h = a("./datum_transform"),
        i = a("./adjust_axis"),
        j = a("./Proj"),
        k = a("./common/toPoint");
      b.exports = function l(a, b, c) {
        function m(a, b) {
          return (a.datum.datum_type === f || a.datum.datum_type === g) && "WGS84" !== b.datumCode
        }
        var n;
        return Array.isArray(c) && (c = k(c)), a.datum && b.datum && (m(a, b) || m(b, a)) && (n = new j("WGS84"), l(a, n, c), a = n), "enu" !== a.axis && i(a, !1, c), "longlat" === a.projName ? (c.x *= d, c.y *= d) : (a.to_meter && (c.x *= a.to_meter, c.y *= a.to_meter), a.inverse(c)), a.from_greenwich && (c.x += a.from_greenwich), c = h(a.datum, b.datum, c), b.from_greenwich && (c.x -= b.from_greenwich), "longlat" === b.projName ? (c.x *= e, c.y *= e) : (b.forward(c), b.to_meter && (c.x /= b.to_meter, c.y /= b.to_meter)), "enu" !== b.axis && i(b, !0, c), c
      }
    }, {
      "./Proj": 2,
      "./adjust_axis": 3,
      "./common/toPoint": 23,
      "./datum_transform": 31
    }],
    66: [function(a, b, c) {
      function d(a, b, c) {
        a[b] = c.map(function(a) {
          var b = {};
          return e(a, b), b
        }).reduce(function(a, b) {
          return j(a, b)
        }, {})
      }

      function e(a, b) {
        var c;
        return Array.isArray(a) ? (c = a.shift(), "PARAMETER" === c && (c = a.shift()), 1 === a.length ? Array.isArray(a[0]) ? (b[c] = {}, e(a[0], b[c])) : b[c] = a[0] : a.length ? "TOWGS84" === c ? b[c] = a : (b[c] = {}, ["UNIT", "PRIMEM", "VERT_DATUM"].indexOf(c) > -1 ? (b[c] = {
          name: a[0].toLowerCase(),
          convert: a[1]
        }, 3 === a.length && (b[c].auth = a[2])) : "SPHEROID" === c ? (b[c] = {
          name: a[0],
          a: a[1],
          rf: a[2]
        }, 4 === a.length && (b[c].auth = a[3])) : ["GEOGCS", "GEOCCS", "DATUM", "VERT_CS", "COMPD_CS", "LOCAL_CS", "FITTED_CS", "LOCAL_DATUM"].indexOf(c) > -1 ? (a[0] = ["name", a[0]], d(b, c, a)) : a.every(function(a) {
          return Array.isArray(a)
        }) ? d(b, c, a) : e(a, b[c])) : b[c] = !0, void 0) : void(b[a] = !0)
      }

      function f(a, b) {
        var c = b[0],
          d = b[1];
        !(c in a) && d in a && (a[c] = a[d], 3 === b.length && (a[c] = b[2](a[c])))
      }

      function g(a) {
        return a * i
      }

      function h(a) {
        function b(b) {
          var c = a.to_meter || 1;
          return parseFloat(b, 10) * c
        }
        "GEOGCS" === a.type ? a.projName = "longlat" : "LOCAL_CS" === a.type ? (a.projName = "identity", a.local = !0) : "object" == typeof a.PROJECTION ? a.projName = Object.keys(a.PROJECTION)[0] : a.projName = a.PROJECTION, a.UNIT && (a.units = a.UNIT.name.toLowerCase(), "metre" === a.units && (a.units = "meter"),
          a.UNIT.convert && ("GEOGCS" === a.type ? a.DATUM && a.DATUM.SPHEROID && (a.to_meter = parseFloat(a.UNIT.convert, 10) * a.DATUM.SPHEROID.a) : a.to_meter = parseFloat(a.UNIT.convert, 10))), a.GEOGCS && (a.GEOGCS.DATUM ? a.datumCode = a.GEOGCS.DATUM.name.toLowerCase() : a.datumCode = a.GEOGCS.name.toLowerCase(), "d_" === a.datumCode.slice(0, 2) && (a.datumCode = a.datumCode.slice(2)), ("new_zealand_geodetic_datum_1949" === a.datumCode || "new_zealand_1949" === a.datumCode) && (a.datumCode = "nzgd49"), "wgs_1984" === a.datumCode && ("Mercator_Auxiliary_Sphere" === a.PROJECTION && (a.sphere = !0), a.datumCode = "wgs84"), "_ferro" === a.datumCode.slice(-6) && (a.datumCode = a.datumCode.slice(0, -6)), "_jakarta" === a.datumCode.slice(-8) && (a.datumCode = a.datumCode.slice(0, -8)), ~a.datumCode.indexOf("belge") && (a.datumCode = "rnb72"), a.GEOGCS.DATUM && a.GEOGCS.DATUM.SPHEROID && (a.ellps = a.GEOGCS.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === a.ellps.toLowerCase().slice(0, 13) && (a.ellps = "intl"), a.a = a.GEOGCS.DATUM.SPHEROID.a, a.rf = parseFloat(a.GEOGCS.DATUM.SPHEROID.rf, 10)), ~a.datumCode.indexOf("osgb_1936") && (a.datumCode = "osgb36")), a.b && !isFinite(a.b) && (a.b = a.a);
        var c = function(b) {
            return f(a, b)
          },
          d = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["false_easting", "False_Easting"],
            ["false_northing", "False_Northing"],
            ["central_meridian", "Central_Meridian"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", g],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longc", "longitude_of_center", g],
            ["x0", "false_easting", b],
            ["y0", "false_northing", b],
            ["long0", "central_meridian", g],
            ["lat0", "latitude_of_origin", g],
            ["lat0", "standard_parallel_1", g],
            ["lat1", "standard_parallel_1", g],
            ["lat2", "standard_parallel_2", g],
            ["alpha", "azimuth", g],
            ["srsCode", "name"]
          ];
        d.forEach(c), a.long0 || !a.longc || "Albers_Conic_Equal_Area" !== a.projName && "Lambert_Azimuthal_Equal_Area" !== a.projName || (a.long0 = a.longc), a.lat_ts || !a.lat1 || "Stereographic_South_Pole" !== a.projName && "Polar Stereographic (variant B)" !== a.projName || (a.lat0 = g(a.lat1 > 0 ? 90 : -90), a.lat_ts = a.lat1)
      }
      var i = .017453292519943295,
        j = a("./extend");
      b.exports = function(a, b) {
        var c = JSON.parse(("," + a).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, "")),
          d = c.shift(),
          f = c.shift();
        c.unshift(["name", f]), c.unshift(["type", d]), c.unshift("output");
        var g = {};
        return e(c, g), h(g.output), j(b, g.output)
      }
    }, {
      "./extend": 34
    }],
    67: [function(a, b, c) {
      function d(a) {
        return a * (Math.PI / 180)
      }

      function e(a) {
        return 180 * (a / Math.PI)
      }

      function f(a) {
        var b, c, e, f, g, i, j, k, l, m = a.lat,
          n = a.lon,
          o = 6378137,
          p = .00669438,
          q = .9996,
          r = d(m),
          s = d(n);
        l = Math.floor((n + 180) / 6) + 1, 180 === n && (l = 60), m >= 56 && 64 > m && n >= 3 && 12 > n && (l = 32), m >= 72 && 84 > m && (n >= 0 && 9 > n ? l = 31 : n >= 9 && 21 > n ? l = 33 : n >= 21 && 33 > n ? l = 35 : n >= 33 && 42 > n && (l = 37)), b = 6 * (l - 1) - 180 + 3, k = d(b), c = p / (1 - p), e = o / Math.sqrt(1 - p * Math.sin(r) * Math.sin(r)), f = Math.tan(r) * Math.tan(r), g = c * Math.cos(r) * Math.cos(r), i = Math.cos(r) * (s - k), j = o * ((1 - p / 4 - 3 * p * p / 64 - 5 * p * p * p / 256) * r - (3 * p / 8 + 3 * p * p / 32 + 45 * p * p * p / 1024) * Math.sin(2 * r) + (15 * p * p / 256 + 45 * p * p * p / 1024) * Math.sin(4 * r) - 35 * p * p * p / 3072 * Math.sin(6 * r));
        var t = q * e * (i + (1 - f + g) * i * i * i / 6 + (5 - 18 * f + f * f + 72 * g - 58 * c) * i * i * i * i * i / 120) + 5e5,
          u = q * (j + e * Math.tan(r) * (i * i / 2 + (5 - f + 9 * g + 4 * g * g) * i * i * i * i / 24 + (61 - 58 * f + f * f + 600 * g - 330 * c) * i * i * i * i * i * i / 720));
        return 0 > m && (u += 1e7), {
          northing: Math.round(u),
          easting: Math.round(t),
          zoneNumber: l,
          zoneLetter: h(m)
        }
      }

      function g(a) {
        var b = a.northing,
          c = a.easting,
          d = a.zoneLetter,
          f = a.zoneNumber;
        if (0 > f || f > 60) return null;
        var h, i, j, k, l, m, n, o, p, q, r = .9996,
          s = 6378137,
          t = .00669438,
          u = (1 - Math.sqrt(1 - t)) / (1 + Math.sqrt(1 - t)),
          v = c - 5e5,
          w = b;
        "N" > d && (w -= 1e7), o = 6 * (f - 1) - 180 + 3, h = t / (1 - t), n = w / r, p = n / (s * (1 - t / 4 - 3 * t * t / 64 - 5 * t * t * t / 256)), q = p + (3 * u / 2 - 27 * u * u * u / 32) * Math.sin(2 * p) + (21 * u * u / 16 - 55 * u * u * u * u / 32) * Math.sin(4 * p) + 151 * u * u * u / 96 * Math.sin(6 * p), i = s / Math.sqrt(1 - t * Math.sin(q) * Math.sin(q)), j = Math.tan(q) * Math.tan(q), k = h * Math.cos(q) * Math.cos(q), l = s * (1 - t) / Math.pow(1 - t * Math.sin(q) * Math.sin(q), 1.5), m = v / (i * r);
        var x = q - i * Math.tan(q) / l * (m * m / 2 - (5 + 3 * j + 10 * k - 4 * k * k - 9 * h) * m * m * m * m / 24 + (61 + 90 * j + 298 * k + 45 * j * j - 252 * h - 3 * k * k) * m * m * m * m * m * m / 720);
        x = e(x);
        var y = (m - (1 + 2 * j + k) * m * m * m / 6 + (5 - 2 * k + 28 * j - 3 * k * k + 8 * h + 24 * j * j) * m * m * m * m * m / 120) / Math.cos(q);
        y = o + e(y);
        var z;
        if (a.accuracy) {
          var A = g({
            northing: a.northing + a.accuracy,
            easting: a.easting + a.accuracy,
            zoneLetter: a.zoneLetter,
            zoneNumber: a.zoneNumber
          });
          z = {
            top: A.lat,
            right: A.lon,
            bottom: x,
            left: y
          }
        } else z = {
          lat: x,
          lon: y
        };
        return z
      }

      function h(a) {
        var b = "Z";
        return 84 >= a && a >= 72 ? b = "X" : 72 > a && a >= 64 ? b = "W" : 64 > a && a >= 56 ? b = "V" : 56 > a && a >= 48 ? b = "U" : 48 > a && a >= 40 ? b = "T" : 40 > a && a >= 32 ? b = "S" : 32 > a && a >= 24 ? b = "R" : 24 > a && a >= 16 ? b = "Q" : 16 > a && a >= 8 ? b = "P" : 8 > a && a >= 0 ? b = "N" : 0 > a && a >= -8 ? b = "M" : -8 > a && a >= -16 ? b = "L" : -16 > a && a >= -24 ? b = "K" : -24 > a && a >= -32 ? b = "J" : -32 > a && a >= -40 ? b = "H" : -40 > a && a >= -48 ? b = "G" : -48 > a && a >= -56 ? b = "F" : -56 > a && a >= -64 ? b = "E" : -64 > a && a >= -72 ? b = "D" : -72 > a && a >= -80 && (b = "C"), b
      }

      function i(a, b) {
        var c = "00000" + a.easting,
          d = "00000" + a.northing;
        return a.zoneNumber + a.zoneLetter + j(a.easting, a.northing, a.zoneNumber) + c.substr(c.length - 5, b) + d.substr(d.length - 5, b)
      }

      function j(a, b, c) {
        var d = k(c),
          e = Math.floor(a / 1e5),
          f = Math.floor(b / 1e5) % 20;
        return l(e, f, d)
      }

      function k(a) {
        var b = a % q;
        return 0 === b && (b = q), b
      }

      function l(a, b, c) {
        var d = c - 1,
          e = r.charCodeAt(d),
          f = s.charCodeAt(d),
          g = e + a - 1,
          h = f + b,
          i = !1;
        g > x && (g = g - x + t - 1, i = !0), (g === u || u > e && g > u || (g > u || u > e) && i) && g++, (g === v || v > e && g > v || (g > v || v > e) && i) && (g++, g === u && g++), g > x && (g = g - x + t - 1), h > w ? (h = h - w + t - 1, i = !0) : i = !1, (h === u || u > f && h > u || (h > u || u > f) && i) && h++, (h === v || v > f && h > v || (h > v || v > f) && i) && (h++, h === u && h++), h > w && (h = h - w + t - 1);
        var j = String.fromCharCode(g) + String.fromCharCode(h);
        return j
      }

      function m(a) {
        if (a && 0 === a.length) throw "MGRSPoint coverting from nothing";
        for (var b, c = a.length, d = null, e = "", f = 0; !/[A-Z]/.test(b = a.charAt(f));) {
          if (f >= 2) throw "MGRSPoint bad conversion from: " + a;
          e += b, f++
        }
        var g = parseInt(e, 10);
        if (0 === f || f + 3 > c) throw "MGRSPoint bad conversion from: " + a;
        var h = a.charAt(f++);
        if ("A" >= h || "B" === h || "Y" === h || h >= "Z" || "I" === h || "O" === h) throw "MGRSPoint zone letter " + h + " not handled: " + a;
        d = a.substring(f, f += 2);
        for (var i = k(g), j = n(d.charAt(0), i), l = o(d.charAt(1), i); l < p(h);) l += 2e6;
        var m = c - f;
        if (m % 2 !== 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + a;
        var q, r, s, t, u, v = m / 2,
          w = 0,
          x = 0;
        return v > 0 && (q = 1e5 / Math.pow(10, v), r = a.substring(f, f + v), w = parseFloat(r) * q, s = a.substring(f + v), x = parseFloat(s) * q), t = w + j, u = x + l, {
          easting: t,
          northing: u,
          zoneLetter: h,
          zoneNumber: g,
          accuracy: q
        }
      }

      function n(a, b) {
        for (var c = r.charCodeAt(b - 1), d = 1e5, e = !1; c !== a.charCodeAt(0);) {
          if (c++, c === u && c++, c === v && c++, c > x) {
            if (e) throw "Bad character: " + a;
            c = t, e = !0
          }
          d += 1e5
        }
        return d
      }

      function o(a, b) {
        if (a > "V") throw "MGRSPoint given invalid Northing " + a;
        for (var c = s.charCodeAt(b - 1), d = 0, e = !1; c !== a.charCodeAt(0);) {
          if (c++, c === u && c++, c === v && c++, c > w) {
            if (e) throw "Bad character: " + a;
            c = t, e = !0
          }
          d += 1e5
        }
        return d
      }

      function p(a) {
        var b;
        switch (a) {
          case "C":
            b = 11e5;
            break;
          case "D":
            b = 2e6;
            break;
          case "E":
            b = 28e5;
            break;
          case "F":
            b = 37e5;
            break;
          case "G":
            b = 46e5;
            break;
          case "H":
            b = 55e5;
            break;
          case "J":
            b = 64e5;
            break;
          case "K":
            b = 73e5;
            break;
          case "L":
            b = 82e5;
            break;
          case "M":
            b = 91e5;
            break;
          case "N":
            b = 0;
            break;
          case "P":
            b = 8e5;
            break;
          case "Q":
            b = 17e5;
            break;
          case "R":
            b = 26e5;
            break;
          case "S":
            b = 35e5;
            break;
          case "T":
            b = 44e5;
            break;
          case "U":
            b = 53e5;
            break;
          case "V":
            b = 62e5;
            break;
          case "W":
            b = 7e6;
            break;
          case "X":
            b = 79e5;
            break;
          default:
            b = -1
        }
        if (b >= 0) return b;
        throw "Invalid zone letter: " + a
      }
      var q = 6,
        r = "AJSAJS",
        s = "AFAFAF",
        t = 65,
        u = 73,
        v = 79,
        w = 86,
        x = 90;
      c.forward = function(a, b) {
        return b = b || 5, i(f({
          lat: a[1],
          lon: a[0]
        }), b)
      }, c.inverse = function(a) {
        var b = g(m(a.toUpperCase()));
        return b.lat && b.lon ? [b.lon, b.lat, b.lon, b.lat] : [b.left, b.bottom, b.right, b.top]
      }, c.toPoint = function(a) {
        var b = g(m(a.toUpperCase()));
        return b.lat && b.lon ? [b.lon, b.lat] : [(b.left + b.right) / 2, (b.top + b.bottom) / 2]
      }
    }, {}],
    68: [function(a, b, c) {
      b.exports = {
        name: "proj4",
        version: "2.3.12",
        description: "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
        main: "lib/index.js",
        directories: {
          test: "test",
          doc: "docs"
        },
        scripts: {
          test: "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
        },
        repository: {
          type: "git",
          url: "git://github.com/proj4js/proj4js.git"
        },
        author: "",
        license: "MIT",
        jam: {
          main: "dist/proj4.js",
          include: ["dist/proj4.js", "README.md", "AUTHORS", "LICENSE.md"]
        },
        devDependencies: {
          "grunt-cli": "~0.1.13",
          grunt: "~0.4.2",
          "grunt-contrib-connect": "~0.6.0",
          "grunt-contrib-jshint": "~0.8.0",
          chai: "~1.8.1",
          mocha: "~1.17.1",
          "grunt-mocha-phantomjs": "~0.4.0",
          browserify: "~3.24.5",
          "grunt-browserify": "~1.3.0",
          "grunt-contrib-uglify": "~0.3.2",
          curl: "git://github.com/cujojs/curl.git",
          istanbul: "~0.2.4",
          tin: "~0.4.0"
        },
        dependencies: {
          mgrs: "~0.0.2"
        }
      }
    }, {}],
    "./includedProjections": [function(a, b, c) {
      b.exports = a("hTEDpn")
    }, {}],
    hTEDpn: [function(a, b, c) {
      var d = [a("./lib/projections/tmerc"), a("./lib/projections/utm"), a("./lib/projections/sterea"), a("./lib/projections/stere"), a("./lib/projections/somerc"), a("./lib/projections/omerc"), a("./lib/projections/lcc"), a("./lib/projections/krovak"), a("./lib/projections/cass"), a("./lib/projections/laea"), a("./lib/projections/aea"), a("./lib/projections/gnom"), a("./lib/projections/cea"), a("./lib/projections/eqc"), a("./lib/projections/poly"), a("./lib/projections/nzmg"), a("./lib/projections/mill"), a("./lib/projections/sinu"), a("./lib/projections/moll"), a("./lib/projections/eqdc"), a("./lib/projections/vandg"), a("./lib/projections/aeqd")];
      b.exports = function(proj4) {
        d.forEach(function(a) {
          proj4.Proj.projections.add(a)
        })
      }
    }, {
      "./lib/projections/aea": 40,
      "./lib/projections/aeqd": 41,
      "./lib/projections/cass": 42,
      "./lib/projections/cea": 43,
      "./lib/projections/eqc": 44,
      "./lib/projections/eqdc": 45,
      "./lib/projections/gnom": 47,
      "./lib/projections/krovak": 48,
      "./lib/projections/laea": 49,
      "./lib/projections/lcc": 50,
      "./lib/projections/mill": 53,
      "./lib/projections/moll": 54,
      "./lib/projections/nzmg": 55,
      "./lib/projections/omerc": 56,
      "./lib/projections/poly": 57,
      "./lib/projections/sinu": 58,
      "./lib/projections/somerc": 59,
      "./lib/projections/stere": 60,
      "./lib/projections/sterea": 61,
      "./lib/projections/tmerc": 62,
      "./lib/projections/utm": 63,
      "./lib/projections/vandg": 64
    }]
  }, {}, [36])(36)
});;
(function(H) {
  "use strict";
  var isEdge = navigator.userAgent.indexOf('Edge/') > 0;
  var isMSIE11 = navigator.userAgent.indexOf('Trident/') > 0;
  var isMSBrowser = (window.isMSIE || isMSIE11 || isEdge);
  var plotOptions = H.getOptions().plotOptions;
  plotOptions.series = plotOptions.series || {};
  plotOptions.series.animation = !isMSBrowser;
  var legendOptions = H.getOptions().legend;
  legendOptions.symbolRadius = 0;
  H.SVGRenderer.prototype.getContrast = function(color) {
    color = H.Color(color).rgba;
    return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';
  };
  updateHighchartsWithMethodsFromVersion611(H);
}(Highcharts));

function updateHighchartsWithMethodsFromVersion611(Highcharts) {
  Highcharts.wrap(Highcharts.Axis.prototype, 'getPlotLinePath', function(proceed) {
    var path = proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    if (path) {
      path.flat = false;
    }
    return path;
  });
};
/*! RESOURCE: /scripts/reportcommon/hc_legend_extension.js */
(function extendHCLegend($, Highcharts) {
  var HIDDEN_SERIES = "hidden-series";
  Highcharts.wrap(Highcharts.Legend.prototype, 'init', function replaceDefaultLegendWithStatsTable(proceed, chart) {
    if (chart.options.legend.statsTable && chart.options.legend.statsTable.active)
      chart.options.legend.enabled = false;
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
    if (!chart.options.legend.statsTable || !chart.options.legend.statsTable.active)
      return;
    chart.options.legend.height = 100;
    var $container = $(chart.container);
    var maxLegendWidth = chart.options.legend.width ? chart.options.legend.width : chart.options.chart.width - 10;
    var tableWidth = maxLegendWidth - 25;
    var expanded = false;
    var $htmlLegend = $('<div><table style="border-spacing: 0 !important;">' +
        '<thead>' +
        '<tr>' +
        '<th class="number">' +
        '</th>' +
        '<th class="symbol">' +
        '</th>' +
        '<th class="series-name"></th>' +
        '<th class="controls"></th>' +
        '<th class="max">Max</th>' +
        '<th class="min">Min</th>' +
        '<th class="average">Avg</th>' +
        '<th class="total">Total</th>' +
        '</tr>' +
        '</thead>' +
        '<tbody></tbody>' +
        '</table></div>')
      .addClass("stats-table")
      .css("max-width", maxLegendWidth)
      .css("height", chart.options.legend.height)
      .find('table')
      .css("max-width", tableWidth >= 450 ? tableWidth : 450)
      .css("min-width", 450)
      .end();
    var series = chart.series;
    for (var i = series.length - 1; i >= 0; i--) {
      var serie = series[i];
      $('<tr>' +
          '<td class="number"></td>' +
          '<td class="symbol">' +
          '<div class="symbol"></div>' +
          '</td>' +
          '<td class="series-name"></td>' +
          '<td class="controls">' +
          '<button class="hide-others btn btn-default btn-xs">Hide Others</button>' +
          '<button class="hide-self btn btn-default btn-xs">Hide Self</button>' +
          '</td>' +
          '<td class="max">' +
          '</td>' +
          '<td class="min">' +
          '</td>' +
          '<td class="average">' +
          '</td>' +
          '<td class="total">' +
          '</td>' +
          '</tr>')
        .find('td.number')
        .text(series.length - i + '.')
        .end()
        .find('td.series-name')
        .text(serie.name)
        .each(returnGenerateLinkIfDefined(serie))
        .end()
        .find('div.symbol')
        .css('background-color', serie.color)
        .end()
        .find('button.hide-others')
        .on('click', returnHideOtherSeries(serie))
        .end()
        .find('button.hide-self')
        .on('click', returnHideSelf(serie))
        .end()
        .find('td.max')
        .text(serie.options.max)
        .end()
        .find('td.min')
        .text(serie.options.min)
        .end()
        .find('td.average')
        .text(serie.options.average.toFixed(2))
        .end()
        .find('td.total')
        .text(serie.options.total)
        .end()
        .find('td.max, td.min, td.average, td.total')
        .each(returnAppendUnitIfDefined(serie))
        .end()
        .hover(returnHighlightSeries(serie), returnUnhighlightSeries(serie))
        .appendTo($htmlLegend.find('tbody'));
    }
    $container.after($htmlLegend);
  });

  function returnHideSelf(serie) {
    return function hideSelf(event) {
      var $thisRow = $(this).closest('tr');
      event.stopPropagation();
      serie.setVisible();
      if (serie.visible)
        $thisRow.removeClass(HIDDEN_SERIES);
      else
        $thisRow.addClass(HIDDEN_SERIES);
    }
  }

  function returnHideOtherSeries(serie) {
    return function hideOtherSeries(event) {
      event.stopPropagation();
      var series = serie.chart.series;
      var $this = $(this);
      var $thisRow = $(this).closest('tr');
      var $allRows = $this.closest('table').find('tr');
      if (serie.onlyVisible) {
        serie.onlyVisible = false;
        for (var i = 0; i < series.length; i++)
          series[i].setVisible(true, false);
      } else {
        serie.onlyVisible = true;
        for (var i = 0; i < series.length; i++) {
          var possiblyOurSeries = series[i];
          if (possiblyOurSeries !== serie) {
            possiblyOurSeries.setVisible(false, false);
            possiblyOurSeries.onlyVisible = false;
          } else
            possiblyOurSeries.setVisible(true, false);
        }
      }
      serie.chart.redraw();
      if (serie.onlyVisible) {
        $thisRow.removeClass(HIDDEN_SERIES);
        $allRows.not($thisRow).addClass(HIDDEN_SERIES);
      } else
        $allRows.removeClass(HIDDEN_SERIES);
    };
  }

  function returnHighlightSeries(serie) {
    return function higlightSeries() {
      serie.setState("hover");
    };
  }

  function returnUnhighlightSeries(serie) {
    return function higlightSeries() {
      serie.setState("");
    };
  }

  function returnGenerateLinkIfDefined(serie) {
    return function generateLinkIfDefined() {
      if (serie.chart.options.legend.statsTable.seriesLinkGenerator) {
        $(this).wrapInner('<a href="' + serie.chart.options.legend.statsTable.seriesLinkGenerator(serie) + '"></a>');
      }
    };
  }

  function returnAppendUnitIfDefined(serie) {
    return function appendUnitIfDefined() {
      var $this = $(this);
      if (serie.chart.options.legend.statsTable.unit) {
        $this.text($this.text() + serie.chart.options.legend.statsTable.unit);
      }
    };
  }
})(jQuery, Highcharts);;
/*! RESOURCE: /scripts/reportcommon/hc_angular_chart_size_fix.js */
(function(H) {
  H.wrap(H.CenteredSeriesMixin, 'getCenter', function(p) {
    var chart = this.chart;
    var options = this.options;
    var maxSize;
    var center = p.apply(this, Array.prototype.slice.call(arguments, 1));
    if (options.startAngle === -90 && options.startAngle !== 90 && chart.series[0].angular) {
      if (chart.plotWidth > chart.plotHeight) {
        maxSize = chart.plotWidth > chart.plotHeight * 2 ? chart.plotHeight * 2 : chart.plotWidth;
        center[1] = H.relativeLength(options.center[1], maxSize);
        center[2] = H.relativeLength(options.size, maxSize);
      }
    }
    return center;
  });
})(Highcharts);;;